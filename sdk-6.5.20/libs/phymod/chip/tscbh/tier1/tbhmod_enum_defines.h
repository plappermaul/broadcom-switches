/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
/*----------------------------------------------------------------------
 * Broadcom Corporation
 * Proprietary and Confidential information
 * All rights reserved
 * This source file is the property of Broadcom Corporation, and
 * may not be copied or distributed in any isomorphic form without the
 * prior written consent of Broadcom Corporation.
 *---------------------------------------------------------------------
 ############### THIS FILE IS AUTOMATICALLY GENERATED.  ###############
 ############### DO !! NOT !! MANUALLY EDIT THIS FILE.  ###############
 *---------------------------------------------------------------------
 * Description: This file contains enums, elems and doxyten comments
 * needed for SerDes Configuration programs.
 *---------------------------------------------------------------------
 * CVS INFORMATION:
 * Please see inc/enum_desc.txt for CVS information.
 *----------------------------------------------------------------------
 */

/* This file is automatically generated. Do not modify it. Modify the
 * inc/enum_desc.txt to change enums, elems, or comments. For issues about
 * the process that creates this file contact the tbhmod development team.
 */

#ifndef _TSCBHMOD_ENUM_DEFINES_H
#define _TSCBHMOD_ENUM_DEFINES_H

/*! \enum tbhmod_lane_select_t 

tbhmod_lane_select_t selects for programming, any combination of 4 lanes of PHY.
A '1' in the latter part of the enum name selects the lane.  Other parameters
will decide what to do with the selected  lane(s). In most cases we
enable/disable a feature on the selected lanes

If lane_select is set to TBHMOD_LANE_BCST for writes we broadcast to all lanes.

Note that you cannot read in broadcast mode.

*/

typedef enum {
  TBHMOD_LANE_0_0_0_0        = 0   ,  /*!< No lane              selected   */
  TBHMOD_LANE_0_0_0_1              ,  /*!< lane number  0       selected   */
  TBHMOD_LANE_0_0_1_0              ,  /*!< lane number  1       selected   */
  TBHMOD_LANE_0_0_1_1              ,  /*!< lane numbers 0,1     selected   */
  TBHMOD_LANE_0_1_0_0              ,  /*!< lane number  2       selected   */
  TBHMOD_LANE_0_1_0_1              ,  /*!< lane numbers 2,0     selected   */
  TBHMOD_LANE_0_1_1_0              ,  /*!< lane numbers 2,1     selected   */
  TBHMOD_LANE_0_1_1_1              ,  /*!< lane numbers 2,1,0   selected   */
  TBHMOD_LANE_1_0_0_0              ,  /*!< lane number  3       selected   */
  TBHMOD_LANE_1_0_0_1              ,  /*!< lane numbers 3,0     selected   */
  TBHMOD_LANE_1_0_1_0              ,  /*!< lane numbers 3,1     selected   */
  TBHMOD_LANE_1_0_1_1              ,  /*!< lane numbers 3,1,0   selected   */
  TBHMOD_LANE_1_1_0_0              ,  /*!< lane numbers 3,2     selected   */
  TBHMOD_LANE_1_1_0_1              ,  /*!< lane numbers 3,2,0   selected   */
  TBHMOD_LANE_1_1_1_0              ,  /*!< lane numbers 3,2,1   selected   */
  TBHMOD_LANE_1_1_1_1              ,  /*!< lane numbers 3,2,1,0 selected   */
  TBHMOD_LANE_BCST                 ,  /*!< lane numbers 3,2,1,0 BCST       */
  TBHMOD_LANE_ILLEGAL                /*!< Illegal (programmatic boundary) */
} tbhmod_lane_select_t;

/*! \def CNT_tbhmod_lane_select_t Types of enum tbhmod_lane_select_t */
#define CNT_tbhmod_lane_select_t 18

/*!
\brief
This array returns the string version of the enum #tbhmod_lane_select_t when
indexed by the enum var.

*/
extern char* e2s_tbhmod_lane_select_t [CNT_tbhmod_lane_select_t];
/*!
\brief
This array associates the enum #tbhmod_lane_select_t enum with a bit mask.
The index is the #tbhmod_lane_select_t enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tbhmod_lane_select_t [CNT_tbhmod_lane_select_t];
/*! \enum tbhmod_spd_intfc_type_t 

All legal speed-interface combination are encapsulated in this enum

There are several speed and interface combinations allowed for a logical PHY
port. Names and speeds are self explanatory.

Speed and interface selection is combined because we don't want the speeds
to be incompatible with interface.

*/

typedef enum {

  TBHMOD_SPD_ZERO            = 0   ,  /*!< Illegal value (enum boundary)   */
  TBHMOD_SPD_10000_XFI             ,  /*!< 10Gb serial XFI                 */
  TBHMOD_SPD_20000_XFI             ,  /*!< 20Gb serial XFI                 */
  TBHMOD_SPD_25000_XFI             ,  /*!< 25Gb serial XFI                 */
  TBHMOD_SPD_40G_MLD_X2            ,  /*!< 40Gb serial XFI                 */
  TBHMOD_SPD_40G_MLD_X4            ,  /*!< 40Gb serial XFI                 */
  TBHMOD_SPD_50G_MLD_X2            ,  /*!< 50Gb serial XFI                 */
  TBHMOD_SPD_50G_MLD_FEC_528_X2    ,  /*!< 50Gb serial XFI FEC RS528       */
  TBHMOD_SPD_100G_MLD_X4           ,  /*!< 100Gb serial XFI FEC RS528      */
  TBHMOD_SPD_100G_MLD_NO_FEC_X4    ,  /*!< 100Gb serial XFI                */
  TBHMOD_SPD_CL73_20G              ,  /*!< 1G CL73 Auto-neg                */
  TBHMOD_SPD_CL73_25G              ,  /*!< 1G CL73 Auto-neg                */
  TBHMOD_SPD_CL73_26G              ,  /*!< 1G CL73 Auto-neg                */
  TBHMOD_SPD_200G_BRCM_NO_FEC_KR4_CR4            ,  /*!< 200G KR4/CR4                    */
  TBHMOD_SPD_200G_IEEE_FEC_544_2XN_KR4_CR4       ,  /*!< 200G KR4/CR4 IEEE FEC RS544 2xN */
  TBHMOD_SPD_200G_BRCM_FEC_544_1XN_KR4_CR4       ,  /*!< 200G KR4/CR4 BRCM FEC RS544 1xN */
  TBHMOD_SPD_50G_BRCM_NOFEC_KR1_CR1              ,  /*!< 50G KR1/CR1 BRCM                */
  TBHMOD_SPD_100G_BRCM_NOFEC_KR2_CR2             ,  /*!< 100G KR2/CR2 BRCM               */
  TBHMOD_SPD_50G_BRCM_FEC_544_CR2_KR2            ,  /*!< 50G KR2/CR2 BRCM FEC RS544 1xN  */
  TBHMOD_SPD_50G_IEEE_KR1_CR1                    ,  /*!< 50G KR1/CR1 IEEE FEC RS544 1xN  */
  TBHMOD_SPD_50G_BRCM_FEC_528_CR1_KR1            ,  /*!< 50G KR1/CR1 BRCM FEC RS528      */
  TBHMOD_SPD_100G_IEEE_KR2_CR2                   ,  /*!< 100G KR2/CR2 IEEE FEC RS544 2xN */
  TBHMOD_SPD_100G_BRCM_FEC_544_1XN_KR4_CR4       ,  /*!< 100G KR4/CR4 BRCM FEC RS544 1xN */
  TBHMOD_SPD_100G_BRCM_FEC_528_KR2_CR2           ,  /*!< 100G KR2/CR2 BRCM FEC RS528     */
  TBHMOD_SPD_400G_IEEE_FEC_544_2XN_X8            ,  /*!< 400G X8 IEEE FEC RS544 2xN  */
  TBHMOD_SPD_CUSTOM_ENTRY_56                     ,  /*!< Custom Entry at 56          */
  TBHMOD_SPD_CUSTOM_ENTRY_57                     ,  /*!< Custom Entry at 57          */
  TBHMOD_SPD_CUSTOM_ENTRY_58                     ,  /*!< Custom Entry at 58          */
  TBHMOD_SPD_CUSTOM_ENTRY_59                     ,  /*!< Custom Entry at 59          */
  TBHMOD_SPD_CUSTOM_ENTRY_60                     ,  /*!< Custom Entry at 60          */
  TBHMOD_SPD_CUSTOM_ENTRY_61                     ,  /*!< Custom Entry at 61          */
  TBHMOD_SPD_CUSTOM_ENTRY_62                     ,  /*!< Custom Entry at 62          */
  TBHMOD_SPD_CUSTOM_ENTRY_63                     ,  /*!< Custom Entry at 63          */
  TBHMOD_SPD_10G_FEC_BASE_R_KR1_CR1              ,  /*!< 10G XFI FEC BASE_R          */
  TBHMOD_SPD_20G_FEC_BASE_R_KR1_CR1              ,  /*!< 20G KR1/CR1 FEC BASE_R      */
  TBHMOD_SPD_25G_FEC_BASE_R_KR1_CR1              ,  /*!< 25G KR1/CR1 FEC BASE R      */
  TBHMOD_SPD_25G_FEC_RS_FEC_KR1_CR1              ,  /*!< 25G KR1/CR1 FEC RS528       */
  TBHMOD_SPD_40G_FEC_BASE_R_KR4_CR4              ,  /*!< 40G KR4/CR4 FEC BASE R      */
  TBHMOD_SPD_50G_BRCM_FEC_272_KR1_CR1            ,  /*!< 50G KR1/CR1 FEC RS272 1xN   */
  TBHMOD_SPD_100G_BRCM_FEC_272_KR2_CR2           ,  /*!< 100G KR2/CR2 FEC RS272 2xN  */
  TBHMOD_SPD_200G_BRCM_FEC_272_2XN_KR4_CR4       ,  /*!< 200G KR4/CR4 FEC RS272 2xN  */
  TBHMOD_SPD_200G_BRCM_FEC_272_1XN_KR4_CR4       ,  /*!< 200G KR4/CR4 FEC RS272 1xN  */
  TBHMOD_SPD_400G_BRCM_FEC_544_2XN_X8            ,  /*!< 400G BRCM X8 FEC RS544 2xN  */
  TBHMOD_SPD_400G_BRCM_FEC_272_2XN_X8            ,  /*!< 400G BRCM X8 FEC RS272 2xN  */
  TBHMOD_SPD_150G_FEC_544_2XN_N3                 ,  /*!< RLM 150G N3 FEC RS544 2xN   */
  TBHMOD_SPD_300G_FEC_544_2XN_N6                 ,  /*!< RLM 300G N6 FEC RS544 2xN   */
  TBHMOD_SPD_350G_FEC_544_2XN_N7                 ,  /*!< RLM 350G N7 FEC RS544 2xN   */
  TBHMOD_SPD_12P5G_BRCM_KR1                      ,  /*!< 12G KR1                     */
  TBHMOD_SPD_50G_BRCM_CR2_KR2_RS_FEC_FLEXE       ,  /*!< 50G KR2/CR2 BRCM FEC RS528 for FLEXE */
  TBHMOD_SPD_50G_BRCM_FEC_544_CR2_KR2_FLEXE      ,  /*!< 50G KR2/CR2 BRCM FEC RS544 1xN for FLEXE */
  TBHMOD_SPD_ILLEGAL                                /*!< Illegal value (enum boundary)*/
} tbhmod_spd_intfc_type_t;

/*! \def CNT_tbhmod_spd_intfc_type_t Types of enum tbhmod_spd_intfc_type_t */
#define CNT_tbhmod_spd_intfc_type_t 48


/*!
\brief
This array returns the string version of the enum #tbhmod_lane_select_t when
indexed by the enum var.

*/
extern char* e2s_tbhmod_spd_intfc_type_t [CNT_tbhmod_spd_intfc_type_t];
/*!
\brief
This array associates the enum #tbhmod_lane_select_t enum with a bit mask.
The index is the #tbhmod_lane_select_t enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tbhmod_spd_intfc_type_t [CNT_tbhmod_spd_intfc_type_t];
/*! \enum tbhmod_regacc_type_t 

MDIO access to PHY registers are no longer supported.

*/

typedef enum {
  TBHMOD_REGACC_CL22         = 0   ,  /*!< IEEE clause 22 based MDIO (for PMD only) */
  TBHMOD_REGACC_CL45               ,  /*!< IEEE clause 45 based MDIO (for PMD only) */
  TBHMOD_REGACC_TOTSC              ,  /*!< Mission mode */
  TBHMOD_REGACC_SBUS_FD            ,  /*!< Probably used in PM testbenches */
  TBHMOD_REGACC_SBUS_BD            ,  /*!< Probably used in PM testbenches */
  TBHMOD_REGACC_ILLEGAL              /*!< Illegal value (enum boundary) */
} tbhmod_regacc_type_t;

/*! \def CNT_tbhmod_regacc_type_t Types of enum tbhmod_regacc_type_t */
#define CNT_tbhmod_regacc_type_t 6

/*!
\brief
This array returns the string version of the enum #e2s_tbhmod_regacc_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_regacc_type_t [CNT_tbhmod_regacc_type_t];
/*! \enum tbhmod_port_type_t 

This is the port mode type enumeration.

WC can be configured in combo mode (i.e. entire WC is a single port) or
independent mode (i.e. WC has more than one port (2, 3, or 4) that are
controlled individually.

*/

typedef enum {
  TBHMOD_MULTI_PORT          = 0   ,  /*!< Each channel is one logical port */
  TBHMOD_TRI1_PORT                 ,  /*!< 3 ports, one of them paird as follows (0,1,2-3) */
  TBHMOD_TRI2_PORT                 ,  /*!< 3 ports, one of them paird as follows (0-1,2,3) */
  TBHMOD_DXGXS                     ,  /*!< Each paired channel(0-1, 2-3) is one logical port */
  TBHMOD_SINGLE_PORT               ,  /*!< single port mode: 4 channels as one logical port */
  TBHMOD_SINGLE_OCTAL_PORT         ,  /*!< single port mode: 8 channels as one logical port */
  TBHMOD_PORT_MODE_ILLEGAL           /*!< Illegal value (enum boundary) */
} tbhmod_port_type_t;

/*! \def CNT_tbhmod_port_type_t Types of enum tbhmod_port_type_t */
#define CNT_tbhmod_port_type_t 7

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_port_type_t [CNT_tbhmod_port_type_t];
/*! \enum tbhmod_sc_mode_type_t 

This is the sc mode type enumeration.



*/

typedef enum {
  TBHMOD_SC_MODE_HT_WITH_BASIC_OVERRIDE = 0   ,  /*!< TBHMOD_SC_MODE_HT_WITH_BASIC_OVERRIDE */
  TBHMOD_SC_MODE_HT_OVERRIDE       ,  /*!< TBHMOD_SC_MODE_ST_OVERRIDE */
  TBHMOD_SC_MODE_ST                ,  /*!< TBHMOD_SC_MODE_ST */
  TBHMOD_SC_MODE_ST_OVERRIDE       ,  /*!< TBHMOD_SC_MODE_ST */
  TBHMOD_SC_MODE_AN_CL37           ,  /*!< TBHMOD_SC_MODE_AN_CL73 */
  TBHMOD_SC_MODE_AN_CL73           ,  /*!< TBHMOD_SC_MODE_AN_CL73 */
  TBHMOD_SC_MODE_BYPASS            ,  /*!< TBHMOD_SC_MODE_BYPASS */
  TBHMOD_SC_MODE_ILLEGAL             /*!< Illegal value (enum boundary) */
} tbhmod_sc_mode_type_t;

/*! \def CNT_tbhmod_sc_mode_type_t Types of enum tbhmod_sc_mode_type_t */
#define CNT_tbhmod_sc_mode_type_t 8

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_sc_mode_type_t [CNT_tbhmod_sc_mode_type_t];
/*! \enum tbhmod_diag_type_t 

tbhmod_diag_type_t enumerates categories of diagnostic data.
has many intermediate stages between down and up. This enum is work in progress


<table cellspacing=0>
<tr><td colspan=3><B>'per_lane_control' bit-mappings</B></td></tr>

<tr><td><B>Type</B></td><td><B>Description</B></td><td><B>Scope</B></td></tr>

<tr><td>General</td>
<td> Combo/independent, Device and Revision Id, VCO settings, Firmware state
and version, active/passive lanes, MDIO type. PLL info, Oversampling Info</td>
<td>Device</td></tr>

<tr><td>Link</td>
<td> Speeds, oversampling, interface, forced/Autoneg, link status, sync
status, RX sequencer on/off </td>
<td>Lane</td></tr>

<tr><td>Autoneg</td>
<td> Local and remote advertisement, link status, cl73/37/BAM info </td>
<td>Lane</td></tr>

<tr><td>Internal Traffic</td>
<td> PRBS type, CJPat Type, Prog_data value, Any associated recorded errors,
and misc. info (IPG etc.)</td>
<td>Lane </td></tr>

<tr>
<td>DFE</td>
<td>Equalization info, Tap settings. (pre/post/overrides), peaking filter values </td>
<td>Lane</td></tr>

<tr><td>IEEE info</td>
<td>Clause 72, FEC</td>
<td>Lane</td></tr>

<tr><td>Topology</td>
<td>Looping info (Gloop/rloop), lane swapping, polarity swap info</td>
<td>Device</td></tr>

<tr><td>EEE</td>
<td>EEE full, passthru modes, some window values?</td>
<td>Lane</td></tr>

<tr><td>Eye Margin</td>
<td>Eye margin measurement (readout only)</td>
<td>Lane</td></tr>

<tr><td>All</td>
<td>All of the above. Except eye margin.</td>
<td>Device</td></tr>

</table>


*/

typedef enum {
  TBHMOD_DIAG_GENERAL        = 0x00000001 ,  /*!< General device wide information.         */
  TBHMOD_DIAG_TOPOLOGY       = 0x00000002 ,  /*!< Loopbacks etc.                           */
  TBHMOD_DIAG_LINK           = 0x00000004 ,  /*!< Link specific info.                      */
  TBHMOD_DIAG_SPEED          = 0x00000008 ,  /*!< sub-category of TBHMOD_DIAG_LINK(for SDK) */
  TBHMOD_DIAG_ANEG           = 0x00000010 ,  /*!< Autoneg specific info.                   */
  TBHMOD_DIAG_TFC            = 0x00000020 ,  /*!< State of tx/rx internal tfc              */
  TBHMOD_DIAG_AN_TIMERS      = 0x00000040 ,  /*!< AN timers */
  TBHMOD_DIAG_STATE          = 0x00000080 ,  /*!< Debug state registers */
  TBHMOD_DIAG_DEBUG          = 0x00000100 ,  /*!< Debug */
  TBHMOD_DIAG_IEEE           = 0x00000200 ,  /*!< IEEE related info                        */
  TBHMOD_DIAG_EEE            = 0x00000400 ,  /*!< EEE                                      */
  TBHMOD_SERDES_DIAG         = 0x00000800 ,  /*!< PMD Triage */
  TBHMOD_DIAG_ALL            = 0x00000fff ,  /*!< Everything but eye margin                */
  TBHMOD_DIAG_ILLEGAL        = 0x00000000   /*!< Illegal value. programmatic boundary.    */
} tbhmod_diag_type_t;

/*! \def CNT_tbhmod_diag_type_t Types of enum tbhmod_diag_type_t */
#define CNT_tbhmod_diag_type_t 14

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_diag_type_t [CNT_tbhmod_diag_type_t];
/*! \enum tbhmod_model_type_t 

tbhmod_model_type_t enumerates different generations and  revisions of PHY.
Note that we pretty much only look at different versions of PHY.

We rely on all the information being in the SERDES_ID register.


*/

typedef enum {
  TBHMOD_WC                  = 0   ,  /*!< Generic PHY (any model) */
  TBHMOD_WC_A0                     ,  /*!< PHY Version A0 */
  TBHMOD_WC_A1                     ,  /*!< PHY Version A1 */
  TBHMOD_WC_A2                     ,  /*!< PHY Version A2 */
  TBHMOD_WC_B0                     ,  /*!< PHY Version B0 */
  TBHMOD_WC_B1                     ,  /*!< PHY Version B1 */
  TBHMOD_WC_B2                     ,  /*!< PHY Version B2 */
  TBHMOD_WC_C0                     ,  /*!< PHY Version C0, model no. differs from other WCs */
  TBHMOD_WC_C1                     ,  /*!< PHY Version C1, model no. differs from other WCs */
  TBHMOD_WC_C2                     ,  /*!< PHY Version C2, model no. differs from other WCs */
  TBHMOD_WC_D0                     ,  /*!< PHY Version D0 */
  TBHMOD_WC_D1                     ,  /*!< PHY Version D1 */
  TBHMOD_WC_D2                     ,  /*!< PHY Version D2 */
  TBHMOD_XN                        ,  /*!< Generic Xenia Core (any model) */
  TBHMOD_WL                        ,  /*!< Generic PHY Lite (any model) */
  TBHMOD_WL_A0                     ,  /*!< WarpLite Core */
  TBHMOD_QS                        ,  /*!< Generic QSGMII core (any model) */
  TBHMOD_QS_A0                     ,  /*!< QSGMII core Version A0 */
  TBHMOD_QS_B0                     ,  /*!< QSGMII core Version B0 */
  TBHMOD_MODEL_TYPE_ILLEGAL          /*!< Illegal value. programmatic boundary. */
} tbhmod_model_type_t;

/*! \def CNT_tbhmod_model_type_t Types of enum tbhmod_model_type_t */
#define CNT_tbhmod_model_type_t 20

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_model_type_t [CNT_tbhmod_model_type_t];

/*! \def CNT_tbhmod_an_type_t Types of enum tbhmod_an_type_t */
#define CNT_tbhmod_an_type_t 7

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_an_type_t [CNT_tbhmod_an_type_t];
/*! \enum tbhmod_eye_direction_t 

The direction of slicer changing always moves from the middle of the eye.
Currently all speeds have the following bit positions.


\li TBHMOD_EYE_VU: Vertical,   Upward direction
\li TBHMOD_EYE_VD: Vertical,   Downward direction
\li TBHMOD_EYE_HL: Horizontal, Left  direction
\li TBHMOD_EYE_HR: Horizontal, Right direction


*/

typedef enum {
  TBHMOD_EYE_VU              = 0   ,  /*!< Vertical,   Upward direction */
  TBHMOD_EYE_VD                    ,  /*!< Vertical,   Downward direction */
  TBHMOD_EYE_HL                    ,  /*!< Horizontal, Left  direction */
  TBHMOD_EYE_HR                    ,  /*!< Horizontal, Right direction */
  TBHMOD_EYE_ILLEGAL                 /*!< Programmatic illegal boundary. */
} tbhmod_eye_direction_t;

/*! \def CNT_tbhmod_eye_direction_t Types of enum tbhmod_eye_direction_t */
#define CNT_tbhmod_eye_direction_t 5

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_eye_direction_t [CNT_tbhmod_eye_direction_t];

/*! \enum tbhmod_ieee_tech_ability_t 

tbhmod_ieee_tech_ability_t enumerates different types of speed advertisements in the
basic autoneg page. Currently for CL73 only.

Currently all speeds have the following bit positions in tbhmod_st

\li TBHMOD_IEEE_ABILITY_1G               Bit Pos: 0
\li TBHMOD_IEEE_ABILITY_10G_KX4           Bit Pos: 1
\li TBHMOD_IEEE_ABILITY_10G_KR           Bit Pos: 1
\li TBHMOD_IEEE_ABILITY_40G_KR4          Bit Pos: 2
\li TBHMOD_IEEE_ABILITY_40G_CR4          Bit Pos: 3
\li TBHMOD_IEEE_ABILITY_100G_CR10        Bit Pos: 4
\li TBHMOD_IEEE_ABILITY_100G_KP4         Bit Pos: 7 
\li TBHMOD_IEEE_ABILITY_100G_KR4         Bit Pos: 5 
\li TBHMOD_IEEE_ABILITY_100G_CR4         Bit Pos: 7 
\li TBHMOD_IEEE_ABILITY_25G_KS1_CS1      Bit Pos: 9 
\li TBHMOD_IEEE_ABILITY_25G_KR1_CR1      Bit Pos: 10 


*/

typedef enum {
  TBHMOD_IEEE_ABILITY_1G     = 0   ,  /*!< please write comments        */
  TBHMOD_IEEE_ABILITY_10G_KX4       ,  /*!< please write comments        */
  TBHMOD_IEEE_ABILITY_10G_KR       ,  /*!< please write comments        */
  TBHMOD_IEEE_ABILITY_40G_KR4       ,  /*!< please write comments        */
  TBHMOD_IEEE_ABILITY_40G_CR4       ,  /*!< please write comments        */
  TBHMOD_IEEE_ABILITY_100G_CR10       ,  /*!< please write comments        */
  TBHMOD_IEEE_ABILITY_100G_KP4       ,  /*!< please write comments        */
   TBHMOD_IEEE_ABILITY_100G_KR4       ,  /*!< please write comments        */
  TBHMOD_IEEE_ABILITY_100G_CR4       ,  /*!< please write comments        */
  TBHMOD_IEEE_ABILITY_25G_KS1_CS1       ,  /*!< please write comments        */
  TBHMOD_IEEE_ABILITY_25G_KR1_CR1         /*!< please write comments        */
} tbhmod_ieee_tech_ability_t;

/*! \def CNT_tbhmod_ieee_tech_ability_t Types of enum tbhmod_ieee_tech_ability_t */
#define CNT_tbhmod_ieee_tech_ability_t 9

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_ieee_tech_ability_t [CNT_tbhmod_ieee_tech_ability_t];
/*!
\brief
This array associates the enum #tbhmod_lane_select_t enum with a bit mask.
The index is the #tbhmod_lane_select_t enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tbhmod_ieee_tech_ability_t [CNT_tbhmod_ieee_tech_ability_t];
/*! \enum tbhmod_cl73_bam_up1_tech_ability0_t 

tbhmod_cl73_bam_up1_tech_ability0_t enumerates different types of speed advertisements in the
bam up1 ability0 autoneg page

Currently all speeds have the following bit positions in tbhmod_st

\li TBHMOD_BAM_UP0_ABILITY0_20G_KR2               Bit Pos: 0
\li TBHMOD_BAM_UP0_ABILITY0_20G_CR2               Bit Pos: 1
\li TBHMOD_BAM_UP0_ABILITY0_40G_KR2               Bit Pos: 2
\li TBHMOD_BAM_UP0_ABILITY0_40G_CR2               Bit Pos: 3
\li TBHMOD_BAM_UP0_ABILITY0_400G_FEC_KR8_CR8      Bit Pos: 4
\li TBHMOD_BAM_UP0_ABILITY0_400G_NO_FEC_KR8_CR8   Bit Pos: 5 
\li TBHMOD_BAM_UP0_ABILITY0_50G_KR2               Bit Pos: 6 
\li TBHMOD_BAM_UP0_ABILITY0_50G_CR2               Bit Pos: 7 
\li TBHMOD_BAM_UP0_ABILITY0_50G_KR4               Bit Pos: 8 
\li TBHMOD_BAM_UP0_ABILITY0_50G_CR4               Bit Pos: 9 
\li TBHMOD_BAM_UP0_ABILITY0_50G_FEC_528_CR1_KR1   Bit Pos: 10
\li TBHMOD_BAM_UP0_ABILITY0_50G_NO_FEC_CR1_KR1    Bit Pos: 11
\li TBHMOD_BAM_UP0_ABILITY0_50G_FEC_544_CR1_KR1   Bit Pos: 12
\li TBHMOD_BAM_UP0_ABILITY0_RSVD_22               Bit Pos: 13
\li TBHMOD_BAM_UP0_ABILITY0_RSVD_19               Bit Pos: 14
\li TBHMOD_BAM_UP0_ABILITY0_50G_FEC_544_CR2_KR2   Bit Pos: 15


*/

typedef enum {
  TBHMOD_BAM_UP0_ABILITY0_20G_KR2 = 0   ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_20G_CR2       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_40G_KR2       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_40G_CR2       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_400G_FEC_KR8_CR8       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_400G_NO_FEC_KR8_CR8       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_50G_KR2       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_50G_CR2       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_50G_KR4       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_50G_CR4       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_50G_FEC_528_CR1_KR1       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_50G_NO_FEC_CR1_KR1       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_50G_FEC_544_CR1_KR1       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_RSVD_22       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_RSVD_19       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY0_50G_FEC_544_CR2_KR2         /*!< please write comments        */
} tbhmod_cl73_bam_up1_tech_ability0_t;

/*! \def CNT_tbhmod_cl73_bam_up1_tech_ability0_t Types of enum tbhmod_cl73_bam_up1_tech_ability0_t */
#define CNT_tbhmod_cl73_bam_up1_tech_ability0_t 16

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_cl73_bam_up1_tech_ability0_t [CNT_tbhmod_cl73_bam_up1_tech_ability0_t];
/*!
\brief
This array associates the enum #tbhmod_lane_select_t enum with a bit mask.
The index is the #tbhmod_lane_select_t enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tbhmod_cl73_bam_up1_tech_ability0_t [CNT_tbhmod_cl73_bam_up1_tech_ability0_t];
/*! \enum tbhmod_cl73_bam_up1_tech_ability1_t 

tbhmod_cl73_bam_up1_tech_ability1_t enumerates different types of speed advertisements in the
bam up1 ability0 autoneg page

Currently all speeds have the following bit positions in tbhmod_st

\li TBHMOD_BAM_UP0_ABILITY1_RSVD                  Bit Pos: 0
\li TBHMOD_BAM_UP0_ABILITY1_20G_KR1               Bit Pos: 1
\li TBHMOD_BAM_UP0_ABILITY1_20G_CR1               Bit Pos: 2
\li TBHMOD_BAM_UP0_ABILITY1_25G_KR1               Bit Pos: 3
\li TBHMOD_BAM_UP0_ABILITY1_25G_CR1               Bit Pos: 4
\li TBHMOD_BAM_UP0_ABILITY1_100G_NO_FEC_X4        Bit Pos: 5
\li TBHMOD_BAM_UP0_ABILITY1_100G_NO_FEC_KR2_CR2   Bit Pos: 6
\li TBHMOD_BAM_UP0_ABILITY1_100G_FEC_528_KR2_CR2  Bit Pos: 7
\li TBHMOD_BAM_UP0_ABILITY1_100G_KR4_CR4          Bit Pos: 8
\li TBHMOD_BAM_UP0_ABILITY1_200G_KR4_CR4          Bit Pos: 9
\li TBHMOD_BAM_UP0_ABILITY1_200G_NO_FEC_KR4_CR4   Bit Pos: 10
\li TBHMOD_BAM_UP0_ABILITY1_RSVD_11               Bit Pos: 11
\li TBHMOD_BAM_UP0_ABILITY1_RS_FEC_REQ            Bit Pos: 12
\li TBHMOD_BAM_UP0_ABILITY1_RS_FEC_REQ_DUMMY      Bit Pos: 13
\li TBHMOD_BAM_UP0_ABILITY1_CL74C_REQ             Bit Pos: 14
\li TBHMOD_BAM_UP0_ABILITY1_CL74C_REQ_DUMMY       Bit Pos: 15


*/

typedef enum {
  TBHMOD_BAM_UP0_ABILITY1_RSVD = 0   ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_20G_KR1       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_20G_CR1       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_25G_KR1       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_25G_CR1       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_100G_NO_FEC_X4       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_100G_NO_FEC_KR2_CR2       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_100G_FEC_528_KR2_CR2       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_100G_KR4_CR4       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_200G_KR4_CR4       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_200G_NO_FEC_KR4_CR4       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_RSVD_11       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_RS_FEC_REQ       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_RS_FEC_REQ_DUMMY       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_CL74C_REQ       ,  /*!< please write comments        */
  TBHMOD_BAM_UP0_ABILITY1_CL74C_REQ_DUMMY         /*!< please write comments        */
} tbhmod_cl73_bam_up1_tech_ability1_t;

/*! \def CNT_tbhmod_cl73_bam_up1_tech_ability1_t Types of enum tbhmod_cl73_bam_up1_tech_ability1_t */
#define CNT_tbhmod_cl73_bam_up1_tech_ability1_t 16

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_cl73_bam_up1_tech_ability1_t [CNT_tbhmod_cl73_bam_up1_tech_ability1_t];
/*!
\brief
This array associates the enum #tbhmod_lane_select_t enum with a bit mask.
The index is the #tbhmod_lane_select_t enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tbhmod_cl73_bam_up1_tech_ability1_t [CNT_tbhmod_cl73_bam_up1_tech_ability1_t];
/*! \enum tbhmod_tech_ability_t 

tbhmod_tech_ability_t enumerates different types of speed advertisements in the
basic autoneg page. Currently for CL73 only.

Currently all speeds have the following bit positions in tbhmod_st

\li TBHMOD_ABILITY_1G               Bit Pos: 0
\li TBHMOD_ABILITY_10G_KR           Bit Pos: 1
\li TBHMOD_ABILITY_40G_KR4          Bit Pos: 2
\li TBHMOD_ABILITY_40G_CR4          Bit Pos: 3
\li TBHMOD_ABILITY_100G_CR10        Bit Pos: 4
\li TBHMOD_ABILITY_10G_HIGIG        Bit Pos: 5
\li TBHMOD_ABILITY_10G_CX4          Bit Pos: 6
\li TBHMOD_ABILITY_20G_X4           Bit Pos: 7
\li TBHMOD_ABILITY_40G              Bit Pos: 8
\li TBHMOD_ABILITY_25P455G          Bit Pos: 9
\li TBHMOD_ABILITY_21G_X4           Bit Pos: 10
\li TBHMOD_ABILITY_20G_X4S          Bit Pos: 11
\li TBHMOD_ABILITY_10G_DXGXS_HIGIG  Bit Pos: 12
\li TBHMOD_ABILITY_10G_DXGXS        Bit Pos: 13
\li TBHMOD_ABILITY_10P5G_DXGXS      Bit Pos: 14
\li TBHMOD_ABILITY_12P5_DXGXS       Bit Pos: 15
\li TBHMOD_ABILITY_20G_KR2_HIGIG    Bit Pos: 16
\li TBHMOD_ABILITY_20G_KR2          Bit Pos: 17
\li TBHMOD_ABILITY_20G_CR2          Bit Pos: 18
\li TBHMOD_ABILITY_15P75G_R2        Bit Pos: 19
\li TBHMOD_ABILITY_100G_KR4         Bit Pos: 20 
\li TBHMOD_ABILITY_100G_CR4         Bit Pos: 21 
\li TBHMOD_ABILITY_40G_KR2          Bit Pos: 22 
\li TBHMOD_ABILITY_40G_CR2          Bit Pos: 23 
\li TBHMOD_ABILITY_50G_KR2          Bit Pos: 24 
\li TBHMOD_ABILITY_50G_CR2          Bit Pos: 25 
\li TBHMOD_ABILITY_50G_KR4          Bit Pos: 26 
\li TBHMOD_ABILITY_50G_CR4          Bit Pos: 27 
\li TBHMOD_ABILITY_20G_KR1          Bit Pos: 28 
\li TBHMOD_ABILITY_20G_CR1          Bit Pos: 29 
\li TBHMOD_ABILITY_25G_KR1          Bit Pos: 30 
\li TBHMOD_ABILITY_25G_CR1          Bit Pos: 31 


*/

typedef enum {
  TBHMOD_ABILITY_1G          = 0   ,  /*!< please write comments        */
  TBHMOD_ABILITY_10G_KR            ,  /*!< please write comments        */
  TBHMOD_ABILITY_40G_KR4           ,  /*!< please write comments        */
  TBHMOD_ABILITY_40G_CR4           ,  /*!< please write comments        */
  TBHMOD_ABILITY_100G_CR10         ,  /*!< please write comments        */
  TBHMOD_ABILITY_10G_HIGIG         ,  /*!< please write comments        */
  TBHMOD_ABILITY_10G_CX4           ,  /*!< please write comments        */
  TBHMOD_ABILITY_20G_X4            ,  /*!< please write comments        */
  TBHMOD_ABILITY_40G               ,  /*!< please write comments        */
  TBHMOD_ABILITY_25P455G           ,  /*!< please write comments        */
  TBHMOD_ABILITY_21G_X4            ,  /*!< please write comments        */
  TBHMOD_ABILITY_20G_X4S           ,  /*!< XAUI 8b10b scrambled data    */
  TBHMOD_ABILITY_10G_DXGXS_HIGIG       ,  /*!< please write comments        */
  TBHMOD_ABILITY_10G_DXGXS         ,  /*!< please write comments        */
  TBHMOD_ABILITY_10P5G_DXGXS       ,  /*!< please write comments        */
  TBHMOD_ABILITY_12P5_DXGXS        ,  /*!< please write comments        */
  TBHMOD_ABILITY_20G_KR2_HIGIG       ,  /*!< please write comments        */
  TBHMOD_ABILITY_20G_KR2           ,  /*!< please write comments        */
  TBHMOD_ABILITY_20G_CR2           ,  /*!< please write comments        */
  TBHMOD_ABILITY_15P75G_R2         ,  /*!< please write comments        */
  TBHMOD_ABILITY_100G_KR4          ,  /*!< please write comments        */
  TBHMOD_ABILITY_100G_CR4          ,  /*!< please write comments        */
  TBHMOD_ABILITY_40G_KR2           ,  /*!< please write comments        */
  TBHMOD_ABILITY_40G_CR2           ,  /*!< please write comments        */
  TBHMOD_ABILITY_50G_KR2           ,  /*!< please write comments        */
  TBHMOD_ABILITY_50G_CR2           ,  /*!< please write comments        */
  TBHMOD_ABILITY_50G_KR4           ,  /*!< please write comments        */
  TBHMOD_ABILITY_50G_CR4           ,  /*!< please write comments        */
  TBHMOD_ABILITY_20G_KR1           ,  /*!< please write comments        */
  TBHMOD_ABILITY_20G_CR1           ,  /*!< please write comments        */
  TBHMOD_ABILITY_25G_KR1           ,  /*!< please write comments        */
  TBHMOD_ABILITY_25G_CR1           ,  /*!< please write comments        */
  TBHMOD_ABILITY_ILLEGAL             /*!< Illegal. Programmatic boundary */
} tbhmod_tech_ability_t;

/*! \def CNT_tbhmod_tech_ability_t Types of enum tbhmod_tech_ability_t */
#define CNT_tbhmod_tech_ability_t 33

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_tech_ability_t [CNT_tbhmod_tech_ability_t];
/*!
\brief
This array associates the enum #tbhmod_lane_select_t enum with a bit mask.
The index is the #tbhmod_lane_select_t enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tbhmod_tech_ability_t [CNT_tbhmod_tech_ability_t];
/*! \enum tbhmod_cl37bam_ability_t 

This array associates the enum #tbhmod_lane_select_t enum with a bit mask.
The index is the #tbhmod_lane_select_t enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  Enabled implies the function under
consideration be enebled for the lane. Disabled means the opposite.  So a value
of 0xF indicates that all lanes or enabled, while 0x5 indicates that only lanes
0 and 2 are enabled.

tbhmod_cl37bam_ability_t enumerates different types of speed advertisements in the
basic autoneg page for CL37BAM only.

Currently all speeds have the following bit positions in tbhmod_st

\li TBHMOD_BAM37ABL_2P5G             Bit Pos: 0
\li TBHMOD_BAM37ABL_5G_X4            Bit Pos: 1
\li TBHMOD_BAM37ABL_6G_X4            Bit Pos: 2
\li TBHMOD_BAM37ABL_10G_HIGIG        Bit Pos: 3
\li TBHMOD_BAM37ABL_10G_CX4          Bit Pos: 4
\li TBHMOD_BAM37ABL_12G_X4           Bit Pos: 5
\li TBHMOD_BAM37ABL_12P5_X4          Bit Pos: 6
\li TBHMOD_BAM37ABL_13G_X4           Bit Pos: 7
\li TBHMOD_BAM37ABL_15G_X4           Bit Pos: 8
\li TBHMOD_BAM37ABL_16G_X4           Bit Pos: 9
\li TBHMOD_BAM37ABL_20G_X4_CX4       Bit Pos: 10
\li TBHMOD_BAM37ABL_20G_X4           Bit Pos: 11
\li TBHMOD_BAM37ABL_21G_X4           Bit Pos: 12
\li TBHMOD_BAM37ABL_25P455G          Bit Pos: 13
\li TBHMOD_BAM37ABL_31P5G            Bit Pos: 14
\li TBHMOD_BAM37ABL_32P7G            Bit Pos: 15
\li TBHMOD_BAM37ABL_40G              Bit Pos: 16
\li TBHMOD_BAM37ABL_10G_X2_CX4       Bit Pos: 17
\li TBHMOD_BAM37ABL_10G_DXGXS        Bit Pos: 18
\li TBHMOD_BAM37ABL_10P5G_DXGXS      Bit Pos: 19
\li TBHMOD_BAM37ABL_12P7_DXGXS       Bit Pos: 20
\li TBHMOD_BAM37ABL_15P75G_R2        Bit Pos: 21
\li TBHMOD_BAM37ABL_20G_X2_CX4       Bit Pos: 22
\li TBHMOD_BAM37ABL_20G_X2           Bit Pos: 23


*/

typedef enum {
  TBHMOD_BAM37ABL_2P5G       = 0   ,  /*!< X1 BRCM */
  TBHMOD_BAM37ABL_5G_X4            ,  /*!< BRCM */
  TBHMOD_BAM37ABL_6G_X4            ,  /*!< BRCM */
  TBHMOD_BAM37ABL_10G_HIGIG        ,  /*!< HG (10G_X4) */
  TBHMOD_BAM37ABL_10G_CX4          ,  /*!< (10G_X4_CX4) */
  TBHMOD_BAM37ABL_12G_X4           ,  /*!< HG */
  TBHMOD_BAM37ABL_12P5_X4          ,  /*!< HG */
  TBHMOD_BAM37ABL_13G_X4           ,  /*!< HG */
  TBHMOD_BAM37ABL_15G_X4           ,  /*!< HG */
  TBHMOD_BAM37ABL_16G_X4           ,  /*!< HG */
  TBHMOD_BAM37ABL_20G_X4_CX4       ,  /*!< XAUI 8b10b scram(20G_X4S) */
  TBHMOD_BAM37ABL_20G_X4           ,  /*!< HG */
  TBHMOD_BAM37ABL_21G_X4           ,  /*!< HG */
  TBHMOD_BAM37ABL_25P455G          ,  /*!< X4 HG */
  TBHMOD_BAM37ABL_31P5G            ,  /*!< X4 HG */
  TBHMOD_BAM37ABL_32P7G            ,  /*!< X4 HG */
  TBHMOD_BAM37ABL_40G              ,  /*!< X4 BRCM HG (40G_X4) */
  TBHMOD_BAM37ABL_10G_X2_CX4       ,  /*!< 10G_X2_CX4 */
  TBHMOD_BAM37ABL_10G_DXGXS        ,  /*!< 10G_X2 */
  TBHMOD_BAM37ABL_10P5G_DXGXS       ,  /*!< 10P5_X2 */
  TBHMOD_BAM37ABL_12P7_DXGXS       ,  /*!< 12P7_X2 */
  TBHMOD_BAM37ABL_15P75G_R2        ,  /*!< 15P75_X2 */
  TBHMOD_BAM37ABL_20G_X2_CX4       ,  /*!< 20G_X2_CX4 */
  TBHMOD_BAM37ABL_20G_X2           ,  /*!< 20G_X2 */
  TBHMOD_BAM37ABL_ILLEGAL            /*!< Illegal. Programmatic boundary */
} tbhmod_cl37bam_ability_t;

/*! \def CNT_tbhmod_cl37bam_ability_t Types of enum tbhmod_cl37bam_ability_t */
#define CNT_tbhmod_cl37bam_ability_t 25

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_cl37bam_ability_t [CNT_tbhmod_cl37bam_ability_t];
/*! \enum tbhmod_diag_an_type_t 

This array associates the enum #tbhmod_lane_select_t enum with a bit mask.
The index is the #tbhmod_lane_select_t enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/

typedef enum {
  TBHMOD_DIAG_AN_DONE        = 0   ,  /*!< AN completion check */
  TBHMOD_DIAG_AN_HCD               ,  /*!< AN HCD speed check */
  TBHMOD_DIAG_AN_TYPE_ILLEGAL         /*!< Illegal value. programmatic boundary */
} tbhmod_diag_an_type_t;

/*! \def CNT_tbhmod_diag_an_type_t Types of enum tbhmod_diag_an_type_t */
#define CNT_tbhmod_diag_an_type_t 3

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_diag_an_type_t [CNT_tbhmod_diag_an_type_t];
/*! \enum tbhmod_tier1_function_type_t 

This array associates the enum #tbhmod_lane_select_t enum with a bit mask.
The index is the #tbhmod_lane_select_t enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/

typedef enum {
  PCS_BYPASS_CTL             = 0   ,  /*!< tbhmod_pcs_bypass_ctl */
  AFE_SPEED_UP_DSC_VGA             ,  /*!< tbhmod_afe_speed_up_dsc_vga */
  TX_LANE_DISABLE                  ,  /*!< tbhmod_tx_lane_disable */
  RX_LOCK_OVRD                     ,  /*!< tbhmod_rx_lock_ovrd */
  RX_SIGDET_OVRD                   ,  /*!< tbhmod_rx_sigdet_ovrd */
  POWER_CONTROL                    ,  /*!< tbhmod_power_control */
  AUTONEG_SET                      ,  /*!< tbhmod_autoneg_set */
  AUTONEG_GET                      ,  /*!< tbhmod_autoneg_get */
  AUTONEG_CONTROL                  ,  /*!< tbhmod_autoneg_control */
  SW_AN_CONTROL                    ,  /*!< tbhmod_sw_an_control */
  AUTONEG_PAGE_SET                 ,  /*!< tbhmod_autoneg_page_set */
  REG_READ                         ,  /*!< tbhmod_reg_read */
  REG_WRITE                        ,  /*!< tbhmod_reg_write */
  PRBS_CHECK                       ,  /*!< tbhmod_prbs_check */
  TBHMOD_DIAG                      ,  /*!< tbhmod_diag */
  PARALLEL_DETECT_CONTROL          ,  /*!< tbhmod_parallel_detect_control */
  CLAUSE_72_CONTROL                ,  /*!< tbhmod_clause72_control */
  PLL_SEQUENCER_CONTROL            ,  /*!< tbhmod_pll_sequencer_control */
  PLL_LOCK_WAIT                    ,  /*!< tbhmod_pll_lock_wait */
  REVID_READ                       ,  /*!< tbhmod_revid_read */
  SET_AN_PORT_MODE                 ,  /*!< tbhmod_set_an_port_mode */
  PRBS_CONTROL                     ,  /*!< tbhmod_prbs_control */
  PRBS_MODE                        ,  /*!< tbhmod_prbs_mode */
  SOFT_RESET                       ,  /*!< tbhmod_soft_reset */
  TX_PMD_LOOPBACK_CONTROL          ,  /*!< tbhmod_tx_pmd_loopback_control */
  CORE_RESET                       ,  /*!< tbhmod_core_reset */
  REFCLK_SET                       ,  /*!< tbhmod_refclk_set */
  WAIT_PMD_LOCK                    ,  /*!< tbhmod_wait_pmd_lock */
  FIRMWARE_SET                     ,  /*!< tbhmod_firmware_set */
  INIT_PCS_BLACKHAWK                  ,  /*!< tbhmod_init_pcs_balckhawk */
  DISABLE_PCS_BLACKHAWK               ,  /*!< tbhmod_disable_pcs_blackhawk */
  INIT_PMD_BLACKHAWK                  ,  /*!< tbhmod_init_pmd_falcon */
  INIT_CORE_PMD_BLACKHAWK             ,  /*!< tbhmod_init_pmd_falcon */
  PMD_LANE_SWAP_TX                 ,  /*!< tbhmod_pmd_lane_swap_tx */
  PMD_LANE_SWAP                    ,  /*!< tbhmod_pmd_lane_swap */
  PCS_RX_LANE_SWAP                 ,  /*!< tbhmod_pcs_rx_lane_swap */
  PCS_TX_LANE_SWAP                 ,  /*!< tbhmod_pcs_tx_lane_swap */
  CHECK_SC_STATS                   ,  /*!< tbhmod_check_status */
  PMD_RESET_REMOVE                 ,  /*!< tbhmod_pmd_reset_remove */
  PMD_CLOCK_GATE                   ,  /*!< tbhmod_pmd_clock_gate */
  PMD_LANE_RESET_BYPASS            ,  /*!< tbhmod_pmd_lane_reset_bypass */
  INIT_PCS_ILKN                    ,  /*!< tbhmod_init_pcs_ilkn */
  PCS_SET_ILKN_WM                  ,  /*!< tbhmod_pcs_set_ilkn_wm */
  SW_AN_LD_PAGE_LOAD               ,  /*!< tbhmod_sw_an_ld_page_load */
  SW_AN_LP_PAGE_READ               ,  /*!< tbhmod_sw_an_lp_page_read */
  SW_AN_SET_ACK                    ,  /*!< tbhmod_sw_an_set_ack */
  PMD_TX_SETUP                     ,  /*!< tbhmod_pmd_tx_setup  */
  PMD_RX_SETUP                     ,  /*!< tbhmod_pmd_rx_setup  */
  READ_AN_GOOD_CHK_INT             ,  /*!< tbhmod_an_good_chk_int_get  */
  READ_SW_AN_INT                   ,  /*!< tbhmod_sw_an_int_get  */
  READ_SW_AN_GLB_INT               ,  /*!< tbhmod_get_sw_mgmt_glb_int  */
  READ_SW_AN_CTL_STS               ,  /*!< tbhmod_sw_an_ctl_sts_get  */
  AN_RESTART                       ,  /*!< tbhmod_autoneg_restart */
  PCS_RX_TS_EN                     ,  /*!< tbhmod_pcs_rx_ts_en */
  PCS_SET_1588_UI                  ,  /*!< tbhmod_pcs_set_1588_ui */
  PCS_MOD_RX_1588_TBL              ,  /*!< tbhmod_pcs_mod_rx_1588_tbl */
  PCS_TS_DESKEW_VALID              ,  /*!< tbhmod_pcs_ts_deskew_valid */
  PCS_SET_1588_XGMII               ,  /*!< tbhmod_pcs_set_1588_xgmii */
  PMD_TX_LN_DP_S_RSTB              ,  /*!< tbhmod_pmd_tx_ln_dp_s_rstb */
  PMD_RX_LN_DP_S_RSTB              ,  /*!< tbhmod_pmd_rx_ln_dp_s_rstb */
  PMD_RXTX_LN_DP_S_RSTB            ,  /*!< tbhmod_pmd_rxtx_ln_dp_s_rstb */
  SET_SW_AN_SPEED                    ,  /*!< tbhmod_pcs_set_sw_an_speed */
  TIER1_FUNCTION_ILLEGAL             /*!< illegal */
} tbhmod_tier1_function_type_t;

/*! \def CNT_tbhmod_tier1_function_type_t Types of enum tbhmod_tier1_function_type_t */
#define CNT_tbhmod_tier1_function_type_t 100

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_tier1_function_type_t [CNT_tbhmod_tier1_function_type_t];
/*! \enum tbhmod_fec_en_parm_t 

For passing parameters to tbhmod_FEC_control.

*/

typedef enum {
  TBHMOD_CL91_TX_EN_DIS      = 0x01 ,  /*!< Enable / Disable CL91 TX */
  TBHMOD_CL91_RX_EN_DIS      = 0x02 ,  /*!< Enable / Disable CL91 RX */
  TBHMOD_CL91_IND_ONLY_EN_DIS = 0x04 ,  /*!< Enable / Disable CL91 indication only */
  TBHMOD_CL91_COR_ONLY_EN_DIS = 0x08 ,  /*!< Enable / Disable CL91 correction only */
  TBHMOD_CL74_TX_EN_DIS      = 0x10 ,  /*!< Enable / Disable CL74 TX */
  TBHMOD_CL74_RX_EN_DIS      = 0x20 ,  /*!< Enable / Disable CL74 RX */
  TBHMOD_CL74_CL91_EN_DIS    = 0x40   /*!< Enable / Disable CL74CL91 for autoneg */
} tbhmod_fec_en_parm_t;

/*! \def CNT_tbhmod_fec_en_parm_t Types of enum tbhmod_fec_en_parm_t */
#define CNT_tbhmod_fec_en_parm_t 7

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_fec_en_parm_t [CNT_tbhmod_fec_en_parm_t];
/*! \enum tbhmod_tx_disable_enum_t 

For various tx disable condition use this enum.

*/

typedef enum {
  TBHMOD_TX_LANE_RESET       = 0x20 ,  /*!< TX lane Reset */
  TBHMOD_TX_LANE_TRAFFIC_ENABLE = 0x1 ,  /*!< TX lane Traffic enable */
  TBHMOD_TX_LANE_TRAFFIC_DISABLE = 0x2 ,  /*!< TX lane Traffic disable */
  TBHMOD_TX_LANE_RESET_TRAFFIC_ENABLE = 0x3 ,  /*!< TX lane Reset/Traffic enable */
  TBHMOD_TX_LANE_RESET_TRAFFIC_DISABLE = 0x4 ,  /*!< TX lane Reset/Traffic disable */
  TBHMOD_TX_LANE_ILLEGAL     = 0x5   /*!< TX lane Illegal */
} tbhmod_tx_disable_enum_t;

/*! \def CNT_tbhmod_tx_disable_enum_t Types of enum tbhmod_tx_disable_enum_t */
#define CNT_tbhmod_tx_disable_enum_t 6

/*!
\brief
This array returns the string version of the enum #tbhmod_port_type_t when indexed
by the enum var.

*/
extern char* e2s_tbhmod_tx_disable_enum_t [CNT_tbhmod_tx_disable_enum_t];
/*! \enum tbhmod_os_mode_type 


The oversampling mode means that bits are sent out more than once to reduce
the effective frequency of data transfer. For example you can send 5G bits
over a 10G bit lane by sending every bit twice, or OS=2. When the OS is 3.3
it's a bit tricky, we send bits 3 or 4 times in a pattern like so
3,3,3,4,3,3,3,4,... Similarly for OS = 8, we send 8,8,8,9,8,8,8,9,...


*/

typedef enum {
  TBHMOD_PMA_OS_MODE_1       = 0   ,  /*!< Over sampling Mode 1         */
  TBHMOD_PMA_OS_MODE_2       = 1   ,  /*!< Over sampling Mode 2         */
  TBHMOD_PMA_OS_MODE_4       = 2   ,  /*!< Over sampling Mode 4         */
  TBHMOD_PMA_OS_MODE_16_25   = 8   ,  /*!< Over sampling Mode 8.25      */
  TBHMOD_PMA_OS_MODE_20_625  = 12  ,  /*!< Over sampling Mode 10        */
  TBHMOD_PMA_OS_MODE_ILLEGAL = 15    /*!< Over sampling Mode Illegal   */
} tbhmod_os_mode_type;

/*! \def CNT_tbhmod_os_mode_type Types of enum tbhmod_os_mode_type */
#define CNT_tbhmod_os_mode_type 6

/*!
\brief
This array returns the string of #tbhmod_os_mode type when indexed by the enum.

*/
extern char* e2s_tbhmod_os_mode_type [CNT_tbhmod_os_mode_type];
/*!
\brief
This array returns the over sampling value of #tbhmod_os_mode type when indexed by
the enum. For floating values 3.3 and 8.25 it returns 33 and 825.

*/
extern int e2n_tbhmod_os_mode_type [CNT_tbhmod_os_mode_type];
/*! \enum tbhmod_scr_mode 

This mode indicates how many bits of a 'frame' will be scrambled. We have either
66 or 80 bits per frame (depending on 8b10b or 64b66b encoding). Normally
scrambling is

\li bypassed for baud rates under 6.25G (0).
\li we scramble all 66 bits (1)
\li all 80 bits(2)
\li only 64 of the 66b (3). i.e we don't scramble the 'sync' bits.

*/

typedef enum {
  TBHMOD_SCR_MODE_BYPASS     = 0   ,  /*!< Scrambling Mode bypassed      */
  TBHMOD_SCR_MODE_CL49       = 1   ,  /*!< Scrambling Mode 66B           */
  TBHMOD_SCR_MODE_40G_2_LANE = 2   ,  /*!< Scrambling Mode 80B           */
  TBHMOD_SCR_MODE_100G       = 3   ,  /*!< Scrambling Mode 64B           */
  TBHMOD_SCR_MODE_20G        = 4   ,  /*!< Scrambling Mode 64B           */
  TBHMOD_SCR_MODE_40G_4_LANE = 5   ,  /*!< Scrambling Mode 64B           */
  TBHMOD_SCR_MODE_ILLEGAL    = 15    /*!< SCR Mode Mode Illegal   */
} tbhmod_scr_mode;

/*! \def CNT_tbhmod_scr_mode Types of enum tbhmod_scr_mode */
#define CNT_tbhmod_scr_mode 7

/*!
\brief
This array returns the string of #tbhmod_scr_mode when indexed by the enum.

*/
extern char* e2s_tbhmod_scr_mode [CNT_tbhmod_scr_mode];
/*!
\brief
This array returns the scrambling mode of #tbhmod_scr_mode when indexed by
the enum.

*/
extern int e2n_tbhmod_scr_mode [CNT_tbhmod_scr_mode];
/*! \enum tbhmod_encode_mode 

Serial bits are encoded when transmitted. The encoding depends on the baud rate
and the link type
\li 000 All encoding functions disabled for lane
\li 001 8b10b  (cl48 )
\li 010 8b10b  (cl48 rxaui)
\li 011 8b10b  (cl36 )
\li 100 64b66b (cl82 )
\li 101 64b66b (cl49 )
\li 110 64b66b (brcm )

*/

typedef enum {
  TBHMOD_ENCODE_MODE_NONE    = 0   ,  /*!< Encoding Mode NONE     */
  TBHMOD_ENCODE_MODE_CL49    = 1   ,  /*!< Encoding Mode CL49     */
  TBHMOD_ENCODE_MODE_CL82    = 2   ,  /*!< Encoding Mode CL82     */
  TBHMOD_ENCODE_MODE_ILLEGAL = 15    /*!< Encoding Mode Illegal  */
} tbhmod_encode_mode;

/*! \def CNT_tbhmod_encode_mode Types of enum tbhmod_encode_mode */
#define CNT_tbhmod_encode_mode 4

/*!
\brief
This array returns the string of #tbhmod_encode_mode when indexed by the enum.

*/
extern char* e2s_tbhmod_encode_mode [CNT_tbhmod_encode_mode];
/*!
\brief
This array returns the encoding mode of #tbhmod_encode_mode when indexed by
the enum.

*/
extern int e2n_tbhmod_encode_mode [CNT_tbhmod_encode_mode];
/*! \enum tbhmod_descrambler_mode 

The descrambling must match the scrambling done at the transmitting port.

*/

typedef enum {
  TBHMOD_R_DESCR_MODE_BYPASS = 0   ,  /*!< No descrambling */
  TBHMOD_R_DESCR_MODE_CL49   = 1   ,  /*!< CL49 */
  TBHMOD_R_DESCR_MODE_CL82   = 2   ,  /*!< CL82 */
  TBHMOD_R_DESCR_MODE_ILLEGAL = 3     /*!< Illegal */
} tbhmod_descrambler_mode;

/*! \def CNT_tbhmod_descrambler_mode Types of enum tbhmod_descrambler_mode */
#define CNT_tbhmod_descrambler_mode 4

/*!
\brief
This array returns the string of #tbhmod_descrambler_mode when indexed by the enum.

*/
extern char* e2s_tbhmod_descrambler_mode [CNT_tbhmod_descrambler_mode];
/*! \enum tbhmod_dec_tl_mode 

The descrambling must match the scrambling done at the transmitting port.

*/

typedef enum {
  TBHMOD_DEC_TL_MODE_NONE    = 0   ,  /*!< decoder mode NONE */
  TBHMOD_DEC_TL_MODE_CL49    = 1   ,  /*!< decoder mode CL49 */
  TBHMOD_DEC_TL_MODE_CL82    = 2   ,  /*!< decoder mode CL82 */
  TBHMOD_DEC_TL_MODE_ILLEGAL = 7     /*!< decoder mode ILLEGAL */
} tbhmod_dec_tl_mode;

/*! \def CNT_tbhmod_dec_tl_mode Types of enum tbhmod_dec_tl_mode */
#define CNT_tbhmod_dec_tl_mode 4

/*!
\brief
This array returns the string of #tbhmod_dec_tl_mode when indexed by the enum.

*/
extern char* e2s_tbhmod_dec_tl_mode [CNT_tbhmod_dec_tl_mode];
/*! \enum tbhmod_dec_fsm_mode 

The descrambling must match the scrambling done at the transmitting port.

*/

typedef enum {
  TBHMOD_DEC_FSM_MODE_NONE   = 0   ,  /*!< decoder mode NONE */
  TBHMOD_DEC_FSM_MODE_CL49   = 1   ,  /*!< decoder mode CL49 */
  TBHMOD_DEC_FSM_MODE_CL82   = 2   ,  /*!< decoder mode CL82 */
  TBHMOD_DEC_FSM_MODE_ILLEGAL = 7     /*!< decoder mode ILLEGAL */
} tbhmod_dec_fsm_mode;

/*! \def CNT_tbhmod_dec_fsm_mode Types of enum tbhmod_dec_fsm_mode */
#define CNT_tbhmod_dec_fsm_mode 4

/*!
\brief
This array returns the string of #tbhmod_dec_fsm_mode when indexed by the enum.

*/
extern char* e2s_tbhmod_dec_fsm_mode [CNT_tbhmod_dec_fsm_mode];
/*! \enum tbhmod_deskew_mode 

Deskew Mode is a function of speed.

*/

typedef enum {
  TBHMOD_R_DESKEW_MODE_BYPASSi = 0   ,  /*!< deskew mode BYPASS */
  TBHMOD_R_DESKEW_MODE_10G   = 1   ,  /*!< deskew mode 10G */
  TBHMOD_R_DESKEW_MODE_40G_4_LANE = 2   ,  /*!< deskew mode 40G_4_LANE */
  TBHMOD_R_DESKEW_MODE_40G_2_LANE = 3   ,  /*!< deskew mode 40G_2_LANE */
  TBHMOD_R_DESKEW_MODE_100G  = 4   ,  /*!< deskew mode 100G */
  TBHMOD_R_DESKEW_MODE_CL49  = 5   ,  /*!< deskew mode CL49 */
  TBHMOD_R_DESKEW_MODE_CL91  = 6   ,  /*!< deskew mode CL91 */
  TBHMOD_R_DESKEW_MODE_ILLEGAL = 7     /*!< deskew mode ILLEGAL */
} tbhmod_deskew_mode;

/*! \def CNT_tbhmod_deskew_mode Types of enum tbhmod_deskew_mode */
#define CNT_tbhmod_deskew_mode 8

/*!
\brief
This array returns the string of #tbhmod_deskew_mode when indexed by the enum.

*/
extern char* e2s_tbhmod_deskew_mode [CNT_tbhmod_deskew_mode];
/*! \enum tbhmod_t_fifo_mode 


*/

typedef enum {
  TBHMOD_T_FIFO_MODE_NONE    = 0   ,  /*!< t_fifo mode NONE */
  TBHMOD_T_FIFO_MODE_40G     = 1   ,  /*!< t_fifo mode 40G */
  TBHMOD_T_FIFO_MODE_100G    = 2   ,  /*!< t_fifo mode 100G */
  TBHMOD_T_FIFO_MODE_20G     = 3   ,  /*!< t_fifo mode 20G */
  TBHMOD_T_FIFO_MODE_ILLEGAL = 7     /*!< t_fifo mode ILLEGAL */
} tbhmod_t_fifo_mode;

/*! \def CNT_tbhmod_t_fifo_mode Types of enum tbhmod_t_fifo_mode */
#define CNT_tbhmod_t_fifo_mode 5

/*!
\brief
This array returns the string of #tbhmod_t_fifo_mode when indexed by the enum.

*/
extern char* e2s_tbhmod_t_fifo_mode [CNT_tbhmod_t_fifo_mode];
/*! \enum tbhmod_bs_btmx_mode 


*/

typedef enum {
  TBHMOD_BS_BTMX_MODE_NONE   = 0   ,  /*!< bs_btmx mode NONE */
  TBHMOD_BS_BTMX_MODE_1to1   = 1   ,  /*!< bs_btmx mode 1to1 */
  TBHMOD_BS_BTMX_MODE_2to1   = 2   ,  /*!< bs_btmx mode 2to1 */
  TBHMOD_BS_BTMX_MODE_5to1   = 3   ,  /*!< bs_btmx mode 5to1 */
  TBHMOD_BS_BTMX_MODE_ILLEGAL = 7     /*!< bs_btmx mode ILLEGAL */
} tbhmod_bs_btmx_mode;

/*! \def CNT_tbhmod_bs_btmx_mode Types of enum tbhmod_bs_btmx_mode */
#define CNT_tbhmod_bs_btmx_mode 5

/*!
\brief
This array returns the string of #tbhmod_bs_btmx_mode when indexed by the enum.

*/
extern char* e2s_tbhmod_bs_btmx_mode [CNT_tbhmod_bs_btmx_mode];
/*! \enum tbhmod_bs_dist_mode 


*/

typedef enum {
  TBHMOD_BS_DIST_MODE_5_LANE_TDM = 0   ,  /*!< bs_dist mode 5LN_TDM */
  TBHMOD_BS_DIST_MODE_2_LANE_TDM_2_VLANE = 1   ,  /*!< bs_dist mode 2LN_TDM_2VLN */
  TBHMOD_BS_DIST_MODE_2_LANE_TDM_1_VLANE = 2   ,  /*!< bs_dist mode 2LN_TDM_1VLN */
  TBHMOD_BS_DIST_MODE_NO_TDM = 3   ,  /*!< bs_dist mode NO_TDM */
  TBHMOD_BS_DIST_MODE_ILLEGAL = 7     /*!< bs_dist mode ILLEGAL */
} tbhmod_bs_dist_mode;

/*! \def CNT_tbhmod_bs_dist_mode Types of enum tbhmod_bs_dist_mode */
#define CNT_tbhmod_bs_dist_mode 5

/*!
\brief
This array returns the string of #tbhmod_bs_dist_mode when indexed by the enum.

*/
extern char* e2s_tbhmod_bs_dist_mode [CNT_tbhmod_bs_dist_mode];
/*! \enum tbhmod_an_property_enable 


*/

typedef enum {
  TBHMOD_AN_PROPERTY_ENABLE_NONE = 0   ,  /*!< an_enabled_none mode 5LN_TDM */
  TBHMOD_AN_PROPERTY_ENABLE_HPAM_TO_CL73_AUTO = 1   ,  /*!< an_enabled_hpam_to_cl73_auto */
  TBHMOD_AN_PROPERTY_ENABLE_CL73_BAM_TO_HPAM_AUTO = 2   ,  /*!< an_enabled_cl73_bam_to_hpam_auto */
  TBHMOD_AN_PROPERTY_ENABLE_ILLEGAL = 4     /*!< bs_dist mode NO_TDM */
} tbhmod_an_property_enable;

/*! \def CNT_tbhmod_an_property_enable Types of enum tbhmod_an_property_enable */
#define CNT_tbhmod_an_property_enable 4

/*!
\brief
This array returns the string of #an_property_enable when indexed by the enum.

*/
extern char* e2s_tbhmod_an_property_enable [CNT_tbhmod_an_property_enable];

typedef enum {
/* Temp fix for VCO enum change UC */
  TSC_VCO_6PT25     = 0,
  TSC_VCO_20PT6250  = 1,
  TSC_VCO_21PT8750  = 2,
  TSC_VCO_25PT78125 = 3,
  TSC_VCO_27PT34375 = 4,
  TSC_VCO_28PT05    = 5,
  TSC_VCO_26PT56250 = 6
} tsc_vco_rate_e;

typedef enum {
    TBHMOD_PLL_MODE_DIV_ZERO = 0, /* Divide value to be determined by API. */
    TBHMOD_PLL_MODE_DIV_66         =          (int)0x00000042, /* Divide by 66        */
    TBHMOD_PLL_MODE_DIV_80         =          (int)0x00000050, /* Divide by 80        */
    TBHMOD_PLL_MODE_DIV_82P5       =          (int)0x80000052, /* Divide by 82.5      */
    TBHMOD_PLL_MODE_DIV_85         =          (int)0x00000055, /* Divide by 85        */
    TBHMOD_PLL_MODE_DIV_132        =          (int)0x00000084, /* Divide by 132       */
    TBHMOD_PLL_MODE_DIV_160        =          (int)0x000000A0, /* Divide by 160       */
    TBHMOD_PLL_MODE_DIV_165        =          (int)0x000000A5, /* Divide by 165       */
    TBHMOD_PLL_MODE_DIV_170        =          (int)0x000000AA  /* Divide by 170       */
} tbhmod_pll_mode_type;
#endif /* _TSCBHMOD_ENUM_DEFINES_H */
