/*! \file bcm56780_a0_sec_init.c
 *
 * File containing device level init sequence for bcm56780_a0.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bsl/bsl.h>
#include <shr/shr_debug.h>
#include <sal/sal_sleep.h>
#include <bcmdrd/bcmdrd_port.h>
#include <bcmdrd/bcmdrd_types.h>
#include <bcmdrd/bcmdrd_feature.h>
#include <bcmdrd/bcmdrd_dev.h>
#include <bcmsec/bcmsec_types.h>
#include <bcmsec/generated/bcmsec_ha.h>
#include <bcmsec/bcmsec_drv.h>
#include <bcmsec/bcmsec_utils.h>
#include <bcmpc/bcmpc_sec.h>
#include <bcmpc/bcmpc_types.h>
#include <bcmsec/chip/bcm56780_a0_sec.h>
#include <bcmsec/chip/bcm56780_a0_sec_port.h>
#include <bcmdrd/chip/bcm56780_a0_defs.h>
#include <bcmbd/chip/bcm56780_a0_acc.h>
#include <bcmdrd/bcmdrd_feature.h>
#include <bcmsec/bcmsec_utils_internal.h>
#include <bcmsec/bcmsec_pt_internal.h>
#include <bcmsec/chip/bcm56780_a0_sec_port.h>
#include <shr/shr_timeout.h>
#include "bcm56780_a0_sec_interrupt.h"

#define EMULATION_FACTOR            10000
#define SEC_ODF_USEC_MAX            (500)
#define SEC_EMUL_ODF_USEC_MAX       (500 * EMULATION_FACTOR)
#define NUM_SEC_PORTS_PER_PC_PM     (16)

/*******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE  BSL_LS_BCMSEC_CHIP

typedef struct sec_port_ops_s {
    /*! Port add */
    int port_add;

    /*! Port delete */
    int port_delete;
} sec_port_ops_t;

/*******************************************************************************
 * Private functions.
 */


/*!
 * \brief SEC driver_info populate function
 *
 * Write all available chip specific info to the SEC dev_info structure.
 * The chip specific information will be retrieved during chip init and config.
 *
 * \param [in] unit Logical unit number.
 * \param [in] warm Warm boot.
 *
 * \retval SHR_E_NONE No error.
 * \retval Returns error code for error.
 */
static int
bcm56780_a0_sec_dev_info_populate(int unit, bool warm)
{
    SHR_FUNC_ENTER(unit);

    /* Initialize dev_info struct. */
    bcmsec_dev_info_portmap_reset(unit);

    SHR_FUNC_EXIT();
}

/*!
 * \brief Function to fill dev_info structure
 *
 * Retrieve all information contained in bcmpc_sec_port_cfg_t and fill it into
 * the field in sec_dev_info. The bcmpc_sec_port_cfg_t is
 * generated by BCMPC and contains all the necessary port config info.
 *
 * \param [in] unit Logical unit number.
 * \param [in] num_ports Number of ports.
 * \param [in] old_cfg Old port configurations.
 * \param [in] new_cfg New port configurations.
 *
 * \retval SHR_E_NONE No error.
 * \retval Return error code in case of error.
 */
static int
bcm56780_a0_sec_dev_info_portmap_fill(int unit,
                                     size_t num_ports,
                                     const bcmpc_sec_port_cfg_t *old_cfg,
                                     const bcmpc_sec_port_cfg_t *new_cfg)
{
    int pport, lport;
    bcmsec_pport_info_t *pport_info, *pinfo;
    bcmsec_lport_info_t *lport_info, *linfo;

    bcmpc_sec_port_cfg_t port_cfg_data;
    bcmpc_sec_port_cfg_t *port_cfg;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmsec_pport_info_get(unit, &pport_info));
    SHR_IF_ERR_EXIT
        (bcmsec_lport_info_get(unit, &lport_info));

    /* Clear portmap in dev_info. */
    bcmsec_dev_info_portmap_reset(unit);

    /* Suppose that the config array is indexed by physical port number. */
    for (pport = 0; pport < (int)num_ports; pport++) {
        port_cfg_data = new_cfg[pport];
        port_cfg = &port_cfg_data;

        /* If the pport is mapped to an invalid lport, ignore it. */
        if ((port_cfg->lport == BCMPC_INVALID_LPORT) ||
            (port_cfg->lport > TD4_X9_DEV_PORTS_PER_DEV)){
            continue;
        }
        lport = port_cfg->lport;
        pinfo = &pport_info[pport];
        linfo = &lport_info[lport];

        pinfo->port_p2l_mapping = lport;
        linfo->port_l2p_mapping = pport;
        linfo->port_num_lanes = port_cfg->num_lanes;
        linfo->port_speed_cur = port_cfg->speed_cur;
    }

exit:
    SHR_FUNC_EXIT();
}


static int
macsec_soft_reset(int unit, int port, int port_up)
{
    int ioerr = 0;
    MACSEC_CTRLr_t ctrl;

    LOG_VERBOSE(BSL_LOG_MODULE,
            (BSL_META("MACSEC_CTRL[%d].SOFT_RESET = %d\n"),
                      port, !port_up));
    ioerr += READ_MACSEC_CTRLr(unit, port, &ctrl );
    MACSEC_CTRLr_SOFT_RESETf_SET(ctrl, !port_up);
    MACSEC_CTRLr_BYPASS_ENf_SET(ctrl, 0);
    ioerr += WRITE_MACSEC_CTRLr(unit, port, ctrl);

    return ioerr;
}


static int
bcm56780_a0_pport_to_pm_id(int unit, int pport, int *pm_id, int *port_offset)
{
    if ((pport <= 0) || (pport > 160)) {
        return SHR_E_PARAM;
    }
    pport -= 1;
    *pm_id = (pport >> 3);
    *port_offset = (pport % 8);
    return SHR_E_NONE;
}


static int
bcm56780_a0_pm_is_macsec_valid(int unit, int pmid)
{
    bcmdrd_sid_t mem = TOP_MACSEC_CTRL0r;
    bcmdrd_fid_t fid;
    bcmdrd_fid_t fid_a[6] = {MACSEC0_ACTIVEf, MACSEC1_ACTIVEf, MACSEC2_ACTIVEf,
                             MACSEC3_ACTIVEf, MACSEC4_ACTIVEf, MACSEC5_ACTIVEf};
    bcmsec_pt_info_t pt_info = {0};
    bcmltd_sid_t ltid = -1; /* Requesting LT ID not available */
    uint32_t ltmbuf[2] = {0};
    uint32_t fval[1];
    uint32_t macsec_active, macsec_src;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmsec_pt_indexed_read(unit, mem, ltid, &pt_info, ltmbuf));
    switch (pmid) {
        case 0: fid = MACSEC_SRC_PM0_OR_PM6f; macsec_src = 1; macsec_active = 0;
            break;
        case 6: fid = MACSEC_SRC_PM0_OR_PM6f; macsec_src = 0; macsec_active = 0;
            break;
        case 1: fid = MACSEC_SRC_PM1_OR_PM7f; macsec_src = 1; macsec_active = 1;
            break;
        case 7: fid = MACSEC_SRC_PM1_OR_PM7f; macsec_src = 0; macsec_active = 1;
            break;
        case 2: fid = MACSEC_SRC_PM2_OR_PM8f; macsec_src = 1; macsec_active = 4;
            break;
        case 8: fid = MACSEC_SRC_PM2_OR_PM8f; macsec_src = 0; macsec_active = 4;
            break;
        case 3: fid = MACSEC_SRC_PM3_OR_PM9f; macsec_src = 1; macsec_active = 5;
            break;
        case 9: fid = MACSEC_SRC_PM3_OR_PM9f; macsec_src = 0; macsec_active = 5;
            break;
        case 10: fid = MACSEC_SRC_PM10_OR_PM16f; macsec_src = 1;
            macsec_active = 7;
            break;
        case 16: fid = MACSEC_SRC_PM10_OR_PM16f; macsec_src = 0;
            macsec_active = 7;
            break;
        case 11: fid = MACSEC_SRC_PM11_OR_PM17f; macsec_src = 1;
            macsec_active = 6;
            break;
        case 17: fid = MACSEC_SRC_PM11_OR_PM17f; macsec_src = 0;
            macsec_active = 6;
            break;
        case 12: fid = MACSEC_SRC_PM12_OR_PM18f; macsec_src = 1;
            macsec_active = 11;
            break;
        case 18: fid = MACSEC_SRC_PM12_OR_PM18f; macsec_src = 0;
            macsec_active = 11;
            break;
        case 13: fid = MACSEC_SRC_PM13_OR_PM19f; macsec_src = 1;
            macsec_active = 10;
            break;
        case 19: fid = MACSEC_SRC_PM13_OR_PM19f; macsec_src = 0;
            macsec_active = 10;
            break;
        case 4: fid = INVALIDf; macsec_src = 0;
            macsec_active = 2;
            break;
        case 5: fid = INVALIDf; macsec_src = 0;
            macsec_active = 3;
            break;
        case 14: fid = INVALIDf; macsec_src = 0;
            macsec_active = 9;
            break;
        case 15: fid = INVALIDf; macsec_src = 0;
            macsec_active = 8;
            break;
        default:
            return SHR_E_PARAM;
    }
    if (fid != INVALIDf) {
        SHR_IF_ERR_EXIT
            (bcmsec_field_get(unit, mem, fid, ltmbuf, fval));
        if (macsec_src != fval[0]) {
            return SHR_E_PARAM;
        }
    }
    fid = fid_a[macsec_active / 2];
    SHR_IF_ERR_EXIT
        (bcmsec_field_get(unit, mem, fid, ltmbuf, fval));
    if (!(fval[0] & (1 << (macsec_active % 2)))) {
        return SHR_E_PARAM;
    }

exit:
    SHR_FUNC_EXIT();
}


static int
td4_pm_to_macsec_port (int unit, int pm_id, int port_offset,
                                   int *macsec_port)
{
    int macsec_base;
    if (port_offset > 7) {
        return SHR_E_PARAM;
    }
    switch (pm_id)
    {
        case 0:
        case 6:
            macsec_base = 0;
            break;
        case 1:
        case 7:
            macsec_base = 8;
            break;
        case 2:
        case 8:
            macsec_base = 16;
            break;
        case 3:
        case 9:
            macsec_base = 24;
            break;
        case 4:
            macsec_base = 32;
            break;
        case 5:
            macsec_base = 40;
            break;
        case 11:
        case 17:
            macsec_base = 80;
            break;
        case 10:
        case 16:
            macsec_base = 88;
            break;
        case 13:
        case 19:
            macsec_base = 96;
            break;
        case 12:
        case 18:
            macsec_base = 104;
            break;
        case 15:
            macsec_base = 112;
            break;
        case 14:
            macsec_base = 120;
            break;
        default:
            return SHR_E_PARAM;
    }
    *macsec_port = macsec_base + port_offset;
    return SHR_E_NONE;
}


static int
bcm56780_a0_sec_odf_status_poll (int unit, int macsec_port, int egress)
{
    bcmdrd_sid_t reg;
    bcmdrd_fid_t fid ;
    uint32_t ltmbuf = 0;
    uint32_t total_count = -1, fval[1];
    bcmsec_pt_info_t pt_dyn_info = {0};
    bool sim = bcmdrd_feature_is_sim(unit);
    bool emul = bcmdrd_feature_enabled(unit, BCMDRD_FT_EMUL);
    shr_timeout_t to;
    uint64_t flags = 0;

    SHR_FUNC_ENTER(unit);
    reg = egress ? ESEC_ODF_STATUSr : ISEC_ODF_STATUSr;
    fid = CELL_CNTf;
    BCMSEC_PT_DYN_INFO(pt_dyn_info, 0, macsec_port, flags);
    if (!sim) {
        if (emul) {
            shr_timeout_init(&to, SEC_EMUL_ODF_USEC_MAX, 1);
        } else {
            shr_timeout_init(&to, SEC_ODF_USEC_MAX, 1);
        }
        do {
            /* Poll until ODF buffer is empty. */
            SHR_IF_ERR_EXIT
                (bcmsec_pt_indexed_read(unit, reg, -1, &pt_dyn_info, &ltmbuf));
            SHR_IF_ERR_EXIT
                (bcmsec_field_get(unit, reg, fid, &ltmbuf, fval));
            total_count = fval[0];
            if (shr_timeout_check(&to)) {
                break;
            }
        } while (total_count != 0);

        if (total_count != 0) {
            SHR_ERR_EXIT(SHR_E_TIMEOUT);
        }
    }
exit:
    SHR_FUNC_EXIT();
}

/*******************************************************************************
 * Public functions
 */

/*!
 * \brief SEC port validation.
 *
 * Validates the port configuration coming from PC.
 *
 * This function is bound to PC drv and will only be invoked by PC during init
 * or after port update.
 *
 * \param [in] unit Logical unit number.
 * \param [in] num_ports Number of ports.
 * \param [in] old_cfg Old port configurations.
 * \param [in] new_cfg New port configurations.
 *
 * \retval SHR_E_NONE No error.
 * \retval Return error code in case of error.
 */
int
bcm56780_a0_sec_validate (int unit,
                          size_t num_ports,
                          const bcmpc_sec_port_cfg_t *old_cfg,
                          const bcmpc_sec_port_cfg_t *new_cfg)
{
    
    SHR_FUNC_ENTER(unit);

    SHR_FUNC_EXIT();
}

/*!
 * \brief SEC port level init/config function
 *
 * Perform all port configuration dependent SEC configurations.
 *
 * This function is invoked by PC during port add/update.
 */
int
bcm56780_a0_sec_pc_configure(int unit,
                             size_t num_ports,
                             const bcmpc_sec_port_cfg_t *old_cfg,
                             const bcmpc_sec_port_cfg_t *new_cfg)
{
    int idx, pport;
    bcmpc_lport_t lport, old_lport;
    bcmsec_drv_t *sec_drv;
    int old_speed, new_speed;
    int port_add = 0;
    int port_delete = 0;
    bcmsec_pport_info_t *pport_info, *pinfo;
    bcmsec_lport_info_t *lport_info, *linfo;
    size_t size;
    sec_port_ops_t *port_ops = NULL;


    SHR_FUNC_ENTER(unit);

    if (!(bcmdrd_dev_flags_get(unit) & CHIP_FLAG_MACSEC)) {
        SHR_EXIT();
    }
    size = BCMSEC_NUM_PPORTS_PER_CHIP_MAX * sizeof(sec_port_ops_t);
    SHR_ALLOC(port_ops, size, "bcmsecInitPortOps");
    SHR_NULL_CHECK(port_ops, SHR_E_MEMORY);
    sal_memset(port_ops, 0, size);

    SHR_IF_ERR_EXIT
        (bcmsec_drv_get(unit, &sec_drv));
    SHR_IF_ERR_EXIT
        (bcmsec_pport_info_get(unit, &pport_info));
    SHR_IF_ERR_EXIT
        (bcmsec_lport_info_get(unit, &lport_info));


    for (idx = 0; idx < (int)num_ports; idx++) {
        pport = new_cfg[idx].pport;
        if (pport == BCMPC_INVALID_LPORT) {
            continue;
        }
        lport = new_cfg[idx].lport;
        pinfo = &pport_info[pport];
        old_lport = pinfo->port_p2l_mapping;
        if ((old_lport == BCMPC_INVALID_LPORT) &&
                (lport == BCMPC_INVALID_LPORT)) {
            /* No change in port state; Do nothing */
            continue;
        } else if ((old_lport != BCMPC_INVALID_LPORT) &&
                (lport == BCMPC_INVALID_LPORT)) {
            /* Deleted port */
            port_delete = 1;
            port_ops[pport].port_add = 0;
            port_ops[pport].port_delete = 1;
        } else if ((old_lport == BCMPC_INVALID_LPORT) &&
                (lport != BCMPC_INVALID_LPORT)) {
            /* Newly added port */
            port_add = 1;
            port_ops[pport].port_add = 1;
            port_ops[pport].port_delete = 0;
        } else if (old_lport != BCMPC_INVALID_LPORT) {
            linfo = &lport_info[old_lport];
            old_speed = linfo->port_speed_cur;
            new_speed = new_cfg[pport].speed_cur;
            if (old_speed != new_speed) {
                /* Port speed change */
                if (new_speed == 0) {
                    /* Port link down */
                    continue;
                }
                if (!bcmsec_port_is_fp(unit, lport)) {
                    /* Speed change not supported in for CPU, LB and MGMT
                     * ports */
                    continue;
                }
                port_add = 1;
                port_delete = 1;
                port_ops[pport].port_add = 1;
                port_ops[pport].port_delete = 1;
            }
        }
    }
    for (idx = 0; idx < (int)num_ports; idx++) {
        pport = new_cfg[idx].pport;
        if (pport == BCMPC_INVALID_LPORT) {
            continue;
        }
        pinfo = &pport_info[pport];
        lport = pinfo->port_p2l_mapping;
        if (port_ops[pport].port_delete == 1) {
            SHR_IF_ERR_EXIT
                (bcmsec_imm_port_update(unit, lport, ACTION_PORT_DELETE_INT));
        }
    }
    if (port_delete == 1) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                (BSL_META("Port delete. Configure TDM.\n")));
        SHR_IF_ERR_EXIT
            (bcm56780_a0_sec_tdm_init(unit));
    }

    SHR_IF_ERR_EXIT
        (bcm56780_a0_sec_dev_info_portmap_fill(unit, num_ports,
                                               old_cfg, new_cfg));

    /* Call only for newly enabled or speed-changed ports */
    if (port_add == 1) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                (BSL_META("Port add. Configure TDM.\n")));
        /* New port addition */
        SHR_IF_ERR_EXIT
            (bcm56780_a0_sec_tdm_init(unit));
    }

    for (idx = 0; idx < (int)num_ports; idx++) {
        pport = new_cfg[idx].pport;
        if (pport == BCMPC_INVALID_LPORT) {
            continue;
        }
        lport = new_cfg[idx].lport;
        if (port_ops[pport].port_add == 1) {
            SHR_IF_ERR_EXIT
                (bcmsec_imm_port_update(unit, lport, ACTION_PORT_ADD_INT));
        }
    }
exit:
    if (port_ops) {
        SHR_FREE(port_ops);
    }
    SHR_FUNC_EXIT();
}

int
bcm56780_a0_sec_chip_init(int unit, bool warm)
{
    sec_port_info_alloc_cfg_t port_cfg;
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmsec_dev_info_alloc(unit, warm));

    if (!(bcmdrd_dev_flags_get(unit) & CHIP_FLAG_MACSEC)) {
        SHR_EXIT();
    }

    /* Do not change across warmboot for bcm56780. */
    port_cfg.num_pport = TD4_X9_NUM_PHYS_PORTS;
    port_cfg.num_lport = TD4_X9_DEV_PORTS_PER_DEV;

    SHR_IF_ERR_EXIT
        (bcmsec_port_info_alloc(unit, warm, &port_cfg));

    SHR_IF_ERR_EXIT
        (bcm56780_a0_sec_dev_info_populate(unit, warm));

    SHR_IF_ERR_EXIT
        (bcm56780_a0_sec_port_init(unit));

    SHR_IF_ERR_EXIT
        (bcm56780_a0_sec_intr_init(unit, warm));
exit:
    SHR_FUNC_EXIT();
}

int
bcm56780_a0_sec_pport_to_secport(int unit, bcmsec_pport_t pport,
                                 int *pm, int *macsec_port,
                                 int *sec_local_port)
{
    int rv, pm_id, port_offset, sec_port;
    SHR_FUNC_ENTER(unit);

    sec_port = -1;
    if (!(bcmdrd_dev_flags_get(unit) & CHIP_FLAG_MACSEC) ||
        (pport <= 0) || (pport > 160)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Identify the port macro for the physical port. */
    rv = bcm56780_a0_pport_to_pm_id(unit, pport, &pm_id, &port_offset);
    if (rv != SHR_E_NONE) {
        LOG_DEBUG(BSL_LOG_MODULE,
                (BSL_META("Unable to get port macro for pport %d\n"),
                 pport));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Ensure the port macro is Macsec enabled. */
    if (bcm56780_a0_pm_is_macsec_valid(unit, pm_id) != 0) {
        LOG_DEBUG(BSL_LOG_MODULE,
                (BSL_META("pm_id %d invalid or not mapped\n"),
                 pm_id));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Get the macsec port from the port macro and offset. */
    rv = td4_pm_to_macsec_port(unit, pm_id, port_offset, &sec_port);
    if (rv != SHR_E_NONE) {
        LOG_DEBUG(BSL_LOG_MODULE,
                (BSL_META("pm_id %d to macsec port error\n"),
                 pm_id));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (pm) {
        *pm = pm_id;
    }
    if (macsec_port) {
        *macsec_port = sec_port;
    }
    if (sec_local_port) {
        *sec_local_port = (sec_port % NUM_SEC_PORTS_PER_PC_PM);
    }

exit:
    SHR_FUNC_EXIT();
}


int
bcm56780_a0_sec_port_tx_up(int unit, bcmsec_pport_t pport)
{
    int rv, macsec_port;

    SHR_FUNC_ENTER(unit);

    if (!(bcmdrd_dev_flags_get(unit) & CHIP_FLAG_MACSEC)) {
        SHR_EXIT();
    }

    rv = bcm56780_a0_sec_pport_to_secport(unit, pport, NULL,
                                          &macsec_port, NULL);
    if (rv != SHR_E_NONE) {
        LOG_DEBUG(BSL_LOG_MODULE,
                  (BSL_META("PM corresponding to pport %d is "
                   "not SEC enabled.\n"), pport));
        SHR_EXIT();
    }

    sal_usleep(10);

    /* Bring SEC port out of reset. */
    (void) macsec_soft_reset(unit, macsec_port, 1);

exit:
    SHR_FUNC_EXIT();
}


int
bcm56780_a0_sec_port_rx_down(int unit, bcmsec_pport_t pport)
{
    int rv, macsec_port;

    SHR_FUNC_ENTER(unit);

    if (!(bcmdrd_dev_flags_get(unit) & CHIP_FLAG_MACSEC)) {
        SHR_EXIT();
    }

    rv = bcm56780_a0_sec_pport_to_secport(unit, pport, NULL,
                                          &macsec_port, NULL);
    if (rv != SHR_E_NONE) {
        LOG_DEBUG(BSL_LOG_MODULE,
                  (BSL_META("PM corresponding to pport %d is "
                   "not SEC enabled.\n"), pport));
        SHR_EXIT();
    }

    SHR_IF_ERR_EXIT
        (bcm56780_a0_sec_odf_status_poll(unit, macsec_port, 0));

exit:
    SHR_FUNC_EXIT();
}


int
bcm56780_a0_sec_port_tx_down(int unit, bcmsec_pport_t pport)
{
    int rv, macsec_port;

    SHR_FUNC_ENTER(unit);

    if (!(bcmdrd_dev_flags_get(unit) & CHIP_FLAG_MACSEC)) {
        SHR_EXIT();
    }

    rv = bcm56780_a0_sec_pport_to_secport(unit, pport, NULL,
                                          &macsec_port, NULL);
    if (rv != SHR_E_NONE) {
        LOG_DEBUG(BSL_LOG_MODULE,
                  (BSL_META("PM corresponding to pport %d is "
                   "not SEC enabled.\n"), pport));
        SHR_EXIT();
    }


    SHR_IF_ERR_EXIT
        (bcm56780_a0_sec_odf_status_poll(unit, macsec_port, 1));

    sal_usleep(10);

    (void) macsec_soft_reset(unit, macsec_port, 0);

exit:
    SHR_FUNC_EXIT();
}
