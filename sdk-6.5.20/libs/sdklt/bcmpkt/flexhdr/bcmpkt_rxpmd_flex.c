/*****************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by xfc_map_parser
 * from the NPL output file(s) map.yml.
 * Edits to this file will be lost when it is regenerated.
 *
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 * All Rights Reserved.$
 *
 * Tool Path: $SDK/INTERNAL/fltg/xfc_map_parser
 */

/*! \file bcmpkt_rxpmd_flex.c
 *
 * RX Packet FLEX Meta Data (called FLEX_DATA in hardware) access interfaces.
 */

#include <shr/shr_error.h>
#include <shr/shr_debug.h>
#include <shr/shr_pb_format.h>
#include <bsl/bsl.h>
#include <bcmlrd/bcmlrd_conf.h>
#include <bcmpkt/flexhdr/bcmpkt_rxpmd_flex.h>
#include <bcmpkt/flexhdr/bcmpkt_rxpmd_flex_internal.h>

#define BSL_LOG_MODULE BSL_LS_BCMPKT_RXPMD

#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
    extern const bcmpkt_rxpmd_flex_fget_t _bd##_vu##_va##_rxpmd_flex_fget;
#include <bcmlrd/chip/bcmlrd_variant.h>

#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
    &_bd##_vu##_va##_rxpmd_flex_fget,
/*! This sequence should be same as bcmdrd_cm_dev_type_t */
static const bcmpkt_rxpmd_flex_fget_t *rxpmd_flex_fget[] = {
    NULL,
#include <bcmlrd/chip/bcmlrd_variant.h>
    NULL
};

#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
    extern const bcmpkt_rxpmd_flex_fset_t _bd##_vu##_va##_rxpmd_flex_fset;
#include <bcmlrd/chip/bcmlrd_variant.h>

#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
    &_bd##_vu##_va##_rxpmd_flex_fset,
/*! This sequence should be same as bcmdrd_cm_dev_type_t */
static const bcmpkt_rxpmd_flex_fset_t *rxpmd_flex_fset[] = {
    NULL,
#include <bcmlrd/chip/bcmlrd_variant.h>
    NULL
};

#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
    extern const bcmpkt_rxpmd_flex_figet_t _bd##_vu##_va##_rxpmd_flex_figet;
#include <bcmlrd/chip/bcmlrd_variant.h>

#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
    &_bd##_vu##_va##_rxpmd_flex_figet,
/*! This sequence should be same as bcmdrd_cm_dev_type_t */
static const bcmpkt_rxpmd_flex_figet_t *rxpmd_flex_figet[] = {
    NULL,
#include <bcmlrd/chip/bcmlrd_variant.h>
    NULL
};

#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
    &_bd##_vu##_va##_rxpmd_flex_reason_decode,
/*! This sequence should be same as bcmdrd_cm_dev_type_t */
static void (*reason_fdecode[])(const uint32_t*, bcmpkt_rxpmd_flex_reasons_t*) = {
    NULL,
#include <bcmlrd/chip/bcmlrd_variant.h>
    NULL
};

#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
    &_bd##_vu##_va##_rxpmd_flex_reason_encode,
static void (*reason_fencode[])(const bcmpkt_rxpmd_flex_reasons_t*, uint32_t*) = {
    NULL,
#include <bcmlrd/chip/bcmlrd_variant.h>
    NULL
};

#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
    &_bd##_vu##_va##_rxpmd_flex_view_info_get,
static void (*view_info_get[])(bcmpkt_pmd_view_info_t *) = {
    NULL,
#include <bcmlrd/chip/bcmlrd_variant.h>
    NULL
};

static const shr_enum_map_t field_names[] =
{
    BCMPKT_RXPMD_FLEX_FIELD_NAME_MAP_INIT
};

static const shr_enum_map_t rxpmd_flex_reason_names[] =
{
    BCMPKT_RXPMD_FLEX_REASON_NAME_MAP_INIT
};

int
bcmpkt_rxpmd_flex_field_get(bcmlrd_variant_t variant, uint32_t *rxpmd_flex,
                            uint32_t profile, int fid, uint32_t *val)
{
    int32_t ret = SHR_E_NONE;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);
    SHR_NULL_CHECK(rxpmd_flex, SHR_E_PARAM);
    SHR_NULL_CHECK(val, SHR_E_PARAM);

    if (variant <= BCMLRD_VARIANT_T_NONE || variant >= BCMLRD_VARIANT_T_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (fid < 0 || fid >= BCMPKT_RXPMD_FLEX_FID_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (rxpmd_flex_fget[variant] == NULL ||
        rxpmd_flex_fget[variant]->fget[fid] == NULL) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    ret = rxpmd_flex_fget[variant]->fget[fid](rxpmd_flex, profile, val);
    if (ret < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

int
bcmpkt_rxpmd_flex_field_set(bcmlrd_variant_t variant, uint32_t *rxpmd_flex,
                            uint32_t profile, int fid, uint32_t val)
{
    int32_t ret = SHR_E_NONE;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);
    SHR_NULL_CHECK(rxpmd_flex, SHR_E_PARAM);

    if (variant <= BCMLRD_VARIANT_T_NONE || variant >= BCMLRD_VARIANT_T_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (fid < 0 || fid >= BCMPKT_RXPMD_FLEX_FID_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (rxpmd_flex_fset[variant] == NULL ||
        rxpmd_flex_fset[variant]->fset[fid] == NULL) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    ret = rxpmd_flex_fset[variant]->fset[fid](rxpmd_flex, profile, val);
    if (ret < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

int
bcmpkt_rxpmd_flex_field_name_get(int fid, char **name)
{
    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);
    SHR_NULL_CHECK(name, SHR_E_PARAM);

    if (fid <= BCMPKT_RXPMD_FLEX_FID_INVALID ||
        fid >= BCMPKT_RXPMD_FLEX_FID_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *name = field_names[fid].name;

exit:
    SHR_FUNC_EXIT();
}

int
bcmpkt_rxpmd_flex_field_id_get(char *name, int *fid)
{
    int i;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);
    SHR_NULL_CHECK(name, SHR_E_PARAM);
    SHR_NULL_CHECK(fid, SHR_E_PARAM);

    for (i = BCMPKT_RXPMD_FLEX_FID_INVALID + 1; i < BCMPKT_RXPMD_FLEX_FID_COUNT; i++) {
        if (sal_strcasecmp(field_names[i].name, name) == 0) {
            *fid = field_names[i].val;
            SHR_EXIT();
        }
    }

    SHR_ERR_EXIT(SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

int
bcmpkt_rxpmd_flex_fid_support_get(bcmlrd_variant_t variant,
                                  bcmpkt_rxpmd_flex_fid_support_t *support)
{
    int i;
    bcmpkt_pmd_view_info_t view_info;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);

    if (variant <= BCMLRD_VARIANT_T_NONE || variant >= BCMLRD_VARIANT_T_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (view_info_get[variant] == NULL) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    SHR_NULL_CHECK(support, SHR_E_PARAM);
    sal_memset(support, 0, sizeof(*support));

    view_info_get[variant](&view_info);
    if (!view_info.view_types || !view_info.view_infos) {
        SHR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

    for (i = BCMPKT_RXPMD_FLEX_FID_INVALID + 1; i < BCMPKT_RXPMD_FLEX_FID_COUNT; i++) {
        if (view_info.view_infos[i] >= -1) {
            SHR_BITSET(support->fbits, i);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
bcmpkt_rxpmd_flex_field_list_dump(bcmlrd_variant_t variant, char *view_name,
                                  shr_pb_t *pb)
{
    int i, j;
    bcmpkt_pmd_view_info_t view_info;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);
    SHR_NULL_CHECK(pb, SHR_E_PARAM);

    if (variant <= BCMLRD_VARIANT_T_NONE || variant >= BCMLRD_VARIANT_T_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (view_info_get[variant] == NULL) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    view_info_get[variant](&view_info);
    SHR_NULL_CHECK(view_info.view_types, SHR_E_UNAVAIL);
    SHR_NULL_CHECK(view_info.view_infos, SHR_E_UNAVAIL);

    /* Print common fields. */
    for (i = BCMPKT_RXPMD_FLEX_FID_INVALID + 1; i < BCMPKT_RXPMD_FLEX_FID_COUNT; i++) {
        if (view_info.view_infos[i] == -1) {
            shr_pb_printf(pb, "    %s\n", field_names[i].name);
        }
    }

    /* Print view fields. */
    for (j = 0; view_info.view_types[j].name != NULL; j++) {
        if (view_name) {
            if (sal_strcasecmp(view_name, view_info.view_types[j].name)) {
                continue;
            }
        }
        for (i = BCMPKT_RXPMD_FLEX_FID_INVALID + 1; i < BCMPKT_RXPMD_FLEX_FID_COUNT; i++) {
            if (view_info.view_infos[i] == view_info.view_types[j].val) {
                shr_pb_printf(pb, "    %s\n", field_names[i].name);
            }
        }
    }
exit:
    SHR_FUNC_EXIT();
}

int
bcmpkt_rxpmd_flex_dump(bcmlrd_variant_t variant, uint32_t *rxpmd_flex,
                       uint32_t profile, uint32_t flags, shr_pb_t *pb)
{
    int i, ret;
    int view_enc;
    uint32_t val;
    bcmpkt_pmd_view_info_t view_info;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);
    SHR_NULL_CHECK(rxpmd_flex, SHR_E_PARAM);
    SHR_NULL_CHECK(pb, SHR_E_PARAM);

    if (variant <= BCMLRD_VARIANT_T_NONE || variant >= BCMLRD_VARIANT_T_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (rxpmd_flex_fget[variant] == NULL ||
        view_info_get[variant] == NULL) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    view_info_get[variant](&view_info);
    SHR_NULL_CHECK(view_info.view_types, SHR_E_UNAVAIL);
    SHR_NULL_CHECK(view_info.view_infos, SHR_E_UNAVAIL);

    /* Print common fields. */
    for (i = BCMPKT_RXPMD_FLEX_FID_INVALID + 1; i < BCMPKT_RXPMD_FLEX_FID_COUNT; i++) {
        if (view_info.view_infos[i] == -1) {
            ret = rxpmd_flex_fget[variant]->fget[i](rxpmd_flex, profile, &val);
            if (((val > 0) || (flags == BCMPKT_RXPMD_FLEX_DUMP_F_ALL)) && (ret >= 0)) {
                shr_pb_printf(pb, "\t%s=", field_names[i].name);
                shr_pb_format_uint32(pb, NULL, &val, 1, 0);
                shr_pb_printf(pb, "\n");
            }
        }
    }

    /* Print view fields. */
    if (view_info.view_type_get) {
        view_enc = view_info.view_type_get(rxpmd_flex);
        for (i = BCMPKT_RXPMD_FLEX_FID_INVALID + 1; i < BCMPKT_RXPMD_FLEX_FID_COUNT; i++) {
            if (view_info.view_infos[i] == view_enc) {
                ret = rxpmd_flex_fget[variant]->fget[i](rxpmd_flex, profile, &val);
                if (((val > 0) || (flags == BCMPKT_RXPMD_FLEX_DUMP_F_ALL)) && (ret >= 0)) {
                    shr_pb_printf(pb, "\t%s=", field_names[i].name);
                    shr_pb_format_uint32(pb, NULL, &val, 1, 0);
                    shr_pb_printf(pb, "\n");
                }
            }
        }
    }
exit:
    SHR_FUNC_EXIT();
}

int
bcmpkt_rxpmd_flex_reasons_get(bcmlrd_variant_t variant, uint32_t *rxpmd_flex,
                              bcmpkt_rxpmd_flex_reasons_t *reasons)
{
    uint32_t *reason = NULL;
    int len;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);
    SHR_NULL_CHECK(rxpmd_flex, SHR_E_PARAM);
    SHR_NULL_CHECK(reasons, SHR_E_PARAM);

    if (variant <= BCMLRD_VARIANT_T_NONE || variant >= BCMLRD_VARIANT_T_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (rxpmd_flex_figet[variant] == NULL ||
        rxpmd_flex_figet[variant]->fget[BCMPKT_RXPMD_FLEX_I_REASON] == NULL) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    BCMPKT_RXPMD_FLEX_REASON_CLEAR_ALL(*reasons);
    len = rxpmd_flex_figet[variant]->fget[BCMPKT_RXPMD_FLEX_I_REASON](rxpmd_flex, &reason);
    if (len <= 0) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    reason_fdecode[variant](reason, reasons);
exit:
    SHR_FUNC_EXIT();
}

int
bcmpkt_rxpmd_flex_reasons_set(bcmlrd_variant_t variant,
                              bcmpkt_rxpmd_flex_reasons_t *reasons, uint32_t *rxpmd_flex)
{
    uint32_t *reason = NULL;
    int len;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);
    SHR_NULL_CHECK(rxpmd_flex, SHR_E_PARAM);
    SHR_NULL_CHECK(reasons, SHR_E_PARAM);

    if (variant <= BCMLRD_VARIANT_T_NONE || variant >= BCMLRD_VARIANT_T_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (rxpmd_flex_figet[variant] == NULL ||
        rxpmd_flex_figet[variant]->fget[BCMPKT_RXPMD_FLEX_I_REASON] == NULL) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    len = rxpmd_flex_figet[variant]->fget[BCMPKT_RXPMD_FLEX_I_REASON](rxpmd_flex, &reason);
    if (len <= 0) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    reason_fencode[variant](reasons, reason);
exit:
    SHR_FUNC_EXIT();
}

int
bcmpkt_rxpmd_flex_reason_dump(bcmlrd_variant_t variant,
                              uint32_t *rxpmd_flex, shr_pb_t *pb)
{
    int reason;
    bcmpkt_rxpmd_flex_reasons_t reasons;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);
    SHR_NULL_CHECK(rxpmd_flex, SHR_E_PARAM);
    SHR_NULL_CHECK(pb, SHR_E_PARAM);

    if (variant <= BCMLRD_VARIANT_T_NONE || variant >= BCMLRD_VARIANT_T_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    BCMPKT_RXPMD_FLEX_REASON_CLEAR_ALL(reasons);
    SHR_IF_ERR_EXIT
        (bcmpkt_rxpmd_flex_reasons_get(variant, rxpmd_flex, &reasons));

    BCMPKT_RXPMD_FLEX_REASON_ITER(reasons, reason) {
        shr_pb_printf(pb, "\t%s\n", rxpmd_flex_reason_names[reason].name);
    }

exit:
    SHR_FUNC_EXIT();
}

int
bcmpkt_rxpmd_flex_reason_name_get(int reason, char **name)
{
    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);
    SHR_NULL_CHECK(name, SHR_E_PARAM);

    if (reason <= BCMPKT_RXPMD_FLEX_REASON_NONE ||
        reason > BCMPKT_RXPMD_FLEX_REASON_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *name = rxpmd_flex_reason_names[reason].name;
exit:
    SHR_FUNC_EXIT();
}
