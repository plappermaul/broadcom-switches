/**************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by HA parser from YAML formated file.
 * Edits to this file will be lost when it is regenerated.
 * Tool: bcmha/scripts/ha_yml_parser.py
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
#ifndef BCMPTM_CCI_HA_H
#define BCMPTM_CCI_HA_H

#include <shr/shr_ha.h>

#define CTR_FIELD_NUM_MAX 16

/*!
 * Counter mode
 */
typedef enum {
   CCI_CTR_NORMAL_MODE = 0,
   CCI_CTR_WIDE_MODE = 1,
   CCI_CTR_SLIM_MODE = 2
} cci_ctr_mode_t;

/*!
 * Counter update mode
 */
typedef enum {
   CCI_UPDATE_NOOP = 0,
   CCI_UPDATE_SET_TO_CVALUE = 1,
   CCI_UPDATE_INC_BY_CVALUE = 2,
   CCI_UPDATE_DEC_BY_CVALUE = 3,
   CCI_UPDATE_MAX_VALUE = 4,
   CCI_UPDATE_MIN_VALUE = 5,
   CCI_UPDATE_AVERAGE_VALUE = 6,
   CCI_UPDATE_SETBIT = 7,
   CCI_UPDATE_RDEC_FROM_CVALUE = 8,
   CCI_UPDATE_XOR = 9,
   CCI_UPDATE_CLR_BIT = 9,
   CCI_UPDATE_XOR_BIT = 9
} cci_update_mode_t;

typedef struct {
   /*! Indicate counter mode */
   uint8_t ctr_mode;
   /*! Indicate update mode */
   uint8_t update_mode;
} cci_count_mode_t;

#define CCI_COUNT_MODE_T_ID 0xc3784e64c0bb77bd

typedef struct {
   /*! Number of entry nodes for a table */
   uint32_t cnt_table;
   /*! Number of entry nodes for a mode */
   uint32_t cnt_mode;
   /*! Indicate counter mode and update mode */
   cci_count_mode_t count_mode[];
} cci_count_mode_array_t;

#define CCI_COUNT_MODE_ARRAY_T_ID 0xa32d90229652f7e0

typedef enum {
   CCI_EVICT_MODE_DISABLE = 0,
   CCI_EVICT_MODE_RANDOM = 1,
   CCI_EVICT_MODE_THD = 2,
   CCI_EVICT_MODE_CONDITIONAL = 3
} cci_evict_mode_t;

typedef enum {
   CCI_CTR_TYPE_PORT = 0,
   CCI_CTR_TYPE_TM = 1,
   CCI_CTR_TYPE_EPIPE = 2,
   CCI_CTR_TYPE_IPIPE = 3,
   CCI_CTR_TYPE_EVICT = 4,
   CCI_CTR_TYPE_NUM = 5
} cci_ctr_type_id;

typedef struct {
   uint16_t minbit;
   uint16_t maxbit;
} cci_field_t;

#define CCI_FIELD_T_ID 0x7afb380c085d2c47

/*!
 * base counter map object
 */
typedef struct {
   /*! Symbol ID */
   uint32_t sid;
   /*! Fixed part of symbol address */
   uint32_t offset;
   /*! Symbol blktype */
   int blktype;
   /*! map of valid pipes */
   uint32_t pipe_map;
   /*! Compare key for map sorting */
   uint64_t cmp_key;
   /*! Number of table instances */
   int tbl_inst;
   /*! Counter Type */
   cci_ctr_type_id ctrtype;
   /*! Sym is memory */
   bool is_mem;
   /*! enable to update */
   bool enable;
   /*! clear-on-read for sbus reads */
   bool clr_on_read;
   /*! Eviction Mode */
   cci_evict_mode_t evict_mode;
   /*! Cache clear from SER event */
   bool clr_on_ser;
   /*! size,number of entries in counter Table */
   uint32_t size;
   /*! size,number of entries in counter mode array */
   uint32_t mode_size;
   /*! state of the pool, disable, enable, shadow */
   uint8_t state;
   /*! Minimum valid index */
   uint32_t index_min;
   /*! Maximum valid index */
   uint32_t index_max;
   /*! ctr_table_offset,in counter Table */
   uint32_t ctr_table_offset;
   /*! ctr_mode_offset,in counter mode array */
   uint32_t ctr_mode_offset;
   /*! field_num, */
   uint32_t field_num;
   /*! slim_field_num, */
   uint32_t slim_field_num;
   /*! physical entry size in words */
   uint32_t pt_entry_wsize;
   /*! physical field */
   cci_field_t pt_field[CTR_FIELD_NUM_MAX];
   /*! logical field */
   cci_field_t lt_field[CTR_FIELD_NUM_MAX];
} cci_ctr_cache_map_t;

#define CCI_CTR_CACHE_MAP_T_ID 0x22f1c3067e97172c

typedef struct {
   /*! Number of entry nodes for a table */
   uint32_t cnt;
   /*! base counter map object */
   cci_ctr_cache_map_t ctr_map_table[];
} cci_ctr_cache_map_array_t;

#define CCI_CTR_CACHE_MAP_ARRAY_T_ID 0x340e03e6257e0608

#endif /* BCMPTM_CCI_HA_H */
