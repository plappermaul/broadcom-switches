/**************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by HA parser from YAML formated file.
 * Edits to this file will be lost when it is regenerated.
 * Tool: bcmha/scripts/ha_yml_parser.py
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
#ifndef BCMFP_HA_H
#define BCMFP_HA_H

#include <shr/shr_ha.h>

#define BCMFP_ENTRY_PARTS_MAX 6
#define BCMFP_HA_BLK_ID_ARRAY_SIZE 8
#define BCMFP_COMPRESS_TYPES_MAX 4
#define BCMFP_EM_MAX_BANKS 12
#define BCMFP_MAX_EXTRACTORS_PER_LEVEL 64

typedef enum {
   BCMFP_STAGE_OPER_MODE_GLOBAL = 0,
   BCMFP_STAGE_OPER_MODE_PIPE_UNIQUE = 1,
   BCMFP_STAGE_OPER_MODE_GLOBAL_PIPE_AWARE = 2,
   BCMFP_STAGE_OPER_MODE_COUNT = 3
} bcmfp_stage_oper_mode_t;

typedef enum {
   BCMFP_GROUP_MODE_HALF = 0,
   BCMFP_GROUP_MODE_SINGLE = 1,
   BCMFP_GROUP_MODE_SINGLE_ASET_NARROW = 2,
   BCMFP_GROUP_MODE_SINGLE_ASET_WIDE = 3,
   BCMFP_GROUP_MODE_DBLINTRA = 4,
   BCMFP_GROUP_MODE_DBLINTER = 5,
   BCMFP_GROUP_MODE_TRIPLE = 6,
   BCMFP_GROUP_MODE_QUAD = 7,
   BCMFP_GROUP_MODE_AUTO = 8,
   BCMFP_GROUP_MODE_NONE = 9,
   BCMFP_GROUP_MODE_COUNT = 10
} bcmfp_group_mode_t;

typedef enum {
   BCMFP_GROUP_SLICE_MODE_L2_SINGLE_WIDE = 0,
   BCMFP_GROUP_SLICE_MODE_L3_SINGLE_WIDE = 1,
   BCMFP_GROUP_SLICE_MODE_L3_DOUBLE_WIDE = 2,
   BCMFP_GROUP_SLICE_MODE_L3_ANY_SINGLE_WIDE = 3,
   BCMFP_GROUP_SLICE_MODE_L3_ANY_DOUBLE_WIDE = 4,
   BCMFP_GROUP_SLICE_MODE_L3_ALT_DOUBLE_WIDE = 5,
   BCMFP_GROUP_SLICE_MODE_COUNT = 6
} bcmfp_group_slice_mode_t;

typedef enum {
   BCMFP_TRANS_STATE_IDLE = 0,
   BCMFP_TRANS_STATE_UC_A = 1,
   BCMFP_TRANS_STATE_COPY_A_TO_B = 2,
   BCMFP_TRANS_STATE_COPY_B_TO_A = 3
} bcmfp_trans_state_t;

typedef enum {
   BCMFP_HA_BLK_TYPE_NONE = 0,
   BCMFP_HA_BLK_TYPE_GENERIC_TV = 1,
   BCMFP_HA_BLK_TYPE_DYNAMIC_CKEY = 2,
   BCMFP_HA_BLK_TYPE_STAGE_OPER = 3,
   BCMFP_HA_BLK_TYPE_PDD_ACTIONS_INFO = 4,
   BCMFP_HA_BLK_TYPE_FID_OFFSET_INFO = 5,
   BCMFP_HA_BLK_TYPE_COMPRESS_OPER_INFO = 6,
   BCMFP_HA_BLK_TYPE_COUNT = 7
} bcmfp_ha_blk_type_t;

typedef enum {
   BCMFP_GROUP_STATE_NONE = 0,
   BCMFP_GROUP_STATE_SUCCESS = 1,
   BCMFP_GROUP_STATE_ASET_WIDER = 2,
   BCMFP_GROUP_STATE_QSET_WIDER = 3,
   BCMFP_GROUP_STATE_NON_COMPRESSIBLE = 4,
   BCMFP_GROUP_STATE_COUNT = 7
} bcmfp_group_state_t;

typedef enum {
   BCMFP_PDD_OPER_TYPE_NONE = 0,
   BCMFP_PDD_OPER_TYPE_PDD_SBR_GROUP = 1,
   BCMFP_PDD_OPER_TYPE_PDD_SBR_ENTRY = 2,
   BCMFP_PDD_OPER_TYPE_PDD_GROUP_SBR_ENTRY = 3,
   BCMFP_PDD_OPER_TYPE_PDD_ENTRY_SBR_GROUP = 4,
   BCMFP_PDD_OPER_TYPE_DEFAULT_POLICY = 5,
   BCMFP_PDD_OPER_TYPE_PDD_GROUP = 6,
   BCMFP_PDD_OPER_TYPE_COUNT = 7
} bcmfp_pdd_oper_type_t;

typedef enum {
   BCMFP_GROUP_SLICE_TYPE_NONE = 0,
   BCMFP_GROUP_SLICE_TYPE_SMALL = 1,
   BCMFP_GROUP_SLICE_TYPE_LARGE = 2,
   BCMFP_GROUP_SLICE_TYPE_COUNT = 3
} bcmfp_group_slice_type_t;

typedef struct {
   /*! HA Blk ID bitmap array. */
   uint32_t w[BCMFP_HA_BLK_ID_ARRAY_SIZE];
} bcmfp_ha_blk_id_bmp_t;

#define BCMFP_HA_BLK_ID_BMP_T_ID 0x93149c0fa80497e8

typedef struct {
   /*! Minimum HA block id allowed. */
   uint8_t min_ha_blk_id;
   /*! Maximum HA block id allowed. */
   uint8_t max_ha_blk_id;
   /*! HA - used blk ID bitmap. */
   bcmfp_ha_blk_id_bmp_t in_use_ha_blk_id_bmp;
} bcmfp_ha_root_blk_t;

#define BCMFP_HA_ROOT_BLK_T_ID 0x5b6ee48220a653e4

typedef struct {
   /*! HA block size */
   uint32_t blk_size;
   /*! HA block type. */
   bcmfp_ha_blk_type_t blk_type;
   /*! Back up block ID. */
   uint8_t backup_blk_id;
   /*! Free HA element in this HA block. This is used to maintain list of free HA elements in this HA block. */
   uint32_t free_blk_offset;
   /*! Number of free HA elements. */
   uint32_t free_ha_element_count;
   /*! Signature. */
   uint32_t signature;
   /*! Transaction state of the stage. */
   bcmfp_trans_state_t trans_state;
   /*! Number of HA elements at each HA block offset. */
   uint8_t bucket_size;
   /*! FP ALPM Compression type. */
   uint8_t ctype;
   /*! FP stage ID. */
   uint8_t stage_id;
} bcmfp_ha_blk_hdr_t;

#define BCMFP_HA_BLK_HDR_T_ID 0xf46978947f7715e2

typedef struct {
   /*! Unique Id assigned to HA block created by BCMFP. This will be same as sub component id used while creating the HA block using bcmfp_ha_mem_alloc API. */
   uint16_t blk_id;
   /*! Block info will be derived for a certain s/w state during run time. This block offset is the offset in the HA block of "blk_id". This is multiples of size of bcmfp_ha_element_t. */
   uint32_t blk_offset;
} bcmfp_ha_blk_info_t;

#define BCMFP_HA_BLK_INFO_T_ID 0xa468357724ec48cc

typedef struct {
   /*! Actual value saved in this element. */
   uint32_t value;
   /*! Next HA block ID. If this is 0, that means the end of the chain. */
   uint16_t next_blk_id;
   /*! Offset in the next HA block ID */
   uint32_t next_blk_offset;
} bcmfp_generic_data_t;

#define BCMFP_GENERIC_DATA_T_ID 0x46a1ac34001b5fc5

typedef struct {
   /*! LT keygen program profile index. */
   int keygen_index;
   /*! Ingress Port Bitmap Source. */
   int ipbm_source;
   /*! Hardware LTID(not SDKLT) assigned to the group. */
   int ltid;
   /*! EM key mode. */
   int key_type;
   /*! EM Default Policy Enable. */
   int8_t default_policy_enable;
   /*! Level 1 32b extractors. */
   int16_t l1_e32_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Level 1 16b extractors. */
   int16_t l1_e16_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Level 1 8b extractors. */
   int16_t l1_e8_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Level 1 4b extractors. */
   int16_t l1_e4_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Level 1 2b extractors. */
   int16_t l1_e2_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Level 2 1b extractors. */
   int16_t l2_e1_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Level 2 2b extractors. */
   int16_t l2_e2_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Level 2 4b extractors. */
   int16_t l2_e4_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Level 2 16b extractors. */
   int16_t l2_e16_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Level 3 1b extractors. */
   int16_t l3_e1_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Level 3 2b extractors. */
   int16_t l3_e2_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Level 3 4b extractors. */
   int16_t l3_e4_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Post muxing extractors. */
   int8_t pmux_sel[BCMFP_MAX_EXTRACTORS_PER_LEVEL];
   /*! Intraslice double wide selection. */
   int8_t intraslice;
   /*! Secondary selector. */
   int8_t secondary;
   /*! Post mux IPBM in final key. */
   int8_t ipbm_present;
   /*! Normalize L3 and L4 address. */
   int8_t normalize_l3_l4_sel;
   /*! Normalize L2 SA & DA. */
   int8_t normalize_mac_sel;
   /*! Auxiliary Tag A Selector. */
   int8_t aux_tag_a_sel;
   /*! Auxiliary Tag B Selector. */
   int8_t aux_tag_b_sel;
   /*! Auxiliary Tag C Selector. */
   int8_t aux_tag_c_sel;
   /*! Auxiliary Tag D Selector. */
   int8_t aux_tag_d_sel;
   /*! TCP function selector. */
   int8_t tcp_fn_sel;
   /*! TOS function selector. */
   int8_t tos_fn_sel;
   /*! TOS function selector. */
   int8_t ttl_fn_sel;
   /*! Class ID container A selector. */
   int8_t class_id_cont_a_sel;
   /*! Class ID container B selector. */
   int8_t class_id_cont_b_sel;
   /*! Class ID container C selector. */
   int8_t class_id_cont_c_sel;
   /*! Class ID container D selector. */
   int8_t class_id_cont_d_sel;
   /*! SRC container A selector. */
   int8_t src_cont_a_sel;
   /*! SRC container B selector. */
   int8_t src_cont_b_sel;
   /*! DST container A selector. */
   int8_t dst_cont_a_sel;
   /*! DST container B selector. */
   int8_t dst_cont_b_sel;
   /*! SRC or DST container 0 selector. */
   int8_t src_dest_cont_0_sel;
   /*! SRC or DST container 0 selector. */
   int8_t src_dest_cont_1_sel;
   /*! FPF0 field(s) select. */
   int8_t fpf0;
   /*! FPF1 field(s) select. */
   int8_t fpf1;
   /*! FPF2 field(s) select. */
   int8_t fpf2;
   /*! FPF3 field(s) select. */
   int8_t fpf3;
   /*! FPF4 field(s) select. */
   int8_t fpf4;
   /*! Src port/trunk entity selection. */
   int8_t src_sel;
   /*! Inner/Outer Ip header selection. */
   int8_t ip_header_sel;
   /*! EFP KEY1 Class ID selector. */
   int8_t egr_key1_classid_sel;
   /*! EFP KEY2 Class ID selector. */
   int8_t egr_key2_classid_sel;
   /*! EFP KEY3 Class ID selector. */
   int8_t egr_key3_classid_sel;
   /*! EFP KEY4 Class ID selector. */
   int8_t egr_key4_classid_sel;
   /*! EFP KEY6 Class ID selector. */
   int8_t egr_key6_classid_sel;
   /*! EFP KEY7 Class ID selector. */
   int8_t egr_key7_classid_sel;
   /*! EFP KEY8 Class ID selector. */
   int8_t egr_key8_classid_sel;
   /*! EFP KEY4 DVP Secondary selector. */
   int8_t egr_key4_dvp_sel;
   /*! EFP KEY8 DVP Secondary selector */
   int8_t egr_key8_dvp_sel;
   /*! EFP KEY4 MDL Secondary selector. */
   int8_t egr_key4_mdl_sel;
   /*! Ip6 address format selection. */
   int8_t egr_ip_addr_sel;
   /*! Index to PDD profile table. */
   int8_t pdd_prof_index;
   /*! Index to default PDD profile table. */
   int8_t default_pdd_prof_index;
   /*! Index to default SBR profile table. */
   int8_t default_sbr_prof_index;
   /*! Index to QOS profile table. */
   int8_t qos_prof_index;
   /*! Index to default QOS profile table. */
   int8_t default_qos_prof_index;
   /*! UDF selector. */
   int8_t udf_sel;
   /*! ALT TTL function selector. */
   int8_t alt_ttl_fn_sel;
   /*! SBR(StrengthBased Resolution) profile index. */
   int8_t sbr_prof_index;
   /*! Presel Group index. */
   int8_t psg_prof_index;
   /*! Exact match entry  class ID. */
   uint16_t em_class_id;
   /*! Default exact match entry  class ID. */
   uint16_t default_em_class_id;
   /*! Exact match entry key attribute profile index. */
   int16_t em_key_attrib_index;
   /*! Number of base entries occupied by EM entry. */
   uint16_t num_base_entries;
   /*! Number of key fields. */
   uint16_t num_key_fields;
   /*! Start bit of key fields in each entry. */
   uint16_t key_field_sbit[8];
   /*! Width of key fields in each entry. */
   uint16_t key_field_width[8];
} bcmfp_ext_codes_t;

#define BCMFP_EXT_CODES_T_ID 0x5b7a631e71615dcb

typedef struct {
   /*! Logical Table ID */
   uint32_t sid;
   /*! LT field ID */
   uint32_t fid;
   /*! Index of LT field ID if it is array. */
   uint16_t fidx;
   /*! Offset and width information of a  Qlifier( unique field ID and field index cobination) in different parts with in the group. Each unique qualifier may take minimum one HA element and upto the number of offset and width pairs belongs to the qualifier. Number of offset, width pairs of a qualifer depends on the keygen algorithm. */
   bcmfp_ha_blk_info_t offset_info;
   /*! HA block ID of next fid offset information. */
   uint8_t next_blk_id;
   /*! HA block ID of next fid offset information. */
   uint32_t next_blk_offset;
} bcmfp_fid_offset_info_t;

#define BCMFP_FID_OFFSET_INFO_T_ID 0x6dfdf8979fb49dfd

typedef struct {
   /*! Valid/Invalid indicator. */
   bool valid;
   /*! State of the group operational information. */
   bcmfp_group_state_t state;
   /*! Set if the group use default presel. */
   bool default_presel;
   /*! Set if any associated presel not exists. */
   bool presel_not_exists;
   /*! Set if aset processing is a failure. */
   bool aset_error;
   /*! Set if qset processing is a failure. */
   bool qset_error;
   /*! Set if default aset processing is a failure. */
   bool default_aset_error;
   /*! Group idenfifier. */
   uint32_t group_id;
   /*! Group priority. */
   uint32_t group_prio;
   /*! Group mode. */
   bcmfp_group_mode_t group_mode;
   /*! Group slice mode. */
   bcmfp_group_slice_mode_t group_slice_mode;
   /*! Flex mode operation. */
   bool flex_mode;
   /*! Size of key field. */
   uint32_t key_size;
   /*! Size of data field. */
   uint32_t data_size;
   /*! Pipe to which group belongs to. */
   int tbl_inst;
   /*! Group flags. */
   uint32_t flags;
   /*! Number of presel IDs. */
   uint32_t num_presel_ids;
   /*! Physical slice id assigned to the group. */
   uint8_t port_pkt_type;
   /*! Physical slice id assigned to the group. */
   uint8_t slice_id;
   /*! Number of entries created in the group. */
   uint32_t ref_count;
   /*! Action resolution Id used in resolving conflicting actions b/w groups. Each action_res_id will be assigned one unique priority. */
   uint16_t action_res_id;
   /*! Offset and width information of all qualifiers in different parts with in the group. Each qualifier may take minimum one HA element and upto the number of offset and width pairs belongs to the qualifier. Number of offset, width pairs of a qualifer depends on the keygen algorithm. */
   bcmfp_ha_blk_info_t qual_offset_info;
   /*! Extractor identification details(part, level, granularity and extractor number) and value assigned to it. This information is maintained only for in use extractors. Each extractor takes two HA elemenets, one to hold the extractor identification details and one for keeping the container id extracted by it. */
   bcmfp_ha_blk_info_t ext_ctrl_info;
   /*! Extractors(in use) Information in all parts of a group. */
   bcmfp_ext_codes_t ext_codes[BCMFP_ENTRY_PARTS_MAX];
   /*! Compression enable/disable indicator. */
   bool compress;
   /*! Types of compressions expected to be applied to entries associated to this group. */
   bool compress_types[BCMFP_COMPRESS_TYPES_MAX];
   /*! Group is enabled/disabled. */
   bool enable;
   /*! SBR Id of the SBR profile created for the group. */
   uint8_t sbr_id;
   /*! SBR LT Template Id of the SBR profile created for the group. */
   uint32_t sbr_template_id;
   /*! Default SBR Id of the SBR profile created for the group. */
   uint8_t def_sbr_id;
   /*! Default SBR LT Template Id of the SBR profile created for the group. */
   uint32_t def_sbr_template_id;
   /*! Operational mode of PDD to be used for this group. */
   bcmfp_pdd_oper_type_t pdd_type;
   /*! Group hint. */
   bcmfp_group_slice_type_t group_slice_type;
} bcmfp_group_oper_info_t;

#define BCMFP_GROUP_OPER_INFO_T_ID 0x6dca3d41034bcf00

typedef struct {
   /*! ID of the bank assigned to FP exact match. */
   uint32_t bank_id;
   /*! Physical table ID of the bank assigned to FP exact match. */
   uint32_t bank_sid;
   /*! Indicator if backup of EM bank is valid. */
   bool valid;
   /*! HA block ID used to backup this EM bank. */
   uint32_t blk_id;
} bcmfp_em_bank_blk_info_t;

#define BCMFP_EM_BANK_BLK_INFO_T_ID 0x2723d32a025d883b

typedef struct {
   /*! Transaction state of the stage. */
   bcmfp_trans_state_t trans_state;
   /*! Stage operational mode. */
   bcmfp_stage_oper_mode_t oper_mode;
   /*! Number of groups created in the stage. */
   uint16_t num_groups;
   /*! Per Group operational information. */
   uint32_t group_oper_info_seg;
   /*! Per presel group operational information. */
   uint32_t presel_group_oper_info_seg;
   /*! Number of entries in keygen profile table. */
   uint16_t num_keygen_prof;
   /*! Reference Count for entries in keygen profile table. Applicable if all slices in a stage share the same keygen program profile table. */
   uint32_t keygen_prof_ref_count_seg;
   /*! Number of entries in action profile table. */
   uint16_t num_action_prof;
   /*! Reference Count for entries in action profile table. This is applicable for stages which have PDD style policy table. */
   uint32_t action_prof_ref_count_seg;
   /*! Number of entries in QOS profile table. */
   uint16_t num_qos_prof;
   /*! Reference Count for entries in QOS action profile table. This is applicable for stages which have PDD style policy table. */
   uint32_t qos_prof_ref_count_seg;
   /*! Number of entries in key attributes profile table. */
   uint16_t num_em_key_attrib_profile;
   /*! Reference Count for entries in Exact match key attributes table. This is applicable for exact match stage. */
   uint32_t em_key_attrib_prof_ref_count_seg;
   /*! Number of entries in SBR profile table. */
   uint16_t num_sbr_profiles;
   /*! Reference Count for entries in EM SBR profile table. This is applicable for exact match stage. */
   uint32_t sbr_prof_ref_count_seg;
   /*! Number of entries in Presel Group profile table. */
   uint16_t num_psg_profiles;
   /*! Reference Count for entries in presel group profile table. This is applicable for exact match stage. */
   uint32_t psg_prof_ref_count_seg;
   /*! Group template id to entry id(s) mapping. */
   uint32_t group_entry_map_seg;
   /*! Number of array elements in group_entry_map_seg array. */
   uint32_t group_entry_map_size;
   /*! Rule template ID to entry ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t rule_entry_map_seg;
   /*! Number of array elements in rule_entry_map_seg array. */
   uint32_t rule_entry_map_size;
   /*! Policy template ID to entry ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t policy_entry_map_seg;
   /*! Number of array elements in policy_entry_map_seg array. */
   uint32_t policy_entry_map_size;
   /*! Presel entry ID to group ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t pse_group_map_seg;
   /*! Number of array elements in pse_group_map_seg array. */
   uint32_t pse_group_map_size;
   /*! Meter template ID to entry ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t meter_entry_map_seg;
   /*! Number of array elements in meter_entry_map_seg array. */
   uint32_t meter_entry_map_size;
   /*! Presel group ID to group ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t psg_group_map_seg;
   /*! Number of array elements in psg_group_map_seg array. */
   uint32_t psg_group_map_size;
   /*! SBR template ID to group ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t sbr_group_map_seg;
   /*! Number of array elements in sbr_group_map_seg array. */
   uint32_t sbr_group_map_size;
   /*! SBR template ID to entry ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t sbr_entry_map_seg;
   /*! Number of array elements in sbr_entry_map_seg array. */
   uint32_t sbr_entry_map_size;
   /*! PDD template ID to group ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t pdd_group_map_seg;
   /*! Number of array elements in pdd_group_map_seg array. */
   uint32_t pdd_group_map_size;
   /*! PDD template ID to entry ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t pdd_entry_map_seg;
   /*! Number of array elements in pdd_entry_map_seg array. */
   uint32_t pdd_entry_map_size;
   /*! Default SBR template ID to group ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t dsbr_group_map_seg;
   /*! Number of array elements in dsbr_group_map_seg array. */
   uint32_t dsbr_group_map_size;
   /*! Default PDD template ID to group ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t dpdd_group_map_seg;
   /*! Number of array elements in dpdd_group_map_seg array. */
   uint32_t dpdd_group_map_size;
   /*! Default policy template ID to group ID mapping. For more information refer comments mentioned for group_entry_map_seg. */
   uint32_t dpolicy_group_map_seg;
   /*! Number of array elements in dpolicy_group_map_seg array. */
   uint32_t dpolicy_group_map_size;
   /*! Counter HW index is allocated during counter configuration based on the COLOR and POOL_ID. */
   uint32_t ctr_hw_index_bitmap_seg;
   /*! Counter entry ID to HW index mapping. */
   uint32_t ctr_id_to_hw_index_map_seg;
   /*! Counter stat ID bitmap to check if the STAT is inserted or not. */
   uint32_t ctr_egr_stats_id_bmp_seg;
   /*! Counter stat ID to byte count mapping. */
   uint32_t ctr_egr_stat_byte_count_map_seg;
   /*! Counter stat ID to packet count mapping. */
   uint32_t ctr_egr_stat_pkt_count_map_seg;
   /*! Counter entry ID to entry ID mapping. For more information refer comments mentioned for group_entry_map_seg. This segment is created only for stages with legacy counters support. */
   uint32_t ctr_entry_map_seg;
   /*! Number of array elements in ctr_entry_map_seg array. */
   uint32_t ctr_entry_map_size;
   /*! PDD profiles operational information. PDD operational information consists of 1. offsets, widths in each part for each action. 2. PDD profile bitmap of all parts. 3. PDD to group/entry association. All stages may not support the PDD style policy. */
   uint32_t pdd_oper_info_seg;
   /*! SBR profiles operational information. It contains SBR profile to group/entry association. All stages may not support the SBR style action resolution. */
   uint32_t sbr_oper_info_seg;
   /*! Number of banks assigned to FP exact match. */
   uint16_t num_em_banks;
   /*! Operational information of FP exact match banks. */
   bcmfp_em_bank_blk_info_t em_bank_blk_info[BCMFP_EM_MAX_BANKS];
   /*! Operational information of ALPM compression. */
   bcmfp_ha_blk_info_t compress_oper_info;
   /*! used to indicate that sbr hw index is allocated by the UFT MGR */
   bool sbr_uftmgr_allocated;
} bcmfp_stage_oper_info_t;

#define BCMFP_STAGE_OPER_INFO_T_ID 0x147af5cf796d6121

typedef struct {
   /*! Maps FP entry IDs that are list compressed with given FP entry ID. */
   uint32_t entry_child_entry_map_seg;
   /*! Size of entry_list_compress_chile_entry_map_seg size in number of bcmfp_ha_blk_info_t elements. */
   uint32_t entry_child_entry_map_size;
   /*! Maps FP entry ID to emtry ID  with which it is list compressed. */
   uint32_t entry_parent_entry_map_seg;
   /*! Size of entry_list_compress_parent_entry_map_seg size in number of bcmfp_ha_blk_info_t elements. */
   uint32_t entry_parent_entry_map_size;
} bcmfp_compress_oper_info_t;

#define BCMFP_COMPRESS_OPER_INFO_T_ID 0xe7a023c42a2c4193

typedef struct {
   /*! PDD bitmap used to encode and decode the raw policy when PDD is attached to an entry. */
   bcmfp_ha_blk_info_t bitmap_info;
   /*! Offset, width information of all actions in the the PDD profile when it is associated to a group. Each action may take minimum one HA element and upto the number of offset and width pairs belongs to the action. */
   bcmfp_ha_blk_info_t offset_info;
   /*! Number of parts(1X/2X/3X) PDD occupies when PDD is attached to an entry. */
   uint8_t num_parts;
   /*! PDD section offsets when the PDD is attached to an entry. */
   bcmfp_ha_blk_info_t section_offset;
   /*! Width of the policy data associated with this PDD. */
   uint32_t policy_width;
   /*! PDD operational mode. */
   bcmfp_group_mode_t pdd_mode;
   /*! PDD operational information type */
   bcmfp_pdd_oper_type_t pdd_type;
   /*! Next actions info block id and block offset. */
   bcmfp_ha_blk_info_t next_actions_info;
} bcmfp_pdd_actions_info_t;

#define BCMFP_PDD_ACTIONS_INFO_T_ID 0x77314bf9facf858d

typedef struct {
   /*! PDD actions operational information */
   bcmfp_ha_blk_info_t actions_info;
} bcmfp_pdd_oper_info_t;

#define BCMFP_PDD_OPER_INFO_T_ID 0x6572606868b010b7

typedef struct {
   /*! Reference count of an object. Used mailnly to track number of times a physical table index is referenced. */
   uint32_t ref_count;
} bcmfp_ref_count_t;

#define BCMFP_REF_COUNT_T_ID 0xa1513e98c3554b63

#endif /* BCMFP_HA_H */
