/**************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by HA parser from YAML formated file.
 * Edits to this file will be lost when it is regenerated.
 * Tool: bcmha/scripts/ha_yml_parser.py
 *
 * $Copyright:.$
 *
 **************************************************************************/
#ifndef BCMLTM_HA_H
#define BCMLTM_HA_H

#include <shr/shr_ha.h>

#define BCMLTM_MAX_COMMITTED_TRANS 32
#define BCMLTM_STATE_NONE 0
#define BCMLTM_STATE_STAGING 1
#define BCMLTM_STATE_COMMITTED 2

/*!
 * \brief LTM Extended State formats.
 *
 * Per-LT state extensions are selected
 * from these types
 *
 * In each bitmap state, the bit position is the Tracking
 * Index for the entry.
 * 1) Local in-use entries
 * 2) Current valid entries
 *
 * 3) Global in-use entries for shared tables.
 */
typedef enum {
   BCMLTM_STATE_TYPE_INUSE_BITMAP = 0,
   BCMLTM_STATE_TYPE_VALID_BITMAP = 1,
   BCMLTM_STATE_TYPE_GLOBAL_BITMAP = 2,
   BCMLTM_STATE_TYPE_COUNT = 3
} bcmltm_state_type_t;

/*!
 * \brief Per-LT additional state data.
 *
 * Some Logical Tables require state
 * beyond the basic elements for all LTs.
 * This structure links the different
 * categories of the LT state for cases where each is needed.
 * All state is
 * stored in HA memory, so HA pointers are used to reference the structure links.
 */
typedef struct {
   /*! Logical Table ID - HA key. */
   uint32_t ltid;
   /*! Size in bytes of any additional table state. */
   uint32_t state_data_size;
   /*! Format of the extended state. */
   bcmltm_state_type_t state_data_type;
   /*! HA Pointer to a this table state. */
   shr_ha_ptr_t state_data_hap;
   /*! Optional HA pointer to additional table state. */
   shr_ha_ptr_t next_state_data_hap;
} bcmltm_lt_state_data_t;

#define BCMLTM_LT_STATE_DATA_T_ID 0x92a699489bf806e2

/*!
 * \brief Per-LT ongoing state.
 *
 * This structure assembles the runtime state
 * of a single LT.  For deployments that enable HA, this state will be updated at
 * each entry or transaction commit.
 */
typedef struct {
   /*! State is initialized - used in HA recovery. */
   bool initialized;
   /*! Logical Table ID - HA key. */
   uint32_t ltid;
   /*! Enable PT status update for LT operation. */
   bool table_op_pt_info_enable;
   /*! Current count of entries in this LT. */
   uint32_t entry_count;
   /*! Maximum permitted count of entries in this LT. */
   uint32_t max_entry_count;
   /*! The length of any LT bitmaps used by this Logical Table. */
   uint32_t bitmap_size;
   /*! Optional HA pointer to a structure tracking additional table state. */
   shr_ha_ptr_t table_state_data_hap;
} bcmltm_lt_state_t;

#define BCMLTM_LT_STATE_T_ID 0x4eafdb0ea2be77e4

/*!
 * \brief Transaction tracking structure.
 *
 * This structure caches the
 * information that must be preserved over the duration of a transaction.  Note
 * that only an Atomic Transaction will have multiple LT entries.  The
 * transaction ID must be identical for each of the LT entries in a transaction.
 */
typedef struct {
   /*! Transaction ID for the LT entry specification of this operation.
 Note that multiple entries may have the same ID.
 Shared ID will bundle the entries into an atomic operation.
 */
   uint32_t trans_id;
   /*! Greatest number of LTIDs recorded for a single transaction. */
   uint32_t max_lt_num;
   /*! Number of LTIDs included in this transaction so far. */
   uint32_t lt_num;
   /*! HA pointer to array of LTIDs in this transaction. */
   shr_ha_ptr_t ltid_list_hap;
} bcmltm_transaction_status_t;

#define BCMLTM_TRANSACTION_STATUS_T_ID 0xf5f0dc844674ad0f

/*!
 * LTM HA block header.
 */
typedef struct {
   /*! Identify if structure is coherent. */
   uint32_t signature;
   /*! Total data length of the block. */
   uint32_t block_size;
   /*! Total data length allocated already. */
   uint32_t allocated_size;
} bcmltm_ha_block_header_t;

#define BCMLTM_HA_BLOCK_HEADER_T_ID 0xa14016cf9125033b

#endif /* BCMLTM_HA_H */
