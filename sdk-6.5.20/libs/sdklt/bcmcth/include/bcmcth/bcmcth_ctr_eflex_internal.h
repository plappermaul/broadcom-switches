/*! \file bcmcth_ctr_eflex_internal.h
 *
 * This file contains defines which are internal to CTR EFLEX.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#ifndef BCMCTH_CTR_EFLEX_INTERNAL_H
#define BCMCTH_CTR_EFLEX_INTERNAL_H

#include <bsl/bsl.h>
#include <shr/shr_debug.h>
#include <shr/shr_bitop.h>

#include <bcmdrd/bcmdrd_pt.h>
#include <bcmlrd/bcmlrd_client.h>
#include <bcmlrd/bcmlrd_table.h>
#include <bcmlrd/bcmlrd_types.h>
#include <bcmimm/bcmimm_int_comp.h>

#include <bcmptm/bcmptm_cci.h>
#include <bcmptm/bcmptm_types.h>
#include <bcmcth/bcmcth_ctr_eflex_lt_info.h>

/*! Ingress direction. */
#define INGRESS 1

/*! Egress direction. */
#define EGRESS  0

/*! Mask to get 32 bits. */
#define U32_MASK 0xFFFFFFFF

/*! Enable. */
#define ENABLE   1

/*! Disable. */
#define DISABLE  0

/*! Maximum number of pipes. */
#define MAX_PIPES_NUM       4

/*! Maximum number of ingress pools. */
#define MAX_ING_POOLS_NUM  32

/*! Maximum number of egress pools. */
#define MAX_EGR_POOLS_NUM  32

/*! Maximum number of counter fields. */
#define MAX_CTR_FIELD_NUM  16

/*! Number of LT whose info is saved. */
#define LT_INFO_NUM 32

/*! Number of CTR_xxx_EFLEX LT whose info is saved. */
#define CTR_EFLEX_LT_INFO_NUM 18

/*! Number of FLEX_STATE_xxx LT whose info is saved. */
#define FLEX_STATE_LT_INFO_NUM 18

/*! Number of LTs with HITBIT monitoring. */
#define HITBIT_LT_NUM 16

/*! Invalid value used during init and validation. */
#define CTR_EFLEX_INVALID_VAL 0xFFFFFFFF

/*! Maximum number of objects. */
#define MAX_OBJECTS 8

/*! Maximum number of counter actions. */
#define MAX_ACTIONS 128

/*! Counter A update mode index */
#define UPDATE_MODE_A_IDX 1

/*! Counter B update mode index */
#define UPDATE_MODE_B_IDX 0

/*! Pipe mode global. */
#define PIPE_OPER_MODE_GLOBAL 0

/*! Pipe mode unique. */
#define PIPE_OPER_MODE_UNIQUE 1

/*! Invalid action profile ID. */
#define CTR_EFLEX_INVALID_ACTION_PROFILE_ID 0

/*! Inactive entry operational state. */
#define CTR_EFLEX_OPER_STATE_INACTIVE 0

/*! Active entry operational state. */
#define CTR_EFLEX_OPER_STATE_ACTIVE 1

/*! Number of counters per entry */
#define NUM_CTRS 2

/*! Generate flex counter LT sid. */
#define CTR_ING_EGR_LT_IDS(x) \
    CTR_ING_##x, \
    CTR_EGR_##x

/*! Generate flex state LT sid. */
#define STATE_ING_EGR_LT_IDS(x) \
    FLEX_STATE_ING_##x, \
    FLEX_STATE_EGR_##x

/*! Hitibt destination lookup index */
#define DST_LKUP_IDX 0

/*! Hitibt source lookup index */
#define SRC_LKUP_IDX 1

/*! Hitbit UFT index */
#define UFT_IDX 1

/*! Hitbit Non-UFT index */
#define NON_UFT_IDX 0

/*! Enable hitbit bank sid to logical id map display */
#define PRINT_HITBIT_MAP 0

/*! Timesync instance used in flex counter & state. */
#define BCMEFLEX_TS_INST 1

/*! Maximum number of flex counter/state objects. */
#define MAX_OBJ_NUM 64

/*! All pipes bitmap. */
#define ALL_PIPES 0xFFFFFFFF

/*!
 * \brief Enhanced flex components.
 */
typedef enum eflex_comp_e {
    /*! Enhanced flex counter. */
    CTR_EFLEX = 0,

    /*! Enhanced flex state. */
    STATE_EFLEX = 1
} eflex_comp_t;

/*!
 * \brief Flex state conditional update comparison operations.
 */
typedef enum state_eflex_compare_e {
    /*! No conditional update. */
    ALWAYS_TRUE = 0,

    /*! Update if stored counter value = computed value. */
    EQUAL = 1,

    /*! Update if stored counter value < computed value. */
    LESSER = 2,

    /*! Update if counter A & counter B */
    AND = 3,

    /*! Update if counter A & (1<<counter B). */
    CHECK_BIT = 4,

    /*! Update if !(counter A & counter B). */
    CHECK_OR = 5

} state_eflex_compare_t;

/*!
 * \brief Flex counter processing drop count mode.
 */
typedef enum ctr_eflex_drop_count_mode_e {
    /*! Count only if packet not being dropped. */
    NO_DROP_COUNT = 0,

    /*! Count only if packet is being dropped. */
    DROP_COUNT = 1,

    /*! Ignore drop status and always count. */
    ALWAYS_COUNT = 2
} ctr_eflex_drop_count_mode_t;

/*!
 * \brief Flex counter source options.
 */
typedef enum ctr_eflex_src_e {
    /*! Use counter value generated by ACTION_PROFILE LT. */
    USE_GENERATED = 0,

    /*! Use packet length. */
    USE_PKTLEN = 1,

    /*! Use stored value of paired counter. */
    USE_PAIRED_COUNTER = 2
} ctr_eflex_src_t;

/*!
 * \brief Flex counter conditional eviction comparison operations.
 */
typedef enum ctr_eflex_evict_comp_e {
    /*! No conditional eviction. */
    NO_EVICT = 0,

    /*! Evict if counter A > counter B. */
    GREATER = 1,

    /*! Evict if counter A < counter B. */
    LESS = 2,

    /*! Evict if counter A == counter B. */
    EQUALS = 3
} ctr_eflex_evict_comp_t;

/*!
 * \brief Flex counter object selection options.
 */
typedef enum ctr_eflex_obj_src_e {
    /*! Use the value 0. */
    USE_0 = 0,

    /*! Use the value 1. */
    USE_1 = 1,

    /*! Use object 1. */
    USE_OBJ_1 = 2,

    /*! Use object 2. */
    USE_OBJ_2 = 3,

    /*! Use object 3. */
    USE_OBJ_3 = 4,

    /*! Use object 4. */
    USE_OBJ_4 = 5,

    /*! Use trigger interval. */
    USE_TRIG_INTERVAL = 6,

    /*! Use range check result 1. */
    USE_RANGE_CHK_1 = 7,

    /*! Use range check result 2. */
    USE_RANGE_CHK_2 = 8,

    /*! Use range check result 3. */
    USE_RANGE_CHK_3 = 9,

    /*! Use range check result 4. */
    USE_RANGE_CHK_4 = 10,

    /*! Use object 5. */
    USE_OBJ_5 = 11,

    /*! Use object 6. */
    USE_OBJ_6 = 12
} ctr_eflex_obj_src_t;

/*!
 * \brief Flex counter start trigger types.
 */
typedef enum ctr_eflex_start_trigger_e {
    /*! Use time as type. */
    TIME = 0,

    /*! Use condition as type. */
    START_CONDITION = 1,
} ctr_eflex_start_trigger_t;

/*!
 * \brief Flex counter stop trigger types.
 */
typedef enum ctr_eflex_stop_trigger_e {
    /*! Use period as type. */
    PERIOD = 0,

    /*! Use condition as type. */
    STOP_CONDITION = 1,

    /*! Use action count  as type. */
    ACTION_COUNT = 2
} ctr_eflex_stop_trigger_t;

/*!
 * \brief Flex counter time scale for a single trigger period.
 */
typedef enum ctr_eflex_scale_e {
    /*! Unlimited collection. */
    SCALE_INFINITE = 0,

    /*! 128 nanoseconds. */
    SCALE_128_NSEC = 1,

    /*! 512 nanoseconds. */
    SCALE_512_NSEC = 2,

    /*! 1024 nanoseconds. */
    SCALE_1024_NSEC = 3,

    /*! Approximately 8.192 microseconds. */
    SCALE_8_USEC = 4,

    /*! Approximately 131 microseconds. */
    SCALE_131_USEC = 5,

    /*! Approximately 1.048 milliseconds. */
    SCALE_1_MSEC = 6,

    /*! Approximately 8.192 milliseconds. */
    SCALE_8_MSEC = 7,

     /*! Approximately 134 milliseconds. */
    SCALE_134_MSEC = 8,

    /*! Approximately 1 second. */
    SCALE_1_SEC = 9,

    /*! Approximately 8.59 seconds. */
    SCALE_8_SEC = 10
} ctr_eflex_scale_t;

/*!
 * \brief Flex state  instances.
 */
typedef enum state_eflex_inst_e {
    /*! Ingress post lookup instance. */
    ING_POST_LKUP_INST = 0,

    /*! Ingress post fowarding instance. */
    ING_POST_FWD_INST = 1
} state_eflex_inst_t;


/*!
 * \brief Flex state egress  instances.
 */
typedef enum state_eflex_egr_inst_e {
    /*! egress post lookup instance. */
    EGR_POST_LKUP_INST = 0,

    /*! egress post fowarding instance. */
    EGR_POST_FWD_INST =1
} state_eflex_egr_inst_t;

/*!
 * \brief Flex counter shadow pool config.
 */
typedef enum ctr_eflex_shadow_config_e {
    /*! No changed to shadow pool config. */
    SHADOW_NOOP = 0,

    /*!  Shadow pool is enabled. */
    SHADOW_ENABLE = 1,

    /*!  Shadow pool is disabled. */
    SHADOW_DISABLE = 2
} ctr_eflex_shadow_config_t;

/*!
 * \brief Flex counter/state object bit offsets.
 */
typedef struct bcmcth_ctr_eflex_obj_bit_offset_s {
    /*! Min bit of object. */
    uint16_t minbit;

    /*! Max bit of object. */
    uint16_t maxbit;
} bcmcth_ctr_eflex_obj_bit_offset_t;

/*!
 * \brief LT counter field info structure.
 */
typedef struct ctr_eflex_field_s {
    /*! First bit of field. */
    uint16_t minbit;

    /*! Last bit of field. */
    uint16_t maxbit;
} ctr_eflex_field_t;

/*!
 * \brief Flex counter operand profile info structure.
 */
typedef struct ctr_eflex_op_profile_data_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! Enhanced flex component. */
    eflex_comp_t comp;

    /*! Operation flags. */
    uint64_t req_flags;

    /*! Operand profile ID. */
    uint32_t op_profile_id;

    /*! Operand profile index. */
    uint32_t op_profile_index;

    /*! Pipe number. */
    uint32_t pipe_idx;

    /*! Flex state instance. */
    state_eflex_inst_t inst;

    /*! Flex state egress  instance. */
    state_eflex_egr_inst_t egr_inst;

    /*! First pipe index being configured. */
    uint32_t start_pipe_idx;

    /*! Last pipe index being configured. */
    uint32_t end_pipe_idx;

    /*! Object 1 selection result. */
    ctr_eflex_obj_src_t obj_1;

    /*! Object 2 selection result. */
    ctr_eflex_obj_src_t obj_2;

    /*! Mask size for object 1. */
    uint32_t mask_size_1;

    /*! Mask size for object 2. */
    uint32_t mask_size_2;

    /*! Right shift amount for object 1. */
    uint32_t shift_1;

    /*! Left shift amount for object 2. */
    uint32_t shift_2;

    /*! Object 3 selection result. */
    ctr_eflex_obj_src_t obj_3;

    /*! Mask size for object 3. */
    uint32_t mask_size_3;

    /*! Left shift amount for object 2. */
    uint32_t shift_3;

    /*! Left shift amount for object 2. */
    uint32_t shift_4;

    /*! Left shift amount for object 2. */
    uint32_t shift_5;

} ctr_eflex_op_profile_data_t;

/*!
 * \brief Flex Counter range check profile info structure.
 */
typedef struct ctr_eflex_range_chk_data_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! Enhanced flex component. */
    eflex_comp_t comp;

    /*! Operation flags. */
    uint64_t req_flags;

    /*! Range check profile ID. */
    uint32_t range_chk_id;

    /*! Pipe number. */
    uint32_t pipe_idx;

    /*! Flex state instance. */
    state_eflex_inst_t inst;

    /*! Flex state egress  instance. */
    state_eflex_egr_inst_t egr_inst;

    /*! First pipe index being configured. */
    uint32_t start_pipe_idx;

    /*! Last pipe index being configured. */
    uint32_t end_pipe_idx;

    /*! Object whose value is to be range checked. */
    uint32_t obj_select;

    /*! Range checker number. */
    uint32_t range_chk_idx;

    /*! Range checker bank number. */
    uint32_t bank_num;

    /*! Minimum value for range checker. */
    uint32_t min;

    /*! Maximum value for range checker. */
    uint32_t max;
} ctr_eflex_range_chk_data_t;

/*!
 * \brief Flex counter trigger info structure.
 */
typedef struct ctr_eflex_trigger_data_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! Enhanced flex component. */
    eflex_comp_t comp;

    /*! Operation flags. */
    uint64_t req_flags;

    /*! Counter action profile ID. */
    uint32_t action_profile_id;

    /*! Counter action ID. */
    uint32_t action_id;

    /*! Pipe number. */
    uint32_t pipe_idx;

    /*! Flex state instance. */
    state_eflex_inst_t inst;

    /*! Flex state egress instance. */
    state_eflex_egr_inst_t egr_inst;

    /*! First pipe index being configured. */
    uint32_t start_pipe_idx;

    /*! Last pipe index being configured. */
    uint32_t end_pipe_idx;

    /*! Enable/Disable trigger. */
    uint32_t trigger;

    /*! Start trigger type. */
    ctr_eflex_start_trigger_t start;

    /*! Stop trigger type. */
    ctr_eflex_stop_trigger_t stop;

    /*! Start value. */
    uint32_t start_value;

    /*! Stop value. */
    uint32_t stop_value;

    /*! Condition mask. */
    uint32_t cond_mask;

    /*! Start time. */
    uint64_t start_time;

    /*! Number of periods. */
    uint32_t num_periods;

    /*! Duration of a single period. */
    ctr_eflex_scale_t scale;

    /*! Number of interval shift. */
    uint32_t interval_shift;

    /*! Number of interval size. */
    uint32_t interval_size;

    /*! Operational state. */
    bool oper_state;

    /*! Number of times action can be hit. */
    uint32_t num_actions;

    /*! comparison function trigger stop. */
     bool compare_start;

    /*! comparison function trigger start. */
     bool compare_stop;

} ctr_eflex_trigger_data_t;

/*!
 * \brief Flex counter action zone info.
 */
typedef enum ctr_eflex_action_zone_e {
    /*! Fixed action zone. */
    FIXED = 0,

    /*! Flex action zone. */
    FLEX
} ctr_eflex_action_zone_t;

/*!
 * \brief Flex counter group action profile info structure.
 */
typedef struct ctr_eflex_group_action_data_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! Enhanced flex component. */
    eflex_comp_t comp;

    /*! Operation flags. */
    uint64_t req_flags;

    /*! Group profile ID. */
    uint32_t group_profile_id;

    /*! Group ID. */
    uint32_t group_id;

    /*! Group action profile ID. */
    uint32_t action_profile_id;

    /*! Group counter action. */
    uint32_t action_id;

    /*! Pipe number. */
    uint32_t pipe_idx;

    /*! Flex state instance. */
    state_eflex_inst_t inst;

    /*! First pipe index being configured. */
    uint32_t start_pipe_idx;

    /*! Last pipe index being configured. */
    uint32_t end_pipe_idx;

    /*! Associated action profile IDs. */
    uint32_t action_profile_id_map[MAX_ACTIONS];

    /*! Associated counter actions. */
    uint32_t action_id_map[MAX_ACTIONS];

    /*! Number of associated counter actions. */
    uint32_t num_actions;

    /*! Flex state egress instance. */
    state_eflex_egr_inst_t egr_inst;

    /*! Operational state. */
    bool oper_state;
} ctr_eflex_group_action_data_t;

/*! Enhanced flex state update sources. */
typedef enum flex_state_update_src_e {

    /*! Use the current value computed. */
    UPDATE_NOOP,

    /*! Use the old counter value in bus/memory. */
    OLD_VALUE,

    /*!
     * Use CVALUE computed by
     * STATE_ING/EGR_EFLEX_ACTION_PROFILE.STATE_A/B_SRC_COMP.
     */
    CVALUE,

    /*!
     * if STATE_ING/EGR_EFLEX_ACTION_PROFILE.UPDATE_COMPARE_A/B == TRUE
     * use STATE_ING/EGR_EFLEX_ACTION_PROFILE.STATE_SRC_UPD_TRUE_A/B
     * if  STATE_ING/EGR_EFLEX_ACTION_PROFILE UPDATE_COMPARE_A/B = FALSE
     * use STATE_ING/EGR_EFLEX_ACTION_PROFILE.STATE_SRC_UPD_FALSE_A/B
     */
    CVALUE_COMPARE
}flex_state_update_src_t;

/*! Enhanced flex state counter width. */

typedef enum flex_state_counter_width_e {
    /*! Total width of flex counter index is 64. */
    COUNTER_WIDTH_64,

    /*! Total width of flex counter index is 32. */
    COUNTER_WIDTH_32
}flex_state_counter_width_t;

/*!
 * \brief Flex state action profile info structure.
 */
typedef struct state_eflex_action_profile_data_s {
    /*! Flex state ingress instance. */
    state_eflex_inst_t     inst;

    /*! Flex state egressinstance. */
    state_eflex_egr_inst_t egr_inst;

    /*! Compare operation for conditional update. */
    state_eflex_compare_t upd_compare_op[NUM_CTRS];

    /*! Counter update mode if comparison operation returns true. */
    bcmptm_cci_update_mode_t upd_true_mode[NUM_CTRS];

    /*! Counter update mode if comparison operation returns false. */
    bcmptm_cci_update_mode_t upd_false_mode[NUM_CTRS];

    /*! OPERAND_PROFILE LT index to calculate counter value for comparison. */
    uint32_t op_profile_id_comp[NUM_CTRS];

    /*!
     * OPERAND_PROFILE LT index to calculate counter value
     * if comparison operation returns true.
     */
    uint32_t op_profile_id_upd_true[NUM_CTRS];

    /*!
     * OPERAND_PROFILE LT index to calculate counter value
     * if comparison operation returns false.
     */
    uint32_t op_profile_id_upd_false[NUM_CTRS];

    /*! OP_PROFILE PT index to calculate counter value for comparison. */
    uint32_t op_profile_comp[NUM_CTRS];

    /*!
     * OP_PROFILE PT index to calculate counter value
     * if comparison operation returns true.
     */
    uint32_t op_profile_upd_true[NUM_CTRS];

    /*!
     * OP_PROFILE PT index to calculate counter value
     * if comparison operation returns false.
     */
    uint32_t op_profile_upd_false[NUM_CTRS];

    /*! Value to use for counter comparison. */
    ctr_eflex_src_t ctr_src_comp[NUM_CTRS];

    /*! value to use for counter if comparison operation returns true. */
    ctr_eflex_src_t ctr_src_upd_true[NUM_CTRS];

    /*! Value to use for counter if comparison operation returns false. */
    ctr_eflex_src_t ctr_src_upd_false[NUM_CTRS];

    /*! Determines the source of mem update for ctr A. */
    flex_state_update_src_t a_mem_update;

    /*! Determines the source of mem update for ctr B. */
    flex_state_update_src_t b_mem_update;

    /*! Determines the source of bus update for ctr A. */
    flex_state_update_src_t a_bus_update;

    /*! Determines the source of bus update for ctr A. */
    flex_state_update_src_t b_bus_update;

    /*! Enable truth table lookup for the action. */
    bool                  truth_table_en;

    /*! Truth table instance to be used for this action. */
    uint8_t                    truth_table_instance;

    /*! flex state counter table width. */
    flex_state_counter_width_t width;

} state_eflex_action_profile_data_t;

/*!
 * \brief Flex counter action profile info structure.
 */
typedef struct ctr_eflex_action_profile_data_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! Enhanced flex component. */
    eflex_comp_t comp;

    /*! Operation flags. */
    uint64_t req_flags;

    /*! Action profile ID. */
    uint32_t action_profile_id;

    /*! Counter action ID. */
    uint32_t action_id;

    /*! Counter action zone. */
    ctr_eflex_action_zone_t zone;

    /*! Pool ID. */
    uint32_t pool_idx;

    /*! Pool ID of first pool being configured. */
    uint32_t start_pool_idx;

    /*! Pool ID of last pool being configured. */
    uint32_t end_pool_idx;

    /*! Base index within first pool being configured. */
    uint32_t start_base_idx;

    /*! Base index within last pool being configured. */
    uint32_t end_base_idx;

    /*! Pipe number. */
    uint32_t pipe_idx;

    /*! First pipe index being configured. */
    uint32_t start_pipe_idx;

    /*! Last pipe index being configured. */
    uint32_t end_pipe_idx;

    /*! Base index calculation mode. */
    uint32_t base_idx_auto;

    /*! Base index. */
    uint32_t base_idx;

    /*! Computer base index value if auto mode is set. */
    uint32_t base_idx_oper;

    /*! Enable shadow pool support. */
    uint32_t shadow;

    /*! Pool ID of first shadow pool being configured. */
    uint32_t start_shdw_pool_idx;

    /*! Pool ID of last shadow pool being configured. */
    uint32_t end_shdw_pool_idx;

    /*! Total number of counters. */
    uint32_t num_ctrs;

    /*! Counter mode. */
    bcmptm_cci_ctr_mode_t ctr_mode;

    /*! Counter update mode for each counter. */
    bcmptm_cci_update_mode_t ctr_update_mode[NUM_CTRS];

    /*! Number of update modes. */
    size_t num_update_mode;

    /*! Objects. */
    uint32_t obj[MAX_OBJECTS];

    /*! OPERAND_PROFILE LT index to calculate counter index. */
    uint32_t op_profile_id_ctr_index;

    /*! OPERAND_PROFILE LT index to calculate counter A value. */
    uint32_t op_profile_id_ctr_a;

    /*! OPERAND_PROFILE LT index to calculate counter B value. */
    uint32_t op_profile_id_ctr_b;

    /*! OP_PROFILE PT index to calculate counter index. */
    uint32_t op_profile_ctr_index;

    /*! OP_PROFILE PT index to calculate counter A value. */
    uint32_t op_profile_ctr_a;

    /*! OP_PROFILE PT index to calculate counter B value. */
    uint32_t op_profile_ctr_b;

    /*! Counter processing drop count mode. */
    ctr_eflex_drop_count_mode_t count_on_rule_drop;

    /*! Value to use for counter A. */
    ctr_eflex_src_t ctr_src_a;

    /*! Value to use for counter B. */
    ctr_eflex_src_t ctr_src_b;

    /*! Weighted average value. */
    uint32_t ctr_val_data;

    /*! Conditional eviction comparison operation. */
    ctr_eflex_evict_comp_t evict_comp;

    /*! Counter B conditional eviction reset enable. */
    uint32_t evict_reset;

    /*! Counter hardware drop enable. */
    uint32_t count_on_hw_drop;

    /*! Counter egress mirror pkt enable. */
    uint32_t count_on_mirror_egress;

    /*! Flex state data. */
    state_eflex_action_profile_data_t state_ext;

} ctr_eflex_action_profile_data_t;

/*!
 * \brief Counter mode info structure.
 */
typedef struct ctr_eflex_ctr_mode_data_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! Pool ID of first pool being configured. */
    uint32_t start_pool_idx;

    /*! Pool ID of last pool being configured. */
    uint32_t end_pool_idx;

    /*! Section index within first pool being configured. */
    uint32_t start_section_idx;

    /*! Section index within last pool being configured. */
    uint32_t end_section_idx;

    /*! Pipe number. */
    uint32_t pipe_idx;

    /*! Counter mode. */
    bcmptm_cci_ctr_mode_t ctr_mode;

    /*! Counter update mode for each counter. */
    bcmptm_cci_update_mode_t ctr_update_mode[NUM_CTRS];

    /*! Number of update modes. */
    size_t num_update_mode;
} ctr_eflex_ctr_mode_data_t;

/*!
 * \brief Stats info structure.
 */
typedef struct ctr_eflex_ctr_stats_data_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! Enhanced flex component. */
    eflex_comp_t comp;

    /*! Counter index. */
    uint32_t index;

    /*! Action profile ID. */
    uint32_t action_profile_id;

    /*! New CTR_A_UPPER value. */
    uint64_t new_ctr_a_upper;

    /*! New CTR_A_LOWER value. */
    uint64_t new_ctr_a_lower;

    /*! New CTR_B value. */
    uint64_t new_ctr_b;

    /*! Update CTR_A_UPPER value. */
    bool upd_ctr_a_upper;

    /*! Update CTR_A_LOWER value. */
    bool upd_ctr_a_lower;

    /*! Update CTR_B value. */
    bool upd_ctr_b;
} ctr_eflex_stats_data_t;

/*!
 * \brief Pool memory management structure.
 */
typedef struct ctr_eflex_pool_list_s {
    /*! Maximum number of sections within the pool. */
    uint32_t max_track;

    /*! Bitmap representing sections within the pool. */
    SHR_BITDCL *inuse_bitmap;
} ctr_eflex_pool_list_t;

/*!
 * \brief Enhanced flex state device specific information
 */
typedef struct bcmcth_state_eflex_device_info_s {
    /*! Number of ingress instances */
    size_t num_ingress_instance;

    /*! Number of ingress instances */
    size_t num_egress_instance;
} bcmcth_state_eflex_device_info_t;

/*!
 * \brief Enhanced flex counter device specific information
 */
typedef struct bcmcth_ctr_eflex_device_info_s {
    /*! Number of ingress pools */
    size_t num_ingress_pools;

    /*! Number of egress pools */
    size_t num_egress_pools;

    /*! Number of counters per section */
    size_t num_ctr_section;

    /*! Number of pipes */
    size_t num_pipes;

    /*! Number of pipe instances */
    size_t num_pipe_instance;

    /*! Number of ingress flex counter actions */
    size_t num_ingress_action_id;

    /*! Number of egress flex counter actions */
    size_t num_egress_action_id;

    /*! Number of reserved actions */
    size_t num_rsvd_action_id;

    /*! Number of operand profile ids */
    size_t num_op_profile_id;

    /*! Number of range checker banks */
    size_t num_range_checker;

    /*! Number of range checkers per bank */
    size_t num_range_checker_per_bank;

    /*! Number of counter objects */
    size_t num_objs;

    /*! Number of simultaneous ingress actions. */
    size_t num_ing_actions;

    /*! Number of simultaneous egress actions. */
    size_t num_egr_actions;

    /*! Number of ingress counter attribute selector. */
    size_t num_ing_attr_sel;

    /*! Number of egress counter attribute selector. */
    size_t num_egr_attr_sel;

    /*! Number of ingress counter attribute offset. */
    size_t num_ing_attr_offset;

    /*! Number of egress counter attribute offset. */
    size_t num_egr_attr_offset;

    /*! Number of counter per offset pool. */
    size_t num_ctr_per_offset_pool;

    /*! Number of slim counters per entry. */
    size_t num_slim_ctrs;

    /*! Number of hitbits per counter. */
    size_t num_hitbit_ctr;

    /*! Slim counter is organised row wise. */
    bool slim_ctr_row;

    /*! Flex state extended device info structure. */
    bcmcth_state_eflex_device_info_t state_ext;

    /*! Number of global counter objects */
    size_t num_global_objs;
} bcmcth_ctr_eflex_device_info_t;

/*!
 * \brief Enhanced flex counter table info structure
 */
typedef struct ctr_eflex_table_info_s {
    /*! LT sid */
    bcmlrd_sid_t lt_sid;

    /*! Number of key fields in LT */
    size_t num_key_fields;

    /*! Number of data fields in LT */
    size_t num_data_fields;

    /*! Number of read-only data fields in LT */
    size_t num_read_only_fields;
} ctr_eflex_table_info_t;

/*!
 * \brief Eflex counter enum values
 */
typedef struct ctr_eflex_enum_s {
    /*! OPERATIONAL_STATE ACTIVE */
    uint32_t oper_state_active;

    /*! OPERATIONAL_STATE INACTIVE */
    uint32_t oper_state_inactive;

    /*! TABLE_ID INVALID_LT */
    uint32_t invalid_lt_id;
} ctr_eflex_enum_t;

/*!
 * \brief Enhanced flex counter hitbit LT info structure
 */
typedef struct ctr_eflex_hitbit_lt_info_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! LT id. */
    uint32_t lt_id;

    /*! Enable hitbit for dst/src lookup */
    bool enable[2];

    /*! Pipe number. */
    uint32_t pipe_idx;

    /*! Pool ID. */
    uint32_t pool_idx[2];

    /*! Pool sid. */
    bcmdrd_sid_t pool_sid[2][2];

    /*! Base index. */
    uint32_t base_idx[2];

    /*! Absolute base index. */
    uint32_t abs_base_idx[2];

    /*! Hitbit configured for dst/src */
    bool is_hitbit[2];

    /*! SLIM mode configured for dst/src */
    bool is_slim[2];

    /*! Shift factor based on hash entry width */
    uint32_t shift_factor;

    /*! Multiplication factor to get absolute index from base index */
    uint32_t factor[2];
} ctr_eflex_hitbit_lt_info_t;

/*!
 * \brief Enhanced flex state control extended structure
 */
typedef struct state_eflex_control_ext_s {
    /*! Ingress pool list info. */
    ctr_eflex_pool_list_t ing_pool_list_b[MAX_ING_POOLS_NUM][MAX_PIPES_NUM];

    /*! Ingress action id info. */
    ctr_eflex_pool_list_t ing_action_id_list_b[MAX_PIPES_NUM];

    /*! Ingress operand profile id info. */
    ctr_eflex_pool_list_t ing_op_id_list_b[MAX_PIPES_NUM];

    /*! Ingress range checker profile id info. */
    ctr_eflex_pool_list_t ing_range_chk_id_list_b[MAX_PIPES_NUM];

    /*! Ingress pool list info. */
    ctr_eflex_pool_list_t egr_pool_list_b[MAX_ING_POOLS_NUM][MAX_PIPES_NUM];

    /*! Ingress action id info. */
   ctr_eflex_pool_list_t egr_action_id_list_b[MAX_PIPES_NUM];

    /*! Ingress operand profile id info. */
    ctr_eflex_pool_list_t egr_op_id_list_b[MAX_PIPES_NUM];

    /*! Ingress range checker profile id info. */
    ctr_eflex_pool_list_t egr_range_chk_id_list_b[MAX_PIPES_NUM];

    /*! Total number of counters in each egress pool. */
    size_t egr_pool_ctr_num_b[MAX_EGR_POOLS_NUM];
} state_eflex_control_ext_t;

/*!
 * \brief Enhanced flex counter control structure
 */
typedef struct ctr_eflex_control_s {
    /*! Device info. */
    bcmcth_ctr_eflex_device_info_t *ctr_eflex_device_info;

    /*! Total number of counters in each ingress pool. */
    size_t ing_pool_ctr_num[MAX_ING_POOLS_NUM];

    /*! Total number of counters in each egress pool. */
    size_t egr_pool_ctr_num[MAX_EGR_POOLS_NUM];

    /*! Ingress pool list info. */
    ctr_eflex_pool_list_t ing_pool_list[MAX_ING_POOLS_NUM][MAX_PIPES_NUM];

    /*! Egress pool list info. */
    ctr_eflex_pool_list_t egr_pool_list[MAX_EGR_POOLS_NUM][MAX_PIPES_NUM];

    /*! Ingress entry size in words. */
    uint32_t ing_entry_wsize;

    /*! Egress entry size in words. */
    uint32_t egr_entry_wsize;

    /*! Ingress number of counter fields. */
    uint32_t ing_ctr_field_num;

    /*! Egress number of counter fields. */
    uint32_t egr_ctr_field_num;

    /*! Number of LT whose field info is saved. */
    uint32_t lt_info_num;

    /*! Ingress LT counter field info */
    ctr_eflex_field_t ing_lt_field[MAX_CTR_FIELD_NUM];

    /*! Egress LT counter field info */
    ctr_eflex_field_t egr_lt_field[MAX_CTR_FIELD_NUM];

    /*! LT info */
    ctr_eflex_table_info_t ctr_eflex_field_info[LT_INFO_NUM];

    /*! Ingress action id info. */
    ctr_eflex_pool_list_t ing_action_id_list[MAX_PIPES_NUM];

    /*! Egress action id info. */
    ctr_eflex_pool_list_t egr_action_id_list[MAX_PIPES_NUM];

    /*! Ingress operand profile id info. */
    ctr_eflex_pool_list_t ing_op_id_list[MAX_PIPES_NUM];

    /*! Egress operand profile id info. */
    ctr_eflex_pool_list_t egr_op_id_list[MAX_PIPES_NUM];

    /*! Ingress range checker profile id info. */
    ctr_eflex_pool_list_t ing_range_chk_id_list[MAX_PIPES_NUM];

    /*! Egress range checker profile id info. */
    ctr_eflex_pool_list_t egr_range_chk_id_list[MAX_PIPES_NUM];

    /*! List of eflex counter field enum values. */
    ctr_eflex_enum_t ctr_eflex_enum;

    /*! Ingress hitbit LT info. */
    ctr_eflex_hitbit_lt_info_t ing_hitbit_lt_info[HITBIT_LT_NUM];

    /*! Egress hitbit LT info. */
    ctr_eflex_hitbit_lt_info_t egr_hitbit_lt_info[HITBIT_LT_NUM];

    /*! CTR_ING_EFLEX_ACTION_PROFILE LT info */
    ctr_eflex_action_profile_lt_info_t ing_action_lt_info;

    /*! CTR_EGR_EFLEX_ACTION_PROFILE LT info */
    ctr_eflex_action_profile_lt_info_t egr_action_lt_info;

    /*! CTR_ING_EFLEX_OBJ_INFO LT info */
    ctr_eflex_obj_info_lt_info_t ing_obj_info_lt_info;

    /*! CTR_EGR_EFLEX_OBJ_INFO LT info */
    ctr_eflex_obj_info_lt_info_t egr_obj_info_lt_info;

    /*! CTR_ING_EFLEX_OBJ_QUANTIZATION LT info */
    ctr_eflex_obj_quant_lt_info_t ing_obj_quant_lt_info;

    /*! CTR_EGR_EFLEX_OBJ_QUANTIZATION LT info */
    ctr_eflex_obj_quant_lt_info_t egr_obj_quant_lt_info;

    /*! Flex state extended control structure. */
    state_eflex_control_ext_t state_ext;
} ctr_eflex_control_t;

/*!
 * \brief error stats info structure.
 */
typedef struct ctr_eflex_ctr_error_stats_data_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! Enhanced flex component. */
    eflex_comp_t comp;

    /*! Flex state instance. */
    state_eflex_inst_t inst;

    /*! Flex state egress  instance. */
    state_eflex_egr_inst_t egr_inst;

    /*! Pipe number. */
    uint32_t pipe_idx;

    /*! First pipe index being configured. */
    uint32_t start_pipe_idx;

    /*! Last pipe index being configured. */
    uint32_t end_pipe_idx;

    /*! Pipe operating mode. */
    uint8_t pipe_unique;

    /*! New ACTION_MISCONFIG value. */
    uint64_t action_misconfig;

    /*! New TOO_MANY_ACTIONS value. */
    uint64_t too_many_actions;

    /*! Update ACTION_MISCONFIG value. */
    bool upd_action_misconfig;

    /*! Update TOO_MANY_ACTIONS value. */
    bool upd_too_many_actions;
} ctr_eflex_error_stats_data_t;

/*!
 * \brief hitbit control info structure.
 */
typedef struct ctr_eflex_hitbit_ctrl_data_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! Enhanced flex component. */
    eflex_comp_t comp;

    /*! Logical table id. */
    uint32_t lt_id;

    /*! Pipe number. */
    uint32_t pipe_idx;

    /*! Pipe operating mode. */
    uint8_t pipe_unique;

    /*! Destination group action profile ID. */
    uint32_t dst_grp_action_profile_id;

    /*! Source group action profile ID. */
    uint32_t src_grp_action_profile_id;

    /*! Destination action profile ID. */
    uint32_t dst_action_profile_id;

    /*! Source action profile ID. */
    uint32_t src_action_profile_id;

    /*! Operational state. */
    bool oper_state;
} ctr_eflex_hitbit_ctrl_data_t;

/*!
 * \brief obj quantization info structure.
 */
typedef struct ctr_eflex_ctr_obj_quant_data_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! Enhanced flex component. */
    eflex_comp_t comp;

    /*! Operation flags. */
    uint64_t req_flags;

    /*! Flex state instance. */
    state_eflex_inst_t inst;

    /*! Flex state egress  instance. */
    state_eflex_egr_inst_t egr_inst;

    /*! Pipe number. */
    uint32_t pipe_idx;

    /*! First pipe index being configured. */
    uint32_t start_pipe_idx;

    /*! Last pipe index being configured. */
    uint32_t end_pipe_idx;

    /*! Pipe operating mode. */
    uint8_t pipe_unique;

    /*! Objects. */
    uint32_t obj[MAX_OBJECTS];

    /*! Enable object quantization. */
    uint32_t quantize[MAX_OBJECTS];

    /*! Enable 32-bit mode for objects 0 and 1. */
    uint32_t obj_0_1_mode;

    /*! Enable 32-bit mode for objects 2 and 3. */
    uint32_t obj_2_3_mode;
} ctr_eflex_obj_quant_data_t;

/*!
 * \brief truth table structure.
 */
typedef struct ctr_eflex_ctr_truth_table_data_s {
    /*! Ingress/egress Direction. */
    bool ingress;

    /*! Enhanced flex component. */
    eflex_comp_t comp;

    /*! Operation flags. */
    uint64_t req_flags;

    /*! Flex state instance. */
    state_eflex_inst_t inst;

    /*! Flex state egress  instance. */
    state_eflex_egr_inst_t egr_inst;

    /*! Pipe number. */
    uint32_t pipe_idx;

    /*! First pipe index being configured. */
    uint32_t start_pipe_idx;

    /*! Last pipe index being configured. */
    uint32_t end_pipe_idx;

    /*! Pipe operating mode. */
    uint8_t pipe_unique;

    /*! Pool ID. */
    uint32_t pool;

    /*! truth table instance. */
    uint32_t truth_table_instance;

    /*! index. */
    uint32_t index;

    /*! index. */
    uint32_t output;

} ctr_eflex_truth_table_data_t;

/*! Enhanced flex counter control structure per unit. */
extern ctr_eflex_control_t *ctr_eflex_ctrl[BCMDRD_CONFIG_MAX_UNITS];

/*! Enhanced flex counter ingress pipe mode per unit. */
extern uint8_t ctr_eflex_ing_pipe_opermode[BCMDRD_CONFIG_MAX_UNITS];

/*! Enhanced flex counter egress pipe mode per unit. */
extern uint8_t ctr_eflex_egr_pipe_opermode[BCMDRD_CONFIG_MAX_UNITS];

/*! Enhanced flex state control structure. */
extern ctr_eflex_control_t *state_eflex_ctrl[BCMDRD_CONFIG_MAX_UNITS];

/*!
 * \brief Get enhanced flex component control structure
 *
 * \param [in] unit    Unit number.
 * \param [in] comp    Enhanced flex component.
 * \param [inout] ctrl Flex control structure.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_eflex_ctrl_get(int unit,
                      eflex_comp_t comp,
                      ctr_eflex_control_t **ctrl);

/*!
 * \brief Debug print ACTION_PROFILE entry info.
 *
 * \param [in] unit    Unit number.
 * \param [in] insert  Insert/Update opertation.
 * \param [in] entry   ACTION_PROFILE LT entry.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_eflex_action_profile_debug_print(int unit,
                                        bool insert,
                                        ctr_eflex_action_profile_data_t *entry);
/*!
 * \brief Initialize enhanced flex counter internal structures
 *
 * \param [in] unit    Unit number.
 * \param [in] warm    Indicates cold or warm boot.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_MEMORY, SHR_E_INTERNAL, SHR_E_PARAM Error.
 */
int bcmcth_ctr_eflex_db_init(int unit, bool warm);

/*!
 * \brief Cleanup enhanced flex counter internal structures
 *
 * \param [in] unit    Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM Error.
 */
int bcmcth_ctr_eflex_db_cleanup(int unit);

/*!
 * \brief Initialize enhanced flex state internal structures
 *
 * \param [in] unit    Unit number.
 * \param [in] warm    Indicates cold or warm boot.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_MEMORY, SHR_E_INTERNAL, SHR_E_PARAM Error.
 */
int bcmcth_state_eflex_db_init(int unit, bool warm);

/*!
 * \brief Cleanup enhanced flex state internal structures
 *
 * \param [in] unit    Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM Error.
 */
int bcmcth_state_eflex_db_cleanup(int unit);

/*!
 * \brief Get flex counter or flex state pool SID
 *
 * \param [in] unit    Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 * \param [in] ctr_inst    Flex counter instance.
 * \param [in] state_inst    Flex state ingress instance.
 * \param [in] pool_idx    Pool number of table.
 * \param [out] ctr_table_sid Counter table SID for this pool.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM Illegal pool number.
 */
int
bcmcth_eflex_pool_sid_get(int unit,
                          bool ingress,
                          eflex_comp_t comp,
                          uint32_t ctr_inst,
                          uint32_t state_inst,
                          uint32_t pool_idx,
                          bcmdrd_sid_t *ctr_table_sid);
/*!
 * \brief Create pool manager resources.
 *
 * \param [in] unit    Unit number.
 * \param [in] comp    Enhanced Flex component.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_MEMORY, SHR_E_PARAM Error.
 */
int bcmcth_ctr_eflex_pool_mgr_create(int unit, eflex_comp_t comp);

/*!
 * \brief Destroy pool manager resources.
 *
 * \param [in] unit    Unit number.
 * \param [in] comp    Enhanced Flex component.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM Error.
 */
int bcmcth_ctr_eflex_pool_mgr_destroy(int unit, eflex_comp_t comp);

/*!
 * \brief Allocate counters
 *
 * \param [in] unit    Unit number.
 * \param [in] warm    Warmboot.
 * \param [in] entry   IMM LT entry info for requested counters.
 * \param [out] base_idx Base index of allocated counters.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_RESOURCE Requested number of counters unavailable.
 */
int
bcmcth_ctr_eflex_pool_mgr_ctr_alloc(int unit,
                                    bool warm,
                                    ctr_eflex_action_profile_data_t *entry,
                                    uint32_t *base_idx);

/*!
 * \brief Free counters
 *
 * \param [in] unit    Unit number.
 * \param [in] entry   IMM LT entry info for requested counters.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_pool_mgr_ctr_free(int unit,
                                   ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Reserve counter with given base index.
 *
 * \param [in] unit    Unit number.
 * \param [in] warm    Warmboot.
 * \param [in] entry   IMM LT entry info for requested counters.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_RESOURCE, SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_pool_mgr_ctr_reserve(int unit,
                                      bool warm,
                                      ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Allocate shadow pool counters
 *
 * \param [in] unit    Unit number.
 * \param [in] warm    Warmboot.
 * \param [in] entry   IMM LT entry info for requested counters.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_RESOURCE Requested number of counters unavailable.
 */
int
bcmcth_ctr_eflex_pool_mgr_shadow_ctr_alloc(
    int unit,
    bool warm,
    ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Free shadow pool counters
 *
 * \param [in] unit    Unit number.
 * \param [in] primary_enable    Enable primary pools.
 * \param [in] entry   IMM LT entry info for requested counters.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_pool_mgr_shadow_ctr_free(
    int unit,
    bool primary_enable,
    ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Check if given pool id free
 *
 * \param [in] unit    Unit number.
 * \param [in] entry   IMM LT entry info for requested counters.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM Error.
 */
bool
bcmcth_ctr_eflex_pool_mgr_is_pool_free(int unit,
                                       ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Lookup ACTION_PROFILE IMM LT with given action profile id.
 *
 * \param [in] unit    Unit number.
 * \param [in] entry   ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_INTERNAL, SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL,
 *         SHR_E_RESOURCE Error.
 */
int
bcmcth_ctr_eflex_action_profile_lookup(int unit,
                                       ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Get first or next ACTION_PROFILE IMM LT entry.
 *
 * \param [in] unit    Unit number.
 * \param [in] first   First or next LT entry.
 * \param [in] entry   ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_INTERNAL, SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL,
 *         SHR_E_RESOURCE Error.
 */
int
bcmcth_ctr_eflex_action_profile_entry_get(
    int unit,
    bool first,
    ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Lookup GROUP_ACTION_PROFILE IMM LT with given group action profile id.
 *
 * \param [in] unit    Unit number.
 * \param [in] entry   GROUP_ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_INTERNAL, SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL,
 *         SHR_E_RESOURCE Error.
 */
int
bcmcth_ctr_eflex_group_action_lookup(int unit,
                                     ctr_eflex_group_action_data_t *entry);

/*!
 * \brief Lookup OPERAND_PROFILE IMM LT with given operand profile id.
 *
 * \param [in] unit    Unit number.
 * \param [in] entry   OPERAND_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_INTERNAL, SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL,
 *         SHR_E_RESOURCE Error.
 */
int
bcmcth_ctr_eflex_op_profile_lookup(int unit,
                                   ctr_eflex_op_profile_data_t *entry);

/*!
 * \brief Free each field in the list.
 *
 * \param [in] unit    Unit number.
 * \param [in] in      Pointer to fields to be freed.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_fields_free(int unit, bcmltd_fields_t* in);

/*!
 * \brief Allocate BCMLT fields.
 *
 * \param [in] unit    Unit number.
 * \param [in] in      Pointer to fields to be allocated.
 * \param [in] num_fields      Number of fields to be allocated.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM, SHR_E_MEMORY Error.
 */
int
bcmcth_ctr_eflex_fields_alloc(int unit, bcmltd_fields_t* in, size_t num_fields);

/*!
 * \brief Get first and last pipe numbers for IMM LT entry.
 *
 * \param [in] unit    Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 * \param [in] pipe_idx Pipe number for given entry.
 * \param [out] start_pipe_idx First Pipe number for given entry.
 * \param [out] end_pipe_idx Last Pipe number for given entry.
 *
 * \retval SHR_E_NONE Success.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_num_pipes_get(int unit,
                               bool ingress,
                               eflex_comp_t comp,
                               uint32_t pipe_idx,
                               uint32_t *start_pipe_idx,
                               uint32_t *end_pipe_idx);

/*!
 * \brief Initialize flex counter pipe mode.
 *
 * \param [in] unit Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 * \param [out] mode Pipe operational mode.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_pipe_opermode_cfg_init(int unit,
                                        bool ingress,
                                        eflex_comp_t comp,
                                        uint8_t *mode);

/*!
 * \brief Get flex component pipe mode.
 *
 * \param [in] unit Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 * \param [out] pipe_unique Pipe operational mode.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_pipe_opermode_get(int unit,
                                   bool ingress,
                                   eflex_comp_t comp,
                                   uint8_t *pipe_unique);

/*!
 * \brief Check if given id is already in use in internal resource list.
 *
 * \param [in] unit Unit number.
 * \param [in] id Resource id.
 * \param [in] list Internal resource list.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_RESOURCE If id already in use.
 */
int
bcmcth_ctr_eflex_id_validate(int unit,
                             uint32_t id,
                             ctr_eflex_pool_list_t *list);

/*!
 * \brief Set/Clear given id in internal resource list.
 *
 * \param [in] unit Unit number.
 * \param [in] val Value to set.
 * \param [in] id Resource id.
 * \param [in] list Internal resource list.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_RESOURCE If id already in use.
 */
int
bcmcth_ctr_eflex_id_set(int unit,
                        bool val,
                        uint32_t id,
                        ctr_eflex_pool_list_t *list);

/*!
 * \brief Populate POOL_INFO entry.
 *
 * \param [in] unit Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL, SHR_E_RESOURCE Error.
 */
int
bcmcth_ctr_eflex_pool_info_populate(int unit, bool ingress, eflex_comp_t comp);

/*!
 * \brief Function to insert/delete ACTION_PROFILE_INFO entry.
 *
 * \param [in] unit Unit number.
 * \param [in] insert Insert or delete operation.
 * \param [in] entry ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL, SHR_E_RESOURCE Error.
 */
int
bcmcth_ctr_eflex_action_profile_info_program(
    int unit,
    bool insert,
    ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Function to lookup ACTION_PROFILE_INFO entry.
 *
 * \param [in] unit Unit number.
 * \param [in] entry ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL, SHR_E_RESOURCE Error.
 */
int
bcmcth_ctr_eflex_action_profile_info_lookup(
    int unit,
    ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Function to register callback handlers for
 * CTR_xxx_EFLEX_OPERAND_PROFILE LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_imm_op_profile_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * STATE_xxx_EFLEX_OPERAND_PROFILE LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_state_eflex_imm_op_profile_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * CTR_xxx_EFLEX_RANGE_CHK_PROFILE LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_imm_range_chk_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * STATE_xxx_EFLEX_RANGE_CHK_PROFILE LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_state_eflex_imm_range_chk_register(int unit);

/*!
 * \brief Function to register callback handlers for CTR_xxx_EFLEX_TRIGGER LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_imm_trigger_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * STATE_xxx_EFLEX_TRIGGER LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_state_eflex_imm_trigger_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * CTR_xxx_EFLEX_GROUP_ACTION_PROFILE LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_imm_group_action_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * STATE_xxx_EFLEX_GROUP_ACTION_PROFILE LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_state_eflex_imm_group_action_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * CTR_xxx_EFLEX_GROUP_ACTION_PROFILE_INFO &
 * CTR_xxx_EFLEX_POOL_INFO LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_imm_action_profile_info_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * FLEX_STATE_xxx_ACTION_PROFILE_INFO &
 * FLEX_STATE_xxx_POOL_INFO LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_state_eflex_imm_action_profile_info_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * CTR_xxx_EFLEX_HITBIT_CONTROL LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_imm_hitbit_ctrl_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * CTR_xxx_EFLEX_OBJ_QUANTIZATION LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_imm_obj_quant_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * FLEX_STATE_xxx_OBJ_QUANTIZATION LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_state_eflex_imm_obj_quant_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * FLEX_STATE_xxx_TRUTH_TABLE LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_state_eflex_imm_truth_table_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * CTR_xxx_EFLEX_OBJ_INFO LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_imm_obj_info_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * FLEX_STATE_xxx_OBJ_INFO LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_state_eflex_imm_obj_info_register(int unit);

/*!
 * \brief Function to recover internal state from
 * ACTION_PROFILE LT during warmboot.
 *
 * \param [in] unit Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_INTERNAL, SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL,
 *         SHR_E_RESOURCE Error.
 */
int
bcmcth_ctr_eflex_action_profile_state_recover(int unit,
                                              bool ingress,
                                              eflex_comp_t comp);

/*!
 * \brief Function to recover internal state from
 * OPERAND_PROFILE LT during warmboot.
 *
 * \param [in] unit Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_INTERNAL, SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL,
 *         SHR_E_RESOURCE Error.
 */
int
bcmcth_ctr_eflex_op_profile_state_recover(int unit,
                                          bool ingress,
                                          eflex_comp_t comp);

/*!
 * \brief Function to recover internal state from
 * RANGE_CHK_PROFILE LT during warmboot.
 *
 * \param [in] unit Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_INTERNAL, SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL,
 *         SHR_E_RESOURCE Error.
 */
int
bcmcth_ctr_eflex_range_chk_state_recover(int unit,
                                         bool ingress,
                                         eflex_comp_t comp);

/*!
 * \brief Function to recover internal state from
 * HITBIT_CONTROL LT during warmboot.
 *
 * \param [in] unit Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_INTERNAL, SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL Error.
 */
int
bcmcth_ctr_eflex_hitbit_ctrl_state_recover(int unit,
                                           bool ingress,
                                           eflex_comp_t comp);

/*!
 * \brief Function to check if corresponding GROUP_ACTION_PROFILE LT entry,
 * should be updated based on ACTION_PROFILE LT entry insert/delete operation.
 *
 * \param [in] unit Unit number.
 * \param [in] insert Insert or delete operation.
 * \param [in] action_entry ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_INTERNAL, SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL Error.
 */
int
bcmcth_ctr_eflex_group_action_notify(
    int unit,
    bool insert,
    ctr_eflex_action_profile_data_t *action_entry);

/*!
 * \brief Function to check if corresponding TRIGGER LT entry,
 * should be updated based on ACTION_PROFILE LT entry insert/delete operation.
 *
 * \param [in] unit Unit number.
 * \param [in] insert Insert or delete operation.
 * \param [in] action_entry ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_INTERNAL, SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL Error.
 */
int
bcmcth_ctr_eflex_trigger_notify(int unit,
                                bool insert,
                                ctr_eflex_action_profile_data_t *action_entry);

/*!
 * \brief Function to check if corresponding HITBIT_CONTROL LT entry,
 * should be updated based on GROUP_ACTION_PROFILE LT entry
 * insert/delete operation.
 *
 * \param [in] unit Unit number.
 * \param [in] insert Insert or delete operation.
 * \param [in] grp_valid GROUP_ACTION_PROFILE/ACTION_PROFILE entry info present.
 * \param [in] context Ptr to GROUP_ACTION_PROFILE/ACTION_PROFILE entry info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_INTERNAL, SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL Error.
 */
int
bcmcth_ctr_eflex_hitbit_ctrl_notify(
    int unit,
    bool insert,
    bool grp_valid,
    void *context);

/*!
 * \brief Function to check if corresponding ACTION_PROFILE LT entry,
 * should be updated based on OPERAND_PROFILE LT entry insert/delete operation.
 *
 * \param [in] unit Unit number.
 * \param [in] insert Insert or delete operation.
 * \param [in] op_entry OPERAND_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM, SHR_E_MEMORY, SHR_E_UNAVAIL Error.
 */
int
bcmcth_ctr_eflex_action_profile_notify(int unit,
                                       bool insert,
                                       ctr_eflex_op_profile_data_t *op_entry);

/*!
 * \brief Function to set operational state to INACTIVE.
 *
 * \param [in] unit Unit number.
 * \param [in] oper_state_fid Operational state fid.
 * \param [in] oper_state Operational state value.
 * \param [in,out] out Structure contains all the fields of the table, so that
 *                     the component should not delete or add any field to this
 *                     structure. The data values of the field were set by the
 *                     IMM so the component may only overwrite the data section
 *                     of the fields.
 *
 * \retval SHR_E_NONE No errors.
 */
int
bcmcth_ctr_eflex_oper_state_set(int unit,
                                bcmlrd_fid_t oper_state_fid,
                                uint32_t oper_state,
                                bcmltd_fields_t *out);

/*!
 * \brief Function to register callback handlers for
 * CTR_xxx_EFLEX_ERROR_STATS LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_imm_error_stats_register(int unit);

/*!
 * \brief Function to register callback handlers for
 * STATE_xxx_EFLEX_ERROR_STATS LTs.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_state_eflex_imm_error_stats_register(int unit);

/*!
 * \brief Entry limit get callback function of ACTION_PROFILE LT
 *
 * \param [in] unit Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 * \param [in] count Entry limit value.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_action_profile_lt_ent_limit_get(int unit,
                                                 bool ingress,
                                                 eflex_comp_t comp,
                                                 uint32_t *count);

/*!
 * \brief Function to handle hash entry move event from BCMPTM RM.
 *
 * \param [in] unit Unit number.
 * \param [in] event Type of event.
 * \param [in] ev_data Data associated with the event.
 *
 * \retval None
 */
void
bcmcth_ctr_eflex_hash_move_event_cb(int unit,
                                    const char *event,
                                    uint64_t ev_data);

/*!
 * \brief Function to calculate hit index for hash LTs.
 *
 * \param [in] unit Unit number.
 * \param [in] ltid Logical table id with hitbit monitoring configured.
 * \param [in] sid Sid of hitbit physical bank.
 * \param [in] hit_context Hit context information.
 * \param [in] tbl_inst Pipe index.
 * \param [in] bkt_num Number of entries in bucket.
 * \param [in] bkt_entry Position of entry in bucket.
 * \param [in] context Flex counter context info.
 * \param [out] entry_idx Calculated hit index.
 *
 * \retval SHR_E_NONE on success and error code otherwise
 * \retval SHR_E_PARAM, SHR_E_INTERNAL Error.
 */
int
bcmcth_ctr_eflex_hash_entry_index_cb(int unit,
                                     bcmltd_sid_t ltid,
                                     bcmdrd_sid_t sid,
                                     bcmptm_rm_hash_hit_context_t *hit_context,
                                     int tbl_inst,
                                     uint32_t bkt_num,
                                     uint32_t bkt_entry,
                                     void *context,
                                     uint32_t *entry_idx);

/*!
 * \brief Function to get absolute counter bit index.
 *
 * \param [in] unit Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 * \param [in] pool_idx Pool id.
 * \param [in] base_idx Base index within the pool.
 * \param [in] bit_idx Counter bit index offset.
 * \param [out] abs_ctr_bit_idx Absolute counter bit index.
 *
 * \retval SHR_E_NONE Success, otherwise failure
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_abs_bit_idx_get(int unit,
                                 bool ingress,
                                 eflex_comp_t comp,
                                 uint32_t pool_idx,
                                 uint32_t base_idx,
                                 uint32_t bit_idx,
                                 uint32_t *abs_ctr_bit_idx);

/*!
 * \brief Function to calculate counter bit index.
 *
 * \param [in] unit Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 * \param [in] base_pool_idx Base pool id.
 * \param [in] abs_ctr_bit_idx Absolute counter bit index.
 * \param [out] pool_idx Pool id.
 * \param [out] ctr_idx Counter index.
 * \param [out] bit_idx Bit index.
 *
 * \retval SHR_E_NONE Success, otherwise failure
 * \retval SHR_E_PARAM Error.
 */
int
bcmcth_ctr_eflex_bit_idx_calc(int unit,
                              bool ingress,
                              eflex_comp_t comp,
                              uint32_t base_pool_idx,
                              uint32_t abs_ctr_bit_idx,
                              uint32_t *pool_idx,
                              uint32_t *ctr_idx,
                              uint32_t *bit_idx);

/*!
 * \brief Function to check if action profile id is configured for hitbit.
 *
 * \param [in] unit Unit number.
 * \param [in] entry ACTION_PROFILE IMM LT entry info.
 *
 * \retval True hitbit configured.
 * \retval False hitbit not configured.
 */
bool
bcmcth_ctr_eflex_is_hitbit(int unit,
                           ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Function to validate action id in ACTION_PROFILE entry.
 *
 * \param [in] unit Unit number.
 * \param [in] entry ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM, SHR_E_RESOURCE Error.
 */
int
bcmcth_ctr_eflex_action_id_validate(int unit,
                                    ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Function to set/clear action id in resource list.
 *
 * \param [in] unit Unit number.
 * \param [in] val Action id value.
 * \param [in] entry ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM  Error.
 */
int
bcmcth_ctr_eflex_action_id_set(int unit,
                               bool val,
                               ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Function to validate the update modes for given counter mode.
 *
 * \param [in] unit Unit number.
 * \param [in] entry ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM  Error.
 */
int
bcmcth_ctr_eflex_update_mode_validate(int unit,
                                      ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Function to validate ACTION_PROFILE LT entry
 *        if SLIM MODE is configured.
 *
 * \param [in] unit Unit number.
 * \param [in] entry ACTION_PROFILE IMM LT entry info.
 * \param [in] cur_entry current ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM  Error.
 */
int
bcmcth_ctr_eflex_slim_mode_validate(int unit,
                                    ctr_eflex_action_profile_data_t *entry,
                                    ctr_eflex_action_profile_data_t *cur_entry);

/*!
 * \brief Function to adjust number of counters for given counter mode
 * and update mode.
 *
 * \param [in] unit Unit number.
 * \param [in] entry ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM  Error.
 */
int
bcmcth_ctr_eflex_action_profile_num_ctrs_adjust(
    int unit,
    ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Function to get operand profile for corresponding
 * OPERAND_PROFILE LT index in ACTION_PROFILE LT entry.
 *
 * \param [in] unit Unit number.
 * \param [in] op_profile_idx Operand profile index to use for update.
 * \param [out] found Flag to indicate if operand profile match is found.
 * \param [in] op_entry OPERAND_PROFILE IMM LT entry info.
 * \param [in] entry ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE on success or error.
 */
int
bcmcth_ctr_eflex_action_profile_op_update(
    int unit,
    uint32_t op_profile_idx,
    bool *found,
    ctr_eflex_op_profile_data_t *op_entry,
    ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Function to get operand profile for corresponding
 * OPERAND_PROFILE LT index in ACTION_PROFILE LT entry.
 *
 * \param [in] unit Unit number.
 * \param [in] entry ACTION_PROFILE IMM LT entry info.
 *
 * \retval SHR_E_NONE on success or error.
 */
int
bcmcth_ctr_eflex_action_profile_op_profile_get(
    int unit,
    ctr_eflex_action_profile_data_t *entry);

/*!
 * \brief Function to  determine if shadow config is enabled or disabled
 * during ACTION_PROFILE LT update operation.
 *
 * \param [in] unit Unit number.
 * \param [in] entry Updated ACTION_PROFILE IMM LT entry info.
 * \param [in] cur_entry Current ACTION_PROFILE IMM LT entry info.
 * \param [out] shadow Shadow pool NOOP/ENABLE/DISABLE config.
 *
 * \retval SHR_E_NONE on success.
 */
int
bcmcth_ctr_eflex_action_profile_shadow_update_get(
    int unit,
    ctr_eflex_action_profile_data_t *entry,
    ctr_eflex_action_profile_data_t *cur_entry,
    ctr_eflex_shadow_config_t *shadow);

/*!
 * \brief Validate callback function of IMM event handler (bcmimm_lt_cb_t)
 *        for FLEX_STATE_xxx/CTR_xxx_EFLEX read only LTs.
 *
 * \param [in] unit Unit number.
 * \param [in] sid  Logical table ID.
 * \param [in] event_reason Reason for the entry event.
 * \param [in] key_fields Linked list of the key fields identifying
 *                        the entry.
 * \param [in] data_fields Linked list of the data fields in the
 *                         modified entry.
 * \param [in] context Pointer that was given during registration.
 *                     The callback can use this pointer to retrieve some
 *                     context.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
int
bcmcth_ctr_eflex_read_only_lt_validate_cb(
    int unit,
    bcmltd_sid_t sid,
    bcmimm_entry_event_t event_reason,
    const bcmltd_field_t *key_fields,
    const bcmltd_field_t *data_fields,
    void *context);

/*! signature of egress cmd bus variant bit offset get function */
typedef const bcmcth_ctr_eflex_obj_bit_offset_t * \
        (*ctr_egr_eflex_cmd_bus_lts_bit_offset_get_f)(int index);

/*! \cond  Externs for  bit offset get. */
#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
extern  const bcmcth_ctr_eflex_obj_bit_offset_t * \
_bd##_vu##_va##_ctr_egr_eflex_cmd_bus_lts_bit_offset_get(int index);
#define BCMLTD_VARIANT_OVERRIDE
#include <bcmlrd/chip/bcmlrd_variant.h>
/*! \endcond */

/*! signature of egress obj bus variant bit offset get function */
typedef const bcmcth_ctr_eflex_obj_bit_offset_t * \
        (*ctr_egr_eflex_obj_bus_bit_offset_get_f)(int index);

/*! \cond  Externs for  bit offset get. */
#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
extern  const bcmcth_ctr_eflex_obj_bit_offset_t * \
_bd##_vu##_va##_ctr_egr_eflex_obj_bus_bit_offset_get(int index);
#define BCMLTD_VARIANT_OVERRIDE
#include <bcmlrd/chip/bcmlrd_variant.h>
/*! \endcond */

/*! signature of ingress obj bus variant bit offset get function */
typedef const bcmcth_ctr_eflex_obj_bit_offset_t * \
        (*ctr_ing_eflex_obj_bus_bit_offset_get_f)(int index);

/*! \cond  Externs for  bit offset get. */
#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
extern  const bcmcth_ctr_eflex_obj_bit_offset_t * \
_bd##_vu##_va##_ctr_ing_eflex_obj_bus_bit_offset_get(int index);
#define BCMLTD_VARIANT_OVERRIDE
#include <bcmlrd/chip/bcmlrd_variant.h>
/*! \endcond */

/*! signature of egress flex state obj bus variant bit offset get function */
typedef const bcmcth_ctr_eflex_obj_bit_offset_t * \
        (*flex_state_egr_obj_bus_bit_offset_get_f)(int index);

/*! \cond  Externs for  bit offset get. */
#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
extern  const bcmcth_ctr_eflex_obj_bit_offset_t * \
_bd##_vu##_va##_flex_state_egr_obj_bus_bit_offset_get(int index); \
extern  const bcmcth_ctr_eflex_obj_bit_offset_t * \
_bd##_vu##_va##_flex_state_egr0_obj_bus_bit_offset_get(int index); \
extern  const bcmcth_ctr_eflex_obj_bit_offset_t * \
_bd##_vu##_va##_flex_state_egr1_obj_bus_bit_offset_get(int index);
#define BCMLTD_VARIANT_OVERRIDE
#include <bcmlrd/chip/bcmlrd_variant.h>
/*! \endcond */

/*! signature of post lookup flex state obj bus variant bit offset get function */
typedef const bcmcth_ctr_eflex_obj_bit_offset_t * \
        (*flex_state_post_lkup_obj_bus_bit_offset_get_f)(int index);

/*! \cond  Externs for  bit offset get. */
#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
extern  const bcmcth_ctr_eflex_obj_bit_offset_t * \
_bd##_vu##_va##_flex_state_post_lkup_obj_bus_bit_offset_get(int index);
#define BCMLTD_VARIANT_OVERRIDE
#include <bcmlrd/chip/bcmlrd_variant.h>
/*! \endcond */

/*! signature of post fwd flex state obj bus variant bit offset get function */
typedef const bcmcth_ctr_eflex_obj_bit_offset_t * \
        (*flex_state_post_fwd_obj_bus_bit_offset_get_f)(int index);

/*! \cond  Externs for  bit offset get. */
#define BCMLRD_VARIANT_ENTRY(_bd,_bu,_va,_ve,_vu,_vv,_vo,_vd,_r0,_r1) \
extern  const bcmcth_ctr_eflex_obj_bit_offset_t * \
_bd##_vu##_va##_flex_state_post_fwd_obj_bus_bit_offset_get(int index);
#define BCMLTD_VARIANT_OVERRIDE
#include <bcmlrd/chip/bcmlrd_variant.h>
/*! \endcond */

/*!
 * \brief  Populate CTR_xxx_EFLEX_OBJ_INFO LT entries.
 *
 * \param [in] unit Unit number.
 * \param [in] ingress Ingress or Egress direction.
 * \param [in] comp    Enhanced Flex component.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
extern int
bcmcth_eflex_obj_info_populate(int unit, bool ingress, eflex_comp_t comp);

/*!
 * \brief  Calculate absolute counter index.
 *
 * \param [in] unit Unit number.
 * \param [in] index Counter index.
 * \param [in] entry Pointer to ACTION_PROFILE LT entry.
 * \param [out] abs_ctr_idx Pointer to absolute counter index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
extern int
bcmcth_ctr_eflex_abs_idx_get(int unit,
                             uint32_t index,
                             ctr_eflex_action_profile_data_t *entry,
                             uint32_t *abs_ctr_idx);

/*!
 * \brief   Intialize sid and fid info for enhanced flex counter
 *          LTs with variant support.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
extern int
bcmcth_ctr_eflex_lt_info_init(int unit);

/*!
 * \brief   Intialize sid and fid info for enhanced flex state
 *          LTs with variant support.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
extern int
bcmcth_state_eflex_lt_info_init(int unit);

#endif /* BCMCTH_CTR_EFLEX_INTERNAL_H */
