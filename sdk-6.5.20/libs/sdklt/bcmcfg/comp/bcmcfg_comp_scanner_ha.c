/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by cfg from component configuration definition files.
 *
 * Tool: $SDK/INTERNAL/cfg/bin/cfg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
#include <sal/sal_types.h>
#include <sal/sal_libc.h>
#include <shr/shr_debug.h>
#include <bcmcfg/bcmcfg_internal.h>
#include <bcmcfg/bcmcfg_ha_internal.h>
#include <bcmcfg/comp/bcmcfg_comp_scanner_conf.h>
#include <bcmcfg/comp/bcmcfg_comp_scanner_ha.h>
#include <bcmcfg/comp/bcmcfg_feature_ctl.h>
#include <bcmcfg/comp/bcmcfg_ltm_resources.h>
#include <bcmcfg/comp/bcmcfg_trm_resources.h>
#include <bcmcfg/comp/bcmcfg_cfg_error_control.h>
#include <bcmcfg/comp/private/bcmcfg_feature_ctl_ha_private.h>
#include <bcmcfg/comp/private/bcmcfg_ltm_resources_ha_private.h>
#include <bcmcfg/comp/private/bcmcfg_trm_resources_ha_private.h>
#include <bcmcfg/comp/private/bcmcfg_cfg_error_control_ha_private.h>
#include <bcmcfg/generated/bcmcfg_ha_config.h>
#include <bcmissu/issu_api.h>
#include <bcmmgmt/bcmmgmt_sysm.h>

/*******************************************************************************
 * Defines
 */
#define BSL_LOG_MODULE BSL_LS_BCMCFG_HA

static int
bcmcfg_comp_config_report(const char *str,
                          uint32_t *offset)
{
    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);

    if (!sal_strcmp(str, "feature_ctl")) {
        SHR_IF_ERR_EXIT(
            bcmissu_struct_info_gen_report(
                         BCMMGMT_CFG_COMP_ID,
                         BCMCFG_HA_SUBID_COMP_RESOURCE,
                         *offset,
                         sizeof(bcmcfg_feature_ctl_config_t), 1,
                         BCMCFG_FEATURE_CTL_HA_CONFIG_T_ID));
        *offset += (uint32_t) sizeof(bcmcfg_feature_ctl_config_t);
    } else if (!sal_strcmp(str, "ltm_resources")) {
        SHR_IF_ERR_EXIT(
            bcmissu_struct_info_gen_report(
                         BCMMGMT_CFG_COMP_ID,
                         BCMCFG_HA_SUBID_COMP_RESOURCE,
                         *offset,
                         sizeof(bcmcfg_ltm_resources_config_t), 1,
                         BCMCFG_LTM_RESOURCES_HA_CONFIG_T_ID));
        *offset += (uint32_t) sizeof(bcmcfg_ltm_resources_config_t);
    } else if (!sal_strcmp(str, "trm_resources")) {
        SHR_IF_ERR_EXIT(
            bcmissu_struct_info_gen_report(
                         BCMMGMT_CFG_COMP_ID,
                         BCMCFG_HA_SUBID_COMP_RESOURCE,
                         *offset,
                         sizeof(bcmcfg_trm_resources_config_t), 1,
                         BCMCFG_TRM_RESOURCES_HA_CONFIG_T_ID));
        *offset += (uint32_t) sizeof(bcmcfg_trm_resources_config_t);
    } else if (!sal_strcmp(str, "cfg_error_control")) {
        SHR_IF_ERR_EXIT(
            bcmissu_struct_info_gen_report(
                         BCMMGMT_CFG_COMP_ID,
                         BCMCFG_HA_SUBID_COMP_RESOURCE,
                         *offset,
                         sizeof(bcmcfg_cfg_error_control_config_t), 1,
                         BCMCFG_CFG_ERROR_CONTROL_HA_CONFIG_T_ID));
        *offset += (uint32_t) sizeof(bcmcfg_cfg_error_control_config_t);
    }
exit:
    SHR_FUNC_EXIT();
}

static int
bcmcfg_comp_config_save(const char *str, uint8_t *ptr)
{
    int rv = SHR_E_NONE;

    if (!sal_strcmp(str, "feature_ctl")) {
        bcmcfg_feature_ctl_config_t cfg;
        rv = bcmcfg_feature_ctl_config_get(&cfg);
        if (SHR_SUCCESS(rv)) {
            bcmcfg_feature_ctl_ha_config_t new;

            sal_memcpy(&new, &cfg, sizeof(new));
            rv = bcmcfg_feature_ctl_ha_config_set(ptr, &new);
        }
    } else if (!sal_strcmp(str, "ltm_resources")) {
        bcmcfg_ltm_resources_config_t cfg;
        rv = bcmcfg_ltm_resources_config_get(&cfg);
        if (SHR_SUCCESS(rv)) {
            bcmcfg_ltm_resources_ha_config_t new;

            sal_memcpy(&new, &cfg, sizeof(new));
            rv = bcmcfg_ltm_resources_ha_config_set(ptr, &new);
        }
    } else if (!sal_strcmp(str, "trm_resources")) {
        bcmcfg_trm_resources_config_t cfg;
        rv = bcmcfg_trm_resources_config_get(&cfg);
        if (SHR_SUCCESS(rv)) {
            bcmcfg_trm_resources_ha_config_t new;

            sal_memcpy(&new, &cfg, sizeof(new));
            rv = bcmcfg_trm_resources_ha_config_set(ptr, &new);
        }
    } else if (!sal_strcmp(str, "cfg_error_control")) {
        bcmcfg_cfg_error_control_config_t cfg;
        rv = bcmcfg_cfg_error_control_config_get(&cfg);
        if (SHR_SUCCESS(rv)) {
            bcmcfg_cfg_error_control_ha_config_t new;

            sal_memcpy(&new, &cfg, sizeof(new));
            rv = bcmcfg_cfg_error_control_ha_config_set(ptr, &new);
        }
    }

    return rv;
}

static int
bcmcfg_comp_config_restore(const char *str, uint8_t *ptr)
{
    int rv = SHR_E_NONE;

    if (!sal_strcmp(str, "feature_ctl")) {
        const bcmcfg_feature_ctl_ha_config_t *cfg;
        cfg = bcmcfg_feature_ctl_ha_config_get(ptr);
        if (cfg) {
            bcmcfg_feature_ctl_config_t new;

            sal_memcpy(&new, cfg, sizeof(new));
            rv = bcmcfg_feature_ctl_config_set(&new);
        }
    } else if (!sal_strcmp(str, "ltm_resources")) {
        const bcmcfg_ltm_resources_ha_config_t *cfg;
        cfg = bcmcfg_ltm_resources_ha_config_get(ptr);
        if (cfg) {
            bcmcfg_ltm_resources_config_t new;

            sal_memcpy(&new, cfg, sizeof(new));
            rv = bcmcfg_ltm_resources_config_set(&new);
        }
    } else if (!sal_strcmp(str, "trm_resources")) {
        const bcmcfg_trm_resources_ha_config_t *cfg;
        cfg = bcmcfg_trm_resources_ha_config_get(ptr);
        if (cfg) {
            bcmcfg_trm_resources_config_t new;

            sal_memcpy(&new, cfg, sizeof(new));
            rv = bcmcfg_trm_resources_config_set(&new);
        }
    } else if (!sal_strcmp(str, "cfg_error_control")) {
        const bcmcfg_cfg_error_control_ha_config_t *cfg;
        cfg = bcmcfg_cfg_error_control_ha_config_get(ptr);
        if (cfg) {
            bcmcfg_cfg_error_control_config_t new;

            sal_memcpy(&new, cfg, sizeof(new));
            rv = bcmcfg_cfg_error_control_config_set(&new);
        }
    }
    return rv;
}

/*******************************************************************************
 * Public Functions
 */

int
bcmcfg_ha_data_comp_resource_issu_report(void)
{
    uint32_t offset = 0;
    size_t i = 0;
    const bcmcfg_comp_scanner_conf_t *conf = bcmcfg_component_conf;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);

    SHR_IF_ERR_EXIT(
        bcmissu_struct_info_gen_report(
                     BCMMGMT_CFG_COMP_ID,
                     BCMCFG_HA_SUBID_COMP_RESOURCE,
                     offset,
                     sizeof(bcmcfg_ha_header_t), 1,
                     BCMCFG_HA_HEADER_T_ID));
    offset += (uint32_t) sizeof(bcmcfg_ha_header_t);

    for (i = 0; i < conf->count; i++) {
        const char *key = conf->scanner[i]->schema[0].key;

        SHR_IF_ERR_VERBOSE_EXIT(
            bcmcfg_comp_config_report(key, &offset));
    }

exit:
    SHR_FUNC_EXIT();
}

int
bcmcfg_ha_data_comp_resource_save(uint8_t *ptr)
{
    size_t i = 0;
    const bcmcfg_comp_scanner_conf_t *conf = bcmcfg_component_conf;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);

    for (i = 0; i < conf->count; i++) {
        const char *key = conf->scanner[i]->schema[0].key;

        SHR_IF_ERR_VERBOSE_EXIT(
            bcmcfg_comp_config_save(key, ptr));
    }

exit:
    SHR_FUNC_EXIT();
}

int
bcmcfg_ha_data_comp_resource_restore(uint8_t *ptr)
{
    size_t i = 0;
    const bcmcfg_comp_scanner_conf_t *conf = bcmcfg_component_conf;

    SHR_FUNC_ENTER(BSL_UNIT_UNKNOWN);

    for (i = 0; i < conf->count; i++) {
        const char *key = conf->scanner[i]->schema[0].key;

        SHR_IF_ERR_VERBOSE_EXIT(
            bcmcfg_comp_config_restore(key, ptr));
    }

exit:
    SHR_FUNC_EXIT();
}

