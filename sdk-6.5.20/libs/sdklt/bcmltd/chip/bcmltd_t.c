/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_control_t_fields[] = {
    {
        .name  = COLLECTION_ENABLEs,  /* COLLECTION_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable counter collection.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Logical port IDs on which counters are collected.",
    },
    {
        .name  = INTERVALs,  /* INTERVAL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Base time interval for collection in microseconds.",
    },
    {
        .name  = MULTIPLIER_PORTs,  /* MULTIPLIER_PORT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multiplier for port counter collection.\n The specified value is multiplied by the value of INTERVAL\n in order to determine the port counter collection interval.\n A value of 0 disables port counter collection.\n",
    },
    {
        .name  = MULTIPLIER_EPIPEs,  /* MULTIPLIER_EPIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multiplier for egress pipeline counter collection.\n The specified value is multiplied by the value of INTERVAL\n in order to determine the egress pipeline counter collection interval.\n A value of 0 disables egress pipeline counter collection.\n",
    },
    {
        .name  = MULTIPLIER_IPIPEs,  /* MULTIPLIER_IPIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multiplier for ingress pipeline counter collection.\n The specified value is multiplied by the value of INTERVAL\n in order to determine the ingress pipeline counter collection interval.\n A value of 0 disables ingress pipeline counter collection.\n",
    },
    {
        .name  = MULTIPLIER_TMs,  /* MULTIPLIER_TM */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multiplier for traffic management counter collection.\n The specified value is multiplied by the value of INTERVAL\n in order to determine the traffic management counter collection interval.\n A value of 0 disables traffic management counter collection.\n",
    },
    {
        .name  = MULTIPLIER_SECs,  /* MULTIPLIER_SEC */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multiplier for security (SEC) counter collection.\n The specified value is multiplied by the value of INTERVAL\n in order to determine the security counter collection interval.\n A value of 0 disables security counter collection.\n",
    },
    {
        .name  = MULTIPLIER_EVICTs,  /* MULTIPLIER_EVICT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multiplier for eviction counter residue collection.\n The specified value is multiplied by the value of INTERVAL\n in order to determine the eviction counter residue collection interval.\n A value of 0 disables eviction counter residue collection.\n",
    },
    {
        .name  = EVICTION_THRESHOLDs,  /* EVICTION_THRESHOLD */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_EVICTION_THRESHOLD_T_DATA,
        .desc = "Threshold for eviction counter collection.\n The specified value is a percentage of host DMA buffer size.\n Counters are evicted if the number of counter entries exceeds the\n specified threshold.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_control_t = {
    .name = CTR_CONTROLs, /* CTR_CONTROL */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_ctr_control_t_fields,
    .desc = "The CTR_CONTROL logical table specifies the parameters\n to control run time counter collection behavior.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ECN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ecn_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = RX_TNL_DECAP_ECN_PKTs,  /* RX_TNL_DECAP_ECN_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive counter for ECN marked packets arriving on a terminating tunnel.",
    },
    {
        .name  = TX_ECN_PKTs,  /* TX_ECN_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Transmit ECN marked packet counter.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ecn_t = {
    .name = CTR_ECNs, /* CTR_ECN */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_ecn_t_fields,
    .desc = "The CTR_ECN table is used to count ECN marked packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EFLEX_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_eflex_config_t_fields[] = {
    {
        .name  = CTR_ING_EFLEX_OPERMODE_PIPEUNIQUEs,  /* CTR_ING_EFLEX_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Ingress flex counter operating mode.\n Enable to use pipe unique operating mode.\n Disable to indicate global operating mode for all pipes.\n The operating mode must be configured during system initialization\n and cannot be modified during runtime.\n",
    },
    {
        .name  = CTR_EGR_EFLEX_OPERMODE_PIPEUNIQUEs,  /* CTR_EGR_EFLEX_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Egress flex counter operating mode.\n Enable to use pipe unique operating mode.\n Disable to indicate global operating mode for all pipes.\n The operating mode must be configured during system initialization\n and cannot be modified during runtime.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_eflex_config_t = {
    .name = CTR_EFLEX_CONFIGs, /* CTR_EFLEX_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 2,
    .field = bcmltd_ctr_eflex_config_t_fields,
    .desc = "CTR_EFLEX_CONFIG configures the chip level parameters\n for ingress and egress enhanced flex counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_DEBUG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_debug_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = DEBUG_0s,  /* DEBUG_0 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #0.",
    },
    {
        .name  = DEBUG_1s,  /* DEBUG_1 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #1.",
    },
    {
        .name  = DEBUG_2s,  /* DEBUG_2 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #2.",
    },
    {
        .name  = DEBUG_3s,  /* DEBUG_3 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #3.",
    },
    {
        .name  = DEBUG_4s,  /* DEBUG_4 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #4.",
    },
    {
        .name  = DEBUG_5s,  /* DEBUG_5 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #5.",
    },
    {
        .name  = DEBUG_6s,  /* DEBUG_6 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #6.",
    },
    {
        .name  = DEBUG_7s,  /* DEBUG_7 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #7.",
    },
    {
        .name  = DEBUG_8s,  /* DEBUG_8 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #8.",
    },
    {
        .name  = DEBUG_9s,  /* DEBUG_9 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #9.",
    },
    {
        .name  = DEBUG_10s,  /* DEBUG_10 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #10.",
    },
    {
        .name  = DEBUG_11s,  /* DEBUG_11 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Debug Counter #11.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_debug_t = {
    .name = CTR_EGR_DEBUGs, /* CTR_EGR_DEBUG */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_ctr_egr_debug_t_fields,
    .desc = "Logical Table for Egress Debug Counter.\n\n TRIGGER_BITMAP bits [63:0] defined in CTR_EGR_DEBUG_SELECT table\n triggers the increment of Egress Debug Counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_DEBUG_SELECT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_debug_select_t_fields[] = {
    {
        .name  = CTR_EGR_DEBUG_SELECT_IDs,  /* CTR_EGR_DEBUG_SELECT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the egress debug counter trigger table.",
    },
    {
        .name  = LB_TO_LB_DROPs,  /* LB_TO_LB_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to loopback packet destination\n is also loopback port.\n",
    },
    {
        .name  = CELL_TOO_SMALLs,  /* CELL_TOO_SMALL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count multi-cell packets whose SOP cell size is smaller\n than 64 bytes after decap.\n",
    },
    {
        .name  = PKT_TOO_SMALLs,  /* PKT_TOO_SMALL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets whose size is too small.",
    },
    {
        .name  = INVALID_1588_PKTs,  /* INVALID_1588_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count invalid IEEE 1588 packets transmitted.",
    },
    {
        .name  = NIV_PRUNEs,  /* NIV_PRUNE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to NIV prune.",
    },
    {
        .name  = PKT_TOO_LARGEs,  /* PKT_TOO_LARGE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count egress packets dropped due to packet size becoming\n too large after additional bytes were added.\n",
    },
    {
        .name  = MODID_GT_31s,  /* MODID_GT_31 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to module ID greater than 31.",
    },
    {
        .name  = IPMC_L3_SELF_INTFs,  /* IPMC_L3_SELF_INTF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to IPMC self interface pruned.",
    },
    {
        .name  = PARITY_ERRs,  /* PARITY_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to parity error.",
    },
    {
        .name  = L2_MTU_FAILs,  /* L2_MTU_FAIL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to L2 MTU check failure.",
    },
    {
        .name  = UNKNOWN_HIGIGs,  /* UNKNOWN_HIGIG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to unknown HiGig packets.",
    },
    {
        .name  = INVALID_HIGIG2_DST_PORTs,  /* INVALID_HIGIG2_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to HiGig2 packet destination is not a HiGig port.",
    },
    {
        .name  = HIGIG_MCs,  /* HIGIG_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count HiGig multicast packets transmitted.",
    },
    {
        .name  = HIGIG_UCs,  /* HIGIG_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count HiGig unicast packets transmitted.",
    },
    {
        .name  = SRC_IP_LINK_LOCALs,  /* SRC_IP_LINK_LOCAL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to link local source IP .",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count mirroring packets.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to any condition.",
    },
    {
        .name  = L2_MC_DROPs,  /* L2_MC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count dropped L2 multicast packets",
    },
    {
        .name  = STG_DROPs,  /* STG_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to forwarding spanning\n tree state.\n",
    },
    {
        .name  = VLAN_XLATE_MISSs,  /* VLAN_XLATE_MISS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to VLAN translation lookup miss.",
    },
    {
        .name  = INVALID_VLANs,  /* INVALID_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to invalid VLAN ID.",
    },
    {
        .name  = VLAN_TAGGEDs,  /* VLAN_TAGGED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets of VLAN tagged transmitted.",
    },
    {
        .name  = CFI_DROPs,  /* CFI_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to CFI bit set.",
    },
    {
        .name  = TTL_DROPs,  /* TTL_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to TTL threshold exceeded.",
    },
    {
        .name  = TNL_ERRs,  /* TNL_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count tunnel error packets transmitted.",
    },
    {
        .name  = TNL_PKTs,  /* TNL_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count tunnel packets transmitted.",
    },
    {
        .name  = IPMCV6_DROPs,  /* IPMCV6_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count IPv6 IPMC aged and drop packets.",
    },
    {
        .name  = IPMCV6_PKTs,  /* IPMCV6_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count good IPv6 IPMC packets transmitted.",
    },
    {
        .name  = IPV6_DROPs,  /* IPV6_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count IPv6 L3 aged and drop packets transmitted.",
    },
    {
        .name  = IPV6_PKTs,  /* IPV6_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count good IPv6 L3 unicast packets transmitted.",
    },
    {
        .name  = IPMCV4_DROPs,  /* IPMCV4_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count IPv4 IPMC aged and drop packets transmitted.",
    },
    {
        .name  = IPMCV4_PKTs,  /* IPMCV4_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count good IPv4 IPMC packets transmitted.",
    },
    {
        .name  = IPV4_DROPs,  /* IPV4_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count IPv4 L3 aged and drop packets transmitted.",
    },
    {
        .name  = IPV4_PKTs,  /* IPV4_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count good IPv4 L3 unicast packets transmitted.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_debug_select_t = {
    .name = CTR_EGR_DEBUG_SELECTs, /* CTR_EGR_DEBUG_SELECT */
    .flags = 0,
    .fields = 35,
    .field = bcmltd_ctr_egr_debug_select_t_fields,
    .desc = "The CTR_EGR_DEBUG_SELECT table specifies triggers for egress debug counters.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_DROP_EVENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_drop_event_t_fields[] = {
    {
        .name  = CTR_EGR_DROP_EVENT_IDs,  /* CTR_EGR_DROP_EVENT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the CTR_EGR_DROP_EVENT table.",
    },
    {
        .name  = DROP_CNTs,  /* DROP_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Drop event count.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_drop_event_t = {
    .name = CTR_EGR_DROP_EVENTs, /* CTR_EGR_DROP_EVENT */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_egr_drop_event_t_fields,
    .desc = "The CTR_EGR_DROP_EVENT table is used to count egress packet drop\n events. Egress drop events can cause packet processing steps to\n be skipped in the pipeline.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_ACTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_action_profile_t_fields[] = {
    {
        .name  = CTR_EGR_EFLEX_ACTION_PROFILE_IDs,  /* CTR_EGR_EFLEX_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_ACTION_PROFILE table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enhanced flex counter action.",
    },
    {
        .name  = ZONEs,  /* ZONE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_ACTION_ZONE_T_DATA,
        .desc = "Enhanced flex counter action zone.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = POOL_IDs,  /* POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting counter block.\n The block may spill over into the adjacent pool(s).\n",
    },
    {
        .name  = BASE_INDEX_AUTOs,  /* BASE_INDEX_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if the base index value should be calculated using\n internal logic.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Base index in the first pool.\n Applicable only if BASE_INDEX_AUTO is disabled.\n If MODE == SLIM_MODE, then BASE_INDEX must be 0.\n",
    },
    {
        .name  = BASE_INDEX_OPERs,  /* BASE_INDEX_OPER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Computed value of BASE_INDEX.\n Applicable only if BASE_INDEX_AUTO is enabled.\n",
    },
    {
        .name  = SHADOWs,  /* SHADOW */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if atomic snapshot of flex counters should be collected.",
    },
    {
        .name  = NUM_COUNTERSs,  /* NUM_COUNTERS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of flex counters requested.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_MODE_T_DATA,
        .desc = "Flex counter mode.\n The specified counter mode may impact the number\n of available counters for this entry.\n",
    },
    {
        .name  = UPDATE_MODE_As,  /* UPDATE_MODE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter A update mode.\n The supported modes may be dependent on the value\n specified in the MODE field.\n",
    },
    {
        .name  = UPDATE_MODE_Bs,  /* UPDATE_MODE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter B update mode.\n The supported modes may be dependent on the value\n specified in the MODE field.\n Applicable only if MODE == NORMAL.\n",
    },
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .desc = "Selected objects to calculate counter index and values.",
    },
    {
        .name  = INDEX_CTR_EGR_EFLEX_OPERAND_PROFILE_IDs,  /* INDEX_CTR_EGR_EFLEX_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The index of the entry in CTR_EGR_EFLEX_OPERAND_PROFILE table.\n This entry determines how the index of this counter is computed.\n",
    },
    {
        .name  = VAL_A_CTR_EGR_EFLEX_OPERAND_PROFILE_IDs,  /* VAL_A_CTR_EGR_EFLEX_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "CTR_EGR_EFLEX_OPERAND_PROFILE table index which determines\n how counter A value is computed.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_A.\n",
    },
    {
        .name  = VAL_B_CTR_EGR_EFLEX_OPERAND_PROFILE_IDs,  /* VAL_B_CTR_EGR_EFLEX_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "CTR_EGR_EFLEX_OPERAND_PROFILE table index which determines\n how counter B value is computed.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_B.\n",
    },
    {
        .name  = CTR_SRC_As,  /* CTR_SRC_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_SRC_T_DATA,
        .desc = "Value selector to be used for counter A.",
    },
    {
        .name  = CTR_SRC_Bs,  /* CTR_SRC_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_SRC_T_DATA,
        .desc = "Value selector to be used for counter B.",
    },
    {
        .name  = COUNT_ON_RULE_DROPs,  /* COUNT_ON_RULE_DROP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_DROP_COUNT_MODE_T_DATA,
        .desc = "Counter drop mode specifies if counter should\n be updated based on functional packet drops.\n",
    },
    {
        .name  = COUNT_ON_HW_EXCP_DROPs,  /* COUNT_ON_HW_EXCP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count on hardware exception drops.",
    },
    {
        .name  = COUNT_ON_MIRRORs,  /* COUNT_ON_MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count egress mirrored packets also.\n Non-mirrored packets are always counted.\n",
    },
    {
        .name  = CTR_VAL_DATAs,  /* CTR_VAL_DATA */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Additional input used for special functions that calculate\n both counter A and B values.\n",
    },
    {
        .name  = EVICT_COMPAREs,  /* EVICT_COMPARE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_EVICT_COMPARE_T_DATA,
        .desc = "Comparison operation to be performed on updated values of\n counter A and B and evict the counter if condition is true.\n Applicable only if CTR_EGR_FLEX_POOL_CONTROL.EVICTION_MODE\n == CONDITIONAL and MODE == NORMAL .\n",
    },
    {
        .name  = EVICT_RESETs,  /* EVICT_RESET */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to reset counter B during conditional eviction.\n Counter A is always reset in this case.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_action_profile_t = {
    .name = CTR_EGR_EFLEX_ACTION_PROFILEs, /* CTR_EGR_EFLEX_ACTION_PROFILE */
    .flags = 0,
    .fields = 25,
    .field = bcmltd_ctr_egr_eflex_action_profile_t_fields,
    .desc = "The CTR_EGR_EFLEX_ACTION_PROFILE logical table specifies the\n egress enhanced flex counter action ID profile configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_ACTION_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_action_profile_info_t_fields[] = {
    {
        .name  = CTR_EGR_EFLEX_ACTION_PROFILE_IDs,  /* CTR_EGR_EFLEX_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_ACTION_PROFILE table.",
    },
    {
        .name  = POOL_IDs,  /* POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting counter block.",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Base index in the first pool.",
    },
    {
        .name  = NUM_POOLSs,  /* NUM_POOLS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of flex counter pools allocated.",
    },
    {
        .name  = TOP_INDEXs,  /* TOP_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Last index within the last pool ID of\n CTR_EGR_EFLEX_ACTION_PROFILE.POOL_ID + (NUM_POOLS - 1)\n for the specified CTR_EGR_EFLEX_ACTION_PROFILE.NUM_COUNTERS.\n",
    },
    {
        .name  = SHADOW_VALIDs,  /* SHADOW_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that shadow pools are configured.",
    },
    {
        .name  = SHADOW_POOL_IDs,  /* SHADOW_POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting shadow counter block.\n\n Applicable only if SHADOW_VALID == TRUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_action_profile_info_t = {
    .name = CTR_EGR_EFLEX_ACTION_PROFILE_INFOs, /* CTR_EGR_EFLEX_ACTION_PROFILE_INFO */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_egr_eflex_action_profile_info_t_fields,
    .desc = "The CTR_EGR_EFLEX_ACTION_PROFILE_INFO logical table provides information\n about the current egress enhanced flex counter action ID profile\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_BITP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_bitp_profile_t_fields[] = {
    {
        .name  = MUX0_SELs,  /* MUX0_SEL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object offset to determine if packet is mirror-copy.",
    },
    {
        .name  = MIRROR_COPY_VALUEs,  /* MIRROR_COPY_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to determine if packet is mirror-copy.",
    },
    {
        .name  = MIRROR_COPY_MASKs,  /* MIRROR_COPY_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask to determine if packet is mirror-copy.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_bitp_profile_t = {
    .name = CTR_EGR_EFLEX_BITP_PROFILEs, /* CTR_EGR_EFLEX_BITP_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_egr_eflex_bitp_profile_t_fields,
    .desc = "The CTR_EGR_EFLEX_BITP_PROFILE table is used to specify\n egress flex counter attributes to determine if packet is mirror-copy\n and should be counted.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_ERROR_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_error_stats_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = ACTION_MISCONFIGs,  /* ACTION_MISCONFIG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Error counter incremented when multiple flex counter actions\n are directed to the same counter pool.\n",
    },
    {
        .name  = TOO_MANY_ACTIONSs,  /* TOO_MANY_ACTIONS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Error counter incremented when more than a specified number of\n flex counter actions are generated for the same packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_error_stats_t = {
    .name = CTR_EGR_EFLEX_ERROR_STATSs, /* CTR_EGR_EFLEX_ERROR_STATS */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_egr_eflex_error_stats_t_fields,
    .desc = "The CTR_EGR_EFLEX_ERROR_STATS table specifies the error counters\n present in the egress enhanced flex counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_GROUP_ACTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_group_action_profile_t_fields[] = {
    {
        .name  = CTR_EGR_EFLEX_GROUP_ACTION_PROFILE_IDs,  /* CTR_EGR_EFLEX_GROUP_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_GROUP_ACTION_PROFILE table.",
    },
    {
        .name  = GROUPs,  /* GROUP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enhanced flex counter action group.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTION_PROFILE_IDs,  /* CTR_EGR_EFLEX_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "CTR_EGR_EFLEX_ACTION_PROFILE table index which\n represents the group action profile ID.\n",
    },
    {
        .name  = GROUP_MAPs,  /* GROUP_MAP */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "Action profile IDs associated with the group action.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_STATE_T_DATA,
        .desc = "Read-only field which reflects the group action operational state.\n The operational state indicates ACTIVE once all\n CTR_EGR_EFLEX_ACTION_PROFILE entries associated with the group\n have been inserted. It may be updated based on the changes to the\n CTR_EGR_EFLEX_ACTION_PROFILE table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_group_action_profile_t = {
    .name = CTR_EGR_EFLEX_GROUP_ACTION_PROFILEs, /* CTR_EGR_EFLEX_GROUP_ACTION_PROFILE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ctr_egr_eflex_group_action_profile_t_fields,
    .desc = "The CTR_EGR_EFLEX_GROUP_ACTION_PROFILE logical table specifies the\n egress enhanced flex counter group action ID profile configuration.\n\n If group counter action is applied, its associated counter actions\n are selected for counter processing.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_HITBIT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_hitbit_control_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table ID.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = DST_CTR_EGR_EFLEX_GROUP_ACTION_PROFILE_IDs,  /* DST_CTR_EGR_EFLEX_GROUP_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_GROUP_ACTION_PROFILE table which\n specifies flex counter group action profile configuration for\n destination hit-bit lookup.\n",
    },
    {
        .name  = SRC_CTR_EGR_EFLEX_GROUP_ACTION_PROFILE_IDs,  /* SRC_CTR_EGR_EFLEX_GROUP_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_GROUP_ACTION_PROFILE table which\n specifies flex counter group action profile configuration for\n source hit-bit lookup.\n",
    },
    {
        .name  = DST_CTR_EGR_EFLEX_ACTION_PROFILE_IDs,  /* DST_CTR_EGR_EFLEX_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_ACTION_PROFILE table which\n specifies flex counter action profile configuration for\n destination hit-bit lookup.\n",
    },
    {
        .name  = SRC_CTR_EGR_EFLEX_ACTION_PROFILE_IDs,  /* SRC_CTR_EGR_EFLEX_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_ACTION_PROFILE table which\n specifies flex counter action profile configuration for\n source hit-bit lookup.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_STATE_T_DATA,
        .desc = "Read-only field which reflects the hitbit operational state.\n The operational state indicates ACTIVE once all valid\n CTR_EGR_EFLEX_GROUP_ACTION_PROFILE entries associated with the\n TABLE_ID have been inserted. It may be updated based on the changes\n to the CTR_EGR_EFLEX_GROUP_ACTION_PROFILE table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_hitbit_control_t = {
    .name = CTR_EGR_EFLEX_HITBIT_CONTROLs, /* CTR_EGR_EFLEX_HITBIT_CONTROL */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_egr_eflex_hitbit_control_t_fields,
    .desc = "The CTR_EGR_EFLEX_HITBIT_CONTROL logical table specifies the\n egress enhanced flex counter action ID profile configuration associated\n with the logical table for hit-bit monitoring.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_OBJ_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_obj_info_t_fields[] = {
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Egress flex counter object.",
    },
    {
        .name  = MIN_BITs,  /* MIN_BIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Starting offset of the flex counter object.",
    },
    {
        .name  = MAX_BITs,  /* MAX_BIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ending offset of the flex counter object.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_obj_info_t = {
    .name = CTR_EGR_EFLEX_OBJ_INFOs, /* CTR_EGR_EFLEX_OBJ_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_egr_eflex_obj_info_t_fields,
    .desc = "The CTR_EGR_EFLEX_OBJ_INFO logical table provides information\n about the egress enhanced flex counter object bit offsets in the object bus.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_OBJ_QUANTIZATION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_obj_quantization_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = QUANTIZEs,  /* QUANTIZE */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable to set object quantization.",
    },
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .desc = "Objects selected for range check quantization .",
    },
    {
        .name  = OBJ_0_1_MODEs,  /* OBJ_0_1_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use 32-bit mode where quantized results\n of objects 0 and 1 are concatenated and assigned to\n object 0. Object 1 is unchanged.\n",
    },
    {
        .name  = OBJ_2_3_MODEs,  /* OBJ_2_3_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use 32-bit mode where quantized results\n of objects 2 and 3 are concatenated and assigned to\n object 2. Object 3 is unchanged.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_obj_quantization_t = {
    .name = CTR_EGR_EFLEX_OBJ_QUANTIZATIONs, /* CTR_EGR_EFLEX_OBJ_QUANTIZATION */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_egr_eflex_obj_quantization_t_fields,
    .desc = "The CTR_EGR_EFLEX_OBJ_QUANTIZATION table configures the egress\n object quantization controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_OPERAND_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_operand_profile_t_fields[] = {
    {
        .name  = CTR_EGR_EFLEX_OPERAND_PROFILE_IDs,  /* CTR_EGR_EFLEX_OPERAND_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the flex counter egress operand profile table.",
    },
    {
        .name  = PROFILEs,  /* PROFILE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Flex counter egress operand profile index.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = OBJ_1s,  /* OBJ_1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 1 selection result.",
    },
    {
        .name  = OBJ_2s,  /* OBJ_2 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 2 selection result.",
    },
    {
        .name  = MASK_SIZE_1s,  /* MASK_SIZE_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 1.",
    },
    {
        .name  = MASK_SIZE_2s,  /* MASK_SIZE_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 2.",
    },
    {
        .name  = SHIFT_1s,  /* SHIFT_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift amount for object 1.",
    },
    {
        .name  = SHIFT_2s,  /* SHIFT_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Left shift amount for object 2.",
    },
    {
        .name  = OBJ_3s,  /* OBJ_3 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 2 selection result.",
    },
    {
        .name  = MASK_SIZE_3s,  /* MASK_SIZE_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 2.",
    },
    {
        .name  = SHIFT_3s,  /* SHIFT_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift amount for object 1.",
    },
    {
        .name  = SHIFT_4s,  /* SHIFT_4 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift amount for object 1.",
    },
    {
        .name  = SHIFT_5s,  /* SHIFT_5 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift amount for object 1.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_operand_profile_t = {
    .name = CTR_EGR_EFLEX_OPERAND_PROFILEs, /* CTR_EGR_EFLEX_OPERAND_PROFILE */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_ctr_egr_eflex_operand_profile_t_fields,
    .desc = "The CTR_EGR_EFLEX_OPERAND_PROFILE table determines how egress\n enhanced flex counter values A, B or counter index are computed.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_OPERAND_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_operand_profile_info_t_fields[] = {
    {
        .name  = CTR_EGR_EFLEX_OPERAND_PROFILE_IDs,  /* CTR_EGR_EFLEX_OPERAND_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_OPERAND_PROFILE table.",
    },
    {
        .name  = PROFILEs,  /* PROFILE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Flex counter egress operand profile index.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_operand_profile_info_t = {
    .name = CTR_EGR_EFLEX_OPERAND_PROFILE_INFOs, /* CTR_EGR_EFLEX_OPERAND_PROFILE_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_egr_eflex_operand_profile_info_t_fields,
    .desc = "The CTR_EGR_EFLEX_OPERAND_PROFILE_INFO logical table provides information\n about the current egress enhanced flex counter operand profile\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_PKT_ATTRIBUTE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_pkt_attribute_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = CTR_EGR_EFLEX_PKT_ATTRIBUTE_IDs,  /* CTR_EGR_EFLEX_PKT_ATTRIBUTE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_PKT_ATTRIBUTE table.",
    },
    {
        .name  = PKT_ATTRIBUTEs,  /* PKT_ATTRIBUTE */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable to select packet attribute.",
    },
    {
        .name  = PKT_ATTRIBUTE_MAPs,  /* PKT_ATTRIBUTE_MAP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .desc = "Packet attribute map.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_pkt_attribute_t = {
    .name = CTR_EGR_EFLEX_PKT_ATTRIBUTEs, /* CTR_EGR_EFLEX_PKT_ATTRIBUTE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_egr_eflex_pkt_attribute_t_fields,
    .desc = "The CTR_EGR_EFLEX_PKT_ATTRIBUTE table specifies the\n egress enhanced flex counter packet attribute configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_PKT_ATTRIBUTE_OBJECT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_pkt_attribute_object_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = CTR_EGR_EFLEX_PKT_ATTRIBUTE_OBJECT_IDs,  /* CTR_EGR_EFLEX_PKT_ATTRIBUTE_OBJECT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_PKT_ATTRIBUTE_OBJECT table.",
    },
    {
        .name  = PKT_ATTRIBUTE_OBJECT_INSTANCE_IDs,  /* PKT_ATTRIBUTE_OBJECT_INSTANCE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Packet attribute object instance.",
    },
    {
        .name  = CTR_EGR_EFLEX_OBJECTs,  /* CTR_EGR_EFLEX_OBJECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enhanced flex counter object.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_pkt_attribute_object_t = {
    .name = CTR_EGR_EFLEX_PKT_ATTRIBUTE_OBJECTs, /* CTR_EGR_EFLEX_PKT_ATTRIBUTE_OBJECT */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_egr_eflex_pkt_attribute_object_t_fields,
    .desc = "The CTR_EGR_EFLEX_PKT_ATTRIBUTE_OBJECT table specifies the\n egress enhanced flex counter packet attribute object configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_RANGE_CHK_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_range_chk_profile_t_fields[] = {
    {
        .name  = CTR_EGR_EFLEX_RANGE_CHK_PROFILE_IDs,  /* CTR_EGR_EFLEX_RANGE_CHK_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_RANGE_CHK_PROFILE table.",
    },
    {
        .name  = OBJ_SELECTs,  /* OBJ_SELECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Object whose value is to be range checked.",
    },
    {
        .name  = RANGE_CHECKERs,  /* RANGE_CHECKER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Range checker number.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = MINs,  /* MIN */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Minimum value for range checker.",
    },
    {
        .name  = MAXs,  /* MAX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum value for range checker.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_range_chk_profile_t = {
    .name = CTR_EGR_EFLEX_RANGE_CHK_PROFILEs, /* CTR_EGR_EFLEX_RANGE_CHK_PROFILE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ctr_egr_eflex_range_chk_profile_t_fields,
    .desc = "The CTR_EGR_EFLEX_RANGE_CHK_PROFILE table configures the egress\n object quantization range checkers with min and max values.\n\n Each range checker determines if the corresponding object value\n is within the min and max range.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_RANGE_CHK_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_range_chk_profile_info_t_fields[] = {
    {
        .name  = CTR_EGR_EFLEX_RANGE_CHK_PROFILE_IDs,  /* CTR_EGR_EFLEX_RANGE_CHK_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_RANGE_CHK_PROFILE table.",
    },
    {
        .name  = OBJ_SELECTs,  /* OBJ_SELECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Object whose value is to be range checked.",
    },
    {
        .name  = RANGE_CHECKERs,  /* RANGE_CHECKER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Range checker number.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_range_chk_profile_info_t = {
    .name = CTR_EGR_EFLEX_RANGE_CHK_PROFILE_INFOs, /* CTR_EGR_EFLEX_RANGE_CHK_PROFILE_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_egr_eflex_range_chk_profile_info_t_fields,
    .desc = "The CTR_EGR_EFLEX_RANGE_CHK_PROFILE_INFO logical table provides information\n about the current egress enhanced flex counter range checker profile\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_stats_t_fields[] = {
    {
        .name  = CTR_EGR_EFLEX_ACTION_PROFILE_IDs,  /* CTR_EGR_EFLEX_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_ACTION_PROFILE table.",
    },
    {
        .name  = CTR_EFLEX_INDEXs,  /* CTR_EFLEX_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Counter index.",
    },
    {
        .name  = CTR_A_UPPERs,  /* CTR_A_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value A. The applicability of this field is\n dependent on the counter width value specified in\n CTR_EGR_EFLEX_ACTION_PROFILE.MODE field.\n",
    },
    {
        .name  = CTR_A_LOWERs,  /* CTR_A_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value A. The applicability of this field is\n dependent on the counter width value specified in\n CTR_EGR_EFLEX_ACTION_PROFILE.MODE field.\n",
    },
    {
        .name  = CTR_Bs,  /* CTR_B */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value B. The applicability of this field is\n dependent on the counter width value specified in\n CTR_EGR_EFLEX_ACTION_PROFILE.MODE field.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_stats_t = {
    .name = CTR_EGR_EFLEX_STATSs, /* CTR_EGR_EFLEX_STATS */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_egr_eflex_stats_t_fields,
    .desc = "The CTR_EGR_EFLEX_STATS table is used to retrieve the\n the egress enhanced flex counter A, B and C values.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_EFLEX_TRIGGER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_eflex_trigger_t_fields[] = {
    {
        .name  = CTR_EGR_EFLEX_ACTION_PROFILE_IDs,  /* CTR_EGR_EFLEX_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_EFLEX_ACTION_PROFILE table.",
    },
    {
        .name  = TRIGGERs,  /* TRIGGER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update counter based on trigger condition.\n Disable to always update counter.\n",
    },
    {
        .name  = STARTs,  /* START */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_START_TRIGGER_T_DATA,
        .desc = "Start trigger type.",
    },
    {
        .name  = STOPs,  /* STOP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Stop trigger type.",
    },
    {
        .name  = START_VALUEs,  /* START_VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Start value which will trigger counter update,\n when the following condition is met:\n CTR_EGR_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK == START_VALUE\n if COMPARE_START == 0.\n CTR_EGR_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK != START_VALUE\n if COMPARE_START == 1.\n\n Applicable only if START == CONDITION.\n",
    },
    {
        .name  = STOP_VALUEs,  /* STOP_VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Stop value which will stop counter update,.\n when the following condition is met:\n CTR_EGR_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK == START_VALUE\n if COMPARE_STOP == 0.\n CTR_EGR_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK != START_VALUE\n if COMPARE_STOP == 1.\n\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = COND_MASKs,  /* COND_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask value applied to start or stop value to select\n desired attributes.\n Applicable if START == CONDITION or STOP == CONDITION.\n",
    },
    {
        .name  = START_TIME_OFFSETs,  /* START_TIME_OFFSET */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Time offset from current time in nanoseconds\n to trigger counter update.\n Applicable only if START == TIME.\n",
    },
    {
        .name  = NUM_PERIODs,  /* NUM_PERIOD */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The number of periods to measure before stopping.\n If set to 0, then number of periods is infinite.\n To disable the trigger in this case,\n set NUM_PERIOD to non-zero value and enable TRIGGER.\n Applicable only if STOP == PERIOD.\n",
    },
    {
        .name  = NUM_ACTIONSs,  /* NUM_ACTIONS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of times a counter action is hit before stopping.\n Applicable only if STOP == ACTION_COUNT.\n",
    },
    {
        .name  = COMPARE_STARTs,  /* COMPARE_START */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If disabled then == is used as the compare function\n to trigger start counter update.\n If enabled then != is used as the compare function\n to trigger start  counter update.\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = COMPARE_STOPs,  /* COMPARE_STOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If disabled then == is used as the compare function\n to trigger stop counter update.\n If enabled then != is used as the compare function\n to trigger stop  counter update.\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = SCALEs,  /* SCALE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Duration of a single time period. It determines interval\n calculation.\n Applicable only if STOP == PERIOD.\n",
    },
    {
        .name  = INTERVAL_SHIFTs,  /* INTERVAL_SHIFT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Interval is dependent on the result of timestamp\n duration divided by SCALE.\n Interval shift is for computing interval mask which to limit\n the number of interval argument to compute counter index.\n",
    },
    {
        .name  = INTERVAL_SIZEs,  /* INTERVAL_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies number of counters to left in an interval.\n It is pre-configured based on result of OPERAND LT.\n Applicable only the calculation of\n (interval & (2 ^ INTERVAL_SHIFT - 1) << INTERVAL_SIZE\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_STATE_T_DATA,
        .desc = "Read-only field which reflects the trigger operational state.\n The operational state indicates ACTIVE once a\n CTR_EGR_EFLEX_ACTION_PROFILE entry has been inserted. It may be\n updated based on the changes to the CTR_EGR_EFLEX_ACTION_PROFILE\n table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_eflex_trigger_t = {
    .name = CTR_EGR_EFLEX_TRIGGERs, /* CTR_EGR_EFLEX_TRIGGER */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_ctr_egr_eflex_trigger_t_fields,
    .desc = "The CTR_EGR_EFLEX_TRIGGER table configures the trigger function to\n enable conditional updates on egress enhanced flex counter.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_FLEX_ATTR_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_flex_attr_template_t_fields[] = {
    {
        .name  = CTR_EGR_FLEX_ATTR_TEMPLATE_IDs,  /* CTR_EGR_FLEX_ATTR_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the egress flex counter attribute template table.",
    },
    {
        .name  = CTR_FLEX_INSTANCEs,  /* CTR_FLEX_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Flex counter instance. The CTR_FLEX_INSTANCE represents\n a single counter within the CTR_EGR_FLEX_ATTR_TEMPLATE_ID.\n",
    },
    {
        .name  = CTR_EGR_FLEX_PKT_ATTR_TEMPLATE_IDs,  /* CTR_EGR_FLEX_PKT_ATTR_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "CTR_EGR_FLEX_PKT_ATTR_TEMPLATE table index. Used to define\n the packet attributes associated with this counter instance.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_flex_attr_template_t = {
    .name = CTR_EGR_FLEX_ATTR_TEMPLATEs, /* CTR_EGR_FLEX_ATTR_TEMPLATE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_egr_flex_attr_template_t_fields,
    .desc = "The CTR_EGR_FLEX_ATTR_TEMPLATE table associates egress packet\n attributes to one or more flex counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_FLEX_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_flex_entry_t_fields[] = {
    {
        .name  = CTR_EGR_FLEX_ENTRY_IDs,  /* CTR_EGR_FLEX_ENTRY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_FLEX_ENTRY table.\n",
    },
    {
        .name  = CTR_EGR_FLEX_ATTR_TEMPLATE_IDs,  /* CTR_EGR_FLEX_ATTR_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "CTR_EGR_FLEX_ATTR_TEMPLATE table index. The ID represents\n a group of flex counter instances.\n",
    },
    {
        .name  = MAX_INSTANCES_AUTOs,  /* MAX_INSTANCES_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to automatically determine MAX_INSTANCES.\n When this field is enabled, the calculated maximum instances\n is reflected in the MAX_INSTANCES_OPER field.\n",
    },
    {
        .name  = MAX_INSTANCESs,  /* MAX_INSTANCES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The maximum number of flex counter instances\n allocated for this BASE_INDEX. Exceeding this\n maximum results in an operational state error.\n",
    },
    {
        .name  = MAX_INSTANCES_OPERs,  /* MAX_INSTANCES_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Computed valued of MAX_INSTANCES. Read-Only field is\n applicable only when the MAX_INSTANCES_AUTO field is enabled.\n",
    },
    {
        .name  = POOL_IDs,  /* POOL_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter pool ID. An application should ensure that a\n packet is counted in no more than one counter per pool.\n The same POOL_ID should not be assigned to accouting objects\n that could generate multiple hits for the same packet.\n",
    },
    {
        .name  = OFFSET_MODEs,  /* OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter offset mode.",
    },
    {
        .name  = BASE_INDEX_AUTOs,  /* BASE_INDEX_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to automatically calculate the value of BASE_INDEX. When\n this field is enabled, the calculated base index is reflected in\n the BASE_INDEX_OPER field.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Base counter index. Applicable only when BASE_INDEX_AUTO\n is disabled. The BASE_INDEX should not overlap any existing\n counter instances and must be positioned with sufficient\n space for its own counter instances.\n",
    },
    {
        .name  = BASE_INDEX_OPERs,  /* BASE_INDEX_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Computed valued of BASE_INDEX. Read-Only field is applicable only\n when the BASE_INDEX_AUTO field is enabled.\n",
    },
    {
        .name  = PIPE_UNIQUEs,  /* PIPE_UNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Pipe unique indicates the entry will be attached to an accounting\n source on the pipeline specified by PIPE.\n",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "XGS pipeline number.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_FLEX_OPERATIONAL_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The operational state indicates OPERATIONAL_STATE_OK once the entry\n is associated with a valid CTR_EGR_FLEX_ATTR_TEMPLATE table entry\n that has at least one counter instance associated with a valid\n CTR_EGR_FLEX_PKT_ATTR_TEMPLATE table entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_flex_entry_t = {
    .name = CTR_EGR_FLEX_ENTRYs, /* CTR_EGR_FLEX_ENTRY */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_ctr_egr_flex_entry_t_fields,
    .desc = "The CTR_EGR_FLEX_ENTRY table specifies the egress flex counter\n configuration. Inserting an entry in this table configures flex\n counters that may be attached to egress accounting objects.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_FLEX_PKT_ATTR_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_flex_pkt_attr_template_t_fields[] = {
    {
        .name  = CTR_EGR_FLEX_PKT_ATTR_TEMPLATE_IDs,  /* CTR_EGR_FLEX_PKT_ATTR_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_FLEX_PKT_ATTR_TEMPLATE table",
    },
    {
        .name  = IPs,  /* IP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select IP packets.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select dropped packets.",
    },
    {
        .name  = PKT_TYPE_ALLs,  /* PKT_TYPE_ALL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select all packet types.",
    },
    {
        .name  = PKT_TYPE_MULTICASTs,  /* PKT_TYPE_MULTICAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select multicast packets.",
    },
    {
        .name  = PKT_TYPE_UNICASTs,  /* PKT_TYPE_UNICAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select unicast packets.",
    },
    {
        .name  = ACCESS_DVPs,  /* ACCESS_DVP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select access-facing DVP type.",
    },
    {
        .name  = NETWORK_DVPs,  /* NETWORK_DVP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select network-facing DVP type.",
    },
    {
        .name  = ACCESS_SVPs,  /* ACCESS_SVP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select access-facing SVP type.",
    },
    {
        .name  = NETWORK_SVPs,  /* NETWORK_SVP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select network-facing SVP type.",
    },
    {
        .name  = TOS_ECNs,  /* TOS_ECN */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Specifies Explicit Congrestion Notification TOS.",
    },
    {
        .name  = TOS_DSCPs,  /* TOS_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Specifies Differentiated Services TOS.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress logical port.",
    },
    {
        .name  = INT_CNs,  /* INT_CN */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Internal congestion.",
    },
    {
        .name  = OUTER_DOT1Ps,  /* OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer 802.1p priority.",
    },
    {
        .name  = INNER_DOT1Ps,  /* INNER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner 802.1p priority.",
    },
    {
        .name  = VLAN_UTs,  /* VLAN_UT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select untagged VLAN packets.",
    },
    {
        .name  = VLAN_SITs,  /* VLAN_SIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select inner VLAN tagged packets.",
    },
    {
        .name  = VLAN_SOTs,  /* VLAN_SOT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select outer VLAN tagged packets.",
    },
    {
        .name  = VLAN_DTs,  /* VLAN_DT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select inner and outer tagged VLAN packets.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal Priority.",
    },
    {
        .name  = PRE_FP_G_COLORs,  /* PRE_FP_G_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select pre-field processor green packets.",
    },
    {
        .name  = PRE_FP_Y_COLORs,  /* PRE_FP_Y_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select pre-field processor yellow packets.",
    },
    {
        .name  = PRE_FP_R_COLORs,  /* PRE_FP_R_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select pre-field processor red packets.",
    },
    {
        .name  = CONGESTION_MARKEDs,  /* CONGESTION_MARKED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets marked due to MMU congestion.",
    },
    {
        .name  = UNICAST_QUEUEINGs,  /* UNICAST_QUEUEING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets unicast queueing value.",
    },
    {
        .name  = MMU_QUEUE_NUMs,  /* MMU_QUEUE_NUM */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Select packets based on lower 4-bits of MMU_QUEUE_NUM/MMU_COS.",
    },
    {
        .name  = MPLS_EXPs,  /* MPLS_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Specifies MPLS experimental field.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_flex_pkt_attr_template_t = {
    .name = CTR_EGR_FLEX_PKT_ATTR_TEMPLATEs, /* CTR_EGR_FLEX_PKT_ATTR_TEMPLATE */
    .flags = 0,
    .fields = 28,
    .field = bcmltd_ctr_egr_flex_pkt_attr_template_t_fields,
    .desc = "The CTR_EGR_FLEX_PKT_ATTR_TEMPLATE table specifies the packet\n attributes to be applied to a flex counter instance.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_FLEX_POOL_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_flex_pool_control_t_fields[] = {
    {
        .name  = CTR_EGR_FLEX_POOL_IDs,  /* CTR_EGR_FLEX_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter pool ID.",
    },
    {
        .name  = EVICTION_MODEs,  /* EVICTION_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Eviction operating mode.",
    },
    {
        .name  = EVICTION_THD_BYTESs,  /* EVICTION_THD_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction threshold in bytes.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_THD_PKTSs,  /* EVICTION_THD_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Eviction threshold in packets.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_THD_CTR_As,  /* EVICTION_THD_CTR_A */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction threshold for counter A.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_THD_CTR_Bs,  /* EVICTION_THD_CTR_B */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction threshold for counter B.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_SEEDs,  /* EVICTION_SEED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction random seed.\n  Applicable only if EVICTION_MODE == RANDOM.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_flex_pool_control_t = {
    .name = CTR_EGR_FLEX_POOL_CONTROLs, /* CTR_EGR_FLEX_POOL_CONTROL */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_egr_flex_pool_control_t_fields,
    .desc = "The CTR_EGR_FLEX_POOL_CONTROL table specifies the egress per-flex\n  counter pool properties.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_FLEX_POOL_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_flex_pool_info_t_fields[] = {
    {
        .name  = CTR_EGR_FLEX_POOL_INFO_IDs,  /* CTR_EGR_FLEX_POOL_INFO_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_EGR_FLEX_POOL_INFO table.",
    },
    {
        .name  = POOL_SIZEs,  /* POOL_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Indicates the number of counters in the pool.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_flex_pool_info_t = {
    .name = CTR_EGR_FLEX_POOL_INFOs, /* CTR_EGR_FLEX_POOL_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_egr_flex_pool_info_t_fields,
    .desc = "The CTR_EGR_FLEX_POOL_INFO read only table provides egress flex\n counter pool information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_FLEX_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_flex_stats_t_fields[] = {
    {
        .name  = CTR_EGR_FLEX_ENTRY_IDs,  /* CTR_EGR_FLEX_ENTRY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter entry ID.",
    },
    {
        .name  = CTR_FLEX_INSTANCEs,  /* CTR_FLEX_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Counter instance.",
    },
    {
        .name  = BYTESs,  /* BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Byte counter.",
    },
    {
        .name  = PKTSs,  /* PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Packet counter.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_FLEX_STATS_STATE_T_DATA,
        .desc = "Read-only field which reflects the counter operational state.\n The operational state indicates ACTIVE once a CTR_EGR_FLEX_ENTRY\n has been inserted.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_flex_stats_t = {
    .name = CTR_EGR_FLEX_STATSs, /* CTR_EGR_FLEX_STATS */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_egr_flex_stats_t_fields,
    .desc = "The CTR_EGR_FLEX_STATS table is used to retrieve the\n the packet and byte counts for egress flex counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_FP_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_fp_control_t_fields[] = {
    {
        .name  = EVICTION_MODEs,  /* EVICTION_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Eviction operating mode.",
    },
    {
        .name  = EVICTION_THD_BYTESs,  /* EVICTION_THD_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction threshold in bytes.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_THD_PKTSs,  /* EVICTION_THD_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Eviction threshold in packets.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_SEEDs,  /* EVICTION_SEED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction random seed.\n  Applicable only if EVICTION_MODE == RANDOM.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_fp_control_t = {
    .name = CTR_EGR_FP_CONTROLs, /* CTR_EGR_FP_CONTROL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_egr_fp_control_t_fields,
    .desc = "The CTR_EGR_FP_CONTROL table specifies the egress FP counter properties.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_FP_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_fp_entry_t_fields[] = {
    {
        .name  = CTR_EGR_FP_ENTRY_IDs,  /* CTR_EGR_FP_ENTRY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Egress FP counter identifier.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = POOL_IDs,  /* POOL_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Egress FP counter pool ID.",
    },
    {
        .name  = COLORs,  /* COLOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Egress FP counter color.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_fp_entry_t = {
    .name = CTR_EGR_FP_ENTRYs, /* CTR_EGR_FP_ENTRY */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_egr_fp_entry_t_fields,
    .desc = "The CTR_EGR_FP_ENTRY table specifies egress FP counter configuration.  The\n counter configuration reserves hardware resources for the specified color and\n pool ID if sufficient resources are available.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_FP_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_fp_stats_t_fields[] = {
    {
        .name  = CTR_EGR_FP_ENTRY_IDs,  /* CTR_EGR_FP_ENTRY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = BYTESs,  /* BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Byte counter.",
    },
    {
        .name  = PKTSs,  /* PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Packet counter.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_fp_stats_t = {
    .name = CTR_EGR_FP_STATSs, /* CTR_EGR_FP_STATS */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_egr_fp_stats_t_fields,
    .desc = "The CTR_EGR_FP_STATS table is used to retrieve the packet and byte count for\n egress FP counters. If a packet matches multiple FP entries in FP_EGR\n stage, only the counter associated to an entry from the highest priority group will\n increment.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_MC_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_mc_q_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port number.",
    },
    {
        .name  = MC_Qs,  /* MC_Q */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue number.",
    },
    {
        .name  = PKTs,  /* PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of transmitted packets on assigned queue of a port.",
    },
    {
        .name  = BYTESs,  /* BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of transmitted bytes on assigned queue of a port.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_mc_q_t = {
    .name = CTR_EGR_MC_Qs, /* CTR_EGR_MC_Q */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_egr_mc_q_t_fields,
    .desc = "Logical table for egress per-queue transmit multicast counter.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_Q_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_q_control_t_fields[] = {
    {
        .name  = EVICTION_MODEs,  /* EVICTION_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Eviction operating mode.",
    },
    {
        .name  = EVICTION_THD_BYTESs,  /* EVICTION_THD_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction threshold in bytes.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_THD_PKTSs,  /* EVICTION_THD_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction threshold in packets.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_SEEDs,  /* EVICTION_SEED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction random seed.\n  Applicable only if EVICTION_MODE == RANDOM.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_q_control_t = {
    .name = CTR_EGR_Q_CONTROLs, /* CTR_EGR_Q_CONTROL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_egr_q_control_t_fields,
    .desc = "The CTR_EGR_Q_CONTROL table specifies the egress per-queue counter\n  properties.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_SOBMH.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_sobmh_t_fields[] = {
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_sobmh_t = {
    .name = CTR_EGR_SOBMHs, /* CTR_EGR_SOBMH */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_ctr_egr_sobmh_t_fields,
    .desc = "The CTR_EGR_SOBMH table specifies an egress flex counter action\n referred by SOBMH packet counter.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_TM_BST_MC_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_tm_bst_mc_q_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tracking counter in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_MC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_tm_bst_mc_q_t = {
    .name = CTR_EGR_TM_BST_MC_Qs, /* CTR_EGR_TM_BST_MC_Q */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_egr_tm_bst_mc_q_t_fields,
    .desc = "The CTR_EGR_TM_BST_MC_Q table is used to retrieve the\n BST tracking counter per egress multicast queue.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_TM_BST_PORT_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_tm_bst_port_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical Port ID.",
    },
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = UC_CELLSs,  /* UC_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Unicast tracking counter in cells.",
    },
    {
        .name  = MC_CELLSs,  /* MC_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Multicast tracking counter in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_tm_bst_port_service_pool_t = {
    .name = CTR_EGR_TM_BST_PORT_SERVICE_POOLs, /* CTR_EGR_TM_BST_PORT_SERVICE_POOL */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ctr_egr_tm_bst_port_service_pool_t_fields,
    .desc = "The CTR_EGR_TM_BST_PORT_SERVICE_POOL table is used to retrieve the\n BST tracking counters per egress port service pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_TM_BST_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_tm_bst_service_pool_t_fields[] = {
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = UC_CELLSs,  /* UC_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Unicast tracking counter in cells.",
    },
    {
        .name  = MC_CELLSs,  /* MC_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Multicast tracking counter in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_tm_bst_service_pool_t = {
    .name = CTR_EGR_TM_BST_SERVICE_POOLs, /* CTR_EGR_TM_BST_SERVICE_POOL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_egr_tm_bst_service_pool_t_fields,
    .desc = "The CTR_EGR_TM_BST_SERVICE_POOL table is used to retrieve the\n BST tracking counters per egress service pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_TM_BST_UC_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_tm_bst_uc_q_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tracking counter in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_UC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_tm_bst_uc_q_t = {
    .name = CTR_EGR_TM_BST_UC_Qs, /* CTR_EGR_TM_BST_UC_Q */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_egr_tm_bst_uc_q_t_fields,
    .desc = "The CTR_EGR_TM_BST_UC_Q table is used to retrieve the\n BST tracking counter per egress unicast queue.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_TM_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_tm_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = UC_PKTs,  /* UC_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of unicast packets.",
    },
    {
        .name  = MC_PKTs,  /* MC_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of multicast packets.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n the mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_tm_port_t = {
    .name = CTR_EGR_TM_PORTs, /* CTR_EGR_TM_PORT */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_egr_tm_port_t_fields,
    .desc = "The CTR_EGR_TM_PORT logical table specifies egress port counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_TM_PORT_DROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_tm_port_drop_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = UC_RED_PKTs,  /* UC_RED_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Red unicast packet drop count.",
    },
    {
        .name  = UC_YELLOW_PKTs,  /* UC_YELLOW_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Yellow unicast Packet drop count.",
    },
    {
        .name  = UC_GREEN_PKTs,  /* UC_GREEN_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Green unicast packet drop count.",
    },
    {
        .name  = MC_RED_PKTs,  /* MC_RED_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Red multicast packet drop count.",
    },
    {
        .name  = MC_YELLOW_PKTs,  /* MC_YELLOW_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Yellow multicast packet drop count.",
    },
    {
        .name  = MC_GREEN_PKTs,  /* MC_GREEN_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Green multicast packet drop count.",
    },
    {
        .name  = WRED_RED_PKTs,  /* WRED_RED_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Red WRED packet drop count.",
    },
    {
        .name  = WRED_YELLOW_PKTs,  /* WRED_YELLOW_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Yellow WRED packet drop count.",
    },
    {
        .name  = WRED_GREEN_PKTs,  /* WRED_GREEN_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Green WRED packet drop count.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n the mapping between PORT_ID to the physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_tm_port_drop_t = {
    .name = CTR_EGR_TM_PORT_DROPs, /* CTR_EGR_TM_PORT_DROP */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_ctr_egr_tm_port_drop_t_fields,
    .desc = "The CTR_EGR_TM_PORT_DROP table specifies per egress port packet drop\n counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_TM_PORT_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_tm_port_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = MC_SHARED_USAGE_CELLSs,  /* MC_SHARED_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Multicast shared port service pool usage in cells.",
    },
    {
        .name  = UC_SHARED_USAGE_CELLSs,  /* UC_SHARED_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Unicast shared port service pool usage in cells.",
    },
    {
        .name  = UC_TOTAL_USAGE_CELLSs,  /* UC_TOTAL_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Unicast total port service pool usage in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_tm_port_service_pool_t = {
    .name = CTR_EGR_TM_PORT_SERVICE_POOLs, /* CTR_EGR_TM_PORT_SERVICE_POOL */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_egr_tm_port_service_pool_t_fields,
    .desc = "The CTR_EGR_TM_PORT_SERVICE_POOL table specifies shared usage in\n in cells for port service pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_TM_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_tm_service_pool_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = TOTAL_USAGE_CELLSs,  /* TOTAL_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of cells in use by all the ports using the\n service pool.\n",
    },
    {
        .name  = TOTAL_MC_USAGE_CELLSs,  /* TOTAL_MC_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of multicast cell entries in use by all the ports\n using the service pool.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_tm_service_pool_t = {
    .name = CTR_EGR_TM_SERVICE_POOLs, /* CTR_EGR_TM_SERVICE_POOL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_egr_tm_service_pool_t_fields,
    .desc = "The CTR_EGR_TM_SERVICE_POOL table specifies shared usage in\n in cells for service pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_TRACE_EVENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_trace_event_t_fields[] = {
    {
        .name  = CTR_EGR_TRACE_EVENT_IDs,  /* CTR_EGR_TRACE_EVENT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the CTR_EGR_TRACE_EVENT table.",
    },
    {
        .name  = TRACE_CNTs,  /* TRACE_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress trace event count.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_trace_event_t = {
    .name = CTR_EGR_TRACE_EVENTs, /* CTR_EGR_TRACE_EVENT */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_egr_trace_event_t_fields,
    .desc = "The CTR_EGR_TRACE_EVENT table is used to count egress trace events.\n Egress trace events indicate that a specific logic condition was hit\n during processing. Multiple egress trace events can coexist for a packet\n without interfering with each other.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EGR_UC_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_egr_uc_q_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port number.",
    },
    {
        .name  = UC_Qs,  /* UC_Q */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue number.",
    },
    {
        .name  = PKTs,  /* PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of transmitted packets on assigned queue of a port.",
    },
    {
        .name  = BYTESs,  /* BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of transmitted bytes on assigned queue of a port.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_egr_uc_q_t = {
    .name = CTR_EGR_UC_Qs, /* CTR_EGR_UC_Q */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_egr_uc_q_t_fields,
    .desc = "Logical table for egress per-queue transmit unicast counter.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ETRAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_etrap_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = CANDIDATE_FILTER_EXCEEDEDs,  /* CANDIDATE_FILTER_EXCEEDED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of flows that have exceeded the candidate elephant threshold.",
    },
    {
        .name  = FLOW_INSERT_SUCCESSs,  /* FLOW_INSERT_SUCCESS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of flows that have been successfully inserted into the flow table.",
    },
    {
        .name  = FLOW_INSERT_FAILUREs,  /* FLOW_INSERT_FAILURE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of flows that failed to be inserted into the flow table.",
    },
    {
        .name  = FLOW_ELEPHANTs,  /* FLOW_ELEPHANT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of flows that have been detected as elephant flows.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_etrap_t = {
    .name = CTR_ETRAPs, /* CTR_ETRAP */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_etrap_t_fields,
    .desc = "The CTR_ETRAP table is used to retrieve elephant trap (ETRAP)\n statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EVENT_SYNC_STATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_event_sync_state_t_fields[] = {
    {
        .name  = CTR_EVENT_SYNC_STATE_IDs,  /* CTR_EVENT_SYNC_STATE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_TYPE_T_DATA,
        .desc = "Counter type.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EVENT_SYNC_STATE_T_DATA,
        .desc = "Counter sync event state.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_event_sync_state_t = {
    .name = CTR_EVENT_SYNC_STATEs, /* CTR_EVENT_SYNC_STATE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_event_sync_state_t_fields,
    .desc = "The CTR_EVENT_SYNC_STATE displays the event state for\n a force triggered counter collection cycle.\n An application can poll or subscribe to this table in order to determine if\n the state has changed. Entries in this table\n follow entries in CTR_EVENT_SYNC_STATE_CONTROL and constitute the operational\n status of the requested state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_EVENT_SYNC_STATE_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_event_sync_state_control_t_fields[] = {
    {
        .name  = CTR_EVENT_SYNC_STATE_CONTROL_IDs,  /* CTR_EVENT_SYNC_STATE_CONTROL_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_TYPE_T_DATA,
        .desc = "Counter type.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EVENT_SYNC_STATE_CONTROL_T_DATA,
        .desc = "Counter sync event state control.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_event_sync_state_control_t = {
    .name = CTR_EVENT_SYNC_STATE_CONTROLs, /* CTR_EVENT_SYNC_STATE_CONTROL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_event_sync_state_control_t_fields,
    .desc = "The CTR_EVENT_SYNC_STATE_CONTROL is used to\n force trigger a counter collection\n cycle. The resultant status of the\n request can be obtained by reading the entry in\n CTR_EVENT_SYNC_STATE table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_DEBUG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_debug_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = DEBUG_0s,  /* DEBUG_0 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #0.",
    },
    {
        .name  = DEBUG_1s,  /* DEBUG_1 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #1.",
    },
    {
        .name  = DEBUG_2s,  /* DEBUG_2 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #2.",
    },
    {
        .name  = DEBUG_3s,  /* DEBUG_3 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #3.",
    },
    {
        .name  = DEBUG_4s,  /* DEBUG_4 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #4.",
    },
    {
        .name  = DEBUG_5s,  /* DEBUG_5 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #5.",
    },
    {
        .name  = DEBUG_6s,  /* DEBUG_6 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #6.",
    },
    {
        .name  = DEBUG_7s,  /* DEBUG_7 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #7.",
    },
    {
        .name  = DEBUG_8s,  /* DEBUG_8 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #8.",
    },
    {
        .name  = DEBUG_9s,  /* DEBUG_9 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #9.",
    },
    {
        .name  = DEBUG_10s,  /* DEBUG_10 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #10.",
    },
    {
        .name  = DEBUG_11s,  /* DEBUG_11 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #11.",
    },
    {
        .name  = DEBUG_12s,  /* DEBUG_12 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #12.",
    },
    {
        .name  = DEBUG_13s,  /* DEBUG_13 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #13.",
    },
    {
        .name  = DEBUG_14s,  /* DEBUG_14 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #14.",
    },
    {
        .name  = DEBUG_15s,  /* DEBUG_15 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress Debug Counter #15.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_debug_t = {
    .name = CTR_ING_DEBUGs, /* CTR_ING_DEBUG */
    .flags = 0,
    .fields = 18,
    .field = bcmltd_ctr_ing_debug_t_fields,
    .desc = "Logical Table for Ingress Debug Counter.\n\n TRIGGER_BITMAP bits [63:0] defined in CTR_ING_DEBUG_SELECT table\n triggers the increment of Ingress Debug Counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_DEBUG_SELECT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_debug_select_t_fields[] = {
    {
        .name  = CTR_ING_DEBUG_SELECT_IDs,  /* CTR_ING_DEBUG_SELECT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the ingress debug counter trigger table.",
    },
    {
        .name  = ECMP_NOT_RESOLVEDs,  /* ECMP_NOT_RESOLVED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count ECMP not resolved.",
    },
    {
        .name  = RX_VOQ_FLOW_CTRLs,  /* RX_VOQ_FLOW_CTRL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received virtual output queue (VOQ) based\n flow control message packets.\n",
    },
    {
        .name  = BFD_UNKNOWN_VER_OR_DISCARDs,  /* BFD_UNKNOWN_VER_OR_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count unknown BFD version or discard dropped.",
    },
    {
        .name  = BFD_UNKNOWN_ACH_ERRs,  /* BFD_UNKNOWN_ACH_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count BFD packets with non-zero version in the ACH header\n or the ACH channel type is unknown.\n",
    },
    {
        .name  = BFD_UNKNOWN_CTRL_PKTs,  /* BFD_UNKNOWN_CTRL_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count unrecognized BFD control packets received from the\n PW VCCM type 1/2/3 or MPLS-TP control channel.\n",
    },
    {
        .name  = TRILL_RPF_CHECK_FAIL_DROPs,  /* TRILL_RPF_CHECK_FAIL_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count TRILL RPF check fail drops.",
    },
    {
        .name  = TRILL_HOPCOUNT_CHECK_FAILs,  /* TRILL_HOPCOUNT_CHECK_FAIL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count TRILL hop count check fail drops.",
    },
    {
        .name  = TRILL_RBRIDGE_LOOKUP_MISS_DROPs,  /* TRILL_RBRIDGE_LOOKUP_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count TRILL routing bridge lookup miss drops.",
    },
    {
        .name  = OFFSET_TRILL_ERRORS_DROPs,  /* OFFSET_TRILL_ERRORS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count TRILL error drops.",
    },
    {
        .name  = TRILL_FRAME_ON_ACCESS_PORT_DROPs,  /* TRILL_FRAME_ON_ACCESS_PORT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count TRILL frame drops on access port.",
    },
    {
        .name  = NON_TRILL_FRAME_ON_NETWORK_PORT_DROPs,  /* NON_TRILL_FRAME_ON_NETWORK_PORT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count non-TRILL frame drops on network port.",
    },
    {
        .name  = NIV_FORWARDING_DROPs,  /* NIV_FORWARDING_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count NIV forwarding error drops.",
    },
    {
        .name  = VNTAG_ERRORs,  /* VNTAG_ERROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to VNTAG error.",
    },
    {
        .name  = MAC_LIMIT_DROPs,  /* MAC_LIMIT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to MAC limit exceeded.",
    },
    {
        .name  = MAC_LIMIT_NODROPs,  /* MAC_LIMIT_NODROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count MAC limit exceeded and packet not dropped.",
    },
    {
        .name  = DOS_L2s,  /* DOS_L2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count L2 DoS attack packets.",
    },
    {
        .name  = CLASS_BASED_LEARN_DROPs,  /* CLASS_BASED_LEARN_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count class based learning drop.",
    },
    {
        .name  = DST_DISCARDs,  /* DST_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to L2/L3 lookup destination discard.",
    },
    {
        .name  = FP_VLAN_DROPs,  /* FP_VLAN_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count VLAN field processor (FP) drops.",
    },
    {
        .name  = URPFs,  /* URPF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to uRPF lookup failure.",
    },
    {
        .name  = RX_HIGIG_NON_UCs,  /* RX_HIGIG_NON_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received HiGig non-unicast packets.",
    },
    {
        .name  = RX_HIGIG_UCs,  /* RX_HIGIG_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received HiGig unicast packets.",
    },
    {
        .name  = PARITY_ERR_DROPs,  /* PARITY_ERR_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to parity error.",
    },
    {
        .name  = TRUNK_FAILOVER_LOOPBACK_DISCARDs,  /* TRUNK_FAILOVER_LOOPBACK_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count trunk failover loopback packets discarded\n due to the backup port being down in packet pre-processing stage.\n",
    },
    {
        .name  = TRUNK_FAILOVER_LOOPBACKs,  /* TRUNK_FAILOVER_LOOPBACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count trunk failover loopback packets in\n packet pre-processing stage.\n",
    },
    {
        .name  = MC_INDEX_ERRs,  /* MC_INDEX_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets with multicast index error.",
    },
    {
        .name  = HIGIG_ERRs,  /* HIGIG_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count HiGig header error packets.",
    },
    {
        .name  = RX_VLAN_DROPs,  /* RX_VLAN_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received VLAN drop packets.",
    },
    {
        .name  = RX_TNL_ERRs,  /* RX_TNL_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received tunnel error packets.",
    },
    {
        .name  = RX_TNLs,  /* RX_TNL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count the number of tunnel packets received.",
    },
    {
        .name  = L3_MTU_ERRs,  /* L3_MTU_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets copied to CPU due to egress L3 MTU violation.",
    },
    {
        .name  = DOS_FRAGMENTs,  /* DOS_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count DoS fragment error packets.",
    },
    {
        .name  = DOS_ICMPs,  /* DOS_ICMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count DoS ICMP error packets.",
    },
    {
        .name  = DOS_L4_HDR_ERRs,  /* DOS_L4_HDR_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count DoS L4 header error packets.",
    },
    {
        .name  = HIGIG_MIRRORs,  /* HIGIG_MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count HiGig mirror packet.",
    },
    {
        .name  = DOS_L3_HDR_ERRs,  /* DOS_L3_HDR_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count DOS L3 header error packets.",
    },
    {
        .name  = HIGIG_UNKNOWN_HDR_TYPEs,  /* HIGIG_UNKNOWN_HDR_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count unknown HiGig header type packets.",
    },
    {
        .name  = RX_HIGIG_IBPs,  /* RX_HIGIG_IBP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received HiGig end-to-end IBP packets.",
    },
    {
        .name  = RX_HIGIG_HOLs,  /* RX_HIGIG_HOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received HiGig end-to-end HOL packets.",
    },
    {
        .name  = RX_HIGIG_PAUSEs,  /* RX_HIGIG_PAUSE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received HiGig IPIC pause packets.",
    },
    {
        .name  = RX_DROPs,  /* RX_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count zero port bitmap drop condition.",
    },
    {
        .name  = RX_MC_DROPs,  /* RX_MC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count multicast (L2+L3) packets that are dropped.",
    },
    {
        .name  = FP_DROPs,  /* FP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped by the FP.",
    },
    {
        .name  = MC_BRIDGEDs,  /* MC_BRIDGED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count bridged multicast packets.",
    },
    {
        .name  = RX_POLICY_DISCARDs,  /* RX_POLICY_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received policy discards.",
    },
    {
        .name  = RX_PORT_DROPs,  /* RX_PORT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped when the ingress port is not\n in a forwarding state.\n",
    },
    {
        .name  = RX_UCs,  /* RX_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count good received unicast (L2+L3) packets.",
    },
    {
        .name  = RX_TM_BUFFER_DISCARDs,  /* RX_TM_BUFFER_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to unavailability of TM buffer resources.",
    },
    {
        .name  = IPV6_MC_ROUTEDs,  /* IPV6_MC_ROUTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count routed IPv6 multicast packets.",
    },
    {
        .name  = RX_IPV6_HDR_ERRs,  /* RX_IPV6_HDR_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received IPv6 header error packets\n (IPv6 martian error addresses + link local).\n",
    },
    {
        .name  = RX_IPV6s,  /* RX_IPV6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count good received IPv6 L3 packets, including tunneled packets.",
    },
    {
        .name  = RX_IPV6_DISCARDs,  /* RX_IPV6_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received L3 IPv6 discarded packets.",
    },
    {
        .name  = IPV4_MC_ROUTEDs,  /* IPV4_MC_ROUTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count routed IPv4 multicast packets.",
    },
    {
        .name  = RX_IPV4_HDR_ERRs,  /* RX_IPV4_HDR_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received IPv4 header error packets\n (martian error address + unicast with Class D + multicast & ~ClassD)\n",
    },
    {
        .name  = RX_IPV4s,  /* RX_IPV4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count good received IPv4 L3, including tunneled packets.",
    },
    {
        .name  = RX_IPV4_DISCARDs,  /* RX_IPV4_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count received L3 IPv4 discarded packets.",
    },
    {
        .name  = VLAN_MEMBERSHIP_DROPs,  /* VLAN_MEMBERSHIP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to mismatched egress port for\n the VLAN.\n",
    },
    {
        .name  = VLAN_BLOCKED_DROPs,  /* VLAN_BLOCKED_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to VLAN blocked ports.",
    },
    {
        .name  = VLAN_STG_DROPs,  /* VLAN_STG_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to spanning tree group state.",
    },
    {
        .name  = NONUC_TRUNK_RESOLUTION_MASKs,  /* NONUC_TRUNK_RESOLUTION_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to multicast and broadcast trunk\n block mask.\n",
    },
    {
        .name  = NONUC_MASKs,  /* NONUC_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to\n unknown unicast, unknown multicast, known multicast,\n and broadcast block masks.\n",
    },
    {
        .name  = MC_DROPs,  /* MC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to multicast errors.",
    },
    {
        .name  = MAC_MASKs,  /* MAC_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to MAC block mask.",
    },
    {
        .name  = ING_EGR_MASKs,  /* ING_EGR_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to block traffic\n from egressing based on the ingress port.\n",
    },
    {
        .name  = FP_ING_DELAYED_DROPs,  /* FP_ING_DELAYED_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to ingress FP delayed action.",
    },
    {
        .name  = FP_REDIRECT_MASKs,  /* FP_REDIRECT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to FP redirection mask.",
    },
    {
        .name  = EGR_MASKs,  /* EGR_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to egress mask.",
    },
    {
        .name  = SRC_PORT_KNOCKOUT_DROPs,  /* SRC_PORT_KNOCKOUT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to source port knockout.",
    },
    {
        .name  = NON_IP_DISCARDs,  /* NON_IP_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count non-IP packet discard dropped.",
    },
    {
        .name  = MTU_CHECK_FAILs,  /* MTU_CHECK_FAIL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to MTU check fail.",
    },
    {
        .name  = BLOCK_MASK_DROPs,  /* BLOCK_MASK_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to block masks.",
    },
    {
        .name  = PVLAN_VID_MISMATCHs,  /* PVLAN_VID_MISMATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to PVLAN VID mismatch.",
    },
    {
        .name  = INVALID_VLANs,  /* INVALID_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to invalid VLAN.",
    },
    {
        .name  = INVALID_TPIDs,  /* INVALID_TPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to TPID mismatch.",
    },
    {
        .name  = PORT_ING_VLAN_MEMBERSHIPs,  /* PORT_ING_VLAN_MEMBERSHIP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to ingress port not in\n VLAN membership.\n",
    },
    {
        .name  = VLAN_CC_OR_PBTs,  /* VLAN_CC_OR_PBT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count VLAN cross-connect drop.",
    },
    {
        .name  = VLAN_FPs,  /* VLAN_FP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to VLAN FP.",
    },
    {
        .name  = MPLS_TTL_CHECK_FAILs,  /* MPLS_TTL_CHECK_FAIL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to MPLS TTL check fail.",
    },
    {
        .name  = MPLS_LABEL_MISSs,  /* MPLS_LABEL_MISS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to MPLS label lookup miss.",
    },
    {
        .name  = MPLS_INVALID_PAYLOADs,  /* MPLS_INVALID_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to MPLS invalid payload.",
    },
    {
        .name  = MPLS_INVALID_CWs,  /* MPLS_INVALID_CW */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to MPLS invalid control word.",
    },
    {
        .name  = MPLS_INVALID_ACTIONs,  /* MPLS_INVALID_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to MPLS invalid action.",
    },
    {
        .name  = MPLS_GAL_LABELs,  /* MPLS_GAL_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to MPLS generic associated label lookup miss.",
    },
    {
        .name  = TNL_DECAP_ECNs,  /* TNL_DECAP_ECN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count tunnel decap ECN error drop.",
    },
    {
        .name  = TIME_SYNC_PKTs,  /* TIME_SYNC_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count time sync drop.",
    },
    {
        .name  = TAG_UNTAG_DISCARDs,  /* TAG_UNTAG_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to port configuration for dropping\n all tagged packets or untagged packets.\n",
    },
    {
        .name  = SRC_ROUTEs,  /* SRC_ROUTE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to source route.",
    },
    {
        .name  = SPANNING_TREE_STATEs,  /* SPANNING_TREE_STATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to spanning tree.",
    },
    {
        .name  = TNL_ERRORs,  /* TNL_ERROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to tunnel errors.",
    },
    {
        .name  = PROTECTION_DATA_DROPs,  /* PROTECTION_DATA_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to protection.",
    },
    {
        .name  = NHOP_DROPs,  /* NHOP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to next hop indication.",
    },
    {
        .name  = FP_ING_DROPs,  /* FP_ING_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to ingress FP drop.",
    },
    {
        .name  = FP_REDIRECT_DROPs,  /* FP_REDIRECT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to invalid FP redirection.",
    },
    {
        .name  = ECMP_RESOLUTION_ERRs,  /* ECMP_RESOLUTION_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to ECMP resolution error.",
    },
    {
        .name  = PVLAN_VP_FILTERs,  /* PVLAN_VP_FILTER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count private VLAN VP filter drop.",
    },
    {
        .name  = PROTCOL_PKT_CTRL_DROPs,  /* PROTCOL_PKT_CTRL_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to protocol packet drop control.",
    },
    {
        .name  = PORT_FILTERING_MODEs,  /* PORT_FILTERING_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count port filtering mode drop.",
    },
    {
        .name  = L2_MY_STATIONs,  /* L2_MY_STATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to L2 my station lookup miss.",
    },
    {
        .name  = MPLS_STAGEs,  /* MPLS_STAGE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count MPLS stage drop.",
    },
    {
        .name  = SRC_MAC_ZEROs,  /* SRC_MAC_ZERO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count source MAC address is zero.",
    },
    {
        .name  = L3_TTL_ERRs,  /* L3_TTL_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count L3 TTL error drop.",
    },
    {
        .name  = L3_HDR_ERRs,  /* L3_HDR_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count L3 header error drop.",
    },
    {
        .name  = DST_L3_LOOKUP_MISSs,  /* DST_L3_LOOKUP_MISS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count L3 destination lookup miss drop.",
    },
    {
        .name  = SRC_L3_DISCARDs,  /* SRC_L3_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count L3 source discard drop.",
    },
    {
        .name  = DST_L3_DISCARDs,  /* DST_L3_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count L3 destination discard drop.",
    },
    {
        .name  = SRC_L2_STATIC_MOVEs,  /* SRC_L2_STATIC_MOVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count L2 source static move drop.",
    },
    {
        .name  = SRC_L2_DISCARDs,  /* SRC_L2_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to L2 source discard.",
    },
    {
        .name  = DST_L2_DISCARDs,  /* DST_L2_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to L2 destination discard.",
    },
    {
        .name  = IP_MC_DROPs,  /* IP_MC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count IP multicast header error drop.",
    },
    {
        .name  = SRC_MAC_EQUALS_DST_MACs,  /* SRC_MAC_EQUALS_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to source MAC address equal to\n destination MAC address.\n",
    },
    {
        .name  = TRUNK_FAIL_LOOPBACKs,  /* TRUNK_FAIL_LOOPBACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets looped back because of trunk failover\n in packet discard stage.\n",
    },
    {
        .name  = DOS_L4_ATTACKs,  /* DOS_L4_ATTACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to L4 DoS attack.",
    },
    {
        .name  = DOS_L3_ATTACKs,  /* DOS_L3_ATTACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to L3 DoS attack.",
    },
    {
        .name  = IPV6_PROTOCOL_ERRs,  /* IPV6_PROTOCOL_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to IPv6 protocol error.",
    },
    {
        .name  = IPV4_PROTOCOL_ERRs,  /* IPV4_PROTOCOL_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to IPv4 protocol error.",
    },
    {
        .name  = MAC_CONTROL_FRAMEs,  /* MAC_CONTROL_FRAME */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to MAC control frame.",
    },
    {
        .name  = COMPOSITE_ERRORs,  /* COMPOSITE_ERROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to parity/ecc errors.",
    },
    {
        .name  = CPU_MANAGED_LEARNINGs,  /* CPU_MANAGED_LEARNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to CPU managed learning (CML).",
    },
    {
        .name  = CFI_OR_L3_DISABLEs,  /* CFI_OR_L3_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to CFI or L3 disable.",
    },
    {
        .name  = BPDUs,  /* BPDU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to BPDU.",
    },
    {
        .name  = BFD_TERMINATED_DROPs,  /* BFD_TERMINATED_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count BFD terminated drop.",
    },
    {
        .name  = INBAND_TELEMETRY_VECTOR_MISS_MATCH_DROPs,  /* INBAND_TELEMETRY_VECTOR_MISS_MATCH_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count In-band Network Telemetry (INT) packets dropped\n due to request vector match failure.\n",
    },
    {
        .name  = INBAND_TELEMETRY_DATAPLANE_EXCEPTION_DROPs,  /* INBAND_TELEMETRY_DATAPLANE_EXCEPTION_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count In-band Network Telemetry Data-plane\n Probe (INT-DP) packets dropped due to exception, including\n turn around and hop limit exceeded.\n",
    },
    {
        .name  = VFI_ING_ADAPT_LOOKUP_MISS_DROPs,  /* VFI_ING_ADAPT_LOOKUP_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to the first lookup\n miss drop or both the first and the second lookup miss\n drop during ingress VFI adaption.\n",
    },
    {
        .name  = OVERLAY_UNDERLAY_NHOP_EIF_RANGE_ERROR_DROPs,  /* OVERLAY_UNDERLAY_NHOP_EIF_RANGE_ERROR_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to overlay\n and underlay next hop or L3 egress interface ID range error.\n",
    },
    {
        .name  = TNL_VXLAN_DECAP_SRC_IP_LOOKUP_MISS_DROPs,  /* TNL_VXLAN_DECAP_SRC_IP_LOOKUP_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count VXLAN packet dropped due to source IP\n lookup miss during tunnel decapsulation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_debug_select_t = {
    .name = CTR_ING_DEBUG_SELECTs, /* CTR_ING_DEBUG_SELECT */
    .flags = 0,
    .fields = 127,
    .field = bcmltd_ctr_ing_debug_select_t_fields,
    .desc = "The CTR_ING_DEBUG_SELECT table specifies triggers for ingress\n debug counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_DROP_EVENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_drop_event_t_fields[] = {
    {
        .name  = CTR_ING_DROP_EVENT_IDs,  /* CTR_ING_DROP_EVENT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the CTR_ING_DROP_EVENT table.",
    },
    {
        .name  = DROP_CNTs,  /* DROP_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Drop event count.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_drop_event_t = {
    .name = CTR_ING_DROP_EVENTs, /* CTR_ING_DROP_EVENT */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_ing_drop_event_t_fields,
    .desc = "The CTR_ING_DROP_EVENT table is used to count ingress packet drop\n events. Ingress drop events can cause packet processing steps to\n be skipped in the pipeline.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_ACTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_action_profile_t_fields[] = {
    {
        .name  = CTR_ING_EFLEX_ACTION_PROFILE_IDs,  /* CTR_ING_EFLEX_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_ACTION_PROFILE table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enhanced flex counter action.",
    },
    {
        .name  = ZONEs,  /* ZONE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_ACTION_ZONE_T_DATA,
        .desc = "Enhanced flex counter action zone.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = POOL_IDs,  /* POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting counter block.\n The block may spill over into the adjacent pool(s).\n",
    },
    {
        .name  = BASE_INDEX_AUTOs,  /* BASE_INDEX_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if the base index value should be calculated using\n internal logic.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Base index in the first pool.\n Applicable only if BASE_INDEX_AUTO is disabled.\n",
    },
    {
        .name  = BASE_INDEX_OPERs,  /* BASE_INDEX_OPER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Computed value of BASE_INDEX.\n Applicable only if BASE_INDEX_AUTO is enabled.\n If MODE == SLIM_MODE, then BASE_INDEX must be 0.\n",
    },
    {
        .name  = SHADOWs,  /* SHADOW */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if atomic snapshot of flex counters should be collected.",
    },
    {
        .name  = NUM_COUNTERSs,  /* NUM_COUNTERS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of flex counters requested.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_MODE_T_DATA,
        .desc = "Flex counter mode.\n The specified counter mode may impact the number\n of available counters for this entry.\n",
    },
    {
        .name  = UPDATE_MODE_As,  /* UPDATE_MODE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter A update mode.\n The supported modes may be dependent on the value\n specified in the MODE field.\n",
    },
    {
        .name  = UPDATE_MODE_Bs,  /* UPDATE_MODE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter B update mode.\n The supported modes may be dependent on the value\n specified in the MODE field.\n Applicable only if MODE == NORMAL.\n",
    },
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .desc = "Selected objects to calculate counter index and values.",
    },
    {
        .name  = INDEX_CTR_ING_EFLEX_OPERAND_PROFILE_IDs,  /* INDEX_CTR_ING_EFLEX_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The index of the entry in CTR_ING_EFLEX_OPERAND_PROFILE table.\n This entry determines how the index of this counter is computed.\n",
    },
    {
        .name  = VAL_A_CTR_ING_EFLEX_OPERAND_PROFILE_IDs,  /* VAL_A_CTR_ING_EFLEX_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "CTR_ING_EFLEX_OPERAND_PROFILE table index which determines\n how counter A value is computed.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_A.\n",
    },
    {
        .name  = VAL_B_CTR_ING_EFLEX_OPERAND_PROFILE_IDs,  /* VAL_B_CTR_ING_EFLEX_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "CTR_ING_EFLEX_OPERAND_PROFILE table index which determines\n how counter B value is computed.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_B.\n",
    },
    {
        .name  = CTR_SRC_As,  /* CTR_SRC_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_SRC_T_DATA,
        .desc = "Value selector to be used for counter A.",
    },
    {
        .name  = CTR_SRC_Bs,  /* CTR_SRC_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_SRC_T_DATA,
        .desc = "Value selector to be used for counter B.",
    },
    {
        .name  = COUNT_ON_RULE_DROPs,  /* COUNT_ON_RULE_DROP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_DROP_COUNT_MODE_T_DATA,
        .desc = "Counter drop mode specifies if counter should\n be updated based on functional packet drops.\n",
    },
    {
        .name  = COUNT_ON_HW_EXCP_DROPs,  /* COUNT_ON_HW_EXCP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count on hardware exception drops.",
    },
    {
        .name  = CTR_VAL_DATAs,  /* CTR_VAL_DATA */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Additional input used for special functions that calculate\n both counter A and B values.\n",
    },
    {
        .name  = EVICT_COMPAREs,  /* EVICT_COMPARE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_EVICT_COMPARE_T_DATA,
        .desc = "Comparison operation to be performed on updated values of\n counter A and B and evict the counter if condition is true.\n Applicable only if CTR_ING_FLEX_POOL_CONTROL.EVICTION_MODE\n == CONDITIONAL and MODE == NORMAL.\n",
    },
    {
        .name  = EVICT_RESETs,  /* EVICT_RESET */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to reset counter B during conditional eviction.\n Counter A is always reset in this case.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_action_profile_t = {
    .name = CTR_ING_EFLEX_ACTION_PROFILEs, /* CTR_ING_EFLEX_ACTION_PROFILE */
    .flags = 0,
    .fields = 24,
    .field = bcmltd_ctr_ing_eflex_action_profile_t_fields,
    .desc = "The CTR_ING_EFLEX_ACTION_PROFILE logical table specifies the\n ingress enhanced flex counter action ID profile configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_ACTION_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_action_profile_info_t_fields[] = {
    {
        .name  = CTR_ING_EFLEX_ACTION_PROFILE_IDs,  /* CTR_ING_EFLEX_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_ACTION_PROFILE table.",
    },
    {
        .name  = POOL_IDs,  /* POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting counter block.",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Base index in the first pool.",
    },
    {
        .name  = NUM_POOLSs,  /* NUM_POOLS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of flex counter pools allocated.",
    },
    {
        .name  = TOP_INDEXs,  /* TOP_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Last index within the last pool ID of\n CTR_ING_EFLEX_ACTION_PROFILE.POOL_ID + (NUM_POOLS - 1)\n for the specified CTR_ING_EFLEX_ACTION_PROFILE.NUM_COUNTERS.\n",
    },
    {
        .name  = SHADOW_VALIDs,  /* SHADOW_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that shadow pools are configured.",
    },
    {
        .name  = SHADOW_POOL_IDs,  /* SHADOW_POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting shadow counter block.\n\n Applicable only if SHADOW_VALID == TRUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_action_profile_info_t = {
    .name = CTR_ING_EFLEX_ACTION_PROFILE_INFOs, /* CTR_ING_EFLEX_ACTION_PROFILE_INFO */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_ing_eflex_action_profile_info_t_fields,
    .desc = "The CTR_ING_EFLEX_ACTION_PROFILE_INFO logical table provides information\n about the current ingress enhanced flex counter action ID profile\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_BITP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_bitp_profile_t_fields[] = {
    {
        .name  = MUX0_SELs,  /* MUX0_SEL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object offset to determine if packet is mirror-copy.",
    },
    {
        .name  = MIRROR_COPY_VALUEs,  /* MIRROR_COPY_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to determine if packet is mirror-copy.",
    },
    {
        .name  = MIRROR_COPY_MASKs,  /* MIRROR_COPY_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask to determine if packet is mirror-copy.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_bitp_profile_t = {
    .name = CTR_ING_EFLEX_BITP_PROFILEs, /* CTR_ING_EFLEX_BITP_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_ing_eflex_bitp_profile_t_fields,
    .desc = "The CTR_ING_EFLEX_BITP_PROFILE table is used to specify\n ingress flex counter attributes to determine if packet is mirror-copy\n and should be counted.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_ERROR_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_error_stats_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = ACTION_MISCONFIGs,  /* ACTION_MISCONFIG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Error counter incremented when multiple flex counter actions\n are directed to the same counter pool.\n",
    },
    {
        .name  = TOO_MANY_ACTIONSs,  /* TOO_MANY_ACTIONS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Error counter incremented when more than a specified number of\n flex counter actions are generated for the same packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_error_stats_t = {
    .name = CTR_ING_EFLEX_ERROR_STATSs, /* CTR_ING_EFLEX_ERROR_STATS */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_ing_eflex_error_stats_t_fields,
    .desc = "The CTR_ING_EFLEX_ERROR_STATS table specifies the error counters\n present in the ingress enhanced flex counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_GROUP_ACTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_group_action_profile_t_fields[] = {
    {
        .name  = CTR_ING_EFLEX_GROUP_ACTION_PROFILE_IDs,  /* CTR_ING_EFLEX_GROUP_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_GROUP_ACTION_PROFILE table.",
    },
    {
        .name  = GROUPs,  /* GROUP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enhanced flex counter action group.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTION_PROFILE_IDs,  /* CTR_ING_EFLEX_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "CTR_ING_EFLEX_ACTION_PROFILE table index which\n represents the group action profile ID.\n",
    },
    {
        .name  = GROUP_MAPs,  /* GROUP_MAP */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "Action profile IDs associated with the group action.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_STATE_T_DATA,
        .desc = "Read-only field which reflects the group action operational state.\n The operational state indicates ACTIVE once all\n CTR_ING_EFLEX_ACTION_PROFILE entries associated with the group\n have been inserted. It may be updated based on the changes to the\n CTR_ING_EFLEX_ACTION_PROFILE table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_group_action_profile_t = {
    .name = CTR_ING_EFLEX_GROUP_ACTION_PROFILEs, /* CTR_ING_EFLEX_GROUP_ACTION_PROFILE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ctr_ing_eflex_group_action_profile_t_fields,
    .desc = "The CTR_ING_EFLEX_GROUP_ACTION_PROFILE logical table specifies the\n ingress enhanced flex counter group action ID profile configuration.\n\n If group counter action is applied, its associated counter actions\n are selected for counter processing.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_HITBIT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_hitbit_control_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table ID.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = DST_CTR_ING_EFLEX_GROUP_ACTION_PROFILE_IDs,  /* DST_CTR_ING_EFLEX_GROUP_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_GROUP_ACTION_PROFILE table which\n specifies flex counter group action profile configuration for\n destination hit-bit lookup.\n",
    },
    {
        .name  = SRC_CTR_ING_EFLEX_GROUP_ACTION_PROFILE_IDs,  /* SRC_CTR_ING_EFLEX_GROUP_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_GROUP_ACTION_PROFILE table which\n specifies flex counter group action profile configuration for\n source hit-bit lookup.\n",
    },
    {
        .name  = DST_CTR_ING_EFLEX_ACTION_PROFILE_IDs,  /* DST_CTR_ING_EFLEX_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_ACTION_PROFILE table which\n specifies flex counter action profile configuration for\n destination hit-bit lookup.\n",
    },
    {
        .name  = SRC_CTR_ING_EFLEX_ACTION_PROFILE_IDs,  /* SRC_CTR_ING_EFLEX_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_ACTION_PROFILE table which\n specifies flex counter action profile configuration for\n source hit-bit lookup.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_STATE_T_DATA,
        .desc = "Read-only field which reflects the hitbit operational state.\n The operational state indicates ACTIVE once all valid\n CTR_ING_EFLEX_GROUP_ACTION_PROFILE entries associated with the\n TABLE_ID have been inserted. It may be updated based on the changes\n to the CTR_ING_EFLEX_GROUP_ACTION_PROFILE table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_hitbit_control_t = {
    .name = CTR_ING_EFLEX_HITBIT_CONTROLs, /* CTR_ING_EFLEX_HITBIT_CONTROL */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_ing_eflex_hitbit_control_t_fields,
    .desc = "The CTR_ING_EFLEX_HITBIT_CONTROL logical table specifies the\n ingress enhanced flex counter action ID profile configuration associated\n with the logical table for hit-bit monitoring.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_OBJ_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_obj_info_t_fields[] = {
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = MIN_BITs,  /* MIN_BIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Starting offset of the flex counter object.",
    },
    {
        .name  = MAX_BITs,  /* MAX_BIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ending offset of the flex counter object.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_obj_info_t = {
    .name = CTR_ING_EFLEX_OBJ_INFOs, /* CTR_ING_EFLEX_OBJ_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_ing_eflex_obj_info_t_fields,
    .desc = "The CTR_ING_EFLEX_OBJ_INFO logical table provides information\n about the ingress enhanced flex counter object bit offsets in the object bus.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_OBJ_QUANTIZATION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_obj_quantization_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = QUANTIZEs,  /* QUANTIZE */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable to set object quantization.",
    },
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .desc = "Objects selected for range check quantization .",
    },
    {
        .name  = OBJ_0_1_MODEs,  /* OBJ_0_1_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use 32-bit mode where quantized results\n of objects 0 and 1 are concatenated and assigned to\n object 0. Object 1 is unchanged.\n",
    },
    {
        .name  = OBJ_2_3_MODEs,  /* OBJ_2_3_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use 32-bit mode where quantized results\n of objects 2 and 3 are concatenated and assigned to\n object 2. Object 3 is unchanged.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_obj_quantization_t = {
    .name = CTR_ING_EFLEX_OBJ_QUANTIZATIONs, /* CTR_ING_EFLEX_OBJ_QUANTIZATION */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_ing_eflex_obj_quantization_t_fields,
    .desc = "The CTR_ING_EFLEX_OBJ_QUANTIZATION table configures the ingress\n object quantization controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_OPERAND_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_operand_profile_t_fields[] = {
    {
        .name  = CTR_ING_EFLEX_OPERAND_PROFILE_IDs,  /* CTR_ING_EFLEX_OPERAND_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the flex counter ingress operand profile table.",
    },
    {
        .name  = PROFILEs,  /* PROFILE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Flex counter ingress operand profile index.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = OBJ_1s,  /* OBJ_1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 1 selection result.",
    },
    {
        .name  = OBJ_2s,  /* OBJ_2 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 2 selection result.",
    },
    {
        .name  = MASK_SIZE_1s,  /* MASK_SIZE_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 1.",
    },
    {
        .name  = MASK_SIZE_2s,  /* MASK_SIZE_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 2.",
    },
    {
        .name  = SHIFT_1s,  /* SHIFT_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift amount for object 1.",
    },
    {
        .name  = SHIFT_2s,  /* SHIFT_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Left shift amount for object 2.",
    },
    {
        .name  = OBJ_3s,  /* OBJ_3 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 2 selection result.",
    },
    {
        .name  = MASK_SIZE_3s,  /* MASK_SIZE_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 2.",
    },
    {
        .name  = SHIFT_3s,  /* SHIFT_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift amount for object 1.",
    },
    {
        .name  = SHIFT_4s,  /* SHIFT_4 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift amount for object 1.",
    },
    {
        .name  = SHIFT_5s,  /* SHIFT_5 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift amount for object 1.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_operand_profile_t = {
    .name = CTR_ING_EFLEX_OPERAND_PROFILEs, /* CTR_ING_EFLEX_OPERAND_PROFILE */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_ctr_ing_eflex_operand_profile_t_fields,
    .desc = "The CTR_ING_EFLEX_OPERAND_PROFILE table computes ingress\n enhanced flex counter values A, B or counter index.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_OPERAND_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_operand_profile_info_t_fields[] = {
    {
        .name  = CTR_ING_EFLEX_OPERAND_PROFILE_IDs,  /* CTR_ING_EFLEX_OPERAND_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_OPERAND_PROFILE table.",
    },
    {
        .name  = PROFILEs,  /* PROFILE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Flex counter ingress operand profile index.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_operand_profile_info_t = {
    .name = CTR_ING_EFLEX_OPERAND_PROFILE_INFOs, /* CTR_ING_EFLEX_OPERAND_PROFILE_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_ing_eflex_operand_profile_info_t_fields,
    .desc = "The CTR_ING_EFLEX_OPERAND_PROFILE_INFO logical table provides information\n about the current ingress enhanced flex counter operand profile\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_PKT_ATTRIBUTE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_pkt_attribute_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = CTR_ING_EFLEX_PKT_ATTRIBUTE_IDs,  /* CTR_ING_EFLEX_PKT_ATTRIBUTE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_PKT_ATTRIBUTE table.",
    },
    {
        .name  = PKT_ATTRIBUTEs,  /* PKT_ATTRIBUTE */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable to select packet attribute.",
    },
    {
        .name  = PKT_ATTRIBUTE_MAPs,  /* PKT_ATTRIBUTE_MAP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .desc = "Packet attribute map.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_pkt_attribute_t = {
    .name = CTR_ING_EFLEX_PKT_ATTRIBUTEs, /* CTR_ING_EFLEX_PKT_ATTRIBUTE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_ing_eflex_pkt_attribute_t_fields,
    .desc = "The CTR_ING_EFLEX_PKT_ATTRIBUTE table specifies the\n ingress enhanced flex counter packet attribute configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_PKT_ATTRIBUTE_OBJECT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_pkt_attribute_object_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = CTR_ING_EFLEX_PKT_ATTRIBUTE_OBJECT_IDs,  /* CTR_ING_EFLEX_PKT_ATTRIBUTE_OBJECT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_PKT_ATTRIBUTE_OBJECT table.",
    },
    {
        .name  = PKT_ATTRIBUTE_OBJECT_INSTANCE_IDs,  /* PKT_ATTRIBUTE_OBJECT_INSTANCE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Packet attribute object instance.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enhanced flex counter object.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_pkt_attribute_object_t = {
    .name = CTR_ING_EFLEX_PKT_ATTRIBUTE_OBJECTs, /* CTR_ING_EFLEX_PKT_ATTRIBUTE_OBJECT */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_ing_eflex_pkt_attribute_object_t_fields,
    .desc = "The CTR_ING_EFLEX_PKT_ATTRIBUTE_OBJECT table specifies the\n ingress enhanced flex counter  packet attribute object configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_PKT_RESOLUTION_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_pkt_resolution_info_t_fields[] = {
    {
        .name  = CTR_ING_EFLEX_PKT_RESOLUTION_INFO_IDs,  /* CTR_ING_EFLEX_PKT_RESOLUTION_INFO_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_PKT_RESOLUTION_INFO table.",
    },
    {
        .name  = PKT_RESOLUTION_BITMAPs,  /* PKT_RESOLUTION_BITMAP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Packet resolution bitmap applied to select PKT_RESOLUTION_BITx\n specified in CTR_ING_EFLEX_PKT_ATTRIBUTE.PKT_ATTRIBUTE_MAP.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_pkt_resolution_info_t = {
    .name = CTR_ING_EFLEX_PKT_RESOLUTION_INFOs, /* CTR_ING_EFLEX_PKT_RESOLUTION_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_ing_eflex_pkt_resolution_info_t_fields,
    .desc = "The CTR_ING_EFLEX_PKT_RESOLUTION_INFO read only table provides\n ingress enhanced flex counter packet resolution information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_RANGE_CHK_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_range_chk_profile_t_fields[] = {
    {
        .name  = CTR_ING_EFLEX_RANGE_CHK_PROFILE_IDs,  /* CTR_ING_EFLEX_RANGE_CHK_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_RANGE_CHK_PROFILE table.",
    },
    {
        .name  = OBJ_SELECTs,  /* OBJ_SELECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Object whose value is to be range checked.",
    },
    {
        .name  = RANGE_CHECKERs,  /* RANGE_CHECKER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Range checker number.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = MINs,  /* MIN */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Minimum value for range checker.",
    },
    {
        .name  = MAXs,  /* MAX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum value for range checker.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_range_chk_profile_t = {
    .name = CTR_ING_EFLEX_RANGE_CHK_PROFILEs, /* CTR_ING_EFLEX_RANGE_CHK_PROFILE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ctr_ing_eflex_range_chk_profile_t_fields,
    .desc = "The CTR_ING_EFLEX_RANGE_CHK_PROFILE table configures the ingress\n object quantization range checkers with min and max values.\n\n Each range checker determines if the corresponding object value\n is within the min and max range.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_RANGE_CHK_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_range_chk_profile_info_t_fields[] = {
    {
        .name  = CTR_ING_EFLEX_RANGE_CHK_PROFILE_IDs,  /* CTR_ING_EFLEX_RANGE_CHK_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_RANGE_CHK_PROFILE table.",
    },
    {
        .name  = OBJ_SELECTs,  /* OBJ_SELECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Object whose value is to be range checked.",
    },
    {
        .name  = RANGE_CHECKERs,  /* RANGE_CHECKER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Range checker number.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_range_chk_profile_info_t = {
    .name = CTR_ING_EFLEX_RANGE_CHK_PROFILE_INFOs, /* CTR_ING_EFLEX_RANGE_CHK_PROFILE_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_ing_eflex_range_chk_profile_info_t_fields,
    .desc = "The CTR_ING_EFLEX_RANGE_CHK_PROFILE_INFO logical table provides information\n about the current ingress enhanced flex counter range checker profile\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_stats_t_fields[] = {
    {
        .name  = CTR_ING_EFLEX_ACTION_PROFILE_IDs,  /* CTR_ING_EFLEX_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_ACTION_PROFILE table.",
    },
    {
        .name  = CTR_EFLEX_INDEXs,  /* CTR_EFLEX_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Counter index.",
    },
    {
        .name  = CTR_A_UPPERs,  /* CTR_A_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value A. The applicability of this field is\n dependent on the counter width value specified in\n CTR_ING_EFLEX_ACTION_PROFILE.MODE field.\n",
    },
    {
        .name  = CTR_A_LOWERs,  /* CTR_A_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value A. The applicability of this field is\n dependent on the counter width value specified in\n CTR_ING_EFLEX_ACTION_PROFILE.MODE field.\n",
    },
    {
        .name  = CTR_Bs,  /* CTR_B */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value B. The applicability of this field is\n dependent on the counter width value specified in\n CTR_ING_EFLEX_ACTION_PROFILE.MODE field.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_stats_t = {
    .name = CTR_ING_EFLEX_STATSs, /* CTR_ING_EFLEX_STATS */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_ing_eflex_stats_t_fields,
    .desc = "The CTR_ING_EFLEX_STATS table is used to retrieve the\n the ingress enhanced flex counter A, B and C values.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_EFLEX_TRIGGER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_eflex_trigger_t_fields[] = {
    {
        .name  = CTR_ING_EFLEX_ACTION_PROFILE_IDs,  /* CTR_ING_EFLEX_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_ACTION_PROFILE table.",
    },
    {
        .name  = TRIGGERs,  /* TRIGGER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update counter based on trigger condition.\n Disable to always update counter.\n",
    },
    {
        .name  = STARTs,  /* START */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_START_TRIGGER_T_DATA,
        .desc = "Start trigger type.",
    },
    {
        .name  = STOPs,  /* STOP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Stop trigger type.",
    },
    {
        .name  = START_VALUEs,  /* START_VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Start value which will trigger counter update,\n when the following condition is met:\n CTR_ING_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK == START_VALUE\n if COMPARE_START == 0.\n CTR_ING_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK != START_VALUE\n if COMPARE_START == 1.\n\n Applicable only if START == CONDITION.\n",
    },
    {
        .name  = STOP_VALUEs,  /* STOP_VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Stop value which will stop counter update,.\n when the following condition is met:\n CTR_ING_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK == START_VALUE\n if COMPARE_STOP == 0.\n CTR_ING_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK != START_VALUE\n if COMPARE_STOP == 1.\n\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = COND_MASKs,  /* COND_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask value applied to start or stop value to select\n desired attributes.\n Applicable if START == CONDITION or STOP == CONDITION.\n",
    },
    {
        .name  = START_TIME_OFFSETs,  /* START_TIME_OFFSET */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Time offset from current time in nanoseconds\n to trigger counter update.\n Applicable only if START == TIME.\n",
    },
    {
        .name  = NUM_PERIODs,  /* NUM_PERIOD */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The number of periods to measure before stopping.\n If set to 0, then number of periods is infinite.\n To disable the trigger in this case,\n set NUM_PERIOD to non-zero value and enable TRIGGER.\n Applicable only if STOP == PERIOD.\n",
    },
    {
        .name  = NUM_ACTIONSs,  /* NUM_ACTIONS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of times a counter action is hit before stopping.\n Applicable only if STOP == ACTION_COUNT.\n",
    },
    {
        .name  = COMPARE_STARTs,  /* COMPARE_START */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If disabled then == is used as the compare function\n to trigger start counter update.\n If enabled then != is used as the compare function\n to trigger start counter update.\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = COMPARE_STOPs,  /* COMPARE_STOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If disabled then == is used as the compare function\n to trigger stopcounter update.\n If enabled then != is used as the compare function\n to trigger stop counter update.\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = SCALEs,  /* SCALE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Duration of a single time period. It determines interval\n calculation.\n Applicable only if STOP == PERIOD.\n",
    },
    {
        .name  = INTERVAL_SHIFTs,  /* INTERVAL_SHIFT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Interval is dependent on the result of timestamp\n duration divided by SCALE.\n Interval shift is for computing interval mask which to limit\n the number of interval argument to compute counter index.\n",
    },
    {
        .name  = INTERVAL_SIZEs,  /* INTERVAL_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies number of counters to left in an interval.\n It is pre-configured based on result of OPERAND LT.\n Applicable only the calculation of\n (interval & (2 ^ INTERVAL_SHIFT - 1) << INTERVAL_SIZE\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_STATE_T_DATA,
        .desc = "Read-only field which reflects the trigger operational state.\n The operational state indicates ACTIVE once a\n CTR_ING_EFLEX_ACTION_PROFILE entry has been inserted. It may be\n updated based on the changes to the CTR_EGR_EFLEX_ACTION_PROFILE\n table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_eflex_trigger_t = {
    .name = CTR_ING_EFLEX_TRIGGERs, /* CTR_ING_EFLEX_TRIGGER */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_ctr_ing_eflex_trigger_t_fields,
    .desc = "The CTR_ING_EFLEX_TRIGGER table configures the trigger function to\n enable conditional updates on ingress enhanced flex counter.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_FLEX_ATTR_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_flex_attr_template_t_fields[] = {
    {
        .name  = CTR_ING_FLEX_ATTR_TEMPLATE_IDs,  /* CTR_ING_FLEX_ATTR_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the ingress flex counter attribute template table.",
    },
    {
        .name  = CTR_FLEX_INSTANCEs,  /* CTR_FLEX_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Flex counter instance. The CTR_FLEX_INSTANCE represents\n a single counter within the CTR_ING_FLEX_ATTR_TEMPLATE_ID.\n",
    },
    {
        .name  = CTR_ING_FLEX_PKT_ATTR_TEMPLATE_IDs,  /* CTR_ING_FLEX_PKT_ATTR_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "CTR_ING_FLEX_PKT_ATTR_TEMPLATE table index. Used to define\n the packet attributes associated with this counter instance.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_flex_attr_template_t = {
    .name = CTR_ING_FLEX_ATTR_TEMPLATEs, /* CTR_ING_FLEX_ATTR_TEMPLATE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_ing_flex_attr_template_t_fields,
    .desc = "The CTR_ING_FLEX_ATTR_TEMPLATE table associates ingress packet\n attributes to one or more flex counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_FLEX_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_flex_entry_t_fields[] = {
    {
        .name  = CTR_ING_FLEX_ENTRY_IDs,  /* CTR_ING_FLEX_ENTRY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_FLEX_ENTRY table.\n",
    },
    {
        .name  = CTR_ING_FLEX_ATTR_TEMPLATE_IDs,  /* CTR_ING_FLEX_ATTR_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "CTR_ING_FLEX_ATTR_TEMPLATE table index. The ID represents\n a group of flex counter instances.\n",
    },
    {
        .name  = MAX_INSTANCES_AUTOs,  /* MAX_INSTANCES_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to automatically determine MAX_INSTANCES.\n When this field is enabled, the calculated maximum instances\n is reflected in the MAX_INSTANCES_OPER field.\n",
    },
    {
        .name  = MAX_INSTANCESs,  /* MAX_INSTANCES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The maximum number of flex counter instances\n allocated for this BASE_INDEX. Exceeding this\n maximum results in an operational state error.\n",
    },
    {
        .name  = MAX_INSTANCES_OPERs,  /* MAX_INSTANCES_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Computed valued of MAX_INSTANCES. Read-Only field is\n applicable only when the MAX_INSTANCES_AUTO field is enabled.\n",
    },
    {
        .name  = POOL_IDs,  /* POOL_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter pool ID. An application should ensure that a\n packet is counted in no more than one counter per pool.\n The same POOL_ID should not be assigned to accouting objects\n that could generate multiple hits for the same packet.\n",
    },
    {
        .name  = OFFSET_MODEs,  /* OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter offset mode.",
    },
    {
        .name  = BASE_INDEX_AUTOs,  /* BASE_INDEX_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to automatically calculate the value of BASE_INDEX. When\n this field is enabled, the calculated base index is reflected in\n the BASE_INDEX_OPER field.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Base counter index. Applicable only when BASE_INDEX_AUTO\n is disabled. The BASE_INDEX should not overlap any existing\n counter instances and must be positioned with sufficient\n space for its own counter instances.\n",
    },
    {
        .name  = BASE_INDEX_OPERs,  /* BASE_INDEX_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Computed valued of BASE_INDEX. Read-Only field is applicable only\n when the BASE_INDEX_AUTO field is enabled.\n",
    },
    {
        .name  = PIPE_UNIQUEs,  /* PIPE_UNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Pipe unique indicates the entry will be attached to an accounting\n source on the pipeline specified by PIPE.\n",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "XGS pipeline number.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_FLEX_OPERATIONAL_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The operational state indicates OPERATIONAL_STATE_OK once the entry\n is associated with a valid CTR_ING_FLEX_ATTR_TEMPLATE table entry\n that has at least one counter instance associated with a valid\n CTR_ING_FLEX_PKT_ATTR_TEMPLATE table entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_flex_entry_t = {
    .name = CTR_ING_FLEX_ENTRYs, /* CTR_ING_FLEX_ENTRY */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_ctr_ing_flex_entry_t_fields,
    .desc = "The CTR_ING_FLEX_ENTRY table specifies the ingress flex counter\n configuration. Inserting an entry in this table configures flex\n counters that may be attached to ingress accounting objects.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_FLEX_PKT_ATTR_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_flex_pkt_attr_template_t_fields[] = {
    {
        .name  = CTR_ING_FLEX_PKT_ATTR_TEMPLATE_IDs,  /* CTR_ING_FLEX_PKT_ATTR_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_FLEX_PKT_ATTR_TEMPLATE table",
    },
    {
        .name  = IPs,  /* IP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select IP packets.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select dropped packets.",
    },
    {
        .name  = PKT_TYPE_ALLs,  /* PKT_TYPE_ALL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select all packet types.",
    },
    {
        .name  = PKT_TYPE_UNKNOWNs,  /* PKT_TYPE_UNKNOWN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select unknown packets.",
    },
    {
        .name  = PKT_TYPE_CONTROLs,  /* PKT_TYPE_CONTROL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select control packets.",
    },
    {
        .name  = PKT_TYPE_OAMs,  /* PKT_TYPE_OAM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select OAM (Operations, Adminstration, Maintenance)\n packets.\n",
    },
    {
        .name  = PKT_TYPE_BFDs,  /* PKT_TYPE_BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select BFD (Bidirectional Forwarding Detection)\n packets.\n",
    },
    {
        .name  = PKT_TYPE_BPDUs,  /* PKT_TYPE_BPDU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select BPDU (Bridge Protocol Data Unit) packets.",
    },
    {
        .name  = PKT_TYPE_ICNMs,  /* PKT_TYPE_ICNM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select ICNM packets.",
    },
    {
        .name  = PKT_TYPE_1588s,  /* PKT_TYPE_1588 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select 1588 packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_L2UCs,  /* PKT_TYPE_KNOWN_L2UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select known L2 unicast packets.",
    },
    {
        .name  = PKT_TYPE_UNKNOWN_L2UCs,  /* PKT_TYPE_UNKNOWN_L2UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select unknown L2 unicast packets.",
    },
    {
        .name  = PKT_TYPE_L2BCs,  /* PKT_TYPE_L2BC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select L2BC (L2 Broadcast) packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_L2MCs,  /* PKT_TYPE_KNOWN_L2MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select known L2 multicast packets.",
    },
    {
        .name  = PKT_TYPE_UNKNOWN_L2MCs,  /* PKT_TYPE_UNKNOWN_L2MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select unknown L2 multicast packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_L3UCs,  /* PKT_TYPE_KNOWN_L3UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select known L3 unicast packets.",
    },
    {
        .name  = PKT_TYPE_UNKNOWN_L3UCs,  /* PKT_TYPE_UNKNOWN_L3UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select unknown L3 unicast packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_IPMCs,  /* PKT_TYPE_KNOWN_IPMC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select known IP multicast packets.",
    },
    {
        .name  = PKT_TYPE_UNKNOWN_IPMCs,  /* PKT_TYPE_UNKNOWN_IPMC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select unknown IP multicast packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_MPLS_L2s,  /* PKT_TYPE_KNOWN_MPLS_L2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select known L2 MPLS packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_MPLS_L3s,  /* PKT_TYPE_KNOWN_MPLS_L3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select known L3 MPLS packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_MPLSs,  /* PKT_TYPE_KNOWN_MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select known MPLS packets.",
    },
    {
        .name  = PKT_TYPE_UNKNOWN_MPLSs,  /* PKT_TYPE_UNKNOWN_MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select unknown MPLS packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_MPLS_MCs,  /* PKT_TYPE_KNOWN_MPLS_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select known MPLS multicast packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_MIMs,  /* PKT_TYPE_KNOWN_MIM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select known MIM (Mac in mac) packets.",
    },
    {
        .name  = PKT_TYPE_UNKNOWN_MIMs,  /* PKT_TYPE_UNKNOWN_MIM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select unknown MIM (Mac in mac) packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_L2GRE_PKTs,  /* PKT_TYPE_KNOWN_L2GRE_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select L2GRE packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_VXLAN_PKTs,  /* PKT_TYPE_KNOWN_VXLAN_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select VXLAN packets.",
    },
    {
        .name  = PKT_TYPE_KNOWN_TRILLs,  /* PKT_TYPE_KNOWN_TRILL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select known TRILL (Transparent Interconnection\n of Lots of Links) packets.\n",
    },
    {
        .name  = PKT_TYPE_UNKNOWN_TRILLs,  /* PKT_TYPE_UNKNOWN_TRILL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select unknown TRILL (Transparent Interconnection\n of Lots of Links) packets.\n",
    },
    {
        .name  = PKT_TYPE_KNOWN_NIVs,  /* PKT_TYPE_KNOWN_NIV */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select known NIV (Network Interface Virtualization)\n packets.\n",
    },
    {
        .name  = PKT_TYPE_UNKNOWN_NIVs,  /* PKT_TYPE_UNKNOWN_NIV */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select unknown NIV (Network Interface Virtualization)\n packets.\n",
    },
    {
        .name  = ACCESS_SVPs,  /* ACCESS_SVP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select access-facing SVP type.",
    },
    {
        .name  = NETWORK_SVPs,  /* NETWORK_SVP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select network-facing SVP type.",
    },
    {
        .name  = TOS_ECNs,  /* TOS_ECN */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Specifies Explicit Congrestion Notification TOS.",
    },
    {
        .name  = TOS_DSCPs,  /* TOS_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Specifies Differentiated Services TOS.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress logical port.",
    },
    {
        .name  = INT_CNs,  /* INT_CN */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Internal congestion.",
    },
    {
        .name  = OUTER_DOT1Ps,  /* OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer 802.1p priority.",
    },
    {
        .name  = INNER_DOT1Ps,  /* INNER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner 802.1p priority.",
    },
    {
        .name  = VLAN_UTs,  /* VLAN_UT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select untagged VLAN packets.",
    },
    {
        .name  = VLAN_SITs,  /* VLAN_SIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select inner VLAN tagged packets.",
    },
    {
        .name  = VLAN_SOTs,  /* VLAN_SOT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select outer VLAN tagged packets.",
    },
    {
        .name  = VLAN_DTs,  /* VLAN_DT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select inner and outer tagged VLAN packets.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal Priority.",
    },
    {
        .name  = FP_G_COLORs,  /* FP_G_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select field processor green packets.",
    },
    {
        .name  = FP_Y_COLORs,  /* FP_Y_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select field processor yellow packets.",
    },
    {
        .name  = FP_R_COLORs,  /* FP_R_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select field processor red packets.",
    },
    {
        .name  = PRE_FP_G_COLORs,  /* PRE_FP_G_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select pre-field processor green packets.",
    },
    {
        .name  = PRE_FP_Y_COLORs,  /* PRE_FP_Y_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select pre-field processor yellow packets.",
    },
    {
        .name  = PRE_FP_R_COLORs,  /* PRE_FP_R_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select pre-field processor red packets.",
    },
    {
        .name  = ELEPHANT_PKTs,  /* ELEPHANT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select elephant packets.",
    },
    {
        .name  = TCP_FLAG_TYPE_SYNs,  /* TCP_FLAG_TYPE_SYN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "TCP SYN flag.",
    },
    {
        .name  = TCP_FLAG_TYPE_FINs,  /* TCP_FLAG_TYPE_FIN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "TCP FIN flag.",
    },
    {
        .name  = TCP_FLAG_TYPE_RSTs,  /* TCP_FLAG_TYPE_RST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "TCP RST flag.",
    },
    {
        .name  = TCP_FLAG_TYPE_PSHs,  /* TCP_FLAG_TYPE_PSH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "TCP PSH flag.",
    },
    {
        .name  = TCP_FLAG_TYPE_ACKs,  /* TCP_FLAG_TYPE_ACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "TCP ACK flag.",
    },
    {
        .name  = TCP_FLAG_TYPE_URGs,  /* TCP_FLAG_TYPE_URG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "TCP URG flag.",
    },
    {
        .name  = TCP_FLAG_TYPE_ECEs,  /* TCP_FLAG_TYPE_ECE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "TCP ECE flag.",
    },
    {
        .name  = TCP_FLAG_TYPE_CWRs,  /* TCP_FLAG_TYPE_CWR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "TCP CWR flag.",
    },
    {
        .name  = MPLS_EXPs,  /* MPLS_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Specifies MPLS experimental field.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_flex_pkt_attr_template_t = {
    .name = CTR_ING_FLEX_PKT_ATTR_TEMPLATEs, /* CTR_ING_FLEX_PKT_ATTR_TEMPLATE */
    .flags = 0,
    .fields = 62,
    .field = bcmltd_ctr_ing_flex_pkt_attr_template_t_fields,
    .desc = "The CTR_ING_FLEX_PKT_ATTR_TEMPLATE table specifies the packet\n attributes to be applied to a flex counter instance.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_FLEX_POOL_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_flex_pool_control_t_fields[] = {
    {
        .name  = CTR_ING_FLEX_POOL_IDs,  /* CTR_ING_FLEX_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter pool ID.",
    },
    {
        .name  = EVICTION_MODEs,  /* EVICTION_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Eviction operating mode.",
    },
    {
        .name  = EVICTION_THD_BYTESs,  /* EVICTION_THD_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction threshold in bytes.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_THD_PKTSs,  /* EVICTION_THD_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Eviction threshold in packets.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_THD_CTR_As,  /* EVICTION_THD_CTR_A */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction threshold for counter A.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_THD_CTR_Bs,  /* EVICTION_THD_CTR_B */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction threshold for counter B.\n  Applicable only if EVICTION_MODE == THRESHOLD.\n",
    },
    {
        .name  = EVICTION_SEEDs,  /* EVICTION_SEED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Eviction random seed.\n  Applicable only if EVICTION_MODE == RANDOM.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_flex_pool_control_t = {
    .name = CTR_ING_FLEX_POOL_CONTROLs, /* CTR_ING_FLEX_POOL_CONTROL */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_ing_flex_pool_control_t_fields,
    .desc = "The CTR_ING_FLEX_POOL_CONTROL table specifies the ingress per-flex\n  counter pool properties.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_FLEX_POOL_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_flex_pool_info_t_fields[] = {
    {
        .name  = CTR_ING_FLEX_POOL_INFO_IDs,  /* CTR_ING_FLEX_POOL_INFO_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_FLEX_POOL_INFO table.",
    },
    {
        .name  = POOL_SIZEs,  /* POOL_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Indicates the number of counters in the pool.",
    },
    {
        .name  = RESERVED_FOR_FPs,  /* RESERVED_FOR_FP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates this pool can only be attached to field processor.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_flex_pool_info_t = {
    .name = CTR_ING_FLEX_POOL_INFOs, /* CTR_ING_FLEX_POOL_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_ing_flex_pool_info_t_fields,
    .desc = "The CTR_ING_FLEX_POOL_INFO read only table provides ingress flex\n counter pool information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_FLEX_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_flex_stats_t_fields[] = {
    {
        .name  = CTR_ING_FLEX_ENTRY_IDs,  /* CTR_ING_FLEX_ENTRY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter entry ID.",
    },
    {
        .name  = CTR_FLEX_INSTANCEs,  /* CTR_FLEX_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Counter instance.",
    },
    {
        .name  = BYTESs,  /* BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Byte counter.",
    },
    {
        .name  = PKTSs,  /* PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Packet counter.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_FLEX_STATS_STATE_T_DATA,
        .desc = "Read-only field which reflects the counter operational state.\n The operational state indicates ACTIVE once a CTR_ING_FLEX_ENTRY\n has been inserted.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_flex_stats_t = {
    .name = CTR_ING_FLEX_STATSs, /* CTR_ING_FLEX_STATS */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_ing_flex_stats_t_fields,
    .desc = "The CTR_ING_FLEX_STATS table is used to retrieve the\n the packet and byte counts for ingress flex counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_TM_BST_PORT_PRI_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_tm_bst_port_pri_grp_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress port.",
    },
    {
        .name  = TM_PRI_GRP_IDs,  /* TM_PRI_GRP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Priority group.",
    },
    {
        .name  = SHARED_CELLSs,  /* SHARED_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Shared tracking counter in cells.",
    },
    {
        .name  = HEADROOM_CELLSs,  /* HEADROOM_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Headroom tracking counter in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_tm_bst_port_pri_grp_t = {
    .name = CTR_ING_TM_BST_PORT_PRI_GRPs, /* CTR_ING_TM_BST_PORT_PRI_GRP */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_ing_tm_bst_port_pri_grp_t_fields,
    .desc = "The CTR_ING_TM_BST_PORT_PRI_GRP table is used to retrieve the\n BST tracking counters per ingress port, per priority group.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_TM_BST_PORT_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_tm_bst_port_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress port.",
    },
    {
        .name  = TM_ING_SERVICE_POOL_IDs,  /* TM_ING_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tracking counter in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_tm_bst_port_service_pool_t = {
    .name = CTR_ING_TM_BST_PORT_SERVICE_POOLs, /* CTR_ING_TM_BST_PORT_SERVICE_POOL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_ing_tm_bst_port_service_pool_t_fields,
    .desc = "The CTR_ING_TM_BST_PORT_SERVICE_POOL table is used to retrieve the\n BST tracking counter per ingress port, per service pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_TM_BST_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_tm_bst_service_pool_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_ING_SERVICE_POOL_INDEXs,  /* TM_ING_SERVICE_POOL_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service Pool Index.",
    },
    {
        .name  = SHARED_CELLSs,  /* SHARED_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Shared tracking counter in cells.",
    },
    {
        .name  = HEADROOM_CELLSs,  /* HEADROOM_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Headroom tracking counter in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_tm_bst_service_pool_t = {
    .name = CTR_ING_TM_BST_SERVICE_POOLs, /* CTR_ING_TM_BST_SERVICE_POOL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_ing_tm_bst_service_pool_t_fields,
    .desc = "The CTR_ING_TM_BST_SERVICE_POOL table is used to retrieve the\n BST tracking counter per ingress service pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_TM_HEADROOM_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_tm_headroom_pool_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_HEADROOM_POOL_IDs,  /* TM_HEADROOM_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Headroom pool ID.",
    },
    {
        .name  = TOTAL_USAGE_CELLSs,  /* TOTAL_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of cells currently in use by all\n Priority Groups (PGs) using the headroom pool.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_tm_headroom_pool_t = {
    .name = CTR_ING_TM_HEADROOM_POOLs, /* CTR_ING_TM_HEADROOM_POOL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_ing_tm_headroom_pool_t_fields,
    .desc = "The CTR_ING_TM_HEADROOM_POOL table specifies device usage per headroom\n pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_TM_PORT_PRI_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_tm_port_pri_grp_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_PRI_GRP_IDs,  /* TM_PRI_GRP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Priority group ID.",
    },
    {
        .name  = HEADROOM_USAGE_CELLSs,  /* HEADROOM_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Local headroom pool usage in cells.",
    },
    {
        .name  = MIN_USAGE_CELLSs,  /* MIN_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Minimum guaranteed usage in cells.",
    },
    {
        .name  = SHARED_USAGE_CELLSs,  /* SHARED_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Shared usage in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n the mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_tm_port_pri_grp_t = {
    .name = CTR_ING_TM_PORT_PRI_GRPs, /* CTR_ING_TM_PORT_PRI_GRP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ctr_ing_tm_port_pri_grp_t_fields,
    .desc = "The CTR_ING_TM_PORT_PRI_GRP table specifies per-port priority group\n usage in cells.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_TM_PORT_UC_DROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_tm_port_uc_drop_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = LOSSLESS_PRI_GRPs,  /* LOSSLESS_PRI_GRP */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enabled to indicate that the packet was dropped for the\n corresponding lossless priority-group. Once set, the\n application needs to clear it.\n",
    },
    {
        .name  = PKTs,  /* PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of dropped unicast packets on the ingress port.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of\n the entry. The OPERATIONAL_STATE of the entry becomes invalid\n if the mapping between PORT_ID to the physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_tm_port_uc_drop_t = {
    .name = CTR_ING_TM_PORT_UC_DROPs, /* CTR_ING_TM_PORT_UC_DROP */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_ing_tm_port_uc_drop_t_fields,
    .desc = "The CTR_ING_TM_PORT_UC_DROP table specifies per port unicast packet\n drop counts for ingress admission.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_TM_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_tm_service_pool_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_ING_SERVICE_POOL_IDs,  /* TM_ING_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = TOTAL_USAGE_CELLSs,  /* TOTAL_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of cells currently in use by all the ports using\n the service pool.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_tm_service_pool_t = {
    .name = CTR_ING_TM_SERVICE_POOLs, /* CTR_ING_TM_SERVICE_POOL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_ing_tm_service_pool_t_fields,
    .desc = "The CTR_ING_TM_SERVICE_POOL table specifies device usage per service\n pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_TM_THD_HEADROOM_POOL_LOSSLESS_UC_DROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_tm_thd_headroom_pool_lossless_uc_drop_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_HEADROOM_POOL_IDs,  /* TM_HEADROOM_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Headroom pool ID.",
    },
    {
        .name  = PKTs,  /* PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of dropped packets.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_tm_thd_headroom_pool_lossless_uc_drop_t = {
    .name = CTR_ING_TM_THD_HEADROOM_POOL_LOSSLESS_UC_DROPs, /* CTR_ING_TM_THD_HEADROOM_POOL_LOSSLESS_UC_DROP */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_ing_tm_thd_headroom_pool_lossless_uc_drop_t_fields,
    .desc = "The CTR_ING_TM_THD_HEADROOM_POOL_LOSSLESS_UC_DROP table\n specifies drop counters for lossless unicast packets per headroom\n pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_TM_THD_PORT_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_tm_thd_port_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_ING_SERVICE_POOL_IDs,  /* TM_ING_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = MIN_USAGE_CELLSs,  /* MIN_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Minimum guaranteed usage in cells.",
    },
    {
        .name  = SHARED_USAGE_CELLSs,  /* SHARED_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Shared usage in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n the mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_tm_thd_port_service_pool_t = {
    .name = CTR_ING_TM_THD_PORT_SERVICE_POOLs, /* CTR_ING_TM_THD_PORT_SERVICE_POOL */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_ing_tm_thd_port_service_pool_t_fields,
    .desc = "The CTR_ING_TM_THD_PORT_SERVICE_POOL table specifies per-port service\n pool usage in cells for min guarantee and shared usage.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_ING_TRACE_EVENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_ing_trace_event_t_fields[] = {
    {
        .name  = CTR_ING_TRACE_EVENT_IDs,  /* CTR_ING_TRACE_EVENT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the CTR_ING_TRACE_EVENT table.",
    },
    {
        .name  = TRACE_CNTs,  /* TRACE_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress trace event count.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_ing_trace_event_t = {
    .name = CTR_ING_TRACE_EVENTs, /* CTR_ING_TRACE_EVENT */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_ing_trace_event_t_fields,
    .desc = "The CTR_ING_TRACE_EVENT table is used to count ingress trace events.\n Ingress trace events indicate that a specific logic condition was hit\n during processing. Multiple ingress trace events can coexist for a packet\n without interfering with each other.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_L3.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_l3_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port Number",
    },
    {
        .name  = RX_IPV4_DISCARDs,  /* RX_IPV4_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive IPv4 Discard Packet Counter.",
    },
    {
        .name  = RX_IPV4_UCs,  /* RX_IPV4_UC */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive IPv4 Unicast Packet Counter.",
    },
    {
        .name  = RX_IPV4_HDR_ERRs,  /* RX_IPV4_HDR_ERR */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive IPv4 IP Header Error Packet Counter.",
    },
    {
        .name  = RX_IPV4_ROUTE_MCs,  /* RX_IPV4_ROUTE_MC */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive IPv4 Routed Multicast Packets.",
    },
    {
        .name  = RX_IPV6_DISCARDs,  /* RX_IPV6_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive IPv6 Discard Packet Counter.",
    },
    {
        .name  = RX_IPV6_UCs,  /* RX_IPV6_UC */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive IPv6 Unicast Packet Counter.",
    },
    {
        .name  = RX_IPV6_HDR_ERRs,  /* RX_IPV6_HDR_ERR */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive IPv6 IP Header Error Packet Counter.",
    },
    {
        .name  = RX_IPV6_ROUTE_MCs,  /* RX_IPV6_ROUTE_MC */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive IPv6 Routed Multicast Packets.",
    },
    {
        .name  = RX_DISCARDs,  /* RX_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive Discard Packet Counter.",
    },
    {
        .name  = RX_UCs,  /* RX_UC */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive Unicast Counter.",
    },
    {
        .name  = RX_PORT_DISCARDs,  /* RX_PORT_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Incremented when spanning tree state\n is not in forwarding state.\n",
    },
    {
        .name  = RX_HIGIG_UNKNOWN_PKTs,  /* RX_HIGIG_UNKNOWN_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive Unknown HiGig Packet Counter.",
    },
    {
        .name  = RX_HIGIG_CTRL_PKTs,  /* RX_HIGIG_CTRL_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive HiGig Packet with Control Opcode Counter.",
    },
    {
        .name  = RX_HIGIG_BC_PKTs,  /* RX_HIGIG_BC_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive HiGig Packet with Broadcast Opcode Counter.",
    },
    {
        .name  = RX_HIGIG_L2MC_OPCODE_PKTs,  /* RX_HIGIG_L2MC_OPCODE_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive HiGig Packet with L2MC Opcode Counter.",
    },
    {
        .name  = RX_HIGIG_IPMC_OPCODE_PKTs,  /* RX_HIGIG_IPMC_OPCODE_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive HiGig Packet with IPMC Opcode Counter.",
    },
    {
        .name  = RX_HIGIG_UNKNOWN_OPCODE_PKTs,  /* RX_HIGIG_UNKNOWN_OPCODE_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Receive HiGig Packet with Unknown Opcode Counter.",
    },
    {
        .name  = RX_TNLs,  /* RX_TNL */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Reveive Tunnel Packet Counter.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_l3_t = {
    .name = CTR_L3s, /* CTR_L3 */
    .flags = 0,
    .fields = 20,
    .field = bcmltd_ctr_l3_t_fields,
    .desc = "Logical Table for L3 Counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_MAC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_mac_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port Number",
    },
    {
        .name  = RX_64B_PKTs,  /* RX_64B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all RX packets (IEEE 64 bytes) or (HiGig 72 bytes)\n or (HiGig2 76 bytes).\n",
    },
    {
        .name  = TX_64B_PKTs,  /* TX_64B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all TX packets (IEEE 64 bytes) or (HiGig 72 bytes)\n or (HiGig2 76 bytes).\n",
    },
    {
        .name  = RX_127B_PKTs,  /* RX_127B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of Rx packets (IEEE 65<=size<=127 bytes) or\n (Higig 73<=size<=127 bytes) or (Higig2 77<=size<=127 bytes).\n",
    },
    {
        .name  = TX_127B_PKTs,  /* TX_127B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of Tx packets (IEEE 65<=size<=127 bytes) or\n (Higig 73<=size<=127 bytes) or (Higig2 77<=size<=127 bytes).\n",
    },
    {
        .name  = RX_255B_PKTs,  /* RX_255B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Rx packets such that 128<=size<=255 bytes.",
    },
    {
        .name  = TX_255B_PKTs,  /* TX_255B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Tx packets such that 128<=size<=255 bytes.",
    },
    {
        .name  = RX_511B_PKTs,  /* RX_511B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Rx packets such that 256<=size<=511 bytes.",
    },
    {
        .name  = TX_511B_PKTs,  /* TX_511B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Tx packets such that 256<=size<=511 bytes.",
    },
    {
        .name  = RX_1023B_PKTs,  /* RX_1023B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Rx packets such that 512<=size<=1023 bytes.",
    },
    {
        .name  = TX_1023B_PKTs,  /* TX_1023B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Tx packets such that 512<=size<=1023 bytes.",
    },
    {
        .name  = RX_1518B_PKTs,  /* RX_1518B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Rx packets such that 1024<=size<=1518 bytes.",
    },
    {
        .name  = TX_1518B_PKTs,  /* TX_1518B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Tx packets such that 1024<=size<=1518 bytes.",
    },
    {
        .name  = RX_2047B_PKTs,  /* RX_2047B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Rx packets such that 1519<=size<=2047 bytes.",
    },
    {
        .name  = TX_2047B_PKTs,  /* TX_2047B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Tx packets such that 1519<=size<=2047 bytes.",
    },
    {
        .name  = RX_4095B_PKTs,  /* RX_4095B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Rx packets such that 2048<=size<=4095 bytes.",
    },
    {
        .name  = TX_4095B_PKTs,  /* TX_4095B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Tx packets such that 2048<=size<=4095 bytes.",
    },
    {
        .name  = RX_9216B_PKTs,  /* RX_9216B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Rx packets such that 4096<=size<=9216 bytes.",
    },
    {
        .name  = TX_9216B_PKTs,  /* TX_9216B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Tx packets such that 4096<=size<=9216 bytes.",
    },
    {
        .name  = RX_16383B_PKTs,  /* RX_16383B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Rx packets such that 9217<=size<=16838 bytes.",
    },
    {
        .name  = TX_16383B_PKTs,  /* TX_16383B_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of all Tx packets such that 9217<=size<=16838 bytes.",
    },
    {
        .name  = RX_VLAN_PKTs,  /* RX_VLAN_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of Rx VLAN pkts (excludes FCS errors) which is\n 1519 to 1522 bytes in length inclusive (excluding framing\n bits but including FCS bytes).\n",
    },
    {
        .name  = TX_VLAN_PKTs,  /* TX_VLAN_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of Tx VLAN pkts (excludes FCS errors) which is\n 1519 to 1522 bytes in length inclusive (excluding framing\n bits but including FCS bytes).\n",
    },
    {
        .name  = RX_PKTs,  /* RX_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Includes Rx bad packets, UC, BC, MC and MAC control packets.",
    },
    {
        .name  = TX_PKTs,  /* TX_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Includes Tx bad packets, UC, BC, MC and MAC control packets.",
    },
    {
        .name  = RX_UC_PKTs,  /* RX_UC_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Rx Unicast good pkts (valid FCS, no code error and pass length\n and field checks.\n",
    },
    {
        .name  = TX_UC_PKTs,  /* TX_UC_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tx Unicast good pkts (valid FCS, no code error and pass length\n and field checks.\n",
    },
    {
        .name  = RX_MC_PKTs,  /* RX_MC_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Multicast Rx good pkts (valid FCS, no code error and pass length\n and field checks.\n",
    },
    {
        .name  = TX_MC_PKTs,  /* TX_MC_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Multicast Tx good pkts (valid FCS, no code error and pass length\n and field checks.\n",
    },
    {
        .name  = RX_BC_PKTs,  /* RX_BC_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Broadcast Rx good pkts (valid FCS, no code error and pass length\n  field checks.\n",
    },
    {
        .name  = TX_BC_PKTs,  /* TX_BC_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Broadcast Tx good pkts (valid FCS, no code error and pass length\n  field checks.\n",
    },
    {
        .name  = RX_CTL_PKTs,  /* RX_CTL_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "MAC Rx Control packets\n a) size>=64 bytes\n b) DA!=0x0180C2000001 or DA!=MACSA\n c) PROTOCOL TYPE==0x8808.\n",
    },
    {
        .name  = TX_CTL_PKTs,  /* TX_CTL_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "MAC Tx Control packets\n a) size>=64 bytes\n b) Pause or Unsupported\n",
    },
    {
        .name  = RX_PAUSE_CTL_PKTs,  /* RX_PAUSE_CTL_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Rx Pause Control packets\n a) size>=64 bytes\n b) DA==0x0180C2000001 or DA==MACSA\n c) PROTOCOL TYPE==0x8808\n d) Control opcode==0x0001\n",
    },
    {
        .name  = TX_PAUSE_CTL_PKTs,  /* TX_PAUSE_CTL_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tx Pause Control packets\n a) size>=64 bytes\n",
    },
    {
        .name  = RX_PER_PRI_PAUSE_CTL_PKTs,  /* RX_PER_PRI_PAUSE_CTL_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Per-Priority Rx Pause Control packets\n a) size>=64 bytes\n b) DA==0x0180C2000001 or DA==MACSA\n c) PROTOCOL TYPE==0x8808\n d) Control opcode==01-01\n",
    },
    {
        .name  = TX_PER_PRI_PAUSE_CTL_PKTs,  /* TX_PER_PRI_PAUSE_CTL_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Per-Priority Tx Pause Control packets.\n a) size>=64 bytes\n",
    },
    {
        .name  = RX_MATCHED_CRC_PKTs,  /* RX_MATCHED_CRC_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "4-byte CRC matching the programmed value.",
    },
    {
        .name  = RX_VLAN_TAG_PKTs,  /* RX_VLAN_TAG_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Rx Packets with VLAN tag but not double tagged VLAN",
    },
    {
        .name  = TX_VLAN_TAG_PKTs,  /* TX_VLAN_TAG_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tx Packets with VLAN tag but not double tagged VLAN",
    },
    {
        .name  = RX_DOUBLE_VLAN_PKTs,  /* RX_DOUBLE_VLAN_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Rx Packets with double VLAN tag",
    },
    {
        .name  = TX_DOUBLE_VLAN_PKTs,  /* TX_DOUBLE_VLAN_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tx Packets with double VLAN tag",
    },
    {
        .name  = RX_OK_PKTs,  /* RX_OK_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Rx OK Packets\n a) No CRC error\n b) No error termination\n c) No truncation\n d) No control packets\n",
    },
    {
        .name  = TX_OK_PKTs,  /* TX_OK_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tx OK Packets\n a) No CRC error\n b) No error termination\n c) No truncation\n d) No control packets\n",
    },
    {
        .name  = RX_PFC_OFF_PKT_PRI0s,  /* RX_PFC_OFF_PKT_PRI0 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "PFC is achieved using Pause Packets.\n Counts Pause transition from XON to XOFF state\n for CoS priority level 0.\n",
    },
    {
        .name  = RX_PFC_OFF_PKT_PRI1s,  /* RX_PFC_OFF_PKT_PRI1 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Pause transition from XON to XOFF state\n for CoS priority level 1.\n",
    },
    {
        .name  = RX_PFC_OFF_PKT_PRI2s,  /* RX_PFC_OFF_PKT_PRI2 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Pause transition from XON to XOFF state\n  for CoS priority level 2.\n",
    },
    {
        .name  = RX_PFC_OFF_PKT_PRI3s,  /* RX_PFC_OFF_PKT_PRI3 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Pause transition from XON to XOFF state\n for CoS priority level 3.\n",
    },
    {
        .name  = RX_PFC_OFF_PKT_PRI4s,  /* RX_PFC_OFF_PKT_PRI4 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Pause transition from XON to XOFF state\n for CoS priority level 4.\n",
    },
    {
        .name  = RX_PFC_OFF_PKT_PRI5s,  /* RX_PFC_OFF_PKT_PRI5 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Pause transition from XON to XOFF state\n for CoS priority level 5.\n",
    },
    {
        .name  = RX_PFC_OFF_PKT_PRI6s,  /* RX_PFC_OFF_PKT_PRI6 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Pause transition from XON to XOFF state\n for CoS priority level 6.\n",
    },
    {
        .name  = RX_PFC_OFF_PKT_PRI7s,  /* RX_PFC_OFF_PKT_PRI7 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Pause transition from XON to XOFF state\n for CoS priority level 7.\n",
    },
    {
        .name  = TX_PFC_OFF_PKT_PRI0s,  /* TX_PFC_OFF_PKT_PRI0 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts TX Pause transition from XON to XOFF state\n for CoS priority level 0.\n",
    },
    {
        .name  = TX_PFC_OFF_PKT_PRI1s,  /* TX_PFC_OFF_PKT_PRI1 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts TX Pause transition from XON to XOFF state\n for CoS priority level 1.\n",
    },
    {
        .name  = TX_PFC_OFF_PKT_PRI2s,  /* TX_PFC_OFF_PKT_PRI2 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts TX Pause transition from XON to XOFF state\n for CoS priority level 2.\n",
    },
    {
        .name  = TX_PFC_OFF_PKT_PRI3s,  /* TX_PFC_OFF_PKT_PRI3 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts TX Pause transition from XON to XOFF state\n for CoS priority level 3.\n",
    },
    {
        .name  = TX_PFC_OFF_PKT_PRI4s,  /* TX_PFC_OFF_PKT_PRI4 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts TX Pause transition from XON to XOFF state\n for CoS priority level 4.\n",
    },
    {
        .name  = TX_PFC_OFF_PKT_PRI5s,  /* TX_PFC_OFF_PKT_PRI5 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts TX Pause transition from XON to XOFF state\n for CoS priority level 5.\n",
    },
    {
        .name  = TX_PFC_OFF_PKT_PRI6s,  /* TX_PFC_OFF_PKT_PRI6 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts TX Pause transition from XON to XOFF state\n for CoS priority level 6.\n",
    },
    {
        .name  = TX_PFC_OFF_PKT_PRI7s,  /* TX_PFC_OFF_PKT_PRI7 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts TX Pause transition from XON to XOFF state\n for CoS priority level 7.\n",
    },
    {
        .name  = RX_PFC_PKT_PRI0s,  /* RX_PFC_PKT_PRI0 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Rx PFC enable vector for CoS priority level 0.",
    },
    {
        .name  = TX_PFC_PKT_PRI0s,  /* TX_PFC_PKT_PRI0 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Tx PFC enable vector for CoS priority level 0.",
    },
    {
        .name  = RX_PFC_PKT_PRI1s,  /* RX_PFC_PKT_PRI1 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Rx PFC enable vector for CoS priority level 1.",
    },
    {
        .name  = TX_PFC_PKT_PRI1s,  /* TX_PFC_PKT_PRI1 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Tx PFC enable vector for CoS priority level 1.",
    },
    {
        .name  = RX_PFC_PKT_PRI2s,  /* RX_PFC_PKT_PRI2 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Rx PFC enable vector for CoS priority level 2.",
    },
    {
        .name  = TX_PFC_PKT_PRI2s,  /* TX_PFC_PKT_PRI2 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Tx PFC enable vector for CoS priority level 2.",
    },
    {
        .name  = RX_PFC_PKT_PRI3s,  /* RX_PFC_PKT_PRI3 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Rx PFC enable vector for CoS priority level 3.",
    },
    {
        .name  = TX_PFC_PKT_PRI3s,  /* TX_PFC_PKT_PRI3 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Tx PFC enable vector for CoS priority level 3.",
    },
    {
        .name  = RX_PFC_PKT_PRI4s,  /* RX_PFC_PKT_PRI4 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Rx PFC enable vector for CoS priority level 4.",
    },
    {
        .name  = TX_PFC_PKT_PRI4s,  /* TX_PFC_PKT_PRI4 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Tx PFC enable vector for CoS priority level 4.",
    },
    {
        .name  = RX_PFC_PKT_PRI5s,  /* RX_PFC_PKT_PRI5 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Rx PFC enable vector for CoS priority level 5",
    },
    {
        .name  = TX_PFC_PKT_PRI5s,  /* TX_PFC_PKT_PRI5 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Tx PFC enable vector for CoS priority level 5.",
    },
    {
        .name  = RX_PFC_PKT_PRI6s,  /* RX_PFC_PKT_PRI6 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Rx PFC enable vector for CoS priority level 6.",
    },
    {
        .name  = TX_PFC_PKT_PRI6s,  /* TX_PFC_PKT_PRI6 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Tx PFC enable vector for CoS priority level 6.",
    },
    {
        .name  = RX_PFC_PKT_PRI7s,  /* RX_PFC_PKT_PRI7 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Rx PFC enable vector for CoS priority level 7.",
    },
    {
        .name  = TX_PFC_PKT_PRI7s,  /* TX_PFC_PKT_PRI7 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Tx PFC enable vector for CoS priority level 7.",
    },
    {
        .name  = RX_FRAGMENT_PKTs,  /* RX_FRAGMENT_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Fragment Rx Packets.",
    },
    {
        .name  = TX_FRAGMENT_PKTs,  /* TX_FRAGMENT_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Fragment Tx Packets.",
    },
    {
        .name  = RX_LO_PWR_IDLE_EVENTs,  /* RX_LO_PWR_IDLE_EVENT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts each time MAC RX enters\n Low power IDLE state.\n",
    },
    {
        .name  = TX_LO_PWR_IDLE_EVENTs,  /* TX_LO_PWR_IDLE_EVENT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts each time MAC TX enters\n Low power IDLE state.\n",
    },
    {
        .name  = RX_LO_PWR_IDLE_DURATIONs,  /* RX_LO_PWR_IDLE_DURATION */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts duration of Rx Low Power idle state\n in 10us increments.\n",
    },
    {
        .name  = TX_LO_PWR_IDLE_DURATIONs,  /* TX_LO_PWR_IDLE_DURATION */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts duration of Tx Low Power idle state\n in 10us increments.\n",
    },
    {
        .name  = RX_LLFC_PHYSICAL_MSGs,  /* RX_LLFC_PHYSICAL_MSG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts every Physical type LLFC message received.",
    },
    {
        .name  = TX_LLFC_PHYSICAL_MSGs,  /* TX_LLFC_PHYSICAL_MSG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts every Physical type LLFC message transmitted.",
    },
    {
        .name  = RX_LLFC_LOGICAL_MSGs,  /* RX_LLFC_LOGICAL_MSG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts every logical type LLFC message received.",
    },
    {
        .name  = TX_LLFC_LOGICAL_MSGs,  /* TX_LLFC_LOGICAL_MSG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts every logical type LLFC message transmitted.",
    },
    {
        .name  = RX_HCFC_MSGs,  /* RX_HCFC_MSG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Count every HCFC message received.",
    },
    {
        .name  = TX_HCFC_MSGs,  /* TX_HCFC_MSG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Count every HCFC message transmitted.",
    },
    {
        .name  = RX_BYTESs,  /* RX_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts byte count of packets received.",
    },
    {
        .name  = TX_BYTESs,  /* TX_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts byte count of packets transmitted.",
    },
    {
        .name  = RX_RUNT_PKT_BYTESs,  /* RX_RUNT_PKT_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts number of bytes received for runt packets.",
    },
    {
        .name  = RX_RUNT_PKTs,  /* RX_RUNT_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts number of runt packets received.",
    },
    {
        .name  = TX_RUNT_PKTs,  /* TX_RUNT_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts number of runt packets transmitted.",
    },
    {
        .name  = TX_SINGLE_DEFERED_PKTs,  /* TX_SINGLE_DEFERED_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts each packet, which was deferred\n on its first transmission attempt and did not\n experience any subsequent collisions, during transmission.\n",
    },
    {
        .name  = TX_MULTI_DEFERED_PKTs,  /* TX_MULTI_DEFERED_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts packets aborted which were deferred for\n an excessive period of time and whose transmission\n was delayed due to busy medium.\n",
    },
    {
        .name  = TX_SINGLE_COLLISION_PKTs,  /* TX_SINGLE_COLLISION_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts packets transmitted which experienced\n exactly one collision during transmission.\n",
    },
    {
        .name  = TX_MULTI_COLLISION_PKTs,  /* TX_MULTI_COLLISION_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts packets transmitted which experienced\n multiple(2-15) collisions (including any late collisions)\n during transmission.\n",
    },
    {
        .name  = TX_LATE_COLLISION_PKTs,  /* TX_LATE_COLLISION_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts packets transmitted which experienced a late collision.",
    },
    {
        .name  = TX_EXCESS_COLLISION_PKTs,  /* TX_EXCESS_COLLISION_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts packets experienced 16 collisions during\n transmission and was aborted.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_mac_t = {
    .name = CTR_MACs, /* CTR_MAC */
    .flags = 0,
    .fields = 100,
    .field = bcmltd_ctr_mac_t_fields,
    .desc = "Logical Table for MAC based counters (IP/EP).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_MAC_ERR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_mac_err_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port Number",
    },
    {
        .name  = RX_FCS_ERR_PKTs,  /* RX_FCS_ERR_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Rx Packets with FCS error.",
    },
    {
        .name  = TX_FCS_ERR_PKTs,  /* TX_FCS_ERR_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tx Packets with FCS error.",
    },
    {
        .name  = RX_PFC_UNSUPPORTED_OPCODE_PKTs,  /* RX_PFC_UNSUPPORTED_OPCODE_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Rx Packets with unsupported OPCODE.\n opcode != 0x0000, 0x0001, PFC OpCode\n",
    },
    {
        .name  = RX_PFC_UNSUPPORTED_DA_PKTs,  /* RX_PFC_UNSUPPORTED_DA_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Pause Flow Control packets with Unsupported DA.",
    },
    {
        .name  = RX_MC_SA_PKTs,  /* RX_MC_SA_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "SA is unicast but if detected as multicast.",
    },
    {
        .name  = RX_ALIGN_ERR_PKTs,  /* RX_ALIGN_ERR_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Alignment Error in packet",
    },
    {
        .name  = RX_LEN_OUT_OF_RANGE_PKTs,  /* RX_LEN_OUT_OF_RANGE_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Length Out of Range.\n 802.3 length field did not match the number\n of data bytes received.\n",
    },
    {
        .name  = RX_CODE_ERR_PKTs,  /* RX_CODE_ERR_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Received Packet with error termination.",
    },
    {
        .name  = RX_FALSE_CARRIER_PKTs,  /* RX_FALSE_CARRIER_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "False Carrier is detected.",
    },
    {
        .name  = RX_OVER_SIZE_PKTs,  /* RX_OVER_SIZE_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Rx Packet which exceeds max Size.",
    },
    {
        .name  = TX_OVER_SIZE_PKTs,  /* TX_OVER_SIZE_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tx Packet which exceeds max Size.",
    },
    {
        .name  = RX_JABBER_PKTs,  /* RX_JABBER_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Rx Packet with following Error.\n a) size> MaxSize bytes\n b) Contain an invalid FCS\n",
    },
    {
        .name  = TX_JABBER_PKTs,  /* TX_JABBER_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tx Packet with following Error.\n a) size> MaxSize bytes\n b) Contain an invalid FCS\n",
    },
    {
        .name  = RX_MTU_CHECK_ERR_PKTs,  /* RX_MTU_CHECK_ERR_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "MTU Check Error, packet\n Exceeds Max frame length\n Valid or invalid FCS.\n",
    },
    {
        .name  = RX_PROMISCUOUS_PKTs,  /* RX_PROMISCUOUS_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Incoming packet other than control packets\n e.g. (pause/PFC packets) and multicast/unicast.\n Packets have DA that is not matching with the RX SA.\n Used in network security.\n",
    },
    {
        .name  = RX_TRUNCATED_PKTs,  /* RX_TRUNCATED_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Truncated packet due to RX FIFO full.",
    },
    {
        .name  = RX_SCH_HDR_CRC_ERRs,  /* RX_SCH_HDR_CRC_ERR */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "SCH CRC error is detected.\n",
    },
    {
        .name  = RX_UNDER_SIZE_PKTs,  /* RX_UNDER_SIZE_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Undersize pkt Received.\n a) size (9 <= size <= 63 IEEE mode)\n b) (17 <= size <= 71 Higig)\n c) (17 <= size <= 75 Higig2)\n d) contains a valid FCS\n",
    },
    {
        .name  = RX_LLFC_CRC_ERRs,  /* RX_LLFC_CRC_ERR */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts every logical LLFC message with CRC Error.",
    },
    {
        .name  = TX_ERR_PKTs,  /* TX_ERR_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts packets transmitted with error set by system.\n Based on TX_ERR signal from Port to MAC.\n",
    },
    {
        .name  = TX_FIFO_UNDER_RUN_PKTs,  /* TX_FIFO_UNDER_RUN_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts packets transmitted which encountered a MAC underrun.\n (Tx Sync FIFO runs out of data before the end of packet).\n",
    },
    {
        .name  = TX_TOTAL_COLLISIONs,  /* TX_TOTAL_COLLISION */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts number of collisions experienced during the\n transmit and receive at the same time.\n",
    },
    {
        .name  = TX_HOL_BLOCK_PKTs,  /* TX_HOL_BLOCK_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counts Transmit End-to-End HOL blocking packets.",
    },
    {
        .name  = EGR_PURGE_CELL_ERR_DROPs,  /* EGR_PURGE_CELL_ERR_DROP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress Purge and Cell Error Drop Counter.\n Set to 64 bits to be consistent with other counters.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_mac_err_t = {
    .name = CTR_MAC_ERRs, /* CTR_MAC_ERR */
    .flags = 0,
    .fields = 26,
    .field = bcmltd_ctr_mac_err_t_fields,
    .desc = "Logical Table for MAC based Error Counters (IP/EP).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_MIRROR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_mirror_t_fields[] = {
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Mirror instance ID.",
    },
    {
        .name  = MIRROR_SESSION_IDs,  /* MIRROR_SESSION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Mirror session ID.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = MIRROR_PKTs,  /* MIRROR_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of mirror copies generated.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_mirror_t = {
    .name = CTR_MIRRORs, /* CTR_MIRROR */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_mirror_t_fields,
    .desc = "Logical Table for Mirroring based counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_MIRROR_ING_FLEX_SFLOW.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_mirror_ing_flex_sflow_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = CTR_MIRROR_ING_FLEX_SFLOW_IDs,  /* CTR_MIRROR_ING_FLEX_SFLOW_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index to the CTR_MIRROR_ING_FLEX_SFLOW table.",
    },
    {
        .name  = SAMPLE_POOL_PKTs,  /* SAMPLE_POOL_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = SAMPLE_PKTs,  /* SAMPLE_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = SAMPLE_POOL_PKT_SNAPSHOTs,  /* SAMPLE_POOL_PKT_SNAPSHOT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Snapshot of SAMPLE_POOL_PKT.\n Snapshot happens whenever a packet is sampled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_mirror_ing_flex_sflow_t = {
    .name = CTR_MIRROR_ING_FLEX_SFLOWs, /* CTR_MIRROR_ING_FLEX_SFLOW */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_mirror_ing_flex_sflow_t_fields,
    .desc = "The CTR_MIRROR_ING_FLEX_SFLOW logical table specifies the ingress flex\n sFlow statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_MIRROR_ING_PORT_SFLOW.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_mirror_ing_port_sflow_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = SAMPLE_POOL_PKTs,  /* SAMPLE_POOL_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = SAMPLE_PKTs,  /* SAMPLE_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = SAMPLE_POOL_PKT_SNAPSHOTs,  /* SAMPLE_POOL_PKT_SNAPSHOT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Snapshot of SAMPLE_POOL_PKT.\n Snapshot happens whenever a packet is sampled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_mirror_ing_port_sflow_t = {
    .name = CTR_MIRROR_ING_PORT_SFLOWs, /* CTR_MIRROR_ING_PORT_SFLOW */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_mirror_ing_port_sflow_t_fields,
    .desc = "The CTR_MIRROR_ING_PORT_SFLOW logical table specifies\n per-port sFlow statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_NIV.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_niv_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port Number",
    },
    {
        .name  = ING_NIV_RX_PKTS_ERROR_DROPs,  /* ING_NIV_RX_PKTS_ERROR_DROP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets dropped due to VNTAG/ETAG\n format errors.\n",
    },
    {
        .name  = ING_NIV_RX_PKTS_FORWARDING_DROPs,  /* ING_NIV_RX_PKTS_FORWARDING_DROP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets dropped due to an NIV/PE\n forwarding errors.\n",
    },
    {
        .name  = ING_NIV_RX_PKTS_VLAN_TAGGEDs,  /* ING_NIV_RX_PKTS_VLAN_TAGGED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of VLAN tagged packets received from this port.\n This is added to make sure VNTAG/ETAG related MAC\n Changes can be avoided if necessary.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_niv_t = {
    .name = CTR_NIVs, /* CTR_NIV */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_niv_t_fields,
    .desc = "Logical Table for NIV Counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_SEC_DECRYPT_IPSEC_SA_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_sec_decrypt_ipsec_sa_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_DECRYPT_IPSEC_SA_POLICY_IDs,  /* SEC_DECRYPT_IPSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_IPSEC_SA_POLICY table index.",
    },
    {
        .name  = INVALID_SA_PKTSs,  /* INVALID_SA_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets matched with invalid SA.\n Set when the relevant IPsec SA matched is invalid.\n",
    },
    {
        .name  = STRICT_INVALID_PKTSs,  /* STRICT_INVALID_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of invalid discarded packets.\n Applicable only for encrypted packets or when\n SEC_DECRYPT_SUBPORT_POLICY.TAG_VALIDATE == STRICT.\n",
    },
    {
        .name  = DUMMY_PKTSs,  /* DUMMY_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of dummy IPsec packets.",
    },
    {
        .name  = PAD_LENGTH_MISMATCH_PKTSs,  /* PAD_LENGTH_MISMATCH_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets which are not a multiple of the cipher suite\n (excess padding done at receive for the C text) or\n ESP trailer pad length value is > 15.\n",
    },
    {
        .name  = OK_PKTSs,  /* OK_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_sec_decrypt_ipsec_sa_policy_t = {
    .name = CTR_SEC_DECRYPT_IPSEC_SA_POLICYs, /* CTR_SEC_DECRYPT_IPSEC_SA_POLICY */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_sec_decrypt_ipsec_sa_policy_t_fields,
    .desc = "The CTR_SEC_DECRYPT_IPSEC_SA_POLICY table specifies the various\n IPsec secure association (SA) counters in the decrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_SEC_DECRYPT_IPSEC_SC_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_sec_decrypt_ipsec_sc_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_DECRYPT_IPSEC_SC_POLICY_IDs,  /* SEC_DECRYPT_IPSEC_SC_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the decrypt secure channel.",
    },
    {
        .name  = VALIDATED_BYTESs,  /* VALIDATED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of octets of plaintext recovered from received\n packets that were integrity protected but not encrypted.\n",
    },
    {
        .name  = DECRYPTED_BYTESs,  /* DECRYPTED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of octets of plaintext recovered from received\n packets that were integrity protected and encrypted.\n",
    },
    {
        .name  = DELAYED_DISCARDED_PKTSs,  /* DELAYED_DISCARDED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "For this SC, the number of received packets that have\n been discarded. Applicable when replay protection is enabled\n and packet number of the packet is lower than the lower\n bound of replay check.\n",
    },
    {
        .name  = DELAYED_PKTSs,  /* DELAYED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets with the condition that the PN of the\n packet is lower than the lower bound of replay check.\n",
    },
    {
        .name  = UNCHECKED_PKTSs,  /* UNCHECKED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of unverified packets fulfilling one of the following\n conditions.\n 1. Frame validation is disabled.\n 2. Frame validation is enabled, the packet is not encrypted\n    and the integrity check has failed.\n 3. Frame validation is enabled, the packet is encrypted and\n    integrity check has failed.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_sec_decrypt_ipsec_sc_policy_t = {
    .name = CTR_SEC_DECRYPT_IPSEC_SC_POLICYs, /* CTR_SEC_DECRYPT_IPSEC_SC_POLICY */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_sec_decrypt_ipsec_sc_policy_t_fields,
    .desc = "The CTR_SEC_DECRYPT_IPSEC_SC_POLICY table specifies the various\n IPsec secure channel (SC) counters in the decrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_SEC_DECRYPT_MACSEC_SA_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_sec_decrypt_macsec_sa_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_DECRYPT_MACSEC_SA_POLICY_IDs,  /* SEC_DECRYPT_MACSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_MACSEC_SA_POLICY table index.",
    },
    {
        .name  = STRICT_UNUSED_SA_PKTSs,  /* STRICT_UNUSED_SA_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of discarded packets received when the SA\n is not in use. Applicable only for encrypted packets\n or when SEC_DECRYPT_SUBPORT_POLICY.TAG_VALIDATE == STRICT.\n",
    },
    {
        .name  = STRICT_INVALID_PKTSs,  /* STRICT_INVALID_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of invalid discarded packets.\n Applicable only for encrypted packets or when\n SEC_DECRYPT_SUBPORT_POLICY.TAG_VALIDATE == STRICT.\n",
    },
    {
        .name  = UNUSED_SA_PKTSs,  /* UNUSED_SA_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of unencrypted packets received when the SA is\n not in use. Applicable only when\n SEC_DECRYPT_SUBPORT_POLICY.TAG_VALIDATE != STRICT.\n",
    },
    {
        .name  = INVALID_PKTSs,  /* INVALID_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of invalid packets received when\n SEC_DECRYPT_SUBPORT_POLICY.TAG_VALIDATE == CHECK_ICV.\n",
    },
    {
        .name  = OK_PKTSs,  /* OK_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_sec_decrypt_macsec_sa_policy_t = {
    .name = CTR_SEC_DECRYPT_MACSEC_SA_POLICYs, /* CTR_SEC_DECRYPT_MACSEC_SA_POLICY */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_sec_decrypt_macsec_sa_policy_t_fields,
    .desc = "The CTR_SEC_DECRYPT_MACSEC_SA_POLICY table specifies the various\n MACsec secure association (SA) counters in the decrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_SEC_DECRYPT_MACSEC_SC_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_sec_decrypt_macsec_sc_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_DECRYPT_MACSEC_SC_POLICY_IDs,  /* SEC_DECRYPT_MACSEC_SC_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the decrypt secure channel.",
    },
    {
        .name  = VALIDATED_BYTESs,  /* VALIDATED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of octets of plaintext recovered from received\n packets that were integrity protected but not encrypted.\n",
    },
    {
        .name  = DECRYPTED_BYTESs,  /* DECRYPTED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of octets of plaintext recovered from received\n packets that were integrity protected and encrypted.\n",
    },
    {
        .name  = DELAYED_DISCARDED_PKTSs,  /* DELAYED_DISCARDED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "For this SC, the number of received packets that have\n been discarded. Applicable when replay protection is enabled\n and packet number of the packet is lower than the lower\n bound of replay check.\n",
    },
    {
        .name  = DELAYED_PKTSs,  /* DELAYED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets with the condition that the PN of the\n packet is lower than the lower bound of replay check.\n",
    },
    {
        .name  = UNCHECKED_PKTSs,  /* UNCHECKED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of unverified packets fulfilling one of the following\n conditions.\n 1. Frame validation is disabled.\n 2. Frame validation is enabled, the packet is not encrypted\n    and the integrity check has failed.\n 3. Frame validation is enabled, the packet is encrypted and\n    integrity check has failed.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_sec_decrypt_macsec_sc_policy_t = {
    .name = CTR_SEC_DECRYPT_MACSEC_SC_POLICYs, /* CTR_SEC_DECRYPT_MACSEC_SC_POLICY */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_sec_decrypt_macsec_sc_policy_t_fields,
    .desc = "The CTR_SEC_DECRYPT_MACSEC_SC_POLICY table specifies the various\n MACsec secure channel (SC) counters in the decrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_SEC_DECRYPT_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_sec_decrypt_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_FLOW_MISSs,  /* SEC_DECRYPT_SUBPORT_FLOW_MISS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress subport flow match miss counter.",
    },
    {
        .name  = SEC_SC_DECRYPT_MISSs,  /* SEC_SC_DECRYPT_MISS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Ingress secure channel match miss counter.\n Gives the aggregate counter for both MACsec and IPsec.\n",
    },
    {
        .name  = DROP_PKTs,  /* DROP_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Packet drop counter.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SEC_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_sec_decrypt_port_t = {
    .name = CTR_SEC_DECRYPT_PORTs, /* CTR_SEC_DECRYPT_PORT */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_sec_decrypt_port_t_fields,
    .desc = "The CTR_SEC_DECRYPT_PORT table specifies the various port level\n MACsec and IPsec counters in the decrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_SEC_DECRYPT_SUBPORT_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_sec_decrypt_subport_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the subport policy counter table.",
    },
    {
        .name  = UNCONTROLLED_BYTESs,  /* UNCONTROLLED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of bytes received.",
    },
    {
        .name  = UNCONTROLLED_MGMT_PKTSs,  /* UNCONTROLLED_MGMT_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of management packets received.",
    },
    {
        .name  = UNCONTROLLED_UNICAST_PKTSs,  /* UNCONTROLLED_UNICAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of unicast packets received.",
    },
    {
        .name  = UNCONTROLLED_MULTICAST_PKTSs,  /* UNCONTROLLED_MULTICAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of multicast packets received.",
    },
    {
        .name  = UNCONTROLLED_BROADCAST_PKTSs,  /* UNCONTROLLED_BROADCAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of broadcast packets received.",
    },
    {
        .name  = UNCONTROLLED_KAY_IKE_PKTSs,  /* UNCONTROLLED_KAY_IKE_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of KaY or IKE packets received.",
    },
    {
        .name  = CONTROLLED_NO_TAGs,  /* CONTROLLED_NO_TAG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received without SecTAG that are\n discarded.\n Applicable when SEC_DECRYPT_SUBPORT_POLICY.UNSECURED_DATA_MODE\n is DROP.\n",
    },
    {
        .name  = CONTROLLED_NO_SCI_SPI_PKTSs,  /* CONTROLLED_NO_SCI_SPI_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received discarded due to unknown\n SCI or SPI information.\n Applicable for MACSec when in strict mode or\n when C bit in SecTAG is set.\n",
    },
    {
        .name  = CONTROLLED_BAD_TAGs,  /* CONTROLLED_BAD_TAG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received discarded due to an invalid\n SecTAG or a zero value PN or an invalid ICV.\n",
    },
    {
        .name  = CONTROLLED_IP_FRAGMENTS_PKTSs,  /* CONTROLLED_IP_FRAGMENTS_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of locally terminated IPsec ESP packets\n that are IP fragments.\n",
    },
    {
        .name  = CONTROLLED_UNTAGGED_OR_FRAGMENTED_PKTSs,  /* CONTROLLED_UNTAGGED_OR_FRAGMENTED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "For IPSec packets - Number of locally terminated ESP packets\n that are IP fragments.\n For MACSec subports - Number of packets received without SecTAG\n that are discarded.\n Applicable when SEC_DECRYPT_SUBPORT_POLICY.UNSECURED_DATA_MODE\n is ALLOW.\n",
    },
    {
        .name  = CONTROLLED_UNKNOWN_SCI_HDR_PKTSs,  /* CONTROLLED_UNKNOWN_SCI_HDR_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets discarded due to unknown SCI\n information. Applicable for MACsec packets when\n not in strict mode and when C bit in SecTAG is not set.\n For IPsec packets, it denotes the number of illegal next\n head frames received.\n",
    },
    {
        .name  = CONTROLLED_BYTESs,  /* CONTROLLED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "The sum of all bytes of the MSDUs received by the user\n of the controlled port after the secure frame verification,\n plus the octets of the destination and source MAC addresses.\n",
    },
    {
        .name  = CONTROLLED_UNICAST_PKTSs,  /* CONTROLLED_UNICAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of unicast packets delivered to the controlled port.",
    },
    {
        .name  = CONTROLLED_MULTICAST_PKTSs,  /* CONTROLLED_MULTICAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of multicast packets delivered to the controlled port.",
    },
    {
        .name  = CONTROLLED_BROADCAST_PKTSs,  /* CONTROLLED_BROADCAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of broadcast packets delivered to the controlled port.",
    },
    {
        .name  = CONTROLLED_DISCARD_PKTSs,  /* CONTROLLED_DISCARD_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Discarded packets. These are sum of CONTROLLED_NO_TAG\n and packets discarded due to replay protect failure.\n",
    },
    {
        .name  = CONTROLLED_ERROR_PKTSs,  /* CONTROLLED_ERROR_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Discarded packets. These are sum of CONTROLLED_BAD_TAG,\n CONTROLLED_NO_SCI_PKTS and packets discarded SA not in use.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_sec_decrypt_subport_policy_t = {
    .name = CTR_SEC_DECRYPT_SUBPORT_POLICYs, /* CTR_SEC_DECRYPT_SUBPORT_POLICY */
    .flags = 0,
    .fields = 20,
    .field = bcmltd_ctr_sec_decrypt_subport_policy_t_fields,
    .desc = "The CTR_SEC_DECRYPT_SUBPORT_POLICY table specifies the various\n MACsec and IPsec counters for a subport.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_SEC_ENCRYPT_IPSEC_SA_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_sec_encrypt_ipsec_sa_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_ENCRYPT_IPSEC_SA_POLICY_IDs,  /* SEC_ENCRYPT_IPSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "SEC_ENCRYPT_IPSEC_SA_POLICY table index.",
    },
    {
        .name  = PROTECTED_PKTSs,  /* PROTECTED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of integrity protected but not encrypted packets\n for this transmitting SA.\n",
    },
    {
        .name  = ENCRYPTED_PKTSs,  /* ENCRYPTED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of integrity protected and encrypted packets\n for this transmitting SA.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_sec_encrypt_ipsec_sa_policy_t = {
    .name = CTR_SEC_ENCRYPT_IPSEC_SA_POLICYs, /* CTR_SEC_ENCRYPT_IPSEC_SA_POLICY */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_sec_encrypt_ipsec_sa_policy_t_fields,
    .desc = "The CTR_SEC_ENCRYPT_IPSEC_SA_POLICY table specifies the various\n MACsec secure association (SA) counters in the encrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_SEC_ENCRYPT_IPSEC_SC_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_sec_encrypt_ipsec_sc_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_ENCRYPT_IPSEC_SC_POLICY_IDs,  /* SEC_ENCRYPT_IPSEC_SC_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the encrypt secure channel.",
    },
    {
        .name  = UNCONTROLLED_BYTESs,  /* UNCONTROLLED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all the octets of the frames transmitted by the\n uncontrolled port.\n",
    },
    {
        .name  = UNCONTROLLED_MGMT_PKTSs,  /* UNCONTROLLED_MGMT_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all the management and KaY frames transmitted by the\n uncontrolled port.\n",
    },
    {
        .name  = UNCONTROLLED_UNICAST_PKTSs,  /* UNCONTROLLED_UNICAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all unicast frames transmitted by the\n uncontrolled port.\n",
    },
    {
        .name  = UNCONTROLLED_MULTICAST_PKTSs,  /* UNCONTROLLED_MULTICAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all the multicast frames transmitted by the\n uncontrolled port.\n",
    },
    {
        .name  = UNCONTROLLED_BROADCAST_PKTSs,  /* UNCONTROLLED_BROADCAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all the broadcast frames transmitted by the\n uncontrolled port.\n",
    },
    {
        .name  = UNCONTROLLED_ERROR_PKTSs,  /* UNCONTROLLED_ERROR_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all frames transmitted by the uncontrolled port\n that exceeds SEC_ENCRYPT.MANAGEMENT_MTU.\n",
    },
    {
        .name  = CONTROLLED_BYTESs,  /* CONTROLLED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all bytes of the MSDU delivered by the user\n of the controlled port to the secure frame generation process,\n plus the octets of the destination and source MAC addresses.\n",
    },
    {
        .name  = CONTROLLED_UNICAST_PKTSs,  /* CONTROLLED_UNICAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all unicast frames transmitted by the\n controlled port.\n",
    },
    {
        .name  = CONTROLLED_DUMMY_PKTSs,  /* CONTROLLED_DUMMY_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all the secure IPSEC packets that have an ESP header\n and trailer inserted with a next header (NH) value of 59,\n transmitted by the controlled port.\n",
    },
    {
        .name  = CONTROLLED_SA_INVALID_PKTSs,  /* CONTROLLED_SA_INVALID_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all controlled port packets for whom the\n resultant SA is marked invalid.\n",
    },
    {
        .name  = PROTECTED_BYTESs,  /* PROTECTED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of plain text octets that are integrity protected\n but not encrypted on the transmitting SC.\n",
    },
    {
        .name  = ENCRYPTED_BYTESs,  /* ENCRYPTED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of plain text octets that are integrity protected\n and encrypted on the transmitting SC.\n",
    },
    {
        .name  = UNTAGGED_PKTSs,  /* UNTAGGED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of transmitted packets without the MAC security tag\n (SecTAG).\n",
    },
    {
        .name  = IP_LENGTH_MISMATCHs,  /* IP_LENGTH_MISMATCH */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of transmitted packets discarded because of mismatch\n between the packet length and the length indicated by the IP\n header, or UDP length and IP length fields.\n",
    },
    {
        .name  = ERROR_PKTSs,  /* ERROR_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of transmitted packets discarded because the\n packet length is greater than the interface MTU.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_sec_encrypt_ipsec_sc_policy_t = {
    .name = CTR_SEC_ENCRYPT_IPSEC_SC_POLICYs, /* CTR_SEC_ENCRYPT_IPSEC_SC_POLICY */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_ctr_sec_encrypt_ipsec_sc_policy_t_fields,
    .desc = "The CTR_SEC_ENCRYPT_IPSEC_SC_POLICY table specifies the various\n MACsec secure channel (SC) counters in the encrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_SEC_ENCRYPT_MACSEC_SA_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_sec_encrypt_macsec_sa_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_ENCRYPT_MACSEC_SA_POLICY_IDs,  /* SEC_ENCRYPT_MACSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "SEC_ENCRYPT_MACSEC_SA_POLICY table index.",
    },
    {
        .name  = PROTECTED_PKTSs,  /* PROTECTED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of integrity protected but not encrypted packets\n for this transmitting SA.\n",
    },
    {
        .name  = ENCRYPTED_PKTSs,  /* ENCRYPTED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of integrity protected and encrypted packets\n for this transmitting SA.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_sec_encrypt_macsec_sa_policy_t = {
    .name = CTR_SEC_ENCRYPT_MACSEC_SA_POLICYs, /* CTR_SEC_ENCRYPT_MACSEC_SA_POLICY */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_sec_encrypt_macsec_sa_policy_t_fields,
    .desc = "The CTR_SEC_ENCRYPT_MACSEC_SA_POLICY table specifies the various\n MACsec secure association (SA) counters in the encrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_SEC_ENCRYPT_MACSEC_SC_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_sec_encrypt_macsec_sc_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_ENCRYPT_MACSEC_SC_POLICY_IDs,  /* SEC_ENCRYPT_MACSEC_SC_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the encrypt secure channel.",
    },
    {
        .name  = UNCONTROLLED_BYTESs,  /* UNCONTROLLED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all the octets of the frames transmitted by the\n uncontrolled port.\n",
    },
    {
        .name  = UNCONTROLLED_MGMT_PKTSs,  /* UNCONTROLLED_MGMT_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all the management and KaY frames transmitted by the\n uncontrolled port.\n",
    },
    {
        .name  = UNCONTROLLED_UNICAST_PKTSs,  /* UNCONTROLLED_UNICAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all unicast frames transmitted by the\n uncontrolled port.\n",
    },
    {
        .name  = UNCONTROLLED_MULTICAST_PKTSs,  /* UNCONTROLLED_MULTICAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all the multicast frames transmitted by the\n uncontrolled port.\n",
    },
    {
        .name  = UNCONTROLLED_BROADCAST_PKTSs,  /* UNCONTROLLED_BROADCAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all the broadcast frames transmitted by the\n uncontrolled port.\n",
    },
    {
        .name  = UNCONTROLLED_ERROR_PKTSs,  /* UNCONTROLLED_ERROR_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all frames transmitted by the uncontrolled port\n that exceeds SEC_ENCRYPT.MANAGEMENT_MTU.\n",
    },
    {
        .name  = CONTROLLED_BYTESs,  /* CONTROLLED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all bytes of the MSDU delivered by the user\n of the controlled port to the secure frame generation process,\n plus the octets of the destination and source MAC addresses.\n",
    },
    {
        .name  = CONTROLLED_UNICAST_PKTSs,  /* CONTROLLED_UNICAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all unicast frames transmitted by the\n controlled port.\n",
    },
    {
        .name  = CONTROLLED_MULTICAST_PKTSs,  /* CONTROLLED_MULTICAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all unicast frames transmitted by the\n controlled port.\n",
    },
    {
        .name  = CONTROLLED_BROADCAST_PKTSs,  /* CONTROLLED_BROADCAST_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all the broadcast frames transmitted by the\n controlled port.\n",
    },
    {
        .name  = CONTROLLED_SA_INVALID_PKTSs,  /* CONTROLLED_SA_INVALID_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sum of all controlled port packets for whom the\n resultant SA is marked invalid.\n",
    },
    {
        .name  = PROTECTED_BYTESs,  /* PROTECTED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of plain text octets that are integrity protected\n but not encrypted on the transmitting SC.\n",
    },
    {
        .name  = ENCRYPTED_BYTESs,  /* ENCRYPTED_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of plain text octets that are integrity protected\n and encrypted on the transmitting SC.\n",
    },
    {
        .name  = UNTAGGED_PKTSs,  /* UNTAGGED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of transmitted packets without the MAC security tag\n (SecTAG).\n",
    },
    {
        .name  = OUTSIZED_PKTSs,  /* OUTSIZED_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of transmitted packets discarded because the\n packet length is greater than the interface MTU.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_sec_encrypt_macsec_sc_policy_t = {
    .name = CTR_SEC_ENCRYPT_MACSEC_SC_POLICYs, /* CTR_SEC_ENCRYPT_MACSEC_SC_POLICY */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_ctr_sec_encrypt_macsec_sc_policy_t_fields,
    .desc = "The CTR_SEC_ENCRYPT_MACSEC_SC_POLICY table specifies the various\n MACsec secure channel (SC) counters in the encrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_SEC_ENCRYPT_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_sec_encrypt_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID",
    },
    {
        .name  = INVALID_SVTAGs,  /* INVALID_SVTAG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Bad custom header count.",
    },
    {
        .name  = DROP_PKTs,  /* DROP_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Packet drop counter.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SEC_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_sec_encrypt_port_t = {
    .name = CTR_SEC_ENCRYPT_PORTs, /* CTR_SEC_ENCRYPT_PORT */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ctr_sec_encrypt_port_t_fields,
    .desc = "The CTR_SEC_ENCRYPT_PORT table specifies the various port level\n MACsec and IPsec counters in the encrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_BST_DEVICE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_bst_device_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tracking counter in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_bst_device_t = {
    .name = CTR_TM_BST_DEVICEs, /* CTR_TM_BST_DEVICE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_tm_bst_device_t_fields,
    .desc = "The CTR_TM_BST_DEVICE table is used to retrieve the\n BST tracking counter at the device level.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_BST_REPL_Q_GLOBAL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_bst_repl_q_global_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tracking counter in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_bst_repl_q_global_t = {
    .name = CTR_TM_BST_REPL_Q_GLOBALs, /* CTR_TM_BST_REPL_Q_GLOBAL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_tm_bst_repl_q_global_t_fields,
    .desc = "The CTR_TM_BST_REPL_Q_GLOBAL table is used to retrieve the\n BST tracking counter for replication engine per\n service pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_BST_REPL_Q_PRI_QUEUE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_bst_repl_q_pri_queue_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = REPL_Q_NUMs,  /* REPL_Q_NUM */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Replication queue number",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Tracking counter in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_bst_repl_q_pri_queue_t = {
    .name = CTR_TM_BST_REPL_Q_PRI_QUEUEs, /* CTR_TM_BST_REPL_Q_PRI_QUEUE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_tm_bst_repl_q_pri_queue_t_fields,
    .desc = "The CTR_TM_BST_REPL_Q_PRI_QUEUE table is used to retrieve the\n BST tracking counter per replication queue.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_BUFFER_POOL_DROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_buffer_pool_drop_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = INVALID_DEST_PORT_PKTs,  /* INVALID_DEST_PORT_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of packets with invalid destination ports.",
    },
    {
        .name  = ERR_PKTs,  /* ERR_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of error packets detected due to framing error,\n invalid source port error, packet type error and mtu violation\n error. This error count excludes packet error due to minimum\n spacing violations.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_buffer_pool_drop_t = {
    .name = CTR_TM_BUFFER_POOL_DROPs, /* CTR_TM_BUFFER_POOL_DROP */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_tm_buffer_pool_drop_t_fields,
    .desc = "The CTR_TM_BUFFER_POOL_DROP table specifies the packet drop\n count for cell resource block allocation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_CUT_THROUGH.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_cut_through_t_fields[] = {
    {
        .name  = CTR_TM_CUT_THROUGH_IDs,  /* CTR_TM_CUT_THROUGH_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Cut through counter ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = PKTs,  /* PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of cut through packets forwarded.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_cut_through_t = {
    .name = CTR_TM_CUT_THROUGHs, /* CTR_TM_CUT_THROUGH */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_tm_cut_through_t_fields,
    .desc = "The CTR_TM_CUT_THROUGH table is used to count the cut through\n packets of a traffic flow that are successfully forwarded from a buffer pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_CUT_THROUGH_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_cut_through_control_t_fields[] = {
    {
        .name  = CTR_TM_CUT_THROUGH_IDs,  /* CTR_TM_CUT_THROUGH_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Cut through counter ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = ING_PORT_ID_MATCHs,  /* ING_PORT_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ingress port match.",
    },
    {
        .name  = ING_TM_PIPE_ID_MATCHs,  /* ING_TM_PIPE_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ingress TM pipe match. TM_PIPE_ID will be derived\n from ING_PORT_ID.\n",
    },
    {
        .name  = ING_PORT_IDs,  /* ING_PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress port ID. Applicable if ING_PORT_ID_MATCH or\n ING_TM_PIPE_ID_MATCH is enabled.\n",
    },
    {
        .name  = EGR_PORT_ID_MATCHs,  /* EGR_PORT_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable egress port match.",
    },
    {
        .name  = EGR_TM_PIPE_ID_MATCHs,  /* EGR_TM_PIPE_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable egress TM pipe match. TM_PIPE_ID will be derived\n from EGR_PORT_ID.\n",
    },
    {
        .name  = EGR_PORT_IDs,  /* EGR_PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress port ID. Applicable if EGR_PORT_ID_MATCH or\n EGR_TM_PIPE_ID_MATCH is enabled.\n",
    },
    {
        .name  = TM_Q_ID_MATCHs,  /* TM_Q_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable queue ID match.",
    },
    {
        .name  = Q_TYPEs,  /* Q_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_TM_QUEUE_TYPE_T_DATA,
        .desc = "Queue type.",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID. Applicable if TM_Q_ID_MATCH is enabled and\n Q_TYPE is UC_Q.\n",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue ID. Applicable if TM_Q_ID_MATCH is enabled and\n Q_TYPE is MC_Q.\n",
    },
    {
        .name  = PRI_GRP_ID_MATCHs,  /* PRI_GRP_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable priority group match.",
    },
    {
        .name  = TM_PRI_GRP_IDs,  /* TM_PRI_GRP_ID */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Priority group. Applicable if PRI_GRP_ID_MATCH is enabled.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_cut_through_control_t = {
    .name = CTR_TM_CUT_THROUGH_CONTROLs, /* CTR_TM_CUT_THROUGH_CONTROL */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_ctr_tm_cut_through_control_t_fields,
    .desc = "The CTR_TM_CUT_THROUGH_CONTROL table is used to specify the\n attributes of the cut through traffic flow tracked by the\n CTR_TM_CUT_THROUGH counter.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_MC_Q_DROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_mc_q_drop_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue ID.",
    },
    {
        .name  = PKTs,  /* PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress admission drop packet count.",
    },
    {
        .name  = BYTEs,  /* BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress admission drop byte count.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_MC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_mc_q_drop_t = {
    .name = CTR_TM_MC_Q_DROPs, /* CTR_TM_MC_Q_DROP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ctr_tm_mc_q_drop_t_fields,
    .desc = "The CTR_TM_MC_Q_DROP table specifies per egress port total drop\n counters for multicast queues.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_MIRROR_ON_DROP_BUFFER_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_mirror_on_drop_buffer_pool_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = CELL_USAGEs,  /* CELL_USAGE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Current cell usage of mirror on drop pool.",
    },
    {
        .name  = HIGH_WATERMARK_CELL_USAGEs,  /* HIGH_WATERMARK_CELL_USAGE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "High watermark of cell usage of mirror on drop pool.",
    },
    {
        .name  = DROP_PKTs,  /* DROP_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of dropped packets that are sampled but failed to be\n mirrored since mirror on drop pool was full.\n",
    },
    {
        .name  = QUEUE_PKTs,  /* QUEUE_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of dropped packets that are sampled and enqueued to\n mirror on drop queue.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_mirror_on_drop_buffer_pool_t = {
    .name = CTR_TM_MIRROR_ON_DROP_BUFFER_POOLs, /* CTR_TM_MIRROR_ON_DROP_BUFFER_POOL */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_tm_mirror_on_drop_buffer_pool_t_fields,
    .desc = "The CTR_TM_MIRROR_ON_DROP_BUFFER_POOL table specifies per-buffer pool\n statistic and cell usage.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_MIRROR_ON_DROP_DESTINATION_USAGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_mirror_on_drop_destination_usage_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_MIRROR_ON_DROP_DESTINATION_IDs,  /* TM_MIRROR_ON_DROP_DESTINATION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Mirror on drop destination identifier.",
    },
    {
        .name  = CELL_USAGEs,  /* CELL_USAGE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Current cell usage of the mirror on drop queue.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_mirror_on_drop_destination_usage_t = {
    .name = CTR_TM_MIRROR_ON_DROP_DESTINATION_USAGEs, /* CTR_TM_MIRROR_ON_DROP_DESTINATION_USAGE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_tm_mirror_on_drop_destination_usage_t_fields,
    .desc = "The CTR_TM_MIRROR_ON_DROP_DESTINATION_USAGE table specifies the cell\n usage for mirror on drop queue.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_OBM_PORT_DROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_obm_port_drop_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = LOSSLESS0_PKTs,  /* LOSSLESS0_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Lossless 0 class packet dropped.",
    },
    {
        .name  = LOSSLESS0_BYTEs,  /* LOSSLESS0_BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Lossless 0 class bytes dropped.",
    },
    {
        .name  = LOSSLESS1_PKTs,  /* LOSSLESS1_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Lossless 1 class packets dropped.",
    },
    {
        .name  = LOSSLESS1_BYTEs,  /* LOSSLESS1_BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Lossless 1 class bytes dropped.",
    },
    {
        .name  = LOSSY_HIGH_PKTs,  /* LOSSY_HIGH_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Lossy high class  packets dropped.",
    },
    {
        .name  = LOSSY_HIGH_BYTEs,  /* LOSSY_HIGH_BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Lossy high class  bytes dropped.",
    },
    {
        .name  = LOSSY_LOW_PKTs,  /* LOSSY_LOW_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Lossy low class packets dropped.",
    },
    {
        .name  = LOSSY_LOW_BYTEs,  /* LOSSY_LOW_BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Lossy low class bytes dropped.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n the mapping between PORT_ID to internal physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_obm_port_drop_t = {
    .name = CTR_TM_OBM_PORT_DROPs, /* CTR_TM_OBM_PORT_DROP */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_ctr_tm_obm_port_drop_t_fields,
    .desc = "The CTR_TM_OBM_PORT_DROP table specifies per-port oversubscription buffer\n management (OBM) packet drops.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_OBM_PORT_FLOW_CTRL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_obm_port_flow_ctrl_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = FLOW_CTRL_EVENTSs,  /* FLOW_CTRL_EVENTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Flow control event counter.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of\n the entry. The OPERATIONAL_STATE of the entry becomes invalid if\n the mapping between PORT_ID to internal physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_obm_port_flow_ctrl_t = {
    .name = CTR_TM_OBM_PORT_FLOW_CTRLs, /* CTR_TM_OBM_PORT_FLOW_CTRL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_tm_obm_port_flow_ctrl_t_fields,
    .desc = "The CTR_TM_OBM_PORT_FLOW_CTRL logical table specifies the number of flow\n control events (XON to XOFF) that have occurred.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_OBM_PORT_USAGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_obm_port_usage_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = BYTEs,  /* BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Current usage in total bytes.",
    },
    {
        .name  = LOSSLESS0_BYTEs,  /* LOSSLESS0_BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Current lossless class 0 usage in bytes.",
    },
    {
        .name  = LOSSLESS1_BYTEs,  /* LOSSLESS1_BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Current lossless class 1 usage in bytes.",
    },
    {
        .name  = LOSSY_BYTEs,  /* LOSSY_BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Current lossy usage in bytes.",
    },
    {
        .name  = MAX_USAGE_BYTEs,  /* MAX_USAGE_BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Maximum usage for TM_OBM_PC_PM_MAX_USAGE_MODE.MAX_USAGE_MODE\n in bytes.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n the mapping between PORT_ID to internal physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_obm_port_usage_t = {
    .name = CTR_TM_OBM_PORT_USAGEs, /* CTR_TM_OBM_PORT_USAGE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_tm_obm_port_usage_t_fields,
    .desc = "The CTR_TM_OBM_PORT_USAGE table specifies per-port oversubscription buffer\n management (OBM) current and maximum usage.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_REPL_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_repl_q_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool ID.",
    },
    {
        .name  = REPL_Q_NUMs,  /* REPL_Q_NUM */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Replication queue number.",
    },
    {
        .name  = SHARED_USAGE_CELLSs,  /* SHARED_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Shared usage in cells.",
    },
    {
        .name  = MIN_USAGE_CELLSs,  /* MIN_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Minimum guarantee usage in cells.",
    },
    {
        .name  = TOTAL_USAGE_CELLSs,  /* TOTAL_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total usage in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_repl_q_t = {
    .name = CTR_TM_REPL_Qs, /* CTR_TM_REPL_Q */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_tm_repl_q_t_fields,
    .desc = "The CTR_TM_REPL_Q table specifies the current queue usage in cells\n for the replication queue engine (RQE).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_REPL_Q_DROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_repl_q_drop_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = REPL_Q_NUMs,  /* REPL_Q_NUM */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Replication queue number.",
    },
    {
        .name  = PKTs,  /* PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Packet drop count.",
    },
    {
        .name  = BYTEs,  /* BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Bytes drop count.",
    },
    {
        .name  = RED_PKTs,  /* RED_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Red packets drop count.",
    },
    {
        .name  = YELLOW_PKTs,  /* YELLOW_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Yellow packets drop count.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_repl_q_drop_t = {
    .name = CTR_TM_REPL_Q_DROPs, /* CTR_TM_REPL_Q_DROP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ctr_tm_repl_q_drop_t_fields,
    .desc = "The CTR_TM_REPL_Q_DROP specifies the drop counters for the\n replication queue engine (RQE) drops.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_REPL_Q_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_repl_q_service_pool_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool ID.",
    },
    {
        .name  = SHARED_USAGE_CELLSs,  /* SHARED_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Shared usage in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_repl_q_service_pool_t = {
    .name = CTR_TM_REPL_Q_SERVICE_POOLs, /* CTR_TM_REPL_Q_SERVICE_POOL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_tm_repl_q_service_pool_t_fields,
    .desc = "The CTR_TM_REPL_Q_SERVICE_POOL table specifies the current shared\n usage by the replication queue engine (RQE) across all of its\n priorities.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_STORE_AND_FORWARD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_store_and_forward_t_fields[] = {
    {
        .name  = CTR_TM_STORE_AND_FORWARD_IDs,  /* CTR_TM_STORE_AND_FORWARD_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Store and forward counter ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = PKTs,  /* PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of store and forward packets forwarded.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_store_and_forward_t = {
    .name = CTR_TM_STORE_AND_FORWARDs, /* CTR_TM_STORE_AND_FORWARD */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_tm_store_and_forward_t_fields,
    .desc = "The CTR_TM_STORE_AND_FORWARD table is used to count the store and forward\n packets of a traffic flow that are successfully forwarded from a buffer pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_STORE_AND_FORWARD_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_store_and_forward_control_t_fields[] = {
    {
        .name  = CTR_TM_STORE_AND_FORWARD_IDs,  /* CTR_TM_STORE_AND_FORWARD_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Store and forward counter ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = ING_PORT_ID_MATCHs,  /* ING_PORT_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ingress port match.",
    },
    {
        .name  = ING_TM_PIPE_ID_MATCHs,  /* ING_TM_PIPE_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ingress TM pipe match. TM_PIPE_ID will be derived\n from ING_PORT_ID.\n",
    },
    {
        .name  = ING_PORT_IDs,  /* ING_PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress port ID. Applicable if ING_PORT_ID_MATCH or\n ING_TM_PIPE_ID_MATCH is enabled.\n",
    },
    {
        .name  = EGR_PORT_ID_MATCHs,  /* EGR_PORT_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable egress port match.",
    },
    {
        .name  = EGR_TM_PIPE_ID_MATCHs,  /* EGR_TM_PIPE_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable egress TM pipe match. TM_PIPE_ID will be derived\n from EGR_PORT_ID.\n",
    },
    {
        .name  = EGR_PORT_IDs,  /* EGR_PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress port ID. Applicable if EGR_PORT_ID_MATCH or\n EGR_TM_PIPE_ID_MATCH is enabled.\n",
    },
    {
        .name  = TM_Q_ID_MATCHs,  /* TM_Q_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable queue ID match.",
    },
    {
        .name  = Q_TYPEs,  /* Q_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_TM_QUEUE_TYPE_T_DATA,
        .desc = "Queue type.",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID. Applicable if TM_Q_ID_MATCH is enabled and\n Q_TYPE is UC_Q.\n",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue ID. Applicable if TM_Q_ID_MATCH is enabled and\n Q_TYPE is MC_Q.\n",
    },
    {
        .name  = PRI_GRP_ID_MATCHs,  /* PRI_GRP_ID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable priority group match.",
    },
    {
        .name  = TM_PRI_GRP_IDs,  /* TM_PRI_GRP_ID */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Priority group. Applicable if PRI_GRP_ID_MATCH is enabled.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_store_and_forward_control_t = {
    .name = CTR_TM_STORE_AND_FORWARD_CONTROLs, /* CTR_TM_STORE_AND_FORWARD_CONTROL */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_ctr_tm_store_and_forward_control_t_fields,
    .desc = "The CTR_TM_STORE_AND_FORWARD_CONTROL table is used to specify the\n attributes of the store and forward traffic flow tracked by the\n CTR_TM_STORE_AND_FORWARD counter.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_THD_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_thd_control_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID whose margins are to be monitored.\n  The CTR_TM_THD_DYNAMIC_LOW should be reset to zero after\n  specifying the pool ID in order to ensure that the counters\n  reflect statistics for the newly selected pool.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_thd_control_t = {
    .name = CTR_TM_THD_CONTROLs, /* CTR_TM_THD_CONTROL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ctr_tm_thd_control_t_fields,
    .desc = "The CTR_TM_THD_CONTROL table specifies the egress pool whose\n margin levels are monitored.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_THD_DYNAMIC_HIGH.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_thd_dynamic_high_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Shared space usage in cells for high priority packets.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_thd_dynamic_high_t = {
    .name = CTR_TM_THD_DYNAMIC_HIGHs, /* CTR_TM_THD_DYNAMIC_HIGH */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_tm_thd_dynamic_high_t_fields,
    .desc = "The CTR_TM_THD_DYNAMIC_HIGH table counts the number of high priority\n accepted cells for a service pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_THD_DYNAMIC_LOW.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_thd_dynamic_low_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = LOW_PRI_DYNAMICs,  /* LOW_PRI_DYNAMIC */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Limit alpha index for low priority packets.",
    },
    {
        .name  = PKTs,  /* PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of low priority packets.",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_thd_dynamic_low_t = {
    .name = CTR_TM_THD_DYNAMIC_LOWs, /* CTR_TM_THD_DYNAMIC_LOW */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ctr_tm_thd_dynamic_low_t_fields,
    .desc = "The CTR_TM_THD_DYNAMIC_LOW table counts the number of low priority\n packets of the selected service pool that are admitted using different\n dynamic alpha.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_THD_MC_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_thd_mc_q_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue ID.",
    },
    {
        .name  = SHARED_USAGE_CELLSs,  /* SHARED_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Shared space usage in cells.",
    },
    {
        .name  = MIN_USAGE_CELLSs,  /* MIN_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Queue min space usage in cells.",
    },
    {
        .name  = TOTAL_USAGE_CELLSs,  /* TOTAL_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total usage in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_MC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_thd_mc_q_t = {
    .name = CTR_TM_THD_MC_Qs, /* CTR_TM_THD_MC_Q */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_tm_thd_mc_q_t_fields,
    .desc = "The CTR_TM_THD_MC_Q table specifies minimum, total and shared usage in\n cells for per-port multicast queues.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_THD_Q_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_thd_q_grp_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = UC_MIN_USAGE_CELLSs,  /* UC_MIN_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Unicast queue group min usage in cells.",
    },
    {
        .name  = MC_MIN_USAGE_CELLSs,  /* MC_MIN_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Multicast queue group min usage in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n the entry. The OPERATIONAL_STATE of the entry becomes invalid\n if the mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_thd_q_grp_t = {
    .name = CTR_TM_THD_Q_GRPs, /* CTR_TM_THD_Q_GRP */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ctr_tm_thd_q_grp_t_fields,
    .desc = "The CTR_TM_THD_Q_GRP logical table specifies minimum usage in\n cells for unicast (UC) and multicast (MC) queue groups for an\n egress port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_THD_UC_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_thd_uc_q_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID.",
    },
    {
        .name  = SHARED_USAGE_CELLSs,  /* SHARED_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Shared space usage in cells.",
    },
    {
        .name  = MIN_USAGE_CELLSs,  /* MIN_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Queue min space usage in cells.",
    },
    {
        .name  = TOTAL_USAGE_CELLSs,  /* TOTAL_USAGE_CELLS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total usage in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_UC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_thd_uc_q_t = {
    .name = CTR_TM_THD_UC_Qs, /* CTR_TM_THD_UC_Q */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_tm_thd_uc_q_t_fields,
    .desc = "The CTR_TM_THD_UC_Q table specifies minimum, total and shared usage in\n cells per-port unicast queues.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TM_UC_Q_DROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_tm_uc_q_drop_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID.",
    },
    {
        .name  = PKTs,  /* PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress admission drop packet count.",
    },
    {
        .name  = BYTEs,  /* BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Egress admission drop byte count.",
    },
    {
        .name  = WRED_PKTs,  /* WRED_PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "WRED drop packet count.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_UC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_tm_uc_q_drop_t = {
    .name = CTR_TM_UC_Q_DROPs, /* CTR_TM_UC_Q_DROP */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ctr_tm_uc_q_drop_t_fields,
    .desc = "The CTR_TM_UC_Q_DROP table specifies per egress port total drop\n counters for unicast queues.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ctr/CTR_TRILL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ctr_trill_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port Number",
    },
    {
        .name  = ING_TRILL_RX_PKTSs,  /* ING_TRILL_RX_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received on this port\n with TRILL EtherType.\n",
    },
    {
        .name  = EGR_TRILL_TX_PKTSs,  /* EGR_TRILL_TX_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets transmitted from this port with\n TRILL ethertype.\n",
    },
    {
        .name  = ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDEDs,  /* ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of TRILL packets dropped on an incoming\n TRILL access port.\n",
    },
    {
        .name  = EGR_TRILL_TX_ACCESS_PORT_TRILL_PKTS_DISCARDEDs,  /* EGR_TRILL_TX_ACCESS_PORT_TRILL_PKTS_DISCARDED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of TRILL packets dropped on an outgoing\n TRILL access port.\n",
    },
    {
        .name  = ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDEDs,  /* ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of non-TRILL packets dropped on an incoming\n TRILL network port.\n",
    },
    {
        .name  = EGR_TRILL_TX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDEDs,  /* EGR_TRILL_TX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of non-TRILL packets dropped on an outgoing\n TRILL network port.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_DATA,
        .desc = "",
    },
};
const bcmltd_table_rep_t bcmltd_ctr_trill_t = {
    .name = CTR_TRILLs, /* CTR_TRILL */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_ctr_trill_t_fields,
    .desc = "Logical Table for TRILL counters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_config_t_fields[] = {
    {
        .name  = VARIANTs,  /* VARIANT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Variant selection.",
    },
    {
        .name  = CORE_CLK_FREQs,  /* CORE_CLK_FREQ */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Core clock frequency.",
    },
    {
        .name  = PP_CLK_FREQs,  /* PP_CLK_FREQ */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Packet processing clock frequency.",
    },
    {
        .name  = TS_PLL_CLK_SELs,  /* TS_PLL_CLK_SEL */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "TS PLL input reference clk source selection.",
    },
    {
        .name  = BS_PLL_0_CLK_SELs,  /* BS_PLL_0_CLK_SEL */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "BS PLL0 input reference clk source selection.",
    },
    {
        .name  = BS_PLL_1_CLK_SELs,  /* BS_PLL_1_CLK_SEL */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "BS PLL1 input reference clk source selection.",
    },
    {
        .name  = CHIP_DEBUGs,  /* CHIP_DEBUG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "The meaning of CHIP_DEBUG field is defined and used by chip-specific driver.",
    },
    {
        .name  = PIO_BULK_READs,  /* PIO_BULK_READ */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable use of programmed IO (PIO) reads instead of direct memory\n access (DMA) for reading consecutive physical table locations.\n",
    },
    {
        .name  = PIO_BULK_WRITEs,  /* PIO_BULK_WRITE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable use of PIO writes instead of DMA for writing consecutive\n physical table locations.\n",
    },
    {
        .name  = PIO_BULK_COPYs,  /* PIO_BULK_COPY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable use of PIO writes instead of cross-coupled DMA to copy data\n from one host memory region to another.\n",
    },
    {
        .name  = POLLED_IRQ_ENABLEs,  /* POLLED_IRQ_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable polled interrupt mode, which means that the device\n interrupt service routine is run at regular intervals\n instead of as a response to a hardware interrupt\n event. This mode of operation is intended for debugging\n only.\n",
    },
    {
        .name  = POLLED_IRQ_DELAYs,  /* POLLED_IRQ_DELAY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Delay in usec between each invocation of the device\n interrupt service routine when polled interrupt mode is\n enabled.\n",
    },
    {
        .name  = POLLED_IRQ_THREAD_PRIORITYs,  /* POLLED_IRQ_THREAD_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Priority of interrupt polling thread. Valid range is 0-99\n with 99 being the highest priority.\n",
    },
    {
        .name  = SEQ_RESETs,  /* SEQ_RESET */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Sequential device reset mode.\n Sequential device reset allows for gradual decrease of device current\n in order to avoid current surge and voltage overshoot or undershoot.\n",
    },
};
const bcmltd_table_rep_t bcmltd_device_config_t = {
    .name = DEVICE_CONFIGs, /* DEVICE_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 14,
    .field = bcmltd_device_config_t_fields,
    .desc = "The DEVICE_CONFIG table is used to specify physical device level controls.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_EM_BANK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_em_bank_t_fields[] = {
    {
        .name  = DEVICE_EM_BANK_IDs,  /* DEVICE_EM_BANK_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "HW Hash Bank ID\n  This is an arbitrary ordering of the hash bank\n  elements in the specific physical device.\n",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bank hash offset into the hash vector.",
    },
};
const bcmltd_table_rep_t bcmltd_device_em_bank_t = {
    .name = DEVICE_EM_BANKs, /* DEVICE_EM_BANK */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_device_em_bank_t_fields,
    .desc = "The DEVICE_EM_BANK logical table specifies hash bank controls.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_EM_BANK_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_em_bank_info_t_fields[] = {
    {
        .name  = DEVICE_EM_BANK_IDs,  /* DEVICE_EM_BANK_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the device enhanced memory table.\n The index is an arbitrary ordering of the enhanced memory bank\n elements in the specific physical device.\n",
    },
    {
        .name  = TYPEs,  /* TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Enhanced memory bank type.",
    },
    {
        .name  = LOOKUP_CNTs,  /* LOOKUP_CNT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of lookups supported by the bank.",
    },
    {
        .name  = GROUP_CNTs,  /* GROUP_CNT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of hardware resource groups which might contain this\n enhanced memory bank.\n",
    },
    {
        .name  = DEVICE_EM_GROUP_IDs,  /* DEVICE_EM_GROUP_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 512,
        .desc = "Array of DEVICE_EM_GROUP table indices.\n Specifies the list of hardware resource group IDs which may\n contain this bank. The length of the array is specified in\n GROUP_CNT.\n",
    },
    {
        .name  = BASE_ENTRY_WIDTHs,  /* BASE_ENTRY_WIDTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Width of base entry in bits.\n Applicable only when the TYPE is HASH.\n",
    },
    {
        .name  = BASE_BUCKET_WIDTHs,  /* BASE_BUCKET_WIDTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Width of base bucket in base entries.\n Applicable only when the TYPE is HASH.\n",
    },
    {
        .name  = NUM_BASE_BUCKETSs,  /* NUM_BASE_BUCKETS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of base buckets.\n Applicable only when the TYPE is HASH.\n",
    },
    {
        .name  = NUM_BASE_ENTRIESs,  /* NUM_BASE_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of base entries.\n Applicable only when the TYPE is HASH.\n",
    },
};
const bcmltd_table_rep_t bcmltd_device_em_bank_info_t = {
    .name = DEVICE_EM_BANK_INFOs, /* DEVICE_EM_BANK_INFO */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_device_em_bank_info_t_fields,
    .desc = "The DEVICE_EM_BANK_INFO read-only table provides enhanced memory bank\n hardware information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_EM_BANK_PAIR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_em_bank_pair_t_fields[] = {
    {
        .name  = DEVICE_EM_BANK_IDs,  /* DEVICE_EM_BANK_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Physical bank which supports lookup0 for the logical table.",
    },
    {
        .name  = PAIRED_DEVICE_EM_BANK_IDs,  /* PAIRED_DEVICE_EM_BANK_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Paired bank used for lookup1 of a logical table.\n Applicable when DEVICE_EM_BANK_ID is used for lookup0 of a\n logical table which requires 2 lookups.\n",
    },
};
const bcmltd_table_rep_t bcmltd_device_em_bank_pair_t = {
    .name = DEVICE_EM_BANK_PAIRs, /* DEVICE_EM_BANK_PAIR */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_device_em_bank_pair_t_fields,
    .desc = "The DEVICE_EM_BANK_PAIR logical table specifies controls for\n bank pairing. A bank must be paired if it supports a single lookup\n and is used for lookup0 of a logical table which requires 2 lookups.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_EM_GROUP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_em_group_t_fields[] = {
    {
        .name  = DEVICE_EM_GROUP_IDs,  /* DEVICE_EM_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Enhanced memory group ID.",
    },
    {
        .name  = ROBUSTs,  /* ROBUST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if robust hash was required.\n Applicable only if ATTRIBUTES == HASH.\n",
    },
    {
        .name  = VECTOR_TYPEs,  /* VECTOR_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "An algorithm used for generating hash vector.\n Applicable only if ATTRIBUTES == HASH.\n",
    },
    {
        .name  = DEVICE_EM_BANK_IDs,  /* DEVICE_EM_BANK_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 16,
        .desc = "List of banks participating in this group.",
    },
    {
        .name  = NUM_BANKSs,  /* NUM_BANKS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of banks in this group.",
    },
};
const bcmltd_table_rep_t bcmltd_device_em_group_t = {
    .name = DEVICE_EM_GROUPs, /* DEVICE_EM_GROUP */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_device_em_group_t_fields,
    .desc = "The DEVICE_EM_GROUP logical table specifies device level\n enhanced memory groupings.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_EM_GROUP_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_em_group_info_t_fields[] = {
    {
        .name  = DEVICE_EM_GROUP_IDs,  /* DEVICE_EM_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Enhanced memory group ID.",
    },
    {
        .name  = TILE_MODEs,  /* TILE_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Tile mode in which the group is valid.",
    },
    {
        .name  = ATTRIBUTESs,  /* ATTRIBUTES */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 1,
        .desc = "Group attributes.",
    },
    {
        .name  = NUM_ATTRIBUTESs,  /* NUM_ATTRIBUTES */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of group attributes.",
    },
    {
        .name  = LOOKUP0_LTs,  /* LOOKUP0_LT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 32,
        .desc = "Logical table array whose lookup0 are mapped to this group.",
    },
    {
        .name  = NUM_LOOKUP0_LTs,  /* NUM_LOOKUP0_LT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of logical tables whose lookup0 are mapped to this group.",
    },
    {
        .name  = LOOKUP1_LTs,  /* LOOKUP1_LT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 32,
        .desc = "Logical table array whose lookup1 are mapped to this group.",
    },
    {
        .name  = NUM_LOOKUP1_LTs,  /* NUM_LOOKUP1_LT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of logical tables whose lookup1 are mapped to this group.",
    },
    {
        .name  = FIXED_DEVICE_EM_BANK_IDs,  /* FIXED_DEVICE_EM_BANK_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 16,
        .desc = "Dedicated banks belonging to this group.",
    },
    {
        .name  = NUM_FIXED_BANKSs,  /* NUM_FIXED_BANKS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of dedicated banks in this group.",
    },
};
const bcmltd_table_rep_t bcmltd_device_em_group_info_t = {
    .name = DEVICE_EM_GROUP_INFOs, /* DEVICE_EM_GROUP_INFO */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_device_em_group_info_t_fields,
    .desc = "",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_EM_TILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_em_tile_t_fields[] = {
    {
        .name  = DEVICE_EM_TILE_IDs,  /* DEVICE_EM_TILE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hardware resource enhanced memory tile ID.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Tile mode.",
    },
    {
        .name  = ROBUSTs,  /* ROBUST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable when robust hash is applied.",
    },
    {
        .name  = SEEDs,  /* SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Random seed for robust hash.",
    },
};
const bcmltd_table_rep_t bcmltd_device_em_tile_t = {
    .name = DEVICE_EM_TILEs, /* DEVICE_EM_TILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_device_em_tile_t_fields,
    .desc = "The DEVICE_EM_TILE table table specifies the attributes of each\n enhanced memory tile.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_EM_TILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_em_tile_info_t_fields[] = {
    {
        .name  = DEVICE_EM_TILE_IDs,  /* DEVICE_EM_TILE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hardware resource enhanced memory tile ID.",
    },
    {
        .name  = NUM_MODEs,  /* NUM_MODE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of supported tile modes.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 32,
        .desc = "Tile modes for the enhanced memory tile.",
    },
    {
        .name  = MODE_ATTRIBUTEs,  /* MODE_ATTRIBUTE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 32,
        .desc = "Tile mode attributes for the enhanced memory tile.",
    },
};
const bcmltd_table_rep_t bcmltd_device_em_tile_info_t = {
    .name = DEVICE_EM_TILE_INFOs, /* DEVICE_EM_TILE_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_device_em_tile_info_t_fields,
    .desc = "The DEVICE_EM_TILE_INFO read-only table table provides\n enhanced memory tile information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_EM_TILE_MODE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_em_tile_mode_info_t_fields[] = {
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hardware resource enhanced memory tile mode ID.",
    },
    {
        .name  = NUM_PDD_TYPEs,  /* NUM_PDD_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of supported PDD type.",
    },
    {
        .name  = PDD_TYPEs,  /* PDD_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 2,
        .desc = "Tile's policy data decoder(PDD) type.",
    },
};
const bcmltd_table_rep_t bcmltd_device_em_tile_mode_info_t = {
    .name = DEVICE_EM_TILE_MODE_INFOs, /* DEVICE_EM_TILE_MODE_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_device_em_tile_mode_info_t_fields,
    .desc = "The DEVICE_EM_TILE_MODE_INFO read-only table table provides\n enhanced memory tile mode information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_info_t_fields[] = {
    {
        .name  = VENDOR_IDs,  /* VENDOR_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Vendor ID (typically PCI vendor ID).",
    },
    {
        .name  = DEV_IDs,  /* DEV_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Device ID (typically PCI device ID).",
    },
    {
        .name  = REV_IDs,  /* REV_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Device revision (used to determine device features).",
    },
    {
        .name  = MODELs,  /* MODEL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Additional identification (in case of ambiguous device IDs).",
    },
};
const bcmltd_table_rep_t bcmltd_device_info_t = {
    .name = DEVICE_INFOs, /* DEVICE_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_device_info_t_fields,
    .desc = "The DEVICE_INFO table is used to show the device information.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_OP_DSH_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_op_dsh_info_t_fields[] = {
    {
        .name  = PT_IDs,  /* PT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Physical table ID.",
    },
    {
        .name  = PT_INDEXs,  /* PT_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Physical table index.",
    },
    {
        .name  = PT_INSTANCEs,  /* PT_INSTANCE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Physical table instance.",
    },
    {
        .name  = PT_OPs,  /* PT_OP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PT_OP_T_DATA,
        .desc = "Physical table operation.",
    },
    {
        .name  = PT_OP_STATUSs,  /* PT_OP_STATUS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PT_OP_STATUS_T_DATA,
        .desc = "Operation status.",
    },
};
const bcmltd_table_rep_t bcmltd_device_op_dsh_info_t = {
    .name = DEVICE_OP_DSH_INFOs, /* DEVICE_OP_DSH_INFO */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_device_op_dsh_info_t_fields,
    .desc = "The DEVICE_OP_DSH_INFO table records the last symbol operation\n performed by the CLI register/memory access commands, e.g. get,\n set, insert, pop and so on.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_OP_PT_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_op_pt_info_t_fields[] = {
    {
        .name  = PT_IDs,  /* PT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Physical table ID.",
    },
    {
        .name  = PT_INDEXs,  /* PT_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Physical table index.\n If an operation for which index is an output fails,\n its value would be 0xFFFFFFFF.\n",
    },
    {
        .name  = PT_INSTANCEs,  /* PT_INSTANCE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Physical table instance.",
    },
    {
        .name  = PT_OPs,  /* PT_OP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PT_OP_T_DATA,
        .desc = "Physical table operation.",
    },
    {
        .name  = PT_OP_STATUSs,  /* PT_OP_STATUS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PT_OP_STATUS_T_DATA,
        .desc = "Operation status.",
    },
};
const bcmltd_table_rep_t bcmltd_device_op_pt_info_t = {
    .name = DEVICE_OP_PT_INFOs, /* DEVICE_OP_PT_INFO */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_device_op_pt_info_t_fields,
    .desc = "The DEVICE_OP_PT_INFO table records the last pass-through operation\n performed on a physical table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_PKT_RX_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_pkt_rx_q_t_fields[] = {
    {
        .name  = RX_Qs,  /* RX_Q */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "RX DMA queues (DMA channel).",
    },
    {
        .name  = COSs,  /* COS */
        .flags = 0,
        .width = 1,
        .depth = 128,
        .desc = "Class of services enabled on the RX queue.",
    },
};
const bcmltd_table_rep_t bcmltd_device_pkt_rx_q_t = {
    .name = DEVICE_PKT_RX_Qs, /* DEVICE_PKT_RX_Q */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_device_pkt_rx_q_t_fields,
    .desc = "The DEVICE_PKT_RX_Q table provides per RX queue properties\n for a CPU RX channel.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_TS_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_ts_control_t_fields[] = {
    {
        .name  = TIMESTAMPING_MODEs,  /* TIMESTAMPING_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Timestamping mode.",
    },
    {
        .name  = IEEE1588_VERSIONs,  /* IEEE1588_VERSION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "IEEE 1588 version control.",
    },
    {
        .name  = LATENCY_ADJUSTs,  /* LATENCY_ADJUST */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Latency adjustment of residence time in nanoseconds.",
    },
    {
        .name  = EGR_OBJ_LATENCY_ADJUSTs,  /* EGR_OBJ_LATENCY_ADJUST */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Residence time adjustment on the egress object bus in nanoseconds.",
    },
    {
        .name  = EGR_OBJ_LATENCY_SHIFTs,  /* EGR_OBJ_LATENCY_SHIFT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift value (in number of bits) for the residence time on the\n egress object bus.\n",
    },
    {
        .name  = PARSE_NTP_DST_L4_UDP_PORTs,  /* PARSE_NTP_DST_L4_UDP_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Value to match against the layer 4 destination port in the UDP header\n to identify NTP packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_device_ts_control_t = {
    .name = DEVICE_TS_CONTROLs, /* DEVICE_TS_CONTROL */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_device_ts_control_t_fields,
    .desc = "The DEVICE_TS_CONTROL table specifies device level\n timesync related configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_TS_PTP_MSG_CONTROL_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_ts_ptp_msg_control_profile_t_fields[] = {
    {
        .name  = DEVICE_TS_PTP_MSG_CONTROL_PROFILE_IDs,  /* DEVICE_TS_PTP_MSG_CONTROL_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PTP message control profile table.",
    },
    {
        .name  = SYNC_TO_CPUs,  /* SYNC_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 SYNC message packets to CPU.",
    },
    {
        .name  = SYNC_DROPs,  /* SYNC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 SYNC message packets.",
    },
    {
        .name  = FOLLOW_UP_TO_CPUs,  /* FOLLOW_UP_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 FOLLOW_UP message packets to CPU.",
    },
    {
        .name  = FOLLOW_UP_DROPs,  /* FOLLOW_UP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 FOLLOW_UP message packets.",
    },
    {
        .name  = DELAY_REQ_TO_CPUs,  /* DELAY_REQ_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 DELAY_REQ message packets to CPU.",
    },
    {
        .name  = DELAY_REQ_DROPs,  /* DELAY_REQ_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 DELAY_REQ message packets.",
    },
    {
        .name  = DELAY_RESP_TO_CPUs,  /* DELAY_RESP_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 DELAY_RESP message packets to CPU.",
    },
    {
        .name  = DELAY_RESP_DROPs,  /* DELAY_RESP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 DELAY_RESP message packets.",
    },
    {
        .name  = PDELAY_RESP_TO_CPUs,  /* PDELAY_RESP_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 PDELAY_RESP message packets to CPU.",
    },
    {
        .name  = PDELAY_RESP_DROPs,  /* PDELAY_RESP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 PDELAY_RESP message packets.",
    },
    {
        .name  = PDELAY_RESP_FOLLOW_UP_TO_CPUs,  /* PDELAY_RESP_FOLLOW_UP_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 PDELAY_RESP_FOLLOW_UP message packets\n to CPU.\n",
    },
    {
        .name  = PDELAY_RESP_FOLLOW_UP_DROPs,  /* PDELAY_RESP_FOLLOW_UP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 PDELAY_RESP_FOLLOW_UP message packets.",
    },
    {
        .name  = PDELAY_REQ_TO_CPUs,  /* PDELAY_REQ_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 PDELAY_REQ message packets to CPU.",
    },
    {
        .name  = PDELAY_REQ_DROPs,  /* PDELAY_REQ_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 PDELAY_REQ message packets.",
    },
    {
        .name  = MSG_TYPE4_TO_CPUs,  /* MSG_TYPE4_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 message type 4 packets to CPU.",
    },
    {
        .name  = MSG_TYPE4_DROPs,  /* MSG_TYPE4_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 message type 4 packets.",
    },
    {
        .name  = MSG_TYPE5_TO_CPUs,  /* MSG_TYPE5_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 message type 5 packets to CPU.",
    },
    {
        .name  = MSG_TYPE5_DROPs,  /* MSG_TYPE5_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 message type 5 packets.",
    },
    {
        .name  = MSG_TYPE6_TO_CPUs,  /* MSG_TYPE6_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 message type 6 packets to CPU.",
    },
    {
        .name  = MSG_TYPE6_DROPs,  /* MSG_TYPE6_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 message type 6 packets.",
    },
    {
        .name  = MSG_TYPE7_TO_CPUs,  /* MSG_TYPE7_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 message type 7 packets to CPU.",
    },
    {
        .name  = MSG_TYPE7_DROPs,  /* MSG_TYPE7_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 message type 7 packets.",
    },
    {
        .name  = MSG_TYPE11_TO_CPUs,  /* MSG_TYPE11_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 message type 11 packets to CPU.",
    },
    {
        .name  = MSG_TYPE11_DROPs,  /* MSG_TYPE11_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 message type 11 packets.",
    },
    {
        .name  = MSG_TYPE12_TO_CPUs,  /* MSG_TYPE12_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 message type 12 packets to CPU.",
    },
    {
        .name  = MSG_TYPE12_DROPs,  /* MSG_TYPE12_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 message type 12 packets.",
    },
    {
        .name  = MSG_TYPE13_TO_CPUs,  /* MSG_TYPE13_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 message type 13 packets to CPU.",
    },
    {
        .name  = MSG_TYPE13_DROPs,  /* MSG_TYPE13_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 message type 13 packets.",
    },
    {
        .name  = MSG_TYPE14_TO_CPUs,  /* MSG_TYPE14_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 message type 13 packets to CPU.",
    },
    {
        .name  = MSG_TYPE14_DROPs,  /* MSG_TYPE14_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 message type 14 packets.",
    },
    {
        .name  = MSG_TYPE15_TO_CPUs,  /* MSG_TYPE15_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IEEE 1588 message type 15 packets to CPU.",
    },
    {
        .name  = MSG_TYPE15_DROPs,  /* MSG_TYPE15_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IEEE 1588 message type 15 packets.",
    },
};
const bcmltd_table_rep_t bcmltd_device_ts_ptp_msg_control_profile_t = {
    .name = DEVICE_TS_PTP_MSG_CONTROL_PROFILEs, /* DEVICE_TS_PTP_MSG_CONTROL_PROFILE */
    .flags = 0,
    .fields = 33,
    .field = bcmltd_device_ts_ptp_msg_control_profile_t_fields,
    .desc = "The DEVICE_TS_PTP_MSG_CONTROL_PROFILE table is used to enable copy_to_CPU or\n drop for different message types of IEEE 1588 packet.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_TS_PTP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_ts_ptp_profile_t_fields[] = {
    {
        .name  = DEVICE_TS_PTP_PROFILE_IDs,  /* DEVICE_TS_PTP_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the timestamp PTP profile table.",
    },
    {
        .name  = TIMESTAMP_VALIDs,  /* TIMESTAMP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that the timestamp is valid for IEEE 1588\n packets.\n",
    },
    {
        .name  = DO_NOT_MODIFYs,  /* DO_NOT_MODIFY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to not modify IEEE 1588 packets.",
    },
    {
        .name  = ING_UPDATE_DONEs,  /* ING_UPDATE_DONE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that IEEE 1588 ingress update has been done.",
    },
};
const bcmltd_table_rep_t bcmltd_device_ts_ptp_profile_t = {
    .name = DEVICE_TS_PTP_PROFILEs, /* DEVICE_TS_PTP_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_device_ts_ptp_profile_t_fields,
    .desc = "The DEVICE_TS_PTP_PROFILE table specifies PTP configuration for packet flows\n which are matched with ingress FP entries.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_TS_SYNCE_CLK_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_ts_synce_clk_control_t_fields[] = {
    {
        .name  = CLK_RECOVERYs,  /* CLK_RECOVERY */
        .flags = 0,
        .width = 1,
        .depth = 2,
        .desc = "Enable clock recovery for the specified clock.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 2,
        .desc = "Logical port ID used to source the specified clock. If clock recovery has been\n enabled (CLK_RECOVERY is enabled) for the specified clock, it must be re-enabled\n by toggling CLK_RECOVERY in order for this field to take effect.\n",
    },
    {
        .name  = PORT_ID_OPERs,  /* PORT_ID_OPER */
        .flags = 0,
        .width = 16,
        .depth = 2,
        .desc = "Operational value of the PORT_ID field. This is a read-only field which reflects the\n logical port ID used to source the specified clock that is currently in use.\n",
    },
    {
        .name  = CLK_DIVISORs,  /* CLK_DIVISOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 2,
        .desc = "Clock divisor. If clock recovery has been enabled (CLK_RECOVERY\n is enabled) for the specified clock, it must be re-enabled by\n toggling CLK_RECOVERY in order for this field to take effect.\n",
    },
    {
        .name  = CLK_DIVISOR_OPERs,  /* CLK_DIVISOR_OPER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 2,
        .desc = "Operational value of the clock divisor. This is a read-only field which reflects the\n clock divisor for the specified clock that is currently in use.\n",
    },
    {
        .name  = OVERRIDEs,  /* OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable override mode. If clock recovery has been enabled\n (CLK_RECOVERY is enabled), it must be re-enabled by toggling\n CLK_RECOVERY in order for this field to take effect.\n",
    },
    {
        .name  = OVERRIDE_OPERs,  /* OVERRIDE_OPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Operational value of the override mode. This is a read-only field which reflects the\n override mode that is currently in use.\n",
    },
    {
        .name  = OVERRIDE_CLK_VALIDs,  /* OVERRIDE_CLK_VALID */
        .flags = 0,
        .width = 1,
        .depth = 2,
        .desc = "Valid status in override mode. Applicable when OVERRIDE is enabled.\n If clock recovery has been enabled (CLK_RECOVERY is enabled) for\n the specified clock, it must be re-enabled by toggling\n CLK_RECOVERY in order for this field to take effect.\n",
    },
    {
        .name  = OVERRIDE_CLK_VALID_OPERs,  /* OVERRIDE_CLK_VALID_OPER */
        .flags = 0,
        .width = 1,
        .depth = 2,
        .desc = "Operational value of the valid status in override mode. Applicable when OVERRIDE is\n enabled. This is a read-only field which reflects the override valid status for\n the specified clock that is currently in use.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 2,
        .edata = BCMLTD_COMMON_SYNCE_CLK_STATE_T_DATA,
        .desc = "Operational state. This is a read-only field which reflects the operational\n state of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_device_ts_synce_clk_control_t = {
    .name = DEVICE_TS_SYNCE_CLK_CONTROLs, /* DEVICE_TS_SYNCE_CLK_CONTROL */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_device_ts_synce_clk_control_t_fields,
    .desc = "The DEVICE_TS_SYNCE_CLK_CONTROL table specifies synchronous Ethernet\n (SyncE) clock recovery configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_TS_TIMESTAMP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_ts_timestamp_profile_t_fields[] = {
    {
        .name  = DEVICE_TS_TIMESTAMP_PROFILE_IDs,  /* DEVICE_TS_TIMESTAMP_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the timestamp profile table.",
    },
    {
        .name  = NTP_MODEs,  /* NTP_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use NTP timestamp format.",
    },
    {
        .name  = SYSTEM_RESIDENCE_TIMEs,  /* SYSTEM_RESIDENCE_TIME */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable system ingress timestamp for residence time calculation.",
    },
};
const bcmltd_table_rep_t bcmltd_device_ts_timestamp_profile_t = {
    .name = DEVICE_TS_TIMESTAMP_PROFILEs, /* DEVICE_TS_TIMESTAMP_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_device_ts_timestamp_profile_t_fields,
    .desc = "The DEVICE_TS_TIMESTAMP_PROFILE table specifies timestamp configurations for\n packet flows which are matched with ingress FP entries.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_TS_TOD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_ts_tod_t_fields[] = {
    {
        .name  = TOD_SECs,  /* TOD_SEC */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Second portion of ToD.",
    },
    {
        .name  = TOD_NSECs,  /* TOD_NSEC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Nanosecond portion of ToD.",
    },
    {
        .name  = ADJUSTs,  /* ADJUST */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Adjustment time in nanoseconds.\n Applicable when HW_UPDATE is disabled.\n",
    },
    {
        .name  = HW_UPDATEs,  /* HW_UPDATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable TOD update by hardware.",
    },
    {
        .name  = TOD_SEC_OPERs,  /* TOD_SEC_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational value of second portion of ToD. This is a read-only\n field which reflects the current second value when\n HW_UPDATE is enabled.\n Applicable when HW_UPDATE is enabled.\n",
    },
    {
        .name  = TOD_NSEC_OPERs,  /* TOD_NSEC_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational value of nanosecond portion of ToD. This is a read-only\n field which reflects the current nanosecond value when\n HW_UPDATE is enabled.\n Applicable when HW_UPDATE is enabled.\n",
    },
    {
        .name  = ADJUST_OPERs,  /* ADJUST_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational value of adjustment time in nanoseconds. This is a\n read-only field which reflects the current adjustment time value\n when HW_UPDATE is enabled.\n Applicable when HW_UPDATE is enabled.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TOD_HW_UPDATE_STATE_T_DATA,
        .desc = "Operational state. This is a read-only field which reflects the\n operational state of TOD update. Applicable when HW_UPDATE is\n enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_device_ts_tod_t = {
    .name = DEVICE_TS_TODs, /* DEVICE_TS_TOD */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_device_ts_tod_t_fields,
    .desc = "The DEVICE_TS_TOD table specifies Time of Day (ToD) configuration\n for timestamp conversion to UTC format.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/device/DEVICE_WAL_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_device_wal_config_t_fields[] = {
    {
        .name  = WAL_DEPTH_MULTIPLIERs,  /* WAL_DEPTH_MULTIPLIER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Override default size of WAL buffers.\n\n The WAL stores the operations and related information for\n transactions.\n\n WAL depth multiplier allows an application to increase or decrease\n the depth with respect to default device-specific setting.\n",
    },
    {
        .name  = FIFO_CHANNELS_MODEs,  /* FIFO_CHANNELS_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_DEVICE_FIFO_CHANNELS_MODE_T_DATA,
        .desc = "Maximum number of FIFO channels allowed for sending messages (groups\n of operations).\n\n DISABLE => Disable use of FIFO channels. Send one operation at a\n time.\n SINGLE => Use only one FIFO channel.\n DOUBLE => Use two FIFO channels (max performance).\n\n Applicable only for devices that support FIFO channels.\n",
    },
    {
        .name  = FIFO_CHANNELS_POLLs,  /* FIFO_CHANNELS_POLL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to poll for completion of operations posted to the FIFO\n channel.\n\n Applicable only when FIFO_CHANNELS_MODE is enabled.\n",
    },
    {
        .name  = FIFO_CHANNELS_MAX_POLLS_OVERRIDEs,  /* FIFO_CHANNELS_MAX_POLLS_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable override for software driver assigned default value for number\n of times to poll for completion of operations posted to a\n FIFO_CHANNEL.\n\n Applicable when FIFO_CHANNELS_MODE is enabled.\n",
    },
    {
        .name  = FIFO_CHANNELS_MAX_POLLSs,  /* FIFO_CHANNELS_MAX_POLLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Override value for number of times to poll for completion of\n operations posted to a FIFO_CHANNEL.\n\n Applicable when FIFO_CHANNELS_MAX_POLLS_OVERRIDE is enabled.\n",
    },
    {
        .name  = FIFO_CHANNELS_DMAs,  /* FIFO_CHANNELS_DMA */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use DMA to send operations to the FIFO channel.\n\n Applicable when FIFO_CHANNELS_MODE is enabled.\n",
    },
    {
        .name  = DMA_READ_OP_THRESHOLDs,  /* DMA_READ_OP_THRESHOLD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Threshold for number of consecutive read operations - to select DMA\n vs. non-DMA method.\n\n When the number of read operations from consecutive table locations\n requested is greater than this threshold, DMA method will be used.\n",
    },
    {
        .name  = DMA_WRITE_OP_THRESHOLDs,  /* DMA_WRITE_OP_THRESHOLD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Threshold for number of consecutive write ops - to select DMA vs.\n non-DMA method.\n When the number of write operations to consecutive table locations\n requested is greater than this threshold, DMA method will be used.\n",
    },
    {
        .name  = WAL_READER_USE_FIFO_CHANNEL_OP_THRESHOLDs,  /* WAL_READER_USE_FIFO_CHANNEL_OP_THRESHOLD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Use FIFO channel to send operations to hardware when the number of\n operations in the message exceeds this setting.\n\n Setting of 0 will result in usage of FIFO_CHANNEL for every message.\n\n Applicable when FIFO_CHANNELS_MODE is enabled.\n",
    },
    {
        .name  = BYPASSs,  /* BYPASS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to bypass write ahead log. Send operations directly to\n hardware without waiting for transaction commit. Should be enabled\n only when atomic transactions are disabled via the software\n configuration control feature_ctl.dis_atomic_trans.\n",
    },
};
const bcmltd_table_rep_t bcmltd_device_wal_config_t = {
    .name = DEVICE_WAL_CONFIGs, /* DEVICE_WAL_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 10,
    .field = bcmltd_device_wal_config_t_fields,
    .desc = "The WAL_CONFIG table is used to specify device-level configuration for the\n write-ahead-log (WAL).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_control_t_fields[] = {
    {
        .name  = SAMPLING_PERIODs,  /* SAMPLING_PERIOD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Time duration in microseconds between two consecutive sampling events.",
    },
    {
        .name  = PORT_LOAD_WEIGHTs,  /* PORT_LOAD_WEIGHT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Port load weight.",
    },
    {
        .name  = PORT_QUEUE_SIZE_WEIGHTs,  /* PORT_QUEUE_SIZE_WEIGHT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Port queue size weight.",
    },
    {
        .name  = TM_QUEUE_SIZE_WEIGHTs,  /* TM_QUEUE_SIZE_WEIGHT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Traffic manager port queue size weight.",
    },
    {
        .name  = CAP_PORT_LOADs,  /* CAP_PORT_LOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update average port loading as instantaneous port loading if\n the latter is smaller.\n",
    },
    {
        .name  = CAP_PORT_QUEUE_SIZEs,  /* CAP_PORT_QUEUE_SIZE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update average port queue size as instantaneous port queue size if\n the latter is smaller.\n",
    },
    {
        .name  = CAP_TM_QUEUE_SIZEs,  /* CAP_TM_QUEUE_SIZE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update average traffic manager port queue size as\n instantaneous traffic manager port queue size if the latter is smaller.\n",
    },
    {
        .name  = ETHERTYPE_ELIGIBILITYs,  /* ETHERTYPE_ELIGIBILITY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable EtherType eligible for DLB if match flag is produced.",
    },
    {
        .name  = LB_HASH_USE_FLOW_DLB_ECMPs,  /* LB_HASH_USE_FLOW_DLB_ECMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use LB_HASH flow based hash field selection mechanism in DLB ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_control_t = {
    .name = DLB_CONTROLs, /* DLB_CONTROL */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_dlb_control_t_fields,
    .desc = "The DLB_CONTROL table is used to configure chip-wide\n DLB parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_ECMP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_ecmp_t_fields[] = {
    {
        .name  = DLB_IDs,  /* DLB_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "DLB group identifier.",
    },
    {
        .name  = INACTIVITY_TIMEs,  /* INACTIVITY_TIME */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inactivity duration in microseconds.",
    },
    {
        .name  = ASSIGNMENT_MODEs,  /* ASSIGNMENT_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "DLB operational mode.",
    },
    {
        .name  = FLOW_SET_SIZEs,  /* FLOW_SET_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Encoding defining the number of flow sets for an aggregation group.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Primary ECMP DLB group size.",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "L3_UC_NHOP logical table indices for primary next hops.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "DLB PORT ID array for primary next hops.",
    },
    {
        .name  = PRIMARY_PATH_THRESHOLDs,  /* PRIMARY_PATH_THRESHOLD */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Indicates the primary path is always selected when\n primary path threshold.\n",
    },
    {
        .name  = ALTERNATE_PATH_COSTs,  /* ALTERNATE_PATH_COST */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Cost to switch over to an alternative path.",
    },
    {
        .name  = ALTERNATE_PATH_BIASs,  /* ALTERNATE_PATH_BIAS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bias to switch over to an alternative path.",
    },
    {
        .name  = ALTERNATE_NUM_PATHSs,  /* ALTERNATE_NUM_PATHS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Alternate ECMP DLB group size.",
    },
    {
        .name  = ALTERNATE_NHOP_IDs,  /* ALTERNATE_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "L3_UC_NHOP logical table indices for alternate next hops.",
    },
    {
        .name  = ALTERNATE_PORT_IDs,  /* ALTERNATE_PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "DLB PORT ID Array for alternate next hops.",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_ecmp_t = {
    .name = DLB_ECMPs, /* DLB_ECMP */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_dlb_ecmp_t_fields,
    .desc = "The DLB ECMP group table specifies parameters for an ECMP DLB group.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_ECMP_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_ecmp_control_t_fields[] = {
    {
        .name  = BASE_ECMP_IDs,  /* BASE_ECMP_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Base of ECMP_GROUP ID with DLB_ID support.\n",
    },
    {
        .name  = SEEDs,  /* SEED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Random seed for optimal candidate random selection process.",
    },
    {
        .name  = MONITOR_SEEDs,  /* MONITOR_SEED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Random seed for DLB flow monitoring.",
    },
    {
        .name  = FP_ING_SEEDs,  /* FP_ING_SEED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Random seed used by ingress FP when selecting packet for DLB monitoring.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable active DLB flow monitoring mirror per container.\n Array is indexed by container ID.\n",
    },
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "Array of DLB flow monitoring mirror instances per container.",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_ecmp_control_t = {
    .name = DLB_ECMP_CONTROLs, /* DLB_ECMP_CONTROL */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_dlb_ecmp_control_t_fields,
    .desc = "The DLB_ECMP_CONTROL table is used to configure chip-wide\n DLB ECMP parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_ECMP_ETHERTYPE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_ecmp_ethertype_t_fields[] = {
    {
        .name  = DLB_ECMP_ETHERTYPE_IDs,  /* DLB_ECMP_ETHERTYPE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "DLB ECMP ethertype ID.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "EtherType for which the match flag should be produced.",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_ecmp_ethertype_t = {
    .name = DLB_ECMP_ETHERTYPEs, /* DLB_ECMP_ETHERTYPE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_dlb_ecmp_ethertype_t_fields,
    .desc = "The DLB_ECMP_ETHERTYPE table defines EtherType for which\n DLB should be performed.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_ECMP_MONITOR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_ecmp_monitor_t_fields[] = {
    {
        .name  = DLB_IDs,  /* DLB_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "ECMP DLB group ID.",
    },
    {
        .name  = MONITORs,  /* MONITOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable monitoring of this DLB group.",
    },
    {
        .name  = SAMPLE_THRESHOLDs,  /* SAMPLE_THRESHOLD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sampling threshold for sampling packets for the DLB group.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy packet to CPU.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mirroring.",
    },
    {
        .name  = TRACEs,  /* TRACE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set trace event.",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_ecmp_monitor_t = {
    .name = DLB_ECMP_MONITORs, /* DLB_ECMP_MONITOR */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_dlb_ecmp_monitor_t_fields,
    .desc = "The DLB_ECMP_MONITOR table is used to configure DLB ECMP\n monitor parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_ECMP_PORT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_ecmp_port_control_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = OVERRIDEs,  /* OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable override mode.",
    },
    {
        .name  = OVERRIDE_LINK_STATEs,  /* OVERRIDE_LINK_STATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Link status of the port.\n Applicable only if OVERRIDE is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_ecmp_port_control_t = {
    .name = DLB_ECMP_PORT_CONTROLs, /* DLB_ECMP_PORT_CONTROL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_dlb_ecmp_port_control_t_fields,
    .desc = "The DLB_ECMP_PORT_CONTROL table specifies port based DLB ECMP control parameters.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_ECMP_PORT_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_ecmp_port_status_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = LINK_STATEs,  /* LINK_STATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicate the port status for a logical port which is used when\n selecting a member for the load balancing.\n Port status can be enabled or disabled due to member failure or\n by software override (DLB_ECMP_PORT_CONTROL.OVERRIDE_LINK_STATE).\n When selecting an aggregate member participating in the DLB group,\n the port state is used to mask the selected quality band.\n If the selected port is disabled, the flow set must choose another\n aggregate member participating in the DLB group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_ecmp_port_status_t = {
    .name = DLB_ECMP_PORT_STATUSs, /* DLB_ECMP_PORT_STATUS */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_dlb_ecmp_port_status_t_fields,
    .desc = "The DLB_ECMP_PORT_STATUS table is used to get the specific port link status.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_ECMP_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_ecmp_stats_t_fields[] = {
    {
        .name  = DLB_IDs,  /* DLB_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "DLB group identifier.",
    },
    {
        .name  = FAIL_CNTs,  /* FAIL_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets whose ECMP member can't be resolved through the\n DLB mechanism. Packet forwarding will be based on static ECMP\n configuration when DLB fails.\n",
    },
    {
        .name  = PORT_REASSIGNMENT_CNTs,  /* PORT_REASSIGNMENT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total aggregate port member assignments.",
    },
    {
        .name  = MEMBER_REASSIGNMENT_CNTs,  /* MEMBER_REASSIGNMENT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total aggregate member assignments.",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_ecmp_stats_t = {
    .name = DLB_ECMP_STATSs, /* DLB_ECMP_STATS */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_dlb_ecmp_stats_t_fields,
    .desc = "The DLB_ECMP_STATS table is used to collect DLB ECMP group statistics.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_PORT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_port_control_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = DLB_QUALITY_MAP_IDs,  /* DLB_QUALITY_MAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "DLB_QUALITY_MAP logical table index.",
    },
    {
        .name  = PORT_LOAD_SCALING_FACTORs,  /* PORT_LOAD_SCALING_FACTOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Port loading scaling factor encodings.",
    },
    {
        .name  = PORT_QUEUE_SIZE_SCALING_FACTORs,  /* PORT_QUEUE_SIZE_SCALING_FACTOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Port queue size scaling factor encodings.",
    },
    {
        .name  = TM_QUEUE_SIZE_SCALING_FACTORs,  /* TM_QUEUE_SIZE_SCALING_FACTOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Traffic manager port queue size scaling factor encodings.",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_port_control_t = {
    .name = DLB_PORT_CONTROLs, /* DLB_PORT_CONTROL */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_dlb_port_control_t_fields,
    .desc = "The DLB_PORT_CONTROL table specifies port based DLB control parameters.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_QUALITY_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_quality_map_t_fields[] = {
    {
        .name  = DLB_QUALITY_MAP_IDs,  /* DLB_QUALITY_MAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "DLB_QUALITY_MAP logical table index.",
    },
    {
        .name  = QUANTIZED_AVG_PORT_LOADINGs,  /* QUANTIZED_AVG_PORT_LOADING */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Quantized Value for average port loading.",
    },
    {
        .name  = QUANTIZED_AVG_PORT_QUEUE_SIZEs,  /* QUANTIZED_AVG_PORT_QUEUE_SIZE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Quantized Value for average port queue size.",
    },
    {
        .name  = QUANTIZED_AVG_TM_QUEUE_SIZEs,  /* QUANTIZED_AVG_TM_QUEUE_SIZE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Quantized Value for average traffic manager queue size.",
    },
    {
        .name  = QUALITYs,  /* QUALITY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Member quality.",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_quality_map_t = {
    .name = DLB_QUALITY_MAPs, /* DLB_QUALITY_MAP */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_dlb_quality_map_t_fields,
    .desc = "The DLB_QUALITY_MAP table specifies DLB quality mapping for ports.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_QUANTIZATION_THRESHOLD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_quantization_threshold_t_fields[] = {
    {
        .name  = DLB_QUANTIZATION_THRESHOLD_IDs,  /* DLB_QUANTIZATION_THRESHOLD_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "DLB_QUANTIZATION_THRESHOLD logical table index.",
    },
    {
        .name  = PORT_LOAD_QUANTIZATION_THRESHOLDs,  /* PORT_LOAD_QUANTIZATION_THRESHOLD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Port load quantized threshold value.",
    },
    {
        .name  = PORT_QUEUE_SIZE_QUANTIZATION_THRESHOLDs,  /* PORT_QUEUE_SIZE_QUANTIZATION_THRESHOLD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Port queue size quantized threshold value.",
    },
    {
        .name  = TM_QUEUE_SIZE_QUANTIZATION_THRESHOLDs,  /* TM_QUEUE_SIZE_QUANTIZATION_THRESHOLD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Traffic manager port queue size quantized threshold value.",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_quantization_threshold_t = {
    .name = DLB_QUANTIZATION_THRESHOLDs, /* DLB_QUANTIZATION_THRESHOLD */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_dlb_quantization_threshold_t_fields,
    .desc = "The DLB_QUANTIZATION_THRESHOLD table specifies\n DLB quantized threshold values.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_trunk_t_fields[] = {
    {
        .name  = DLB_IDs,  /* DLB_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "DLB group identifier.",
    },
    {
        .name  = INACTIVITY_TIMEs,  /* INACTIVITY_TIME */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inactivity duration in microseconds.",
    },
    {
        .name  = ASSIGNMENT_MODEs,  /* ASSIGNMENT_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Assigns the DLB operational mode per group which\n determines whether a flow set should be\n re-assigned to a new port.\n",
    },
    {
        .name  = FLOW_SET_SIZEs,  /* FLOW_SET_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Number of flow set entries used by DLB trunk group.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Primary DLB trunk group size.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "Ports managed by the DLB trunk group.",
    },
    {
        .name  = PRIMARY_PATH_THRESHOLDs,  /* PRIMARY_PATH_THRESHOLD */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Minimum quality value in which the primary paths must fall below\n before the alternative paths are considered for reassignment.\n",
    },
    {
        .name  = ALTERNATE_PATH_COSTs,  /* ALTERNATE_PATH_COST */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Cost to switch to an alternative path.",
    },
    {
        .name  = ALTERNATE_PATH_BIASs,  /* ALTERNATE_PATH_BIAS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bias to switch to an alternative path.",
    },
    {
        .name  = ALTERNATE_NUM_PATHSs,  /* ALTERNATE_NUM_PATHS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Alternate DLB trunk group size.",
    },
    {
        .name  = ALTERNATE_PORT_IDs,  /* ALTERNATE_PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "Ports managed by alternate DLB trunk group.",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_trunk_t = {
    .name = DLB_TRUNKs, /* DLB_TRUNK */
    .flags = 0,
    .fields = 11,
    .field = bcmltd_dlb_trunk_t_fields,
    .desc = "The DLB_TRUNK table is used to specify the dynamic load balancing\n (DLB) group used by the trunk for optimal port resolution.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_TRUNK_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_trunk_control_t_fields[] = {
    {
        .name  = SEEDs,  /* SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Random seed for optimal candidate selection.",
    },
    {
        .name  = MONITOR_SEEDs,  /* MONITOR_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Random seed for DLB flow monitoring.",
    },
    {
        .name  = FP_ING_SEEDs,  /* FP_ING_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Random seed used by ingress field processor\n to select a packet for DLB monitoring.\n",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_trunk_control_t = {
    .name = DLB_TRUNK_CONTROLs, /* DLB_TRUNK_CONTROL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_dlb_trunk_control_t_fields,
    .desc = "The DLB_TRUNK_CONTROL table is used to configure\n chip-wide dyamic load balancing (DLB) trunk parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_TRUNK_HASH_OUTPUT_SELECTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_trunk_hash_output_selection_profile_t_fields[] = {
    {
        .name  = DLB_TRUNK_HASH_OUTPUT_SELECTION_PROFILE_IDs,  /* DLB_TRUNK_HASH_OUTPUT_SELECTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the DLB_TRUNK_HASH_OUTPUT_SELECTION_PROFILE table.",
    },
    {
        .name  = HASH_FLOW_ID_SRCs,  /* HASH_FLOW_ID_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The Flex Digest output sub-field selected as the source for generating\n LB_HASH_DLB_TRUNK_OUTPUT_SELECTION.LB_HASH_DLB_TRUNK_OUTPUT_SELECTION_ID,\n key field value, which is used in combination with the\n LB_HASH_INSTANCE key field to index into the\n LB_HASH_DLB_TRUNK_OUTPUT_SELECTION logical table.\n",
    },
    {
        .name  = HASH_INSTANCEs,  /* HASH_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hash table selection for DLB trunk which is used as\n key field value for LB_HASH_DLB_TRUNK_OUTPUT_SELECTION.LB_HASH_INSTANCE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_trunk_hash_output_selection_profile_t = {
    .name = DLB_TRUNK_HASH_OUTPUT_SELECTION_PROFILEs, /* DLB_TRUNK_HASH_OUTPUT_SELECTION_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_dlb_trunk_hash_output_selection_profile_t_fields,
    .desc = "The DLB_TRUNK_HASH_OUTPUT_SELECTION_PROFILE table is used to\n create hash output selection profile for trunk resolution using\n dynamic load balancing (DLB).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_TRUNK_MONITOR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_trunk_monitor_t_fields[] = {
    {
        .name  = DLB_IDs,  /* DLB_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "DLB group identifier.",
    },
    {
        .name  = MONITORs,  /* MONITOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to monitor DLB group.",
    },
    {
        .name  = SAMPLE_THRESHOLDs,  /* SAMPLE_THRESHOLD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Sampling threshold for sampling packets for the DLB group.\n Applicable only when MONITOR is enabled.\n",
    },
    {
        .name  = TRACEs,  /* TRACE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set trace event.\n Applicable only when MONITOR is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_trunk_monitor_t = {
    .name = DLB_TRUNK_MONITORs, /* DLB_TRUNK_MONITOR */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_dlb_trunk_monitor_t_fields,
    .desc = "The DLB_TRUNK_MONITOR table is used to configure\n dynamic load balancing (DLB) trunk monitor parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_TRUNK_PORT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_trunk_port_control_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = OVERRIDEs,  /* OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use software provided link state\n for a port rather than hardware port state.\n",
    },
    {
        .name  = OVERRIDE_LINK_STATEs,  /* OVERRIDE_LINK_STATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Link status provided by the software, used to\n force link active or inactive and to filter out\n an eligible port that is member of the trunk group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_trunk_port_control_t = {
    .name = DLB_TRUNK_PORT_CONTROLs, /* DLB_TRUNK_PORT_CONTROL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_dlb_trunk_port_control_t_fields,
    .desc = "The DLB_TRUNK_PORT_CONTROL table specifies port\n based dynamic load balancing (DLB) trunk control parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_TRUNK_PORT_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_trunk_port_status_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = LINK_STATEs,  /* LINK_STATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicate the port status for a logical port which is used when\n selecting a member for the load balancing.\n Port status can be enabled or disabled due to member failure or\n by software override (DLB_TRUNK_PORT_CONTROL.OVERRIDE_LINK_STATE).\n When selecting an aggregate member participating in the DLB group,\n the port state is used to mask the selected quality band.\n If the selected port is disabled, the flow set must choose another\n aggregate member participating in the DLB group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_trunk_port_status_t = {
    .name = DLB_TRUNK_PORT_STATUSs, /* DLB_TRUNK_PORT_STATUS */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_dlb_trunk_port_status_t_fields,
    .desc = "The DLB_TRUNK_PORT_STATUS read-only table provides the\n current port link status for the logical port parcipating in the\n dynamic load balancing (DLB) trunk group.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dlb/DLB_TRUNK_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dlb_trunk_stats_t_fields[] = {
    {
        .name  = DLB_IDs,  /* DLB_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "DLB group identifier.",
    },
    {
        .name  = FAIL_CNTs,  /* FAIL_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets whose trunk member can't be resolved through the\n DLB mechanism. Packet forwarding will be based on static trunk\n resolution when DLB fails.\n",
    },
    {
        .name  = PORT_REASSIGNMENT_CNTs,  /* PORT_REASSIGNMENT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total aggregate port member reassignments.",
    },
};
const bcmltd_table_rep_t bcmltd_dlb_trunk_stats_t = {
    .name = DLB_TRUNK_STATSs, /* DLB_TRUNK_STATS */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_dlb_trunk_stats_t_fields,
    .desc = "The DLB_TRUNK_STATS table is used to collect\n dynamic load balancing (DLB) trunk group statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/dos/DOS_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dos_control_t_fields[] = {
    {
        .name  = TCP_HDR_SIZE_CHECKs,  /* TCP_HDR_SIZE_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop TCP fragments that fail minimum\n header size specified by TCP_HDR_MIN_SIZE.\n",
    },
    {
        .name  = TCP_HDR_MIN_SIZEs,  /* TCP_HDR_MIN_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies the minimum permissible TCP header size.\n Applicable only when TCP_HDR_SIZE_CHECK is enabled.\n",
    },
    {
        .name  = ICMPV4_PKT_MAX_SIZE_EXCEEDEDs,  /* ICMPV4_PKT_MAX_SIZE_EXCEEDED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IPv4 ICMP packets with payload size\n exceeding the limit specified by ICMPV4_PKT_MAX_SIZE.\n",
    },
    {
        .name  = ICMPV4_PKT_MAX_SIZEs,  /* ICMPV4_PKT_MAX_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies the maximum IPv4 ICMP packet length.\n Applicable only when ICMPV4_PKT_MAX_SIZE_EXCEEDED is enabled.\n",
    },
    {
        .name  = ICMPV6_PKT_MAX_SIZE_EXCEEDEDs,  /* ICMPV6_PKT_MAX_SIZE_EXCEEDED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IPv6 ICMP packets with payload size\n exceeding the limit specified by ICMPV6_PKT_MAX_SIZE.\n",
    },
    {
        .name  = ICMPV6_PKT_MAX_SIZEs,  /* ICMPV6_PKT_MAX_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies the maximum IPv6 ICMP packet length.\n Applicable only when ICMPV6_PKT_MAX_SIZE_EXCEEDED is enabled.\n",
    },
    {
        .name  = IPV6_MIN_FRAGMENT_SIZE_CHECKs,  /* IPV6_MIN_FRAGMENT_SIZE_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check for minimum size of IPv6 fragments\n specified by IPV6_MIN_FRAGMENT_SIZE.\n",
    },
    {
        .name  = IPV6_MIN_FRAGMENT_SIZEs,  /* IPV6_MIN_FRAGMENT_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies the minimum size for IPv6 fragments.\n Applicable only when IPV6_MIN_FRAGMENT_SIZE_CHECK is enabled.\n",
    },
    {
        .name  = IP_FIRST_FRAGMENTs,  /* IP_FIRST_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check for DOS attacks on IP first fragments.",
    },
    {
        .name  = DST_MAC_EQUAL_TO_SRC_MACs,  /* DST_MAC_EQUAL_TO_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets having same source and\n destination MAC addresses.\n",
    },
    {
        .name  = DST_IP_EQUAL_TO_SRC_IPs,  /* DST_IP_EQUAL_TO_SRC_IP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets having same source and\n destination IP addresses.\n",
    },
    {
        .name  = ICMP_FRAGMENTs,  /* ICMP_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IPv4 or IPv6 fragmented ICMP packet.",
    },
    {
        .name  = TCP_PKT_CTRL_FLAG_SEQ_NUM_ZEROs,  /* TCP_PKT_CTRL_FLAG_SEQ_NUM_ZERO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop TCP packets with control flags and\n sequence number equal to 0.\n",
    },
    {
        .name  = TCP_SYN_PKT_FRAGMENTs,  /* TCP_SYN_PKT_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop fragmented TCP SYN packets.",
    },
    {
        .name  = TCP_FRAGMENT_OFFSET_ONEs,  /* TCP_FRAGMENT_OFFSET_ONE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop TCP fragments with fragment offset value\n equal to 1.\n",
    },
    {
        .name  = TCP_DST_PORT_EQUAL_TO_SRC_PORTs,  /* TCP_DST_PORT_EQUAL_TO_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop TCP packets having same L4 destination and source ports.",
    },
    {
        .name  = TCP_PKT_SYN_FIN_SETs,  /* TCP_PKT_SYN_FIN_SET */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop TCP packets having both SYN and FIN bits set.",
    },
    {
        .name  = TCP_PKT_FIN_URG_PUSH_SEQ_NUM_ZEROs,  /* TCP_PKT_FIN_URG_PUSH_SEQ_NUM_ZERO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop TCP packets with FIN, URG and PSH bit set\n and sequence number equal to zero.\n",
    },
    {
        .name  = UDP_DST_PORT_EQUAL_TO_SRC_PORTs,  /* UDP_DST_PORT_EQUAL_TO_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop UDP packets having same L4 destination and source ports.",
    },
    {
        .name  = DOS_ATTACK_TO_CPUs,  /* DOS_ATTACK_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy DOS attack packets to the CPU.",
    },
    {
        .name  = OUTER_IP_PAYLOAD_MAX_CHECKs,  /* OUTER_IP_PAYLOAD_MAX_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IP packets that exceed maximum outer\n IP payload size specified by OUTER_IP_PAYLOAD_MAX_SIZE.\n",
    },
    {
        .name  = OUTER_IP_PAYLOAD_MAX_SIZEs,  /* OUTER_IP_PAYLOAD_MAX_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specify the maximum permissible outer IP payload size.\n Applicable only when OUTER_IP_PAYLOAD_MAX_CHECK is enabled.\n",
    },
    {
        .name  = OUTER_IP_PAYLOAD_MIN_CHECKs,  /* OUTER_IP_PAYLOAD_MIN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IP packets that are below the minimum outer\n IP payload size specified by OUTER_IP_PAYLOAD_MIN_SIZE.\n",
    },
    {
        .name  = OUTER_IP_PAYLOAD_MIN_SIZEs,  /* OUTER_IP_PAYLOAD_MIN_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specify the minimum permissible outer IP payload size.\n Applicable only when OUTER_IP_PAYLOAD_MIN_CHECK is enabled.\n",
    },
    {
        .name  = INNER_IP_PAYLOAD_MAX_CHECKs,  /* INNER_IP_PAYLOAD_MAX_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IP packets that exceed maximum inner\n IP payload size specified by INNER_IP_PAYLOAD_MAX_SIZE.\n",
    },
    {
        .name  = INNER_IP_PAYLOAD_MAX_SIZEs,  /* INNER_IP_PAYLOAD_MAX_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specify the maximum permissible inner IP payload size.\n Applicable only when INNER_IP_PAYLOAD_MAX_CHECK is enabled.\n",
    },
    {
        .name  = INNER_IP_PAYLOAD_MIN_CHECKs,  /* INNER_IP_PAYLOAD_MIN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IP packets that are below the minimum inner\n IP payload size specified by INNER_IP_PAYLOAD_MIN_SIZE.\n",
    },
    {
        .name  = INNER_IP_PAYLOAD_MIN_SIZEs,  /* INNER_IP_PAYLOAD_MIN_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specify the minimum permissible inner IP payload size.\n Applicable only when INNER_IP_PAYLOAD_MIN_CHECK is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_dos_control_t = {
    .name = DOS_CONTROLs, /* DOS_CONTROL */
    .flags = 0,
    .fields = 28,
    .field = bcmltd_dos_control_t_fields,
    .desc = "The DOS_CONTROL table is used to enable Denial Of Service (DOS) checks for\n different types of DOS attacks.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/DT_EFP_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dt_efp_entry_t_fields[] = {
    {
        .name  = DT_EFP_ENTRY_INDEXs,  /* DT_EFP_ENTRY_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP entry identifier.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operational state of the entry.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Priority associated with entry.",
    },
    {
        .name  = DT_EFP_GRP_TEMPLATE_INDEXs,  /* DT_EFP_GRP_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated group ID from DT_EFP_GROUP_TEMPLATE LT.",
    },
    {
        .name  = DT_EFP_RULE_TEMPLATE_INDEXs,  /* DT_EFP_RULE_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated rule ID from DT_EFP_RULE_TEMPLATE LT.",
    },
    {
        .name  = DT_EFP_ACTION_TEMPLATE_INDEXs,  /* DT_EFP_ACTION_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from DT_EFP_POLICY_TEMPLATE LT.",
    },
    {
        .name  = DT_EFP_SBR_TEMPLATE_INDEXs,  /* DT_EFP_SBR_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from DT_EFP_SBR_TEMPLATE LT.",
    },
    {
        .name  = FLEX_CTR_ACTIONs,  /* FLEX_CTR_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated flex counter ID from CTR_EGR_EFLEX_ACTION_PROFILE.",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_dt_efp_entry_t = {
    .name = DT_EFP_ENTRYs, /* DT_EFP_ENTRY */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_dt_efp_entry_t_fields,
    .desc = "The DT_EFP_ENTRY associates group ID, rule ID, action ID and counter ID\n to the entries in the group. Operations on this logical table will\n provision the device egress field processor logic, if sufficient resources\n are available.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/DT_EM_FP_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dt_em_fp_entry_t_fields[] = {
    {
        .name  = DT_EM_FP_ENTRY_INDEXs,  /* DT_EM_FP_ENTRY_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Exact match FP entry identifier.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operational state of the entry.",
    },
    {
        .name  = DT_EM_FP_GRP_TEMPLATE_INDEXs,  /* DT_EM_FP_GRP_TEMPLATE_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated group ID from DT_EM_FP_GROUP_TEMPLATE LT.",
    },
    {
        .name  = DT_EM_FP_RULE_TEMPLATE_INDEXs,  /* DT_EM_FP_RULE_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated rule ID from DT_EM_FP_RULE_TEMPLATE LT.",
    },
    {
        .name  = DT_EM_FP_ACTION_TEMPLATE_INDEXs,  /* DT_EM_FP_ACTION_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from DT_EM_FP_POLICY_TEMPLATE LT.",
    },
    {
        .name  = DT_EM_FP_SBR_TEMPLATE_INDEXs,  /* DT_EM_FP_SBR_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from DT_EM_FP_SBR_TEMPLATE LT.",
    },
    {
        .name  = FLEX_CTR_ACTIONs,  /* FLEX_CTR_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated flex counter ID from CTR_ING_EFLEX_ACTION_PROFILE",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_dt_em_fp_entry_t = {
    .name = DT_EM_FP_ENTRYs, /* DT_EM_FP_ENTRY */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_dt_em_fp_entry_t_fields,
    .desc = "The DT_EM_FP_ENTRY associates group ID, rule ID, action ID and counter ID\n to the entries in the group. Operations on this logical table will\n provision the device exact match field processor logic, if sufficient\n resources are available.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/DT_EM_FT_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dt_em_ft_entry_t_fields[] = {
    {
        .name  = DT_EM_FT_ENTRY_INDEXs,  /* DT_EM_FT_ENTRY_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Exact match FP entry identifier.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operational state of the entry.",
    },
    {
        .name  = DT_EM_FT_GRP_TEMPLATE_INDEXs,  /* DT_EM_FT_GRP_TEMPLATE_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated group ID from DT_EM_FT_GROUP_TEMPLATE LT.",
    },
    {
        .name  = DT_EM_FT_RULE_TEMPLATE_INDEXs,  /* DT_EM_FT_RULE_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated rule ID from DT_EM_FT_RULE_TEMPLATE LT.",
    },
    {
        .name  = DT_EM_FT_ACTION_TEMPLATE_INDEXs,  /* DT_EM_FT_ACTION_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from DT_EM_FT_POLICY_TEMPLATE LT.",
    },
    {
        .name  = FLEX_CTR_ACTIONs,  /* FLEX_CTR_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated flex counter ID from CTR_ING_EFLEX_ACTION_PROFILE",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_dt_em_ft_entry_t = {
    .name = DT_EM_FT_ENTRYs, /* DT_EM_FT_ENTRY */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_dt_em_ft_entry_t_fields,
    .desc = "The DT_EM_FT_ENTRY associates group ID, rule ID, action ID, counter ID and\n meter ID to the entries in the group. Operations on this logical table will\n provision the device flow tracker exact match logic, if sufficient resources\n are available.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/DT_IFP_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dt_ifp_entry_t_fields[] = {
    {
        .name  = DT_IFP_ENTRY_INDEXs,  /* DT_IFP_ENTRY_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP entry identifier.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operational state of the entry.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Priority associated with entry.",
    },
    {
        .name  = DT_IFP_GRP_TEMPLATE_INDEXs,  /* DT_IFP_GRP_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated group ID from DT_IFP_GROUP_TEMPLATE LT.",
    },
    {
        .name  = DT_IFP_RULE_TEMPLATE_INDEXs,  /* DT_IFP_RULE_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated rule ID from DT_IFP_RULE_TEMPLATE LT.",
    },
    {
        .name  = DT_IFP_ACTION_TEMPLATE_INDEXs,  /* DT_IFP_ACTION_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from DT_IFP_POLICY_TEMPLATE LT.",
    },
    {
        .name  = DT_IFP_SBR_TEMPLATE_INDEXs,  /* DT_IFP_SBR_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from DT_IFP_SBR_TEMPLATE LT.",
    },
    {
        .name  = FLEX_CTR_ACTIONs,  /* FLEX_CTR_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated flex counter ID from CTR_ING_EFLEX_ACTION_PROFILE",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_dt_ifp_entry_t = {
    .name = DT_IFP_ENTRYs, /* DT_IFP_ENTRY */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_dt_ifp_entry_t_fields,
    .desc = "The DT_IFP_ENTRY associates group ID, rule ID, action ID and counter ID\n to the entries in the group. Operations on this logical table will\n provision the device ingress field processor logic, if sufficient resources\n are available.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/DT_VFP_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_dt_vfp_entry_t_fields[] = {
    {
        .name  = DT_VFP_ENTRY_INDEXs,  /* DT_VFP_ENTRY_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP entry identifier.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operational state of the entry.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Priority associated with entry.",
    },
    {
        .name  = DT_VFP_GRP_TEMPLATE_INDEXs,  /* DT_VFP_GRP_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated group ID from DT_VFP_GROUP_TEMPLATE LT.",
    },
    {
        .name  = DT_VFP_RULE_TEMPLATE_INDEXs,  /* DT_VFP_RULE_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated rule ID from DT_VFP_RULE_TEMPLATE LT.",
    },
    {
        .name  = DT_VFP_ACTION_TEMPLATE_INDEXs,  /* DT_VFP_ACTION_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from DT_VFP_POLICY_TEMPLATE LT.",
    },
    {
        .name  = DT_VFP_SBR_TEMPLATE_INDEXs,  /* DT_VFP_SBR_TEMPLATE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from DT_VFP_SBR_TEMPLATE LT.",
    },
    {
        .name  = FLEX_CTR_ACTIONs,  /* FLEX_CTR_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated flex counter ID from CTR_ING_EFLEX_ACTION_PROFILE.",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_dt_vfp_entry_t = {
    .name = DT_VFP_ENTRYs, /* DT_VFP_ENTRY */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_dt_vfp_entry_t_fields,
    .desc = "The DT_VFP_ENTRY associates group ID, rule ID, action ID and counter ID\n to the entries in the group. Operations on this logical table will\n provision the device VLAN field processor logic, if sufficient resources\n are available.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP group identifier.",
    },
    {
        .name  = LB_MODEs,  /* LB_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Full ECMP group load balancing mode.",
    },
    {
        .name  = NHOP_SORTEDs,  /* NHOP_SORTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to sort the specified next-hops prior to installation in\n hardware.\n",
    },
    {
        .name  = MAX_PATHSs,  /* MAX_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum number of paths in this ECMP group.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of paths configured for this ECMP group.",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "L3_UC_NHOP or TNL_MPLS_ENCAP_NHOP logical table indices.",
    },
    {
        .name  = RH_NHOP_IDs,  /* RH_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "L3_UC_NHOP or TNL_MPLS_ENCAP_NHOP logical table indices for\n resilient hash load balancing mode group.\n",
    },
    {
        .name  = RH_SIZEs,  /* RH_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Total number of entries occupied by the group in member table when\n configured in resilient hashing load balancing mode.\n",
    },
    {
        .name  = RH_NUM_PATHSs,  /* RH_NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of members in the resilient hashing load balancing\n mode group.\n",
    },
    {
        .name  = RH_RANDOM_SEEDs,  /* RH_RANDOM_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The resilient hashing load balancing mode group random number\n generator seed value.\n",
    },
    {
        .name  = MON_AGM_POOLs,  /* MON_AGM_POOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor pool for unicast packets.",
    },
    {
        .name  = MON_AGM_IDs,  /* MON_AGM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor identifier for unicast packets.",
    },
    {
        .name  = ECMP_CTR_ING_EFLEX_ACTION_IDs,  /* ECMP_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Select one enhanced flex counter action from\n ECMP_CTR_ING_EFLEX_ACTION logical table.\n",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enhanced flex counter object.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_t = {
    .name = ECMPs, /* ECMP */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_ecmp_t_fields,
    .desc = "ECMP logical table can be used to configure full feature single ECMP\n resolution groups on the device.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_config_t_fields[] = {
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Device ECMP resolution mode (Default: FULL).\n FULL         - Full feature single level ECMP resolution mode.\n HIERARCHICAL - Two level hierarchical ECMP resolution mode.\n FAST         - Fast single level ECMP resolution mode.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_config_t = {
    .name = ECMP_CONFIGs, /* ECMP_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 1,
    .field = bcmltd_ecmp_config_t_fields,
    .desc = "ECMP_CONFIG logical table is used to configure device ECMP resolution\n mode.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_control_t_fields[] = {
    {
        .name  = LB_HASHs,  /* LB_HASH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use LB_HASH hash computation.",
    },
    {
        .name  = LB_HASH_FLOW_BASEDs,  /* LB_HASH_FLOW_BASED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use LB_HASH flow based hash field selection mechanism in\n regular ECMP load balancing mode for layer 3 IP unicast packets.\n",
    },
    {
        .name  = OVERLAY_LB_HASH_FLOW_BASEDs,  /* OVERLAY_LB_HASH_FLOW_BASED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use LB_HASH flow based hash field selection mechanism in\n regular ECMP load balancing mode of overlay ECMP group for layer 3\n IP unicast packets.\n",
    },
    {
        .name  = LB_HASH_FLOW_BASED_L2s,  /* LB_HASH_FLOW_BASED_L2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use LB_HASH flow based hash field selection mechanism in\n regular ECMP load balancing mode of single level or underlay ECMP\n group for layer 2 unicast packets.\n",
    },
    {
        .name  = OVERLAY_LB_HASH_FLOW_BASED_L2s,  /* OVERLAY_LB_HASH_FLOW_BASED_L2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use LB_HASH flow based hash field selection mechanism in\n regular ECMP load balancing mode of overlay ECMP group for layer 2\n unicast packets.\n",
    },
    {
        .name  = LB_HASH_FLOW_BASED_RHs,  /* LB_HASH_FLOW_BASED_RH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use LB_HASH flow based hash field selection mechanism in\n resilient hashing ECMP load balancing mode  for layer 3 IP unicast\n packets.\n",
    },
    {
        .name  = OVERLAY_LB_HASH_FLOW_BASED_RHs,  /* OVERLAY_LB_HASH_FLOW_BASED_RH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use LB_HASH flow based hash field selection mechanism in\n resilient hashing ECMP load balancing mode of overlay ECMP group.\n",
    },
    {
        .name  = LB_HASH_FLOW_BASED_MEMBER_WEIGHTs,  /* LB_HASH_FLOW_BASED_MEMBER_WEIGHT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use LB_HASH flow based hash field selection mechanism in\n member weight ECMP load balancing mode for selecting the final next\n hop index from the member pair.\n",
    },
    {
        .name  = OVERLAY_LB_HASH_FLOW_BASED_MEMBER_WEIGHTs,  /* OVERLAY_LB_HASH_FLOW_BASED_MEMBER_WEIGHT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use LB_HASH flow based hash field selection mechanism in\n member weight ECMP load balancing mode of overlay ECMP group for\n selecting the final next hop index from the member pair.\n",
    },
    {
        .name  = USER_DEFINED_VALUEs,  /* USER_DEFINED_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "User defined value used as input for hash computation.",
    },
    {
        .name  = USE_DIP_IN_HASH_CALCs,  /* USE_DIP_IN_HASH_CALC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use destination IP as input for hash computation.",
    },
    {
        .name  = HASH_ALGs,  /* HASH_ALG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash algorithm used for hash computation.",
    },
    {
        .name  = HASH_MASKs,  /* HASH_MASK */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash mask to be applied to the computed hash value for use in modulo\n computation.\n",
    },
    {
        .name  = SINGLE_OVERLAY_RANDOM_SEEDs,  /* SINGLE_OVERLAY_RANDOM_SEED */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Seed for the random number generator used in randomized load\n balancing in single ECMP resolution mode and overlay hierarchical\n ECMP resolution mode groups.\n\n Applicable only if ECMP.LB_MODE == RANDOM (or)\n                    ECMP_FAST.LB_MODE == RANDOM (or)\n                    ECMP_HIERARCHICAL.LB_MODE == RANDOM (or)\n                    ECMP_OVERLAY.LB_MODE == RANDOM.\n",
    },
    {
        .name  = UNDERLAY_RANDOM_SEEDs,  /* UNDERLAY_RANDOM_SEED */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Seed for the random number generator used in randomized load\n balancing in underlay hierarchical ECMP resolution mode groups.\n This seed value is not used when device is configured in single ECMP\n resolution mode.\n\n Applicable only if ECMP_UNDERLAY.LB_MODE == RANDOM.\n",
    },
    {
        .name  = LEVEL0_RANDOM_SEEDs,  /* LEVEL0_RANDOM_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The seed value for the random number generator in the first level\n ECMP resolution function, used for generating the random number\n value that is used in the modulo computation which provides the\n group member offset index value for making forwarding decisions.\n\n Applicable only to groups with ECMP_LEVEL0.LB_MODE == RANDOM.\n",
    },
    {
        .name  = LEVEL1_RANDOM_SEEDs,  /* LEVEL1_RANDOM_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The seed value for the random number generator in the second level\n ECMP resolution function, used for generating the random number\n value that is used in the modulo computation which provides the\n group member offset index value for making forwarding decisions.\n\n Applicable only to groups with ECMP_LEVEL1.LB_MODE == RANDOM.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_control_t = {
    .name = ECMP_CONTROLs, /* ECMP_CONTROL */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_ecmp_control_t_fields,
    .desc = "ECMP_CONTROL logical table is used to control device level ECMP\n functions.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_CTR_ING_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_ctr_ing_eflex_action_t_fields[] = {
    {
        .name  = ECMP_CTR_ING_EFLEX_ACTION_IDs,  /* ECMP_CTR_ING_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the ECMP_CTR_ING_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_ctr_ing_eflex_action_t = {
    .name = ECMP_CTR_ING_EFLEX_ACTIONs, /* ECMP_CTR_ING_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ecmp_ctr_ing_eflex_action_t_fields,
    .desc = "ECMP_CTR_ING_EFLEX_ATION logical table is used to control device level\n ECMP enhanced flex counter functions.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_FAST.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_fast_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Fast ECMP group identifier.",
    },
    {
        .name  = LB_MODEs,  /* LB_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Fast ECMP group load balancing mode.",
    },
    {
        .name  = NHOP_SORTEDs,  /* NHOP_SORTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to sort next-hops prior to installation in hardware.",
    },
    {
        .name  = MAX_PATHSs,  /* MAX_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum number of paths in this ECMP group.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of paths configured for this ECMP group.",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "L3_UC_NHOP or TNL_MPLS_ENCAP_NHOP logical table indices.",
    },
    {
        .name  = RH_NHOP_IDs,  /* RH_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "L3_UC_NHOP or TNL_MPLS_ENCAP_NHOP logical table indices for\n resilient hash load balancing mode group.\n",
    },
    {
        .name  = RH_SIZEs,  /* RH_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Total number of entries occupied by the group in member table when\n configured in resilient hashing load balancing mode.\n",
    },
    {
        .name  = RH_NUM_PATHSs,  /* RH_NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of members in the resilient hashing load balancing\n mode group.\n",
    },
    {
        .name  = RH_RANDOM_SEEDs,  /* RH_RANDOM_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The resilient hashing load balancing mode group random number\n generator seed value.\n",
    },
    {
        .name  = MON_AGM_POOLs,  /* MON_AGM_POOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor pool for unicast packets.",
    },
    {
        .name  = MON_AGM_IDs,  /* MON_AGM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor identifier for unicast packets.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_fast_t = {
    .name = ECMP_FASTs, /* ECMP_FAST */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_ecmp_fast_t_fields,
    .desc = "ECMP_FAST logical table can be used to configure fast single level ECMP\n groups on the device. This logical table is supported only when the device\n ECMP mode is configured as FAST in ECMP_CONFIG logical table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_HIERARCHICAL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_hierarchical_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Hierarchical ECMP group identifier.",
    },
    {
        .name  = LB_MODEs,  /* LB_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hierarchical ECMP group load balancing mode.",
    },
    {
        .name  = NHOP_SORTEDs,  /* NHOP_SORTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to sort the specified next-hops prior to installation in\n hardware.\n",
    },
    {
        .name  = MAX_PATHSs,  /* MAX_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum number of paths in this ECMP group.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of paths configured for this ECMP group.",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "L3_UC_NHOP or TNL_MPLS_ENCAP_NHOP logical table indices.",
    },
    {
        .name  = RH_NHOP_IDs,  /* RH_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "L3_UC_NHOP or TNL_MPLS_ENCAP_NHOP logical table indices for\n resilient hashing load balancing mode.\n",
    },
    {
        .name  = RH_SIZEs,  /* RH_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Total number of entries occupied by the group in member table when\n configured in resilient hashing load balancing mode.\n",
    },
    {
        .name  = RH_NUM_PATHSs,  /* RH_NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of members in the resilient hashing load balancing\n mode group.\n",
    },
    {
        .name  = RH_RANDOM_SEEDs,  /* RH_RANDOM_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The resilient hashing load balancing mode group random number\n generator seed value.\n",
    },
    {
        .name  = MON_AGM_POOLs,  /* MON_AGM_POOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor pool for unicast packets.",
    },
    {
        .name  = MON_AGM_IDs,  /* MON_AGM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor identifier for unicast packets.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_hierarchical_t = {
    .name = ECMP_HIERARCHICALs, /* ECMP_HIERARCHICAL */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_ecmp_hierarchical_t_fields,
    .desc = "ECMP_HIERARCHICAL logical table can be used to configure single level\n ECMP groups on the device. This logical table is supported only when the\n device ECMP mode is configured as HIERARCHICAL in ECMP_CONFIG logical table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_LEVEL0.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_level0_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP Group Member index_0.",
    },
    {
        .name  = NHOP_INDEX_1s,  /* NHOP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 128,
        .desc = "Next hop table index. Inner Next hop table index in case of a Tunnel flow.",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 16,
        .depth = 128,
        .desc = "Destination VP.",
    },
    {
        .name  = NHOP_2_OR_ECMP_GROUP_INDEX_1s,  /* NHOP_2_OR_ECMP_GROUP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 128,
        .desc = "Next_hop_2 table index or ECMP Group index_2.",
    },
    {
        .name  = ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,  /* ECMP_AND_PROT_SWT_SFC_PROFILE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 128,
        .desc = "Encoding for ecmp_and_prot_swt_sfc_profile_index:\n               [1:0]: BITP/BOTP Profile Table index for ECMP and Protection Switching SF;\n               [2:2]: If set, nhop_2_or_ecmp_group_index_1 is ECMP Group 1 Table index else Next hop 2 table index;\n               [3:3]: If set, nhop_2_or_ecmp_group_index_1 carries the ecmp member 0 index to read the ecmp member table;\n",
    },
    {
        .name  = LB_MODEs,  /* LB_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "ECMP group load balancing mode.",
    },
    {
        .name  = MAX_PATHSs,  /* MAX_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum number of ECMP paths supported by this group.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of ECMP paths configured for this group.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_level0_t = {
    .name = ECMP_LEVEL0s, /* ECMP_LEVEL0 */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_ecmp_level0_t_fields,
    .desc = "This table is looked up by ECMP Group Member index_0 which is\n     generated by ECMP Group_0 SF. This table provides the nexthop table index. It also\n     provides a DVP and an underlay next_hop_index or ecmp_group_index_1 in case of an L3\n     unicast packet switching into Layer 2 tunnel. In case of hierarchical ECMP mode for a\n     non_tunnel flow, it can provide ecmp_group_index_1 to resolve next level of ECMP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_LEVEL0_HASH_OUTPUT_CONTROL_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_level0_hash_output_control_profile_t_fields[] = {
    {
        .name  = PROFILE_IDs,  /* PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "ECMP profile identifier.",
    },
    {
        .name  = HASH_TABLE_INSTANCEs,  /* HASH_TABLE_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The ECMP hash output table instance (0/1) selected for generating\n the final ECMP hash value for use in the first level ECMP resolution\n function.\n LB_HASH_ECMP_LEVEL0_OUTPUT_SELECTION.HASH_TABLE_INSTANCE\n key field value.\n",
    },
    {
        .name  = HASH_FLOW_ID_SRCs,  /* HASH_FLOW_ID_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The Flex Digest output sub-field selected as the source for\n generating LB_HASH_ECMP_LEVEL0_OUTPUT_SELECTION.ECMP_HASH_FLOW_ID\n key field value, which is used in combination with\n HASH_TABLE_INSTANCE key field to index into the\n LB_HASH_ECMP_LEVEL0_OUTPUT_SELECTION logical table.\n",
    },
    {
        .name  = MEMBER_INDEXs,  /* MEMBER_INDEX */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select the source for the member index.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_level0_hash_output_control_profile_t = {
    .name = ECMP_LEVEL0_HASH_OUTPUT_CONTROL_PROFILEs, /* ECMP_LEVEL0_HASH_OUTPUT_CONTROL_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ecmp_level0_hash_output_control_profile_t_fields,
    .desc = "The ECMP_LEVEL0_HASH_OUTPUT_CONTROL_PROFILE logical table is used\n for selecting an ECMP hash output table instance and the source for\n generating an index into the selected ECMP hash output table for the first\n level ECMP resolution function.\n\n This logical table is indexed by an ECMP PROFILE_ID value that is defined\n in the NPL application.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_LEVEL0_WEIGHTED.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_level0_weighted_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP Group Member index_0.",
    },
    {
        .name  = NHOP_INDEX_1s,  /* NHOP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 16384,
        .desc = "Next hop table index. Inner Next hop table index in case of a Tunnel flow.",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 16,
        .depth = 16384,
        .desc = "Destination VP.",
    },
    {
        .name  = NHOP_2_OR_ECMP_GROUP_INDEX_1s,  /* NHOP_2_OR_ECMP_GROUP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 16384,
        .desc = "Next_hop_2 table index or ECMP Group index_2.",
    },
    {
        .name  = ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,  /* ECMP_AND_PROT_SWT_SFC_PROFILE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 16384,
        .desc = "Encoding for ecmp_and_prot_swt_sfc_profile_index:\n               [1:0]: BITP/BOTP Profile Table index for ECMP and Protection Switching SF;\n               [2:2]: If set, nhop_2_or_ecmp_group_index_1 is ECMP Group 1 Table index else Next hop 2 table index;\n               [3:3]: If set, nhop_2_or_ecmp_group_index_1 carries the ecmp member 0 index to read the ecmp member table;\n",
    },
    {
        .name  = RH_RANDOM_SEEDs,  /* RH_RANDOM_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "RH ECMP random seed.",
    },
    {
        .name  = RH_MODEs,  /* RH_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to setup resilient hashing in the ECMP group.",
    },
    {
        .name  = RH_NUM_PATHSs,  /* RH_NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of RH ECMP paths configured for the ECMP group.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of ECMP paths configured for this group.",
    },
    {
        .name  = WEIGHTED_SIZEs,  /* WEIGHTED_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Total number of entries occupied by this weighted ECMP group\n in the ECMP member table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_level0_weighted_t = {
    .name = ECMP_LEVEL0_WEIGHTEDs, /* ECMP_LEVEL0_WEIGHTED */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_ecmp_level0_weighted_t_fields,
    .desc = "This table is looked up by ECMP Group Member index_0 which is\n     generated by ECMP Group_0 SF. This table provides the nexthop table index. It also\n     provides a DVP and an underlay next_hop_index or ecmp_group_index_1 in case of an L3\n     unicast packet switching into Layer 2 tunnel. In case of hierarchical ECMP mode for a\n     non_tunnel flow, it can provide ecmp_group_index_1 to resolve next level of ECMP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_LEVEL1.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_level1_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP Group Member index_1.",
    },
    {
        .name  = NHOP_INDEX_1s,  /* NHOP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 128,
        .desc = "Inner Next hop table index.",
    },
    {
        .name  = NHOP_INDEX_2s,  /* NHOP_INDEX_2 */
        .flags = 0,
        .width = 16,
        .depth = 128,
        .desc = "Outer Next hop table index.",
    },
    {
        .name  = STRENGTH_PROFILE_INDEXs,  /* STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 128,
        .desc = "Index of the strength profile table for this entry.",
    },
    {
        .name  = LB_MODEs,  /* LB_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "ECMP group load balancing mode.",
    },
    {
        .name  = MAX_PATHSs,  /* MAX_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum number of ECMP paths supported by this group.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of ECMP paths configured for this group.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_level1_t = {
    .name = ECMP_LEVEL1s, /* ECMP_LEVEL1 */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ecmp_level1_t_fields,
    .desc = "This table is looked up by ECMP Group Member index_2 which is\n     generated by ECMP Group_1 SF. This table can provide both inner and outer nexthop\n     table indexes in case of a tunnel flow. The inner nexthop index_1 get assigned\n     based upon strength resolution.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_LEVEL1_HASH_OUTPUT_CONTROL_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_level1_hash_output_control_profile_t_fields[] = {
    {
        .name  = PROFILE_IDs,  /* PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "ECMP profile identifier.",
    },
    {
        .name  = HASH_TABLE_INSTANCEs,  /* HASH_TABLE_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The ECMP hash output table instance (0/1) selected for generating\n the final ECMP hash value for use in the second level ECMP resolution\n function.\n LB_HASH_ECMP_LEVEL1_OUTPUT_SELECTION.HASH_TABLE_INSTANCE\n key field value.\n",
    },
    {
        .name  = HASH_FLOW_ID_SRCs,  /* HASH_FLOW_ID_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The flex digest output sub-field selected as the source for\n generating LB_HASH_ECMP_LEVEL1_OUTPUT_SELECTION.HASH_FLOW_ID\n key field value, which is used in combination with\n HASH_TABLE_INSTANCE key field to index into the\n LB_HASH_ECMP_LEVEL1_OUTPUT_SELECTION logical table.\n",
    },
    {
        .name  = WECMPs,  /* WECMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable for weighted distribution ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_level1_hash_output_control_profile_t = {
    .name = ECMP_LEVEL1_HASH_OUTPUT_CONTROL_PROFILEs, /* ECMP_LEVEL1_HASH_OUTPUT_CONTROL_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ecmp_level1_hash_output_control_profile_t_fields,
    .desc = "The ECMP_LEVEL1_HASH_OUTPUT_CONTROL_PROFILE logical table is used\n generating an index into the selected ECMP hash output table for the second\n level ECMP resolution function.\n\n This logical table is indexed by an ECMP PROFILE_ID value, which is defined\n in the NPL application.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_LEVEL1_STRENGTH_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_level1_strength_profile_t_fields[] = {
    {
        .name  = ECMP_LEVEL1_STRENGTH_PROFILE_INDEXs,  /* ECMP_LEVEL1_STRENGTH_PROFILE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "ECMP level 1 strength profile index.",
    },
    {
        .name  = DISABLE_OBJ_0s,  /* DISABLE_OBJ_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Member object 0.",
    },
    {
        .name  = DISABLE_OBJ_1s,  /* DISABLE_OBJ_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Member object 1.",
    },
    {
        .name  = DISABLE_OBJ_2s,  /* DISABLE_OBJ_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Member object 2.",
    },
    {
        .name  = DISABLE_CTRL_INFO_0s,  /* DISABLE_CTRL_INFO_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Member control info 0.",
    },
    {
        .name  = DISABLE_CTRL_INFO_1s,  /* DISABLE_CTRL_INFO_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Member control info 1.",
    },
    {
        .name  = DISABLE_CTRL_INFO_2s,  /* DISABLE_CTRL_INFO_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Member control info 2.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_level1_strength_profile_t = {
    .name = ECMP_LEVEL1_STRENGTH_PROFILEs, /* ECMP_LEVEL1_STRENGTH_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ecmp_level1_strength_profile_t_fields,
    .desc = "The ECMP_LEVEL1_STRENGTH_PROFILE table is used to disable ECMP level1 fields\n from overwriting the related level0 fields.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_LEVEL1_WEIGHTED.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_level1_weighted_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP Group Member index_1.",
    },
    {
        .name  = NHOP_INDEX_1s,  /* NHOP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 16384,
        .desc = "Inner Next hop table index.",
    },
    {
        .name  = NHOP_INDEX_2s,  /* NHOP_INDEX_2 */
        .flags = 0,
        .width = 16,
        .depth = 16384,
        .desc = "Outer Next hop table index.",
    },
    {
        .name  = STRENGTH_PROFILE_INDEXs,  /* STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 16384,
        .desc = "Index of the strength profile table for this entry.",
    },
    {
        .name  = RH_RANDOM_SEEDs,  /* RH_RANDOM_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "RH ECMP random seed.",
    },
    {
        .name  = RH_MODEs,  /* RH_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to setup resilient hashing in the ECMP group.",
    },
    {
        .name  = RH_NUM_PATHSs,  /* RH_NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of RH ECMP paths configured for the ECMP group.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of ECMP paths configured for this group.",
    },
    {
        .name  = WEIGHTED_SIZEs,  /* WEIGHTED_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Total number of entries occupied by this weighted ECMP group\n in the ECMP member table.\n",
    },
    {
        .name  = WEIGHTED_MODEs,  /* WEIGHTED_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Weighted ECMP group load balancing mode.",
    },
    {
        .name  = WEIGHTED_NHOP_INDEXs,  /* WEIGHTED_NHOP_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 16384,
        .desc = "Weighted next hop index.\n Applicable only when WEIGHTED_MODE == MEMBER_WEIGHT.\n",
    },
    {
        .name  = WEIGHTs,  /* WEIGHT */
        .flags = 0,
        .width = 16,
        .depth = 16384,
        .desc = "Weight value associated with WEIGHTED_NHOP_INDEX.\n Applicable only when WEIGHTED_MODE == MEMBER_WEIGHT.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_level1_weighted_t = {
    .name = ECMP_LEVEL1_WEIGHTEDs, /* ECMP_LEVEL1_WEIGHTED */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_ecmp_level1_weighted_t_fields,
    .desc = "This table is looked up by ECMP Group Member index_2 which is\n     generated by ECMP Group_1 SF. This table can provide both inner and\n     outer nexthop table indexes in case of a tunnel flow. The inner nexthop\n     index_1 get assigned based upon strength resolution.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_LIMIT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_limit_control_t_fields[] = {
    {
        .name  = MEMBER_OVERLAY_LIMITs,  /* MEMBER_OVERLAY_LIMIT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Limit of the number of hardware\n member table entries used for the overlay ECMP groups.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_limit_control_t = {
    .name = ECMP_LIMIT_CONTROLs, /* ECMP_LIMIT_CONTROL */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_ecmp_limit_control_t_fields,
    .desc = "The ECMP_LIMIT_CONTROL logical table is used to specify the limits for ECMP\n index tables.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_MEMBER0.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_member0_t_fields[] = {
    {
        .name  = ECMP_MEMBER0_IDs,  /* ECMP_MEMBER0_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP Group Member index_0.",
    },
    {
        .name  = NHOP_INDEX_1s,  /* NHOP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Next hop table index. Inner Next hop table index in case of a Tunnel flow.",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Destination VP.",
    },
    {
        .name  = NHOP_2_OR_ECMP_GROUP_INDEX_1s,  /* NHOP_2_OR_ECMP_GROUP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Next_hop_2 table index or ECMP Group index_2.",
    },
    {
        .name  = ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,  /* ECMP_AND_PROT_SWT_SFC_PROFILE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 4096,
        .desc = "Encoding for ecmp_and_prot_swt_sfc_profile_index:\n               [1:0]: BITP/BOTP Profile Table index for ECMP and Protection Switching SF;\n               [2:2]: If set, nhop_2_or_ecmp_group_index_1 is ECMP Group 1 Table index else Next hop 2 table index;\n               [3:3]: If set, nhop_2_or_ecmp_group_index_1 carries the ecmp member 0 index to read the ecmp member table;\n",
    },
    {
        .name  = NUM_ENTRIESs,  /* NUM_ENTRIES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of member entries configured for this group.",
    },
    {
        .name  = BASE_INDEX_AUTOs,  /* BASE_INDEX_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to automatically allocate base index and ignore\n application specified BASE_INDEX field.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index of the first entry of this block in the member table.\n Applicable when BASE_INDEX_AUTO is disabled.\n",
    },
    {
        .name  = BASE_INDEX_OPERs,  /* BASE_INDEX_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Read-only field reflecting the operational base index.\n If BASE_INDEX_AUTO is enabled, this field reflects the base\n index assigned by SDKLT.\n If BASE_INDEX_AUTO is disabled, this field reflects the\n value specified in the BASE_INDEX field.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_member0_t = {
    .name = ECMP_MEMBER0s, /* ECMP_MEMBER0 */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_ecmp_member0_t_fields,
    .desc = "This table is looked up by ECMP Group Member index_0 which is\n     generated by ECMP Group_0 SF. This table provides the nexthop table index. It also\n     provides a DVP and an underlay next_hop_index or ecmp_group_index_1 in case of an L3\n     unicast packet switching into Layer 2 tunnel. In case of hierarchical ECMP mode for a\n     non_tunnel flow, it can provide ecmp_group_index_1 to resolve next level of ECMP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_MEMBER1.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_member1_t_fields[] = {
    {
        .name  = ECMP_MEMBER1_IDs,  /* ECMP_MEMBER1_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP Group Member index_1.",
    },
    {
        .name  = NHOP_INDEX_1s,  /* NHOP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Inner Next hop table index.",
    },
    {
        .name  = NHOP_INDEX_2s,  /* NHOP_INDEX_2 */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Outer Next hop table index.",
    },
    {
        .name  = STRENGTH_PROFILE_INDEXs,  /* STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 4096,
        .desc = "Index of the strength profile table for this entry.",
    },
    {
        .name  = NUM_ENTRIESs,  /* NUM_ENTRIES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of member entries configured for this group.",
    },
    {
        .name  = BASE_INDEX_AUTOs,  /* BASE_INDEX_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to automatically allocate base index and ignore\n application specified BASE_INDEX field.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index of the first entry of this block in the member table.\n Applicable when BASE_INDEX_AUTO is disabled.\n",
    },
    {
        .name  = BASE_INDEX_OPERs,  /* BASE_INDEX_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational group mode(Read Only) of the group.\n If BASE_INDEX_AUTO is set, then BASE_INDEX_OPER field is\n updated with offset of the first entry assigned to group by\n SDKLT.\n If BASE_INDEX_AUTO is not set and the block starting at\n BASE_INDEX is available, then BASE_INDEX field will be\n assigned to BASE_INDEX_OPER field.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_member1_t = {
    .name = ECMP_MEMBER1s, /* ECMP_MEMBER1 */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_ecmp_member1_t_fields,
    .desc = "This table is looked up by ECMP Group Member index_2 which is\n     generated by ECMP Group_1 SF. This table can provide both inner and outer nexthop\n     table indexes in case of a tunnel flow. The inner nexthop index_1 get assigned\n     based upon strength resolution.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_OVERLAY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_overlay_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Overlay ECMP group identifier.",
    },
    {
        .name  = LB_MODEs,  /* LB_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Overlay ECMP group load balancing mode.",
    },
    {
        .name  = NHOP_SORTEDs,  /* NHOP_SORTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to sort next-hops prior to installation in hardware.",
    },
    {
        .name  = MAX_PATHSs,  /* MAX_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum number of paths in this Overlay ECMP group.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of paths configured for this Overlay ECMP group.",
    },
    {
        .name  = ECMP_NHOPs,  /* ECMP_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use ECMP_UNDERLAY_ID logical field array elements as group\n members else use NHOP_ID logical field array elements as group\n members.\n",
    },
    {
        .name  = ECMP_NHOP_UNDERLAYs,  /* ECMP_NHOP_UNDERLAY */
        .flags = 0,
        .width = 1,
        .depth = 4096,
        .desc = "Enable to use the ECMP_UNDERLAY_ID element with the specified array\n index as the group member. Disable to use the corresponding\n UNDERLAY_NHOP_ID element as a group member.\n",
    },
    {
        .name  = ECMP_UNDERLAY_IDs,  /* ECMP_UNDERLAY_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "ECMP_UNDERLAY or ECMP_WEIGHTED_UNDERLAY (if applicable for the mapped\n device) logical table indices.\n",
    },
    {
        .name  = UNDERLAY_NHOP_IDs,  /* UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Underlay next hop IDs.",
    },
    {
        .name  = OVERLAY_NHOP_IDs,  /* OVERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Overlay next hop IDs.",
    },
    {
        .name  = RH_ECMP_NHOP_UNDERLAYs,  /* RH_ECMP_NHOP_UNDERLAY */
        .flags = 0,
        .width = 1,
        .depth = 4096,
        .desc = "Enable to use the RH_ECMP_UNDERLAY_ID element with the specified array\n index as the group member. Disable to use the corresponding\n RH_UNDERLAY_NHOP_ID element as the group member. Applicable only if\n LB_MODE == RESILIENT.\n",
    },
    {
        .name  = RH_ECMP_UNDERLAY_IDs,  /* RH_ECMP_UNDERLAY_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "ECMP_UNDERLAY or ECMP_WEIGHTED_UNDERLAY  (if applicable for the mapped\n device) logical table indices.\n Applicable only if LB_MODE == RESILIENT.\n",
    },
    {
        .name  = RH_UNDERLAY_NHOP_IDs,  /* RH_UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Underlay next hop IDs. Applicable only if\n LB_MODE == RESILIENT.\n",
    },
    {
        .name  = RH_OVERLAY_NHOP_IDs,  /* RH_OVERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Overlay next hop IDs. Applicable only if\n LB_MODE == RESILIENT.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "L3_UC_NHOP or TNL_MPLS_ENCAP_NHOP logical table indices.",
    },
    {
        .name  = RH_NHOP_IDs,  /* RH_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "L3_UC_NHOP or TNL_MPLS_ENCAP_NHOP logical table indices for\n resilient hash load balancing mode group.\n",
    },
    {
        .name  = RH_SIZEs,  /* RH_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Total number of entries occupied by the group in member table when\n configured in resilient hashing load balancing mode.\n",
    },
    {
        .name  = RH_NUM_PATHSs,  /* RH_NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of members in the resilient hashing load balancing\n mode group.\n",
    },
    {
        .name  = RH_RANDOM_SEEDs,  /* RH_RANDOM_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The resilient hashing load balancing mode group random number\n generator seed value.\n",
    },
    {
        .name  = MON_AGM_POOLs,  /* MON_AGM_POOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor pool for unicast packets.",
    },
    {
        .name  = MON_AGM_IDs,  /* MON_AGM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor identifier for unicast packets.",
    },
    {
        .name  = ECMP_OVERLAY_CTR_ING_EFLEX_ACTION_IDs,  /* ECMP_OVERLAY_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Select one enhanced flex counter action from\n ECMP_OVERLAY_CTR_ING_EFLEX_ACTION logical table.\n",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enhanced flex counter object.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_overlay_t = {
    .name = ECMP_OVERLAYs, /* ECMP_OVERLAY */
    .flags = 0,
    .fields = 23,
    .field = bcmltd_ecmp_overlay_t_fields,
    .desc = "ECMP_OVERLAY logical table can be used to configure overlay (level 1) ECMP\n groups on the device.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_OVERLAY_CTR_ING_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_overlay_ctr_ing_eflex_action_t_fields[] = {
    {
        .name  = ECMP_OVERLAY_CTR_ING_EFLEX_ACTION_IDs,  /* ECMP_OVERLAY_CTR_ING_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the ECMP_OVERLAY_CTR_ING_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specify an action.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_overlay_ctr_ing_eflex_action_t = {
    .name = ECMP_OVERLAY_CTR_ING_EFLEX_ACTIONs, /* ECMP_OVERLAY_CTR_ING_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ecmp_overlay_ctr_ing_eflex_action_t_fields,
    .desc = "ECMP_OVERLAY_CTR_ING_EFLEX_ATION logical table is used to control device level\n overlay ECMP enhanced flex counter functions.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_SRC_L3_GROUP_0.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_src_l3_group_0_t_fields[] = {
    {
        .name  = ECMP_SRC_L3_GROUP_0_IDs,  /* ECMP_SRC_L3_GROUP_0_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L3 source ECMP group 0 index.",
    },
    {
        .name  = OBJ_0s,  /* OBJ_0 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Member object 0.",
    },
    {
        .name  = OBJ_1s,  /* OBJ_1 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Member object 1.",
    },
    {
        .name  = OBJ_2s,  /* OBJ_2 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Member object 2.",
    },
    {
        .name  = OBJ_3s,  /* OBJ_3 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Member object 3.",
    },
    {
        .name  = CMD_0s,  /* CMD_0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Member command 0.",
    },
    {
        .name  = CMD_1s,  /* CMD_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Member command 1.",
    },
    {
        .name  = CMD_2s,  /* CMD_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Member command 2.",
    },
    {
        .name  = CMD_3s,  /* CMD_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Member command 3.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_src_l3_group_0_t = {
    .name = ECMP_SRC_L3_GROUP_0s, /* ECMP_SRC_L3_GROUP_0 */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_ecmp_src_l3_group_0_t_fields,
    .desc = "The ECMP_SRC_L3_GROUP_0 table is used to configure L3 outgoing interfaces\n and tunnel types for uRPF.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_SRC_L3_GROUP_1.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_src_l3_group_1_t_fields[] = {
    {
        .name  = ECMP_SRC_L3_GROUP_1_IDs,  /* ECMP_SRC_L3_GROUP_1_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L3 source ECMP group 1 index .",
    },
    {
        .name  = OBJ_0s,  /* OBJ_0 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Member object 0.",
    },
    {
        .name  = OBJ_1s,  /* OBJ_1 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Member object 1.",
    },
    {
        .name  = OBJ_2s,  /* OBJ_2 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Member object 2.",
    },
    {
        .name  = OBJ_3s,  /* OBJ_3 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Member object 3.",
    },
    {
        .name  = CMD_0s,  /* CMD_0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Member command 0.",
    },
    {
        .name  = CMD_1s,  /* CMD_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Member command 1.",
    },
    {
        .name  = CMD_2s,  /* CMD_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Member command 2.",
    },
    {
        .name  = CMD_3s,  /* CMD_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Member command 3.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_src_l3_group_1_t = {
    .name = ECMP_SRC_L3_GROUP_1s, /* ECMP_SRC_L3_GROUP_1 */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_ecmp_src_l3_group_1_t_fields,
    .desc = "The ECMP_SRC_L3_GROUP_1 table is used to configure L3 outgoing interfaces\n and tunnel types for uRPF.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_UNDERLAY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_underlay_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Underlay ECMP group identifier.",
    },
    {
        .name  = LB_MODEs,  /* LB_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Underlay ECMP group load balancing mode.",
    },
    {
        .name  = NHOP_SORTEDs,  /* NHOP_SORTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to sort next-hops prior to installation in hardware.",
    },
    {
        .name  = MAX_PATHSs,  /* MAX_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum number of paths in this Underlay ECMP group.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of paths configured for this Overlay ECMP group.",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "L3_UC_NHOP or TNL_MPLS_ENCAP_NHOP logical table indices.",
    },
    {
        .name  = RH_NHOP_IDs,  /* RH_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Next hop IDs for resilient hash load balancing mode group.\n",
    },
    {
        .name  = RH_SIZEs,  /* RH_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Total number of entries occupied by the group in member table when\n configured in resilient hashing load balancing mode.\n",
    },
    {
        .name  = RH_NUM_PATHSs,  /* RH_NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of members in the resilient hashing load balancing\n mode group.\n",
    },
    {
        .name  = RH_RANDOM_SEEDs,  /* RH_RANDOM_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The resilient hashing load balancing mode group random number\n generator seed value.\n",
    },
    {
        .name  = ECMP_CTR_ING_EFLEX_ACTION_IDs,  /* ECMP_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Select one enhanced flex counter action from\n ECMP_CTR_ING_EFLEX_ACTION logical table.\n",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enhanced flex counter object.",
    },
    {
        .name  = MON_AGM_POOLs,  /* MON_AGM_POOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor pool for unicast packets.",
    },
    {
        .name  = MON_AGM_IDs,  /* MON_AGM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor identifier for unicast packets.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_underlay_t = {
    .name = ECMP_UNDERLAYs, /* ECMP_UNDERLAY */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_ecmp_underlay_t_fields,
    .desc = "ECMP_UNDERLAY logical table can be used to configure underlay (level 2) ECMP\n groups on the device.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_WEIGHTED.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_weighted_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP group identifier.",
    },
    {
        .name  = WEIGHTED_MODEs,  /* WEIGHTED_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Weighted ECMP group load balancing mode.",
    },
    {
        .name  = WEIGHTED_SIZEs,  /* WEIGHTED_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Total number of entries occupied by this weighted ECMP group in the\n ECMP member table.\n",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of members configured and installed in the member table.\n Value of this field must match the members count value configured\n in WEIGHTED_SIZE field to install entries in member table. Value\n of this field can be set to zero to delete the entries installed\n in the member table.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Weighted distribution of L3_UC_NHOP or TNL_MPLS_ENCAP_NHOP\n logical table indices, group members.\n",
    },
    {
        .name  = WEIGHTs,  /* WEIGHT */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "The weight value associated with NHOP_ID.\n Applicable only when WEIGHTED_MODE == MEMBER_WEIGHT.\n",
    },
    {
        .name  = MON_AGM_POOLs,  /* MON_AGM_POOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor pool for unicast packets.",
    },
    {
        .name  = MON_AGM_IDs,  /* MON_AGM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor identifier for unicast packets.",
    },
    {
        .name  = ECMP_CTR_ING_EFLEX_ACTION_IDs,  /* ECMP_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Select one enhanced flex counter action from\n ECMP_CTR_ING_EFLEX_ACTION logical table.\n",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enhanced flex counter object.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_weighted_t = {
    .name = ECMP_WEIGHTEDs, /* ECMP_WEIGHTED */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_ecmp_weighted_t_fields,
    .desc = "The ECMP_WEIGHTED logical table is used to configure weighted ECMP load balancing\n mode single-level ECMP resolution groups on the device.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_WEIGHTED_OVERLAY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_weighted_overlay_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP group identifier.",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of members configured and installed in the member table.\n Value of this field can be set to zero to delete the entries\n installed in the member table.\n",
    },
    {
        .name  = OVERLAY_NHOP_IDs,  /* OVERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Weighted distribution of overlay next hop logical table\n indices.\n",
    },
    {
        .name  = ECMP_NHOP_UNDERLAYs,  /* ECMP_NHOP_UNDERLAY */
        .flags = 0,
        .width = 1,
        .depth = 4096,
        .desc = "Enable to use the ECMP_UNDERLAY_ID element with the same array\n index as a group member else use the corresponding UNDERLAY_NHOP_ID\n element as a group member.\n",
    },
    {
        .name  = ECMP_UNDERLAY_IDs,  /* ECMP_UNDERLAY_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Weighted distribution of underlay ECMP logical table indices.\n One element is applicable only if the corresponding\n ECMP_NHOP_UNDERLAY element is enabled.\n",
    },
    {
        .name  = UNDERLAY_NHOP_IDs,  /* UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Weighted distribution of underlay next hop logical table\n indices.\n",
    },
    {
        .name  = WEIGHTs,  /* WEIGHT */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "The weight value associated with NHOP_ID.\n",
    },
    {
        .name  = ECMP_OVERLAY_CTR_ING_EFLEX_ACTION_IDs,  /* ECMP_OVERLAY_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Select one enhanced flex counter action from\n ECMP_OVERLAY_CTR_ING_EFLEX_ACTION logical table.\n",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enhanced flex counter object.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_weighted_overlay_t = {
    .name = ECMP_WEIGHTED_OVERLAYs, /* ECMP_WEIGHTED_OVERLAY */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_ecmp_weighted_overlay_t_fields,
    .desc = "The ECMP_WEIGHTED_OVERLAY logical table is used to configure\n overlay (level 1) weighted ECMP groups on the device.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecmp/ECMP_WEIGHTED_UNDERLAY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecmp_weighted_underlay_t_fields[] = {
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP group identifier.",
    },
    {
        .name  = WEIGHTED_MODEs,  /* WEIGHTED_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Weighted ECMP group load balancing mode.",
    },
    {
        .name  = WEIGHTED_SIZEs,  /* WEIGHTED_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Total number of entries occupied by this weighted ECMP group in the\n ECMP member table.\n",
    },
    {
        .name  = NUM_PATHSs,  /* NUM_PATHS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of members configured and installed in the member table.\n Value of this field must match the members count value configured\n in WEIGHTED_SIZE field to install entries in the member table.\n Value of this field can be set to zero to delete the entries\n installed in the member table.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "Weighted distribution of L3_UC_NHOP or TNL_MPLS_ENCAP_NHOP\n logical table indices, group members.\n",
    },
    {
        .name  = WEIGHTs,  /* WEIGHT */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "The weight value associated with NHOP_ID.\n Applicable only when WEIGHTED_MODE == MEMBER_WEIGHT.\n",
    },
    {
        .name  = MON_AGM_POOLs,  /* MON_AGM_POOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor pool for unicast packets.",
    },
    {
        .name  = MON_AGM_IDs,  /* MON_AGM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation group monitor identifier for unicast packets.",
    },
    {
        .name  = ECMP_CTR_ING_EFLEX_ACTION_IDs,  /* ECMP_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Select one enhanced flex counter action from\n ECMP_CTR_ING_EFLEX_ACTION logical table.\n",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enhanced flex counter object.",
    },
};
const bcmltd_table_rep_t bcmltd_ecmp_weighted_underlay_t = {
    .name = ECMP_WEIGHTED_UNDERLAYs, /* ECMP_WEIGHTED_UNDERLAY */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_ecmp_weighted_underlay_t_fields,
    .desc = "The ECMP_WEIGHTED_UNDERLAY logical table is used to configure underlay (level 2)\n weighted ECMP groups on the device.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_CNG_TO_IP_ECN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_cng_to_ip_ecn_t_fields[] = {
    {
        .name  = INT_ECN_CNGs,  /* INT_ECN_CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Internal Congestion Notification value.\n It is the final result of the traffic manager's mapped\n congestion parameters and the incoming packet's ECN parameters.\n",
    },
    {
        .name  = PAYLOAD_ECNs,  /* PAYLOAD_ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "ECN value from the IP header for non-tunneled packets.\n  Mapped ECN value from the tunnel ECN and payload ECN\n  for tunneled packets.\n",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet when this entry is hit.",
    },
    {
        .name  = CHANGE_PAYLOAD_ECNs,  /* CHANGE_PAYLOAD_ECN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update the payload ECN value.",
    },
    {
        .name  = NEW_PAYLOAD_ECNs,  /* NEW_PAYLOAD_ECN */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Payload ECN value to be set in the packet\n when CHANGE_PAYLOAD_ECN is enabled.\n",
    },
    {
        .name  = CTR_ECNs,  /* CTR_ECN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update the transmit ECN counter for ECN marked IP packets.",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_cng_to_ip_ecn_t = {
    .name = ECN_CNG_TO_IP_ECNs, /* ECN_CNG_TO_IP_ECN */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ecn_cng_to_ip_ecn_t_fields,
    .desc = "The ECN_CNG_TO_IP_ECN table is used to derive the new payload ECN from the\n  internal congestion notification and the incoming packet's ECN.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_CNG_TO_MPLS_EXP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_cng_to_mpls_exp_t_fields[] = {
    {
        .name  = ECN_CNG_TO_MPLS_EXP_IDs,  /* ECN_CNG_TO_MPLS_EXP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "ECN_CNG_TO_MPLS_EXP logical table index.",
    },
    {
        .name  = INT_ECN_CNGs,  /* INT_ECN_CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Internal congestion notification value.",
    },
    {
        .name  = EXPs,  /* EXP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Label EXP.",
    },
    {
        .name  = CHANGE_EXPs,  /* CHANGE_EXP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to change EXP value.",
    },
    {
        .name  = NEW_EXPs,  /* NEW_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New MPLS Label EXP. Applicable when CHANGE_EXP is enabled.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet",
    },
    {
        .name  = CTR_ECNs,  /* CTR_ECN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update the transmit ECN counter for ECN marked LSR packets.",
    },
    {
        .name  = CHANGE_INT_ECN_CNGs,  /* CHANGE_INT_ECN_CNG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to change INT_ECN_CNG value.",
    },
    {
        .name  = NEW_INT_ECN_CNGs,  /* NEW_INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "New internal congestion notification value.\n Applicable when CHANGE_INT_ECN_CNG is enabled.\n Used as key of EFP, packet attribute of flex counter, congestion\n notification in HiGig header.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_cng_to_mpls_exp_t = {
    .name = ECN_CNG_TO_MPLS_EXPs, /* ECN_CNG_TO_MPLS_EXP */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_ecn_cng_to_mpls_exp_t_fields,
    .desc = "The ECN_CNG_TO_MPLS_EXP table is used to derive MPLS EXP values from\n  internal priority for an MPLS LSR label being pushed into an outgoing\n  MPLS packet.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_CNG_TO_WRED.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_cng_to_wred_t_fields[] = {
    {
        .name  = INT_ECN_CNGs,  /* INT_ECN_CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Internal Congestion Notification.\n It is the final result of the traffic manager's mapped\n congestion parameters and the incoming packet's ECN parameters.\n",
    },
    {
        .name  = RESPONSIVEs,  /* RESPONSIVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that this flow is responsive to drops.",
    },
    {
        .name  = MARKs,  /* MARK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to mark the packets in case of congestion.",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_cng_to_wred_t = {
    .name = ECN_CNG_TO_WREDs, /* ECN_CNG_TO_WRED */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ecn_cng_to_wred_t_fields,
    .desc = "The ECN_CNG_TO_WRED table is used to derive the traffic manager's WRED\n  parameters for this flow from the internal congestion notifications.\n  The traffic manager uses these parameters to pick different WRED curves\n  for the congestion marking and dropping.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_control_t_fields[] = {
    {
        .name  = NON_IP_RESPONSIVEs,  /* NON_IP_RESPONSIVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify all non-IP payloads are responsive.",
    },
    {
        .name  = RESPONSIVE_NON_IP_ECN_CNGs,  /* RESPONSIVE_NON_IP_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Internal congestion notification value for non-IP payloads.\n Applicable only if NON_IP_RESPONSIVE is enabled.\n",
    },
    {
        .name  = NON_RESPONSIVE_NON_IP_ECN_CNGs,  /* NON_RESPONSIVE_NON_IP_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Internal congestion notification value for non-IP payloads.\n Applicable only if NON_IP_RESPONSIVE is disabled.\n",
    },
    {
        .name  = USE_PAYLOAD_IP_PROTO_FOR_RESPONSIVEs,  /* USE_PAYLOAD_IP_PROTO_FOR_RESPONSIVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use the payload's IP protocol field to determine\n responsiveness via the ECN_PROTOCOL table.\n Applicable only for packets with IP payloads.\n",
    },
    {
        .name  = TNL_ENCAP_RESPONSIVE_DEFAULT_INT_ECN_CNGs,  /* TNL_ENCAP_RESPONSIVE_DEFAULT_INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Default internal congestion notification value for tunnel\n encapsulation with non-IP L3 header and responsive protocol.\n Used as key of EFP, packet attribute of flex counter, congestion\n notification in HiGig header.\n",
    },
    {
        .name  = TNL_ENCAP_NON_RESPONSIVE_DEFAULT_INT_ECN_CNGs,  /* TNL_ENCAP_NON_RESPONSIVE_DEFAULT_INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Default internal congestion notification value for tunnel\n encapsulation with non-IP L3 header and non-responsive protocol.\n Used as key of EFP, packet attribute of flex counter, congestion\n notification in HiGig header.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_control_t = {
    .name = ECN_CONTROLs, /* ECN_CONTROL */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ecn_control_t_fields,
    .desc = "The ECN_CONTROL table is used to set global configuration for ECN derivation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_INT_PRI_TO_CNG_POST.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_int_pri_to_cng_post_t_fields[] = {
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Input packet priority.",
    },
    {
        .name  = ECN_IP_TO_CNG_IDs,  /* ECN_IP_TO_CNG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_IP_TO_CNG_POST logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_int_pri_to_cng_post_t = {
    .name = ECN_INT_PRI_TO_CNG_POSTs, /* ECN_INT_PRI_TO_CNG_POST */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ecn_int_pri_to_cng_post_t_fields,
    .desc = "The ECN_INT_PRI_TO_CNG_POST table is used to derive internal congestion\n notification mapping profile index from internal priority (post-forward).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_INT_PRI_TO_CNG_PRE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_int_pri_to_cng_pre_t_fields[] = {
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Input packet priority.",
    },
    {
        .name  = ECN_IP_TO_CNG_IDs,  /* ECN_IP_TO_CNG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_IP_TO_CNG_PRE logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_int_pri_to_cng_pre_t = {
    .name = ECN_INT_PRI_TO_CNG_PREs, /* ECN_INT_PRI_TO_CNG_PRE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ecn_int_pri_to_cng_pre_t_fields,
    .desc = "The ECN_INT_PRI_TO_CNG_PRE table is used to derive internal congestion\n notification mapping profile index from internal priority (pre-forward).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_IP_TO_CNG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_ip_to_cng_t_fields[] = {
    {
        .name  = RESPONSIVEs,  /* RESPONSIVE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that the IP protocol is responsive.",
    },
    {
        .name  = ECNs,  /* ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "ECN value from the IP header for non-tunneled packets.\n Mapped ECN value from the Tunnel ECN and payload ECN\n for tunneled packets.\n",
    },
    {
        .name  = INT_ECN_CNGs,  /* INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Internal Congestion Notification value.",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_ip_to_cng_t = {
    .name = ECN_IP_TO_CNGs, /* ECN_IP_TO_CNG */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ecn_ip_to_cng_t_fields,
    .desc = "The ECN_IP_TO_CNG table is used to derive the internal congestion\n notifications from the payload ECN and the responsiveness of the IP protocol.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_IP_TO_CNG_POST.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_ip_to_cng_post_t_fields[] = {
    {
        .name  = ECN_IP_TO_CNG_IDs,  /* ECN_IP_TO_CNG_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the ECN_IP_TO_CNG_POST table.",
    },
    {
        .name  = RESPONSIVEs,  /* RESPONSIVE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that the IP protocol is responsive.",
    },
    {
        .name  = ECNs,  /* ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "ECN value from the IP header for non-tunneled packets.\n Mapped ECN value from the Tunnel ECN and payload ECN\n for tunneled packets.\n",
    },
    {
        .name  = INT_ECN_CNGs,  /* INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Internal congestion notification value.\n Overwrite the value assigned by ECN_IP_TO_CNG_PRE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_ip_to_cng_post_t = {
    .name = ECN_IP_TO_CNG_POSTs, /* ECN_IP_TO_CNG_POST */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ecn_ip_to_cng_post_t_fields,
    .desc = "The ECN_IP_TO_CNG_POST table is used to derive the internal congestion\n notifications from the payload ECN and the responsiveness and mapping\n profile index (post-forward).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_IP_TO_CNG_PRE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_ip_to_cng_pre_t_fields[] = {
    {
        .name  = ECN_IP_TO_CNG_IDs,  /* ECN_IP_TO_CNG_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the ECN_IP_TO_CNG_PRE table.",
    },
    {
        .name  = RESPONSIVEs,  /* RESPONSIVE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that the IP protocol is responsive.",
    },
    {
        .name  = ECNs,  /* ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "ECN value from the IP header for non-tunneled packets.\n Mapped ECN value from the Tunnel ECN and payload ECN\n for tunneled packets.\n",
    },
    {
        .name  = INT_ECN_CNGs,  /* INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Internal congestion notification value.\n Used as key of EM.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_ip_to_cng_pre_t = {
    .name = ECN_IP_TO_CNG_PREs, /* ECN_IP_TO_CNG_PRE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ecn_ip_to_cng_pre_t_fields,
    .desc = "The ECN_IP_TO_CNG_PRE table is used to derive the internal congestion\n notifications from the payload ECN and the responsiveness and mapping\n profile index (pre-forward).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_ip_to_mpls_exp_non_responsive_t_fields[] = {
    {
        .name  = ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE_IDs,  /* ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE logical table index.",
    },
    {
        .name  = ECNs,  /* ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "IP ECN value of L3 payload.",
    },
    {
        .name  = EXPs,  /* EXP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Label EXP.",
    },
    {
        .name  = CHANGE_EXPs,  /* CHANGE_EXP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to change the EXP value of the label.",
    },
    {
        .name  = NEW_EXPs,  /* NEW_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New MPLS Label EXP. Applicable when CHANGE_EXP is enabled.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet",
    },
    {
        .name  = CTR_ECNs,  /* CTR_ECN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update the transmit ECN counter for ECN marked MPLS packets.",
    },
    {
        .name  = CHANGE_INT_ECN_CNGs,  /* CHANGE_INT_ECN_CNG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to change INT_ECN_CNG value.",
    },
    {
        .name  = NEW_INT_ECN_CNGs,  /* NEW_INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "New Internal congestion notification value.\n Applicable when CHANGE_INT_ECN_CNG is enabled.\n Used as key of EFP, packet attribute of flex counter, congestion\n notification in HiGig header.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_ip_to_mpls_exp_non_responsive_t = {
    .name = ECN_IP_TO_MPLS_EXP_NON_RESPONSIVEs, /* ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_ecn_ip_to_mpls_exp_non_responsive_t_fields,
    .desc = "The ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE table is used to derive MPLS EXP value\n  from IP ECN for non-responsive protocols for all MPLS labels\n  which are pushed into the outgoing MPLS packet in the L3 MPLS flow.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_IP_TO_MPLS_EXP_RESPONSIVE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_ip_to_mpls_exp_responsive_t_fields[] = {
    {
        .name  = ECN_IP_TO_MPLS_EXP_RESPONSIVE_IDs,  /* ECN_IP_TO_MPLS_EXP_RESPONSIVE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "ECN_IP_TO_MPLS_EXP_RESPONSIVE logical table index.",
    },
    {
        .name  = ECNs,  /* ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "IP ECN value of L3 payload.",
    },
    {
        .name  = EXPs,  /* EXP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Label EXP.",
    },
    {
        .name  = CHANGE_EXPs,  /* CHANGE_EXP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to change the EXP value of the label.",
    },
    {
        .name  = NEW_EXPs,  /* NEW_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New MPLS Label EXP. Applicable when CHANGE_EXP is enabled.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet",
    },
    {
        .name  = CTR_ECNs,  /* CTR_ECN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update the transmit ECN counter for ECN marked MPLS packets.",
    },
    {
        .name  = CHANGE_INT_ECN_CNGs,  /* CHANGE_INT_ECN_CNG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to change INT_ECN_CNG value.",
    },
    {
        .name  = NEW_INT_ECN_CNGs,  /* NEW_INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "New Internal congestion notification value.\n Applicable when CHANGE_INT_ECN_CNG is enabled.\n Used as key of EFP, packet attribute of flex counter, congestion\n notification in HiGig header.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_ip_to_mpls_exp_responsive_t = {
    .name = ECN_IP_TO_MPLS_EXP_RESPONSIVEs, /* ECN_IP_TO_MPLS_EXP_RESPONSIVE */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_ecn_ip_to_mpls_exp_responsive_t_fields,
    .desc = "The ECN_IP_TO_MPLS_EXP_RESPONSIVE table is used to derive MPLS EXP value\n  from IP ECN for responsive protocols for all MPLS labels\n  which are pushed into the outgoing MPLS packet in the L3 MPLS flow.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_LATENCY_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_latency_profile_t_fields[] = {
    {
        .name  = ECN_LATENCY_PROFILE_IDs,  /* ECN_LATENCY_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "ECN_LATENCY_PROFILE logical table index.",
    },
    {
        .name  = MMU_QUEUE_NUMs,  /* MMU_QUEUE_NUM */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Lower 4-bits of MMU_QUEUE_NUM/MMU_COS.",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable latency ECN.",
    },
    {
        .name  = THDs,  /* THD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Latency threshold in nsec.",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_latency_profile_t = {
    .name = ECN_LATENCY_PROFILEs, /* ECN_LATENCY_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_ecn_latency_profile_t_fields,
    .desc = "The ECN_LATENCY_PROFILE table is used to enable latency ECN and configure\n latency threshold.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_LATENCY_WRED_UPDATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_latency_wred_update_t_fields[] = {
    {
        .name  = INT_ECN_CNGs,  /* INT_ECN_CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Internal congestion notification value.\n It is the final result of the traffic manager's mapped\n congestion parameters and the incoming packet's ECN parameters.\n",
    },
    {
        .name  = MAX_THD_EXCEEDs,  /* MAX_THD_EXCEED */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Maximum buffer threshold exceeded status from the traffic\n manager.\n",
    },
    {
        .name  = MIN_THD_EXCEEDs,  /* MIN_THD_EXCEED */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Minimum buffer threshold exceeded status from the traffic\n manager.\n",
    },
    {
        .name  = CE_LATENCYs,  /* CE_LATENCY */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Latency experience status.",
    },
    {
        .name  = RESPONSIVEs,  /* RESPONSIVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Responsiveness of the flow.",
    },
    {
        .name  = NEW_INT_ECN_CNGs,  /* NEW_INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "New internal congestion notification.",
    },
    {
        .name  = CONGESTION_MARKEDs,  /* CONGESTION_MARKED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Congestion marked status.\n Used as attribute of flex counter.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_latency_wred_update_t = {
    .name = ECN_LATENCY_WRED_UPDATEs, /* ECN_LATENCY_WRED_UPDATE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ecn_latency_wred_update_t_fields,
    .desc = "The ECN_LATENCY_WRED_UPDATE table is used to update internal congestion\n notification based on the buffer usage status and latency.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_MPLS_EXP_TO_IP_ECN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_mpls_exp_to_ip_ecn_t_fields[] = {
    {
        .name  = ECN_MPLS_EXP_TO_IP_ECN_IDs,  /* ECN_MPLS_EXP_TO_IP_ECN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "ECN_MPLS_EXP_TO_IP_ECN logical table index.",
    },
    {
        .name  = LAST_DERIVED_ECNs,  /* LAST_DERIVED_ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Specifies ECN value from the previous label to be used to derive\n this label's ECN from EXP.\n The ECN value used for the first label lookup is 0.\n",
    },
    {
        .name  = EXPs,  /* EXP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "EXP value of this label.\n",
    },
    {
        .name  = ECNs,  /* ECN */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Specifies tunnel ECN value to be used for deriving new payload ECN.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet when this entry is hit.",
    },
    {
        .name  = CTR_ECNs,  /* CTR_ECN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update the receive ECN counter for packets arriving on\n the terminating tunnel.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_mpls_exp_to_ip_ecn_t = {
    .name = ECN_MPLS_EXP_TO_IP_ECNs, /* ECN_MPLS_EXP_TO_IP_ECN */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ecn_mpls_exp_to_ip_ecn_t_fields,
    .desc = "The ECN_MPLS_EXP_TO_IP_ECN table is used to derive the ECN value\n  from the incoming MPLS packet.\n  The incoming label's EXP value is used and the profile index pointer is taken\n  from the matching label entry.\n\n  If the MPLS packet has multiple labels, then the ECN value derived in the last\n  label matching result is used to derive the next ECN value.\n  The ECN value used in the index for first lookup is 0.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_PROTOCOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_protocol_t_fields[] = {
    {
        .name  = IP_PROTOs,  /* IP_PROTO */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP protocol in the IP header",
    },
    {
        .name  = RESPONSIVEs,  /* RESPONSIVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that the IP protocol is responsive.",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_protocol_t = {
    .name = ECN_PROTOCOLs, /* ECN_PROTOCOL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ecn_protocol_t_fields,
    .desc = "The ECN_PROTOCOL table is used to derive the responsiveness of the IP\n  protocol.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_TNL_DECAP_IP_PAYLOAD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_tnl_decap_ip_payload_t_fields[] = {
    {
        .name  = ECN_TNL_DECAP_IP_PAYLOAD_IDs,  /* ECN_TNL_DECAP_IP_PAYLOAD_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the ECN_TNL_DECAP_IP_PAYLOAD table.",
    },
    {
        .name  = TNL_ECNs,  /* TNL_ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "ECN value in the tunnel header.",
    },
    {
        .name  = PAYLOAD_ECNs,  /* PAYLOAD_ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "ECN value in the IP payload.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy the packet to CPU when this entry is hit.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet when this entry is hit.",
    },
    {
        .name  = CHANGE_PAYLOAD_ECNs,  /* CHANGE_PAYLOAD_ECN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update the payload ECN value",
    },
    {
        .name  = NEW_PAYLOAD_ECNs,  /* NEW_PAYLOAD_ECN */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Payload ECN value to be set in the packet when\n CHANGE_PAYLOAD_ECN is enabled.\n",
    },
    {
        .name  = CTR_ECNs,  /* CTR_ECN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update the receive ECN counter for packets arriving on\n the terminating tunnel.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_tnl_decap_ip_payload_t = {
    .name = ECN_TNL_DECAP_IP_PAYLOADs, /* ECN_TNL_DECAP_IP_PAYLOAD */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_ecn_tnl_decap_ip_payload_t_fields,
    .desc = "The ECN_TNL_DECAP_IP_PAYLOAD table is used to derive the payload ECN from\n  a tunnel termination flow with an IP payload.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_TNL_DECAP_NON_IP_PAYLOAD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_tnl_decap_non_ip_payload_t_fields[] = {
    {
        .name  = ECN_TNL_DECAP_NON_IP_PAYLOAD_IDs,  /* ECN_TNL_DECAP_NON_IP_PAYLOAD_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the ECN_TNL_DECAP_NON_IP_PAYLOAD table.",
    },
    {
        .name  = TNL_ECNs,  /* TNL_ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "ECN value in the tunnel header.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy the packet to CPU when this entry is hit",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet when this entry is hit.",
    },
    {
        .name  = CTR_ECNs,  /* CTR_ECN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update the receive ECN counter for packets arriving on\n the terminating tunnel.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_tnl_decap_non_ip_payload_t = {
    .name = ECN_TNL_DECAP_NON_IP_PAYLOADs, /* ECN_TNL_DECAP_NON_IP_PAYLOAD */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_ecn_tnl_decap_non_ip_payload_t_fields,
    .desc = "The ECN_TNL_DECAP_NON_IP_PAYLOAD table is used to derive the payload ECN\n from a tunnel termination flow with a NON IP payload.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_TNL_ENCAP_IP_PAYLOAD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_tnl_encap_ip_payload_t_fields[] = {
    {
        .name  = ECN_TNL_ENCAP_IP_PAYLOAD_IDs,  /* ECN_TNL_ENCAP_IP_PAYLOAD_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the ECN_TNL_ENCAP_IP_PAYLOAD table.",
    },
    {
        .name  = PAYLOAD_ECNs,  /* PAYLOAD_ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Payload ECN value.",
    },
    {
        .name  = TNL_ECNs,  /* TNL_ECN */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "ECN value of the tunnel IP header.",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_tnl_encap_ip_payload_t = {
    .name = ECN_TNL_ENCAP_IP_PAYLOADs, /* ECN_TNL_ENCAP_IP_PAYLOAD */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ecn_tnl_encap_ip_payload_t_fields,
    .desc = "The ECN_TNL_ENCAP_IP_PAYLOAD table is used to derive the tunnel ECN when an\n IP payload is encapsulated into an IP tunnel.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_TNL_ENCAP_IP_TO_CNG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_tnl_encap_ip_to_cng_t_fields[] = {
    {
        .name  = RESPONSIVEs,  /* RESPONSIVE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that the IP protocol is responsive.",
    },
    {
        .name  = TNL_ECNs,  /* TNL_ECN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "ECN value of the tunnel IP header.",
    },
    {
        .name  = INT_ECN_CNGs,  /* INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "New internal congestion notification value.\n Used as key of EFP, packet attributes of flex counter, congestion\n notification in HiGig header.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_tnl_encap_ip_to_cng_t = {
    .name = ECN_TNL_ENCAP_IP_TO_CNGs, /* ECN_TNL_ENCAP_IP_TO_CNG */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ecn_tnl_encap_ip_to_cng_t_fields,
    .desc = "The ECN_TNL_ENCAP_IP_TO_CNG table is used to derive the internal\n congestion notifications from the tunnel ECN and the responsiveness of\n the IP protocol.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_TNL_ENCAP_NON_IP_PAYLOAD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_tnl_encap_non_ip_payload_t_fields[] = {
    {
        .name  = ECN_TNL_ENCAP_NON_IP_PAYLOAD_IDs,  /* ECN_TNL_ENCAP_NON_IP_PAYLOAD_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the ECN_TNL_ENCAP_NON_IP_PAYLOAD table.",
    },
    {
        .name  = TNL_ECNs,  /* TNL_ECN */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "ECN value of the tunnel IP header.",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_tnl_encap_non_ip_payload_t = {
    .name = ECN_TNL_ENCAP_NON_IP_PAYLOADs, /* ECN_TNL_ENCAP_NON_IP_PAYLOAD */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_ecn_tnl_encap_non_ip_payload_t_fields,
    .desc = "The ECN_TNL_ENCAP_NON_IP_PAYLOAD table is used to derive the tunnel ECN\n when a non-IP payload is encapsulated into the IP tunnel.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ecn/ECN_WRED_UPDATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ecn_wred_update_t_fields[] = {
    {
        .name  = INT_ECN_CNGs,  /* INT_ECN_CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Internal Congestion Notification value.\n It is the final result of the traffic manager's mapped\n congestion parameters and the incoming packet's ECN parameters.\n",
    },
    {
        .name  = TM_CONGESTIONs,  /* TM_CONGESTION */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Congestion status from the traffic manager.",
    },
    {
        .name  = PACKET_CNGs,  /* PACKET_CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Congestion status derived from the incoming packet.",
    },
    {
        .name  = RESPONSIVEs,  /* RESPONSIVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Responsiveness of the flow.",
    },
    {
        .name  = NEW_INT_ECN_CNGs,  /* NEW_INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "New internal congestion notification.",
    },
    {
        .name  = CONGESTION_MARKEDs,  /* CONGESTION_MARKED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Congestion marked status.\n Used as attribute of flex counter.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ecn_wred_update_t = {
    .name = ECN_WRED_UPDATEs, /* ECN_WRED_UPDATE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ecn_wred_update_t_fields,
    .desc = "The ECN_WRED_UPDATE table is used to update internal congestion\n notification based on the congestion status from the traffic manager.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_digest/FLEX_DIGEST_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_digest_control_t_fields[] = {
    {
        .name  = VERSATILE_HASH_RANDOM_SEED_As,  /* VERSATILE_HASH_RANDOM_SEED_A */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Random seed value which will be populated into VH_KEY[287:256].",
    },
    {
        .name  = VERSATILE_HASH_RANDOM_SEED_Bs,  /* VERSATILE_HASH_RANDOM_SEED_B */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Random seed value which will be populated into VH_KEY[287:256].",
    },
    {
        .name  = VERSATILE_HASH_RANDOM_SEED_Cs,  /* VERSATILE_HASH_RANDOM_SEED_C */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Random seed value which will be populated into VH_KEY[287:256].",
    },
};
const bcmltd_table_rep_t bcmltd_flex_digest_control_t = {
    .name = FLEX_DIGEST_CONTROLs, /* FLEX_DIGEST_CONTROL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_digest_control_t_fields,
    .desc = "The FLEX_DIGEST_CONTROL table is used to control device level\n flex digest functions.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_digest/FLEX_DIGEST_HASH_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_digest_hash_profile_t_fields[] = {
    {
        .name  = FLEX_DIGEST_HASH_PROFILE_IDs,  /* FLEX_DIGEST_HASH_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the flex digest hash profile table.",
    },
    {
        .name  = PRE_PROCESSING_BIN_As,  /* PRE_PROCESSING_BIN_A */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable pre-processing (shift and XOR action) control for\n BIN_A set.\n",
    },
    {
        .name  = PRE_PROCESSING_BIN_Bs,  /* PRE_PROCESSING_BIN_B */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable pre-processing (shift and XOR action) control for\n BIN_B set.\n",
    },
    {
        .name  = PRE_PROCESSING_BIN_Cs,  /* PRE_PROCESSING_BIN_C */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable pre-processing (shift and XOR action) control for\n BIN_C set.\n",
    },
    {
        .name  = XOR_SALT_BIN_As,  /* XOR_SALT_BIN_A */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable XOR salt control for BIN_A set.",
    },
    {
        .name  = XOR_SALT_BIN_Bs,  /* XOR_SALT_BIN_B */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable XOR salt control for BIN_B set.",
    },
    {
        .name  = XOR_SALT_BIN_Cs,  /* XOR_SALT_BIN_C */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable XOR salt control for BIN_C set.",
    },
    {
        .name  = BIN_A_0_FUNCTION_SELECTIONs,  /* BIN_A_0_FUNCTION_SELECTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "First hash function to process BIN_A set to produce hash A_0.",
    },
    {
        .name  = BIN_A_1_FUNCTION_SELECTIONs,  /* BIN_A_1_FUNCTION_SELECTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Second hash function to process BIN_A set to produce hash A_1.",
    },
    {
        .name  = BIN_B_0_FUNCTION_SELECTIONs,  /* BIN_B_0_FUNCTION_SELECTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "First hash function to process BIN_B set to produce hash B_0.",
    },
    {
        .name  = BIN_B_1_FUNCTION_SELECTIONs,  /* BIN_B_1_FUNCTION_SELECTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Second hash function to process BIN_B set to produce hash B_1.",
    },
    {
        .name  = BIN_C_0_FUNCTION_SELECTIONs,  /* BIN_C_0_FUNCTION_SELECTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "First hash function to process BIN_C set to produce hash C_0.",
    },
    {
        .name  = BIN_C_1_FUNCTION_SELECTIONs,  /* BIN_C_1_FUNCTION_SELECTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Second hash function to process BIN_C set to produce hash C_1.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_digest_hash_profile_t = {
    .name = FLEX_DIGEST_HASH_PROFILEs, /* FLEX_DIGEST_HASH_PROFILE */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_flex_digest_hash_profile_t_fields,
    .desc = "The FLEX_DIGEST_HASH_PROFILE table specifies a hash function profile.\n The profile contains controls to pre-process and salt the three set of\n bins as well as selecting two hash algorithms for each set of bin.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_digest/FLEX_DIGEST_HASH_SALT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_digest_hash_salt_t_fields[] = {
    {
        .name  = BIN_As,  /* BIN_A */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "SALT field for BIN_A set.",
    },
    {
        .name  = BIN_Bs,  /* BIN_B */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "SALT field for BIN_B set.",
    },
    {
        .name  = BIN_Cs,  /* BIN_C */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "SALT field for BIN_C set.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_digest_hash_salt_t = {
    .name = FLEX_DIGEST_HASH_SALTs, /* FLEX_DIGEST_HASH_SALT */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_digest_hash_salt_t_fields,
    .desc = "The FLEX_DIGEST_HASH_SALT table specifies the salt for each bin.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_digest/FLEX_DIGEST_LKUP_MASK_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_digest_lkup_mask_profile_t_fields[] = {
    {
        .name  = FLEX_DIGEST_LKUP_MASK_PROFILE_IDs,  /* FLEX_DIGEST_LKUP_MASK_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_DIGEST_LKUP_MASK_PROFILE table.",
    },
    {
        .name  = MASKs,  /* MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Bin mask.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_digest_lkup_mask_profile_t = {
    .name = FLEX_DIGEST_LKUP_MASK_PROFILEs, /* FLEX_DIGEST_LKUP_MASK_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_flex_digest_lkup_mask_profile_t_fields,
    .desc = "The FLEX_DIGEST_LKUP_MASK_PROFILE table specifies a bin mask profile.\n Once a field is selected for a bin, the mask is applied to the\n FLEX_DIGEST_LKUP table's BIN_A and BIN_B values (BIN_A/B & MASK) to\n derive the final output of the bin.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_digest/FLEX_DIGEST_NORM_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_digest_norm_profile_t_fields[] = {
    {
        .name  = FLEX_DIGEST_NORM_PROFILE_IDs,  /* FLEX_DIGEST_NORM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the normalization control profile.",
    },
    {
        .name  = NORMs,  /* NORM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the normalization.",
    },
    {
        .name  = FLEX_DIGEST_NORM_PROFILE_SEED_IDs,  /* FLEX_DIGEST_NORM_PROFILE_SEED_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Hash random seed profile index.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_digest_norm_profile_t = {
    .name = FLEX_DIGEST_NORM_PROFILEs, /* FLEX_DIGEST_NORM_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_digest_norm_profile_t_fields,
    .desc = "The FLEX_DIGEST_NORM_PROFILE table programs user configurable parameters of\n the normalization control profile. Other parameters are initialized by the\n system. The control profile determines which packet's fields to be\n compressed and normalized to form a new set of fields. The profile ID is\n available for reference.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_digest/FLEX_DIGEST_NORM_PROFILE_SEED.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_digest_norm_profile_seed_t_fields[] = {
    {
        .name  = FLEX_DIGEST_NORM_PROFILE_SEED_IDs,  /* FLEX_DIGEST_NORM_PROFILE_SEED_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the flex digest normalization profile seed table.",
    },
    {
        .name  = BIN_A_SEEDs,  /* BIN_A_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Hash random seed for BIN_A set.",
    },
    {
        .name  = BIN_B_SEEDs,  /* BIN_B_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Hash random seed for BIN_B set.",
    },
    {
        .name  = BIN_C_SEEDs,  /* BIN_C_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Hash random seed for BIN_C set.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_digest_norm_profile_seed_t = {
    .name = FLEX_DIGEST_NORM_PROFILE_SEEDs, /* FLEX_DIGEST_NORM_PROFILE_SEED */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_flex_digest_norm_profile_seed_t_fields,
    .desc = "The FLEX_DIGEST_NORM_PROFILE_SEED table specifies a random seed profile.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_0.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_0_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_0_t = {
    .name = FLEX_QOS_EGR_ECN_0s, /* FLEX_QOS_EGR_ECN_0 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_0_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_0 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_1.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_1_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_1_t = {
    .name = FLEX_QOS_EGR_ECN_1s, /* FLEX_QOS_EGR_ECN_1 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_1_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_1 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_10.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_10_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_10_t = {
    .name = FLEX_QOS_EGR_ECN_10s, /* FLEX_QOS_EGR_ECN_10 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_10_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_10 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_11.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_11_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_11_t = {
    .name = FLEX_QOS_EGR_ECN_11s, /* FLEX_QOS_EGR_ECN_11 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_11_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_11 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_2.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_2_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_2_t = {
    .name = FLEX_QOS_EGR_ECN_2s, /* FLEX_QOS_EGR_ECN_2 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_2_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_2 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_3.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_3_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_3_t = {
    .name = FLEX_QOS_EGR_ECN_3s, /* FLEX_QOS_EGR_ECN_3 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_3_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_3 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_4_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_4_t = {
    .name = FLEX_QOS_EGR_ECN_4s, /* FLEX_QOS_EGR_ECN_4 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_4_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_4 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_5.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_5_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_5_t = {
    .name = FLEX_QOS_EGR_ECN_5s, /* FLEX_QOS_EGR_ECN_5 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_5_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_5 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_6_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_6_t = {
    .name = FLEX_QOS_EGR_ECN_6s, /* FLEX_QOS_EGR_ECN_6 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_6_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_6 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_7.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_7_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_7_t = {
    .name = FLEX_QOS_EGR_ECN_7s, /* FLEX_QOS_EGR_ECN_7 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_7_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_7 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_8.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_8_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_8_t = {
    .name = FLEX_QOS_EGR_ECN_8s, /* FLEX_QOS_EGR_ECN_8 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_8_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_8 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_ECN_9.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_ecn_9_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_ecn_9_t = {
    .name = FLEX_QOS_EGR_ECN_9s, /* FLEX_QOS_EGR_ECN_9 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_ecn_9_t_fields,
    .desc = "The FLEX_QOS_EGR_ECN_9 table is used to derive the outgoing packet's\n  ECN field based on internal CN attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_0.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_0_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_0_t = {
    .name = FLEX_QOS_EGR_PHB_0s, /* FLEX_QOS_EGR_PHB_0 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_0_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_0 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_1.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_1_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_1_t = {
    .name = FLEX_QOS_EGR_PHB_1s, /* FLEX_QOS_EGR_PHB_1 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_1_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_1 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_10.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_10_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_10_t = {
    .name = FLEX_QOS_EGR_PHB_10s, /* FLEX_QOS_EGR_PHB_10 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_10_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_10 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_11.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_11_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_11_t = {
    .name = FLEX_QOS_EGR_PHB_11s, /* FLEX_QOS_EGR_PHB_11 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_11_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_11 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_2.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_2_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_2_t = {
    .name = FLEX_QOS_EGR_PHB_2s, /* FLEX_QOS_EGR_PHB_2 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_2_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_2 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_3.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_3_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_3_t = {
    .name = FLEX_QOS_EGR_PHB_3s, /* FLEX_QOS_EGR_PHB_3 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_3_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_3 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_4_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_4_t = {
    .name = FLEX_QOS_EGR_PHB_4s, /* FLEX_QOS_EGR_PHB_4 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_4_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_4 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_5.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_5_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_5_t = {
    .name = FLEX_QOS_EGR_PHB_5s, /* FLEX_QOS_EGR_PHB_5 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_5_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_5 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_6_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_6_t = {
    .name = FLEX_QOS_EGR_PHB_6s, /* FLEX_QOS_EGR_PHB_6 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_6_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_6 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_7.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_7_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_7_t = {
    .name = FLEX_QOS_EGR_PHB_7s, /* FLEX_QOS_EGR_PHB_7 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_7_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_7 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_8.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_8_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_8_t = {
    .name = FLEX_QOS_EGR_PHB_8s, /* FLEX_QOS_EGR_PHB_8 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_8_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_8 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_PHB_9.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_phb_9_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = QOS_FIELDs,  /* QOS_FIELD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "QoS field value of the outgoing packet.",
    },
    {
        .name  = PKT_DROPs,  /* PKT_DROP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_phb_9_t = {
    .name = FLEX_QOS_EGR_PHB_9s, /* FLEX_QOS_EGR_PHB_9 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_qos_egr_phb_9_t_fields,
    .desc = "The FLEX_QOS_EGR_PHB_9 table is used to derive the outgoing packet's\n  QoS field based on internal PHB attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_EGR_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_egr_policy_t_fields[] = {
    {
        .name  = FLEX_QOS_EGR_POLICY_IDs,  /* FLEX_QOS_EGR_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into FLEX_QOS_EGR_POLICY table.",
    },
    {
        .name  = EGR_QOS_TABLE_0_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_0_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 0.",
    },
    {
        .name  = EGR_QOS_TABLE_0_BASE_INDEXs,  /* EGR_QOS_TABLE_0_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 0 if hits.",
    },
    {
        .name  = EGR_QOS_TABLE_1_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_1_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 1.",
    },
    {
        .name  = EGR_QOS_TABLE_1_BASE_INDEXs,  /* EGR_QOS_TABLE_1_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 1 if hits.",
    },
    {
        .name  = EGR_QOS_TABLE_2_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_2_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 2.",
    },
    {
        .name  = EGR_QOS_TABLE_2_BASE_INDEXs,  /* EGR_QOS_TABLE_2_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 2 if hits.",
    },
    {
        .name  = EGR_QOS_TABLE_3_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_3_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 3.",
    },
    {
        .name  = EGR_QOS_TABLE_3_BASE_INDEXs,  /* EGR_QOS_TABLE_3_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 3 if hits.",
    },
    {
        .name  = EGR_QOS_TABLE_4_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_4_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 4.",
    },
    {
        .name  = EGR_QOS_TABLE_4_BASE_INDEXs,  /* EGR_QOS_TABLE_4_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 4 if hits.",
    },
    {
        .name  = EGR_QOS_TABLE_5_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_5_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 5.",
    },
    {
        .name  = EGR_QOS_TABLE_5_BASE_INDEXs,  /* EGR_QOS_TABLE_5_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 5 if hits.",
    },
    {
        .name  = EGR_QOS_TABLE_6_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_6_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 6.",
    },
    {
        .name  = EGR_QOS_TABLE_6_BASE_INDEXs,  /* EGR_QOS_TABLE_6_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 6 if hits.",
    },
    {
        .name  = EGR_QOS_TABLE_7_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_7_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 7.",
    },
    {
        .name  = EGR_QOS_TABLE_7_BASE_INDEXs,  /* EGR_QOS_TABLE_7_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 7 if hits.",
    },
    {
        .name  = EGR_QOS_TABLE_8_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_8_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 8.",
    },
    {
        .name  = EGR_QOS_TABLE_8_BASE_INDEXs,  /* EGR_QOS_TABLE_8_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 8 if hits.",
    },
    {
        .name  = EGR_QOS_TABLE_9_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_9_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 9.",
    },
    {
        .name  = EGR_QOS_TABLE_9_BASE_INDEXs,  /* EGR_QOS_TABLE_9_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 9 if hits.",
    },
    {
        .name  = EGR_QOS_TABLE_10_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_10_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 10.",
    },
    {
        .name  = EGR_QOS_TABLE_10_BASE_INDEXs,  /* EGR_QOS_TABLE_10_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 10 if hits.",
    },
    {
        .name  = EGR_QOS_TABLE_11_BASE_INDEX_SRCs,  /* EGR_QOS_TABLE_11_BASE_INDEX_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source of base index for QoS table 11.",
    },
    {
        .name  = EGR_QOS_TABLE_11_BASE_INDEXs,  /* EGR_QOS_TABLE_11_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default base index for QoS table 11 if hits.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_egr_policy_t = {
    .name = FLEX_QOS_EGR_POLICYs, /* FLEX_QOS_EGR_POLICY */
    .flags = 0,
    .fields = 25,
    .field = bcmltd_flex_qos_egr_policy_t_fields,
    .desc = "The FLEX_QOS_EGR_POLICY table is used to map each\n  hardware remark table to source of base_index.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_ING_ECN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_ing_ecn_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = INT_ECN_CNGs,  /* INT_ECN_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Internal congestion notification value.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_ing_ecn_t = {
    .name = FLEX_QOS_ING_ECNs, /* FLEX_QOS_ING_ECN */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_flex_qos_ing_ecn_t_fields,
    .desc = "The FLEX_QOS_ING_ECN table is used to derive internal\n  congestion notification value from the ECN field of incoming packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_ING_PHB.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_ing_phb_t_fields[] = {
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Absolute index into map table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the incoming packet.",
    },
    {
        .name  = INT_CNGs,  /* INT_CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Internal color/drop precedence of the incoming packet.",
    },
    {
        .name  = DSCP_VALIDs,  /* DSCP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the MAPPED_DSCP value is valid.",
    },
    {
        .name  = MAPPED_DSCPs,  /* MAPPED_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Mapped DSCP value for the packet.\n Applicable only when DSCP_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_ing_phb_t = {
    .name = FLEX_QOS_ING_PHBs, /* FLEX_QOS_ING_PHB */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_flex_qos_ing_phb_t_fields,
    .desc = "The FLEX_QOS_ING_PHB table is used to derive internal PHB\n  properties from the QoS field of incoming packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_ING_PHB_INT_CNG_STRENGTH_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_ing_phb_int_cng_strength_profile_t_fields[] = {
    {
        .name  = FLEX_QOS_ING_PHB_INT_CNG_STRENGTH_PROFILE_IDs,  /* FLEX_QOS_ING_PHB_INT_CNG_STRENGTH_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into FLEX_QOS_ING_PHB_INT_CNG_STRENGTH_PROFILE table.",
    },
    {
        .name  = MAPPED_VALUE_STRENGTHs,  /* MAPPED_VALUE_STRENGTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mapped value strength.",
    },
    {
        .name  = POLICY_VALUE_STRENGTHs,  /* POLICY_VALUE_STRENGTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Policy value strength.",
    },
    {
        .name  = BUS_VALUE_STRENGTHs,  /* BUS_VALUE_STRENGTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Bus value strength.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_ing_phb_int_cng_strength_profile_t = {
    .name = FLEX_QOS_ING_PHB_INT_CNG_STRENGTH_PROFILEs, /* FLEX_QOS_ING_PHB_INT_CNG_STRENGTH_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_flex_qos_ing_phb_int_cng_strength_profile_t_fields,
    .desc = "The FLEX_QOS_ING_PHB_INT_CNG_STRENGTH_PROFILE table is used to configure\n  strength value for derived CNG from a specific packet flow.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_ING_PHB_INT_PRI_STRENGTH_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_ing_phb_int_pri_strength_profile_t_fields[] = {
    {
        .name  = FLEX_QOS_ING_PHB_INT_PRI_STRENGTH_PROFILE_IDs,  /* FLEX_QOS_ING_PHB_INT_PRI_STRENGTH_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into FLEX_QOS_ING_PHB_INT_PRI_STRENGTH_PROFILE table.",
    },
    {
        .name  = MAPPED_VALUE_STRENGTHs,  /* MAPPED_VALUE_STRENGTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mapped value strength.",
    },
    {
        .name  = POLICY_VALUE_STRENGTHs,  /* POLICY_VALUE_STRENGTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Policy value strength.",
    },
    {
        .name  = BUS_VALUE_STRENGTHs,  /* BUS_VALUE_STRENGTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Bus value strength.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_ing_phb_int_pri_strength_profile_t = {
    .name = FLEX_QOS_ING_PHB_INT_PRI_STRENGTH_PROFILEs, /* FLEX_QOS_ING_PHB_INT_PRI_STRENGTH_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_flex_qos_ing_phb_int_pri_strength_profile_t_fields,
    .desc = "The FLEX_QOS_ING_PHB_INT_PRI_STRENGTH_PROFILE table is used to configure\n  strength value for derived INT_PRI from a specific packet flow.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_qos/FLEX_QOS_ING_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_qos_ing_policy_t_fields[] = {
    {
        .name  = FLEX_QOS_ING_POLICY_IDs,  /* FLEX_QOS_ING_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into FLEX_QOS_ING_POLICY table.",
    },
    {
        .name  = FLEX_QOS_ING_PHB_INT_PRI_STRENGTH_PROFILE_IDs,  /* FLEX_QOS_ING_PHB_INT_PRI_STRENGTH_PROFILE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Strength profile ID for INT_PRI.",
    },
    {
        .name  = FLEX_QOS_ING_PHB_INT_CNG_STRENGTH_PROFILE_IDs,  /* FLEX_QOS_ING_PHB_INT_CNG_STRENGTH_PROFILE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Strength profile ID for INT_CNG.",
    },
    {
        .name  = INT_CN_MAPPING_PTRs,  /* INT_CN_MAPPING_PTR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mapping pointer for INT_CN.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Directly assigned INT_PRI without strength comparison.",
    },
    {
        .name  = INT_CNGs,  /* INT_CNG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Directly assigned CNG without strength comparison.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_qos_ing_policy_t = {
    .name = FLEX_QOS_ING_POLICYs, /* FLEX_QOS_ING_POLICY */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_flex_qos_ing_policy_t_fields,
    .desc = "The FLEX_QOS_ING_POLICY table is used to select\n  strength profile for both INT_PRI and CNG per policy.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_1_BITP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_1_bitp_profile_t_fields[] = {
    {
        .name  = MUX0_SIZE0_SEL_0s,  /* MUX0_SIZE0_SEL_0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 0 offset.",
    },
    {
        .name  = MUX0_SIZE0_SEL_1s,  /* MUX0_SIZE0_SEL_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 1 offset.",
    },
    {
        .name  = MUX0_SIZE0_SEL_2s,  /* MUX0_SIZE0_SEL_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 2 offset.",
    },
    {
        .name  = MUX0_MASKs,  /* MUX0_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Bus object mask.",
    },
    {
        .name  = MUX_ENABLEs,  /* MUX_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mux selection logic.",
    },
    {
        .name  = MIRROR_COPY_VALUEs,  /* MIRROR_COPY_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to determine if packet is mirror-copy.",
    },
    {
        .name  = MIRROR_COPY_MASKs,  /* MIRROR_COPY_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask to determine if packet is mirror-copy.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_1_bitp_profile_t = {
    .name = FLEX_STATE_EGR_1_BITP_PROFILEs, /* FLEX_STATE_EGR_1_BITP_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_flex_state_egr_1_bitp_profile_t_fields,
    .desc = "The FLEX_STATE_EGR_1_BITP_PROFILE table is used to specify\n egress flex state instance 1 attributes to determine if packet is mirror-copy\n and if it should be counted.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_ACTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_action_profile_t_fields[] = {
    {
        .name  = FLEX_STATE_EGR_ACTION_PROFILE_IDs,  /* FLEX_STATE_EGR_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_EGR_ACTION_PROFILE table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enhanced flex state action.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state egress instance.",
    },
    {
        .name  = POOL_IDs,  /* POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting counter block.\n The block may spill over into the adjacent pool(s).\n",
    },
    {
        .name  = BASE_INDEX_AUTOs,  /* BASE_INDEX_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if the base index value should be calculated using\n internal logic.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Base index in the first pool.\n Applicable only if BASE_INDEX_AUTO is disabled.\n",
    },
    {
        .name  = BASE_INDEX_OPERs,  /* BASE_INDEX_OPER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Computed value of BASE_INDEX.\n Applicable only if BASE_INDEX_AUTO is enabled.\n",
    },
    {
        .name  = SHADOWs,  /* SHADOW */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if atomic snapshot of flex counters should be collected.",
    },
    {
        .name  = NUM_COUNTERSs,  /* NUM_COUNTERS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of flex counters requested.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state mode.\n The specified counter mode may impact the number\n of available counters for this entry.\n",
    },
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .desc = "Selected objects to calculate counter index and values.",
    },
    {
        .name  = INDEX_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,  /* INDEX_FLEX_STATE_EGR_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The index of the entry in FLEX_STATE_EGR_OPERAND_PROFILE table.\n This entry determines how the index of this counter is computed.\n",
    },
    {
        .name  = INDEX_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_IDs,  /* INDEX_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The index of the entry in FLEX_STATE_EGR_OPERAND_PROFILE table.\n This entry determines how the index of this counter is computed.\n",
    },
    {
        .name  = INDEX_FLEX_STATE_EGR_SM_OPERAND_PROFILE_IDs,  /* INDEX_FLEX_STATE_EGR_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The index of the entry in FLEX_STATE_EGR_OPERAND_PROFILE table.\n This entry determines how the index of this counter is computed.\n",
    },
    {
        .name  = UPDATE_COMPARE_As,  /* UPDATE_COMPARE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Comparison operation to be performed on stored value of\n counter A for conditional update.\n Applicable only if MODE == NORMAL.\n",
    },
    {
        .name  = VAL_A_COMP_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,  /* VAL_A_COMP_FLEX_STATE_EGR_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter A value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_A.\n",
    },
    {
        .name  = VAL_A_COMP_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_IDs,  /* VAL_A_COMP_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter A value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_A.\n",
    },
    {
        .name  = VAL_A_COMP_FLEX_STATE_EGR_SM_OPERAND_PROFILE_IDs,  /* VAL_A_COMP_FLEX_STATE_EGR_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter A value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_A.\n",
    },
    {
        .name  = CTR_SRC_COMP_As,  /* CTR_SRC_COMP_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter A\n conditional update comparison.\n",
    },
    {
        .name  = TRUE_UPDATE_MODE_As,  /* TRUE_UPDATE_MODE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state A update mode if UPDATE_COMPARE_A returns TRUE.\n The supported modes may be dependent on the value\n specified in the MODE field.\n",
    },
    {
        .name  = VAL_A_UPD_TRUE_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_TRUE_FLEX_STATE_EGR_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_A.\n",
    },
    {
        .name  = VAL_A_UPD_TRUE_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_TRUE_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_A.\n",
    },
    {
        .name  = VAL_A_UPD_TRUE_FLEX_STATE_EGR_SM_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_TRUE_FLEX_STATE_EGR_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_A.\n",
    },
    {
        .name  = CTR_SRC_UPD_TRUE_As,  /* CTR_SRC_UPD_TRUE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter A\n conditional update if UPDATE_COMPARE_A returns TRUE.\n",
    },
    {
        .name  = FALSE_UPDATE_MODE_As,  /* FALSE_UPDATE_MODE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state A update mode if UPDATE_COMPARE_A returns FALSE.\n The supported modes may be dependent on the value\n specified in the MODE field.\n",
    },
    {
        .name  = VAL_A_UPD_FALSE_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_FALSE_FLEX_STATE_EGR_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_A.\n",
    },
    {
        .name  = VAL_A_UPD_FALSE_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_FALSE_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_A.\n",
    },
    {
        .name  = VAL_A_UPD_FALSE_FLEX_STATE_EGR_SM_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_FALSE_FLEX_STATE_EGR_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_A.\n",
    },
    {
        .name  = CTR_SRC_UPD_FALSE_As,  /* CTR_SRC_UPD_FALSE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter A\n conditional update if UPDATE_COMPARE_A returns FALSE.\n",
    },
    {
        .name  = UPDATE_COMPARE_Bs,  /* UPDATE_COMPARE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Comparison operation to be performed on stored value of\n counter B for conditional update.\n Applicable only if MODE == NORMAL.\n",
    },
    {
        .name  = VAL_B_COMP_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,  /* VAL_B_COMP_FLEX_STATE_EGR_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter B value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_B.\n",
    },
    {
        .name  = VAL_B_COMP_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_IDs,  /* VAL_B_COMP_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter B value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_B.\n",
    },
    {
        .name  = VAL_B_COMP_FLEX_STATE_EGR_SM_OPERAND_PROFILE_IDs,  /* VAL_B_COMP_FLEX_STATE_EGR_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter B value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_B.\n",
    },
    {
        .name  = CTR_SRC_COMP_Bs,  /* CTR_SRC_COMP_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter B\n conditional update comparison.\n",
    },
    {
        .name  = TRUE_UPDATE_MODE_Bs,  /* TRUE_UPDATE_MODE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state B update mode if UPDATE_COMPARE_B returns TRUE.\n The supported modes may be dependent on the value\n specified in the MODE field.\n",
    },
    {
        .name  = VAL_B_UPD_TRUE_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_TRUE_FLEX_STATE_EGR_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_B.\n",
    },
    {
        .name  = VAL_B_UPD_TRUE_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_TRUE_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_B.\n",
    },
    {
        .name  = VAL_B_UPD_TRUE_FLEX_STATE_EGR_SM_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_TRUE_FLEX_STATE_EGR_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_B.\n",
    },
    {
        .name  = CTR_SRC_UPD_TRUE_Bs,  /* CTR_SRC_UPD_TRUE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter B\n conditional update if UPDATE_COMPARE_B returns TRUE.\n",
    },
    {
        .name  = FALSE_UPDATE_MODE_Bs,  /* FALSE_UPDATE_MODE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state B update mode if UPDATE_COMPARE_B returns FALSE.\n The supported modes may be dependent on the value\n specified in the MODE field.\n",
    },
    {
        .name  = VAL_B_UPD_FALSE_FLEX_STATE_EGR_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_FALSE_FLEX_STATE_EGR_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_B.\n",
    },
    {
        .name  = VAL_B_UPD_FALSE_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_FALSE_FLEX_STATE_EGR_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_B.\n",
    },
    {
        .name  = VAL_B_UPD_FALSE_FLEX_STATE_EGR_SM_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_FALSE_FLEX_STATE_EGR_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_B.\n",
    },
    {
        .name  = CTR_SRC_UPD_FALSE_Bs,  /* CTR_SRC_UPD_FALSE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter B\n conditional update if UPDATE_COMPARE_B returns FALSE.\n",
    },
    {
        .name  = VAL_A_MEM_UPDATEs,  /* VAL_A_MEM_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the source of memory update for\n Counter A.\n",
    },
    {
        .name  = VAL_B_MEM_UPDATEs,  /* VAL_B_MEM_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the source of memory update for\n Counter B.\n",
    },
    {
        .name  = VAL_A_BUS_UPDATEs,  /* VAL_A_BUS_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the source of bus update for\n counter A.\n",
    },
    {
        .name  = VAL_B_BUS_UPDATEs,  /* VAL_B_BUS_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the source of bus update\n for counter B.\n",
    },
    {
        .name  = TRUTH_TABLE_ENs,  /* TRUTH_TABLE_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable truth table lookup for the action.",
    },
    {
        .name  = TRUTH_TABLE_INSTANCEs,  /* TRUTH_TABLE_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Truth table instance to be used for this action.",
    },
    {
        .name  = COUNT_ON_RULE_DROPs,  /* COUNT_ON_RULE_DROP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_DROP_COUNT_MODE_T_DATA,
        .desc = "Counter drop mode specifies if counter should\n be updated based on functional packet drops.\n",
    },
    {
        .name  = COUNT_ON_HW_EXCP_DROPs,  /* COUNT_ON_HW_EXCP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count on hardware exception drops.",
    },
    {
        .name  = COUNT_ON_MIRRORs,  /* COUNT_ON_MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count egress mirrored packets also.\n Non-mirrored packets are always counted.\n",
    },
    {
        .name  = CTR_VAL_DATAs,  /* CTR_VAL_DATA */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Additional input used for special functions that calculate\n both counter A and B values.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_action_profile_t = {
    .name = FLEX_STATE_EGR_ACTION_PROFILEs, /* FLEX_STATE_EGR_ACTION_PROFILE */
    .flags = 0,
    .fields = 55,
    .field = bcmltd_flex_state_egr_action_profile_t_fields,
    .desc = "The FLEX_STATE_EGR_ACTION_PROFILE logical table specifies the\n egress enhanced flex state action ID profile configuration.\n\n The following conditional update logic is applicable only if\n MODE == NORMAL.\n There are 3 values per counter (A or B) that can be calculated.\n These values are marked as compare_value, update_value_true and\n update_value_false.\n They are calculated based on FLEX_STATE_EGR_OPERAND_PROFILE entry.\n\n If UPDATE_COMPARE_x(stored_value, compare_value) returns true\n    where stored_value is current value of counter A or B.\n\n    where UPDATE_COMPARE_x function can be any of the following:\n          - TRUE\n          - EQUAL\n          - LESS_THAN (i.e. stored_value < compare_value)\n\n    where compare_value == value calculated by the entry indexed by\n          VAL_x_COMP_FLEX_STATE_EGR_OPERAND_PROFILE_ID of the table\n          FLEX_STATE_EGR_OPERAND_PROFILE and x is in {A, B}\n          It may be overidden by CTR_SRC_COMP_x.\n\n Then\n    new_state_x = TRUE_UPDATE_MODE_x(stored_value, update_value_true)\n    where update_value_true == value calculated by the entry indexed by\n          VAL_x_UPD_TRUE_FLEX_STATE_EGR_OPERAND_PROFILE_ID of the table\n          FLEX_STATE_EGR_OPERAND_PROFILE and x is in {A, B}\n          It may be overidden by CTR_SRC_UPD_TRUE_x.\n\n Else\n    new_state_x = FALSE_UPDATE_MODE_x(stored_value, update_value_false)\n    where update_value_true == value calculated by the entry indexed by\n          VAL_x_UPD_FALSE_FLEX_STATE_EGR_OPERAND_PROFILE_ID of the table\n          FLEX_STATE_EGR_OPERAND_PROFILE and x is in {A, B}\n          It may be overidden by CTR_SRC_UPD_FALSE_x.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_ACTION_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_action_profile_info_t_fields[] = {
    {
        .name  = FLEX_STATE_EGR_ACTION_PROFILE_IDs,  /* FLEX_STATE_EGR_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_EGR_ACTION_PROFILE table.",
    },
    {
        .name  = POOL_IDs,  /* POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting counter block.",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Base index in the first pool.",
    },
    {
        .name  = NUM_POOLSs,  /* NUM_POOLS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of flex state pools allocated.",
    },
    {
        .name  = TOP_INDEXs,  /* TOP_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Last index within the last pool ID of\n FLEX_STATE_EGR_ACTION_PROFILE.POOL_ID + (NUM_POOLS - 1)\n for the specified FLEX_STATE_EGR_ACTION_PROFILE.NUM_COUNTERS.\n",
    },
    {
        .name  = SHADOW_VALIDs,  /* SHADOW_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that shadow pools are configured.",
    },
    {
        .name  = SHADOW_POOL_IDs,  /* SHADOW_POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting shadow counter block.\n\n Applicable only if SHADOW_VALID == TRUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_action_profile_info_t = {
    .name = FLEX_STATE_EGR_ACTION_PROFILE_INFOs, /* FLEX_STATE_EGR_ACTION_PROFILE_INFO */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_flex_state_egr_action_profile_info_t_fields,
    .desc = "The FLEX_STATE_EGR_ACTION_PROFILE_INFO logical table provides\n information about the current egress enhanced flex state action ID\n profile configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_BITP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_bitp_profile_t_fields[] = {
    {
        .name  = MUX0_SIZE0_SEL_0s,  /* MUX0_SIZE0_SEL_0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 0 offset.",
    },
    {
        .name  = MUX0_SIZE0_SEL_1s,  /* MUX0_SIZE0_SEL_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 1 offset.",
    },
    {
        .name  = MUX0_SIZE0_SEL_2s,  /* MUX0_SIZE0_SEL_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 2 offset.",
    },
    {
        .name  = MUX0_MASKs,  /* MUX0_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Bus object mask.",
    },
    {
        .name  = MUX_ENABLEs,  /* MUX_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mux selection logic.",
    },
    {
        .name  = MIRROR_COPY_VALUEs,  /* MIRROR_COPY_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to determine if packet is mirror-copy.",
    },
    {
        .name  = MIRROR_COPY_MASKs,  /* MIRROR_COPY_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask to determine if packet is mirror-copy.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_bitp_profile_t = {
    .name = FLEX_STATE_EGR_BITP_PROFILEs, /* FLEX_STATE_EGR_BITP_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_flex_state_egr_bitp_profile_t_fields,
    .desc = "The FLEX_STATE_EGR_BITP_PROFILE table is used to specify\n egress flex state instance 0 attributes to determine if packet is mirror-copy\n and should be counted.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_ERROR_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_error_stats_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state instance.",
    },
    {
        .name  = ACTION_MISCONFIGs,  /* ACTION_MISCONFIG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Error counter incremented when multiple flex state actions\n are directed to the same counter pool.\n",
    },
    {
        .name  = TOO_MANY_ACTIONSs,  /* TOO_MANY_ACTIONS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Error counter incremented when more than a specified number of\n flex state actions are generated for the same packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_error_stats_t = {
    .name = FLEX_STATE_EGR_ERROR_STATSs, /* FLEX_STATE_EGR_ERROR_STATS */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_flex_state_egr_error_stats_t_fields,
    .desc = "The FLEX_STATE_EGR_ERROR_STATS table specifies the error counters\n present in the egress enhanced flex state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_GROUP_ACTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_group_action_profile_t_fields[] = {
    {
        .name  = FLEX_STATE_EGR_GROUP_ACTION_PROFILE_IDs,  /* FLEX_STATE_EGR_GROUP_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_EGR_GROUP_ACTION_PROFILE table.",
    },
    {
        .name  = GROUPs,  /* GROUP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enhanced flex state action group.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state instance.",
    },
    {
        .name  = FLEX_STATE_EGR_ACTION_PROFILE_IDs,  /* FLEX_STATE_EGR_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_EGR_ACTION_PROFILE table index which\n represents the group action profile ID.\n",
    },
    {
        .name  = GROUP_MAPs,  /* GROUP_MAP */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "Action profile IDs associated with the group action.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_STATE_T_DATA,
        .desc = "Read-only field which reflects the group action operational state.\n The operational state indicates ACTIVE once all\n FLEX_STATE_EGR_ACTION_PROFILE entries associated with the group\n have been inserted. It may be updated based on the changes to the\n FLEX_STATE_EGR_ACTION_PROFILE table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_group_action_profile_t = {
    .name = FLEX_STATE_EGR_GROUP_ACTION_PROFILEs, /* FLEX_STATE_EGR_GROUP_ACTION_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_flex_state_egr_group_action_profile_t_fields,
    .desc = "The FLEX_STATE_EGR_GROUP_ACTION_PROFILE logical table specifies the\n egress enhanced flex state group action ID profile configuration.\n\n It allows a single action, indicated by\n INDEX_FLEX_STATE_EGR_ACTION_PROFILE_ID, to trigger all the actions\n within the group, indicated by the GROUP_MAP array.\n\n If group state action is applied, its associated state actions\n are selected for counter processing.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_OBJ_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_obj_info_t_fields[] = {
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Egress flex state object.",
    },
    {
        .name  = MIN_BITs,  /* MIN_BIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Starting offset of the flex state object.",
    },
    {
        .name  = MAX_BITs,  /* MAX_BIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ending offset of the flex state object.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_obj_info_t = {
    .name = FLEX_STATE_EGR_OBJ_INFOs, /* FLEX_STATE_EGR_OBJ_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_state_egr_obj_info_t_fields,
    .desc = "The FLEX_STATE_EGR_OBJ_INFO logical table provides information\n about the egress enhanced flex state object bit offsets in the object bus.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_OBJ_QUANTIZATION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_obj_quantization_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state instance.",
    },
    {
        .name  = QUANTIZEs,  /* QUANTIZE */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable to set object quantization.",
    },
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .desc = "Objects selected for range check quantization .",
    },
    {
        .name  = OBJ_0_1_MODEs,  /* OBJ_0_1_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use 32-bit mode where quantized results\n of objects 0 and 1 are concatenated and assigned to\n object 0. Object 1 is unchanged.\n",
    },
    {
        .name  = OBJ_2_3_MODEs,  /* OBJ_2_3_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use 32-bit mode where quantized results\n of objects 2 and 3 are concatenated and assigned to\n object 2. Object 3 is unchanged.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_obj_quantization_t = {
    .name = FLEX_STATE_EGR_OBJ_QUANTIZATIONs, /* FLEX_STATE_EGR_OBJ_QUANTIZATION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_flex_state_egr_obj_quantization_t_fields,
    .desc = "The FLEX_STATE_EGR_OBJ_QUANTIZATION table configures the egress\n object quantization controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_OPERAND_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_operand_profile_t_fields[] = {
    {
        .name  = FLEX_STATE_EGR_OPERAND_PROFILE_IDs,  /* FLEX_STATE_EGR_OPERAND_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the flex state egress operand profile table.",
    },
    {
        .name  = PROFILEs,  /* PROFILE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Flex state egress operand profile index.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state instance.",
    },
    {
        .name  = OBJ_1s,  /* OBJ_1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 1 selection result.",
    },
    {
        .name  = OBJ_2s,  /* OBJ_2 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 2 selection result.",
    },
    {
        .name  = OBJ_3s,  /* OBJ_3 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 2 selection result.",
    },
    {
        .name  = MASK_SIZE_1s,  /* MASK_SIZE_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 1.",
    },
    {
        .name  = MASK_SIZE_2s,  /* MASK_SIZE_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 2.",
    },
    {
        .name  = MASK_SIZE_3s,  /* MASK_SIZE_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 2.",
    },
    {
        .name  = SHIFT_1s,  /* SHIFT_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift amount for object 1.",
    },
    {
        .name  = SHIFT_2s,  /* SHIFT_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Left shift amount for object 2.",
    },
    {
        .name  = SHIFT_3s,  /* SHIFT_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Left shift amount for object 2.",
    },
    {
        .name  = SHIFT_4s,  /* SHIFT_4 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Left shift amount for object 2.",
    },
    {
        .name  = SHIFT_5s,  /* SHIFT_5 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Left shift amount for object 2.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_operand_profile_t = {
    .name = FLEX_STATE_EGR_OPERAND_PROFILEs, /* FLEX_STATE_EGR_OPERAND_PROFILE */
    .flags = 0,
    .fields = 15,
    .field = bcmltd_flex_state_egr_operand_profile_t_fields,
    .desc = "The FLEX_STATE_EGR_OPERAND_PROFILE table determines how egress\n enhanced flex state values A, B or counter index are computed.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_OPERAND_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_operand_profile_info_t_fields[] = {
    {
        .name  = FLEX_STATE_EGR_OPERAND_PROFILE_IDs,  /* FLEX_STATE_EGR_OPERAND_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_EGR_OPERAND_PROFILE table.",
    },
    {
        .name  = PROFILEs,  /* PROFILE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Flex state egress operand profile index.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_operand_profile_info_t = {
    .name = FLEX_STATE_EGR_OPERAND_PROFILE_INFOs, /* FLEX_STATE_EGR_OPERAND_PROFILE_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_flex_state_egr_operand_profile_info_t_fields,
    .desc = "The FLEX_STATE_EGR_OPERAND_PROFILE_INFO logical table provides information\n about the current egress enhanced flex state operand profile\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_POOL_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_pool_info_t_fields[] = {
    {
        .name  = FLEX_STATE_EGR_POOL_INFO_IDs,  /* FLEX_STATE_EGR_POOL_INFO_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_EGR_POOL_INFO table.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state instance.",
    },
    {
        .name  = POOL_SIZEs,  /* POOL_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Indicates the number of counters in the pool.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_pool_info_t = {
    .name = FLEX_STATE_EGR_POOL_INFOs, /* FLEX_STATE_EGR_POOL_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_state_egr_pool_info_t_fields,
    .desc = "The FLEX_STATE_EGR_POOL_INFO table provides egress\n enhanced flex state pool information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_RANGE_CHK_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_range_chk_profile_t_fields[] = {
    {
        .name  = FLEX_STATE_EGR_RANGE_CHK_PROFILE_IDs,  /* FLEX_STATE_EGR_RANGE_CHK_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_EGR_RANGE_CHK_PROFILE table.",
    },
    {
        .name  = OBJ_SELECTs,  /* OBJ_SELECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Object whose value is to be range checked.",
    },
    {
        .name  = RANGE_CHECKERs,  /* RANGE_CHECKER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Range checker number.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state instance.",
    },
    {
        .name  = MINs,  /* MIN */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Minimum value for range checker.",
    },
    {
        .name  = MAXs,  /* MAX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum value for range checker.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_range_chk_profile_t = {
    .name = FLEX_STATE_EGR_RANGE_CHK_PROFILEs, /* FLEX_STATE_EGR_RANGE_CHK_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_flex_state_egr_range_chk_profile_t_fields,
    .desc = "The FLEX_STATE_EGR_RANGE_CHK_PROFILE table configures the egress\n flex state object quantization range checkers with min and max values.\n\n Each range checker determines if the corresponding object value\n is within the min and max range.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_RANGE_CHK_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_range_chk_profile_info_t_fields[] = {
    {
        .name  = FLEX_STATE_EGR_RANGE_CHK_PROFILE_IDs,  /* FLEX_STATE_EGR_RANGE_CHK_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_EGR_RANGE_CHK_PROFILE table.",
    },
    {
        .name  = OBJ_SELECTs,  /* OBJ_SELECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Object whose value is to be range checked.",
    },
    {
        .name  = RANGE_CHECKERs,  /* RANGE_CHECKER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Range checker number.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_range_chk_profile_info_t = {
    .name = FLEX_STATE_EGR_RANGE_CHK_PROFILE_INFOs, /* FLEX_STATE_EGR_RANGE_CHK_PROFILE_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_state_egr_range_chk_profile_info_t_fields,
    .desc = "The FLEX_STATE_EGR_RANGE_CHK_PROFILE_INFO logical table provides information\n about the current egress enhanced flex state range checker profile\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_stats_t_fields[] = {
    {
        .name  = FLEX_STATE_EGR_ACTION_PROFILE_IDs,  /* FLEX_STATE_EGR_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_EGR_ACTION_PROFILE table.",
    },
    {
        .name  = CTR_EFLEX_INDEXs,  /* CTR_EFLEX_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Counter index.",
    },
    {
        .name  = CTR_A_UPPERs,  /* CTR_A_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value A. The applicability of this field is\n dependent on the counter width value specified in\n FLEX_STATE_EGR_ACTION_PROFILE.MODE field.\n",
    },
    {
        .name  = CTR_A_LOWERs,  /* CTR_A_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value A. The applicability of this field is\n dependent on the counter width value specified in\n FLEX_STATE_EGR_ACTION_PROFILE.MODE field.\n",
    },
    {
        .name  = CTR_Bs,  /* CTR_B */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value B. The applicability of this field is\n dependent on the counter width value specified in\n FLEX_STATE_EGR_ACTION_PROFILE.MODE field.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_stats_t = {
    .name = FLEX_STATE_EGR_STATSs, /* FLEX_STATE_EGR_STATS */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_flex_state_egr_stats_t_fields,
    .desc = "The FLEX_STATE_EGR_STATS table is used to retrieve the\n the egress enhanced flex state counter A and B values.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_TRIGGER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_trigger_t_fields[] = {
    {
        .name  = FLEX_STATE_EGR_ACTION_PROFILE_IDs,  /* FLEX_STATE_EGR_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_EGR_ACTION_PROFILE table.",
    },
    {
        .name  = TRIGGERs,  /* TRIGGER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update counter based on trigger condition.\n Disable to always update counter.\n",
    },
    {
        .name  = STARTs,  /* START */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_START_TRIGGER_T_DATA,
        .desc = "Start trigger type.",
    },
    {
        .name  = STOPs,  /* STOP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Stop trigger type.",
    },
    {
        .name  = START_VALUEs,  /* START_VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Start value which will trigger counter update,\n when the following condition is met:\n STATE_EEGR_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK == START_VALUE\n if COMPARE_START == 0.\n STATE_EGR_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK != START_VALUE\n if COMPARE_START == 1.\n Applicable only if START == CONDITION.\n",
    },
    {
        .name  = STOP_VALUEs,  /* STOP_VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Stop value which will stop counter update,.\n when the following condition is met:\n STATE_EGR_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK == START_VALUE\n if COMPARE_STOP == 0.\n STATE_EGR_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK != START_VALUE\n if COMPARE_STOP == 1.\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = COND_MASKs,  /* COND_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask value applied to start or stop value to select\n desired attributes.\n Applicable if START == CONDITION or STOP == CONDITION.\n",
    },
    {
        .name  = START_TIME_OFFSETs,  /* START_TIME_OFFSET */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Time offset from current time in nanoseconds\n to trigger counter update.\n Applicable only if START == TIME.\n",
    },
    {
        .name  = NUM_PERIODs,  /* NUM_PERIOD */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The number of periods to measure before stopping.\n If set to 0, then the number of periods is infinite.\n To disable the trigger in this case,\n set NUM_PERIOD to non-zero value and enable TRIGGER.\n Applicable only if STOP == PERIOD.\n",
    },
    {
        .name  = NUM_ACTIONSs,  /* NUM_ACTIONS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = COMPARE_STARTs,  /* COMPARE_START */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If disabled then == is used as the compare function\n to trigger start counter update.\n If enabled then != is used as the compare function\n to trigger start  counter update.\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = COMPARE_STOPs,  /* COMPARE_STOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If disabled then == is used as the compare function\n to trigger stop counter update.\n If enabled then != is used as the compare function\n to trigger stop  counter update.\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = SCALEs,  /* SCALE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Duration of a single time period.\n Applicable only if STOP == PERIOD.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_STATE_T_DATA,
        .desc = "Read-only field which reflects the trigger operational state.\n The operational state indicates ACTIVE once a\n FLEX_STATE_EGR_ACTION_PROFILE entry has been inserted.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_trigger_t = {
    .name = FLEX_STATE_EGR_TRIGGERs, /* FLEX_STATE_EGR_TRIGGER */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_flex_state_egr_trigger_t_fields,
    .desc = "The FLEX_STATE_EGR_TRIGGER table configures the trigger function to\n enable conditional updates on egress enhanced flex state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_EGR_TRUTH_TABLE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_egr_truth_table_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = POOLs,  /* POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Indicates the  pool  associated with the entry.",
    },
    {
        .name  = TRUTH_TABLE_INSTANCEs,  /* TRUTH_TABLE_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Indicates the  truth table instance associated\n with this entry.\n Each pool has 4 instances of truth table.\n",
    },
    {
        .name  = INDEXs,  /* INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Indicates the truth table index associated\n with this entry.\n",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state instance.",
    },
    {
        .name  = OUTPUTs,  /* OUTPUT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Flex state output sent to the bus.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_egr_truth_table_t = {
    .name = FLEX_STATE_EGR_TRUTH_TABLEs, /* FLEX_STATE_EGR_TRUTH_TABLE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_flex_state_egr_truth_table_t_fields,
    .desc = "The FLEX_STATE_EGR_TRUTH_TABLE table provides  egress\n enhanced flex truth table configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_1_BITP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_1_bitp_profile_t_fields[] = {
    {
        .name  = MUX0_SIZE0_SEL_0s,  /* MUX0_SIZE0_SEL_0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 0 offset.",
    },
    {
        .name  = MUX0_SIZE0_SEL_1s,  /* MUX0_SIZE0_SEL_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 1 offset.",
    },
    {
        .name  = MUX0_SIZE0_SEL_2s,  /* MUX0_SIZE0_SEL_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 2 offset.",
    },
    {
        .name  = MUX0_MASKs,  /* MUX0_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Bus object mask.",
    },
    {
        .name  = MUX_ENABLEs,  /* MUX_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mux selection logic.",
    },
    {
        .name  = MIRROR_COPY_VALUEs,  /* MIRROR_COPY_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to determine if packet is mirror-copy.",
    },
    {
        .name  = MIRROR_COPY_MASKs,  /* MIRROR_COPY_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask to determine if packet is mirror-copy.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_1_bitp_profile_t = {
    .name = FLEX_STATE_ING_1_BITP_PROFILEs, /* FLEX_STATE_ING_1_BITP_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_flex_state_ing_1_bitp_profile_t_fields,
    .desc = "The FLEX_STATE_ING_1_BITP_PROFILE table is used to specify ingress\n flex state instance 1 attributes to determine if packet is mirror-copy\n and should be counted.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_ACTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_action_profile_t_fields[] = {
    {
        .name  = FLEX_STATE_ING_ACTION_PROFILE_IDs,  /* FLEX_STATE_ING_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_ING_ACTION_PROFILE table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enhanced flex state action.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLEX_STATE_INSTANCE_T_DATA,
        .desc = "Flex state instance.",
    },
    {
        .name  = POOL_IDs,  /* POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting counter block.\n The block may spill over into the adjacent pool(s).\n",
    },
    {
        .name  = BASE_INDEX_AUTOs,  /* BASE_INDEX_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if the base index value should be calculated using\n internal logic.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Base index in the first pool.\n Applicable only if BASE_INDEX_AUTO is disabled.\n",
    },
    {
        .name  = BASE_INDEX_OPERs,  /* BASE_INDEX_OPER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Computed value of BASE_INDEX.\n Applicable only if BASE_INDEX_AUTO is enabled.\n",
    },
    {
        .name  = SHADOWs,  /* SHADOW */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if atomic snapshot of flex counters should be collected.",
    },
    {
        .name  = NUM_COUNTERSs,  /* NUM_COUNTERS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of flex counters requested.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state mode.\n The specified counter mode may impact the number\n of available counters for this entry.\n",
    },
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .desc = "Selected objects to calculate counter index and values.",
    },
    {
        .name  = INDEX_FLEX_STATE_ING_OPERAND_PROFILE_IDs,  /* INDEX_FLEX_STATE_ING_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The index of the entry in FLEX_STATE_ING_OPERAND_PROFILE table.\n This entry determines how the index of this counter is computed.\n",
    },
    {
        .name  = INDEX_FLEX_STATE_ING_ARG_OPERAND_PROFILE_IDs,  /* INDEX_FLEX_STATE_ING_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The index of the entry in FLEX_STATE_ING_OPERAND_PROFILE table.\n This entry determines how the index of this counter is computed.\n",
    },
    {
        .name  = INDEX_FLEX_STATE_ING_SM_OPERAND_PROFILE_IDs,  /* INDEX_FLEX_STATE_ING_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The index of the entry in FLEX_STATE_ING_OPERAND_PROFILE table.\n This entry determines how the index of this counter is computed.\n",
    },
    {
        .name  = UPDATE_COMPARE_As,  /* UPDATE_COMPARE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Comparison operation to be performed on stored value of\n counter A for conditional update.\n Applicable only if MODE == NORMAL.\n",
    },
    {
        .name  = VAL_A_COMP_FLEX_STATE_ING_OPERAND_PROFILE_IDs,  /* VAL_A_COMP_FLEX_STATE_ING_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter A value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_A.\n",
    },
    {
        .name  = VAL_A_COMP_FLEX_STATE_ING_ARG_OPERAND_PROFILE_IDs,  /* VAL_A_COMP_FLEX_STATE_ING_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter A value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_A.\n",
    },
    {
        .name  = VAL_A_COMP_FLEX_STATE_ING_SM_OPERAND_PROFILE_IDs,  /* VAL_A_COMP_FLEX_STATE_ING_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter A value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_A.\n",
    },
    {
        .name  = CTR_SRC_COMP_As,  /* CTR_SRC_COMP_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter A\n conditional update comparison.\n",
    },
    {
        .name  = TRUE_UPDATE_MODE_As,  /* TRUE_UPDATE_MODE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state A update mode if UPDATE_COMPARE_A returns TRUE.\n The supported modes may be dependent on the value\n specified in the MODE field.\n",
    },
    {
        .name  = VAL_A_UPD_TRUE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_TRUE_FLEX_STATE_ING_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_A.\n",
    },
    {
        .name  = VAL_A_UPD_TRUE_FLEX_STATE_ING_ARG_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_TRUE_FLEX_STATE_ING_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_A.\n",
    },
    {
        .name  = VAL_A_UPD_TRUE_FLEX_STATE_ING_SM_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_TRUE_FLEX_STATE_ING_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_A.\n",
    },
    {
        .name  = CTR_SRC_UPD_TRUE_As,  /* CTR_SRC_UPD_TRUE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter A\n conditional update if UPDATE_COMPARE_A returns TRUE.\n",
    },
    {
        .name  = FALSE_UPDATE_MODE_As,  /* FALSE_UPDATE_MODE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state A update mode if UPDATE_COMPARE_A returns FALSE.\n The supported modes may be dependent on the value\n specified in the MODE field.\n",
    },
    {
        .name  = VAL_A_UPD_FALSE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_FALSE_FLEX_STATE_ING_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_A.\n",
    },
    {
        .name  = VAL_A_UPD_FALSE_FLEX_STATE_ING_ARG_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_FALSE_FLEX_STATE_ING_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_A.\n",
    },
    {
        .name  = VAL_A_UPD_FALSE_FLEX_STATE_ING_SM_OPERAND_PROFILE_IDs,  /* VAL_A_UPD_FALSE_FLEX_STATE_ING_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter A value is computed for conditional\n update if UPDATE_COMPARE_A returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_A.\n",
    },
    {
        .name  = CTR_SRC_UPD_FALSE_As,  /* CTR_SRC_UPD_FALSE_A */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter A\n conditional update if UPDATE_COMPARE_A returns FALSE.\n",
    },
    {
        .name  = UPDATE_COMPARE_Bs,  /* UPDATE_COMPARE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Comparison operation to be performed on stored value of\n counter B for conditional update.\n Applicable only if MODE == NORMAL.\n",
    },
    {
        .name  = VAL_B_COMP_FLEX_STATE_ING_OPERAND_PROFILE_IDs,  /* VAL_B_COMP_FLEX_STATE_ING_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter B value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_B.\n",
    },
    {
        .name  = VAL_B_COMP_FLEX_STATE_ING_ARG_OPERAND_PROFILE_IDs,  /* VAL_B_COMP_FLEX_STATE_ING_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter B value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_B.\n",
    },
    {
        .name  = VAL_B_COMP_FLEX_STATE_ING_SM_OPERAND_PROFILE_IDs,  /* VAL_B_COMP_FLEX_STATE_ING_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter B value is computed for comparison\n during conditional update.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_COMP_B.\n",
    },
    {
        .name  = CTR_SRC_COMP_Bs,  /* CTR_SRC_COMP_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter B\n conditional update comparison.\n",
    },
    {
        .name  = TRUE_UPDATE_MODE_Bs,  /* TRUE_UPDATE_MODE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state B update mode if UPDATE_COMPARE_B returns TRUE.\n The supported modes may be dependent on the value\n specified in the MODE field.\n",
    },
    {
        .name  = VAL_B_UPD_TRUE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_TRUE_FLEX_STATE_ING_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_B.\n",
    },
    {
        .name  = VAL_B_UPD_TRUE_FLEX_STATE_ING_ARG_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_TRUE_FLEX_STATE_ING_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_B.\n",
    },
    {
        .name  = VAL_B_UPD_TRUE_FLEX_STATE_ING_SM_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_TRUE_FLEX_STATE_ING_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns TRUE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_TRUE_B.\n",
    },
    {
        .name  = CTR_SRC_UPD_TRUE_Bs,  /* CTR_SRC_UPD_TRUE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter B\n conditional update if UPDATE_COMPARE_B returns TRUE.\n",
    },
    {
        .name  = FALSE_UPDATE_MODE_Bs,  /* FALSE_UPDATE_MODE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex state B update mode if UPDATE_COMPARE_B returns FALSE.\n The supported modes may be dependent on the value\n specified in the MODE field.\n",
    },
    {
        .name  = VAL_B_UPD_FALSE_FLEX_STATE_ING_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_FALSE_FLEX_STATE_ING_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_B.\n",
    },
    {
        .name  = VAL_B_UPD_FALSE_FLEX_STATE_ING_ARG_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_FALSE_FLEX_STATE_ING_ARG_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_B.\n",
    },
    {
        .name  = VAL_B_UPD_FALSE_FLEX_STATE_ING_SM_OPERAND_PROFILE_IDs,  /* VAL_B_UPD_FALSE_FLEX_STATE_ING_SM_OPERAND_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_OPERAND_PROFILE table index which determines\n how counter B value is computed for conditional\n update if UPDATE_COMPARE_B returns FALSE.\n The computed value may be over-ridden by the value specified\n in CTR_SRC_UPD_FALSE_B.\n",
    },
    {
        .name  = CTR_SRC_UPD_FALSE_Bs,  /* CTR_SRC_UPD_FALSE_B */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Value selector to be used for counter B\n conditional update if UPDATE_COMPARE_B returns FALSE.\n",
    },
    {
        .name  = VAL_A_MEM_UPDATEs,  /* VAL_A_MEM_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the source of memory update for c\n Counter A.\n",
    },
    {
        .name  = VAL_B_MEM_UPDATEs,  /* VAL_B_MEM_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the source of memory update for\n Counter B.\n",
    },
    {
        .name  = VAL_A_BUS_UPDATEs,  /* VAL_A_BUS_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the source of bus update for\n counter A.\n",
    },
    {
        .name  = VAL_B_BUS_UPDATEs,  /* VAL_B_BUS_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the source of bus update\n for counter B.\n",
    },
    {
        .name  = TRUTH_TABLE_ENs,  /* TRUTH_TABLE_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable truth table lookup for the action.",
    },
    {
        .name  = TRUTH_TABLE_INSTANCEs,  /* TRUTH_TABLE_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Truth table instance to be used for this action.",
    },
    {
        .name  = COUNT_ON_RULE_DROPs,  /* COUNT_ON_RULE_DROP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_DROP_COUNT_MODE_T_DATA,
        .desc = "Counter drop mode specifies if counter should\n be updated based on functional packet drops.\n",
    },
    {
        .name  = COUNT_ON_HW_EXCP_DROPs,  /* COUNT_ON_HW_EXCP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count on hardware exception drops.",
    },
    {
        .name  = COUNT_ON_MIRRORs,  /* COUNT_ON_MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count egress mirrored packets also.\n Non-mirrored packets are always counted.\n",
    },
    {
        .name  = CTR_VAL_DATAs,  /* CTR_VAL_DATA */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Additional input used for special functions that calculate\n both counter A and B values.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_action_profile_t = {
    .name = FLEX_STATE_ING_ACTION_PROFILEs, /* FLEX_STATE_ING_ACTION_PROFILE */
    .flags = 0,
    .fields = 55,
    .field = bcmltd_flex_state_ing_action_profile_t_fields,
    .desc = "The FLEX_STATE_ING_ACTION_PROFILE logical table specifies the\n egress enhanced flex state action ID profile configuration.\n\n The following conditional update logic is applicable only if\n MODE == NORMAL.\n There are 3 values per counter (A or B) that can be calculated.\n These values are marked as compare_value, update_value_true and\n update_value_false.\n They are calculated based on FLEX_STATE_ING_OPERAND_PROFILE entry.\n\n If UPDATE_COMPARE_x(stored_value, compare_value) returns true\n    where stored_value is current value of counter A or B.\n\n    where UPDATE_COMPARE_x function can be any of the following:\n          - TRUE\n          - EQUAL\n          - LESS_THAN (i.e. stored_value < compare_value)\n\n    where compare_value == value calculated by the entry indexed by\n          VAL_x_COMP_FLEX_STATE_ING_OPERAND_PROFILE_ID of the table\n          FLEX_STATE_ING_OPERAND_PROFILE and x is in {A, B}\n          It may be overidden by CTR_SRC_COMP_x.\n\n Then\n    new_state_x = TRUE_UPDATE_MODE_x(stored_value, update_value_true)\n    where update_value_true == value calculated by the entry indexed by\n          VAL_x_UPD_TRUE_FLEX_STATE_ING_OPERAND_PROFILE_ID of the table\n          FLEX_STATE_ING_OPERAND_PROFILE and x is in {A, B}\n          It may be overidden by CTR_SRC_UPD_TRUE_x.\n\n Else\n    new_state_x = FALSE_UPDATE_MODE_x(stored_value, update_value_false)\n    where update_value_true == value calculated by the entry indexed by\n          VAL_x_UPD_FALSE_FLEX_STATE_ING_OPERAND_PROFILE_ID of the table\n          FLEX_STATE_ING_OPERAND_PROFILE and x is in {A, B}\n          It may be overidden by CTR_SRC_UPD_FALSE_x.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_ACTION_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_action_profile_info_t_fields[] = {
    {
        .name  = FLEX_STATE_ING_ACTION_PROFILE_IDs,  /* FLEX_STATE_ING_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_ING_ACTION_PROFILE table.",
    },
    {
        .name  = POOL_IDs,  /* POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting counter block.",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Base index in the first pool.",
    },
    {
        .name  = NUM_POOLSs,  /* NUM_POOLS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of flex state pools allocated.",
    },
    {
        .name  = TOP_INDEXs,  /* TOP_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Last index within the last pool ID of\n FLEX_STATE_ING_ACTION_PROFILE.POOL_ID + (NUM_POOLS - 1)\n for the specified FLEX_STATE_ING_ACTION_PROFILE.NUM_COUNTERS.\n",
    },
    {
        .name  = SHADOW_VALIDs,  /* SHADOW_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that shadow pools are configured.",
    },
    {
        .name  = SHADOW_POOL_IDs,  /* SHADOW_POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pool ID for the starting shadow counter block.\n\n Applicable only if SHADOW_VALID == TRUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_action_profile_info_t = {
    .name = FLEX_STATE_ING_ACTION_PROFILE_INFOs, /* FLEX_STATE_ING_ACTION_PROFILE_INFO */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_flex_state_ing_action_profile_info_t_fields,
    .desc = "The FLEX_STATE_ING_ACTION_PROFILE_INFO logical table provides\n information about the current ingress enhanced flex state action ID\n profile configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_BITP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_bitp_profile_t_fields[] = {
    {
        .name  = MUX0_SIZE0_SEL_0s,  /* MUX0_SIZE0_SEL_0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 0 offset.",
    },
    {
        .name  = MUX0_SIZE0_SEL_1s,  /* MUX0_SIZE0_SEL_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 1 offset.",
    },
    {
        .name  = MUX0_SIZE0_SEL_2s,  /* MUX0_SIZE0_SEL_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bus object 2 offset.",
    },
    {
        .name  = MUX0_MASKs,  /* MUX0_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Bus object mask.",
    },
    {
        .name  = MUX_ENABLEs,  /* MUX_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mux selection logic.",
    },
    {
        .name  = MIRROR_COPY_VALUEs,  /* MIRROR_COPY_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to determine if packet is mirror-copy.",
    },
    {
        .name  = MIRROR_COPY_MASKs,  /* MIRROR_COPY_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask to determine if packet is mirror-copy.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_bitp_profile_t = {
    .name = FLEX_STATE_ING_BITP_PROFILEs, /* FLEX_STATE_ING_BITP_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_flex_state_ing_bitp_profile_t_fields,
    .desc = "The FLEX_STATE_ING_BITP_PROFILE table is used to specify ingress\n flex state instance 0 attributes to determine if packet is mirror-copy\n and should be counted.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_ERROR_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_error_stats_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLEX_STATE_INSTANCE_T_DATA,
        .desc = "Flex state instance.",
    },
    {
        .name  = ACTION_MISCONFIGs,  /* ACTION_MISCONFIG */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Error counter incremented when multiple flex state actions\n are directed to the same counter pool.\n",
    },
    {
        .name  = TOO_MANY_ACTIONSs,  /* TOO_MANY_ACTIONS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Error counter incremented when more than a specified number of\n flex state actions are generated for the same packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_error_stats_t = {
    .name = FLEX_STATE_ING_ERROR_STATSs, /* FLEX_STATE_ING_ERROR_STATS */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_flex_state_ing_error_stats_t_fields,
    .desc = "The FLEX_STATE_ING_ERROR_STATS table specifies the error counters\n present in the ingress enhanced flex state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_GROUP_ACTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_group_action_profile_t_fields[] = {
    {
        .name  = FLEX_STATE_ING_GROUP_ACTION_PROFILE_IDs,  /* FLEX_STATE_ING_GROUP_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_ING_GROUP_ACTION_PROFILE table.",
    },
    {
        .name  = GROUPs,  /* GROUP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enhanced flex state action group.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLEX_STATE_INSTANCE_T_DATA,
        .desc = "Flex state instance.",
    },
    {
        .name  = FLEX_STATE_ING_ACTION_PROFILE_IDs,  /* FLEX_STATE_ING_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FLEX_STATE_ING_ACTION_PROFILE table index which\n represents the group action profile ID.\n",
    },
    {
        .name  = GROUP_MAPs,  /* GROUP_MAP */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "Action profile IDs associated with the group action.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_STATE_T_DATA,
        .desc = "Read-only field which reflects the group action operational state.\n The operational state indicates ACTIVE once all\n FLEX_STATE_ING_ACTION_PROFILE entries associated with the group\n have been inserted. It may be updated based on the changes to the\n FLEX_STATE_ING_ACTION_PROFILE table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_group_action_profile_t = {
    .name = FLEX_STATE_ING_GROUP_ACTION_PROFILEs, /* FLEX_STATE_ING_GROUP_ACTION_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_flex_state_ing_group_action_profile_t_fields,
    .desc = "The FLEX_STATE_ING_GROUP_ACTION_PROFILE logical table specifies the\n ingress enhanced flex state group action ID profile configuration.\n\n It allows a single action, indicated by\n INDEX_FLEX_STATE_ING_ACTION_PROFILE_ID, to trigger all the actions\n within the group, indicated by the GROUP_MAP array.\n\n If group state action is applied, its associated state actions\n are selected for counter processing.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_OBJ_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_obj_info_t_fields[] = {
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Ingress flex state object.",
    },
    {
        .name  = MIN_BITs,  /* MIN_BIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Starting offset of the flex state object.",
    },
    {
        .name  = MAX_BITs,  /* MAX_BIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ending offset of the flex state object.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_obj_info_t = {
    .name = FLEX_STATE_ING_OBJ_INFOs, /* FLEX_STATE_ING_OBJ_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_state_ing_obj_info_t_fields,
    .desc = "The FLEX_STATE_ING_OBJ_INFO logical table provides information\n about the ingress enhanced flex state object bit offsets in the object bus.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_OBJ_QUANTIZATION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_obj_quantization_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLEX_STATE_INSTANCE_T_DATA,
        .desc = "Flex state instance.",
    },
    {
        .name  = QUANTIZEs,  /* QUANTIZE */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable to set object quantization.",
    },
    {
        .name  = OBJs,  /* OBJ */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .desc = "Objects selected for range check quantization .",
    },
    {
        .name  = OBJ_0_1_MODEs,  /* OBJ_0_1_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use 32-bit mode where quantized results\n of objects 0 and 1 are concatenated and assigned to\n object 0. Object 1 is unchanged.\n",
    },
    {
        .name  = OBJ_2_3_MODEs,  /* OBJ_2_3_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use 32-bit mode where quantized results\n of objects 2 and 3 are concatenated and assigned to\n object 2. Object 3 is unchanged.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_obj_quantization_t = {
    .name = FLEX_STATE_ING_OBJ_QUANTIZATIONs, /* FLEX_STATE_ING_OBJ_QUANTIZATION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_flex_state_ing_obj_quantization_t_fields,
    .desc = "The FLEX_STATE_ING_OBJ_QUANTIZATION table configures the ingress\n object quantization controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_OPERAND_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_operand_profile_t_fields[] = {
    {
        .name  = FLEX_STATE_ING_OPERAND_PROFILE_IDs,  /* FLEX_STATE_ING_OPERAND_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the flex state egress operand profile table.",
    },
    {
        .name  = PROFILEs,  /* PROFILE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Flex state egress operand profile index.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLEX_STATE_INSTANCE_T_DATA,
        .desc = "Flex state instance.",
    },
    {
        .name  = OBJ_1s,  /* OBJ_1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 1 selection result.",
    },
    {
        .name  = OBJ_2s,  /* OBJ_2 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 2 selection result.",
    },
    {
        .name  = OBJ_3s,  /* OBJ_3 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Object 2 selection result.",
    },
    {
        .name  = MASK_SIZE_1s,  /* MASK_SIZE_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 1.",
    },
    {
        .name  = MASK_SIZE_2s,  /* MASK_SIZE_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 2.",
    },
    {
        .name  = MASK_SIZE_3s,  /* MASK_SIZE_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask size for object 2.",
    },
    {
        .name  = SHIFT_1s,  /* SHIFT_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift amount for object 1.",
    },
    {
        .name  = SHIFT_2s,  /* SHIFT_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Left shift amount for object 2.",
    },
    {
        .name  = SHIFT_3s,  /* SHIFT_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Left shift amount for object 2.",
    },
    {
        .name  = SHIFT_4s,  /* SHIFT_4 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Left shift amount for object 2.",
    },
    {
        .name  = SHIFT_5s,  /* SHIFT_5 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Left shift amount for object 2.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_operand_profile_t = {
    .name = FLEX_STATE_ING_OPERAND_PROFILEs, /* FLEX_STATE_ING_OPERAND_PROFILE */
    .flags = 0,
    .fields = 15,
    .field = bcmltd_flex_state_ing_operand_profile_t_fields,
    .desc = "The FLEX_STATE_ING_OPERAND_PROFILE table determines how ingress\n enhanced flex state values A, B or counter index are computed.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_OPERAND_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_operand_profile_info_t_fields[] = {
    {
        .name  = FLEX_STATE_ING_OPERAND_PROFILE_IDs,  /* FLEX_STATE_ING_OPERAND_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_ING_OPERAND_PROFILE table.",
    },
    {
        .name  = PROFILEs,  /* PROFILE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Flex state ingress operand profile index.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_operand_profile_info_t = {
    .name = FLEX_STATE_ING_OPERAND_PROFILE_INFOs, /* FLEX_STATE_ING_OPERAND_PROFILE_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_flex_state_ing_operand_profile_info_t_fields,
    .desc = "The FLEX_STATE_ING_OPERAND_PROFILE_INFO logical table provides information\n about the current ingress enhanced flex state operand profile\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_POOL_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_pool_info_t_fields[] = {
    {
        .name  = FLEX_STATE_ING_POOL_INFO_IDs,  /* FLEX_STATE_ING_POOL_INFO_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_ING_POOL_INFO table.",
    },
    {
        .name  = POOL_SIZEs,  /* POOL_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Indicates the number of counters in the pool.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_pool_info_t = {
    .name = FLEX_STATE_ING_POOL_INFOs, /* FLEX_STATE_ING_POOL_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_flex_state_ing_pool_info_t_fields,
    .desc = "The FLEX_STATE_ING_POOL_INFO table provides ingress\n enhanced flex state pool information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_RANGE_CHK_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_range_chk_profile_t_fields[] = {
    {
        .name  = FLEX_STATE_ING_RANGE_CHK_PROFILE_IDs,  /* FLEX_STATE_ING_RANGE_CHK_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_ING_RANGE_CHK_PROFILE table.",
    },
    {
        .name  = OBJ_SELECTs,  /* OBJ_SELECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Object whose value is to be range checked.",
    },
    {
        .name  = RANGE_CHECKERs,  /* RANGE_CHECKER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Range checker number.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLEX_STATE_INSTANCE_T_DATA,
        .desc = "Flex state instance.",
    },
    {
        .name  = MINs,  /* MIN */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Minimum value for range checker.",
    },
    {
        .name  = MAXs,  /* MAX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum value for range checker.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_range_chk_profile_t = {
    .name = FLEX_STATE_ING_RANGE_CHK_PROFILEs, /* FLEX_STATE_ING_RANGE_CHK_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_flex_state_ing_range_chk_profile_t_fields,
    .desc = "The FLEX_STATE_ING_RANGE_CHK_PROFILE table configures the ingress\n flex state object quantization range checkers with min and max values.\n\n Each range checker determines if the corresponding object value\n is within the min and max range.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_RANGE_CHK_PROFILE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_range_chk_profile_info_t_fields[] = {
    {
        .name  = FLEX_STATE_ING_RANGE_CHK_PROFILE_IDs,  /* FLEX_STATE_ING_RANGE_CHK_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_ING_RANGE_CHK_PROFILE table.",
    },
    {
        .name  = OBJ_SELECTs,  /* OBJ_SELECT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Object whose value is to be range checked.",
    },
    {
        .name  = RANGE_CHECKERs,  /* RANGE_CHECKER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Range checker number.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_range_chk_profile_info_t = {
    .name = FLEX_STATE_ING_RANGE_CHK_PROFILE_INFOs, /* FLEX_STATE_ING_RANGE_CHK_PROFILE_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_flex_state_ing_range_chk_profile_info_t_fields,
    .desc = "The FLEX_STATE_ING_RANGE_CHK_PROFILE_INFO logical table provides information\n about the current ingress enhanced flex state range checker profile\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_stats_t_fields[] = {
    {
        .name  = FLEX_STATE_ING_ACTION_PROFILE_IDs,  /* FLEX_STATE_ING_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_ING_ACTION_PROFILE table.",
    },
    {
        .name  = CTR_EFLEX_INDEXs,  /* CTR_EFLEX_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Counter index.",
    },
    {
        .name  = CTR_A_UPPERs,  /* CTR_A_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value A. The applicability of this field is\n dependent on the counter width value specified in\n FLEX_STATE_ING_ACTION_PROFILE.MODE field.\n",
    },
    {
        .name  = CTR_A_LOWERs,  /* CTR_A_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value A. The applicability of this field is\n dependent on the counter width value specified in\n FLEX_STATE_ING_ACTION_PROFILE.MODE field.\n",
    },
    {
        .name  = CTR_Bs,  /* CTR_B */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Counter value B. The applicability of this field is\n dependent on the counter width value specified in\n FLEX_STATE_ING_ACTION_PROFILE.MODE field.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_stats_t = {
    .name = FLEX_STATE_ING_STATSs, /* FLEX_STATE_ING_STATS */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_flex_state_ing_stats_t_fields,
    .desc = "The FLEX_STATE_ING_STATS table is used to retrieve the\n the ingress enhanced flex state counter A and B values.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_TRIGGER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_trigger_t_fields[] = {
    {
        .name  = FLEX_STATE_ING_ACTION_PROFILE_IDs,  /* FLEX_STATE_ING_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FLEX_STATE_ING_ACTION_PROFILE table.",
    },
    {
        .name  = TRIGGERs,  /* TRIGGER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update counter based on trigger condition.\n Disable to always update counter.\n",
    },
    {
        .name  = STARTs,  /* START */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_START_TRIGGER_T_DATA,
        .desc = "Start trigger type.",
    },
    {
        .name  = STOPs,  /* STOP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Stop trigger type.",
    },
    {
        .name  = START_VALUEs,  /* START_VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Start value which will trigger counter update,\n when the following condition is met:\n CTR_EGR_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK == START_VALUE\n if COMPARE_START == 0.\n CTR_EGR_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK != START_VALUE\n if COMPARE_START == 1.\n Applicable only if START == CONDITION.\n",
    },
    {
        .name  = STOP_VALUEs,  /* STOP_VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Stop value which will stop counter update,.\n when the following condition is met:\n STATE_ING_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK == START_VALUE\n if COMPARE_STOP == 0.\n STATE_ING_EFLEX_ACTION_PROFILE.OBJ[1] & COND_MASK != START_VALUE\n if COMPARE_STOP == 1.\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = COND_MASKs,  /* COND_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask value applied to start or stop value to select\n desired attributes.\n Applicable if START == CONDITION or STOP == CONDITION.\n",
    },
    {
        .name  = START_TIME_OFFSETs,  /* START_TIME_OFFSET */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Time offset from current time in nanoseconds\n to trigger counter update.\n Applicable only if START == TIME.\n",
    },
    {
        .name  = NUM_PERIODs,  /* NUM_PERIOD */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The number of periods to measure before stopping.\n If set to 0, then the number of periods is infinite.\n To disable the trigger in this case,\n set NUM_PERIOD to non-zero value and enable TRIGGER.\n Applicable only if STOP == PERIOD.\n",
    },
    {
        .name  = NUM_ACTIONSs,  /* NUM_ACTIONS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = COMPARE_STARTs,  /* COMPARE_START */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If disabled then == is used as the compare function\n to trigger start counter update.\n If enabled then != is used as the compare function\n to trigger start  counter update.\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = COMPARE_STOPs,  /* COMPARE_STOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If disabled then == is used as the compare function\n to trigger stop counter update.\n If enabled then != is used as the compare function\n to trigger stop  counter update.\n Applicable only if STOP == CONDITION.\n",
    },
    {
        .name  = SCALEs,  /* SCALE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Duration of a single time period.\n Applicable only if STOP == PERIOD.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CTR_EFLEX_STATE_T_DATA,
        .desc = "Read-only field which reflects the trigger operational state.\n The operational state indicates ACTIVE once a\n FLEX_STATE_ING_ACTION_PROFILE entry has been inserted.\n",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_trigger_t = {
    .name = FLEX_STATE_ING_TRIGGERs, /* FLEX_STATE_ING_TRIGGER */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_flex_state_ing_trigger_t_fields,
    .desc = "The FLEX_STATE_ING_TRIGGER table configures the trigger function to\n enable conditional updates on ingress enhanced flex state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/flex_state/FLEX_STATE_ING_TRUTH_TABLE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_flex_state_ing_truth_table_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = POOLs,  /* POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Indicates the  pool  associated with the entry.",
    },
    {
        .name  = TRUTH_TABLE_INSTANCEs,  /* TRUTH_TABLE_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Indicates the  truth table instance associated\n with this entry.\n Each pool has 4 instances of truth table.\n",
    },
    {
        .name  = INDEXs,  /* INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Indicates the truth table index associated\n with this entry.\n",
    },
    {
        .name  = INSTANCEs,  /* INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLEX_STATE_INSTANCE_T_DATA,
        .desc = "Flex state instance.",
    },
    {
        .name  = OUTPUTs,  /* OUTPUT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Flex state output sent to the bus.",
    },
};
const bcmltd_table_rep_t bcmltd_flex_state_ing_truth_table_t = {
    .name = FLEX_STATE_ING_TRUTH_TABLEs, /* FLEX_STATE_ING_TRUTH_TABLE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_flex_state_ing_truth_table_t_fields,
    .desc = "The FLEX_STATE_ING_TRUTH_TABLE table provides ingress\n enhanced flex truth table configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_CLASSID_REMAP_0.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_classid_remap_0_t_fields[] = {
    {
        .name  = FP_COMPRESSION_CLASSID_REMAP_0_IDs,  /* FP_COMPRESSION_CLASSID_REMAP_0_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the class ID remap table.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = REMAPPED_VALUEs,  /* REMAPPED_VALUE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Remapped classid value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_classid_remap_0_t = {
    .name = FP_COMPRESSION_CLASSID_REMAP_0s, /* FP_COMPRESSION_CLASSID_REMAP_0 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_compression_classid_remap_0_t_fields,
    .desc = "The FP_COMPRESSION_CLASSID_REMAP_0 tables specifies remaps to the\n class ID.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_CLASSID_REMAP_1.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_classid_remap_1_t_fields[] = {
    {
        .name  = FP_COMPRESSION_CLASSID_REMAP_1_IDs,  /* FP_COMPRESSION_CLASSID_REMAP_1_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the class ID remap table.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = REMAPPED_VALUEs,  /* REMAPPED_VALUE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Remapped classid value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_classid_remap_1_t = {
    .name = FP_COMPRESSION_CLASSID_REMAP_1s, /* FP_COMPRESSION_CLASSID_REMAP_1 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_compression_classid_remap_1_t_fields,
    .desc = "The FP_COMPRESSION_CLASSID_REMAP_1 tables specifies remaps to the\n class ID.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_DST_FCOE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_dst_fcoe_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PIPE_MASKs,  /* PIPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PIPE.",
    },
    {
        .name  = DST_FCOE_IDENTIFIERs,  /* DST_FCOE_IDENTIFIER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Destination FCoE identifier to be matched in entry.",
    },
    {
        .name  = DST_FCOE_IDENTIFIER_MASKs,  /* DST_FCOE_IDENTIFIER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for DST_FCOE_IDENTIFIER.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = COMPRESSED_DST_FCOE_IDENTIFIERs,  /* COMPRESSED_DST_FCOE_IDENTIFIER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Compressed destination FCoE value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_dst_fcoe_t = {
    .name = FP_COMPRESSION_DST_FCOEs, /* FP_COMPRESSION_DST_FCOE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 6,
    .field = bcmltd_fp_compression_dst_fcoe_t_fields,
    .desc = "The FP_COMPRESSION_DST_FCOE specifies the compression map for destination\n FCoE identifier. Compressed value can be assigned to a single or range of\n destination FCoE identifier. Compressed value along with original\n destination FCoE identifier are available in FP to match.\n Destination identifier is a field in FCoE header.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_DST_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_dst_ipv4_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PIPE_MASKs,  /* PIPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PIPE.",
    },
    {
        .name  = VRFs,  /* VRF */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF to be matched in entry.",
    },
    {
        .name  = VRF_MASKs,  /* VRF_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address to be matched in entry.",
    },
    {
        .name  = DST_IPV4_MASKs,  /* DST_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for DST_IPV4.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = COMPRESSED_DST_IPV4s,  /* COMPRESSED_DST_IPV4 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Compressed destination IPv4 value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_dst_ipv4_t = {
    .name = FP_COMPRESSION_DST_IPV4s, /* FP_COMPRESSION_DST_IPV4 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 8,
    .field = bcmltd_fp_compression_dst_ipv4_t_fields,
    .desc = "The FP_COMPRESSION_DST_IPV4 specifies the compression map for destination\n IPv4 address.\n Compressed value can be assigned to a single or range of destination\n IPv4 addresses. Compressed value along with original destination IPv4\n address are available in FP to match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_DST_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_dst_ipv6_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PIPE_MASKs,  /* PIPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PIPE.",
    },
    {
        .name  = VRFs,  /* VRF */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF to be matched in entry.",
    },
    {
        .name  = VRF_MASKs,  /* VRF_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 addresss to be matched in entry.",
    },
    {
        .name  = DST_IPV6_UPPER_MASKs,  /* DST_IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for DST_IPV6_UPPER.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = DST_IPV6_LOWER_MASKs,  /* DST_IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for DST_IPV6_LOWER.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = COMPRESSED_DST_IPV6s,  /* COMPRESSED_DST_IPV6 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Compressed destination IPv6 value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_dst_ipv6_t = {
    .name = FP_COMPRESSION_DST_IPV6s, /* FP_COMPRESSION_DST_IPV6 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 10,
    .field = bcmltd_fp_compression_dst_ipv6_t_fields,
    .desc = "The FP_COMPRESSION_DST_IPV6 specifies the compression map for destination\n IPv6 address.\n Compressed value can be assigned to a single or range of destination\n IPv6 addresses. Compressed value along with original destination IPv6\n address are available in FP to match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_DST_L4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_dst_l4_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = FP_COMPRESSION_DST_L4_IDs,  /* FP_COMPRESSION_DST_L4_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "LT entry identifier.",
    },
    {
        .name  = DST_L4_TYPEs,  /* DST_L4_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Type of the entry.\n Type can be either\n DST_L4_PORT (destination L4 port and ICMP type) or\n FCOE_RX_ID\n",
    },
    {
        .name  = DST_L4s,  /* DST_L4 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination L4 Port/FCoE RX ID/ICMP type to be\n matched in the entry.\n",
    },
    {
        .name  = COMPRESSED_DST_L4s,  /* COMPRESSED_DST_L4 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Compressed destination L4 Port/FCoE RX ID/ICMP type value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_dst_l4_t = {
    .name = FP_COMPRESSION_DST_L4s, /* FP_COMPRESSION_DST_L4 */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_compression_dst_l4_t_fields,
    .desc = "The FP_COMPRESSION_DST_L4 specifies the compression map for third and fourth\n bytes in L4 header of IP packet or RX ID in FCoE Packet.\n In case of IP packet, field could be either L4 destination port or ICMP type.\n Each entry in this LT will assign one compressed value to one original value.\n It is programming requirement to not have two different entries with\n same match value(DST_L4) and entry type(DST_L4_TYPE)\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_ETHERTYPE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_ethertype_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = FP_COMPRESSION_ETHERTYPE_IDs,  /* FP_COMPRESSION_ETHERTYPE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "LT entry identifier.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype to be matched in the entry.",
    },
    {
        .name  = COMPRESSED_ETHERTYPEs,  /* COMPRESSED_ETHERTYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Compressed ethertype.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_ethertype_t = {
    .name = FP_COMPRESSION_ETHERTYPEs, /* FP_COMPRESSION_ETHERTYPE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_compression_ethertype_t_fields,
    .desc = "The FP_COMPRESSION_ETHERTYPE specifies the compression map for ethertype in\n the packet. Each entry in this LT will assign one compressed value to one\n ethernet value in the incoming packet.\n It is programming requirement to not have more than one entry with\n same ethertype value(ETHERTYPE).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_INDEX_REMAP_0.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_index_remap_0_t_fields[] = {
    {
        .name  = FP_COMPRESSION_INDEX_REMAP_0_IDs,  /* FP_COMPRESSION_INDEX_REMAP_0_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Packet or metadata field value.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = REMAPPED_VALUEs,  /* REMAPPED_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Remapped packet or metadata field value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_index_remap_0_t = {
    .name = FP_COMPRESSION_INDEX_REMAP_0s, /* FP_COMPRESSION_INDEX_REMAP_0 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_compression_index_remap_0_t_fields,
    .desc = "The FP_COMPRESSION_INDEX_REMAP_0 tables specifies remaps to the\n packet or metadata fields with old packet or metadata field as index.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_INDEX_REMAP_1.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_index_remap_1_t_fields[] = {
    {
        .name  = FP_COMPRESSION_INDEX_REMAP_1_IDs,  /* FP_COMPRESSION_INDEX_REMAP_1_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Packet or metadata field value.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = REMAPPED_VALUEs,  /* REMAPPED_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Remapped packet or metadata field value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_index_remap_1_t = {
    .name = FP_COMPRESSION_INDEX_REMAP_1s, /* FP_COMPRESSION_INDEX_REMAP_1 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_compression_index_remap_1_t_fields,
    .desc = "The FP_COMPRESSION_INDEX_REMAP_1 tables specifies remaps to the\n packet or metadata fields with old packet or metadata field as index.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_INDEX_REMAP_2.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_index_remap_2_t_fields[] = {
    {
        .name  = FP_COMPRESSION_INDEX_REMAP_2_IDs,  /* FP_COMPRESSION_INDEX_REMAP_2_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Packet or metadata field value.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = REMAPPED_VALUEs,  /* REMAPPED_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Remapped packet or metadata field value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_index_remap_2_t = {
    .name = FP_COMPRESSION_INDEX_REMAP_2s, /* FP_COMPRESSION_INDEX_REMAP_2 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_compression_index_remap_2_t_fields,
    .desc = "The FP_COMPRESSION_INDEX_REMAP_2 tables specifies remaps to the\n packet or metadata fields with old packet or metadata field as index.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_INDEX_REMAP_3.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_index_remap_3_t_fields[] = {
    {
        .name  = FP_COMPRESSION_INDEX_REMAP_3_IDs,  /* FP_COMPRESSION_INDEX_REMAP_3_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Packet or metadata field value.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = REMAPPED_VALUEs,  /* REMAPPED_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Remapped packet or metadata field value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_index_remap_3_t = {
    .name = FP_COMPRESSION_INDEX_REMAP_3s, /* FP_COMPRESSION_INDEX_REMAP_3 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_compression_index_remap_3_t_fields,
    .desc = "The FP_COMPRESSION_INDEX_REMAP_3 tables specifies remaps to the\n packet or metadata fields with old packet or metadata field as index.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_IP_PROTOCOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_ip_protocol_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = IP_PROTOCOLs,  /* IP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP Protocol value.",
    },
    {
        .name  = COMPRESSED_IP_PROTOCOLs,  /* COMPRESSED_IP_PROTOCOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Compressed IP protocol value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_ip_protocol_t = {
    .name = FP_COMPRESSION_IP_PROTOCOLs, /* FP_COMPRESSION_IP_PROTOCOL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_compression_ip_protocol_t_fields,
    .desc = "The FP_COMPRESSION_IP_PROTOCOL specifies the compression map for IP protocol\n value.\n Each entry in this LT will assign one compressed value to one IP protocol\n value and that IP protocol value is the index to this LT. Compressed\n IP protocol along with the original IP protocol are available in\n FP to match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_IP_TOS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_ip_tos_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP TOS value.",
    },
    {
        .name  = COMPRESSED_IP_TOS_0s,  /* COMPRESSED_IP_TOS_0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "First compressed IP TOS value.",
    },
    {
        .name  = COMPRESSED_IP_TOS_1s,  /* COMPRESSED_IP_TOS_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Second compressed IP TOS value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_ip_tos_t = {
    .name = FP_COMPRESSION_IP_TOSs, /* FP_COMPRESSION_IP_TOS */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_compression_ip_tos_t_fields,
    .desc = "The FP_COMPRESSION_IP_TOS specifies the compression map for IP TOS.\n Each entry in this LT will assign two compressed values to each IP TOS.\n IP TOS is the index to this LT. Two compressed values along with original\n value are available in FP to match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_IP_TTL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_ip_ttl_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP TTL value.",
    },
    {
        .name  = COMPRESSED_IP_TTL_0s,  /* COMPRESSED_IP_TTL_0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "First compressed IP TTL value.",
    },
    {
        .name  = COMPRESSED_IP_TTL_1s,  /* COMPRESSED_IP_TTL_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Second compressed IP TTL value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_ip_ttl_t = {
    .name = FP_COMPRESSION_IP_TTLs, /* FP_COMPRESSION_IP_TTL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_compression_ip_ttl_t_fields,
    .desc = "FP_COMPRESSION_IP_TTL creates compression map for IP TTL. Each entry in\n this LT will assign two compressed values to each IP TTL. IP TTL is the\n index to this LT. Two compressed IP TTL values along with original IP TTL\n value are available in FP to match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_MATCH_REMAP_0.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_match_remap_0_t_fields[] = {
    {
        .name  = FP_COMPRESSION_MATCH_REMAP_0_IDs,  /* FP_COMPRESSION_MATCH_REMAP_0_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index to the logical table",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = ORIGINAL_VALUEs,  /* ORIGINAL_VALUE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Original Packet or metadata field value.",
    },
    {
        .name  = REMAPPED_VALUEs,  /* REMAPPED_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Remapped packet or metadata field value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_match_remap_0_t = {
    .name = FP_COMPRESSION_MATCH_REMAP_0s, /* FP_COMPRESSION_MATCH_REMAP_0 */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_compression_match_remap_0_t_fields,
    .desc = "The FP_COMPRESSION_MATCH_REMAP_0 tables specifies remaps to the\n packet or metadata fields when there is a match with old packet or\n metadata field.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_MATCH_REMAP_1.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_match_remap_1_t_fields[] = {
    {
        .name  = FP_COMPRESSION_MATCH_REMAP_1_IDs,  /* FP_COMPRESSION_MATCH_REMAP_1_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index to the logical table",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = ORIGINAL_VALUEs,  /* ORIGINAL_VALUE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Original Packet or metadata field value.",
    },
    {
        .name  = REMAPPED_VALUEs,  /* REMAPPED_VALUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Remapped packet or metadata field value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_match_remap_1_t = {
    .name = FP_COMPRESSION_MATCH_REMAP_1s, /* FP_COMPRESSION_MATCH_REMAP_1 */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_compression_match_remap_1_t_fields,
    .desc = "The FP_COMPRESSION_MATCH_REMAP_1 tables specifies remaps to the\n packet or metadata fields when there is a match with old packet or\n metadata field.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_PKT_LEN_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_pkt_len_profile_t_fields[] = {
    {
        .name  = FP_COMPRESSION_PKT_LEN_PROFILE_IDs,  /* FP_COMPRESSION_PKT_LEN_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index to the packet length profile table.",
    },
    {
        .name  = BYTESs,  /* BYTES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of bytes that should be incremented or decremented\n from the packet length.\n",
    },
    {
        .name  = DECREMENTs,  /* DECREMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to decrement the specified BYTES value from the\n packet length. Disable to increment the packet length with\n the specified BYTES value.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_pkt_len_profile_t = {
    .name = FP_COMPRESSION_PKT_LEN_PROFILEs, /* FP_COMPRESSION_PKT_LEN_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_compression_pkt_len_profile_t_fields,
    .desc = "The FP_COMPRESSION_PKT_LEN_PROFILE table specifies the packet length\n adjustment for FP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_RANGE_CHECK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_range_check_t_fields[] = {
    {
        .name  = FP_COMPRESSION_RANGE_CHECK_IDs,  /* FP_COMPRESSION_RANGE_CHECK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index to the logical table",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = FIELD_TYPEs,  /* FIELD_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The packet or metadata field to be range checked.",
    },
    {
        .name  = MIN_VALUEs,  /* MIN_VALUE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Minimum value of packet or metadata field value to be range\n checked.\n",
    },
    {
        .name  = MAX_VALUEs,  /* MAX_VALUE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Minimum value of packet or metadata field value to be range\n checked.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_range_check_t = {
    .name = FP_COMPRESSION_RANGE_CHECKs, /* FP_COMPRESSION_RANGE_CHECK */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_compression_range_check_t_fields,
    .desc = "The FP_COMPRESSION_RANGE_CHECK table specifies ranges on packet or\n metadata fields.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_RANGE_CHECK_GROUP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_range_check_group_t_fields[] = {
    {
        .name  = FP_COMPRESSION_RANGE_CHECK_GROUP_IDs,  /* FP_COMPRESSION_RANGE_CHECK_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Range group identifier.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = FP_COMPRESSION_RANGE_CHECK_GROUPs,  /* FP_COMPRESSION_RANGE_CHECK_GROUP */
        .flags = 0,
        .width = 1,
        .depth = 64,
        .desc = "Enable if the range check ID created in FP_COMPRESSION_RANGE_CHECK\n table is to be added to this range group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_range_check_group_t = {
    .name = FP_COMPRESSION_RANGE_CHECK_GROUPs, /* FP_COMPRESSION_RANGE_CHECK_GROUP */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_compression_range_check_group_t_fields,
    .desc = "The FP_COMPRESSION_RANGE_CHECK_GROUP table specifies a set of range check\n IDs that needs to be grouped together. The specified group will get a hit\n when one of the range conditions in the set of range IDs is met.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_SRC_FCOE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_src_fcoe_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe Number.",
    },
    {
        .name  = PIPE_MASKs,  /* PIPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PIPE.",
    },
    {
        .name  = SRC_FCOE_IDENTIFIERs,  /* SRC_FCOE_IDENTIFIER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Source FCoE identifier to be matched in entry.",
    },
    {
        .name  = SRC_FCOE_IDENTIFIER_MASKs,  /* SRC_FCOE_IDENTIFIER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for SRC_FCOE_IDENTIFIER.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = COMPRESSED_SRC_FCOE_IDENTIFIERs,  /* COMPRESSED_SRC_FCOE_IDENTIFIER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Compressed source FCoE identifier.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_src_fcoe_t = {
    .name = FP_COMPRESSION_SRC_FCOEs, /* FP_COMPRESSION_SRC_FCOE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 6,
    .field = bcmltd_fp_compression_src_fcoe_t_fields,
    .desc = "The FP_COMPRESSION_SRC_FCOE specifies the compression map for source FCoE\n identifier. Compressed value can be assigned to a single or range of source\n FCoE identifier. Compressed value along with original source FCoE identifier\n are available in FP to match. Source identifier is a field in FCoE header.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_SRC_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_src_ipv4_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PIPE_MASKs,  /* PIPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PIPE.",
    },
    {
        .name  = VRFs,  /* VRF */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF to be matched in entry.",
    },
    {
        .name  = VRF_MASKs,  /* VRF_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address to be matched in entry.",
    },
    {
        .name  = SRC_IPV4_MASKs,  /* SRC_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for SRC_IPV4.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = COMPRESSED_SRC_IPV4s,  /* COMPRESSED_SRC_IPV4 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Compressed source IPv4 value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_src_ipv4_t = {
    .name = FP_COMPRESSION_SRC_IPV4s, /* FP_COMPRESSION_SRC_IPV4 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 8,
    .field = bcmltd_fp_compression_src_ipv4_t_fields,
    .desc = "The FP_COMPRESSION_SRC_IPV4 specifies the compression map for source IPv4\n address.\n Compressed value can be assigned to a single or range of source\n IPv4 addresses. Compressed value along with original source IPv4\n address are available in FP to match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_SRC_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_src_ipv6_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PIPE_MASKs,  /* PIPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PIPE.",
    },
    {
        .name  = VRFs,  /* VRF */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF to be matched in entry.",
    },
    {
        .name  = VRF_MASKs,  /* VRF_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address to be matched in entry.",
    },
    {
        .name  = SRC_IPV6_UPPER_MASKs,  /* SRC_IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for SRC_IPV6_UPPER.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = SRC_IPV6_LOWER_MASKs,  /* SRC_IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for SRC_IPV6_LOWER.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = COMPRESSED_SRC_IPV6s,  /* COMPRESSED_SRC_IPV6 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Compressed source IPv6 value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_src_ipv6_t = {
    .name = FP_COMPRESSION_SRC_IPV6s, /* FP_COMPRESSION_SRC_IPV6 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 10,
    .field = bcmltd_fp_compression_src_ipv6_t_fields,
    .desc = "The FP_COMPRESSION_SRC_IPV6 specifies the compression map for source IPv6\n address.\n Compressed value can be assigned to a single or range of source\n IPv6 addresses. Compressed value along with original source IPv6\n address are available in FP to match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_SRC_L4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_src_l4_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = FP_COMPRESSION_SRC_L4_IDs,  /* FP_COMPRESSION_SRC_L4_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "LT entry identifier.",
    },
    {
        .name  = SRC_L4_TYPEs,  /* SRC_L4_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Type of the entry.\n Type can be either\n SRC_L4_PORT (source L4 port and ICMP code) or\n FCOE_OX_ID\n",
    },
    {
        .name  = SRC_L4s,  /* SRC_L4 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source L4 Port/FCoE OX ID/ICMP Code to be\n matched in the entry.\n",
    },
    {
        .name  = COMPRESSED_SRC_L4s,  /* COMPRESSED_SRC_L4 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Compressed source L4 Port/FCoE OX ID/ICMP Code value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_src_l4_t = {
    .name = FP_COMPRESSION_SRC_L4s, /* FP_COMPRESSION_SRC_L4 */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_compression_src_l4_t_fields,
    .desc = "The FP_COMPRESSION_SRC_L4 specifies the compression map for frist two bytes in\n L4 header of IP packet or OX ID in FCoE Packet. In case of IP packet, field\n could be either L4 source port or ICMP code. Each entry in this LT\n will assign one compressed value to one original value.\n It is programming requirement to not have two different entries with\n same match value(SRC_L4) and entry type(SRC_L4_TYPE)\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_TCP_FLAGS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_tcp_flags_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = TCP_FLAGSs,  /* TCP_FLAGS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TCP flags value.",
    },
    {
        .name  = COMPRESSED_TCP_FLAGS_0s,  /* COMPRESSED_TCP_FLAGS_0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "First compressed TCP flags value.",
    },
    {
        .name  = COMPRESSED_TCP_FLAGS_1s,  /* COMPRESSED_TCP_FLAGS_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Second compressed TCP flags value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_tcp_flags_t = {
    .name = FP_COMPRESSION_TCP_FLAGSs, /* FP_COMPRESSION_TCP_FLAGS */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_compression_tcp_flags_t_fields,
    .desc = "The FP_COMPRESSION_TCP_FLAGS specifies the compression map for TCP flags\n value. Each entry in this LT will assign two compressed values to each TCP\n flags value. TCP flags value is the index to this LT. Two compressed IP flags\n values along with original IP flags value are available in FP to match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_COMPRESSION_TNL_IP_TTL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_compression_tnl_ip_ttl_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP tunnel outer TTL value.",
    },
    {
        .name  = COMPRESSED_TTLs,  /* COMPRESSED_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Compressed IP tunnel outer TTL value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_compression_tnl_ip_ttl_t = {
    .name = FP_COMPRESSION_TNL_IP_TTLs, /* FP_COMPRESSION_TNL_IP_TTL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_compression_tnl_ip_ttl_t_fields,
    .desc = "The FP_COMPRESSION_TNL_IP_TTL table specifies the compression map\n for the outer TTL of a terminating IP tunnel. Each entry in\n this logical table will assign one compressed value to each IP tunnel TTL.\n The compressed IP tunnel TTL values along with original\n IP tunnel TTL values are available in the FP to match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_config_t_fields[] = {
    {
        .name  = FP_ING_OPERMODEs,  /* FP_ING_OPERMODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FP_ING_OPERMODE_T_DATA,
        .desc = "The operating mode of ingress FP stage.\n The default value is set to 0 means global operating mode.\n This field can be set to any of the three modes as below during\n system initialization to use ingress FP stage to\n operate in that particular mode. This field cannot be modified during\n run runtime.\n\n      GLOBAL: Global operating mode with no INPORTS qualifier support\n      GLOBAL_PIPE_AWARE: Global pipe aware operating mode with INPORTS\n        qualifier support.\n      PIPE_UNIQUE: Pipe unique operating mode\n",
    },
    {
        .name  = FP_EM_OPERMODE_PIPEUNIQUEs,  /* FP_EM_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "The operating mode of exact match FP stage. The default value\n is set to FALSE means global operating mode. This field\n can be set to TRUE during system initialization to use\n Exact match FP stage in pipe unique operating mode. This\n field cannot be modified during runtime.\n",
    },
    {
        .name  = FP_VLAN_OPERMODE_PIPEUNIQUEs,  /* FP_VLAN_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "The operating mode of vlan FP stage. The default value\n is set to FALSE means global operating mode. This field\n can be set to TRUE during system initialization to use\n Vlan FP stage in pipe unique operating mode. This\n field cannot be modified during runtime.\n",
    },
    {
        .name  = FP_EGR_OPERMODE_PIPEUNIQUEs,  /* FP_EGR_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "The operating mode of Egress FP stage. The default value\n is set to FALSE means global operating mode. This field\n can be set to TRUE during system initialization to use\n Egress FP stage in pipe unique operating mode. This\n field cannot be modified during runtime.\n",
    },
    {
        .name  = FP_COMPRESSION_OPERMODE_PIPEUNIQUEs,  /* FP_COMPRESSION_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "The operating mode of FP Compression qualifiers. The default value\n is set to FALSE means global operating mode. This field\n can be set to TRUE during system initialization to use\n FP Compression qualifier in pipe unique operating mode. This\n field cannot be modified during runtime.\n",
    },
    {
        .name  = FP_ING_RANGE_CHECK_OPERMODE_PIPEUNIQUEs,  /* FP_ING_RANGE_CHECK_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "The operating mode of FP range check qualifier. The default value\n is set to FALSE means global operating mode. This field\n can be set to TRUE during system initialization to use\n FP range check qualifier in pipe unique operating mode. This\n field cannot be modified during runtime.\n",
    },
    {
        .name  = FP_ING_MANUAL_COMPs,  /* FP_ING_MANUAL_COMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable FP AACL compression.",
    },
    {
        .name  = FP_ING_COMP_SRC_IP4_ONLYs,  /* FP_ING_COMP_SRC_IP4_ONLY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to limit AACL compression to only the\n IPV4 source address.\n",
    },
    {
        .name  = FP_ING_COMP_DST_IP4_ONLYs,  /* FP_ING_COMP_DST_IP4_ONLY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to limit AACL compression to only the\n IPV4 destination address.\n",
    },
    {
        .name  = FP_ING_COMP_SRC_IP6_ONLYs,  /* FP_ING_COMP_SRC_IP6_ONLY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to limit AACL compression to only the\n IPV6 source address.\n",
    },
    {
        .name  = FP_ING_COMP_DST_IP6_ONLYs,  /* FP_ING_COMP_DST_IP6_ONLY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to limit AACL compression to only the\n IPV6 destination address.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_config_t = {
    .name = FP_CONFIGs, /* FP_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 11,
    .field = bcmltd_fp_config_t_fields,
    .desc = "FP_CONFIG shows the chip Level configuration parameters\n for different FP engines.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_control_t_fields[] = {
    {
        .name  = FP_ING_REDIRECT_EXCLUDE_SRCPORTs,  /* FP_ING_REDIRECT_EXCLUDE_SRCPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Exclude source port/trunk from ingress field processor\n redirection destination.\n",
    },
    {
        .name  = FP_ING_REDIRECT_EXCLUDE_HGSRCPORTs,  /* FP_ING_REDIRECT_EXCLUDE_HGSRCPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Exclude HiGiG source port/trunk from ingress field processor\n redirection destination.\n",
    },
    {
        .name  = FP_ING_REDIRECT_ING_VLANCHECKSs,  /* FP_ING_REDIRECT_ING_VLANCHECKS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ingress VLAN membership check for ingress field processor\n redirected traffic.\n",
    },
    {
        .name  = FP_ING_REDIRECT_NONUC_TRUNKRESOLVEs,  /* FP_ING_REDIRECT_NONUC_TRUNKRESOLVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable uniform distribution of non-unicast ingres field processor\n redirected traffic to ethernet port trunk.\n",
    },
    {
        .name  = FP_ING_REDIRECT_NONUC_HGTRUNKRESOLVEs,  /* FP_ING_REDIRECT_NONUC_HGTRUNKRESOLVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable uniform distribution of non-unicast ingress field processor\n redirected traffic to HiGiG trunk.\n",
    },
    {
        .name  = FP_ING_REDIRECT_PORT_FLOODBLOCKs,  /* FP_ING_REDIRECT_PORT_FLOODBLOCK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable port flood blocking policy for ingress field processor\n redirected traffic.\n",
    },
    {
        .name  = FP_ING_REDIRECT_VLAN_FLOODBLOCKs,  /* FP_ING_REDIRECT_VLAN_FLOODBLOCK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable VLAN flood blocking policy for ingress field processor\n redirected traffic.\n",
    },
    {
        .name  = FP_ING_ECMP_HASH_OFFSETs,  /* FP_ING_ECMP_HASH_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Configure offset for ECMP hash key. This configuration wil be used\n when packets are switched with action ACTION_ECMP_HASH.\n",
    },
    {
        .name  = FP_ING_ECMP_HASH_USE_CRCs,  /* FP_ING_ECMP_HASH_USE_CRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use CRC32 hash. If disabled XOR function will be used. This\n configuration will be used when packets are switched with action\n ACTION_ECMP_HASH.\n",
    },
    {
        .name  = FP_ING_ECMP_USE_UPPER_5_BITSs,  /* FP_ING_ECMP_USE_UPPER_5_BITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use most significant 5 bits of hash result. If disabled\n least significant 5 bits of hash result will be used. This\n configuration will be  used when packets are switched with action\n ACTION_ECMP_HASH.\n",
    },
    {
        .name  = FP_ING_ECMP_HASH_ENABLEs,  /* FP_ING_ECMP_HASH_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use action ACTION_ECMP_HASH in the field processor.\n",
    },
    {
        .name  = FP_ING_REDIRECT_NHI_EXCLUDE_SRCPORTs,  /* FP_ING_REDIRECT_NHI_EXCLUDE_SRCPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Exclude source port/trunk from ingress field processor\n redirection to NHI destination.\n",
    },
    {
        .name  = FP_VLAN_OVERRIDE_PHBs,  /* FP_VLAN_OVERRIDE_PHB */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "FB2 backward compatibility mode for L2/L3 lookup/DSCP priority override over VFP.\n",
    },
    {
        .name  = FP_ING_ARP_AS_IPs,  /* FP_ING_ARP_AS_IP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set ARP as IP packet for field processing.\n",
    },
    {
        .name  = FP_ING_RARP_AS_IPs,  /* FP_ING_RARP_AS_IP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set RARP as IP packet for field processing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_control_t = {
    .name = FP_CONTROLs, /* FP_CONTROL */
    .flags = 0,
    .fields = 15,
    .field = bcmltd_fp_control_t_fields,
    .desc = "The FP_CONTROL specifies the controls for different FP engines.\n This LT is normally configured at NET-OS init time.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_DELAYED_DROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_delayed_drop_t_fields[] = {
    {
        .name  = FP_DELAYED_DROP_IDs,  /* FP_DELAYED_DROP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the FP_DELAYED_DROP table.",
    },
    {
        .name  = ELEPHANT_PKTs,  /* ELEPHANT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable profile only for elephant flows.",
    },
    {
        .name  = EGR_PORT_IDs,  /* EGR_PORT_ID */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to drop packets for the specified egress ports.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_delayed_drop_t = {
    .name = FP_DELAYED_DROPs, /* FP_DELAYED_DROP */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_delayed_drop_t_fields,
    .desc = "The FP_DELAYED_DROP table specifies controls\n for setting the set of egress ports where a packet drop\n action needs to be performed.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_DELAYED_REDIRECT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_delayed_redirect_t_fields[] = {
    {
        .name  = FP_DELAYED_REDIRECT_IDs,  /* FP_DELAYED_REDIRECT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the FP_DELAYED_REDIRECT table.",
    },
    {
        .name  = ELEPHANT_PKTs,  /* ELEPHANT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable profile only for elephant flows.",
    },
    {
        .name  = EGR_PORT_IDs,  /* EGR_PORT_ID */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to redirect packets for the specified egress ports.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_delayed_redirect_t = {
    .name = FP_DELAYED_REDIRECTs, /* FP_DELAYED_REDIRECT */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_delayed_redirect_t_fields,
    .desc = "The FP_DELAYED_REDIRECT table specifies controls\n for setting the set of egress ports where a packet redirect\n action needs to be performed.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_DESTINATION_COS_Q_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_destination_cos_q_map_t_fields[] = {
    {
        .name  = FP_DESTINATION_COS_Q_MAP_IDs,  /* FP_DESTINATION_COS_Q_MAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FP_DESTINATION_COS_Q_MAP table.",
    },
    {
        .name  = UC_COSs,  /* UC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast COS queue value.",
    },
    {
        .name  = MC_COSs,  /* MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast COS queue value.",
    },
    {
        .name  = RQE_COSs,  /* RQE_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Replication queue engine (RQE) COS queue value.",
    },
    {
        .name  = CPU_COSs,  /* CPU_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "CPU COS queue value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_destination_cos_q_map_t = {
    .name = FP_DESTINATION_COS_Q_MAPs, /* FP_DESTINATION_COS_Q_MAP */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_destination_cos_q_map_t_fields,
    .desc = "The FP_DESTINATION_COS_Q_MAP specifies the controls to change the\n COS queue for unicast packets, multicast packets and packets\n destined to the replication queue engine (RQE).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_DESTINATION_COS_Q_STRENGTH_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_destination_cos_q_strength_profile_t_fields[] = {
    {
        .name  = FP_DESTINATION_COS_Q_STRENGTH_PROFILE_IDs,  /* FP_DESTINATION_COS_Q_STRENGTH_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Destination FP COS queue strength profile table index.",
    },
    {
        .name  = UC_COS_STRENGTHs,  /* UC_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast COS queue strength.",
    },
    {
        .name  = MC_COS_STRENGTHs,  /* MC_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast COS queue strength.",
    },
    {
        .name  = RQE_COS_STRENGTHs,  /* RQE_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Replication queue engine (RQE) COS queue strength.",
    },
    {
        .name  = CPU_COS_STRENGTHs,  /* CPU_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "CPU COS queue strength.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_destination_cos_q_strength_profile_t = {
    .name = FP_DESTINATION_COS_Q_STRENGTH_PROFILEs, /* FP_DESTINATION_COS_Q_STRENGTH_PROFILE */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_destination_cos_q_strength_profile_t_fields,
    .desc = "The FP_DESTINATION_COS_Q_STRENGTH_PROFILE table specifies the strength\n of the destination FP COS queues value relative to the COS queue values that\n may be specified by other entities such as PORT, ingress FP or TM.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EGR_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_egr_entry_t_fields[] = {
    {
        .name  = FP_EGR_ENTRY_IDs,  /* FP_EGR_ENTRY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Egress FP entry identifier.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operational state of the entry.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Priority associated with entry.",
    },
    {
        .name  = FP_EGR_GRP_TEMPLATE_IDs,  /* FP_EGR_GRP_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated group ID from FP_EGR_GROUP_TEMPLATE LT.",
    },
    {
        .name  = FP_EGR_RULE_TEMPLATE_IDs,  /* FP_EGR_RULE_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated rule ID from FP_EGR_RULE_TEMPLATE LT.",
    },
    {
        .name  = FP_EGR_POLICY_TEMPLATE_IDs,  /* FP_EGR_POLICY_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from FP_EGR_POLICY_TEMPLATE LT.",
    },
    {
        .name  = CTR_EGR_FP_ENTRY_IDs,  /* CTR_EGR_FP_ENTRY_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated counter ID to this entry.",
    },
    {
        .name  = METER_EGR_FP_TEMPLATE_IDs,  /* METER_EGR_FP_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated meter ID to this entry.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_fp_egr_entry_t = {
    .name = FP_EGR_ENTRYs, /* FP_EGR_ENTRY */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_fp_egr_entry_t_fields,
    .desc = "The FP_EGR_ENTRY associates the group ID, rule ID, policy ID, counter ID and\n meter ID to the entries in the group. Operations on this logical table will\n provision the device EFP logic, if sufficient resources are available.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EGR_GRP_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_egr_grp_template_t_fields[] = {
    {
        .name  = FP_EGR_GRP_TEMPLATE_IDs,  /* FP_EGR_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Group priority. Used to resolve conflicting actions when packet\n hits rules from different groups.\n",
    },
    {
        .name  = AUTO_EXPANDs,  /* AUTO_EXPAND */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to disable auto expansion of the group.\n",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Configured mode for group\n This can be set to one of the following strings.\n        L2_SINGLE_WIDE\n        L3_SINGLE_WIDE\n        L3_DOUBLE_WIDE\n        L3_ANY_SINGLE_WIDE\n        L3_ANY_DOUBLE_WIDE\n        L3_ALT_DOUBLE_WIDE\n",
    },
    {
        .name  = PORT_PKT_TYPEs,  /* PORT_PKT_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Configured port packet type. This can be set to one of the following\n strings.\n        PORT_ANY_PACKET_IPV4\n        PORT_ANY_PACKET_IPV6\n        PORT_ANY_PACKET_IP\n        PORT_HIGIG_PACKET_ANY\n        PORT_FRONT_PACKET_ANY\n        PORT_ANY_PACKET_NONIP\n        PORT_ANY_PACKET_ANY\n",
    },
    {
        .name  = VIRTUAL_SLICE_GRPs,  /* VIRTUAL_SLICE_GRP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Virtual slice group.\n Field groups created with same virtual slice group\n will be under one virtual group set.\n Policy resolution among groups in a virtual group set\n will result in policy (actions, counter and meter) belonging to\n higher priority group in the virtual group set.\n Policy resolution among different virtual group sets\n will result in combined counter, non-conflicting actions\n from all virtual group sets and for conflicting actions group\n with the highest priority will take precedence across\n all such virtual group sets.\n Allowed values [0 to number of slices-1].\n",
    },
    {
        .name  = QUAL_BYTES_0_7_AFTER_L2HEADERs,  /* QUAL_BYTES_0_7_AFTER_L2HEADER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on first 8 bytes after L2 header as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_BYTES_8_15_AFTER_L2HEADERs,  /* QUAL_BYTES_8_15_AFTER_L2HEADER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on bytes 8_15 after L2 header as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_BYTES_16_17_AFTER_L2HEADERs,  /* QUAL_BYTES_16_17_AFTER_L2HEADER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on bytes 16_17 after L2 header as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_COLORs,  /* QUAL_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet color.",
    },
    {
        .name  = QUAL_CPU_COSs,  /* QUAL_CPU_COS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet CPU cos queue value.",
    },
    {
        .name  = QUAL_DROP_PKTs,  /* QUAL_DROP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet is flagged to be dropped.",
    },
    {
        .name  = QUAL_DST_IP4s,  /* QUAL_DST_IP4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = QUAL_DST_IP6s,  /* QUAL_DST_IP6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Destination IPV6 address.",
    },
    {
        .name  = QUAL_DST_IP6_HIGHs,  /* QUAL_DST_IP6_HIGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Destination IPv6 address (High/Upper 64 bits).",
    },
    {
        .name  = QUAL_DST_MACs,  /* QUAL_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = QUAL_DST_VP_VALIDs,  /* QUAL_DST_VP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if destination VP valid.",
    },
    {
        .name  = QUAL_DST_VPs,  /* QUAL_DST_VP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "DVP.",
    },
    {
        .name  = QUAL_EGR_L3_IIF_CLASS_IDs,  /* QUAL_EGR_L3_IIF_CLASS_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Class ID assigned by egress interface.",
    },
    {
        .name  = QUAL_UNDERLAY_EGR_L3_IIF_CLASS_IDs,  /* QUAL_UNDERLAY_EGR_L3_IIF_CLASS_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Class ID assigned by underlay egress interface.",
    },
    {
        .name  = QUAL_EGR_NHOP_CLASS_IDs,  /* QUAL_EGR_NHOP_CLASS_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Class ID assigned by next hop.",
    },
    {
        .name  = QUAL_UNDERLAY_EGR_NHOP_CLASS_IDs,  /* QUAL_UNDERLAY_EGR_NHOP_CLASS_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Class ID assigned by underlay next hop.",
    },
    {
        .name  = QUAL_EGR_DVP_CLASS_IDs,  /* QUAL_EGR_DVP_CLASS_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Class ID assigned by DVP.",
    },
    {
        .name  = QUAL_ETHERTYPEs,  /* QUAL_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = QUAL_FWD_TYPEs,  /* QUAL_FWD_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet forwarding type.",
    },
    {
        .name  = QUAL_FWD_VLAN_IDs,  /* QUAL_FWD_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Forwarding VLAN ID.",
    },
    {
        .name  = QUAL_ICMP_TYPE_CODEs,  /* QUAL_ICMP_TYPE_CODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "ICMP type code.",
    },
    {
        .name  = QUAL_INNER_VLAN_CFIs,  /* QUAL_INNER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = QUAL_INNER_VLAN_IDs,  /* QUAL_INNER_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = QUAL_INNER_VLAN_PRIs,  /* QUAL_INNER_VLAN_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN Priority.",
    },
    {
        .name  = QUAL_LOOPBACK_PP_PORTs,  /* QUAL_LOOPBACK_PP_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Loopback packet processing port.",
    },
    {
        .name  = QUAL_LOOPBACK_TRAFFIC_CLASSs,  /* QUAL_LOOPBACK_TRAFFIC_CLASS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Loopback traffic class.",
    },
    {
        .name  = QUAL_LOOPBACK_COLORs,  /* QUAL_LOOPBACK_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Loopback packet color.",
    },
    {
        .name  = QUAL_LOOPBACK_MASQUERADE_PKT_PROFILEs,  /* QUAL_LOOPBACK_MASQUERADE_PKT_PROFILE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Points to the masquerade packet profile.",
    },
    {
        .name  = QUAL_VISIBILITY_PKTs,  /* QUAL_VISIBILITY_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Visibility packet.",
    },
    {
        .name  = QUAL_LOOPBACK_SRC_PORTs,  /* QUAL_LOOPBACK_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Loopback source port.",
    },
    {
        .name  = QUAL_LOOPBACK_TYPEs,  /* QUAL_LOOPBACK_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Loopback type.",
    },
    {
        .name  = QUAL_LOOPBACK_QUEUEs,  /* QUAL_LOOPBACK_QUEUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Loopback queue.",
    },
    {
        .name  = QUAL_INPORTs,  /* QUAL_INPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Single input port.",
    },
    {
        .name  = QUAL_EGR_DVPs,  /* QUAL_EGR_DVP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Egress DVP.",
    },
    {
        .name  = QUAL_EGR_DVP_GROUP_IDs,  /* QUAL_EGR_DVP_GROUP_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Egress DVP group ID.",
    },
    {
        .name  = QUAL_INT_CNs,  /* QUAL_INT_CN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Internal congestion.",
    },
    {
        .name  = QUAL_INT_PRIs,  /* QUAL_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Internal priority of packet.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_PROTOs,  /* QUAL_IP_FIRST_EH_PROTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Next header field in first header extension header.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_SUBCODEs,  /* QUAL_IP_FIRST_EH_SUBCODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "First byte after the extension header length field.",
    },
    {
        .name  = QUAL_IP_FRAGs,  /* QUAL_IP_FRAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on the IP fragment flag in the IP header as specified\n in the rule template entries that are associated with FP entries\n which reference this group template.\n",
    },
    {
        .name  = QUAL_IP_PROTOCOLs,  /* QUAL_IP_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IP protocol.",
    },
    {
        .name  = QUAL_L2_FORMATs,  /* QUAL_L2_FORMAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "L2 packet format",
    },
    {
        .name  = QUAL_ING_CLASS_ID_TYPEs,  /* QUAL_ING_CLASS_ID_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Ingress class ID type",
    },
    {
        .name  = QUAL_ING_CLASS_IDs,  /* QUAL_ING_CLASS_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Class ID assigned by the ingress field processor.",
    },
    {
        .name  = QUAL_L3_ROUTABLE_PKTs,  /* QUAL_L3_ROUTABLE_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet is L3 routable status.",
    },
    {
        .name  = QUAL_IP_TYPEs,  /* QUAL_IP_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IP Type.",
    },
    {
        .name  = QUAL_L4DST_PORTs,  /* QUAL_L4DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "L4 header destination port.",
    },
    {
        .name  = QUAL_L4SRC_PORTs,  /* QUAL_L4SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "L4 header source port.",
    },
    {
        .name  = QUAL_L4_PKTs,  /* QUAL_L4_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "L4 packet (has Valid L4 source and destination port).",
    },
    {
        .name  = QUAL_SRV6_SRH_PKTs,  /* QUAL_SRV6_SRH_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IPv6 segment routing header.",
    },
    {
        .name  = QUAL_MIRR_COPYs,  /* QUAL_MIRR_COPY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mirror copy.",
    },
    {
        .name  = QUAL_OUTER_VLAN_CFIs,  /* QUAL_OUTER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = QUAL_OUTER_VLAN_IDs,  /* QUAL_OUTER_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = QUAL_OUTER_VLAN_PRIs,  /* QUAL_OUTER_VLAN_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN Priority.",
    },
    {
        .name  = QUAL_OUTPORTs,  /* QUAL_OUTPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Single Out Port.",
    },
    {
        .name  = QUAL_SRC_IP4s,  /* QUAL_SRC_IP4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = QUAL_SRC_IP6s,  /* QUAL_SRC_IP6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Source IPv6 Address.",
    },
    {
        .name  = QUAL_SRC_IP6_HIGHs,  /* QUAL_SRC_IP6_HIGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Source IPv6 Address (High/Upper 64 bits).",
    },
    {
        .name  = QUAL_SRC_MACs,  /* QUAL_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASSs,  /* QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Class ID from PORT_FP.",
    },
    {
        .name  = QUAL_TCP_FLAGSs,  /* QUAL_TCP_FLAGS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "TCP control flags.",
    },
    {
        .name  = QUAL_TOSs,  /* QUAL_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet TOS.",
    },
    {
        .name  = QUAL_TTLs,  /* QUAL_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet TTL.",
    },
    {
        .name  = QUAL_VLAN_INNER_PRESENTs,  /* QUAL_VLAN_INNER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet inner VLAN tag status.",
    },
    {
        .name  = QUAL_VLAN_OUTER_PRESENTs,  /* QUAL_VLAN_OUTER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet outer VLAN tag status.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_PRESENTs,  /* QUAL_OPAQUE_TAG_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet opaque tag status.",
    },
    {
        .name  = QUAL_VPNs,  /* QUAL_VPN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "VPN.",
    },
    {
        .name  = QUAL_VRFs,  /* QUAL_VRF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "VRF.",
    },
    {
        .name  = QUAL_VXLT_LOOKUP_HITs,  /* QUAL_VXLT_LOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "First/Second/All/None lookup hit for VLAN translation",
    },
    {
        .name  = QUAL_SFLOW_SAMPLEDs,  /* QUAL_SFLOW_SAMPLED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to qualify on sFlow sampling status",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_fp_egr_grp_template_t = {
    .name = FP_EGR_GRP_TEMPLATEs, /* FP_EGR_GRP_TEMPLATE */
    .flags = 0,
    .fields = 78,
    .field = bcmltd_fp_egr_grp_template_t_fields,
    .desc = "The FP_EGR_GRP_TEMPLATE table specifies the group configuration in the egress\n field processor stage.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EGR_GRP_TEMPLATE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_egr_grp_template_info_t_fields[] = {
    {
        .name  = FP_EGR_GRP_TEMPLATE_IDs,  /* FP_EGR_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Egress FP group template ID.",
    },
    {
        .name  = HW_LTIDs,  /* HW_LTID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hardware logical table ID used in action resolution or partition\n resolution in case of group auto expansion. This logical table ID is\n different from the SDKLT logical table ID. Priority can be assigned to\n the hardware logical table ID and is used to resolve conflicting\n actions when a packet matches FP entries from two different FP groups.\n",
    },
    {
        .name  = NUM_ENTRIES_CREATEDs,  /* NUM_ENTRIES_CREATED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries created in this group.",
    },
    {
        .name  = NUM_ENTRIES_TENTATIVEs,  /* NUM_ENTRIES_TENTATIVE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries that can be created in this group.",
    },
    {
        .name  = NUM_PARTITION_IDs,  /* NUM_PARTITION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of partitions(a.k.a physical slices) used for groups width\n expansion.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_egr_grp_template_info_t = {
    .name = FP_EGR_GRP_TEMPLATE_INFOs, /* FP_EGR_GRP_TEMPLATE_INFO */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_egr_grp_template_info_t_fields,
    .desc = "The FP_EGR_GRP_TEMPLATE_INFO table provides FP group-specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EGR_GRP_TEMPLATE_PARTITION_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_egr_grp_template_partition_info_t_fields[] = {
    {
        .name  = FP_EGR_GRP_TEMPLATE_IDs,  /* FP_EGR_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP group template ID.",
    },
    {
        .name  = PARTITION_IDs,  /* PARTITION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Partition ID.",
    },
    {
        .name  = NUM_SLICE_IDs,  /* NUM_SLICE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of slices to which a group is auto expanded.\n This field specifies\n the number of valid indexes in the SLICE_ID arrays of partitions.\n",
    },
    {
        .name  = SLICE_IDs,  /* SLICE_ID */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Physical slice IDs allocated for the group in the order of expansion\n in the given partition ID.\n",
    },
    {
        .name  = VIRTUAL_SLICE_IDs,  /* VIRTUAL_SLICE_ID */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Virtual slice IDs allocated for the group in the order of expansion\n in the given partition ID.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_egr_grp_template_partition_info_t = {
    .name = FP_EGR_GRP_TEMPLATE_PARTITION_INFOs, /* FP_EGR_GRP_TEMPLATE_PARTITION_INFO */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_egr_grp_template_partition_info_t_fields,
    .desc = "The FP_EGR_GRP_TEMPLATE_PARTITION_INFO table provides\n FP group partition specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EGR_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_egr_info_t_fields[] = {
    {
        .name  = NUM_SLICESs,  /* NUM_SLICES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of slices.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_egr_info_t = {
    .name = FP_EGR_INFOs, /* FP_EGR_INFO */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_fp_egr_info_t_fields,
    .desc = "The FP_EGR_INFO table provides egress FP stage-specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EGR_POLICY_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_egr_policy_template_t_fields[] = {
    {
        .name  = FP_EGR_POLICY_TEMPLATE_IDs,  /* FP_EGR_POLICY_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Egress FP policy identifier.",
    },
    {
        .name  = ACTION_DROPs,  /* ACTION_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop packets.",
    },
    {
        .name  = ACTION_R_DROPs,  /* ACTION_R_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop red packets.",
    },
    {
        .name  = ACTION_DROP_CANCELs,  /* ACTION_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule.",
    },
    {
        .name  = ACTION_R_DROP_CANCELs,  /* ACTION_R_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for red packets.",
    },
    {
        .name  = ACTION_NEW_DSCPs,  /* ACTION_NEW_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Change DSCP to a new value.",
    },
    {
        .name  = ACTION_DSCP_MASKs,  /* ACTION_DSCP_MASK */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Remove some bits from the packet's DSCP.",
    },
    {
        .name  = ACTION_R_NEW_DSCPs,  /* ACTION_R_NEW_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Change DSCP to a new value for red packets.",
    },
    {
        .name  = ACTION_NEW_ECNs,  /* ACTION_NEW_ECN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change ECN.",
    },
    {
        .name  = ACTION_ECN_MASKs,  /* ACTION_ECN_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Remove bits from the packet's ECN",
    },
    {
        .name  = ACTION_R_NEW_ECNs,  /* ACTION_R_NEW_ECN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change ECN for red packets.",
    },
    {
        .name  = ACTION_Y_DROPs,  /* ACTION_Y_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop yellow packets.",
    },
    {
        .name  = ACTION_Y_DROP_CANCELs,  /* ACTION_Y_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for yellow packets.",
    },
    {
        .name  = ACTION_Y_NEW_DSCPs,  /* ACTION_Y_NEW_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Change DSCP to a new value for yellow packets.",
    },
    {
        .name  = ACTION_Y_NEW_ECNs,  /* ACTION_Y_NEW_ECN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change ECN for yellow packets.",
    },
    {
        .name  = ACTION_G_DROPs,  /* ACTION_G_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop green packets.",
    },
    {
        .name  = ACTION_G_DROP_CANCELs,  /* ACTION_G_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for green packets.",
    },
    {
        .name  = ACTION_G_NEW_DSCPs,  /* ACTION_G_NEW_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Change DSCP to a new value for green packets.",
    },
    {
        .name  = ACTION_G_NEW_ECNs,  /* ACTION_G_NEW_ECN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change ECN for green packets.",
    },
    {
        .name  = ACTION_NEW_INNER_VLANIDs,  /* ACTION_NEW_INNER_VLANID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Change inner VLAN ID to a new value",
    },
    {
        .name  = ACTION_NEW_OUTER_VLANIDs,  /* ACTION_NEW_OUTER_VLANID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Change outer VLAN ID to a new value",
    },
    {
        .name  = ACTION_NEW_OUTER_TPIDs,  /* ACTION_NEW_OUTER_TPID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change outer TPID to a new value",
    },
    {
        .name  = ACTION_NEW_OUTER_DOT1Ps,  /* ACTION_NEW_OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change outer VLAN tags dot1p bits to new value.",
    },
    {
        .name  = ACTION_R_NEW_OUTER_DOT1Ps,  /* ACTION_R_NEW_OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change outer VLAN tags dot1p bits to new value for red packets.",
    },
    {
        .name  = ACTION_Y_NEW_OUTER_DOT1Ps,  /* ACTION_Y_NEW_OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change outer VLAN tags dot1p bits to new value for red packets.",
    },
    {
        .name  = ACTION_G_NEW_OUTER_DOT1Ps,  /* ACTION_G_NEW_OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change outer VLAN tags dot1p bits to new value for green packets.",
    },
    {
        .name  = ACTION_R_NEW_INNER_PRIs,  /* ACTION_R_NEW_INNER_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change inner VLAN tags dot1p bits to new value for red packets.",
    },
    {
        .name  = ACTION_Y_NEW_INNER_PRIs,  /* ACTION_Y_NEW_INNER_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change inner VLAN tags dot1p bits to new value for red packets.",
    },
    {
        .name  = ACTION_G_NEW_INNER_PRIs,  /* ACTION_G_NEW_INNER_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change inner VLAN tags dot1p bits to new value for green packets.",
    },
    {
        .name  = ACTION_NEW_OUTER_CFIs,  /* ACTION_NEW_OUTER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Replace outer 802.1p CFI with a new one.",
    },
    {
        .name  = ACTION_R_NEW_OUTER_CFIs,  /* ACTION_R_NEW_OUTER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Replace red packet outer 802.1p CFI with a new one.",
    },
    {
        .name  = ACTION_Y_NEW_OUTER_CFIs,  /* ACTION_Y_NEW_OUTER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Replace yellow packet outer 802.1p CFI with a new one.",
    },
    {
        .name  = ACTION_G_NEW_OUTER_CFIs,  /* ACTION_G_NEW_OUTER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Replace green packet outer 802.1p CFI with a new one.",
    },
    {
        .name  = ACTION_R_NEW_INNER_CFIs,  /* ACTION_R_NEW_INNER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Replace red packet inner 802.1p CFI with a new one.",
    },
    {
        .name  = ACTION_Y_NEW_INNER_CFIs,  /* ACTION_Y_NEW_INNER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Replace yellow packet inner 802.1p CFI with a new one.",
    },
    {
        .name  = ACTION_G_NEW_INNER_CFIs,  /* ACTION_G_NEW_INNER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Replace green packet inner 802.1p CFI with a new one.",
    },
    {
        .name  = ACTION_SET_VXLAN_HEADER_8_31s,  /* ACTION_SET_VXLAN_HEADER_8_31 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Set VXLAN header bytes from 8-31",
    },
    {
        .name  = ACTION_SET_VXLAN_HEADER_56_63s,  /* ACTION_SET_VXLAN_HEADER_56_63 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Set VXLAN header bytes from 56-63",
    },
    {
        .name  = ACTION_SET_VXLAN_FLAGSs,  /* ACTION_SET_VXLAN_FLAGS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set VXLAN flags",
    },
    {
        .name  = CTR_EGR_EFLEX_OBJECTs,  /* CTR_EGR_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter object.",
    },
    {
        .name  = ACTION_NEW_MPLS_EXPs,  /* ACTION_NEW_MPLS_EXP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change MPLS EXP.",
    },
    {
        .name  = ACTION_NEW_LOOPBACK_PACKET_PROFILEs,  /* ACTION_NEW_LOOPBACK_PACKET_PROFILE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change loopback packet profile.",
    },
    {
        .name  = ACTION_NEW_LOOPBACK_PP_PORTs,  /* ACTION_NEW_LOOPBACK_PP_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Change loopback packet processing port.",
    },
    {
        .name  = ACTION_NEW_LOOPBACK_SRC_PORTs,  /* ACTION_NEW_LOOPBACK_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Change loopback source port.",
    },
    {
        .name  = ACTION_NEW_LOOPBACK_TYPEs,  /* ACTION_NEW_LOOPBACK_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change loopback type.",
    },
    {
        .name  = ACTION_LATENCY_MONITOR_ENABLEs,  /* ACTION_LATENCY_MONITOR_ENABLE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enable latency monitor for the monitor IDs set.\n Bit 0 - Monitor ID 0\n Bit 1 - Monitor ID 1\n Bit 2 - Monitor ID 2\n Bit 3 - Monitor ID 3\n",
    },
    {
        .name  = ACTION_LATENCY_MONITOR_DISABLEs,  /* ACTION_LATENCY_MONITOR_DISABLE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Disable latency monitor for the monitor IDs set.\n Bit 0 - Monitor ID 0\n Bit 1 - Monitor ID 1\n Bit 2 - Monitor ID 2\n Bit 3 - Monitor ID 3\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_egr_policy_template_t = {
    .name = FP_EGR_POLICY_TEMPLATEs, /* FP_EGR_POLICY_TEMPLATE */
    .flags = 0,
    .fields = 47,
    .field = bcmltd_fp_egr_policy_template_t_fields,
    .desc = "The FP_EGR_POLICY_TEMPLATE specifies the egress FP policy that can be\n attached to an egress FP entry.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EGR_RULE_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_egr_rule_template_t_fields[] = {
    {
        .name  = FP_EGR_RULE_TEMPLATE_IDs,  /* FP_EGR_RULE_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Egress FP rule identifier.",
    },
    {
        .name  = QUAL_EGR_NHOP_CLASS_IDs,  /* QUAL_EGR_NHOP_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for class ID assigned by next hop",
    },
    {
        .name  = QUAL_EGR_NHOP_CLASS_ID_MASKs,  /* QUAL_EGR_NHOP_CLASS_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask for QUAL_EGR_NHOP_CLASS_ID",
    },
    {
        .name  = QUAL_EGR_L3_IIF_CLASS_IDs,  /* QUAL_EGR_L3_IIF_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID assigned by egress interface",
    },
    {
        .name  = QUAL_EGR_L3_IIF_CLASS_ID_MASKs,  /* QUAL_EGR_L3_IIF_CLASS_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask for QUAL_EGR_L3_IIF_CLASS_ID",
    },
    {
        .name  = QUAL_UNDERLAY_EGR_NHOP_CLASS_IDs,  /* QUAL_UNDERLAY_EGR_NHOP_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for class ID assigned by underlay next hop",
    },
    {
        .name  = QUAL_UNDERLAY_EGR_NHOP_CLASS_ID_MASKs,  /* QUAL_UNDERLAY_EGR_NHOP_CLASS_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask for QUAL_UNDERLAY_EGR_NHOP_CLASS_ID",
    },
    {
        .name  = QUAL_UNDERLAY_EGR_L3_IIF_CLASS_IDs,  /* QUAL_UNDERLAY_EGR_L3_IIF_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID assigned by egress interface",
    },
    {
        .name  = QUAL_UNDERLAY_EGR_L3_IIF_CLASS_ID_MASKs,  /* QUAL_UNDERLAY_EGR_L3_IIF_CLASS_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask for QUAL_UNDERLAY_EGR_L3_IIF_CLASS_ID",
    },
    {
        .name  = QUAL_EGR_DVP_CLASS_IDs,  /* QUAL_EGR_DVP_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID assigned by DVP",
    },
    {
        .name  = QUAL_EGR_DVP_CLASS_ID_MASKs,  /* QUAL_EGR_DVP_CLASS_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask for QUAL_EGR_DVP_CLASS_ID",
    },
    {
        .name  = QUAL_L4_PKTs,  /* QUAL_L4_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L4 packet (Valid L4 Src and dest port).",
    },
    {
        .name  = QUAL_L4_PKT_MASKs,  /* QUAL_L4_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L4_PKT.",
    },
    {
        .name  = QUAL_SRV6_SRH_PKTs,  /* QUAL_SRV6_SRH_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet with IPv6 segment routing header.",
    },
    {
        .name  = QUAL_SRV6_SRH_PKT_MASKs,  /* QUAL_SRV6_SRH_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRV6_SRH.",
    },
    {
        .name  = QUAL_DST_VP_VALIDs,  /* QUAL_DST_VP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if destination VP valid.",
    },
    {
        .name  = QUAL_DST_VP_VALID_MASKs,  /* QUAL_DST_VP_VALID_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_DST_VP_VALID.",
    },
    {
        .name  = QUAL_DST_VPs,  /* QUAL_DST_VP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for destination VP (DVP).",
    },
    {
        .name  = QUAL_DST_VP_MASKs,  /* QUAL_DST_VP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_VP",
    },
    {
        .name  = QUAL_INT_PRIs,  /* QUAL_INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Qualifier for Internal Priority of packet.",
    },
    {
        .name  = QUAL_INT_PRI_MASKs,  /* QUAL_INT_PRI_MASK */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INT_PRI.",
    },
    {
        .name  = QUAL_COLORs,  /* QUAL_COLOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for packet Color.",
    },
    {
        .name  = QUAL_L2_FORMATs,  /* QUAL_L2_FORMAT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for L2 format in packet.",
    },
    {
        .name  = QUAL_ETHERTYPEs,  /* QUAL_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for ethertype.",
    },
    {
        .name  = QUAL_ETHERTYPE_MASKs,  /* QUAL_ETHERTYPE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_ETHERTYPE.",
    },
    {
        .name  = QUAL_SRC_MACs,  /* QUAL_SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier for source MAC address.",
    },
    {
        .name  = QUAL_SRC_MAC_MASKs,  /* QUAL_SRC_MAC_MASK */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_MAC.",
    },
    {
        .name  = QUAL_DST_MACs,  /* QUAL_DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier for destination MAC address.",
    },
    {
        .name  = QUAL_DST_MAC_MASKs,  /* QUAL_DST_MAC_MASK */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_MAC.",
    },
    {
        .name  = QUAL_VXLT_LOOKUP_HITs,  /* QUAL_VXLT_LOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Look up hit for VLAN tranlation",
    },
    {
        .name  = QUAL_VXLT_LOOKUP_HIT_MASKs,  /* QUAL_VXLT_LOOKUP_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VXLT_LOOKUP_HIT.",
    },
    {
        .name  = QUAL_INNER_VLAN_CFIs,  /* QUAL_INNER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for inner VLAN CFI.",
    },
    {
        .name  = QUAL_INNER_VLAN_CFI_MASKs,  /* QUAL_INNER_VLAN_CFI_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_VLAN_CFI.",
    },
    {
        .name  = QUAL_INNER_VLAN_PRIs,  /* QUAL_INNER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier for inner VLAN Priority.",
    },
    {
        .name  = QUAL_INNER_VLAN_PRI_MASKs,  /* QUAL_INNER_VLAN_PRI_MASK */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_VLAN_PRI.",
    },
    {
        .name  = QUAL_INNER_VLAN_IDs,  /* QUAL_INNER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier for inner VLAN ID.",
    },
    {
        .name  = QUAL_INNER_VLAN_ID_MASKs,  /* QUAL_INNER_VLAN_ID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_VLAN_ID.",
    },
    {
        .name  = QUAL_LOOPBACK_PP_PORTs,  /* QUAL_LOOPBACK_PP_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for loopback packet processing port.",
    },
    {
        .name  = QUAL_LOOPBACK_PP_PORT_MASKs,  /* QUAL_LOOPBACK_PP_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_LOOPBACK_PP_PORT.",
    },
    {
        .name  = QUAL_LOOPBACK_TRAFFIC_CLASSs,  /* QUAL_LOOPBACK_TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for loopback traffic class.",
    },
    {
        .name  = QUAL_LOOPBACK_TRAFFIC_CLASS_MASKs,  /* QUAL_LOOPBACK_TRAFFIC_CLASS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_LOOPBACK_TRAFFIC_CLASS.",
    },
    {
        .name  = QUAL_LOOPBACK_COLORs,  /* QUAL_LOOPBACK_COLOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for loopback packet color.",
    },
    {
        .name  = QUAL_LOOPBACK_MASQUERADE_PKT_PROFILEs,  /* QUAL_LOOPBACK_MASQUERADE_PKT_PROFILE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for pointer to masquerade packet profile.",
    },
    {
        .name  = QUAL_LOOPBACK_MASQUERADE_PKT_PROFILE_MASKs,  /* QUAL_LOOPBACK_MASQUERADE_PKT_PROFILE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_LOOPBACK_MASQUERADE_PKT_PROFILE.",
    },
    {
        .name  = QUAL_VISIBILITY_PKTs,  /* QUAL_VISIBILITY_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for visiblity packet.",
    },
    {
        .name  = QUAL_VISIBILITY_PKT_MASKs,  /* QUAL_VISIBILITY_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VISIBILITY_PKT.",
    },
    {
        .name  = QUAL_LOOPBACK_SRC_PORTs,  /* QUAL_LOOPBACK_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for loopback source port.",
    },
    {
        .name  = QUAL_LOOPBACK_SRC_PORT_MASKs,  /* QUAL_LOOPBACK_SRC_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_LOOPBACK_SRC_PORT.",
    },
    {
        .name  = QUAL_LOOPBACK_TYPEs,  /* QUAL_LOOPBACK_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for loopback type.",
    },
    {
        .name  = QUAL_LOOPBACK_QUEUEs,  /* QUAL_LOOPBACK_QUEUE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for loopback queue.",
    },
    {
        .name  = QUAL_LOOPBACK_QUEUE_MASKs,  /* QUAL_LOOPBACK_QUEUE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_LOOPBACK_QUEUE.",
    },
    {
        .name  = QUAL_INPORTs,  /* QUAL_INPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for inport.",
    },
    {
        .name  = QUAL_INPORT_MASKs,  /* QUAL_INPORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INPORT.",
    },
    {
        .name  = QUAL_EGR_DVPs,  /* QUAL_EGR_DVP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for egress destination virtual port .",
    },
    {
        .name  = QUAL_EGR_DVP_MASKs,  /* QUAL_EGR_DVP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_EGR_DVP.",
    },
    {
        .name  = QUAL_EGR_DVP_GROUP_IDs,  /* QUAL_EGR_DVP_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for egress destination virtual port group ID .",
    },
    {
        .name  = QUAL_EGR_DVP_GROUP_ID_MASKs,  /* QUAL_EGR_DVP_GROUP_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_EGR_DVP_GROUP_ID.",
    },
    {
        .name  = QUAL_L3_ROUTABLE_PKTs,  /* QUAL_L3_ROUTABLE_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet is L3 routable status.",
    },
    {
        .name  = QUAL_L3_ROUTABLE_PKT_MASKs,  /* QUAL_L3_ROUTABLE_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_ROUTABLE_PKT.",
    },
    {
        .name  = QUAL_OUTER_VLAN_IDs,  /* QUAL_OUTER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier for outer VLAN ID.",
    },
    {
        .name  = QUAL_OUTER_VLAN_ID_MASKs,  /* QUAL_OUTER_VLAN_ID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OUTER_VLAN_ID.",
    },
    {
        .name  = QUAL_OUTER_VLAN_CFIs,  /* QUAL_OUTER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for outer VLAN CFI.",
    },
    {
        .name  = QUAL_OUTER_VLAN_CFI_MASKs,  /* QUAL_OUTER_VLAN_CFI_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OUTER_VLAN_CFI.",
    },
    {
        .name  = QUAL_OUTER_VLAN_PRIs,  /* QUAL_OUTER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier for outer VLAN Priority.\n  Qualifies on priority value set in field NEW_PRI\n  which is a part of PHB_ING_L2_OTAG_REMAP LT.\n",
    },
    {
        .name  = QUAL_OUTER_VLAN_PRI_MASKs,  /* QUAL_OUTER_VLAN_PRI_MASK */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OUTER_VLAN_PRI.",
    },
    {
        .name  = QUAL_VLAN_INNER_PRESENTs,  /* QUAL_VLAN_INNER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if inner VLAN Present in packet.",
    },
    {
        .name  = QUAL_VLAN_INNER_PRESENT_MASKs,  /* QUAL_VLAN_INNER_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VLAN_INNER_PRESENT.",
    },
    {
        .name  = QUAL_VLAN_OUTER_PRESENTs,  /* QUAL_VLAN_OUTER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if outer VLAN Present in packet.",
    },
    {
        .name  = QUAL_VLAN_OUTER_PRESENT_MASKs,  /* QUAL_VLAN_OUTER_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_VLAN_OUTER_PRESENT.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_PRESENTs,  /* QUAL_OPAQUE_TAG_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet opaque tag status.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_PRESENT_MASKs,  /* QUAL_OPAQUE_TAG_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OPAQUE_TAG_PRESENT.",
    },
    {
        .name  = QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASSs,  /* QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for PORT_FP class ID.",
    },
    {
        .name  = QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS_MASKs,  /* QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS.",
    },
    {
        .name  = QUAL_ING_CLASS_ID_TYPEs,  /* QUAL_ING_CLASS_ID_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier to mention the ingress FP class ID type",
    },
    {
        .name  = QUAL_ING_CLASS_IDs,  /* QUAL_ING_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for ingress FP class ID.",
    },
    {
        .name  = QUAL_ING_CLASS_ID_MASKs,  /* QUAL_ING_CLASS_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_ING_CLASS_ID",
    },
    {
        .name  = QUAL_OUTPORTs,  /* QUAL_OUTPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for outport.",
    },
    {
        .name  = QUAL_OUTPORT_MASKs,  /* QUAL_OUTPORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OUTPORT.",
    },
    {
        .name  = QUAL_CPU_COSs,  /* QUAL_CPU_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for CPU COS queue value.",
    },
    {
        .name  = QUAL_CPU_COS_MASKs,  /* QUAL_CPU_COS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_CPU_COS_MASK.",
    },
    {
        .name  = QUAL_IP_TYPEs,  /* QUAL_IP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for IP type in packet.",
    },
    {
        .name  = QUAL_FWD_VLAN_IDs,  /* QUAL_FWD_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier for forwarding VLAN ID.",
    },
    {
        .name  = QUAL_FWD_VLAN_ID_MASKs,  /* QUAL_FWD_VLAN_ID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_FWD_VLAN_ID.",
    },
    {
        .name  = QUAL_VRFs,  /* QUAL_VRF */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for VRF.",
    },
    {
        .name  = QUAL_VRF_MASKs,  /* QUAL_VRF_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VRF.",
    },
    {
        .name  = QUAL_VPNs,  /* QUAL_VPN */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for VPN.",
    },
    {
        .name  = QUAL_VPN_MASKs,  /* QUAL_VPN_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VPN.",
    },
    {
        .name  = QUAL_SFLOW_SAMPLEDs,  /* QUAL_SFLOW_SAMPLED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to filter sFlow sampled packets.\n Disable to filter sFlow non sampled packets.\n",
    },
    {
        .name  = QUAL_SFLOW_SAMPLED_MASKs,  /* QUAL_SFLOW_SAMPLED_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SFLOW_SAMPLED.",
    },
    {
        .name  = QUAL_FWD_TYPEs,  /* QUAL_FWD_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for forwarding type.",
    },
    {
        .name  = QUAL_INT_CNs,  /* QUAL_INT_CN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for internal congestion.",
    },
    {
        .name  = QUAL_INT_CN_MASKs,  /* QUAL_INT_CN_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INT_CN.",
    },
    {
        .name  = QUAL_DROP_PKTs,  /* QUAL_DROP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet is flagged to be dropped.",
    },
    {
        .name  = QUAL_DROP_PKT_MASKs,  /* QUAL_DROP_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DROP_PKT.",
    },
    {
        .name  = QUAL_IP_FRAGs,  /* QUAL_IP_FRAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IP fragment.",
    },
    {
        .name  = QUAL_MIRR_COPYs,  /* QUAL_MIRR_COPY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mirrored traffic.",
    },
    {
        .name  = QUAL_MIRR_COPY_MASKs,  /* QUAL_MIRR_COPY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MIRR_COPY.",
    },
    {
        .name  = QUAL_TCP_FLAGSs,  /* QUAL_TCP_FLAGS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for TCP control flags.",
    },
    {
        .name  = QUAL_TCP_FLAGS_MASKs,  /* QUAL_TCP_FLAGS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TCP_FLAGS.",
    },
    {
        .name  = QUAL_L4DST_PORTs,  /* QUAL_L4DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L4 destination port.",
    },
    {
        .name  = QUAL_L4DST_PORT_MASKs,  /* QUAL_L4DST_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L4DST_PORT.",
    },
    {
        .name  = QUAL_L4SRC_PORTs,  /* QUAL_L4SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L4 source port.",
    },
    {
        .name  = QUAL_L4SRC_PORT_MASKs,  /* QUAL_L4SRC_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L4SRC_PORT.",
    },
    {
        .name  = QUAL_ICMP_TYPE_CODEs,  /* QUAL_ICMP_TYPE_CODE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for ICMP type code.",
    },
    {
        .name  = QUAL_ICMP_TYPE_CODE_MASKs,  /* QUAL_ICMP_TYPE_CODE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_ICMP_TYPE_CODE.",
    },
    {
        .name  = QUAL_TTLs,  /* QUAL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for packet TTL.",
    },
    {
        .name  = QUAL_TTL_MASKs,  /* QUAL_TTL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TTL.",
    },
    {
        .name  = QUAL_IP_PROTOCOLs,  /* QUAL_IP_PROTOCOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for protocol Number in IPv4/IPv6 packets.",
    },
    {
        .name  = QUAL_IP_PROTOCOL_MASKs,  /* QUAL_IP_PROTOCOL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_PROTO.",
    },
    {
        .name  = QUAL_DST_IP4s,  /* QUAL_DST_IP4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IPv4 destination address.",
    },
    {
        .name  = QUAL_DST_IP4_MASKs,  /* QUAL_DST_IP4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP4.",
    },
    {
        .name  = QUAL_SRC_IP4s,  /* QUAL_SRC_IP4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IPv4 source address.",
    },
    {
        .name  = QUAL_SRC_IP4_MASKs,  /* QUAL_SRC_IP4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_IP4.",
    },
    {
        .name  = QUAL_TOSs,  /* QUAL_TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for type of service.",
    },
    {
        .name  = QUAL_TOS_MASKs,  /* QUAL_TOS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TOS.",
    },
    {
        .name  = QUAL_SRC_IP6_UPPERs,  /* QUAL_SRC_IP6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 source address.",
    },
    {
        .name  = QUAL_SRC_IP6_LOWERs,  /* QUAL_SRC_IP6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 source address.",
    },
    {
        .name  = QUAL_SRC_IP6_MASK_UPPERs,  /* QUAL_SRC_IP6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_IP6.",
    },
    {
        .name  = QUAL_SRC_IP6_MASK_LOWERs,  /* QUAL_SRC_IP6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_IP6.",
    },
    {
        .name  = QUAL_DST_IP6_UPPERs,  /* QUAL_DST_IP6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 destination address.",
    },
    {
        .name  = QUAL_DST_IP6_LOWERs,  /* QUAL_DST_IP6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 destination address.",
    },
    {
        .name  = QUAL_DST_IP6_MASK_UPPERs,  /* QUAL_DST_IP6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP6.",
    },
    {
        .name  = QUAL_DST_IP6_MASK_LOWERs,  /* QUAL_DST_IP6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP6.",
    },
    {
        .name  = QUAL_SRC_IP6_HIGHs,  /* QUAL_SRC_IP6_HIGH */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for source IPv6 address (High/Upper 64 bits).",
    },
    {
        .name  = QUAL_SRC_IP6_HIGH_MASKs,  /* QUAL_SRC_IP6_HIGH_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_IP6_HIGH.",
    },
    {
        .name  = QUAL_DST_IP6_HIGHs,  /* QUAL_DST_IP6_HIGH */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for destination IPv6 address (High/Upper 64 bits).",
    },
    {
        .name  = QUAL_DST_IP6_HIGH_MASKs,  /* QUAL_DST_IP6_HIGH_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP6_HIGH.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_SUBCODEs,  /* QUAL_IP_FIRST_EH_SUBCODE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP first extension header subcode.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_SUBCODE_MASKs,  /* QUAL_IP_FIRST_EH_SUBCODE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_FIRST_EH_SUBCODE.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_PROTOs,  /* QUAL_IP_FIRST_EH_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP first extension header protocol type.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_PROTO_MASKs,  /* QUAL_IP_FIRST_EH_PROTO_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_FIRST_EH_PROTO.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_EXPs,  /* QUAL_MPLS_FWD_LABEL_EXP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for MPLS forwarding exp label.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_EXP_MASKs,  /* QUAL_MPLS_FWD_LABEL_EXP_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MPLS_FWD_LABEL_EXP.",
    },
    {
        .name  = QUAL_BYTES_0_7_AFTER_L2HEADERs,  /* QUAL_BYTES_0_7_AFTER_L2HEADER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for first 8 bytes after L2 Header.",
    },
    {
        .name  = QUAL_BYTES_0_7_AFTER_L2HEADER_MASKs,  /* QUAL_BYTES_0_7_AFTER_L2HEADER_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_FIRST_BYTES_0_7_AFTER_L2HEADER.",
    },
    {
        .name  = QUAL_BYTES_8_15_AFTER_L2HEADERs,  /* QUAL_BYTES_8_15_AFTER_L2HEADER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for bytes 8 - 15 after L2 Header.",
    },
    {
        .name  = QUAL_BYTES_8_15_AFTER_L2HEADER_MASKs,  /* QUAL_BYTES_8_15_AFTER_L2HEADER_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_BYTES_8_15_AFTER_L2HEADER.",
    },
    {
        .name  = QUAL_BYTES_16_17_AFTER_L2HEADERs,  /* QUAL_BYTES_16_17_AFTER_L2HEADER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for bytes 16 - 17 after L2 Header.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_egr_rule_template_t = {
    .name = FP_EGR_RULE_TEMPLATEs, /* FP_EGR_RULE_TEMPLATE */
    .flags = 0,
    .fields = 138,
    .field = bcmltd_fp_egr_rule_template_t_fields,
    .desc = "The FP_EGR_RULE_TEMPLATE specifies the egress FP rule that can be\n attached to an egress FP entry.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EGR_SLICE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_egr_slice_info_t_fields[] = {
    {
        .name  = FP_EGR_SLICE_IDs,  /* FP_EGR_SLICE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Egress FP slice ID.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = ENTRY_INUSE_CNTs,  /* ENTRY_INUSE_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries created.",
    },
    {
        .name  = ENTRY_MAXIMUMs,  /* ENTRY_MAXIMUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of entries.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_egr_slice_info_t = {
    .name = FP_EGR_SLICE_INFOs, /* FP_EGR_SLICE_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_egr_slice_info_t_fields,
    .desc = "The FP_EGR_SLICE_INFO table provides egress FP slice-specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EM_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_em_entry_t_fields[] = {
    {
        .name  = FP_EM_ENTRY_IDs,  /* FP_EM_ENTRY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP Exact Match Entry Identifier.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operational state of the entry.",
    },
    {
        .name  = FP_EM_GRP_TEMPLATE_IDs,  /* FP_EM_GRP_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated group ID from FP_EM_GRP_TEMPLATE LT.",
    },
    {
        .name  = FP_EM_RULE_TEMPLATE_IDs,  /* FP_EM_RULE_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated rule ID from FP_EM_RULE_TEMPLATE LT.",
    },
    {
        .name  = FP_EM_POLICY_TEMPLATE_IDs,  /* FP_EM_POLICY_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from FP_EM_POLICY_TEMPLATE LT.",
    },
    {
        .name  = METER_ING_FP_TEMPLATE_IDs,  /* METER_ING_FP_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated meter ID from METER_ING_FP_TEMPLATE LT.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated flex counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Associated flex counter offset mode.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated flex counter pool ID.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_fp_em_entry_t = {
    .name = FP_EM_ENTRYs, /* FP_EM_ENTRY */
    .flags = 0,
    .fields = 11,
    .field = bcmltd_fp_em_entry_t_fields,
    .desc = "The FP_EM_ENTRY associates the group ID, rule ID, policy ID, counter ID and\n meter ID to the entries in the group. Operations on this logical table will\n provision the device EM logic, if sufficient resources are available.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EM_GRP_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_em_grp_template_t_fields[] = {
    {
        .name  = FP_EM_GRP_TEMPLATE_IDs,  /* FP_EM_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Exact match group identifier.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Group priority. groups with same priority will share the same\n physical resources(exact match FP slices) if the corresponding presel\n slice have enough free entries to accommodate the presel entries\n associated to all groups with that priority.\n",
    },
    {
        .name  = MODE_AUTOs,  /* MODE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to auto calculate the group mode and ignore the user specified\n mode in MODE field in this table.\n",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Configurable group mode.\n    SINGLE     : Single wide mode\n    DBLINTER   : Double wide inter-slice mode\n Applicable only if MODE_AUTO is disabled.\n",
    },
    {
        .name  = MODE_OPERs,  /* MODE_OPER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational group mode.\n If MODE_AUTO is enabled, then the MODE_OPER field will be updated\n with the mode assigned to the group by the SDK.\n If MODE_AUTO is disabled and if the group fits in the mode specified\n in the MODE field, then the MODE field will be assigned to the\n MODE_OPER field.\n",
    },
    {
        .name  = FP_EM_PRESEL_ENTRY_COUNTs,  /* FP_EM_PRESEL_ENTRY_COUNT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of active presel entries.",
    },
    {
        .name  = FP_EM_PRESEL_ENTRY_TEMPLATE_IDs,  /* FP_EM_PRESEL_ENTRY_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 32,
        .desc = "Presel entries created in FP_EM_PRESEL_ENTRY LT that are\n associated to this GROUP_ID.\n",
    },
    {
        .name  = LTID_AUTOs,  /* LTID_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to auto allocate group LTID and ignore the user specified\n LTID field in this table. By default this field is enabled.\n",
    },
    {
        .name  = LTIDs,  /* LTID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies the group logical table ID (LTID). This value is used to\n chain exact match FP with ingress FP. Can be qualified in ingress FP\n preselection.\n Applicable only if LTID_AUTO is disabled.\n",
    },
    {
        .name  = LTID_OPERs,  /* LTID_OPER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Read-only field reflects the operational group LTID of the\n group. If LTID_AUTO is enabled, then the LTID_OPER field will be\n updated with the LTID assigned to the group by the SDK.\n If LTID_AUTO is disabled, then the LTID field will be assigned to\n the LTID_OPER field.\n",
    },
    {
        .name  = LOOKUPs,  /* LOOKUP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies the lookup partition in which the group needs to be\n installed in the hardware.\n Exact match has 2 lookups, based on the value of the lookup, the\n group will be mapped to the lookup 0/1.\n",
    },
    {
        .name  = DEFAULT_FP_EM_POLICY_TEMPLATE_IDs,  /* DEFAULT_FP_EM_POLICY_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default policy template ID that needs to be\n applied for a search miss. The group's preselect data controls the\n usage of the default policy. When a valid value is specified for\n DEFAULT_FP_EM_POLICY_TEMPLATE_ID, the default policy\n is enabled in the corresponding group's preselect.\n",
    },
    {
        .name  = DEFAULT_FP_EM_PDD_TEMPLATE_IDs,  /* DEFAULT_FP_EM_PDD_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default PDD template ID used to decode the policy specified in\n DEFAULT_FP_EM_POLICY_TEMPLATE_ID in case of a search miss.\n",
    },
    {
        .name  = DEFAULT_CTR_ING_EFLEX_ACTIONs,  /* DEFAULT_CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action for the policy specified in\n DEFAULT_FP_EM_POLICY_TEMPLATE_ID in case of a search miss.\n",
    },
    {
        .name  = DEFAULT_METER_ING_FP_TEMPLATE_IDs,  /* DEFAULT_METER_ING_FP_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated meter ID from METER_ING_FP_TEMPLATE LT for the\n policy specified in DEFAULT_FP_EM_POLICY_TEMPLATE_ID in case\n of a search miss.\n",
    },
    {
        .name  = FP_EM_PDD_TEMPLATE_IDs,  /* FP_EM_PDD_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "PDD template ID used to decode the policies linked\n to the entries associated with this group template ID.\n",
    },
    {
        .name  = QUAL_OUTER_VLAN_ID_BITMAPs,  /* QUAL_OUTER_VLAN_ID_BITMAP */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID qualifier bitmap.\n All supported qualifiers have QUAL_<qualifier name>_BITMAP field\n to mask the bits not used for qualification in any of its rules.\n This information is required to SDKLT extraction algorithm to\n optimally building the key by not extracting these don.t care\n bits into the key.\n",
    },
    {
        .name  = QUAL_OUTER_VLAN_PRI_BITMAPs,  /* QUAL_OUTER_VLAN_PRI_BITMAP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority qualifier bitmap.",
    },
    {
        .name  = QUAL_OUTER_VLAN_CFI_BITMAPs,  /* QUAL_OUTER_VLAN_CFI_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI qualifier bitmap.",
    },
    {
        .name  = QUAL_INNER_VLAN_ID_BITMAPs,  /* QUAL_INNER_VLAN_ID_BITMAP */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID qualifier bitmap.",
    },
    {
        .name  = QUAL_INNER_VLAN_PRI_BITMAPs,  /* QUAL_INNER_VLAN_PRI_BITMAP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority qualifier bitmap.",
    },
    {
        .name  = QUAL_INNER_VLAN_CFI_BITMAPs,  /* QUAL_INNER_VLAN_CFI_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI qualifier bitmap.",
    },
    {
        .name  = QUAL_SRC_MAC_BITMAPs,  /* QUAL_SRC_MAC_BITMAP */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address qualifier bitmap.",
    },
    {
        .name  = QUAL_DST_MAC_BITMAPs,  /* QUAL_DST_MAC_BITMAP */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address qualifier bitmap.",
    },
    {
        .name  = QUAL_SRC_IP4_BITMAPs,  /* QUAL_SRC_IP4_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 source address qualifier bitmap.",
    },
    {
        .name  = QUAL_DST_IP4_BITMAPs,  /* QUAL_DST_IP4_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 destination address qualifier bitmap.",
    },
    {
        .name  = QUAL_SRC_IP6_BITMAP_UPPERs,  /* QUAL_SRC_IP6_BITMAP_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 source address qualifier bitmap.",
    },
    {
        .name  = QUAL_SRC_IP6_BITMAP_LOWERs,  /* QUAL_SRC_IP6_BITMAP_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 source address qualifier bitmap.",
    },
    {
        .name  = QUAL_DST_IP6_BITMAP_UPPERs,  /* QUAL_DST_IP6_BITMAP_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 destination address qualifier bitmap.",
    },
    {
        .name  = QUAL_DST_IP6_BITMAP_LOWERs,  /* QUAL_DST_IP6_BITMAP_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 destination address qualifier bitmap.",
    },
    {
        .name  = QUAL_ETHERTYPE_BITMAPs,  /* QUAL_ETHERTYPE_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L2 Ethertype qualifier bitmap.",
    },
    {
        .name  = QUAL_L4SRC_PORT_BITMAPs,  /* QUAL_L4SRC_PORT_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L4 source port qualifier bitmap.",
    },
    {
        .name  = QUAL_ICMP_TYPE_CODE_BITMAPs,  /* QUAL_ICMP_TYPE_CODE_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "ICMP type code qualifier bitmap.",
    },
    {
        .name  = QUAL_L4DST_PORT_BITMAPs,  /* QUAL_L4DST_PORT_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L4 destination port qualifier bitmap.",
    },
    {
        .name  = QUAL_MIM_ISID_BITMAPs,  /* QUAL_MIM_ISID_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for ISID in MiM packet header.",
    },
    {
        .name  = QUAL_NVGRE_VSID_BITMAPs,  /* QUAL_NVGRE_VSID_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for VPNID in NVGRE packet header.",
    },
    {
        .name  = QUAL_VXLAN_VNID_BITMAPs,  /* QUAL_VXLAN_VNID_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for VNID in VXLAN packet header.",
    },
    {
        .name  = QUAL_VXLAN_FLAGS_BITMAPs,  /* QUAL_VXLAN_FLAGS_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for flags in VXLAN packet header.",
    },
    {
        .name  = QUAL_VXLAN_RSVD_24_BITMAPs,  /* QUAL_VXLAN_RSVD_24_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for 24 reserved bits in VXLAN.",
    },
    {
        .name  = QUAL_VXLAN_RSVD_8_BITMAPs,  /* QUAL_VXLAN_RSVD_8_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for 8 reserved bits in VXLAN.",
    },
    {
        .name  = QUAL_ETAG_BITMAPs,  /* QUAL_ETAG_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for extended port tag.",
    },
    {
        .name  = QUAL_VNTAG_BITMAPs,  /* QUAL_VNTAG_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for VN TAG.",
    },
    {
        .name  = QUAL_CNTAG_BITMAPs,  /* QUAL_CNTAG_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap CNTAG.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_ID_BITMAPs,  /* QUAL_MPLS_FWD_LABEL_ID_BITMAP */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS forwarding label ID.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_TTL_BITMAPs,  /* QUAL_MPLS_FWD_LABEL_TTL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS forwarding label TTL.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_EXP_BITMAPs,  /* QUAL_MPLS_FWD_LABEL_EXP_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS forwarding label EXP.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_BOS_BITMAPs,  /* QUAL_MPLS_FWD_LABEL_BOS_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on MPLS forwarding label BOS as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_MPLS_CTRL_WORD_BITMAPs,  /* QUAL_MPLS_CTRL_WORD_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS control word.",
    },
    {
        .name  = QUAL_IP6_FLOW_LABEL_BITMAPs,  /* QUAL_IP6_FLOW_LABEL_BITMAP */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Qualifier bitmap for flow label of IPv6 packets",
    },
    {
        .name  = QUAL_TTL_BITMAPs,  /* QUAL_TTL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for packet's TTL.",
    },
    {
        .name  = QUAL_TOS_BITMAPs,  /* QUAL_TOS_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for type of service.",
    },
    {
        .name  = QUAL_IP_PROTOCOL_BITMAPs,  /* QUAL_IP_PROTOCOL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for protocol number in IPv4/IPv6 packets.",
    },
    {
        .name  = QUAL_TCP_FLAGS_BITMAPs,  /* QUAL_TCP_FLAGS_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for TCP control flags.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_PROTO_BITMAPs,  /* QUAL_IP_FIRST_EH_PROTO_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for IP first extension header protocol type.",
    },
    {
        .name  = QUAL_IP_SECOND_EH_PROTO_BITMAPs,  /* QUAL_IP_SECOND_EH_PROTO_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for IP second extension header protocol type.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_SUBCODE_BITMAPs,  /* QUAL_IP_FIRST_EH_SUBCODE_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for IP first extension header subcode.",
    },
    {
        .name  = QUAL_IP_FLAGS_MF_BITMAPs,  /* QUAL_IP_FLAGS_MF_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on more fragment flag in IP header as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_IP_FLAGS_DF_BITMAPs,  /* QUAL_IP_FLAGS_DF_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on do not fragment flag in IP header as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_IP_FRAG_BITMAPs,  /* QUAL_IP_FRAG_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on IP fragment flag in IP header as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_HIGIG_PKT_BITMAPs,  /* QUAL_HIGIG_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets received on HiGig port as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKT_BITMAPs,  /* QUAL_HIGIGLOOKUP_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets received on HiGig port and lookup\n happened as specified in rule template entries that are associated\n with FP entries which reference this group template.\n",
    },
    {
        .name  = QUAL_DROP_PKT_BITMAPs,  /* QUAL_DROP_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets flagged to be dropped as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_VISIBILITY_PKT_BITMAPs,  /* QUAL_VISIBILITY_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on visibility packets(CPU masquerade packets)) as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_DOSATTACK_PKT_BITMAPs,  /* QUAL_DOSATTACK_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on DOS attack packets as specified in rule template\n entries that are associated with FP entries which reference this\n group template.\n",
    },
    {
        .name  = QUAL_L4_PKT_BITMAPs,  /* QUAL_L4_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L4 packets (valid L4 SRC and DST port) as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_MIRROR_PKT_BITMAPs,  /* QUAL_MIRROR_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on mirrored packets as specified in rule template\n entries that are associated with FP entries which reference this\n group template.\n",
    },
    {
        .name  = QUAL_NON_OR_FIRST_FRAGMENT_BITMAPs,  /* QUAL_NON_OR_FIRST_FRAGMENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on first fragment packets as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_ICMP_ERROR_PKT_BITMAPs,  /* QUAL_ICMP_ERROR_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on ICMP error packets as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_REPLICATION_PKT_BITMAPs,  /* QUAL_REPLICATION_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on replication copy of original packet as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_L3_TNL_HIT_BITMAPs,  /* QUAL_L3_TNL_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on IP address hit in L3 tunnel table as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_VXLT_LOOKUP_HIT_BITMAPs,  /* QUAL_VXLT_LOOKUP_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on first/second/all/none lookup hit for VLAN\n translation as specified in rule template entries that are associated\n with FP entries which reference this group template.\n",
    },
    {
        .name  = QUAL_MPLSENTRY_FIRSTLOOKUP_HIT_BITMAPs,  /* QUAL_MPLSENTRY_FIRSTLOOKUP_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on first lookup hit in MPLS entry table as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_MPLSENTRY_SECONDLOOKUP_HIT_BITMAPs,  /* QUAL_MPLSENTRY_SECONDLOOKUP_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on second lookup hit in MPLS entry table as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_HIT_BITMAPs,  /* QUAL_MYSTATIONTCAM_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on my station TCAM hit status as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_2_HIT_BITMAPs,  /* QUAL_MYSTATIONTCAM_2_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on my station TCAM 2 hit status as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_MPLS_BOS_TERMINATED_BITMAPs,  /* QUAL_MPLS_BOS_TERMINATED_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on BOS label terminated in MPLS packets as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_DST_IP_LOCAL_BITMAPs,  /* QUAL_DST_IP_LOCAL_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on destination IP address is local as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_L3_ROUTABLE_PKT_BITMAPs,  /* QUAL_L3_ROUTABLE_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L3 routable status of the packets as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_INNER_L2_L3_ROUTABLE_PKT_BITMAPs,  /* QUAL_INNER_L2_L3_ROUTABLE_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on inner L2 L3 routable status of the packets as\n specified in rule template entries that are associated with FP entries\n which reference this group template.\n",
    },
    {
        .name  = QUAL_PORT_SYSTEM_CLASS_BITMAPs,  /* QUAL_PORT_SYSTEM_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for PORT_SYSTEM class ID.",
    },
    {
        .name  = QUAL_L3_IIF_CLASS_ID_BITMAPs,  /* QUAL_L3_IIF_CLASS_ID_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for L3_IIF class ID.",
    },
    {
        .name  = QUAL_SVP_CLASS_BITMAPs,  /* QUAL_SVP_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for source virtual port class ID.",
    },
    {
        .name  = QUAL_VLAN_CLASS_BITMAPs,  /* QUAL_VLAN_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for VLAN class ID.",
    },
    {
        .name  = QUAL_FP_VLAN_CLASS0_BITMAPs,  /* QUAL_FP_VLAN_CLASS0_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for first VLAN FP class ID.",
    },
    {
        .name  = QUAL_FP_VLAN_CLASS1_BITMAPs,  /* QUAL_FP_VLAN_CLASS1_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for second VLAN FP class ID.",
    },
    {
        .name  = QUAL_FP_VLAN_PORT_GRP_BITMAPs,  /* QUAL_FP_VLAN_PORT_GRP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for VLAN FP port group ID from port.",
    },
    {
        .name  = QUAL_FP_ING_GRP_SEL_CLASS_BITMAPs,  /* QUAL_FP_ING_GRP_SEL_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for ingress FP key select class ID from port.",
    },
    {
        .name  = QUAL_UDF_CLASS_BITMAPs,  /* QUAL_UDF_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for UDF class ID.",
    },
    {
        .name  = QUAL_L2_SRC_CLASS_BITMAPs,  /* QUAL_L2_SRC_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for class ID from L2 source lookup hit\n in L2_ENTRY.\n",
    },
    {
        .name  = QUAL_L2_DST_CLASS_BITMAPs,  /* QUAL_L2_DST_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for class ID from L2 destination lookup hit\n in L2_ENTRY.\n",
    },
    {
        .name  = QUAL_L3_SRC_CLASS_BITMAPs,  /* QUAL_L3_SRC_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for class ID from L3 source lookup\n in L3 host table.\n",
    },
    {
        .name  = QUAL_L3_DST_CLASS_BITMAPs,  /* QUAL_L3_DST_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for class ID from L3 destination lookup\n in L3 Host table.\n",
    },
    {
        .name  = QUAL_PRESEL_CLASS_BITMAPs,  /* QUAL_PRESEL_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for presel class ID.",
    },
    {
        .name  = QUAL_FWD_VLAN_VALID_BITMAPs,  /* QUAL_FWD_VLAN_VALID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with valid forwarding VLAN ID as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_SRC_VP_VALID_BITMAPs,  /* QUAL_SRC_VP_VALID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with valid SVP as specified in rule\n template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_DST_VP_VALID_BITMAPs,  /* QUAL_DST_VP_VALID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with valid DVP as specified in rule\n template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_SRC_MODULE_BITMAPs,  /* QUAL_SRC_MODULE_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for source module ID.",
    },
    {
        .name  = QUAL_SRC_PORT_BITMAPs,  /* QUAL_SRC_PORT_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for source port.",
    },
    {
        .name  = QUAL_SRC_TRUNK_BITMAPs,  /* QUAL_SRC_TRUNK_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for SGLP.",
    },
    {
        .name  = QUAL_SRC_VP_BITMAPs,  /* QUAL_SRC_VP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for source VP.",
    },
    {
        .name  = QUAL_FWD_VLAN_ID_BITMAPs,  /* QUAL_FWD_VLAN_ID_BITMAP */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier bitmap for forwarding VLAN ID.",
    },
    {
        .name  = QUAL_VRF_BITMAPs,  /* QUAL_VRF_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for VRF.",
    },
    {
        .name  = QUAL_VFI_BITMAPs,  /* QUAL_VFI_BITMAP */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Qualifier bitmap for VFI.",
    },
    {
        .name  = QUAL_VPN_BITMAPs,  /* QUAL_VPN_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for VPN.",
    },
    {
        .name  = QUAL_L3_IIF_BITMAPs,  /* QUAL_L3_IIF_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for L3 ingress interface.",
    },
    {
        .name  = QUAL_INPORT_BITMAPs,  /* QUAL_INPORT_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Single inport qualifier bitmap.",
    },
    {
        .name  = QUAL_RAL_PRESENT_BITMAPs,  /* QUAL_RAL_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with RAL label present as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_GAL_PRESENT_BITMAPs,  /* QUAL_GAL_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with GAL label present as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_MPLS_CW_VALID_BITMAPs,  /* QUAL_MPLS_CW_VALID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with MPLS pseudo wire control word valid\n as specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_NAT_SRC_REALM_ID_BITMAPs,  /* QUAL_NAT_SRC_REALM_ID_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for NAT source realm ID from L3_IIF table.",
    },
    {
        .name  = QUAL_INT_CN_BITMAPs,  /* QUAL_INT_CN_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for internal congestion.",
    },
    {
        .name  = QUAL_MACADDR_NORMALIZE_BITMAPs,  /* QUAL_MACADDR_NORMALIZE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L2 fields normalized as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_IPADDR_NORMALIZE_BITMAPs,  /* QUAL_IPADDR_NORMALIZE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L3/L4 fields normalized as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_VLAN_INNER_PRESENT_BITMAPs,  /* QUAL_VLAN_INNER_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with inner VLAN tag present as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_VLAN_OUTER_PRESENT_BITMAPs,  /* QUAL_VLAN_OUTER_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with outer VLAN tag present as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_OPAQUE_TAG_PRESENT_BITMAPs,  /* QUAL_OPAQUE_TAG_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with opaque tag present as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_INNER_L2_VLAN_OUTER_PRESENT_BITMAPs,  /* QUAL_INNER_L2_VLAN_OUTER_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with inner L2 VLAN tag present as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_INNER_L2_OPAQUE_TAG_PRESENT_BITMAPs,  /* QUAL_INNER_L2_OPAQUE_TAG_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with inner L2 opaque tag present as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_TRANSLATED_VLAN_INNER_PRESENT_BITMAPs,  /* QUAL_TRANSLATED_VLAN_INNER_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on inner VLAN tag status after VLAN assignment and\n VLAN translation as specified in rule template entries that are\n associated with FP entries which reference this group template.\n",
    },
    {
        .name  = QUAL_TRANSLATED_VLAN_OUTER_PRESENT_BITMAPs,  /* QUAL_TRANSLATED_VLAN_OUTER_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on outer VLAN tag status after VLAN assignment and\n VLAN translation as specified in rule template entries that are\n associated with FP entries which reference this group template.\n",
    },
    {
        .name  = QUAL_BYTES_0_7_AFTER_L2HEADER_BITMAPs,  /* QUAL_BYTES_0_7_AFTER_L2HEADER_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Enable to match on first 8 bytes after L2 header as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_BYTES_8_15_AFTER_L2HEADER_BITMAPs,  /* QUAL_BYTES_8_15_AFTER_L2HEADER_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Enable to match on bytes 8_15 after L2 header as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_BYTES_16_23_AFTER_L2HEADER_BITMAPs,  /* QUAL_BYTES_16_23_AFTER_L2HEADER_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Enable to match on bytes 16_23 after L2 header as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_BYTES_24_31_AFTER_L2HEADER_BITMAPs,  /* QUAL_BYTES_24_31_AFTER_L2HEADER_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Enable to match on bytes 24_31 after L2 header as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_IP_CHECKSUM_VALID_BITMAPs,  /* QUAL_IP_CHECKSUM_VALID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on matching IP checksum as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_BFD_DISCRIMINATOR_BITMAPs,  /* QUAL_BFD_DISCRIMINATOR_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for BFD discrimination.",
    },
    {
        .name  = QUAL_PKT_LENGTH_BITMAPs,  /* QUAL_PKT_LENGTH_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for packets length.",
    },
    {
        .name  = QUAL_RANGE_CHECKID_BMP_BITMAPs,  /* QUAL_RANGE_CHECKID_BMP_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier bitmap for range_check table.",
    },
    {
        .name  = QUAL_RANGE_CHECK_GRP_ID_BMP_BITMAPs,  /* QUAL_RANGE_CHECK_GRP_ID_BMP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for range_check group table.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_ACTION_BITMAPs,  /* QUAL_MPLS_FWD_LABEL_ACTION_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on MPLS forwarding label as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_TNL_TYPE_BITMAPs,  /* QUAL_TNL_TYPE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on tunnel type as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_LOOPBACK_TYPE_BITMAPs,  /* QUAL_LOOPBACK_TYPE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on loopback type as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_LOOPBACK_BITMAPs,  /* QUAL_LOOPBACK_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on loopback packets as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_IP_TYPE_BITMAPs,  /* QUAL_IP_TYPE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on IP type as specified in rule template entries that\n are associated with FP entries which reference this group template.\n",
    },
    {
        .name  = QUAL_L2_FORMAT_BITMAPs,  /* QUAL_L2_FORMAT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L2 format as specified in rule template entries\n that are associated with FP entries which reference this group\n template.\n",
    },
    {
        .name  = QUAL_INNER_TPID_BITMAPs,  /* QUAL_INNER_TPID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on inner TPID  as specified in rule template entries\n that are associated with FP entries which reference this group\n template.\n",
    },
    {
        .name  = QUAL_OUTER_TPID_BITMAPs,  /* QUAL_OUTER_TPID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on outer TPID  as specified in rule template entries\n that are associated with FP entries which reference this group\n template.\n",
    },
    {
        .name  = QUAL_INNER_L2_OUTER_TPID_BITMAPs,  /* QUAL_INNER_L2_OUTER_TPID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on inner L2 outer TPID  as specified in rule template\n entries that are associated with FP entries which reference this\n group template.\n",
    },
    {
        .name  = QUAL_FWD_TYPE_BITMAPs,  /* QUAL_FWD_TYPE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packet forwarding type as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_ING_STP_STATE_BITMAPs,  /* QUAL_ING_STP_STATE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on STP state type as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_UDF_CHUNKS_BITMAPs,  /* QUAL_UDF_CHUNKS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "Qualifier bitmap for UDF chunks.",
    },
    {
        .name  = QUAL_C_L4SRC_PORT_BITMAPs,  /* QUAL_C_L4SRC_PORT_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed L4 source port.",
    },
    {
        .name  = QUAL_C_L4DST_PORT_BITMAPs,  /* QUAL_C_L4DST_PORT_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed L4 destination port.",
    },
    {
        .name  = QUAL_C_ETHERTYPE_BITMAPs,  /* QUAL_C_ETHERTYPE_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed ethertype.",
    },
    {
        .name  = QUAL_C_IP_PROTOCOL_BITMAPs,  /* QUAL_C_IP_PROTOCOL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed IP protocol.",
    },
    {
        .name  = QUAL_C_TTL0_BITMAPs,  /* QUAL_C_TTL0_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed or remapped first TTL.\n Original packet's TTL can be mapped to 2 different values\n This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TTL1_BITMAPs,  /* QUAL_C_TTL1_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed or remapped second TTL.\n Original packet's TTL can be mapped to 2 different values\n This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_C_TOS0_BITMAPs,  /* QUAL_C_TOS0_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed or remapped first TOS.\n Original packet's TOS can be mapped to 2 different values\n This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TOS1_BITMAPs,  /* QUAL_C_TOS1_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed or remapped second TOS.\n Original packet's TOS can be mapped to 2 different values\n This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_C_TCP_FLAGS0_BITMAPs,  /* QUAL_C_TCP_FLAGS0_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed/remapped first TCP control flags.\n Original packet's TCP control flags can be mapped to 2 different\n values. This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TCP_FLAGS1_BITMAPs,  /* QUAL_C_TCP_FLAGS1_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed/remapped second TCP control flags.\n Original packet's TCP control flags can be mapped to 2 different\n values. This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_C_DST_IP_BITMAPs,  /* QUAL_C_DST_IP_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed IP destination address.",
    },
    {
        .name  = QUAL_TNL_IP_TTL_BITMAPs,  /* QUAL_TNL_IP_TTL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap IP tunnel TTL.\n",
    },
    {
        .name  = QUAL_C_TNL_IP_TTL_BITMAPs,  /* QUAL_C_TNL_IP_TTL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed or remapped IP tunnel TTL.\n The outer TTL in the terminated tunnel can be mapped to\n a compressed value represented by this field.\n",
    },
    {
        .name  = QUAL_C_SRC_IP_BITMAPs,  /* QUAL_C_SRC_IP_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed IP source address.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_LOW_BITMAPs,  /* QUAL_OPAQUE_TAG_LOW_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for lower 32 bits of opaque tag.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_HIGH_BITMAPs,  /* QUAL_OPAQUE_TAG_HIGH_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for upper 32 bits of opaque tag.",
    },
    {
        .name  = QUAL_INNER_L2_OPAQUE_TAG_BITMAPs,  /* QUAL_INNER_L2_OPAQUE_TAG_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap of inner L2 opaque tag.",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_FLAGS_BITMAPs,  /* QUAL_INBAND_TELEMETRY_FLAGS_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifiers bitmap for inband network telemetry flag fields from\n the INT/IOAM/IFA header.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_MD_HDR_TYPE_BITMAPs,  /* QUAL_INBAND_TELEMETRY_MD_HDR_TYPE_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for incoming inband network telemetry MD header\n type.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HOP_LIMIT_CHECK_STATUS_BITMAPs,  /* QUAL_INBAND_TELEMETRY_HOP_LIMIT_CHECK_STATUS_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for inband network telemetry hop limit check status.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_MAX_LENGTH_CHECK_BITMAPs,  /* QUAL_INBAND_TELEMETRY_MAX_LENGTH_CHECK_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for inband network telemetry max length check\n status.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HDR_TYPE_BITMAPs,  /* QUAL_INBAND_TELEMETRY_HDR_TYPE_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for incoming inband network telemetry header type.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_UDP_CHECKSUM_ZERO_BITMAPs,  /* QUAL_INBAND_TELEMETRY_UDP_CHECKSUM_ZERO_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for inband network telemetry UDP checksum zero\n check.\n",
    },
    {
        .name  = QUAL_GSH_SYSTEM_DST_BITMAPs,  /* QUAL_GSH_SYSTEM_DST_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifiers bitmap for GSH system destination.\n",
    },
    {
        .name  = QUAL_GSH_ETHERTYPE_LSB_4BIT_BITMAPs,  /* QUAL_GSH_ETHERTYPE_LSB_4BIT_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for last 4 bits for GSH ether_type.\n",
    },
    {
        .name  = QUAL_GSH_OPCODE_BITMAPs,  /* QUAL_GSH_OPCODE_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for GSH opcode.\n",
    },
    {
        .name  = QUAL_PROTECTION_DATA_DROP_BITMAPs,  /* QUAL_PROTECTION_DATA_DROP_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on protection data drop packet as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_DCN_PKT_BITMAPs,  /* QUAL_DCN_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on drop congestion notification(DCN) packet as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HDR_IN_TNL_BITMAPs,  /* QUAL_INBAND_TELEMETRY_HDR_IN_TNL_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packet with inband network telemetry header in\n tunnel specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_RAL_DETECTED_BITMAPs,  /* QUAL_MPLS_SPECIAL_LABEL_RAL_DETECTED_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS RAL detected.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_GAL_DETECTED_BITMAPs,  /* QUAL_MPLS_SPECIAL_LABEL_GAL_DETECTED_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS GAL detected.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_CW_DETECTED_BITMAPs,  /* QUAL_MPLS_SPECIAL_LABEL_CW_DETECTED_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS CW detected.\n",
    },
    {
        .name  = QUAL_RH_FIRST_4_BYTES_BITMAPs,  /* QUAL_RH_FIRST_4_BYTES_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for first 4 bytes of IPv6 routing ext header.\n",
    },
    {
        .name  = QUAL_RH_NEXT_4_BYTES_BITMAPs,  /* QUAL_RH_NEXT_4_BYTES_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for next 4 bytes of IPv6 routing ext header.\n",
    },
    {
        .name  = QUAL_RTAG7A_HASH_LOWER_BITMAPs,  /* QUAL_RTAG7A_HASH_LOWER_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for lower half of RTAG7 hash A result.",
    },
    {
        .name  = QUAL_RTAG7A_HASH_UPPER_BITMAPs,  /* QUAL_RTAG7A_HASH_UPPER_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for upper half of RTAG7 hash A result.",
    },
    {
        .name  = QUAL_RTAG7B_HASH_LOWER_BITMAPs,  /* QUAL_RTAG7B_HASH_LOWER_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for lower half of RTAG7 hash B result.",
    },
    {
        .name  = QUAL_RTAG7B_HASH_UPPER_BITMAPs,  /* QUAL_RTAG7B_HASH_UPPER_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for upper half of RTAG7 hash B result.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_em_grp_template_t = {
    .name = FP_EM_GRP_TEMPLATEs, /* FP_EM_GRP_TEMPLATE */
    .flags = 0,
    .fields = 181,
    .field = bcmltd_fp_em_grp_template_t_fields,
    .desc = "The FP_EM_GRP_TEMPLATE table specifies the group configuration in the exact\n match field processor stage.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EM_GRP_TEMPLATE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_em_grp_template_info_t_fields[] = {
    {
        .name  = FP_EM_GRP_TEMPLATE_IDs,  /* FP_EM_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP group template ID.",
    },
    {
        .name  = HW_LTIDs,  /* HW_LTID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hardware logical table ID used in action resolution or partition\n resolution in case of group auto expansion. This logical table ID is\n different from the SDKLT logical table ID. Priority can be assigned to\n the hardware logical table ID and is used to resolve conflicting\n actions when a packet matches FP entries from two different FP groups.\n",
    },
    {
        .name  = NUM_ENTRIES_CREATEDs,  /* NUM_ENTRIES_CREATED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries created in this group.",
    },
    {
        .name  = NUM_PARTITION_IDs,  /* NUM_PARTITION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of partitions(a.k.a physical slices) used for groups width\n expansion.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_em_grp_template_info_t = {
    .name = FP_EM_GRP_TEMPLATE_INFOs, /* FP_EM_GRP_TEMPLATE_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_em_grp_template_info_t_fields,
    .desc = "The FP_EM_GRP_TEMPLATE_INFO table provides FP group-specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EM_GRP_TEMPLATE_PARTITION_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_em_grp_template_partition_info_t_fields[] = {
    {
        .name  = FP_EM_GRP_TEMPLATE_IDs,  /* FP_EM_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP group template ID.",
    },
    {
        .name  = PARTITION_IDs,  /* PARTITION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Partition ID.",
    },
    {
        .name  = NUM_QUAL_SRC_IP_INFOs,  /* NUM_QUAL_SRC_IP_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partition ID arrays\n for source IP qualifier.\n",
    },
    {
        .name  = QUAL_SRC_IP_OFFSETs,  /* QUAL_SRC_IP_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of source IP qualifier in the final key.",
    },
    {
        .name  = QUAL_SRC_IP_WIDTHs,  /* QUAL_SRC_IP_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of source IP qualifier in the final key. The width at each index\n corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_SRC_IP_ORDERs,  /* QUAL_SRC_IP_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for source IP qualifier in the current partition.\n",
    },
    {
        .name  = NUM_QUAL_DST_IP_INFOs,  /* NUM_QUAL_DST_IP_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partition ID arrays\n for Destination IP qualifier.\n",
    },
    {
        .name  = QUAL_DST_IP_OFFSETs,  /* QUAL_DST_IP_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of Destination IP qualifier in the final key.",
    },
    {
        .name  = QUAL_DST_IP_WIDTHs,  /* QUAL_DST_IP_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of Destination IP qualifier in the final key. The width at each index\n corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_DST_IP_ORDERs,  /* QUAL_DST_IP_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for Destination IP qualifier in the current partition.\n",
    },
    {
        .name  = NUM_QUAL_L4_SRC_PORT_INFOs,  /* NUM_QUAL_L4_SRC_PORT_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partition ID arrays\n for L4 Src Port qualifier.\n",
    },
    {
        .name  = QUAL_L4_SRC_PORT_OFFSETs,  /* QUAL_L4_SRC_PORT_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of L4 Src Port qualifier in the final key.",
    },
    {
        .name  = QUAL_L4_SRC_PORT_WIDTHs,  /* QUAL_L4_SRC_PORT_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of L4 Src Port qualifier in the final key. The width at each index\n corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_L4_SRC_PORT_ORDERs,  /* QUAL_L4_SRC_PORT_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for L4 Src Port qualifier in the current partition.\n",
    },
    {
        .name  = NUM_QUAL_L4_DST_PORT_INFOs,  /* NUM_QUAL_L4_DST_PORT_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partition ID arrays\n for L4 Dst Port qualifier.\n",
    },
    {
        .name  = QUAL_L4_DST_PORT_OFFSETs,  /* QUAL_L4_DST_PORT_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of L4 Dst Port qualifier in the final key.",
    },
    {
        .name  = QUAL_L4_DST_PORT_WIDTHs,  /* QUAL_L4_DST_PORT_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of L4 Dst Port qualifier in the final key. The width at each index\n corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_L4_DST_PORT_ORDERs,  /* QUAL_L4_DST_PORT_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for L4 Dst Port qualifier in the current partition.\n",
    },
    {
        .name  = NUM_QUAL_IP_PROTOCOL_INFOs,  /* NUM_QUAL_IP_PROTOCOL_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partition ID arrays\n for IP Protocol qualifier.\n",
    },
    {
        .name  = QUAL_IP_PROTOCOL_OFFSETs,  /* QUAL_IP_PROTOCOL_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of IP Protocol qualifier in the final key.",
    },
    {
        .name  = QUAL_IP_PROTOCOL_WIDTHs,  /* QUAL_IP_PROTOCOL_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of IP Protocol qualifier in the final key. The width at each index\n corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_IP_PROTOCOL_ORDERs,  /* QUAL_IP_PROTOCOL_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for IP Protocol qualifier in the current partition.\n",
    },
    {
        .name  = NUM_QUAL_INGRESS_PORT_INFOs,  /* NUM_QUAL_INGRESS_PORT_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partition ID arrays\n for Ingress Port qualifier.\n",
    },
    {
        .name  = QUAL_INGRESS_PORT_OFFSETs,  /* QUAL_INGRESS_PORT_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of Ingress Port qualifier in the final key.",
    },
    {
        .name  = QUAL_INGRESS_PORT_WIDTHs,  /* QUAL_INGRESS_PORT_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of Ingress Port qualifier in the final key. The width at each index\n corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_INGRESS_PORT_ORDERs,  /* QUAL_INGRESS_PORT_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for Ingress Port qualifier in the current partition.\n",
    },
    {
        .name  = NUM_QUAL_UDF_2_BYTE_CONTAINER_INFOs,  /* NUM_QUAL_UDF_2_BYTE_CONTAINER_INFO */
        .flags = 0,
        .width = 8,
        .depth = 36,
        .desc = "Number of valid indexes in all the offsets, widths and order arrays\n for UDF 2 byte qualifier and its corresponding chunk as index to array.\n",
    },
    {
        .name  = QUAL_UDF_2_BYTE_CONTAINER_OFFSETs,  /* QUAL_UDF_2_BYTE_CONTAINER_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of UDF 2 byte qualifier in the final key.",
    },
    {
        .name  = QUAL_UDF_2_BYTE_CONTAINER_WIDTHs,  /* QUAL_UDF_2_BYTE_CONTAINER_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of UDF 2 byte qualifier in the final key. The width at each index\n corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_UDF_2_BYTE_CONTAINER_ORDERs,  /* QUAL_UDF_2_BYTE_CONTAINER_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for UDF 2 byte qualifier in the current partition.\n",
    },
    {
        .name  = EM_KEY_ATTRIBUTE_INDEXs,  /* EM_KEY_ATTRIBUTE_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Exact match entry key attribute profile index.\n",
    },
    {
        .name  = NUM_UDF_1_BYTE_CONTAINER_INFOs,  /* NUM_UDF_1_BYTE_CONTAINER_INFO */
        .flags = 0,
        .width = 8,
        .depth = 36,
        .desc = "Number of valid indexes in all the offsets, widths and order arrays\n for UDF 1 byte qualifier and its corresponding chunk as index to array.\n",
    },
    {
        .name  = QUAL_UDF_1_BYTE_CONTAINER_OFFSETs,  /* QUAL_UDF_1_BYTE_CONTAINER_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of UDF 1 byte qualifier in the final key.",
    },
    {
        .name  = QUAL_UDF_1_BYTE_CONTAINER_WIDTHs,  /* QUAL_UDF_1_BYTE_CONTAINER_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of UDF 1 byte qualifier in the final key. The width at each index\n corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_UDF_1_BYTE_CONTAINER_ORDERs,  /* QUAL_UDF_1_BYTE_CONTAINER_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for UDF 1 byte qualifier in the current partition.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_em_grp_template_partition_info_t = {
    .name = FP_EM_GRP_TEMPLATE_PARTITION_INFOs, /* FP_EM_GRP_TEMPLATE_PARTITION_INFO */
    .flags = 0,
    .fields = 35,
    .field = bcmltd_fp_em_grp_template_partition_info_t_fields,
    .desc = "The FP_EM_GRP_TEMPLATE_PARTITION_INFO table provides\n FP group partition specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EM_PDD_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_em_pdd_template_t_fields[] = {
    {
        .name  = FP_EM_PDD_TEMPLATE_IDs,  /* FP_EM_PDD_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "EM FP PDD identifier.",
    },
    {
        .name  = ACTION_METER_ENABLEs,  /* ACTION_METER_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow attaching meters to the FP entries.",
    },
    {
        .name  = ACTION_CTR_ENABLEs,  /* ACTION_CTR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow attaching counters to the FP entries.",
    },
    {
        .name  = ACTION_R_DROPs,  /* ACTION_R_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = ACTION_Y_DROPs,  /* ACTION_Y_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop yellow packet.",
    },
    {
        .name  = ACTION_G_DROPs,  /* ACTION_G_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop green packet.",
    },
    {
        .name  = ACTION_MIRROR_INSTANCE_ENABLEs,  /* ACTION_MIRROR_INSTANCE_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable the mirror instance at the specified index.",
    },
    {
        .name  = ACTION_MIRROR_INSTANCE_IDs,  /* ACTION_MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Array of mirror instances.",
    },
    {
        .name  = ACTION_HGT_SPRAY_HASH_CANCELs,  /* ACTION_HGT_SPRAY_HASH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable spray hash on HiGiG Ports trunk.",
    },
    {
        .name  = ACTION_TRUNK_SPRAY_HASH_CANCELs,  /* ACTION_TRUNK_SPRAY_HASH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable spray hash on front panel ports trunk.",
    },
    {
        .name  = ACTION_ECMP_SPRAY_HASH_CANCELs,  /* ACTION_ECMP_SPRAY_HASH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable spray hash on ECMP group.",
    },
    {
        .name  = ACTION_DO_NOT_NATs,  /* ACTION_DO_NOT_NAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not NAT.",
    },
    {
        .name  = ACTION_MATCH_IDs,  /* ACTION_MATCH_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set the match ID to packets copied to CPU. This action\n is applied only if COPY_TO_CPU action is present in\n the same POLICY_TEMPLATE entry.\n",
    },
    {
        .name  = ACTION_R_COPY_TO_CPUs,  /* ACTION_R_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy yellow packet to CPU.",
    },
    {
        .name  = ACTION_R_COPY_TO_CPU_CANCELs,  /* ACTION_R_COPY_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy red packet to CPU action set\n by the lower priority rule for yellow packet.\n",
    },
    {
        .name  = ACTION_R_SWITCH_TO_CPU_CANCELs,  /* ACTION_R_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Switch to CPU cancel -- Cancel the signal set\n by ingress pipeline to switch the packet to CPU\n for red packet.\n",
    },
    {
        .name  = ACTION_R_SWITCH_TO_CPU_REINSATEs,  /* ACTION_R_SWITCH_TO_CPU_REINSATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cancel switch to CPU - To cancel the 'Cancel\n switch to CPU' action set by the lower priority rule\n for red packet\n",
    },
    {
        .name  = ACTION_R_COPY_AND_SWITCH_TO_CPU_CANCELs,  /* ACTION_R_COPY_AND_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy packet to CPU action set by the lower priority rule\n and the signal set by ingress pipeline to switch the packets to\n CPU for red packets.\n",
    },
    {
        .name  = ACTION_R_COPY_TO_CPU_WITH_TIMESTAMPs,  /* ACTION_R_COPY_TO_CPU_WITH_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy packet to CPU with time stamp for red packet.",
    },
    {
        .name  = ACTION_Y_COPY_TO_CPUs,  /* ACTION_Y_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy yellow packet to CPU.",
    },
    {
        .name  = ACTION_Y_COPY_TO_CPU_CANCELs,  /* ACTION_Y_COPY_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy green packet to CPU action set\n by the lower priority rule for yellow packet.\n",
    },
    {
        .name  = ACTION_Y_SWITCH_TO_CPU_CANCELs,  /* ACTION_Y_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Switch to CPU cancel - Cancel the signal set\n by ingress pipeline to switch the packet to CPU\n for yellow packet.\n",
    },
    {
        .name  = ACTION_Y_SWITCH_TO_CPU_REINSATEs,  /* ACTION_Y_SWITCH_TO_CPU_REINSATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cancel switch to CPU - To cancel the 'Cancel\n switch to CPU' action set by the lower priority rule\n for yellow packet.\n",
    },
    {
        .name  = ACTION_Y_COPY_AND_SWITCH_TO_CPU_CANCELs,  /* ACTION_Y_COPY_AND_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy packet to CPU action set by the lower priority rule\n and the signal set by ingress pipeline to switch the packets to\n CPU for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_COPY_TO_CPU_WITH_TIMESTAMPs,  /* ACTION_Y_COPY_TO_CPU_WITH_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy packet to CPU with time stamp for yellow packet.",
    },
    {
        .name  = ACTION_G_COPY_TO_CPUs,  /* ACTION_G_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy green packet to CPU .",
    },
    {
        .name  = ACTION_G_COPY_TO_CPU_CANCELs,  /* ACTION_G_COPY_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy green packet to CPU action set\n by the lower priority rule for green packet.\n",
    },
    {
        .name  = ACTION_G_SWITCH_TO_CPU_CANCELs,  /* ACTION_G_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Switch to CPU cancel - Cancel the signal set\n by ingress pipeline to switch the packet to CPU\n for green packet.\n",
    },
    {
        .name  = ACTION_G_SWITCH_TO_CPU_REINSATEs,  /* ACTION_G_SWITCH_TO_CPU_REINSATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cancel switch to CPU - To cancel the 'Cancel\n switch to CPU' action set by the lower priority rule\n for green packet.\n",
    },
    {
        .name  = ACTION_G_COPY_AND_SWITCH_TO_CPU_CANCELs,  /* ACTION_G_COPY_AND_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy packet to CPU action set by the lower priority rule\n and the signal set by ingress pipeline to switch the packets to\n CPU for green packets.\n",
    },
    {
        .name  = ACTION_G_COPY_TO_CPU_WITH_TIMESTAMPs,  /* ACTION_G_COPY_TO_CPU_WITH_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy packet to CPU with time stamp for green packet.",
    },
    {
        .name  = ACTION_DO_NOT_CUT_THROUGHs,  /* ACTION_DO_NOT_CUT_THROUGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cut-through the packet if ingress pipeline\n set the packet to cutthrough.\n",
    },
    {
        .name  = ACTION_DO_NOT_URPFs,  /* ACTION_DO_NOT_URPF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not URPF if the ingress pipilne set the packet to URPF.",
    },
    {
        .name  = ACTION_DO_NOT_CHANGE_TTLs,  /* ACTION_DO_NOT_CHANGE_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not change packet TTL.",
    },
    {
        .name  = ACTION_CHANGE_PKT_L2_FIELDSs,  /* ACTION_CHANGE_PKT_L2_FIELDS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change different L2 Fields in the packet with new values.\n New values comes from EGR_L3_NEXT_HOP (view type: IFP_ACTIONS)\n L2 Fields that can be modified using this action:\n Source MAC address\n Destination MAC address\n Outer VLAN\n VnTag (Modify/Delete)\n Etag (Modify/Delete)\n",
    },
    {
        .name  = ACTION_CHANGE_PKT_L2_FIELDS_CANCELs,  /* ACTION_CHANGE_PKT_L2_FIELDS_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Dont Change L2 fieldsin the packet. It cancels Action from\n CHANGE_PKT_L2_FIELDS set by the lower priority rule\n",
    },
    {
        .name  = ACTION_NEW_CLASSIFICATION_TAGs,  /* ACTION_NEW_CLASSIFICATION_TAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Add classification Tag.",
    },
    {
        .name  = ACTION_SWITCH_TO_L3UCs,  /* ACTION_SWITCH_TO_L3UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Switch the packet to L3 unicast Destination.",
    },
    {
        .name  = ACTION_SWITCH_TO_ECMPs,  /* ACTION_SWITCH_TO_ECMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Switch the packet to ECMP group.",
    },
    {
        .name  = ACTION_ECMP_HASHs,  /* ACTION_ECMP_HASH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "ECMP hash value to be used. FP_ING_ECMP_HASH_ENABLE in the\n  FP_CONTROL table, with some optional control fields also has to be\n  set to enable this action.\n",
    },
    {
        .name  = ACTION_L3_SWITCH_CANCELs,  /* ACTION_L3_SWITCH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel L3 switch action set by the lower priority rule.",
    },
    {
        .name  = ACTION_ING_CLASS_ID_SELECTs,  /* ACTION_ING_CLASS_ID_SELECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Select the type of ingress class ID to pass to egress pipeline..",
    },
    {
        .name  = ACTION_HIGIG_CLASS_ID_SELECTs,  /* ACTION_HIGIG_CLASS_ID_SELECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Select HiGig class ID.",
    },
    {
        .name  = ACTION_FP_ING_CLASS_IDs,  /* ACTION_FP_ING_CLASS_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assign a new class ID.",
    },
    {
        .name  = ACTION_NEW_CPU_COSs,  /* ACTION_NEW_CPU_COS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set new COS to packets copied to or switched to CPU\n This Action is conflicting with NEW_SERVICE_POOL_ID\n Only one can be set at a time\n",
    },
    {
        .name  = ACTION_NEW_SERVICE_POOL_IDs,  /* ACTION_NEW_SERVICE_POOL_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set the new service Pool ID\n This Action is conflicting with NEW_CPU_COS\n Only one can be set at a time\n",
    },
    {
        .name  = ACTION_R_DROP_CANCELs,  /* ACTION_R_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for red packet.",
    },
    {
        .name  = ACTION_Y_DROP_CANCELs,  /* ACTION_Y_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for yellow packet.",
    },
    {
        .name  = ACTION_G_DROP_CANCELs,  /* ACTION_G_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for green packet.",
    },
    {
        .name  = ACTION_MIRROR_OVERRIDEs,  /* ACTION_MIRROR_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Override the mirror. This field generates a single mirror\n Override action out of the physical slice. This action is\n used to cancel all mirror copies of the packet (Ingress FP generated\n mirror copies and switch-logic generated mirror copies).\n",
    },
    {
        .name  = ACTION_SFLOW_ENABLEs,  /* ACTION_SFLOW_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable sFlow on packet.",
    },
    {
        .name  = ACTION_MIRROR_ING_FLEX_SFLOW_IDs,  /* ACTION_MIRROR_ING_FLEX_SFLOW_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Ingress sFlow sample index.",
    },
    {
        .name  = ACTION_MIRROR_FLOW_CLASS_ENABLEs,  /* ACTION_MIRROR_FLOW_CLASS_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MIRROR_FLOW_CLASS on packets. This will override hash based\n MIRROR_FLOW_CLASS.\n",
    },
    {
        .name  = ACTION_MIRROR_FLOW_CLASSs,  /* ACTION_MIRROR_FLOW_CLASS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mirror flow class for selecting the mirror destination\n",
    },
    {
        .name  = ACTION_VISIBILITY_ENABLEs,  /* ACTION_VISIBILITY_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to mark an ingress packet as a visibility packet,\n similar to CPU masquerading feature.\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_MODULEs,  /* ACTION_REDIRECT_TO_MODULE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Redirect to module and do switch logic forwarding\n modifications\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_PORTs,  /* ACTION_REDIRECT_TO_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Redirect to system physical Port and do switch logic forwarding\n modifications\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_DVPs,  /* ACTION_REDIRECT_TO_DVP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Redirect to DVP.",
    },
    {
        .name  = ACTION_REDIRECT_TO_TRUNKs,  /* ACTION_REDIRECT_TO_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Redirect to trunk and do switch logic forwarding modifications.",
    },
    {
        .name  = ACTION_UNMODIFIED_REDIRECT_TO_MODULEs,  /* ACTION_UNMODIFIED_REDIRECT_TO_MODULE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Redirect to module but do not perform switch logic forwarding\n modifications\n",
    },
    {
        .name  = ACTION_UNMODIFIED_REDIRECT_TO_TRUNKs,  /* ACTION_UNMODIFIED_REDIRECT_TO_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Redirect to trunk but do not perform switch logic forwarding\n modifications\n",
    },
    {
        .name  = ACTION_UNMODIFIED_REDIRECT_TO_PORTs,  /* ACTION_UNMODIFIED_REDIRECT_TO_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Redirect to system physical port and do not perform switch logic\n forwarding modifications\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_NHOPs,  /* ACTION_REDIRECT_TO_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Redirect to next hop.",
    },
    {
        .name  = ACTION_REDIRECT_TO_ECMPs,  /* ACTION_REDIRECT_TO_ECMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Redirect to ECMP group.",
    },
    {
        .name  = ACTION_REDIRECT_UC_CANCELs,  /* ACTION_REDIRECT_UC_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not redirect to unicast destination.\n Cancels all unicast redirect actions set by the lower prioirty rule.\n",
    },
    {
        .name  = ACTION_REDIRECT_PORTS_BROADCAST_PKTs,  /* ACTION_REDIRECT_PORTS_BROADCAST_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to replace the pipeline generated egress port bitmap with the\n new egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_ADD_PORTS_BROADCASTs,  /* ACTION_REDIRECT_ADD_PORTS_BROADCAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add ports to the pipeline generated egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_REMOVE_PORTS_BROADCASTs,  /* ACTION_REDIRECT_REMOVE_PORTS_BROADCAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove ports from the pipeline generated egress port\n bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_PORTS_VLAN_BROADCASTs,  /* ACTION_REDIRECT_PORTS_VLAN_BROADCAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to redirect packets to all ports associated with the incoming\n VLAN instead of the pipeline generated egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_PORTS_VLAN_BROADCAST_FP_INGs,  /* ACTION_REDIRECT_PORTS_VLAN_BROADCAST_FP_ING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to redirect packets to new ports in the incoming VLAN instead\n of pipeline generated egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_L2_MC_GROUP_IDs,  /* ACTION_REDIRECT_L2_MC_GROUP_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to redirect the packet using the L2 multicast index.",
    },
    {
        .name  = ACTION_REDIRECT_L3_MC_NHOP_IDs,  /* ACTION_REDIRECT_L3_MC_NHOP_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to redirect the packet using the L3 multicast index.",
    },
    {
        .name  = ACTION_FP_ING_REDIRECT_DATA_IDs,  /* ACTION_FP_ING_REDIRECT_DATA_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify the index into the FP_ING_REDIRECT_DATA table.\n",
    },
    {
        .name  = ACTION_FP_ING_REMOVE_REDIRECT_DATA_IDs,  /* ACTION_FP_ING_REMOVE_REDIRECT_DATA_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify the index into the FP_ING_REMOVE_REDIRECT_DATA\n table.\n",
    },
    {
        .name  = ACTION_FP_ING_ADD_REDIRECT_DATA_IDs,  /* ACTION_FP_ING_ADD_REDIRECT_DATA_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify the index into the FP_ING_ADD_REDIRECT_DATA table.\n",
    },
    {
        .name  = ACTION_DISABLE_SRC_PRUNINGs,  /* ACTION_DISABLE_SRC_PRUNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to disable source pruning.\n",
    },
    {
        .name  = ACTION_NEW_HIGIG_EHs,  /* ACTION_NEW_HIGIG_EH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Add HiGiG extended header.",
    },
    {
        .name  = ACTION_HIGIG_EH_MASK_PROFILE_IDs,  /* ACTION_HIGIG_EH_MASK_PROFILE_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "HiGig extended header profile ID.",
    },
    {
        .name  = ACTION_NAT_EGR_OVERRIDEs,  /* ACTION_NAT_EGR_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Override egress NAT.",
    },
    {
        .name  = ACTION_ING_TIMESTAMP_INSERTs,  /* ACTION_ING_TIMESTAMP_INSERT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Insert ingress pipe received time stamp.",
    },
    {
        .name  = ACTION_ING_TIMESTAMP_INSERT_CANCELs,  /* ACTION_ING_TIMESTAMP_INSERT_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the ingress timestamp action set by the lower priority rule.",
    },
    {
        .name  = ACTION_EGR_TIMESTAMP_INSERTs,  /* ACTION_EGR_TIMESTAMP_INSERT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Insert egress pipe trasmitted time stamp.",
    },
    {
        .name  = ACTION_EGR_TIMESTAMP_INSERT_CANCELs,  /* ACTION_EGR_TIMESTAMP_INSERT_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the egress timestamp action set tby the lower priority rule.",
    },
    {
        .name  = ACTION_EXACT_MATCH_CLASS_IDs,  /* ACTION_EXACT_MATCH_CLASS_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assign a new class ID to pass to egress pipeline.",
    },
    {
        .name  = ACTION_FLEX_CTR_R_COUNTs,  /* ACTION_FLEX_CTR_R_COUNT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Count red packets and provide adjustment to\n CTR_ING_FLEX_BASE_INDEX.\n",
    },
    {
        .name  = ACTION_FLEX_CTR_Y_COUNTs,  /* ACTION_FLEX_CTR_Y_COUNT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Count yellow packets and provide adjustment to\n CTR_ING_FLEX_BASE_INDEX.\n",
    },
    {
        .name  = ACTION_FLEX_CTR_G_COUNTs,  /* ACTION_FLEX_CTR_G_COUNT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Count green packets and provide adjustment to\n CTR_ING_FLEX_BASE_INDEX.\n",
    },
    {
        .name  = ACTION_ETRAP_COLOR_DISABLEs,  /* ACTION_ETRAP_COLOR_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable color and COS for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_COLOR_ENABLEs,  /* ACTION_ETRAP_COLOR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable color and COS for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_LOOKUP_DISABLEs,  /* ACTION_ETRAP_LOOKUP_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable lookup for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_LOOKUP_ENABLEs,  /* ACTION_ETRAP_LOOKUP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable lookup for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_QUEUE_DISABLEs,  /* ACTION_ETRAP_QUEUE_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable queue assignment for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_QUEUE_ENABLEs,  /* ACTION_ETRAP_QUEUE_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable queue assignment for elephant flows.",
    },
    {
        .name  = ACTION_DLB_ECMP_MONITOR_DISABLEs,  /* ACTION_DLB_ECMP_MONITOR_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable ECMP monitor during Dynamic Load Balancing(DLB).",
    },
    {
        .name  = ACTION_DLB_ECMP_MONITOR_ENABLEs,  /* ACTION_DLB_ECMP_MONITOR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ECMP monitor during Dynamic Load Balancing(DLB).",
    },
    {
        .name  = ACTION_MIRROR_EGR_ZERO_PAYLOAD_PROFILE_IDs,  /* ACTION_MIRROR_EGR_ZERO_PAYLOAD_PROFILE_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable zeroing (payload wiping) on any mirrored packet\n and sets the corresponding profile ID to determine the\n offsets to start for zeroing for the payload.\n",
    },
    {
        .name  = ACTION_DELAYED_DROP_ENABLEs,  /* ACTION_DELAYED_DROP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable delayed drop action specified by ACTION_FP_DELAYED_DROP_ID.\n",
    },
    {
        .name  = ACTION_FP_DELAYED_DROP_IDs,  /* ACTION_FP_DELAYED_DROP_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Index to FP_DELAYED_DROP table used to program\n delayed drop action related controls. Applicable when\n ACTION_DELAYED_DROP_ENABLE is enabled.\n",
    },
    {
        .name  = ACTION_DELAYED_REDIRECT_ENABLEs,  /* ACTION_DELAYED_REDIRECT_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable delayed redirect action specified by\n ACTION_FP_DELAYED_REDIRECT_ID and ACTION_DELAYED_REDIRECT_PORT.\n",
    },
    {
        .name  = ACTION_FP_DELAYED_REDIRECT_IDs,  /* ACTION_FP_DELAYED_REDIRECT_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Index to FP_DELAYED_REDIRECT table used to program\n delayed redirect action related controls.\n This should be programmed along with ACTION_DELAYED_REDIRECT_PORT\n for the action to take effect. Applicable when\n ACTION_DELAYED_REDIRECT_ENABLE is enabled.\n",
    },
    {
        .name  = ACTION_DELAYED_REDIRECT_PORTs,  /* ACTION_DELAYED_REDIRECT_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Redirect port where the packets need to be redirected to, in case\n of a delayed redirection action.\n This should be programmed along with ACTION_FP_DELAYED_REDIRECT_ID.\n for the action to take effect. Applicable when\n ACTION_DELAYED_REDIRECT_ENABLE is enabled.\n",
    },
    {
        .name  = ACTION_MIRROR_ON_DROP_TM_ENABLEs,  /* ACTION_MIRROR_ON_DROP_TM_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mirror on DROP enable for TM.\n",
    },
    {
        .name  = ACTION_MIRROR_ON_DROP_TM_DISABLEs,  /* ACTION_MIRROR_ON_DROP_TM_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mirror on DROP disable for TM.\n",
    },
    {
        .name  = ACTION_MIRROR_ON_DROP_TM_PROFILE_IDs,  /* ACTION_MIRROR_ON_DROP_TM_PROFILE_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify the index into the TM_MIRROR_ON_DROP_PROFILE table.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_ENCAP_ENABLEs,  /* ACTION_INBAND_TELEMETRY_ENCAP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable inband network telemetry encapsulation.\n This action triggers to encapsulate\n the inband network telemetry (INT) metadata\n in the egress stage for a given packet.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_ENCAP_DISABLEs,  /* ACTION_INBAND_TELEMETRY_ENCAP_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable inband network telemetry encapsulation.\n This action force disables the encapsulation which\n is triggered by the INT module in the ingress stage.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_PROFILE_IDXs,  /* ACTION_INBAND_TELEMETRY_PROFILE_IDX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inband network telemetry action profile index.",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_SAMPLE_ENABLEs,  /* ACTION_INBAND_TELEMETRY_SAMPLE_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to apply the inband network telemetry action profile scope\n only to sampled packets matching this flow.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_FLOW_CLASS_IDs,  /* ACTION_INBAND_TELEMETRY_FLOW_CLASS_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inband network telemetry flow class ID. Used to index\n INT_FLOW_METADATA table and this will overrides the FLOW_CLASS_ID\n assigned by LPM.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_TERM_ACTION_PROFILE_IDXs,  /* ACTION_INBAND_TELEMETRY_TERM_ACTION_PROFILE_IDX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inband network telemetry action profile index assigned when the\n destination port bitmap check result is TRUE. This overrides the\n INBAND_ACTION_PROFILE_IDX.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_EGR_LOOPBACK_PROFILE_IDXs,  /* ACTION_INBAND_TELEMETRY_EGR_LOOPBACK_PROFILE_IDX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Index to EGR_LOOPBACK_PROFILE table.",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_0s,  /* ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inband network telemetry MMU request 0.",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_1s,  /* ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inband network telemetry MMU request 1.",
    },
    {
        .name  = ACTION_NEW_SERVICE_POOL_PRECEDENCEs,  /* ACTION_NEW_SERVICE_POOL_PRECEDENCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set the service pool ID's new precedence.\n",
    },
    {
        .name  = ACTION_DGMs,  /* ACTION_DGM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set dynamic group multipath enable for load balancing.\n",
    },
    {
        .name  = ACTION_DGM_BIASs,  /* ACTION_DGM_BIAS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set alternate path bias for dynamic group multipath.\n",
    },
    {
        .name  = ACTION_DGM_COSTs,  /* ACTION_DGM_COST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set alternate path cost for dynamic group multipath.\n",
    },
    {
        .name  = ACTION_DGM_THRESHOLDs,  /* ACTION_DGM_THRESHOLD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set alternate path threshold for dynamic group multipath.\n",
    },
    {
        .name  = ACTION_PROTECTION_SWITCHING_DROP_OVERRIDEs,  /* ACTION_PROTECTION_SWITCHING_DROP_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to override the protection switching drop.\n",
    },
    {
        .name  = ACTION_DYNAMIC_ECMP_CANCELs,  /* ACTION_DYNAMIC_ECMP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to prefer hash based load balancing over dynamic.",
    },
    {
        .name  = ACTION_DYNAMIC_ECMP_ENABLEs,  /* ACTION_DYNAMIC_ECMP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to prefer dynamic load balancing over hash based.",
    },
    {
        .name  = CTR_ING_EFLEX_CONTAINER_IDs,  /* CTR_ING_EFLEX_CONTAINER_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable for the flex counter conatiner id\n",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = ACTION_DCN_ENABLEs,  /* ACTION_DCN_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mark packets as eligible for DCN",
    },
    {
        .name  = ACTION_DCN_DISABLEs,  /* ACTION_DCN_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mark packets as not eligible for DCN",
    },
    {
        .name  = ACTION_GREEN_TO_PIDs,  /* ACTION_GREEN_TO_PID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Treat all packets as green",
    },
};
const bcmltd_table_rep_t bcmltd_fp_em_pdd_template_t = {
    .name = FP_EM_PDD_TEMPLATEs, /* FP_EM_PDD_TEMPLATE */
    .flags = 0,
    .fields = 126,
    .field = bcmltd_fp_em_pdd_template_t_fields,
    .desc = "The FP_EM_PDD_TEMPLATE specifies the exact match FP PDD actions that can\n be associated to the group. The FP EM policy is distributed across multiple\n physical tables, some using PDD policy and others using a flat policy. All\n of the fields in the FP_EM_POLICY_TEMPLATE table are present in this logical\n table with the exception of the QoS actions which use a flat policy.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EM_PDD_TEMPLATE_PARTITION_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_em_pdd_template_partition_info_t_fields[] = {
    {
        .name  = FP_EM_PDD_TEMPLATE_IDs,  /* FP_EM_PDD_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP PDD template ID.",
    },
    {
        .name  = PARTITION_IDs,  /* PARTITION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Partition ID.",
    },
    {
        .name  = NUM_ACTION_COPY_TO_CPU_INFOs,  /* NUM_ACTION_COPY_TO_CPU_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partids arrays for\n copy to cpu action.\n",
    },
    {
        .name  = ACTION_COPY_TO_CPU_OFFSETs,  /* ACTION_COPY_TO_CPU_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of copy to cpu action in the final policy.",
    },
    {
        .name  = ACTION_COPY_TO_CPU_WIDTHs,  /* ACTION_COPY_TO_CPU_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of copy to cpu action in the final policy. Width at each index\n is corresponding to offset at the same index.\n",
    },
    {
        .name  = ACTION_COPY_TO_CPU_ORDERs,  /* ACTION_COPY_TO_CPU_ORDER */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of copy to cpu action in the final policy. Width at each index\n is corresponding to offset at the same index.\n",
    },
    {
        .name  = NUM_ACTION_FLEX_CTR_INFOs,  /* NUM_ACTION_FLEX_CTR_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partids arrays for\n flex ctr action.\n",
    },
    {
        .name  = ACTION_FLEX_CTR_OFFSETs,  /* ACTION_FLEX_CTR_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of flex ctr action in the final policy.",
    },
    {
        .name  = ACTION_FLEX_CTR_WIDTHs,  /* ACTION_FLEX_CTR_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of flex ctr action in the final policy. Width at each index\n is corresponding to offset at the same index.\n",
    },
    {
        .name  = NUM_ACTION_OPAQUE_OBJ0_INFOs,  /* NUM_ACTION_OPAQUE_OBJ0_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partids arrays for\n opaque obj 0 action.\n",
    },
    {
        .name  = ACTION_OPAQUE_OBJ0_OFFSETs,  /* ACTION_OPAQUE_OBJ0_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of opaque obj 0 action in the final policy.",
    },
    {
        .name  = ACTION_OPAQUE_OBJ0_WIDTHs,  /* ACTION_OPAQUE_OBJ0_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of opaque obj 0 action in the final policy. Width at each index\n is corresponding to offset at the same index.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_em_pdd_template_partition_info_t = {
    .name = FP_EM_PDD_TEMPLATE_PARTITION_INFOs, /* FP_EM_PDD_TEMPLATE_PARTITION_INFO */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_fp_em_pdd_template_partition_info_t_fields,
    .desc = "The FP_EM_PDD_TEMPLATE_PARTITION_INFO table provides FP PDD-specific partition information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EM_POLICY_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_em_policy_template_t_fields[] = {
    {
        .name  = FP_EM_POLICY_TEMPLATE_IDs,  /* FP_EM_POLICY_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Exact match FP policy identifier.",
    },
    {
        .name  = ACTION_R_DROPs,  /* ACTION_R_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop red packets.",
    },
    {
        .name  = ACTION_Y_DROPs,  /* ACTION_Y_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop yellow packets.",
    },
    {
        .name  = ACTION_G_DROPs,  /* ACTION_G_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop green packets.",
    },
    {
        .name  = ACTION_NEW_UNTAG_PKT_PRIORITYs,  /* ACTION_NEW_UNTAG_PKT_PRIORITY */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change packets input priority.",
    },
    {
        .name  = ACTION_R_NEW_COLORs,  /* ACTION_R_NEW_COLOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Change packet color for red packets.",
    },
    {
        .name  = ACTION_Y_NEW_COLORs,  /* ACTION_Y_NEW_COLOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Change packet color for yellow packets.",
    },
    {
        .name  = ACTION_G_NEW_COLORs,  /* ACTION_G_NEW_COLOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Change packet color for green packets.",
    },
    {
        .name  = ACTION_R_FP_ING_COS_Q_INT_PRI_MAP_IDs,  /* ACTION_R_FP_ING_COS_Q_INT_PRI_MAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue using\n FP_ING_COS_Q_INT_PRI_MAP table for red packets.\n",
    },
    {
        .name  = ACTION_R_NEW_COSs,  /* ACTION_R_NEW_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue for red packets.\n Lower 4 bits value is used for changing the unicast COS queue and\n the upper 4 bits value is used for changing the multicast COS queue\n value.\n",
    },
    {
        .name  = ACTION_R_INTPRI_TO_INNER_DOT1Ps,  /* ACTION_R_INTPRI_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to packets inner VLAN tag dot1p priority\n for red packets.\n",
    },
    {
        .name  = ACTION_R_NEW_INTPRIs,  /* ACTION_R_NEW_INTPRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Change internal priority to a new value for red packets.",
    },
    {
        .name  = ACTION_R_INTPRI_TO_TOSs,  /* ACTION_R_INTPRI_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to MSB 3 bits from IP header\n TOS field for red packets.\n",
    },
    {
        .name  = ACTION_R_INTPRI_UPDATES_CANCELs,  /* ACTION_R_INTPRI_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change to internal priority cancel for red packets.",
    },
    {
        .name  = ACTION_R_NEW_UC_COSs,  /* ACTION_R_NEW_UC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS for red packets.",
    },
    {
        .name  = ACTION_R_NEW_MC_COSs,  /* ACTION_R_NEW_MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change multicast COS for red packets.",
    },
    {
        .name  = ACTION_Y_FP_ING_COS_Q_INT_PRI_MAP_IDs,  /* ACTION_Y_FP_ING_COS_Q_INT_PRI_MAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue using\n FP_ING_COS_Q_INT_PRI_MAP table for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_NEW_COSs,  /* ACTION_Y_NEW_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue for yellow packets.\n Lower 4 bits value is used for changing the unicast COS queue and\n the upper 4 bits value is used for changing the multicast COS queue\n value.\n",
    },
    {
        .name  = ACTION_Y_INTPRI_TO_INNER_DOT1Ps,  /* ACTION_Y_INTPRI_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to packets inner VLAN tag dot1p priority\n for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_NEW_INTPRIs,  /* ACTION_Y_NEW_INTPRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Change internal priority to a new value for yellow packets.",
    },
    {
        .name  = ACTION_Y_INTPRI_TO_TOSs,  /* ACTION_Y_INTPRI_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to MSB 3 bits from IP header\n TOS field for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_INTPRI_UPDATES_CANCELs,  /* ACTION_Y_INTPRI_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to a new value for yellow packets.",
    },
    {
        .name  = ACTION_Y_NEW_UC_COSs,  /* ACTION_Y_NEW_UC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue for yellow packets.",
    },
    {
        .name  = ACTION_Y_NEW_MC_COSs,  /* ACTION_Y_NEW_MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change multicast COS queue for yellow packets.",
    },
    {
        .name  = ACTION_G_FP_ING_COS_Q_INT_PRI_MAP_IDs,  /* ACTION_G_FP_ING_COS_Q_INT_PRI_MAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue using\n FP_ING_COS_Q_INT_PRI_MAP table for green packets.\n",
    },
    {
        .name  = ACTION_G_NEW_COSs,  /* ACTION_G_NEW_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue for green packets.\n Lower 4 bits value is used for changing the unicast COS queue and\n the upper 4 bits value is used for changing the multicast COS queue\n value.\n",
    },
    {
        .name  = ACTION_G_INTPRI_TO_INNER_DOT1Ps,  /* ACTION_G_INTPRI_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to packets inner VLAN tag dot1p priority\n for green packets.\n",
    },
    {
        .name  = ACTION_G_NEW_INTPRIs,  /* ACTION_G_NEW_INTPRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Change internal priority to a new value for green packets.",
    },
    {
        .name  = ACTION_G_INTPRI_TO_TOSs,  /* ACTION_G_INTPRI_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to MSB 3 bits from IP header\n TOS field for green packets.\n",
    },
    {
        .name  = ACTION_G_INTPRI_UPDATES_CANCELs,  /* ACTION_G_INTPRI_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to a new value for green packets.",
    },
    {
        .name  = ACTION_G_NEW_UC_COSs,  /* ACTION_G_NEW_UC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue for green packets.",
    },
    {
        .name  = ACTION_G_NEW_MC_COSs,  /* ACTION_G_NEW_MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change multicast COS queue for green packets.",
    },
    {
        .name  = ACTION_MIRROR_INSTANCE_ENABLEs,  /* ACTION_MIRROR_INSTANCE_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable the mirror instance at the index.",
    },
    {
        .name  = ACTION_MIRROR_INSTANCE_IDs,  /* ACTION_MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 4,
        .desc = "Array of mirror instances.",
    },
    {
        .name  = ACTION_HGT_SPRAY_HASH_CANCELs,  /* ACTION_HGT_SPRAY_HASH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable spray hash on HiGiG ports trunk.",
    },
    {
        .name  = ACTION_TRUNK_SPRAY_HASH_CANCELs,  /* ACTION_TRUNK_SPRAY_HASH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable spray hash on front panel ports trunk.",
    },
    {
        .name  = ACTION_ECMP_SPRAY_HASH_CANCELs,  /* ACTION_ECMP_SPRAY_HASH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable spray hash on ECMP group.",
    },
    {
        .name  = ACTION_DO_NOT_NATs,  /* ACTION_DO_NOT_NAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not NAT.",
    },
    {
        .name  = ACTION_MATCH_IDs,  /* ACTION_MATCH_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set the match ID to packets copied to CPU. This action\n is applied only if COPY_TO_CPU action is present in\n the same POLICY_TEMPLATE  entry.\n",
    },
    {
        .name  = ACTION_R_COPY_TO_CPUs,  /* ACTION_R_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy yellow packet to CPU.",
    },
    {
        .name  = ACTION_R_COPY_TO_CPU_CANCELs,  /* ACTION_R_COPY_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy red packet to CPU action set\n by the lower priority rule for yellow packets.\n",
    },
    {
        .name  = ACTION_R_SWITCH_TO_CPU_CANCELs,  /* ACTION_R_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Switch to CPU cancel - Cancel the signal set\n by ingress pipeline to switch the packet to CPU\n for red packets.\n",
    },
    {
        .name  = ACTION_R_SWITCH_TO_CPU_REINSATEs,  /* ACTION_R_SWITCH_TO_CPU_REINSATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cancel switch to CPU - To cancel the 'Cancel\n switch to CPU' action set by the lower priority rule\n for red packets.\n",
    },
    {
        .name  = ACTION_R_COPY_AND_SWITCH_TO_CPU_CANCELs,  /* ACTION_R_COPY_AND_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy packet to CPU action set by the lower priority rule\n and the signal set by ingress pipeline to switch the packets to\n CPU for red packets.\n",
    },
    {
        .name  = ACTION_R_COPY_TO_CPU_WITH_TIMESTAMPs,  /* ACTION_R_COPY_TO_CPU_WITH_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy packet to CPU with time stamp for red packets.",
    },
    {
        .name  = ACTION_Y_COPY_TO_CPUs,  /* ACTION_Y_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy yellow packet to CPU.",
    },
    {
        .name  = ACTION_Y_COPY_TO_CPU_CANCELs,  /* ACTION_Y_COPY_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy green packet to CPU action set\n by the lower priority rule for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_SWITCH_TO_CPU_CANCELs,  /* ACTION_Y_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Switch to CPU cancel - Cancel the signal set\n by ingress pipeline to switch the packet to CPU\n for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_SWITCH_TO_CPU_REINSATEs,  /* ACTION_Y_SWITCH_TO_CPU_REINSATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cancel switch to CPU - To cancel the 'Cancel\n switch to CPU' action set by the lower priority rule\n for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_COPY_AND_SWITCH_TO_CPU_CANCELs,  /* ACTION_Y_COPY_AND_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy packet to CPU action set by the lower priority rule\n and the signal set by ingress pipeline to switch the packets to\n CPU for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_COPY_TO_CPU_WITH_TIMESTAMPs,  /* ACTION_Y_COPY_TO_CPU_WITH_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy packet to CPU with time stamp for yellow packets.",
    },
    {
        .name  = ACTION_G_COPY_TO_CPUs,  /* ACTION_G_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy green packet to CPU .",
    },
    {
        .name  = ACTION_G_COPY_TO_CPU_CANCELs,  /* ACTION_G_COPY_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy green packet to CPU action set\n by the lower priority rule for green packets.\n",
    },
    {
        .name  = ACTION_G_SWITCH_TO_CPU_CANCELs,  /* ACTION_G_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Switch to CPU cancel - Cancel the signal set\n by ingress pipeline to switch the packet to CPU\n for green packets.\n",
    },
    {
        .name  = ACTION_G_SWITCH_TO_CPU_REINSATEs,  /* ACTION_G_SWITCH_TO_CPU_REINSATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cancel switch to CPU - To cancel the 'Cancel\n switch to CPU' action set by the lower priority rule\n for green packets.\n",
    },
    {
        .name  = ACTION_G_COPY_AND_SWITCH_TO_CPU_CANCELs,  /* ACTION_G_COPY_AND_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy packet to CPU action set by the lower priority rule\n and the signal set by ingress pipeline to switch the packets to\n CPU for green packets.\n",
    },
    {
        .name  = ACTION_G_COPY_TO_CPU_WITH_TIMESTAMPs,  /* ACTION_G_COPY_TO_CPU_WITH_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy packet to CPU with time stamp for green packets.",
    },
    {
        .name  = ACTION_DO_NOT_CUT_THROUGHs,  /* ACTION_DO_NOT_CUT_THROUGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cut-through the packet if ingress pipeline\n set the packet to cutthrough.\n",
    },
    {
        .name  = ACTION_DO_NOT_URPFs,  /* ACTION_DO_NOT_URPF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not URPF if the ingress pipilne set the packet to URPF.",
    },
    {
        .name  = ACTION_DO_NOT_CHANGE_TTLs,  /* ACTION_DO_NOT_CHANGE_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not change packet TTL.",
    },
    {
        .name  = ACTION_R_NEW_ECNs,  /* ACTION_R_NEW_ECN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change ECN for red packet.",
    },
    {
        .name  = ACTION_R_PRESERVE_DOT1Ps,  /* ACTION_R_PRESERVE_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Preserve packets dot1p value for red packets.",
    },
    {
        .name  = ACTION_R_OUTER_DOT1P_TO_INNER_DOT1Ps,  /* ACTION_R_OUTER_DOT1P_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy inner VLAN tags dot1p value to outer VLAN tag for red packets.\n",
    },
    {
        .name  = ACTION_R_NEW_OUTER_DOT1Ps,  /* ACTION_R_NEW_OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change outer VLAN tags dot1p bits to new value for red packets.",
    },
    {
        .name  = ACTION_R_OUTER_DOT1P_TO_TOSs,  /* ACTION_R_OUTER_DOT1P_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change outer VLAN tag dot1p value to bit(7,5) of TOS\n for red packets.\n",
    },
    {
        .name  = ACTION_R_DOT1P_UPDATES_CANCELs,  /* ACTION_R_DOT1P_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not change packet dot1p value for red packets.\n This overrides dot1p actions from lower priority logical\n tables, but does not result in an action out of the ingress FP\n",
    },
    {
        .name  = ACTION_Y_NEW_ECNs,  /* ACTION_Y_NEW_ECN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change ECN for yellow packets.",
    },
    {
        .name  = ACTION_Y_PRESERVE_DOT1Ps,  /* ACTION_Y_PRESERVE_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Preserve packets dot1p value for yellow packets.",
    },
    {
        .name  = ACTION_Y_OUTER_DOT1P_TO_INNER_DOT1Ps,  /* ACTION_Y_OUTER_DOT1P_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy inner VLAN tags dot1p value to outer VLAN tag for\n yellow packets.\n",
    },
    {
        .name  = ACTION_Y_NEW_OUTER_DOT1Ps,  /* ACTION_Y_NEW_OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change outer VLAN tags dot1p bits to new value for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_OUTER_DOT1P_TO_TOSs,  /* ACTION_Y_OUTER_DOT1P_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change outer VLAN tag dot1p value to TOS (bit [7,5]) for\n yellow packets.\n",
    },
    {
        .name  = ACTION_Y_DOT1P_UPDATES_CANCELs,  /* ACTION_Y_DOT1P_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not change packet dot1p value for yellow packets.\n This overrides dot1p actions from lower priority logical\n tables, but does not result in an action out of the ingresss FP.\n",
    },
    {
        .name  = ACTION_G_NEW_ECNs,  /* ACTION_G_NEW_ECN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change ECN for green packets.",
    },
    {
        .name  = ACTION_G_PRESERVE_DOT1Ps,  /* ACTION_G_PRESERVE_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Preserve packets dot1p value for green packets.",
    },
    {
        .name  = ACTION_G_OUTER_DOT1P_TO_INNER_DOT1Ps,  /* ACTION_G_OUTER_DOT1P_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy inner VLAN tag dot1p value to outer VLAN tag for\n green packets.\n",
    },
    {
        .name  = ACTION_G_NEW_OUTER_DOT1Ps,  /* ACTION_G_NEW_OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change outer VLAN tags dot1p bits to new value for green packets.\n",
    },
    {
        .name  = ACTION_G_OUTER_DOT1P_TO_TOSs,  /* ACTION_G_OUTER_DOT1P_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change outer VLAN tag dot1p value to TOS (bit [7,5]) for\n green packets.\n",
    },
    {
        .name  = ACTION_G_DOT1P_UPDATES_CANCELs,  /* ACTION_G_DOT1P_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not change packet dot1p value for yellow packets.\n This overrides dot1p actions from lower priority logical\n tables, but does not result in an action out of the ingress FP.\n",
    },
    {
        .name  = ACTION_R_NEW_DSCPs,  /* ACTION_R_NEW_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Change DSCP to a new value for red packets.",
    },
    {
        .name  = ACTION_R_DSCP_UPDATES_CANCELs,  /* ACTION_R_DSCP_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "This action overrides CHANGE_DSCP actions from lower priority\n logical tables for red packets, but does not result in an action\n out of the ingress FP.\n",
    },
    {
        .name  = ACTION_R_PRESERVE_DSCPs,  /* ACTION_R_PRESERVE_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Sets the PRESERVE_DSCP indication in the HiGig header for\n red packets.\n",
    },
    {
        .name  = ACTION_Y_NEW_DSCPs,  /* ACTION_Y_NEW_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Change DSCP to a new value for yellow packets.",
    },
    {
        .name  = ACTION_Y_DSCP_UPDATES_CANCELs,  /* ACTION_Y_DSCP_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "This action overrides CHANGE_DSCP actions from lower priority\n logical tables for yellow packets, but does not result in an action\n out of the ingress FP.\n",
    },
    {
        .name  = ACTION_Y_PRESERVE_DSCPs,  /* ACTION_Y_PRESERVE_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Sets the PRESERVE_DSCP indication in the HiGig header for\n yellow packets.\n",
    },
    {
        .name  = ACTION_G_NEW_DSCPs,  /* ACTION_G_NEW_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Change DSCP to a new value for green packets.",
    },
    {
        .name  = ACTION_G_DSCP_UPDATES_CANCELs,  /* ACTION_G_DSCP_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "This action overrides CHANGE_DSCP actions from lower priority\n logical tables for green packets, but does not result in an action\n out of the ingress FP.\n",
    },
    {
        .name  = ACTION_G_PRESERVE_DSCPs,  /* ACTION_G_PRESERVE_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Sets the PRESERVE_DSCP indication in the HiGig header for\n green packets.\n",
    },
    {
        .name  = ACTION_G_NEW_TOSs,  /* ACTION_G_NEW_TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change bits (7,5) of TOS to a new value for green packets.",
    },
    {
        .name  = ACTION_G_TOS_TO_PRE_FP_ING_OUTER_DOT1Ps,  /* ACTION_G_TOS_TO_PRE_FP_ING_OUTER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change bits (7,5) of TOS to the dot1p value\n from the pre-IFP outer VLAN tag for green packets.\n",
    },
    {
        .name  = ACTION_CHANGE_PKT_L2_FIELDSs,  /* ACTION_CHANGE_PKT_L2_FIELDS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Change different L2 Fields in the packet with new values.\n New values comes from EGR_L3_NEXT_HOP (view type: IFP_ACTIONS)\n L2 Fields that can be modified using this action:\n Source MAC address\n Destination MAC address\n Outer VLAN\n Vntag (Modify/Delete)\n Etag (Modify/Delete)\n",
    },
    {
        .name  = ACTION_CHANGE_PKT_L2_FIELDS_CANCELs,  /* ACTION_CHANGE_PKT_L2_FIELDS_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Don't Change L2 fields in the packet. It cancels action from\n CHANGE_PKT_L2_FIELDS set by the lower priority rule\n",
    },
    {
        .name  = ACTION_NEW_CLASSIFICATION_TAGs,  /* ACTION_NEW_CLASSIFICATION_TAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Add Classification tag.",
    },
    {
        .name  = ACTION_SWITCH_TO_L3UCs,  /* ACTION_SWITCH_TO_L3UC */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Switch the packet to L3 unicast destination.",
    },
    {
        .name  = ACTION_SWITCH_TO_ECMPs,  /* ACTION_SWITCH_TO_ECMP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Switch the packet to ECMP group.",
    },
    {
        .name  = ACTION_SWITCH_TO_ECMP_RESET_OVERLAY_NHOP_IDs,  /* ACTION_SWITCH_TO_ECMP_RESET_OVERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Switch the packet to ECMP group resetting the overlay next hop index\n assigned by the pipeline.\n",
    },
    {
        .name  = ACTION_ECMP_HASHs,  /* ACTION_ECMP_HASH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECMP hash value to be used.\n",
    },
    {
        .name  = ACTION_L3_SWITCH_CANCELs,  /* ACTION_L3_SWITCH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel L3 switch action set by the lower priority rule.",
    },
    {
        .name  = ACTION_ING_CLASS_ID_SELECTs,  /* ACTION_ING_CLASS_ID_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select the type of ingress class ID to pass to egress pipeline.",
    },
    {
        .name  = ACTION_FP_ING_CLASS_IDs,  /* ACTION_FP_ING_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Assign a new class ID.",
    },
    {
        .name  = ACTION_HIGIG_CLASS_ID_SELECTs,  /* ACTION_HIGIG_CLASS_ID_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select HiGig class ID.",
    },
    {
        .name  = ACTION_NEW_CPU_COSs,  /* ACTION_NEW_CPU_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set new COS to packets copied to or switched to CPU.\n",
    },
    {
        .name  = ACTION_NEW_SERVICE_POOL_IDs,  /* ACTION_NEW_SERVICE_POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set the new service pool ID.\n",
    },
    {
        .name  = ACTION_R_DROP_CANCELs,  /* ACTION_R_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for red packets.",
    },
    {
        .name  = ACTION_Y_DROP_CANCELs,  /* ACTION_Y_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for yellow packets.\n",
    },
    {
        .name  = ACTION_G_DROP_CANCELs,  /* ACTION_G_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for green packets.\n",
    },
    {
        .name  = ACTION_G_NEW_INTCNs,  /* ACTION_G_NEW_INTCN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change internal congestion for green packets.",
    },
    {
        .name  = ACTION_Y_NEW_INTCNs,  /* ACTION_Y_NEW_INTCN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change internal congestion for yellow packets.",
    },
    {
        .name  = ACTION_R_NEW_INTCNs,  /* ACTION_R_NEW_INTCN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change internal congestion for red packets.",
    },
    {
        .name  = ACTION_MIRROR_OVERRIDEs,  /* ACTION_MIRROR_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Override the mirror. This field generates a single mirror\n Override action out of the physical slice. This action is\n used to cancel all mirror copies of the packet (Ingress FP-generated\n mirror copies and switch-logic generated mirror copies)\n",
    },
    {
        .name  = ACTION_SFLOW_ENABLEs,  /* ACTION_SFLOW_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable sFlow on packets.",
    },
    {
        .name  = ACTION_MIRROR_ING_FLEX_SFLOW_IDs,  /* ACTION_MIRROR_ING_FLEX_SFLOW_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress sFlow sample index.",
    },
    {
        .name  = ACTION_MIRROR_FLOW_CLASS_ENABLEs,  /* ACTION_MIRROR_FLOW_CLASS_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MIRROR_FLOW_CLASS on packets. This will override hash based\n MIRROR_FLOW_CLASS.\n",
    },
    {
        .name  = ACTION_MIRROR_FLOW_CLASSs,  /* ACTION_MIRROR_FLOW_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mirror flow class for selecting the mirror destination\n",
    },
    {
        .name  = ACTION_VISIBILITY_ENABLEs,  /* ACTION_VISIBILITY_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to mark an ingress packet as a visibility packet,\n similar to CPU masquerading feature.\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_MODULEs,  /* ACTION_REDIRECT_TO_MODULE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Redirect to module and do switch logic forwarding\n modifications.\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_PORTs,  /* ACTION_REDIRECT_TO_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to system physical Port and do switch logic forwarding\n modifications.\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_DVPs,  /* ACTION_REDIRECT_TO_DVP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Redirect to DVP.",
    },
    {
        .name  = ACTION_REDIRECT_TO_TRUNKs,  /* ACTION_REDIRECT_TO_TRUNK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to trunk and do switch logic forwarding modifications.",
    },
    {
        .name  = ACTION_UNMODIFIED_REDIRECT_TO_MODULEs,  /* ACTION_UNMODIFIED_REDIRECT_TO_MODULE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Redirect to module but do not perform switch logic forwarding\n modifications.\n",
    },
    {
        .name  = ACTION_UNMODIFIED_REDIRECT_TO_TRUNKs,  /* ACTION_UNMODIFIED_REDIRECT_TO_TRUNK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to trunk but do not perform switch logic forwarding\n modifications.\n",
    },
    {
        .name  = ACTION_UNMODIFIED_REDIRECT_TO_PORTs,  /* ACTION_UNMODIFIED_REDIRECT_TO_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to system physical port and do not perform switch logic\n forwarding modifications.\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_NHOPs,  /* ACTION_REDIRECT_TO_NHOP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to next hop.",
    },
    {
        .name  = ACTION_REDIRECT_TO_ECMPs,  /* ACTION_REDIRECT_TO_ECMP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to ECMP group.",
    },
    {
        .name  = ACTION_REDIRECT_TO_ECMP_RESET_OVERLAY_NHOP_IDs,  /* ACTION_REDIRECT_TO_ECMP_RESET_OVERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to ECMP group resetting the overlay next hop index assigned\n by the pipeline.\n",
    },
    {
        .name  = ACTION_REDIRECT_UC_CANCELs,  /* ACTION_REDIRECT_UC_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not redirect to unicast destination.\n Cancels all unicast redirect actions set by the lower prioirty rule.\n",
    },
    {
        .name  = ACTION_REDIRECT_PORTS_BROADCAST_PKTs,  /* ACTION_REDIRECT_PORTS_BROADCAST_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to replace the pipeline generated egress port bitmap with the\n new egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_ADD_PORTS_BROADCASTs,  /* ACTION_REDIRECT_ADD_PORTS_BROADCAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add ports to the pipeline generated egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_REMOVE_PORTS_BROADCASTs,  /* ACTION_REDIRECT_REMOVE_PORTS_BROADCAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove ports from the pipeline generated egress port\n bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_PORTS_VLAN_BROADCASTs,  /* ACTION_REDIRECT_PORTS_VLAN_BROADCAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to redirect packets to all ports associated with the incoming\n VLAN instead of the pipeline generated egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_PORTS_VLAN_BROADCAST_FP_INGs,  /* ACTION_REDIRECT_PORTS_VLAN_BROADCAST_FP_ING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to redirect packets to new ports in the incoming VLAN instead\n of pipeline generated egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_L2_MC_GROUP_IDs,  /* ACTION_REDIRECT_L2_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L2_MC_GROUP logical table index.",
    },
    {
        .name  = ACTION_REDIRECT_L3_MC_NHOP_IDs,  /* ACTION_REDIRECT_L3_MC_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3_MC_NHOP logical table index.",
    },
    {
        .name  = ACTION_FP_ING_REDIRECT_DATA_IDs,  /* ACTION_FP_ING_REDIRECT_DATA_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP_ING_REDIRECT_DATA logical table index.",
    },
    {
        .name  = ACTION_FP_ING_REMOVE_REDIRECT_DATA_IDs,  /* ACTION_FP_ING_REMOVE_REDIRECT_DATA_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP_ING_REMOVE_REDIRECT_DATA logical table index.",
    },
    {
        .name  = ACTION_FP_ING_ADD_REDIRECT_DATA_IDs,  /* ACTION_FP_ING_ADD_REDIRECT_DATA_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP_ING_ADD_REDIRECT_DATA logical table index.",
    },
    {
        .name  = ACTION_NEW_HIGIG_EHs,  /* ACTION_NEW_HIGIG_EH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Add HiGiG extended header.",
    },
    {
        .name  = ACTION_HIGIG_EH_MASK_PROFILE_IDs,  /* ACTION_HIGIG_EH_MASK_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "HiGig extended header profile ID.",
    },
    {
        .name  = ACTION_NAT_EGR_OVERRIDEs,  /* ACTION_NAT_EGR_OVERRIDE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Override egress NAT.",
    },
    {
        .name  = ACTION_ING_TIMESTAMP_INSERTs,  /* ACTION_ING_TIMESTAMP_INSERT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Insert ingress pipe received time stamp.",
    },
    {
        .name  = ACTION_ING_TIMESTAMP_INSERT_CANCELs,  /* ACTION_ING_TIMESTAMP_INSERT_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the ingress timestamp action set tby the lower priority rule.\n",
    },
    {
        .name  = ACTION_EGR_TIMESTAMP_INSERTs,  /* ACTION_EGR_TIMESTAMP_INSERT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Insert egress pipe trasmitted time stamp.",
    },
    {
        .name  = ACTION_EGR_TIMESTAMP_INSERT_CANCELs,  /* ACTION_EGR_TIMESTAMP_INSERT_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the egress timestamp action set by the lower priority rule.\n",
    },
    {
        .name  = ACTION_EXACT_MATCH_CLASS_IDs,  /* ACTION_EXACT_MATCH_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Assign a new class ID to pass to egress pipeline.",
    },
    {
        .name  = ACTION_METER_ENABLEs,  /* ACTION_METER_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabling the meter actions",
    },
    {
        .name  = ACTION_CTR_ENABLEs,  /* ACTION_CTR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabling the counter actions",
    },
    {
        .name  = ACTION_FLEX_CTR_R_COUNTs,  /* ACTION_FLEX_CTR_R_COUNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "0 - Don't count red packets.\n 1 - Count red packets and\n            counter index = CTR_ING_FLEX_BASE_INDEX + 0\n 2 - Count red packets and\n            counter index = CTR_ING_FLEX_BASE_INDEX + 1\n 3 - Count red packets and\n            counter index = CTR_ING_FLEX_BASE_INDEX + 2\n",
    },
    {
        .name  = ACTION_FLEX_CTR_Y_COUNTs,  /* ACTION_FLEX_CTR_Y_COUNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "0 - Don't count yellow packets.\n 1 - Count yellow packets and\n            counter index = CTR_ING_FLEX_BASE_INDEX + 0\n 2 - Count yellow packets and\n            counter index = CTR_ING_FLEX_BASE_INDEX + 1\n 3 - Count yellow packets and\n            counter index = CTR_ING_FLEX_BASE_INDEX + 2\n",
    },
    {
        .name  = ACTION_FLEX_CTR_G_COUNTs,  /* ACTION_FLEX_CTR_G_COUNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "0 - Don't count green packets.\n 1 - Count green packets and\n            counter index = CTR_ING_FLEX_BASE_INDEX + 0\n 2 - Count green packets and\n            counter index = CTR_ING_FLEX_BASE_INDEX + 1\n 3 - Count green packets and\n            counter index = CTR_ING_FLEX_BASE_INDEX + 2\n",
    },
    {
        .name  = ACTION_ETRAP_COLOR_DISABLEs,  /* ACTION_ETRAP_COLOR_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable color and COS for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_COLOR_ENABLEs,  /* ACTION_ETRAP_COLOR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable color and COS for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_LOOKUP_DISABLEs,  /* ACTION_ETRAP_LOOKUP_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable lookup for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_LOOKUP_ENABLEs,  /* ACTION_ETRAP_LOOKUP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable lookup for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_QUEUE_DISABLEs,  /* ACTION_ETRAP_QUEUE_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable queue assignment for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_QUEUE_ENABLEs,  /* ACTION_ETRAP_QUEUE_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable queue assignment for elephant flows.",
    },
    {
        .name  = ACTION_DLB_ECMP_MONITOR_DISABLEs,  /* ACTION_DLB_ECMP_MONITOR_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable ECMP monitor during Dynamic Load Balancing (DLB).",
    },
    {
        .name  = ACTION_DLB_ECMP_MONITOR_ENABLEs,  /* ACTION_DLB_ECMP_MONITOR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ECMP monitor during Dynamic Load Balancing (DLB).",
    },
    {
        .name  = ACTION_MIRROR_EGR_ZERO_PAYLOAD_PROFILE_IDs,  /* ACTION_MIRROR_EGR_ZERO_PAYLOAD_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enable zeroing (payload wiping) on any mirrored packet\n and sets the corresponding profile ID to determine the\n offsets to start for zeroing for the payload.\n",
    },
    {
        .name  = ACTION_DELAYED_DROP_ENABLEs,  /* ACTION_DELAYED_DROP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable delayed drop action specified by ACTION_FP_DELAYED_DROP_ID.\n",
    },
    {
        .name  = ACTION_FP_DELAYED_DROP_IDs,  /* ACTION_FP_DELAYED_DROP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index to FP_DELAYED_DROP table used to program\n delayed drop action related controls. Applicable when\n ACTION_DELAYED_DROP_ENABLE is enabled.\n",
    },
    {
        .name  = ACTION_DELAYED_REDIRECT_ENABLEs,  /* ACTION_DELAYED_REDIRECT_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable delayed redirect action specified by\n ACTION_FP_DELAYED_REDIRECT_ID and ACTION_DELAYED_REDIRECT_PORT.\n",
    },
    {
        .name  = ACTION_FP_DELAYED_REDIRECT_IDs,  /* ACTION_FP_DELAYED_REDIRECT_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index to FP_DELAYED_REDIRECT table used to program\n delayed redirect action related controls.\n This should be programmed along with ACTION_DELAYED_REDIRECT_PORT\n for the action to take effect. Applicable when\n ACTION_DELAYED_REDIRECT_ENABLE is enabled.\n",
    },
    {
        .name  = ACTION_DELAYED_REDIRECT_PORTs,  /* ACTION_DELAYED_REDIRECT_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect port where the packets need to be redirected to, in case\n of a delayed redirection action.\n This should be programmed along with ACTION_FP_DELAYED_REDIRECT_ID.\n for the action to take effect. Applicable when\n ACTION_DELAYED_REDIRECT_ENABLE is enabled.\n",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_CONTAINER_IDs,  /* CTR_ING_EFLEX_CONTAINER_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter container ID.",
    },
    {
        .name  = ACTION_MIRROR_ON_DROP_TM_ENABLEs,  /* ACTION_MIRROR_ON_DROP_TM_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mirror on DROP enable for TM.\n",
    },
    {
        .name  = ACTION_MIRROR_ON_DROP_TM_DISABLEs,  /* ACTION_MIRROR_ON_DROP_TM_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mirror on DROP disable for TM.\n",
    },
    {
        .name  = ACTION_MIRROR_ON_DROP_TM_PROFILE_IDs,  /* ACTION_MIRROR_ON_DROP_TM_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Points to the TM_MIRROR_ON_DROP_PROFILE logical table index.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_ENCAP_ENABLEs,  /* ACTION_INBAND_TELEMETRY_ENCAP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable inband network telemetry encapsulation.\n This action triggers to encapsulate\n the inband network telemetry (INT) metadata\n in the egress stage for a given packet.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_ENCAP_DISABLEs,  /* ACTION_INBAND_TELEMETRY_ENCAP_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable inband network telemetry encapsulation.\n This action force disables the encapsulation which\n is triggered by the INT module in the ingress stage.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_PROFILE_IDXs,  /* ACTION_INBAND_TELEMETRY_PROFILE_IDX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inband network telemetry action profile index.",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_SAMPLE_ENABLEs,  /* ACTION_INBAND_TELEMETRY_SAMPLE_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to apply the inband network telemetry action profile scope\n only to sampled packets matching this flow.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_FLOW_CLASS_IDs,  /* ACTION_INBAND_TELEMETRY_FLOW_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inband network telemetry flow class ID. Used to index\n INT_FLOW_METADATA table and this will overrides the FLOW_CLASS_ID\n assigned by LPM.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_TERM_ACTION_PROFILE_IDXs,  /* ACTION_INBAND_TELEMETRY_TERM_ACTION_PROFILE_IDX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inband network telemetry action profile index assigned when the\n destination port bitmap check result is TRUE. This overrides the\n INBAND_ACTION_PROFILE_IDX.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_EGR_LOOPBACK_PROFILE_IDXs,  /* ACTION_INBAND_TELEMETRY_EGR_LOOPBACK_PROFILE_IDX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index to EGR_LOOPBACK_PROFILE table.",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_0s,  /* ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_0 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inband network telemetry MMU request 0.",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_1s,  /* ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inband network telemetry MMU request 1.",
    },
    {
        .name  = ACTION_NEW_SERVICE_POOL_PRECEDENCEs,  /* ACTION_NEW_SERVICE_POOL_PRECEDENCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set the service pool ID's new precedence.\n",
    },
    {
        .name  = ACTION_DGMs,  /* ACTION_DGM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set dynamic group multipath enable for load balancing.\n",
    },
    {
        .name  = ACTION_DGM_BIASs,  /* ACTION_DGM_BIAS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set alternate path bias for dynamic group multipath.\n",
    },
    {
        .name  = ACTION_DGM_COSTs,  /* ACTION_DGM_COST */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set alternate path cost for dynamic group multipath.\n",
    },
    {
        .name  = ACTION_DGM_THRESHOLDs,  /* ACTION_DGM_THRESHOLD */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set alternate path threshold for dynamic group multipath.\n",
    },
    {
        .name  = ACTION_PROTECTION_SWITCHING_DROP_OVERRIDEs,  /* ACTION_PROTECTION_SWITCHING_DROP_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to override the protection switching drop.\n",
    },
    {
        .name  = ACTION_DYNAMIC_ECMP_CANCELs,  /* ACTION_DYNAMIC_ECMP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to prefer hash based load balancing over dynamic.",
    },
    {
        .name  = ACTION_DYNAMIC_ECMP_ENABLEs,  /* ACTION_DYNAMIC_ECMP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to prefer dynamic load balancing over hash based.",
    },
    {
        .name  = ACTION_DISABLE_SRC_PRUNINGs,  /* ACTION_DISABLE_SRC_PRUNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable source pruning.",
    },
    {
        .name  = ACTION_DCN_ENABLEs,  /* ACTION_DCN_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mark packets as eligible for DCN",
    },
    {
        .name  = ACTION_DCN_DISABLEs,  /* ACTION_DCN_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mark packets as not eligible for DCN",
    },
    {
        .name  = ACTION_GREEN_TO_PIDs,  /* ACTION_GREEN_TO_PID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Treat all packets as green",
    },
};
const bcmltd_table_rep_t bcmltd_fp_em_policy_template_t = {
    .name = FP_EM_POLICY_TEMPLATEs, /* FP_EM_POLICY_TEMPLATE */
    .flags = 0,
    .fields = 188,
    .field = bcmltd_fp_em_policy_template_t_fields,
    .desc = "The FP_EM_POLICY_TEMPLATE specifies the exact match FP policy that can be\n attached to an exact match FP entry.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EM_PRESEL_ENTRY_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_em_presel_entry_template_t_fields[] = {
    {
        .name  = FP_EM_PRESEL_ENTRY_TEMPLATE_IDs,  /* FP_EM_PRESEL_ENTRY_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Exact match preselection entry identifier.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Presel entry Priority. Scope of this priority is within other\n presel ids associated to a group to which this presel id is\n associated.\n",
    },
    {
        .name  = QUAL_IP_TYPEs,  /* QUAL_IP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IP specific information.",
    },
    {
        .name  = QUAL_L4_PKTs,  /* QUAL_L4_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier if valid L4 SRC and DST Port.",
    },
    {
        .name  = QUAL_L4_PKT_MASKs,  /* QUAL_L4_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L4.",
    },
    {
        .name  = QUAL_TNL_TYPEs,  /* QUAL_TNL_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for tunnel type.",
    },
    {
        .name  = QUAL_LOOPBACK_TYPEs,  /* QUAL_LOOPBACK_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for loopback type.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_HITs,  /* QUAL_MYSTATIONTCAM_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for my station tcam hit Status.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_HIT_MASKs,  /* QUAL_MYSTATIONTCAM_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MYSTATIONTCAM_HIT.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_2_HITs,  /* QUAL_MYSTATIONTCAM_2_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for my station 2 tcam hit Status.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_2_HIT_MASKs,  /* QUAL_MYSTATIONTCAM_2_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MYSTATIONTCAM_2_HIT.",
    },
    {
        .name  = QUAL_SRC_VP_VALIDs,  /* QUAL_SRC_VP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier if packet has valid SVP.",
    },
    {
        .name  = QUAL_SRC_VP_VALID_MASKs,  /* QUAL_SRC_VP_VALID_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_SRC_VP_VALID.",
    },
    {
        .name  = QUAL_MPLS_BOS_TERMINATEDs,  /* QUAL_MPLS_BOS_TERMINATED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for BOS label terminated in MPLS packet.",
    },
    {
        .name  = QUAL_MPLS_BOS_TERMINATED_MASKs,  /* QUAL_MPLS_BOS_TERMINATED_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MPLS_BOS_TERMINATED.",
    },
    {
        .name  = QUAL_MPLSENTRY_FIRSTLOOKUP_HITs,  /* QUAL_MPLSENTRY_FIRSTLOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for first lookup hit in MPLS_ENTRY table.",
    },
    {
        .name  = QUAL_MPLSENTRY_FIRSTLOOKUP_HIT_MASKs,  /* QUAL_MPLSENTRY_FIRSTLOOKUP_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MPLSENTRY_FIRSTLOOKUP_HIT.",
    },
    {
        .name  = QUAL_MPLSENTRY_SECONDLOOKUP_HITs,  /* QUAL_MPLSENTRY_SECONDLOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for second lookup hit in MPLS_ENTRY table.",
    },
    {
        .name  = QUAL_MPLSENTRY_SECONDLOOKUP_HIT_MASKs,  /* QUAL_MPLSENTRY_SECONDLOOKUP_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MPLSENTRY_SECONDLOOKUP_HIT.",
    },
    {
        .name  = QUAL_L3_TNL_HITs,  /* QUAL_L3_TNL_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for IP Address hit in L3 tunnel table.",
    },
    {
        .name  = QUAL_L3_TNL_HIT_MASKs,  /* QUAL_L3_TNL_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L3_TNL_HIT.",
    },
    {
        .name  = QUAL_DOSATTACK_PKTs,  /* QUAL_DOSATTACK_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for DOS attack packet.",
    },
    {
        .name  = QUAL_DOSATTACK_PKT_MASKs,  /* QUAL_DOSATTACK_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_DOSATTACK_PKT.",
    },
    {
        .name  = QUAL_L3_DST_LPM_HITs,  /* QUAL_L3_DST_LPM_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for destination IP Address hit in L3 Route table.",
    },
    {
        .name  = QUAL_L3_DST_LPM_HIT_MASKs,  /* QUAL_L3_DST_LPM_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L3_DST_LPM_HIT.",
    },
    {
        .name  = QUAL_L3_DST_HOST_HITs,  /* QUAL_L3_DST_HOST_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for destination IP Address hit in L3_ENTRY table.",
    },
    {
        .name  = QUAL_L3_DST_HOST_HIT_MASKs,  /* QUAL_L3_DST_HOST_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L3_DST_HOST_HIT.",
    },
    {
        .name  = QUAL_L3_SRC_HOST_HITs,  /* QUAL_L3_SRC_HOST_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for source IP Address hit in L3_ENTRY table.",
    },
    {
        .name  = QUAL_L3_SRC_HOST_HIT_MASKs,  /* QUAL_L3_SRC_HOST_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L3_SRC_HOST_HIT.",
    },
    {
        .name  = QUAL_L2CACHE_HITs,  /* QUAL_L2CACHE_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L2 User entry lookup hit Status.",
    },
    {
        .name  = QUAL_L2CACHE_HIT_MASKs,  /* QUAL_L2CACHE_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L2CACHE_HIT.",
    },
    {
        .name  = QUAL_L2_DST_HITs,  /* QUAL_L2_DST_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for destination MAC lookup hit in L2_ENTRY table.",
    },
    {
        .name  = QUAL_L2_DST_HIT_MASKs,  /* QUAL_L2_DST_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L2_DST_HIT.",
    },
    {
        .name  = QUAL_L2_SRC_HITs,  /* QUAL_L2_SRC_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for source MAC lookup hit in L2_ENTRY table.",
    },
    {
        .name  = QUAL_L2_SRC_HIT_MASKs,  /* QUAL_L2_SRC_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L2_SRC_HIT.",
    },
    {
        .name  = QUAL_L2_SRC_STATICs,  /* QUAL_L2_SRC_STATIC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L2 source is a Static entry.",
    },
    {
        .name  = QUAL_L2_SRC_STATIC_MASKs,  /* QUAL_L2_SRC_STATIC_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L2_SRC_STATIC.",
    },
    {
        .name  = QUAL_ING_STP_STATEs,  /* QUAL_ING_STP_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for ingress match spanning tree state.",
    },
    {
        .name  = QUAL_FWD_VLAN_VALIDs,  /* QUAL_FWD_VLAN_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for forwarding VLAN valid.",
    },
    {
        .name  = QUAL_FWD_VLAN_VALID_MASKs,  /* QUAL_FWD_VLAN_VALID_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_FWD_VLAN_VALID.",
    },
    {
        .name  = QUAL_VXLT_LOOKUP_HITs,  /* QUAL_VXLT_LOOKUP_HIT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for VLAN translate lookup hit.",
    },
    {
        .name  = QUAL_FWD_TYPEs,  /* QUAL_FWD_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for forwarding type.",
    },
    {
        .name  = QUAL_DROP_PKTs,  /* QUAL_DROP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet is flagged to be dropped.",
    },
    {
        .name  = QUAL_DROP_PKT_MASKs,  /* QUAL_DROP_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_DROP_PKT.",
    },
    {
        .name  = QUAL_HIGIG_PKTs,  /* QUAL_HIGIG_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet received on HiGig Port.",
    },
    {
        .name  = QUAL_HIGIG_PKT_MASKs,  /* QUAL_HIGIG_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_HIGIG_PKT.",
    },
    {
        .name  = QUAL_MIRROR_PKTs,  /* QUAL_MIRROR_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for replication copy of Original packet.",
    },
    {
        .name  = QUAL_MIRROR_PKT_MASKs,  /* QUAL_MIRROR_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MIRROR_PKT.",
    },
    {
        .name  = QUAL_VISIBILITY_PKTs,  /* QUAL_VISIBILITY_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for visibility packet(CPU masquerade packet).",
    },
    {
        .name  = QUAL_VISIBILITY_PKT_MASKs,  /* QUAL_VISIBILITY_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_VISIBILITY_PKT.",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKTs,  /* QUAL_HIGIGLOOKUP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet received on HiGig Port\n and lookup happened.\n",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKT_MASKs,  /* QUAL_HIGIGLOOKUP_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_HIGIGLOOKUP_PKT.",
    },
    {
        .name  = QUAL_MIXED_SRC_CLASSs,  /* QUAL_MIXED_SRC_CLASS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for mixed source class.",
    },
    {
        .name  = QUAL_MIXED_SRC_CLASS_MASKs,  /* QUAL_MIXED_SRC_CLASS_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask of QUAL_MIXED_SRC_CLASS.",
    },
    {
        .name  = PRESEL_CLASSs,  /* PRESEL_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "User can assign class ID in presel. This class ID can be\n used as a qualifier in IFP.\n",
    },
    {
        .name  = NORMALIZE_L2s,  /* NORMALIZE_L2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "User can set Normalize MAC in case of presel rule match.\n This value can be used as a qualifier in IFP.\n By setting to 1, MAC qualifiers in IFP are normalized.\n",
    },
    {
        .name  = NORMALIZE_L3_L4s,  /* NORMALIZE_L3_L4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "User can set Normalize IP and L4 Port in case of presel rule\n match. This value can be matched in IFP.\n By setting to 1, IP and L4 PORT qualifiers in IFP are normalized.\n",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_fp_em_presel_entry_template_t = {
    .name = FP_EM_PRESEL_ENTRY_TEMPLATEs, /* FP_EM_PRESEL_ENTRY_TEMPLATE */
    .flags = 0,
    .fields = 58,
    .field = bcmltd_fp_em_presel_entry_template_t_fields,
    .desc = "The FP_EM_PRESEL_ENTRY_TEMPLATE table specifies the preselection entries for\n the exact match FP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EM_PRESEL_GRP_TEMPLATE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_em_presel_grp_template_info_t_fields[] = {
    {
        .name  = FP_EM_PRESEL_GRP_TEMPLATE_IDs,  /* FP_EM_PRESEL_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP group template ID.",
    },
    {
        .name  = NUM_QUAL_L4_VALID_INFOs,  /* NUM_QUAL_L4_VALID_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partids arrays for\n L4 packet qualifier.\n",
    },
    {
        .name  = QUAL_L4_VALID_OFFSETs,  /* QUAL_L4_VALID_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of L4 packet qualifier in the final KEY.",
    },
    {
        .name  = QUAL_L4_VALID_WIDTHs,  /* QUAL_L4_VALID_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of L4 Packet qualifier in the final KEY. Width at each index\n is corresponding to offset at the same index.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_em_presel_grp_template_info_t = {
    .name = FP_EM_PRESEL_GRP_TEMPLATE_INFOs, /* FP_EM_PRESEL_GRP_TEMPLATE_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_em_presel_grp_template_info_t_fields,
    .desc = "The FP_EM_PRESEL_GRP_TEMPLATE_INFO table provide\n FP preselection group specific\n information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EM_RULE_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_em_rule_template_t_fields[] = {
    {
        .name  = FP_EM_RULE_TEMPLATE_IDs,  /* FP_EM_RULE_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Exact Match rule identifier.",
    },
    {
        .name  = QUAL_OUTER_VLAN_IDs,  /* QUAL_OUTER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier for outer VLAN ID.",
    },
    {
        .name  = QUAL_OUTER_VLAN_PRIs,  /* QUAL_OUTER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier for outer VLAN Priority.\n  Qualifies on priority value set in field NEW_PRI\n  which is a part of PHB_ING_L2_OTAG_REMAP LT.\n",
    },
    {
        .name  = QUAL_OUTER_VLAN_CFIs,  /* QUAL_OUTER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for outer VLAN CFI.",
    },
    {
        .name  = QUAL_INNER_VLAN_IDs,  /* QUAL_INNER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier for inner VLAN ID.",
    },
    {
        .name  = QUAL_INNER_VLAN_PRIs,  /* QUAL_INNER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier for inner VLAN Priority.",
    },
    {
        .name  = QUAL_INNER_VLAN_CFIs,  /* QUAL_INNER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for inner VLAN CFI.",
    },
    {
        .name  = QUAL_SRC_MACs,  /* QUAL_SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier for source MAC address.",
    },
    {
        .name  = QUAL_DST_MACs,  /* QUAL_DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier for destination MAC address.",
    },
    {
        .name  = QUAL_SRC_IP4s,  /* QUAL_SRC_IP4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IPv4 source address.",
    },
    {
        .name  = QUAL_DST_IP4s,  /* QUAL_DST_IP4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IPv4 destination address.",
    },
    {
        .name  = QUAL_SRC_IP6_UPPERs,  /* QUAL_SRC_IP6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 source address.",
    },
    {
        .name  = QUAL_SRC_IP6_LOWERs,  /* QUAL_SRC_IP6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 source address.",
    },
    {
        .name  = QUAL_DST_IP6_UPPERs,  /* QUAL_DST_IP6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 destination address.",
    },
    {
        .name  = QUAL_DST_IP6_LOWERs,  /* QUAL_DST_IP6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 destination address.",
    },
    {
        .name  = QUAL_ETHERTYPEs,  /* QUAL_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L2 ethertype.",
    },
    {
        .name  = QUAL_L4SRC_PORTs,  /* QUAL_L4SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L4 source port.",
    },
    {
        .name  = QUAL_ICMP_TYPE_CODEs,  /* QUAL_ICMP_TYPE_CODE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for ICMP type code.",
    },
    {
        .name  = QUAL_L4DST_PORTs,  /* QUAL_L4DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L4 destination port.",
    },
    {
        .name  = QUAL_MIM_ISIDs,  /* QUAL_MIM_ISID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for ISID in MiM packet header.",
    },
    {
        .name  = QUAL_NVGRE_VSIDs,  /* QUAL_NVGRE_VSID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for VPNID in NVGRE packet header.",
    },
    {
        .name  = QUAL_VXLAN_VNIDs,  /* QUAL_VXLAN_VNID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for VNID in VXLAN packet header.",
    },
    {
        .name  = QUAL_VXLAN_FLAGSs,  /* QUAL_VXLAN_FLAGS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for flags in VXLAN packet header.",
    },
    {
        .name  = QUAL_VXLAN_RSVD_24s,  /* QUAL_VXLAN_RSVD_24 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for 24 reserved bits in VXLAN.",
    },
    {
        .name  = QUAL_VXLAN_RSVD_8s,  /* QUAL_VXLAN_RSVD_8 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for 8 reserved bits in VXLAN.",
    },
    {
        .name  = QUAL_ETAGs,  /* QUAL_ETAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for extended port tag.",
    },
    {
        .name  = QUAL_VNTAGs,  /* QUAL_VNTAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for VN TAG.",
    },
    {
        .name  = QUAL_CNTAGs,  /* QUAL_CNTAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for CNTAG.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_IDs,  /* QUAL_MPLS_FWD_LABEL_ID */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Qualifier for MPLS Fowrarding label ID.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_TTLs,  /* QUAL_MPLS_FWD_LABEL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for MPLS forwarding label TTL.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_EXPs,  /* QUAL_MPLS_FWD_LABEL_EXP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for MPLS forwarding Exp label.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_BOSs,  /* QUAL_MPLS_FWD_LABEL_BOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for MPLS forwarding label BOS.",
    },
    {
        .name  = QUAL_MPLS_CTRL_WORDs,  /* QUAL_MPLS_CTRL_WORD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for MPLS control Word.",
    },
    {
        .name  = QUAL_IP6_FLOW_LABELs,  /* QUAL_IP6_FLOW_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Qualifier for flow label for IPv6 packet.",
    },
    {
        .name  = QUAL_TTLs,  /* QUAL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for packet TTL.",
    },
    {
        .name  = QUAL_TOSs,  /* QUAL_TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for type of service.",
    },
    {
        .name  = QUAL_IP_PROTOCOLs,  /* QUAL_IP_PROTOCOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for protocol number in IPv4/IPv6 packets.",
    },
    {
        .name  = QUAL_TCP_FLAGSs,  /* QUAL_TCP_FLAGS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for TCP control flags.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_PROTOs,  /* QUAL_IP_FIRST_EH_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP first extension header protocol type.",
    },
    {
        .name  = QUAL_IP_SECOND_EH_PROTOs,  /* QUAL_IP_SECOND_EH_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP second extension header protocol type.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_SUBCODEs,  /* QUAL_IP_FIRST_EH_SUBCODE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP first extension header Subcode.",
    },
    {
        .name  = QUAL_IP_FLAGS_MFs,  /* QUAL_IP_FLAGS_MF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for more fragment flag in IP header.",
    },
    {
        .name  = QUAL_IP_FLAGS_DFs,  /* QUAL_IP_FLAGS_DF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for do not fragment flag in IP header.",
    },
    {
        .name  = QUAL_IP_FRAGs,  /* QUAL_IP_FRAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IP fragment.",
    },
    {
        .name  = QUAL_HIGIG_PKTs,  /* QUAL_HIGIG_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet received on HiGig port.",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKTs,  /* QUAL_HIGIGLOOKUP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet received on HiGig port and\n lookup happened.\n",
    },
    {
        .name  = QUAL_DROP_PKTs,  /* QUAL_DROP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet is flagged to be dropped.",
    },
    {
        .name  = QUAL_VISIBILITY_PKTs,  /* QUAL_VISIBILITY_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for visibility packet(CPU masquerade packet).",
    },
    {
        .name  = QUAL_DOSATTACK_PKTs,  /* QUAL_DOSATTACK_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for DOS attack packet.",
    },
    {
        .name  = QUAL_L4_PKTs,  /* QUAL_L4_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L4 packet (Valid L4 SRC and DST port).",
    },
    {
        .name  = QUAL_MIRROR_PKTs,  /* QUAL_MIRROR_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for Mirror packet.",
    },
    {
        .name  = QUAL_NON_OR_FIRST_FRAGMENTs,  /* QUAL_NON_OR_FIRST_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for No fragment or first fragment packet.",
    },
    {
        .name  = QUAL_ICMP_ERROR_PKTs,  /* QUAL_ICMP_ERROR_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for ICMP error packet.",
    },
    {
        .name  = QUAL_REPLICATION_PKTs,  /* QUAL_REPLICATION_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for replication copy of original packet.",
    },
    {
        .name  = QUAL_L3_TNL_HITs,  /* QUAL_L3_TNL_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for IP address hit in L3 tunnel table.",
    },
    {
        .name  = QUAL_VXLT_LOOKUP_HITs,  /* QUAL_VXLT_LOOKUP_HIT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for first/second/all/none lookup hit for\n VLAN Translation.\n",
    },
    {
        .name  = QUAL_MPLSENTRY_FIRSTLOOKUP_HITs,  /* QUAL_MPLSENTRY_FIRSTLOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for first lookup hit in MPLS_ENTRY table.",
    },
    {
        .name  = QUAL_MPLSENTRY_SECONDLOOKUP_HITs,  /* QUAL_MPLSENTRY_SECONDLOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for second lookup hit in MPLS_ENTRY table.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_HITs,  /* QUAL_MYSTATIONTCAM_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for my station TCAM hit status.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_2_HITs,  /* QUAL_MYSTATIONTCAM_2_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for my station TCAM 2 hit status.",
    },
    {
        .name  = QUAL_MPLS_BOS_TERMINATEDs,  /* QUAL_MPLS_BOS_TERMINATED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for BOS label terminated in MPLS packet.",
    },
    {
        .name  = QUAL_DST_IP_LOCALs,  /* QUAL_DST_IP_LOCAL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for destination IP address is Local.",
    },
    {
        .name  = QUAL_L3_ROUTABLE_PKTs,  /* QUAL_L3_ROUTABLE_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet is L3 routable status.",
    },
    {
        .name  = QUAL_INNER_L2_L3_ROUTABLE_PKTs,  /* QUAL_INNER_L2_L3_ROUTABLE_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet is inner L2 L3 routable status.",
    },
    {
        .name  = QUAL_PORT_SYSTEM_CLASSs,  /* QUAL_PORT_SYSTEM_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for port class ID.",
    },
    {
        .name  = QUAL_L3_IIF_CLASS_IDs,  /* QUAL_L3_IIF_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L3 ingress interface class ID.",
    },
    {
        .name  = QUAL_SVP_CLASSs,  /* QUAL_SVP_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source VP class ID.",
    },
    {
        .name  = QUAL_VLAN_CLASSs,  /* QUAL_VLAN_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for VLAN class ID.",
    },
    {
        .name  = QUAL_FP_VLAN_CLASS0s,  /* QUAL_FP_VLAN_CLASS0 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for first VLAN FP class ID.",
    },
    {
        .name  = QUAL_FP_VLAN_CLASS1s,  /* QUAL_FP_VLAN_CLASS1 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for second VLAN FP class ID.",
    },
    {
        .name  = QUAL_FP_VLAN_PORT_GRPs,  /* QUAL_FP_VLAN_PORT_GRP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for VLAN FP port Group ID from port.",
    },
    {
        .name  = QUAL_FP_ING_GRP_SEL_CLASSs,  /* QUAL_FP_ING_GRP_SEL_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for ingress FP key select class ID from port.",
    },
    {
        .name  = QUAL_UDF_CLASSs,  /* QUAL_UDF_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for UDF class ID.",
    },
    {
        .name  = QUAL_L2_SRC_CLASSs,  /* QUAL_L2_SRC_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for class ID from L2 source lookup hit in L2_ENTRY.",
    },
    {
        .name  = QUAL_L2_DST_CLASSs,  /* QUAL_L2_DST_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for class ID from L2 destination lookup hit in L2_ENTRY.",
    },
    {
        .name  = QUAL_L3_SRC_CLASSs,  /* QUAL_L3_SRC_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for class ID from L3 source lookup in L3 host table.",
    },
    {
        .name  = QUAL_L3_DST_CLASSs,  /* QUAL_L3_DST_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for class ID from L3 destination lookup in\n L3 host table.\n",
    },
    {
        .name  = QUAL_PRESEL_CLASSs,  /* QUAL_PRESEL_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for presel class.",
    },
    {
        .name  = QUAL_FWD_VLAN_VALIDs,  /* QUAL_FWD_VLAN_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if forwarding VLAN valid.",
    },
    {
        .name  = QUAL_SRC_VP_VALIDs,  /* QUAL_SRC_VP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if source VP valid.",
    },
    {
        .name  = QUAL_DST_VP_VALIDs,  /* QUAL_DST_VP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if destination VP valid.",
    },
    {
        .name  = QUAL_SRC_MODULEs,  /* QUAL_SRC_MODULE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source module ID (SGPP).",
    },
    {
        .name  = QUAL_SRC_PORTs,  /* QUAL_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source port (SGPP).",
    },
    {
        .name  = QUAL_SRC_TRUNKs,  /* QUAL_SRC_TRUNK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source trunk (SGLP).",
    },
    {
        .name  = QUAL_SRC_VPs,  /* QUAL_SRC_VP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source VP.",
    },
    {
        .name  = QUAL_FWD_VLAN_IDs,  /* QUAL_FWD_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier for forwarding VLAN ID.",
    },
    {
        .name  = QUAL_VRFs,  /* QUAL_VRF */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for VRF.",
    },
    {
        .name  = QUAL_VFIs,  /* QUAL_VFI */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Qualifier for VFI.",
    },
    {
        .name  = QUAL_VPNs,  /* QUAL_VPN */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for VPN.",
    },
    {
        .name  = QUAL_L3_IIFs,  /* QUAL_L3_IIF */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L3 ingress interface.",
    },
    {
        .name  = QUAL_INPORTs,  /* QUAL_INPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for inport.",
    },
    {
        .name  = QUAL_GSH_SYSTEM_DSTs,  /* QUAL_GSH_SYSTEM_DST */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for GSH system destination.",
    },
    {
        .name  = QUAL_GSH_ETHERTYPE_LSB_4BITs,  /* QUAL_GSH_ETHERTYPE_LSB_4BIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for last 4 bits for GSH ether_type.\n",
    },
    {
        .name  = QUAL_GSH_OPCODEs,  /* QUAL_GSH_OPCODE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for GSH opcode.\n",
    },
    {
        .name  = QUAL_RAL_PRESENTs,  /* QUAL_RAL_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if RAL label present.",
    },
    {
        .name  = QUAL_GAL_PRESENTs,  /* QUAL_GAL_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if GAL label present.",
    },
    {
        .name  = QUAL_MPLS_CW_VALIDs,  /* QUAL_MPLS_CW_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier is MPLS psuedo wire control word valid.",
    },
    {
        .name  = QUAL_NAT_SRC_REALM_IDs,  /* QUAL_NAT_SRC_REALM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for NAT source Realm ID from L3_IIF table.",
    },
    {
        .name  = QUAL_INT_CNs,  /* QUAL_INT_CN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for internal congestion.",
    },
    {
        .name  = QUAL_MACADDR_NORMALIZEs,  /* QUAL_MACADDR_NORMALIZE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for normalized L2 fields.",
    },
    {
        .name  = QUAL_IPADDR_NORMALIZEs,  /* QUAL_IPADDR_NORMALIZE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L3/L4 fields normalized.",
    },
    {
        .name  = QUAL_VLAN_INNER_PRESENTs,  /* QUAL_VLAN_INNER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if inner VLAN present in packet.",
    },
    {
        .name  = QUAL_VLAN_OUTER_PRESENTs,  /* QUAL_VLAN_OUTER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if outer VLAN present in packet.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_PRESENTs,  /* QUAL_OPAQUE_TAG_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if opaque tag present in packet.",
    },
    {
        .name  = QUAL_INNER_L2_VLAN_OUTER_PRESENTs,  /* QUAL_INNER_L2_VLAN_OUTER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if inner L2 outer VLAN present in packet.",
    },
    {
        .name  = QUAL_INNER_L2_OPAQUE_TAG_PRESENTs,  /* QUAL_INNER_L2_OPAQUE_TAG_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if opaque tag present in packet.",
    },
    {
        .name  = QUAL_TRANSLATED_VLAN_OUTER_PRESENTs,  /* QUAL_TRANSLATED_VLAN_OUTER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for outer VLAN tag status after VLAN\n assignment and VLAN translation.\n",
    },
    {
        .name  = QUAL_TRANSLATED_VLAN_INNER_PRESENTs,  /* QUAL_TRANSLATED_VLAN_INNER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for inner VLAN tag status after VLAN\n assignment and VLAN translation.\n",
    },
    {
        .name  = QUAL_BYTES_0_7_AFTER_L2HEADERs,  /* QUAL_BYTES_0_7_AFTER_L2HEADER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for first 8 bytes after L2 Header.",
    },
    {
        .name  = QUAL_BYTES_0_7_AFTER_L2HEADER_MASKs,  /* QUAL_BYTES_0_7_AFTER_L2HEADER_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifer mask of QUAL_FIRST_BYTES_0_7_AFTER_L2HEADER.",
    },
    {
        .name  = QUAL_BYTES_8_15_AFTER_L2HEADERs,  /* QUAL_BYTES_8_15_AFTER_L2HEADER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for bytes 8 - 15 after L2 Header.",
    },
    {
        .name  = QUAL_BYTES_8_15_AFTER_L2HEADER_MASKs,  /* QUAL_BYTES_8_15_AFTER_L2HEADER_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifer mask of QUAL_BYTES_8_15_AFTER_L2HEADER.",
    },
    {
        .name  = QUAL_BYTES_16_23_AFTER_L2HEADERs,  /* QUAL_BYTES_16_23_AFTER_L2HEADER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for bytes 16 - 23 after L2 Header.",
    },
    {
        .name  = QUAL_BYTES_16_23_AFTER_L2HEADER_MASKs,  /* QUAL_BYTES_16_23_AFTER_L2HEADER_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifer mask of QUAL_BYTES_16_23_AFTER_L2HEADER.",
    },
    {
        .name  = QUAL_BYTES_24_31_AFTER_L2HEADERs,  /* QUAL_BYTES_24_31_AFTER_L2HEADER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for bytes 24 - 31 after L2 Header.",
    },
    {
        .name  = QUAL_BYTES_24_31_AFTER_L2HEADER_MASKs,  /* QUAL_BYTES_24_31_AFTER_L2HEADER_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifer mask of QUAL_BYTES_24_31_AFTER_L2HEADER.",
    },
    {
        .name  = QUAL_IP_CHECKSUM_VALIDs,  /* QUAL_IP_CHECKSUM_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if packet has matching IP checksum.",
    },
    {
        .name  = QUAL_BFD_DISCRIMINATORs,  /* QUAL_BFD_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for BFD Descriminator.",
    },
    {
        .name  = QUAL_PKT_LENGTHs,  /* QUAL_PKT_LENGTH */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for length of packet.",
    },
    {
        .name  = QUAL_RANGE_CHECKID_BMPs,  /* QUAL_RANGE_CHECKID_BMP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for range check ID bitmap.",
    },
    {
        .name  = QUAL_RANGE_CHECK_GRP_ID_BMPs,  /* QUAL_RANGE_CHECK_GRP_ID_BMP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for range check group ID bitmap.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_ACTIONs,  /* QUAL_MPLS_FWD_LABEL_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for MPLS forwarding label action.",
    },
    {
        .name  = QUAL_TNL_TYPEs,  /* QUAL_TNL_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for tunnel type.",
    },
    {
        .name  = QUAL_LOOPBACK_TYPEs,  /* QUAL_LOOPBACK_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for loopback type.",
    },
    {
        .name  = QUAL_LOOPBACKs,  /* QUAL_LOOPBACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for loopback packet.",
    },
    {
        .name  = QUAL_IP_TYPEs,  /* QUAL_IP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for IP type in packet.",
    },
    {
        .name  = QUAL_L2_FORMATs,  /* QUAL_L2_FORMAT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for L2 format in packet.",
    },
    {
        .name  = QUAL_INNER_TPIDs,  /* QUAL_INNER_TPID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for inner TPID.",
    },
    {
        .name  = QUAL_OUTER_TPIDs,  /* QUAL_OUTER_TPID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for outer TPID.",
    },
    {
        .name  = QUAL_INNER_L2_OUTER_TPIDs,  /* QUAL_INNER_L2_OUTER_TPID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for inner L2 outer TPID.",
    },
    {
        .name  = QUAL_FWD_TYPEs,  /* QUAL_FWD_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for forwarding type.",
    },
    {
        .name  = QUAL_ING_STP_STATEs,  /* QUAL_ING_STP_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for ingress STP state.",
    },
    {
        .name  = QUAL_UDF_CHUNKSs,  /* QUAL_UDF_CHUNKS */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "Qualifier array for UDF chunk.",
    },
    {
        .name  = QUAL_C_L4SRC_PORTs,  /* QUAL_C_L4SRC_PORT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed L4 source port.",
    },
    {
        .name  = QUAL_C_L4DST_PORTs,  /* QUAL_C_L4DST_PORT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed L4 destination port.",
    },
    {
        .name  = QUAL_C_DST_IPs,  /* QUAL_C_DST_IP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for compressed IP destination address.",
    },
    {
        .name  = QUAL_C_SRC_IPs,  /* QUAL_C_SRC_IP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for compressed IP source address.",
    },
    {
        .name  = QUAL_C_IP_PROTOCOLs,  /* QUAL_C_IP_PROTOCOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed IP protocol.",
    },
    {
        .name  = QUAL_C_ETHERTYPEs,  /* QUAL_C_ETHERTYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed ethertype.",
    },
    {
        .name  = QUAL_C_TTL0s,  /* QUAL_C_TTL0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed or remapped first TTL\n Original packet TTL can be mapped to 2 different values\n This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TTL1s,  /* QUAL_C_TTL1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed or remapped second TTL\n Original packet TTL can be mapped to 2 different values\n This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_C_TOS0s,  /* QUAL_C_TOS0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed or remapped first TOS\n Original packet TOS can be mapped to 2 different values\n This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TOS1s,  /* QUAL_C_TOS1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed or remapped second TOS\n Original packet TOS can be mapped to 2 different values\n This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_C_TCP_FLAGS0s,  /* QUAL_C_TCP_FLAGS0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed/remapped first TCP control flags\n Original packet TCP control flags can be mapped to 2 different\n values. This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TCP_FLAGS1s,  /* QUAL_C_TCP_FLAGS1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed/remapped second TCP control flags\n Original packet TCP control flags can be mapped to 2 different\n values. This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_OPAQUE_TAG_LOWs,  /* QUAL_OPAQUE_TAG_LOW */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Lower 32 bits of opaque tag.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_HIGHs,  /* QUAL_OPAQUE_TAG_HIGH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Upper 32 bits of opaque tag.",
    },
    {
        .name  = QUAL_INNER_L2_OPAQUE_TAGs,  /* QUAL_INNER_L2_OPAQUE_TAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for inner L2 opaque tag.",
    },
    {
        .name  = QUAL_TNL_IP_TTLs,  /* QUAL_TNL_IP_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP tunnel TTL.\n",
    },
    {
        .name  = QUAL_C_TNL_IP_TTLs,  /* QUAL_C_TNL_IP_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed or remapped IP tunnel TTL.\n The outer TTL in the terminated tunnel can be mapped to\n a compressed value represented by this field.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_FLAGSs,  /* QUAL_INBAND_TELEMETRY_FLAGS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifiers bitmap for the inband network telemetry flag fields from\n the INT/IOAM/IFAs header.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_MD_HDR_TYPEs,  /* QUAL_INBAND_TELEMETRY_MD_HDR_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for incoming inband network telemetry MD header\n type.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HOP_LIMIT_CHECK_STATUSs,  /* QUAL_INBAND_TELEMETRY_HOP_LIMIT_CHECK_STATUS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for inband network telemetry hop limit check status.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_MAX_LENGTH_CHECKs,  /* QUAL_INBAND_TELEMETRY_MAX_LENGTH_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for inband network telemetry max length check\n status.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HDR_TYPEs,  /* QUAL_INBAND_TELEMETRY_HDR_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for incoming inband network telemetry header type.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_UDP_CHECKSUM_ZEROs,  /* QUAL_INBAND_TELEMETRY_UDP_CHECKSUM_ZERO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for inband network telemetry UDP checksum zero\n check.\n",
    },
    {
        .name  = QUAL_PROTECTION_DATA_DROPs,  /* QUAL_PROTECTION_DATA_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for protection data drop packet.",
    },
    {
        .name  = QUAL_DCN_PKTs,  /* QUAL_DCN_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for drop congestion notification packet.",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HDR_IN_TNLs,  /* QUAL_INBAND_TELEMETRY_HDR_IN_TNL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for inband network telemetry header in tunnel.",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_RAL_DETECTEDs,  /* QUAL_MPLS_SPECIAL_LABEL_RAL_DETECTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for MPLS RAL detected.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_GAL_DETECTEDs,  /* QUAL_MPLS_SPECIAL_LABEL_GAL_DETECTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for MPLS GAL detected.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_CW_DETECTEDs,  /* QUAL_MPLS_SPECIAL_LABEL_CW_DETECTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for MPLS CW detected.\n",
    },
    {
        .name  = QUAL_RH_FIRST_4_BYTESs,  /* QUAL_RH_FIRST_4_BYTES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for first 4 bytes of IPv6 routing ext header.\n",
    },
    {
        .name  = QUAL_RH_NEXT_4_BYTESs,  /* QUAL_RH_NEXT_4_BYTES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for next 4 bytes of IPv6 routing ext header.\n",
    },
    {
        .name  = QUAL_RTAG7A_HASH_LOWERs,  /* QUAL_RTAG7A_HASH_LOWER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for lower half of RTAG7 hash A result.",
    },
    {
        .name  = QUAL_RTAG7A_HASH_UPPERs,  /* QUAL_RTAG7A_HASH_UPPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for lower half of RTAG7 hash A result.",
    },
    {
        .name  = QUAL_RTAG7B_HASH_LOWERs,  /* QUAL_RTAG7B_HASH_LOWER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for lower half of RTAG7 hash B result.",
    },
    {
        .name  = QUAL_RTAG7B_HASH_UPPERs,  /* QUAL_RTAG7B_HASH_UPPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for lower half of RTAG7 hash B result.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_em_rule_template_t = {
    .name = FP_EM_RULE_TEMPLATEs, /* FP_EM_RULE_TEMPLATE */
    .flags = 0,
    .fields = 168,
    .field = bcmltd_fp_em_rule_template_t_fields,
    .desc = "The FP_EM_RULE_TEMPLATE table specifies the exact match FP rule that can be\n attached to an exact match FP entry.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_EM_SRC_CLASS_MODE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_em_src_class_mode_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe ID",
    },
    {
        .name  = SRC_CLASS_MODEs,  /* SRC_CLASS_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "This field configure mode for class IDs input to preselection.\n SRCCLASS_MODE is a 2 bit field in\n EXACT_MATCH_LOGICAL_TABLE_CONFIG_SELECT\n register.\n MODE = 0 means SRC_CLASS is for legacy XGS style devices.\n MODE = 1 means SRC_CLASS is for SDN deployments.\n MODE = 2 means SRC_CLASS is for balanced.\n MODE = 3 means SRC_CLASS is for overlay networks.\n This field is string enumeration and can be set to one of the\n following 4 strings.\n LEGACY\n SDN\n BALANCED\n OVERLAY\n This field can be switch b/w the above mentioned strings when\n SRCCLASS_REF_COUNT is 0.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_em_src_class_mode_t = {
    .name = FP_EM_SRC_CLASS_MODEs, /* FP_EM_SRC_CLASS_MODE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_fp_em_src_class_mode_t_fields,
    .desc = "The FP_EM_SRC_CLASS_MODE specifies the mixed source class mode for exact\n match FP stage. Different modes supported in this table are mutually\n exclusive to each other.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_FT_GRP_TEMPLATE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ft_grp_template_info_t_fields[] = {
    {
        .name  = FP_FT_GRP_TEMPLATE_IDs,  /* FP_FT_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "EM flowtracker FP group template ID.",
    },
    {
        .name  = HW_LTIDs,  /* HW_LTID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hardware logical table ID used in action resolution or partition\n resolution in case of group auto expansion. This logical table ID is\n different from the SDKLT logical table ID. Priority can be assigned to\n the hardware logical table ID and is used to resolve conflicting\n actions when a packet matches FP entries from two different FP groups.\n",
    },
    {
        .name  = NUM_ENTRIES_CREATEDs,  /* NUM_ENTRIES_CREATED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries created in this group.",
    },
    {
        .name  = NUM_ENTRIES_TENTATIVEs,  /* NUM_ENTRIES_TENTATIVE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries that can be created in this group.",
    },
    {
        .name  = NUM_PARTITION_IDs,  /* NUM_PARTITION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of partitions(a.k.a physical slices) used for groups width\n expansion.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ft_grp_template_info_t = {
    .name = FP_FT_GRP_TEMPLATE_INFOs, /* FP_FT_GRP_TEMPLATE_INFO */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_ft_grp_template_info_t_fields,
    .desc = "The FP_FT_GRP_TEMPLATE_INFO table provides FP group-specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_ACTION_NHOP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_action_nhop_t_fields[] = {
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index to the FP_ING_ACTION_NHOP table.",
    },
    {
        .name  = L3_EIF_VALIDs,  /* L3_EIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate L3_EIF_ID is valid.\n L3_EIF_ID is applicable only if L3_EIF_VALID is enabled.\n",
    },
    {
        .name  = L3_EIF_IDs,  /* L3_EIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_EIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 class ID for egress FP.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "MAC address to be used for destination MAC address replacement.",
    },
    {
        .name  = KEEP_DST_MACs,  /* KEEP_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip destination MAC address replacement.",
    },
    {
        .name  = KEEP_SRC_MACs,  /* KEEP_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip source MAC address replacement.",
    },
    {
        .name  = KEEP_TTLs,  /* KEEP_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip decrement of TTL.",
    },
    {
        .name  = KEEP_VLAN_IDs,  /* KEEP_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip outer VLAN ID replacement.",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Destination VP derived from this next hop.",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_VALIDs,  /* EGR_UNDERLAY_NHOP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate EGR_UNDERLAY_NHOP_ID is valid.\n Applicable only when NHOP_ID is used as an underlay next hop.\n",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_IDs,  /* EGR_UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Underlay next hop ID which overrides\n the underlay next hop in the egress pipeline.\n Applicable only if EGR_UNDERLAY_NHOP_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_action_nhop_t = {
    .name = FP_ING_ACTION_NHOPs, /* FP_ING_ACTION_NHOP */
    .flags = BCMLTD_TABLE_F_TYPE_INDEX_ALLOC,
    .fields = 12,
    .field = bcmltd_fp_ing_action_nhop_t_fields,
    .desc = "The FP_ING_ACTION_NHOP logical table specifies egress L3 nexthop parameters\n for ingress FP actions.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_ADD_REDIRECT_DATA.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_add_redirect_data_t_fields[] = {
    {
        .name  = FP_ING_ADD_REDIRECT_DATA_IDs,  /* FP_ING_ADD_REDIRECT_DATA_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Redirect data identifier.",
    },
    {
        .name  = REDIRECT_PORTSs,  /* REDIRECT_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to add the specified port to the pipeline generated\n egress port bitmap.\n Disable to preserve the specified port in the pipeline generated\n egress port bitmap.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_add_redirect_data_t = {
    .name = FP_ING_ADD_REDIRECT_DATAs, /* FP_ING_ADD_REDIRECT_DATA */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_fp_ing_add_redirect_data_t_fields,
    .desc = "The FP_ING_ADD_REDIRECT_DATA table specifies a set of redirect ports that\n can be added to the pipeline generated egress port bitmap. The redirect\n actions can be specified in the FP_ING_POLICY_TEMPLATE and\n FP_EM_POLICY_TEMPLATE tables.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_COS_Q_INT_PRI_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_cos_q_int_pri_map_t_fields[] = {
    {
        .name  = FP_ING_COS_Q_INT_PRI_MAP_IDs,  /* FP_ING_COS_Q_INT_PRI_MAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FP_ING_COS_Q_INT_PRI_MAP table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority.",
    },
    {
        .name  = UC_COSs,  /* UC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast COS queue value.",
    },
    {
        .name  = MC_COSs,  /* MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast COS queue value.",
    },
    {
        .name  = RQE_COSs,  /* RQE_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Replication queue engine (RQE) COS queue value.",
    },
    {
        .name  = CPU_COSs,  /* CPU_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "CPU COS queue value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_cos_q_int_pri_map_t = {
    .name = FP_ING_COS_Q_INT_PRI_MAPs, /* FP_ING_COS_Q_INT_PRI_MAP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_fp_ing_cos_q_int_pri_map_t_fields,
    .desc = "The FP_ING_COS_Q_INT_PRI_MAP table specifies which COS queue to use for\n a packet with a specific internal priority.\n The selection of map ID is determined by ingress FP action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_COS_Q_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_cos_q_map_t_fields[] = {
    {
        .name  = FP_ING_COS_Q_MAP_IDs,  /* FP_ING_COS_Q_MAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the FP_ING_COS_Q_MAP table.",
    },
    {
        .name  = UC_COSs,  /* UC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast COS queue value.",
    },
    {
        .name  = MC_COSs,  /* MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast COS queue value.",
    },
    {
        .name  = RQE_COSs,  /* RQE_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Replication queue engine (RQE) COS queue value.",
    },
    {
        .name  = CPU_COSs,  /* CPU_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "CPU COS queue value.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_cos_q_map_t = {
    .name = FP_ING_COS_Q_MAPs, /* FP_ING_COS_Q_MAP */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_ing_cos_q_map_t_fields,
    .desc = "The FP_ING_COS_Q_MAP specifies the COS queue to use for a packet.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_COS_Q_STRENGTH_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_cos_q_strength_profile_t_fields[] = {
    {
        .name  = FP_ING_COS_Q_STRENGTH_PROFILE_IDs,  /* FP_ING_COS_Q_STRENGTH_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into FP ingress COS queue strength profile table.",
    },
    {
        .name  = UC_COS_STRENGTHs,  /* UC_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast COS queue strength.",
    },
    {
        .name  = MC_COS_STRENGTHs,  /* MC_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast COS queue strength.",
    },
    {
        .name  = RQE_COS_STRENGTHs,  /* RQE_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Replication queue engine (RQE) COS queue strength.",
    },
    {
        .name  = CPU_COS_STRENGTHs,  /* CPU_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "CPU COS queue strength.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_cos_q_strength_profile_t = {
    .name = FP_ING_COS_Q_STRENGTH_PROFILEs, /* FP_ING_COS_Q_STRENGTH_PROFILE */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_ing_cos_q_strength_profile_t_fields,
    .desc = "The FP_ING_COS_Q_STRENGTH_PROFILE table specifies the strength of the\n ingress FP COS queue values relative to the COS queue values that may be\n specified by other entities such as PORT, destination FP or TM.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_entry_t_fields[] = {
    {
        .name  = FP_ING_ENTRY_IDs,  /* FP_ING_ENTRY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP entry identifier.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operational state of the entry.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Priority associated with Entry.",
    },
    {
        .name  = FP_ING_GRP_TEMPLATE_IDs,  /* FP_ING_GRP_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated group ID from FP_ING_GROUP_TEMPLATE LT.",
    },
    {
        .name  = FP_ING_RULE_TEMPLATE_IDs,  /* FP_ING_RULE_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated rule ID from FP_ING_RULE_TEMPLATE LT.",
    },
    {
        .name  = FP_ING_POLICY_TEMPLATE_IDs,  /* FP_ING_POLICY_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from FP_ING_POLICY_TEMPLATE LT.",
    },
    {
        .name  = METER_ING_FP_TEMPLATE_IDs,  /* METER_ING_FP_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated meter ID from METER_ING_FP_TEMPLATE_TEMPLATE LT.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated flex counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Associated flex counter offset mode.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated flex counter pool ID.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_entry_t = {
    .name = FP_ING_ENTRYs, /* FP_ING_ENTRY */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_fp_ing_entry_t_fields,
    .desc = "The FP_ING_ENTRY associates group ID, rule ID, action ID, counter ID and\n meter ID to the entries in the group. Operations on this logical table will\n provision the device IFP logic, if sufficient resources are available.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_GRP_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_grp_template_t_fields[] = {
    {
        .name  = FP_ING_GRP_TEMPLATE_IDs,  /* FP_ING_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress FP group identifier.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Group priority. Groups with same priority will share the same\n physical resources(ingress FP slices) if the corresponding presel\n slice have enough free entries to accommodate the presel entries\n associated to all groups with that priority.\n",
    },
    {
        .name  = MODE_AUTOs,  /* MODE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to auto calculate the group mode and ignore the user specified\n mode in MODE field in this table.\n",
    },
    {
        .name  = AUTO_EXPANDs,  /* AUTO_EXPAND */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to disable auto expansion of the group.\n",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Configurable group mode.\n    HALF       : Half wide mode\n    SINGLE     : Single wide mode\n    DBLINTRA   : Double wide intra-slice mode\n    DBLINTER   : Double wide inter-slice mode\n    TRIPLE     : Triple wide mode\n    QUAD       : Quad wide mode\n Applicable only if MODE_AUTO is disabled.\n",
    },
    {
        .name  = MODE_OPERs,  /* MODE_OPER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational group mode.\n If MODE_AUTO is enabled, then the MODE_OPER field will updated with\n the mode assigned to the group by the SDK.\n If MODE_AUTO is disabled and if the group fits in the mode specified\n in the MODE field, then the MODE field will be assigned to the\n MODE_OPER field.\n",
    },
    {
        .name  = FP_ING_PRESEL_ENTRY_COUNTs,  /* FP_ING_PRESEL_ENTRY_COUNT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of active presel entries.",
    },
    {
        .name  = FP_ING_PRESEL_ENTRY_TEMPLATE_IDs,  /* FP_ING_PRESEL_ENTRY_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 32,
        .desc = "List of presel entries created in FP_ING_PRESEL_ENTRY LT that\n are associated to this GROUP_ID.\n",
    },
    {
        .name  = FP_ING_PDD_TEMPLATE_IDs,  /* FP_ING_PDD_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "PDD(Policy data decoding) profile ID",
    },
    {
        .name  = FP_ING_SBR_TEMPLATE_IDs,  /* FP_ING_SBR_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "SBR(Strength based resolution) profile ID",
    },
    {
        .name  = FP_ING_PRESEL_GRP_TEMPLATE_IDs,  /* FP_ING_PRESEL_GRP_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Presel group template ID.",
    },
    {
        .name  = GRP_SLICE_TYPEs,  /* GRP_SLICE_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Group slice type information.\n",
    },
    {
        .name  = QUAL_OUTER_VLAN_ID_BITMAPs,  /* QUAL_OUTER_VLAN_ID_BITMAP */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID qualifier bitmap.\n All supported qualifiers have QUAL_<qualifier name>_BITMAP field\n to mask the bits not used for qualification in any of its rules.\n This information is required to SDKLT extraction algorithm to\n optimally building the key by not extracting these don.t care\n bits into the key.\n Note: Do not confuse it with MASK specified for qualifiers when\n creating rules. MASK specified in rules is to don.t care few bits\n of qualifier only in that rule.\n",
    },
    {
        .name  = QUAL_OUTER_VLAN_PRI_BITMAPs,  /* QUAL_OUTER_VLAN_PRI_BITMAP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority qualifier bitmap.",
    },
    {
        .name  = QUAL_OUTER_VLAN_CFI_BITMAPs,  /* QUAL_OUTER_VLAN_CFI_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI qualifier bitmap.",
    },
    {
        .name  = QUAL_INNER_VLAN_ID_BITMAPs,  /* QUAL_INNER_VLAN_ID_BITMAP */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID qualifier bitmap.",
    },
    {
        .name  = QUAL_INNER_VLAN_PRI_BITMAPs,  /* QUAL_INNER_VLAN_PRI_BITMAP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority qualifier bitmap.",
    },
    {
        .name  = QUAL_INNER_VLAN_CFI_BITMAPs,  /* QUAL_INNER_VLAN_CFI_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI qualifier bitmap.",
    },
    {
        .name  = QUAL_SRC_MAC_BITMAPs,  /* QUAL_SRC_MAC_BITMAP */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address qualifier bitmap.",
    },
    {
        .name  = QUAL_DST_MAC_BITMAPs,  /* QUAL_DST_MAC_BITMAP */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address qualifier bitmap.",
    },
    {
        .name  = QUAL_SRC_IP4_BITMAPs,  /* QUAL_SRC_IP4_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 source address qualifier bitmap.",
    },
    {
        .name  = QUAL_DST_IP4_BITMAPs,  /* QUAL_DST_IP4_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 destination address qualifier bitmap.",
    },
    {
        .name  = QUAL_SRC_IP6_BITMAP_UPPERs,  /* QUAL_SRC_IP6_BITMAP_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 source address qualifier bitmap.",
    },
    {
        .name  = QUAL_SRC_IP6_BITMAP_LOWERs,  /* QUAL_SRC_IP6_BITMAP_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 source address qualifier bitmap.",
    },
    {
        .name  = QUAL_DST_IP6_BITMAP_UPPERs,  /* QUAL_DST_IP6_BITMAP_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 destination address qualifier bitmap.",
    },
    {
        .name  = QUAL_DST_IP6_BITMAP_LOWERs,  /* QUAL_DST_IP6_BITMAP_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 destination address qualifier bitmap.",
    },
    {
        .name  = QUAL_INNER_DST_IP6_BITMAP_UPPERs,  /* QUAL_INNER_DST_IP6_BITMAP_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 inner destination address qualifier bitmap.",
    },
    {
        .name  = QUAL_INNER_DST_IP6_BITMAP_LOWERs,  /* QUAL_INNER_DST_IP6_BITMAP_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 inner destination address qualifier bitmap.",
    },
    {
        .name  = QUAL_ETHERTYPE_BITMAPs,  /* QUAL_ETHERTYPE_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L2 Ethertype qualifier bitmap.",
    },
    {
        .name  = QUAL_L4SRC_PORT_BITMAPs,  /* QUAL_L4SRC_PORT_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L4 source port qualifier bitmap.",
    },
    {
        .name  = QUAL_ICMP_TYPE_CODE_BITMAPs,  /* QUAL_ICMP_TYPE_CODE_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "ICMP type code qualifier bitmap.",
    },
    {
        .name  = QUAL_L4DST_PORT_BITMAPs,  /* QUAL_L4DST_PORT_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L4 destination port qualifier bitmap.",
    },
    {
        .name  = QUAL_MIM_ISID_BITMAPs,  /* QUAL_MIM_ISID_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for ISID in MiM packet header.",
    },
    {
        .name  = QUAL_NVGRE_VSID_BITMAPs,  /* QUAL_NVGRE_VSID_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for VPNID in NVGRE packet header.",
    },
    {
        .name  = QUAL_VXLAN_VNID_BITMAPs,  /* QUAL_VXLAN_VNID_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for VNID in VXLAN packet header.",
    },
    {
        .name  = QUAL_VXLAN_FLAGS_BITMAPs,  /* QUAL_VXLAN_FLAGS_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for flags in VXLAN packet header.",
    },
    {
        .name  = QUAL_VXLAN_RSVD_24_BITMAPs,  /* QUAL_VXLAN_RSVD_24_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for 24 reserved bits in VXLAN.",
    },
    {
        .name  = QUAL_VXLAN_RSVD_8_BITMAPs,  /* QUAL_VXLAN_RSVD_8_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for 8 reserved bits in VXLAN.",
    },
    {
        .name  = QUAL_MH_OPCODE_BITMAPs,  /* QUAL_MH_OPCODE_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for module header opcode.",
    },
    {
        .name  = QUAL_ETAG_BITMAPs,  /* QUAL_ETAG_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for extended port tag.",
    },
    {
        .name  = QUAL_VNTAG_BITMAPs,  /* QUAL_VNTAG_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for VN TAG.",
    },
    {
        .name  = QUAL_CNTAG_BITMAPs,  /* QUAL_CNTAG_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap CNTAG.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_ID_BITMAPs,  /* QUAL_MPLS_FWD_LABEL_ID_BITMAP */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS forwarding label ID.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_TTL_BITMAPs,  /* QUAL_MPLS_FWD_LABEL_TTL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS forwarding label TTL.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_EXP_BITMAPs,  /* QUAL_MPLS_FWD_LABEL_EXP_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS forwarding label EXP.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_BOS_BITMAPs,  /* QUAL_MPLS_FWD_LABEL_BOS_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on MPLS forwarding label BOS as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_RTAG7A_HASH_LOWER_BITMAPs,  /* QUAL_RTAG7A_HASH_LOWER_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for lower half of RTAG7 hash A result.",
    },
    {
        .name  = QUAL_RTAG7A_HASH_UPPER_BITMAPs,  /* QUAL_RTAG7A_HASH_UPPER_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for upper half of RTAG7 hash A result.",
    },
    {
        .name  = QUAL_RTAG7B_HASH_LOWER_BITMAPs,  /* QUAL_RTAG7B_HASH_LOWER_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for lower half of RTAG7 hash B result.",
    },
    {
        .name  = QUAL_RTAG7B_HASH_UPPER_BITMAPs,  /* QUAL_RTAG7B_HASH_UPPER_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for upper half of RTAG7 hash B result.",
    },
    {
        .name  = QUAL_MPLS_CTRL_WORD_BITMAPs,  /* QUAL_MPLS_CTRL_WORD_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS control word.",
    },
    {
        .name  = QUAL_IP6_FLOW_LABEL_BITMAPs,  /* QUAL_IP6_FLOW_LABEL_BITMAP */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Qualifier bitmap for flow label of IPv6 packets",
    },
    {
        .name  = QUAL_TTL_BITMAPs,  /* QUAL_TTL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for packet's TTL.",
    },
    {
        .name  = QUAL_TOS_BITMAPs,  /* QUAL_TOS_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for type of service.",
    },
    {
        .name  = QUAL_IP_PROTOCOL_BITMAPs,  /* QUAL_IP_PROTOCOL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for protocol number in IPv4/IPv6 packets.",
    },
    {
        .name  = QUAL_TCP_FLAGS_BITMAPs,  /* QUAL_TCP_FLAGS_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for TCP control flags.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_PROTO_BITMAPs,  /* QUAL_IP_FIRST_EH_PROTO_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for IP first extension header protocol type.",
    },
    {
        .name  = QUAL_IP_SECOND_EH_PROTO_BITMAPs,  /* QUAL_IP_SECOND_EH_PROTO_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for IP second extension header protocol type.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_SUBCODE_BITMAPs,  /* QUAL_IP_FIRST_EH_SUBCODE_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for IP first extension header subcode.",
    },
    {
        .name  = QUAL_IP_FLAGS_MF_BITMAPs,  /* QUAL_IP_FLAGS_MF_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on more fragment flag in IP header as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_IP_FLAGS_DF_BITMAPs,  /* QUAL_IP_FLAGS_DF_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on do not fragment flag in IP header as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_IP_FRAG_BITMAPs,  /* QUAL_IP_FRAG_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on IP fragment flag in IP header as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_HIGIG_PKT_BITMAPs,  /* QUAL_HIGIG_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets received on HiGig port as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKT_BITMAPs,  /* QUAL_HIGIGLOOKUP_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets received on HiGig port and lookup\n happened as specified in rule template entries that are associated\n with FP entries which reference this group template.\n",
    },
    {
        .name  = QUAL_DROP_PKT_BITMAPs,  /* QUAL_DROP_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets flagged to be dropped as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_VISIBILITY_PKT_BITMAPs,  /* QUAL_VISIBILITY_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on visibility packets(CPU masquerade packets)) as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_DOSATTACK_PKT_BITMAPs,  /* QUAL_DOSATTACK_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on DOS attack packets as specified in rule template\n entries that are associated with FP entries which reference this\n group template.\n",
    },
    {
        .name  = QUAL_L4_PKT_BITMAPs,  /* QUAL_L4_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L4 packets (valid L4 SRC and DST port) as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_MIRROR_PKT_BITMAPs,  /* QUAL_MIRROR_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on mirrored packets as specified in rule template\n entries that are associated with FP entries which reference this\n group template.\n",
    },
    {
        .name  = QUAL_NON_OR_FIRST_FRAGMENT_BITMAPs,  /* QUAL_NON_OR_FIRST_FRAGMENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on first fragment packets as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_ICMP_ERROR_PKT_BITMAPs,  /* QUAL_ICMP_ERROR_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on ICMP error packets as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_REPLICATION_PKT_BITMAPs,  /* QUAL_REPLICATION_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on replication copy of original packets as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_L2_SRC_HIT_BITMAPs,  /* QUAL_L2_SRC_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on source MAC lookup hit in L2 entry table as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_L2_DST_HIT_BITMAPs,  /* QUAL_L2_DST_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on destination MAC lookup hit in L2 entry table as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_L3_SRC_HOST_HIT_BITMAPs,  /* QUAL_L3_SRC_HOST_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on source IP address hit in L3 host table as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_COMPRESSED_L3_SRC_HIT_BITMAPs,  /* QUAL_COMPRESSED_L3_SRC_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on compressed source IP address hit in L3 host table as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_COMPRESSED_L3_DST_HIT_BITMAPs,  /* QUAL_COMPRESSED_L3_DST_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on compressed destination IP address hit in L3 host table as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_L3_DST_HOST_HIT_BITMAPs,  /* QUAL_L3_DST_HOST_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on destination IP address hit in L3 host table as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_L3_DST_LPM_HIT_BITMAPs,  /* QUAL_L3_DST_LPM_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on destination IP address hit in L3 route table as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_L3_SRC_LPM_HIT_BITMAPs,  /* QUAL_L3_SRC_LPM_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on source IP address hit in L3 route table as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_L3_TNL_HIT_BITMAPs,  /* QUAL_L3_TNL_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on IP address hit in L3 tunnel table as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_VXLT_LOOKUP_HIT_BITMAPs,  /* QUAL_VXLT_LOOKUP_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on first/second/all/none lookup hit for VLAN\n translation as specified in rule template entries that are associated\n with FP entries which reference this group template.\n",
    },
    {
        .name  = QUAL_L2CACHE_HIT_BITMAPs,  /* QUAL_L2CACHE_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L2 user entry lookup hit status as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_MPLSENTRY_FIRSTLOOKUP_HIT_BITMAPs,  /* QUAL_MPLSENTRY_FIRSTLOOKUP_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on first lookup hit in MPLS entry table as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_MPLSENTRY_SECONDLOOKUP_HIT_BITMAPs,  /* QUAL_MPLSENTRY_SECONDLOOKUP_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on second lookup hit in MPLS entry table as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_HIT_BITMAPs,  /* QUAL_MYSTATIONTCAM_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on my station TCAM hit status as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_2_HIT_BITMAPs,  /* QUAL_MYSTATIONTCAM_2_HIT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on my station 2 TCAM hit status as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_L2_SRC_STATIC_BITMAPs,  /* QUAL_L2_SRC_STATIC_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L2 static source entry as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_L2STATION_MOVE_BITMAPs,  /* QUAL_L2STATION_MOVE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L2 station move status as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_MPLS_BOS_TERMINATED_BITMAPs,  /* QUAL_MPLS_BOS_TERMINATED_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on BOS label terminated in MPLS packets as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_DST_IP_LOCAL_BITMAPs,  /* QUAL_DST_IP_LOCAL_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on destination IP address is local as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_L3_ROUTABLE_PKT_BITMAPs,  /* QUAL_L3_ROUTABLE_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L3 routable status of the packets as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_INNER_L2_L3_ROUTABLE_PKT_BITMAPs,  /* QUAL_INNER_L2_L3_ROUTABLE_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on inner L2 L3 routable status of the packets as\n specified in rule template entries that are associated with FP entries\n which reference this group template.\n",
    },
    {
        .name  = QUAL_PORT_SYSTEM_CLASS_BITMAPs,  /* QUAL_PORT_SYSTEM_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for PORT_SYSTEM class ID.",
    },
    {
        .name  = QUAL_L3_IIF_CLASS_ID_BITMAPs,  /* QUAL_L3_IIF_CLASS_ID_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for L3_IIF class ID.",
    },
    {
        .name  = QUAL_SVP_CLASS_BITMAPs,  /* QUAL_SVP_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for source virtual port class ID.",
    },
    {
        .name  = QUAL_VLAN_CLASS_BITMAPs,  /* QUAL_VLAN_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for VLAN class ID.",
    },
    {
        .name  = QUAL_FP_VLAN_CLASS0_BITMAPs,  /* QUAL_FP_VLAN_CLASS0_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for first VLAN FP class ID.",
    },
    {
        .name  = QUAL_FP_VLAN_CLASS1_BITMAPs,  /* QUAL_FP_VLAN_CLASS1_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for second VLAN FP class ID.",
    },
    {
        .name  = QUAL_FP_VLAN_PORT_GRP_BITMAPs,  /* QUAL_FP_VLAN_PORT_GRP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for VLAN FP port group ID from port.",
    },
    {
        .name  = QUAL_FP_ING_GRP_SEL_CLASS_BITMAPs,  /* QUAL_FP_ING_GRP_SEL_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for ingress FP key select class ID from port.",
    },
    {
        .name  = QUAL_UDF_CLASS_BITMAPs,  /* QUAL_UDF_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for UDF class ID.",
    },
    {
        .name  = QUAL_L2_SRC_CLASS_BITMAPs,  /* QUAL_L2_SRC_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for class ID from L2 source lookup hit\n in L2_ENTRY.\n",
    },
    {
        .name  = QUAL_L2_DST_CLASS_BITMAPs,  /* QUAL_L2_DST_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for class ID from L2 destination lookup hit\n in L2_ENTRY.\n",
    },
    {
        .name  = QUAL_L3_SRC_CLASS_BITMAPs,  /* QUAL_L3_SRC_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for class ID from L3 source lookup\n in L3 host table.\n",
    },
    {
        .name  = QUAL_L3_DST_CLASS_BITMAPs,  /* QUAL_L3_DST_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for class ID from L3 destination lookup\n in L3 host table.\n",
    },
    {
        .name  = QUAL_PRESEL_CLASS_BITMAPs,  /* QUAL_PRESEL_CLASS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for Presel class ID.",
    },
    {
        .name  = QUAL_EM_GROUP_CLASS_ID_0_BITMAPs,  /* QUAL_EM_GROUP_CLASS_ID_0_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for exact match group class ID 0.",
    },
    {
        .name  = QUAL_EM_GROUP_CLASS_ID_1_BITMAPs,  /* QUAL_EM_GROUP_CLASS_ID_1_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for exact match group class ID 1.",
    },
    {
        .name  = QUAL_FWD_VLAN_VALID_BITMAPs,  /* QUAL_FWD_VLAN_VALID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with valid forwarding VLAN ID as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_SRC_VP_VALID_BITMAPs,  /* QUAL_SRC_VP_VALID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with valid SVP as specified in rule\n template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_DST_VP_VALID_BITMAPs,  /* QUAL_DST_VP_VALID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with valid DVP as specified in rule\n template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_SRC_MODULE_BITMAPs,  /* QUAL_SRC_MODULE_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for source module ID.",
    },
    {
        .name  = QUAL_SRC_PORT_BITMAPs,  /* QUAL_SRC_PORT_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for source port.",
    },
    {
        .name  = QUAL_SRC_TRUNK_BITMAPs,  /* QUAL_SRC_TRUNK_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for SGLP.",
    },
    {
        .name  = QUAL_SRC_VP_BITMAPs,  /* QUAL_SRC_VP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for source VP.",
    },
    {
        .name  = QUAL_DST_MODULE_BITMAPs,  /* QUAL_DST_MODULE_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for destination Module ID.",
    },
    {
        .name  = QUAL_DST_PORT_BITMAPs,  /* QUAL_DST_PORT_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for destination port.",
    },
    {
        .name  = QUAL_DST_TRUNK_BITMAPs,  /* QUAL_DST_TRUNK_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for destination Trunk.",
    },
    {
        .name  = QUAL_DST_VP_TRUNK_BITMAPs,  /* QUAL_DST_VP_TRUNK_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for DVPLAG.",
    },
    {
        .name  = QUAL_DST_VP_BITMAPs,  /* QUAL_DST_VP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for destination virtual port.",
    },
    {
        .name  = QUAL_OVERLAY_DST_VP_BITMAPs,  /* QUAL_OVERLAY_DST_VP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for overlay destination virtual port.",
    },
    {
        .name  = QUAL_NHOP_BITMAPs,  /* QUAL_NHOP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for next hop.",
    },
    {
        .name  = QUAL_OVERLAY_ECMP_BITMAPs,  /* QUAL_OVERLAY_ECMP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for ECMP1.",
    },
    {
        .name  = QUAL_UNDERLAY_ECMP_BITMAPs,  /* QUAL_UNDERLAY_ECMP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for ECMP2.",
    },
    {
        .name  = QUAL_L3_MC_GROUP_BITMAPs,  /* QUAL_L3_MC_GROUP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for IPMC group.",
    },
    {
        .name  = QUAL_L2_MC_GROUP_BITMAPs,  /* QUAL_L2_MC_GROUP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for L2MC group.",
    },
    {
        .name  = QUAL_FWD_VLAN_ID_BITMAPs,  /* QUAL_FWD_VLAN_ID_BITMAP */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier bitmap for forwarding VLAN ID.",
    },
    {
        .name  = QUAL_VRF_BITMAPs,  /* QUAL_VRF_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for VRF.",
    },
    {
        .name  = QUAL_VFI_BITMAPs,  /* QUAL_VFI_BITMAP */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Qualifier bitmap for VFI.",
    },
    {
        .name  = QUAL_VPN_BITMAPs,  /* QUAL_VPN_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for VPN.",
    },
    {
        .name  = QUAL_L3_IIF_BITMAPs,  /* QUAL_L3_IIF_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for L3 Ingress interface.",
    },
    {
        .name  = QUAL_INPORT_BITMAPs,  /* QUAL_INPORT_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Single inport qualifier bitmap.",
    },
    {
        .name  = QUAL_INPORTS_BITMAPs,  /* QUAL_INPORTS_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier for port bitmap.",
    },
    {
        .name  = QUAL_SYSTEM_PORTS_BITMAPs,  /* QUAL_SYSTEM_PORTS_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier for system port bitmap.",
    },
    {
        .name  = QUAL_DEVICE_PORTS_BITMAPs,  /* QUAL_DEVICE_PORTS_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier for device port bitmap.",
    },
    {
        .name  = QUAL_SVP_PORTS_BITMAPs,  /* QUAL_SVP_PORTS_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier for source virtual port bitmap.",
    },
    {
        .name  = QUAL_INT_PRI_BITMAPs,  /* QUAL_INT_PRI_BITMAP */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Qualifier bitmap for internal priority of packets.",
    },
    {
        .name  = QUAL_COLOR_BITMAPs,  /* QUAL_COLOR_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets color as specified in rule template\n entries that are associated with FP entries which reference this\n group template.\n",
    },
    {
        .name  = QUAL_RAL_PRESENT_BITMAPs,  /* QUAL_RAL_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with RAL label present as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_GAL_PRESENT_BITMAPs,  /* QUAL_GAL_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with GAL label present as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_MPLS_CW_VALID_BITMAPs,  /* QUAL_MPLS_CW_VALID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with MPLS pseudo wire control word valid\n as specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_NAT_NEEDED_BITMAPs,  /* QUAL_NAT_NEEDED_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets that need NAT as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_NAT_SRC_REALM_ID_BITMAPs,  /* QUAL_NAT_SRC_REALM_ID_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for NAT source Realm ID from L3_IIF table.",
    },
    {
        .name  = QUAL_NAT_DST_REALM_ID_BITMAPs,  /* QUAL_NAT_DST_REALM_ID_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for NAT destination realm ID from\n ING_L3_NEXT_HOP table.\n",
    },
    {
        .name  = QUAL_INT_CN_BITMAPs,  /* QUAL_INT_CN_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for internal congestion.",
    },
    {
        .name  = QUAL_MACADDR_NORMALIZE_BITMAPs,  /* QUAL_MACADDR_NORMALIZE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L2 fields normalized as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_IPADDR_NORMALIZE_BITMAPs,  /* QUAL_IPADDR_NORMALIZE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L3/L4 fields normalized as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_VLAN_INNER_PRESENT_BITMAPs,  /* QUAL_VLAN_INNER_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with inner VLAN tag present as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_VLAN_OUTER_PRESENT_BITMAPs,  /* QUAL_VLAN_OUTER_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with outer VLAN tag present as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_OPAQUE_TAG_PRESENT_BITMAPs,  /* QUAL_OPAQUE_TAG_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with opaque tag present as specified\n in rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_INNER_L2_VLAN_OUTER_PRESENT_BITMAPs,  /* QUAL_INNER_L2_VLAN_OUTER_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with inner L2 VLAN tag present as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_INNER_L2_OPAQUE_TAG_PRESENT_BITMAPs,  /* QUAL_INNER_L2_OPAQUE_TAG_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packets with inner L2 opaque tag present as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_TRANSLATED_VLAN_INNER_PRESENT_BITMAPs,  /* QUAL_TRANSLATED_VLAN_INNER_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on inner VLAN tag status after VLAN assignment and\n VLAN translation as specified in rule template entries that are\n associated with FP entries which reference this group template.\n",
    },
    {
        .name  = QUAL_TRANSLATED_VLAN_OUTER_PRESENT_BITMAPs,  /* QUAL_TRANSLATED_VLAN_OUTER_PRESENT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on outer VLAN tag status after VLAN assignment and\n VLAN translation as specified in rule template entries that are\n associated with FP entries which reference this group template.\n",
    },
    {
        .name  = QUAL_BYTES_0_7_AFTER_L2HEADER_BITMAPs,  /* QUAL_BYTES_0_7_AFTER_L2HEADER_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Enable to match on first 8 bytes after L2 header as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_BYTES_8_15_AFTER_L2HEADER_BITMAPs,  /* QUAL_BYTES_8_15_AFTER_L2HEADER_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Enable to match on bytes 8_15 after L2 header as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_BYTES_16_23_AFTER_L2HEADER_BITMAPs,  /* QUAL_BYTES_16_23_AFTER_L2HEADER_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Enable to match on bytes 16_23 after L2 header as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_BYTES_24_31_AFTER_L2HEADER_BITMAPs,  /* QUAL_BYTES_24_31_AFTER_L2HEADER_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Enable to match on bytes 24_31 after L2 header as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_IP_CHECKSUM_VALID_BITMAPs,  /* QUAL_IP_CHECKSUM_VALID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on matching IP checksum as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_BFD_DISCRIMINATOR_BITMAPs,  /* QUAL_BFD_DISCRIMINATOR_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable to match on BFD destination as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_PKT_LENGTH_BITMAPs,  /* QUAL_PKT_LENGTH_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enable to match on packets length as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_RANGE_CHECKID_BMP_BITMAPs,  /* QUAL_RANGE_CHECKID_BMP_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Enable to match on range check table ID as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_RANGE_CHECK_GRP_ID_BMP_BITMAPs,  /* QUAL_RANGE_CHECK_GRP_ID_BMP_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enable to match on range check group table ID as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_ACTION_BITMAPs,  /* QUAL_MPLS_FWD_LABEL_ACTION_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on MPLS forwarding label as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_TNL_TYPE_BITMAPs,  /* QUAL_TNL_TYPE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on tunnel type as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_LOOPBACK_TYPE_BITMAPs,  /* QUAL_LOOPBACK_TYPE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on loopback type as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_LOOPBACK_BITMAPs,  /* QUAL_LOOPBACK_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on loopback packets as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_PKT_RESOLUTION_BITMAPs,  /* QUAL_PKT_RESOLUTION_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enable to match on packets resolution as specified in rule template\n entries that are associated with FP entries which reference this\n group template.\n",
    },
    {
        .name  = QUAL_EM_FIRST_LOOKUP_HITs,  /* QUAL_EM_FIRST_LOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on exact match first lookup hit as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_EM_SECOND_LOOKUP_HITs,  /* QUAL_EM_SECOND_LOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on exact match second lookup hit as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_EM_FIRST_LOOKUP_CLASS_ID_BITMAPs,  /* QUAL_EM_FIRST_LOOKUP_CLASS_ID_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for exact match first lookup class ID.",
    },
    {
        .name  = QUAL_EM_SECOND_LOOKUP_CLASS_ID_BITMAPs,  /* QUAL_EM_SECOND_LOOKUP_CLASS_ID_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for exact match second lookup class ID.",
    },
    {
        .name  = QUAL_IP_TYPE_BITMAPs,  /* QUAL_IP_TYPE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on IP type as specified in rule template entries that\n are associated with FP entries which reference this group template.\n",
    },
    {
        .name  = QUAL_L2_FORMAT_BITMAPs,  /* QUAL_L2_FORMAT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on L2 format as specified in rule template entries\n that are associated with FP entries which reference this group\n template.\n",
    },
    {
        .name  = QUAL_INNER_TPID_BITMAPs,  /* QUAL_INNER_TPID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on inner TPID  as specified in rule template entries\n that are associated with FP entries which reference this group\n template.\n",
    },
    {
        .name  = QUAL_OUTER_TPID_BITMAPs,  /* QUAL_OUTER_TPID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on outer TPID  as specified in rule template entries\n that are associated with FP entries which reference this group\n template.\n",
    },
    {
        .name  = QUAL_INNER_L2_OUTER_TPID_BITMAPs,  /* QUAL_INNER_L2_OUTER_TPID_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on inner L2 outer TPID  as specified in rule template\n entries that are associated with FP entries which reference this\n group template.\n",
    },
    {
        .name  = QUAL_FWD_TYPE_BITMAPs,  /* QUAL_FWD_TYPE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packet forwarding type as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_ING_STP_STATE_BITMAPs,  /* QUAL_ING_STP_STATE_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on STP state type as specified in rule\n template entries that are associated with FP entries which reference\n this group template.\n",
    },
    {
        .name  = QUAL_UDF_CHUNKS_BITMAPs,  /* QUAL_UDF_CHUNKS_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "Qualifier bitmap for UDF chunks.",
    },
    {
        .name  = QUAL_C_L4SRC_PORT_BITMAPs,  /* QUAL_C_L4SRC_PORT_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed L4 source port.",
    },
    {
        .name  = QUAL_C_L4DST_PORT_BITMAPs,  /* QUAL_C_L4DST_PORT_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed L4 destination port.",
    },
    {
        .name  = QUAL_C_ETHERTYPE_BITMAPs,  /* QUAL_C_ETHERTYPE_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed Ethertype.",
    },
    {
        .name  = QUAL_C_IP_PROTOCOL_BITMAPs,  /* QUAL_C_IP_PROTOCOL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed IP protocol.",
    },
    {
        .name  = QUAL_C_TTL0_BITMAPs,  /* QUAL_C_TTL0_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed or remapped first TTL.\n Original packet's TTL can be mapped to 2 different values\n This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TTL1_BITMAPs,  /* QUAL_C_TTL1_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed or remapped second TTL.\n Original packet's TTL can be mapped to 2 different values\n This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_C_TOS0_BITMAPs,  /* QUAL_C_TOS0_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed or remapped first TOS.\n Original packet's TOS can be mapped to 2 different values\n This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TOS1_BITMAPs,  /* QUAL_C_TOS1_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed or remapped second TOS.\n Original packet's TOS can be mapped to 2 different values\n This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_C_TCP_FLAGS0_BITMAPs,  /* QUAL_C_TCP_FLAGS0_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed/remapped first TCP control flags.\n Original packet's TCP control flags can be mapped to 2 different\n values. This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TCP_FLAGS1_BITMAPs,  /* QUAL_C_TCP_FLAGS1_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed/remapped second TCP control flags.\n Original packet's TCP control flags can be mapped to 2 different\n values. This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_C_SRC_IP_BITMAPs,  /* QUAL_C_SRC_IP_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed IP source address.",
    },
    {
        .name  = QUAL_C_DST_IP_BITMAPs,  /* QUAL_C_DST_IP_BITMAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed IP destination address.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_LOW_BITMAPs,  /* QUAL_OPAQUE_TAG_LOW_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for lower 32 bits of opaque tag.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_HIGH_BITMAPs,  /* QUAL_OPAQUE_TAG_HIGH_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for upper 32 bits of opaque tag.",
    },
    {
        .name  = QUAL_INNER_L2_OPAQUE_TAG_BITMAPs,  /* QUAL_INNER_L2_OPAQUE_TAG_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for inner L2 opaque tag.",
    },
    {
        .name  = QUAL_TNL_IP_TTL_BITMAPs,  /* QUAL_TNL_IP_TTL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap IP tunnel TTL.\n",
    },
    {
        .name  = QUAL_C_TNL_IP_TTL_BITMAPs,  /* QUAL_C_TNL_IP_TTL_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for compressed or remapped IP tunnel TTL.\n The outer TTL in the terminated tunnel can be mapped to\n a compressed value represented by this field.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_FLAGS_BITMAPs,  /* QUAL_INBAND_TELEMETRY_FLAGS_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifiers bitmap for inband network telemetry flag fields from\n the INT/IOAM/IFA  header.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_MD_HDR_TYPE_BITMAPs,  /* QUAL_INBAND_TELEMETRY_MD_HDR_TYPE_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for incoming inband network telemetry MD header\n type.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HOP_LIMIT_CHECK_STATUS_BITMAPs,  /* QUAL_INBAND_TELEMETRY_HOP_LIMIT_CHECK_STATUS_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for inband network telemetry hop limit check status.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_MAX_LENGTH_CHECK_BITMAPs,  /* QUAL_INBAND_TELEMETRY_MAX_LENGTH_CHECK_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for inband network telemetry max length check status.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HDR_TYPE_BITMAPs,  /* QUAL_INBAND_TELEMETRY_HDR_TYPE_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for incoming inband network telemetry header type.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_UDP_CHECKSUM_ZERO_BITMAPs,  /* QUAL_INBAND_TELEMETRY_UDP_CHECKSUM_ZERO_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for inband network telemetry UDP checksum zero check.\n",
    },
    {
        .name  = QUAL_PROTECTION_DATA_DROP_BITMAPs,  /* QUAL_PROTECTION_DATA_DROP_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on protection data drop packet as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_DCN_PKT_BITMAPs,  /* QUAL_DCN_PKT_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on drop congestion notification(DCN) packet as\n specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HDR_IN_TNL_BITMAPs,  /* QUAL_INBAND_TELEMETRY_HDR_IN_TNL_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on packet with inband network telemetry header in\n tunnel specified in rule template entries that are associated with FP\n entries which reference this group template.\n",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
    {
        .name  = NUM_COMPRESSION_TYPEs,  /* NUM_COMPRESSION_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of elements in COMPRESSION_TYPE array.",
    },
    {
        .name  = COMPRESSION_TYPEs,  /* COMPRESSION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 4,
        .edata = BCMLTD_COMMON_FP_COMPRESSION_TYPE_T_DATA,
        .desc = "Array of compression types to be tried on group qualifer bitmaps",
    },
    {
        .name  = QUAL_GSH_SYSTEM_DST_BITMAPs,  /* QUAL_GSH_SYSTEM_DST_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifiers bitmap for GSH system destination.\n",
    },
    {
        .name  = QUAL_GSH_ETHERTYPE_LSB_4BIT_BITMAPs,  /* QUAL_GSH_ETHERTYPE_LSB_4BIT_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for last 4 bits for GSH ether_type.\n",
    },
    {
        .name  = QUAL_GSH_OPCODE_BITMAPs,  /* QUAL_GSH_OPCODE_BITMAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier bitmap for GSH opcode.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_RAL_DETECTED_BITMAPs,  /* QUAL_MPLS_SPECIAL_LABEL_RAL_DETECTED_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS RAL detected.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_GAL_DETECTED_BITMAPs,  /* QUAL_MPLS_SPECIAL_LABEL_GAL_DETECTED_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS GAL detected.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_CW_DETECTED_BITMAPs,  /* QUAL_MPLS_SPECIAL_LABEL_CW_DETECTED_BITMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier bitmap for MPLS CW detected.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_A_0_15_BITMAPs,  /* QUAL_L3_L4_COMPRESSION_ID_A_0_15_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for l3 l4 compression ID first 2 bytes in part A.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_A_31_16_BITMAPs,  /* QUAL_L3_L4_COMPRESSION_ID_A_31_16_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for l3 l4 compression ID next 2 bytes in part A.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_B_0_15_BITMAPs,  /* QUAL_L3_L4_COMPRESSION_ID_B_0_15_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for l3 l4 compression ID first 2 bytes in part B.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_B_31_16_BITMAPs,  /* QUAL_L3_L4_COMPRESSION_ID_B_31_16_BITMAP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier bitmap for l3 l4 compression ID next 2 bytes in part B.\n",
    },
    {
        .name  = QUAL_RH_FIRST_4_BYTES_BITMAPs,  /* QUAL_RH_FIRST_4_BYTES_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for first 4 bytes of IPv6 routing ext header.\n",
    },
    {
        .name  = QUAL_RH_NEXT_4_BYTES_BITMAPs,  /* QUAL_RH_NEXT_4_BYTES_BITMAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier bitmap for next 4 bytes of IPv6 routing ext header.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_grp_template_t = {
    .name = FP_ING_GRP_TEMPLATEs, /* FP_ING_GRP_TEMPLATE */
    .flags = 0,
    .fields = 223,
    .field = bcmltd_fp_ing_grp_template_t_fields,
    .desc = "The FP_ING_GRP_TEMPLATE table specifies groups in\n the ingress field processor stage.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_GRP_TEMPLATE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_grp_template_info_t_fields[] = {
    {
        .name  = FP_ING_GRP_TEMPLATE_IDs,  /* FP_ING_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP group template ID.",
    },
    {
        .name  = HW_LTIDs,  /* HW_LTID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hardware logical table ID used in action resolution or partition\n resolution in case of group auto expansion. This logical table ID is\n different from the SDKLT logical table ID. Priority can be assigned to\n the hardware logical table ID and is used to resolve conflicting\n actions when a packet matches FP entries from two different FP groups.\n",
    },
    {
        .name  = NUM_ENTRIES_CREATEDs,  /* NUM_ENTRIES_CREATED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries created in this group.",
    },
    {
        .name  = NUM_ENTRIES_TENTATIVEs,  /* NUM_ENTRIES_TENTATIVE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries that can be created in this group.",
    },
    {
        .name  = NUM_PARTITION_IDs,  /* NUM_PARTITION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of partitions(a.k.a physical slices) used for groups width\n expansion.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_grp_template_info_t = {
    .name = FP_ING_GRP_TEMPLATE_INFOs, /* FP_ING_GRP_TEMPLATE_INFO */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_ing_grp_template_info_t_fields,
    .desc = "The FP_ING_GRP_TEMPLATE_INFO table provides FP group-specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_GRP_TEMPLATE_PARTITION_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_grp_template_partition_info_t_fields[] = {
    {
        .name  = FP_ING_GRP_TEMPLATE_IDs,  /* FP_ING_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP group template ID.",
    },
    {
        .name  = PARTITION_IDs,  /* PARTITION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Partition ID.",
    },
    {
        .name  = NUM_SLICE_IDs,  /* NUM_SLICE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of slices to which a group is auto expanded.\n This field specifies\n the number of valid indexes in the SLICE_ID arrays of partitions.\n",
    },
    {
        .name  = SLICE_IDs,  /* SLICE_ID */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Physical slice IDs allocated for the group in the order of expansion\n in the given partition ID.\n",
    },
    {
        .name  = NUM_QUAL_SRC_MAC_INFOs,  /* NUM_QUAL_SRC_MAC_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partition ID arrays\n for source MAC qualifier.\n",
    },
    {
        .name  = QUAL_SRC_MAC_OFFSETs,  /* QUAL_SRC_MAC_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of source MAC qualifier in the final key.",
    },
    {
        .name  = QUAL_SRC_MAC_WIDTHs,  /* QUAL_SRC_MAC_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of source MAC qualifier in the final key. The width at each index\n corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_SRC_MAC_ORDERs,  /* QUAL_SRC_MAC_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for source MAC qualifier in the current partition.\n",
    },
    {
        .name  = NUM_QUAL_DST_MAC_INFOs,  /* NUM_QUAL_DST_MAC_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partition ID arrays\n for source MAC qualifier.\n",
    },
    {
        .name  = QUAL_DST_MAC_OFFSETs,  /* QUAL_DST_MAC_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of source MAC qualifier in the final key.",
    },
    {
        .name  = QUAL_DST_MAC_WIDTHs,  /* QUAL_DST_MAC_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of source MAC qualifier in the final key. The width at each index\n corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_DST_MAC_ORDERs,  /* QUAL_DST_MAC_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for source MAC qualifier in the current partition.\n",
    },
    {
        .name  = NUM_UDF_2_BYTE_CONTAINER_INFOs,  /* NUM_UDF_2_BYTE_CONTAINER_INFO */
        .flags = 0,
        .width = 8,
        .depth = 36,
        .desc = "Number of valid indexes in all the offsets, widths and order arrays\n for UDF 2 byte qualifier and its corresponding chunk as index to array.\n",
    },
    {
        .name  = QUAL_UDF_2_BYTE_CONTAINER_OFFSETs,  /* QUAL_UDF_2_BYTE_CONTAINER_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of UDF 2 byte qualifier in the final key.",
    },
    {
        .name  = QUAL_UDF_2_BYTE_CONTAINER_WIDTHs,  /* QUAL_UDF_2_BYTE_CONTAINER_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of UDF 2 byte qualifier in the final key.\n The width at each index corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_UDF_2_BYTE_CONTAINER_ORDERs,  /* QUAL_UDF_2_BYTE_CONTAINER_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for UDF 2 byte qualifier in the current partition.\n",
    },
    {
        .name  = NUM_UDF_1_BYTE_CONTAINER_INFOs,  /* NUM_UDF_1_BYTE_CONTAINER_INFO */
        .flags = 0,
        .width = 8,
        .depth = 36,
        .desc = "Number of valid indexes in all the offsets, widths and order arrays\n for UDF 1 byte qualifier and its corresponding chunk as index to array.\n",
    },
    {
        .name  = QUAL_UDF_1_BYTE_CONTAINER_OFFSETs,  /* QUAL_UDF_1_BYTE_CONTAINER_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of UDF 1 byte qualifier in the final key.",
    },
    {
        .name  = QUAL_UDF_1_BYTE_CONTAINER_WIDTHs,  /* QUAL_UDF_1_BYTE_CONTAINER_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of UDF 1 byte qualifier in the final key. The width at each index\n corresponds to the offset at the same index.\n",
    },
    {
        .name  = QUAL_UDF_1_BYTE_CONTAINER_ORDERs,  /* QUAL_UDF_1_BYTE_CONTAINER_ORDER */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Order in which offsets, widths, partition ID arrays are present\n for UDF 1 byte qualifier in the current partition.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_grp_template_partition_info_t = {
    .name = FP_ING_GRP_TEMPLATE_PARTITION_INFOs, /* FP_ING_GRP_TEMPLATE_PARTITION_INFO */
    .flags = 0,
    .fields = 20,
    .field = bcmltd_fp_ing_grp_template_partition_info_t_fields,
    .desc = "The FP_ING_GRP_TEMPLATE_PARTITION_INFO table provides\n FP group partition specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_HIGIG_EH_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_higig_eh_mask_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PROFILE_IDs,  /* PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Profile ID.",
    },
    {
        .name  = EH_MASKs,  /* EH_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "This field provides mask. The formula used to modify incoming\n packet follows.\n if HG packet comes with EH Tag\n  pkt.new_EH = (pkt.EH & tEH_MASK[EH_MASK_PROFILE].mask) |\n               (NEW_EH & ~tEH_MASK[EH_MASK_PROFILE].mask);\n If HG packet does not contain EH Tag\n  pkt.new_EH = NEW_EH & ~tEH_MASK[EH_MASK_PROFILE].mask);\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_higig_eh_mask_t = {
    .name = FP_ING_HIGIG_EH_MASKs, /* FP_ING_HIGIG_EH_MASK */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_ing_higig_eh_mask_t_fields,
    .desc = "The FP_ING_HIGIG_EH_MASK specifies the mask for HiGIG extended header.\n IFP_POLICY_TABLE has a field called NEW_EH to set new HiGIG\n Extended header. This EH_MASK is used to reset bits in NEW_EH\n as well as extended header.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_info_t_fields[] = {
    {
        .name  = NUM_SLICESs,  /* NUM_SLICES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of slices.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_info_t = {
    .name = FP_ING_INFOs, /* FP_ING_INFO */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_fp_ing_info_t_fields,
    .desc = "The FP_ING_INFO table provides ingress FP stage-specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_PDD_TEMPLATE_PARTITION_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_pdd_template_partition_info_t_fields[] = {
    {
        .name  = FP_ING_PDD_TEMPLATE_IDs,  /* FP_ING_PDD_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP PDD template ID.",
    },
    {
        .name  = PARTITION_IDs,  /* PARTITION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Partition ID.",
    },
    {
        .name  = NUM_ACTION_COPY_TO_CPU_INFOs,  /* NUM_ACTION_COPY_TO_CPU_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partids arrays for\n copy to cpu action.\n",
    },
    {
        .name  = ACTION_COPY_TO_CPU_OFFSETs,  /* ACTION_COPY_TO_CPU_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of copy to cpu action in the final policy.",
    },
    {
        .name  = ACTION_COPY_TO_CPU_WIDTHs,  /* ACTION_COPY_TO_CPU_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of copy to cpu action in the final policy. Width at each index\n is corresponding to offset at the same index.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_pdd_template_partition_info_t = {
    .name = FP_ING_PDD_TEMPLATE_PARTITION_INFOs, /* FP_ING_PDD_TEMPLATE_PARTITION_INFO */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_ing_pdd_template_partition_info_t_fields,
    .desc = "The FP_ING_PDD_TEMPLATE_PARTITION_INFO table provides FP PDD-specific partition information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_POLICY_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_policy_template_t_fields[] = {
    {
        .name  = FP_ING_POLICY_TEMPLATE_IDs,  /* FP_ING_POLICY_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP policy identifier.",
    },
    {
        .name  = ACTION_R_DROPs,  /* ACTION_R_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop red packets.",
    },
    {
        .name  = ACTION_Y_DROPs,  /* ACTION_Y_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop yellow packets.",
    },
    {
        .name  = ACTION_G_DROPs,  /* ACTION_G_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop green packets.",
    },
    {
        .name  = ACTION_NEW_UNTAG_PKT_PRIORITYs,  /* ACTION_NEW_UNTAG_PKT_PRIORITY */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change packets input priority.",
    },
    {
        .name  = ACTION_R_NEW_COLORs,  /* ACTION_R_NEW_COLOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Change packet color for red packets.",
    },
    {
        .name  = ACTION_Y_NEW_COLORs,  /* ACTION_Y_NEW_COLOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Change packet color for yellow packets.",
    },
    {
        .name  = ACTION_G_NEW_COLORs,  /* ACTION_G_NEW_COLOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Change packet color for green packets.",
    },
    {
        .name  = ACTION_R_FP_ING_COS_Q_INT_PRI_MAP_IDs,  /* ACTION_R_FP_ING_COS_Q_INT_PRI_MAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue using\n FP_ING_COS_Q_INT_PRI_MAP table for red packets.\n",
    },
    {
        .name  = ACTION_R_NEW_COSs,  /* ACTION_R_NEW_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue for red packets.\n Lower 4 bits value is used for changing the unicast COS queue and\n the upper 4 bits value is used for changing the multicast COS queue\n value.\n",
    },
    {
        .name  = ACTION_R_INTPRI_TO_INNER_DOT1Ps,  /* ACTION_R_INTPRI_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to packets inner VLAN tag dot1p priority\n for red packets\n",
    },
    {
        .name  = ACTION_R_NEW_INTPRIs,  /* ACTION_R_NEW_INTPRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Change internal priority to a new value for red packets.",
    },
    {
        .name  = ACTION_R_INTPRI_TO_TOSs,  /* ACTION_R_INTPRI_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to MSB 3 bits from IP Header\n TOS field for red packets.\n",
    },
    {
        .name  = ACTION_R_INTPRI_UPDATES_CANCELs,  /* ACTION_R_INTPRI_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change to internal priority cancel for red packets.",
    },
    {
        .name  = ACTION_R_NEW_UC_COSs,  /* ACTION_R_NEW_UC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue for red packets.",
    },
    {
        .name  = ACTION_R_NEW_MC_COSs,  /* ACTION_R_NEW_MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change multicast COS queue red packets.",
    },
    {
        .name  = ACTION_Y_FP_ING_COS_Q_INT_PRI_MAP_IDs,  /* ACTION_Y_FP_ING_COS_Q_INT_PRI_MAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue using\n FP_ING_COS_Q_INT_PRI_MAP table for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_NEW_COSs,  /* ACTION_Y_NEW_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue for yellow packets.\n Lower 4 bits value is used for changing the unicast COS queue and\n the upper 4 bits value is used for changing the multicast COS queue\n value.\n",
    },
    {
        .name  = ACTION_Y_INTPRI_TO_INNER_DOT1Ps,  /* ACTION_Y_INTPRI_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to packets inner VLAN tag dot1p priority\n for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_NEW_INTPRIs,  /* ACTION_Y_NEW_INTPRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Change internal priority to a new value for yellow packets.",
    },
    {
        .name  = ACTION_Y_INTPRI_TO_TOSs,  /* ACTION_Y_INTPRI_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to MSB 3 bits from IP Header\n TOS field for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_INTPRI_UPDATES_CANCELs,  /* ACTION_Y_INTPRI_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to a new value for yellow packets.",
    },
    {
        .name  = ACTION_Y_NEW_UC_COSs,  /* ACTION_Y_NEW_UC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue for yellow packets.",
    },
    {
        .name  = ACTION_Y_NEW_MC_COSs,  /* ACTION_Y_NEW_MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change multicast COS queue for yellow packets.",
    },
    {
        .name  = ACTION_G_FP_ING_COS_Q_INT_PRI_MAP_IDs,  /* ACTION_G_FP_ING_COS_Q_INT_PRI_MAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue using\n FP_ING_COS_Q_INT_PRI_MAP table for green packets.\n",
    },
    {
        .name  = ACTION_G_NEW_COSs,  /* ACTION_G_NEW_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue and multicast COS queue for green packets.\n Lower 4 bits value is used for changing the unicast COS queue and\n the upper 4 bits value is used for changing the multicast COS queue\n value.\n",
    },
    {
        .name  = ACTION_G_INTPRI_TO_INNER_DOT1Ps,  /* ACTION_G_INTPRI_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to packets inner VLAN tag dot1p priority\n for green packets.\n",
    },
    {
        .name  = ACTION_G_NEW_INTPRIs,  /* ACTION_G_NEW_INTPRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Change internal priority to a new value for green packets.",
    },
    {
        .name  = ACTION_G_INTPRI_TO_TOSs,  /* ACTION_G_INTPRI_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to MSB 3 bits from IP Header\n TOS field for green packets.\n",
    },
    {
        .name  = ACTION_G_INTPRI_UPDATES_CANCELs,  /* ACTION_G_INTPRI_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change internal priority to a new value for green packets.",
    },
    {
        .name  = ACTION_G_NEW_UC_COSs,  /* ACTION_G_NEW_UC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change unicast COS queue for green packets.",
    },
    {
        .name  = ACTION_G_NEW_MC_COSs,  /* ACTION_G_NEW_MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change multicast COS queue for green packets.",
    },
    {
        .name  = ACTION_MIRROR_INSTANCE_ENABLEs,  /* ACTION_MIRROR_INSTANCE_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable the mirror instance at the index.",
    },
    {
        .name  = ACTION_MIRROR_INSTANCE_IDs,  /* ACTION_MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 4,
        .desc = "Array of mirror instances per container.",
    },
    {
        .name  = ACTION_HGT_SPRAY_HASH_CANCELs,  /* ACTION_HGT_SPRAY_HASH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable spray hash on HiGiG ports trunk.",
    },
    {
        .name  = ACTION_TRUNK_SPRAY_HASH_CANCELs,  /* ACTION_TRUNK_SPRAY_HASH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable spray hash on front panel ports trunk.",
    },
    {
        .name  = ACTION_ECMP_SPRAY_HASH_CANCELs,  /* ACTION_ECMP_SPRAY_HASH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable spray hash on ECMP group.",
    },
    {
        .name  = ACTION_DO_NOT_NATs,  /* ACTION_DO_NOT_NAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not NAT.",
    },
    {
        .name  = ACTION_MATCH_IDs,  /* ACTION_MATCH_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set the match ID to packets copied to CPU. This action\n is applied only if COPY_TO_CPU action is present in\n the same POLICY_TEMPLATE  entry.\n",
    },
    {
        .name  = ACTION_R_COPY_TO_CPUs,  /* ACTION_R_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy yellow packet to CPU.",
    },
    {
        .name  = ACTION_R_COPY_TO_CPU_CANCELs,  /* ACTION_R_COPY_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy red packet to CPU action set\n by the lower priority rule for yellow packets.\n",
    },
    {
        .name  = ACTION_R_SWITCH_TO_CPU_CANCELs,  /* ACTION_R_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Switch to CPU cancel - Cancel the signal set\n by ingress pipeline to switch the packet to CPU\n for red packets.\n",
    },
    {
        .name  = ACTION_R_SWITCH_TO_CPU_REINSATEs,  /* ACTION_R_SWITCH_TO_CPU_REINSATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cancel switch to CPU - To cancel the 'Cancel\n switch to CPU' action set by the lower priority rule\n for red packets.\n",
    },
    {
        .name  = ACTION_R_COPY_AND_SWITCH_TO_CPU_CANCELs,  /* ACTION_R_COPY_AND_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy packet to CPU action set by the lower priority rule\n and the signal set by ingress pipeline to switch the packets to\n CPU for red packets.\n",
    },
    {
        .name  = ACTION_R_COPY_TO_CPU_WITH_TIMESTAMPs,  /* ACTION_R_COPY_TO_CPU_WITH_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy packet to CPU with time stamp for red packets.",
    },
    {
        .name  = ACTION_Y_COPY_TO_CPUs,  /* ACTION_Y_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy yellow packet to CPU.",
    },
    {
        .name  = ACTION_Y_COPY_TO_CPU_CANCELs,  /* ACTION_Y_COPY_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy green packet to CPU action set\n by the lower priority rule for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_SWITCH_TO_CPU_CANCELs,  /* ACTION_Y_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Switch to CPU cancel - Cancel the signal set\n by ingress pipeline to switch the packet to CPU\n for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_SWITCH_TO_CPU_REINSATEs,  /* ACTION_Y_SWITCH_TO_CPU_REINSATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cancel switch to CPU - To cancel the 'Cancel\n switch to CPU' action set by the lower priority rule\n for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_COPY_AND_SWITCH_TO_CPU_CANCELs,  /* ACTION_Y_COPY_AND_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy packet to CPU action set by the lower priority rule\n and the signal set by ingress pipeline to switch the packets to\n CPU for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_COPY_TO_CPU_WITH_TIMESTAMPs,  /* ACTION_Y_COPY_TO_CPU_WITH_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy packet to CPU with time stamp for yellow packets.",
    },
    {
        .name  = ACTION_G_COPY_TO_CPUs,  /* ACTION_G_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy green packet to CPU .",
    },
    {
        .name  = ACTION_G_COPY_TO_CPU_CANCELs,  /* ACTION_G_COPY_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy green packet to CPU action set\n by the lower priority rule for green packets.\n",
    },
    {
        .name  = ACTION_G_SWITCH_TO_CPU_CANCELs,  /* ACTION_G_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Switch to CPU cancel - Cancel the signal set\n by ingress pipeline to switch the packet to CPU\n for green packets.\n",
    },
    {
        .name  = ACTION_G_SWITCH_TO_CPU_REINSATEs,  /* ACTION_G_SWITCH_TO_CPU_REINSATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cancel switch to CPU - To cancel the 'Cancel\n switch to CPU' action set by the lower priority rule\n for green packets.\n",
    },
    {
        .name  = ACTION_G_COPY_AND_SWITCH_TO_CPU_CANCELs,  /* ACTION_G_COPY_AND_SWITCH_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel copy packet to CPU action set by the lower priority rule\n and the signal set by ingress pipeline to switch the packets to\n CPU for green packets.\n",
    },
    {
        .name  = ACTION_G_COPY_TO_CPU_WITH_TIMESTAMPs,  /* ACTION_G_COPY_TO_CPU_WITH_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy packet to CPU with time stamp for green packets.",
    },
    {
        .name  = ACTION_DO_NOT_CUT_THROUGHs,  /* ACTION_DO_NOT_CUT_THROUGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not cut-through the packet if ingress pipeline\n set the packet to cutthrough.\n",
    },
    {
        .name  = ACTION_DO_NOT_URPFs,  /* ACTION_DO_NOT_URPF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not URPF if the ingress pipilne set the packet to URPF.",
    },
    {
        .name  = ACTION_DO_NOT_CHANGE_TTLs,  /* ACTION_DO_NOT_CHANGE_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not change packet TTL.",
    },
    {
        .name  = ACTION_R_NEW_ECNs,  /* ACTION_R_NEW_ECN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change ECN for red packets.",
    },
    {
        .name  = ACTION_Y_NEW_ECNs,  /* ACTION_Y_NEW_ECN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change ECN for yellow packets.",
    },
    {
        .name  = ACTION_G_NEW_ECNs,  /* ACTION_G_NEW_ECN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change ECN for green packets.",
    },
    {
        .name  = ACTION_R_PRESERVE_DOT1Ps,  /* ACTION_R_PRESERVE_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Preserve packets dot1p value for red packets.",
    },
    {
        .name  = ACTION_R_OUTER_DOT1P_TO_INNER_DOT1Ps,  /* ACTION_R_OUTER_DOT1P_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy inner VLAN tags dot1p value to outer VLAN tag for red\n packets.\n",
    },
    {
        .name  = ACTION_R_NEW_OUTER_DOT1Ps,  /* ACTION_R_NEW_OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change outer VLAN tags dot1p bits to new value for red packets.",
    },
    {
        .name  = ACTION_R_OUTER_DOT1P_TO_TOSs,  /* ACTION_R_OUTER_DOT1P_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change outer VLAN tag dot1p Value to bit(7,5) of TOS\n for red packets.\n",
    },
    {
        .name  = ACTION_R_DOT1P_UPDATES_CANCELs,  /* ACTION_R_DOT1P_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not change packet dot1p value for red packet\n This overrides dot1p actions from lower priority logical\n tables, but does not result in an action out of the ingress FP.\n",
    },
    {
        .name  = ACTION_Y_PRESERVE_DOT1Ps,  /* ACTION_Y_PRESERVE_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Preserve packets dot1p value for yellow packets.",
    },
    {
        .name  = ACTION_Y_OUTER_DOT1P_TO_INNER_DOT1Ps,  /* ACTION_Y_OUTER_DOT1P_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy inner VLAN tags dot1p value to outer VLAN tag for\n yellow packets.\n",
    },
    {
        .name  = ACTION_Y_NEW_OUTER_DOT1Ps,  /* ACTION_Y_NEW_OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change outer VLAN tags dot1p bits to new value for yellow packets.\n",
    },
    {
        .name  = ACTION_Y_OUTER_DOT1P_TO_TOSs,  /* ACTION_Y_OUTER_DOT1P_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change outer VLAN tag dot1p value to TOS (bit [7,5]) for\n yellow packets.\n",
    },
    {
        .name  = ACTION_Y_DOT1P_UPDATES_CANCELs,  /* ACTION_Y_DOT1P_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not change packet dot1p value for yellow packet\n This overrides dot1p actions from lower priority logical\n tables, but does not result in an action out of the ingresss FP\n",
    },
    {
        .name  = ACTION_G_PRESERVE_DOT1Ps,  /* ACTION_G_PRESERVE_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Preserve packets dot1p value for green packets.",
    },
    {
        .name  = ACTION_G_OUTER_DOT1P_TO_INNER_DOT1Ps,  /* ACTION_G_OUTER_DOT1P_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy inner VLAN tag dot1p value to outer VLAN tag for\n green packets.\n",
    },
    {
        .name  = ACTION_G_NEW_OUTER_DOT1Ps,  /* ACTION_G_NEW_OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change outer VLAN tags dot1p bits to new value for green packets.\n",
    },
    {
        .name  = ACTION_G_OUTER_DOT1P_TO_TOSs,  /* ACTION_G_OUTER_DOT1P_TO_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change outer VLAN tag dot1p value to TOS (bit [7,5]) for\n green packets.\n",
    },
    {
        .name  = ACTION_G_DOT1P_UPDATES_CANCELs,  /* ACTION_G_DOT1P_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not change packet dot1p value for yellow packet\n This overrides dot1p actions from lower priority logical\n tables, but does not result in an action out of the ingress FP.\n",
    },
    {
        .name  = ACTION_R_NEW_DSCPs,  /* ACTION_R_NEW_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Change DSCP to a new value for red packets.",
    },
    {
        .name  = ACTION_R_DSCP_UPDATES_CANCELs,  /* ACTION_R_DSCP_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "This action overrides CHANGE_DSCP actions from lower priority\n logical tables for red packet, but does not result in an action\n out of the ingress FP.\n",
    },
    {
        .name  = ACTION_R_PRESERVE_DSCPs,  /* ACTION_R_PRESERVE_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Sets the PRESERVE_DSCP indication in the HiGig header for\n red packets.\n",
    },
    {
        .name  = ACTION_Y_NEW_DSCPs,  /* ACTION_Y_NEW_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Change DSCP to a new value for yellow packets.",
    },
    {
        .name  = ACTION_Y_DSCP_UPDATES_CANCELs,  /* ACTION_Y_DSCP_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "This action overrides CHANGE_DSCP actions from lower priority\n logical tables for yellow packet, but does not result in an action\n out of the ingress FP.\n",
    },
    {
        .name  = ACTION_Y_PRESERVE_DSCPs,  /* ACTION_Y_PRESERVE_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Sets the PRESERVE_DSCP indication in the HiGig header for\n yellow packets.\n",
    },
    {
        .name  = ACTION_G_NEW_DSCPs,  /* ACTION_G_NEW_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "Change DSCP to a new value for green packets.",
    },
    {
        .name  = ACTION_G_DSCP_UPDATES_CANCELs,  /* ACTION_G_DSCP_UPDATES_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "This action overrides CHANGE_DSCP actions from lower priority\n logical tables for green packet, but does not result in an action\n out of the ingress FP.\n",
    },
    {
        .name  = ACTION_G_PRESERVE_DSCPs,  /* ACTION_G_PRESERVE_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Sets the PRESERVE_DSCP indication in the HiGig header for\n green packets.\n",
    },
    {
        .name  = ACTION_G_NEW_TOSs,  /* ACTION_G_NEW_TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change bits (7,5) of TOS to a new value for green packets.",
    },
    {
        .name  = ACTION_G_TOS_TO_PRE_FP_ING_OUTER_DOT1Ps,  /* ACTION_G_TOS_TO_PRE_FP_ING_OUTER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Change bits (7,5) of TOS to the dot1p value\n from the pre-ingress FP outer VLAN tag for green packets\n",
    },
    {
        .name  = ACTION_CHANGE_PKT_L2_FIELDSs,  /* ACTION_CHANGE_PKT_L2_FIELDS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Change different L2 Fields in the packet with new values.\n New values comes from EGR_L3_NEXT_HOP (view type: IFP_ACTIONS)\n L2 Fields that can be modified using this action:\n Source MAC address\n Destination MAC address\n Outer VLAN\n Vntag (Modify/Delete)\n Etag (Modify/Delete)\n",
    },
    {
        .name  = ACTION_CHANGE_PKT_L2_FIELDS_CANCELs,  /* ACTION_CHANGE_PKT_L2_FIELDS_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Dont Change L2 fields in the packet. It cancels Action from\n CHANGE_PKT_L2_FIELDS set by the lower priority rule\n",
    },
    {
        .name  = ACTION_NEW_CLASSIFICATION_TAGs,  /* ACTION_NEW_CLASSIFICATION_TAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Add classification tag.",
    },
    {
        .name  = ACTION_SWITCH_TO_L3UCs,  /* ACTION_SWITCH_TO_L3UC */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Switch the packet to L3 unicast destination.",
    },
    {
        .name  = ACTION_SWITCH_TO_ECMPs,  /* ACTION_SWITCH_TO_ECMP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Switch the packet to ECMP group.",
    },
    {
        .name  = ACTION_SWITCH_TO_ECMP_RESET_OVERLAY_NHOP_IDs,  /* ACTION_SWITCH_TO_ECMP_RESET_OVERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Switch the packet to ECMP group resetting the overlay next hop index\n assigned by the pipeline.\n",
    },
    {
        .name  = ACTION_ECMP_HASHs,  /* ACTION_ECMP_HASH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECMP hash value to be used.\n",
    },
    {
        .name  = ACTION_L3_SWITCH_CANCELs,  /* ACTION_L3_SWITCH_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel L3 switch action set by the lower priority rule.",
    },
    {
        .name  = ACTION_ING_CLASS_ID_SELECTs,  /* ACTION_ING_CLASS_ID_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select the type of ingress class ID to pass to egress pipeline.",
    },
    {
        .name  = ACTION_FP_ING_CLASS_IDs,  /* ACTION_FP_ING_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Assign a new class ID.",
    },
    {
        .name  = ACTION_NEW_BFD_SEESSION_IDXs,  /* ACTION_NEW_BFD_SEESSION_IDX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Assign new BFD session index.",
    },
    {
        .name  = ACTION_HIGIG_CLASS_ID_SELECTs,  /* ACTION_HIGIG_CLASS_ID_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select HiGig Class ID.",
    },
    {
        .name  = ACTION_NEW_CPU_COSs,  /* ACTION_NEW_CPU_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set new COS to packets copied to or switched to CPU.\n",
    },
    {
        .name  = ACTION_NEW_SERVICE_POOL_IDs,  /* ACTION_NEW_SERVICE_POOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set the new service Pool ID.\n",
    },
    {
        .name  = ACTION_R_DROP_CANCELs,  /* ACTION_R_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for red packets.",
    },
    {
        .name  = ACTION_Y_DROP_CANCELs,  /* ACTION_Y_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for yellow packets.\n",
    },
    {
        .name  = ACTION_G_DROP_CANCELs,  /* ACTION_G_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the drop set by the lower priority rule for green packets.\n",
    },
    {
        .name  = ACTION_G_NEW_INTCNs,  /* ACTION_G_NEW_INTCN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change internal congestion for green packets.",
    },
    {
        .name  = ACTION_Y_NEW_INTCNs,  /* ACTION_Y_NEW_INTCN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change internal congestion for yellow packets.",
    },
    {
        .name  = ACTION_R_NEW_INTCNs,  /* ACTION_R_NEW_INTCN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change internal congestion for red packets.",
    },
    {
        .name  = ACTION_MIRROR_OVERRIDEs,  /* ACTION_MIRROR_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Override the mirror. This field generates a single mirror\n Override action out of the physical slice. This action is\n used to cancel all mirror copies of the packet (Ingress FP-generated\n mirror copies and switch-logic generated mirror copies)\n",
    },
    {
        .name  = ACTION_SFLOW_ENABLEs,  /* ACTION_SFLOW_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable sFlow on packets.",
    },
    {
        .name  = ACTION_MIRROR_ING_FLEX_SFLOW_IDs,  /* ACTION_MIRROR_ING_FLEX_SFLOW_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress sFlow sample index.",
    },
    {
        .name  = ACTION_MIRROR_FLOW_CLASS_ENABLEs,  /* ACTION_MIRROR_FLOW_CLASS_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mirror flow class for selecting the mirror destination\n",
    },
    {
        .name  = ACTION_MIRROR_FLOW_CLASSs,  /* ACTION_MIRROR_FLOW_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mirror flow class for selecting mirror destination\n from EGR_MIRROR_ENCAP_DESTINATION table.\n",
    },
    {
        .name  = ACTION_VISIBILITY_ENABLEs,  /* ACTION_VISIBILITY_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to mark an ingress packet as a visibility packet,\n similar to CPU masquerading feature.\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_MODULEs,  /* ACTION_REDIRECT_TO_MODULE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Redirect to module and do switch logic forwarding\n modifications.\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_PORTs,  /* ACTION_REDIRECT_TO_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to system physical Port and do switch logic forwarding\n modifications.\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_DVPs,  /* ACTION_REDIRECT_TO_DVP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Redirect to DVP.",
    },
    {
        .name  = ACTION_REDIRECT_TO_TRUNKs,  /* ACTION_REDIRECT_TO_TRUNK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to trunk and do switch logic forwarding modifications.",
    },
    {
        .name  = ACTION_UNMODIFIED_REDIRECT_TO_MODULEs,  /* ACTION_UNMODIFIED_REDIRECT_TO_MODULE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Redirect to module but do not perform switch logic forwarding\n modifications.\n",
    },
    {
        .name  = ACTION_UNMODIFIED_REDIRECT_TO_TRUNKs,  /* ACTION_UNMODIFIED_REDIRECT_TO_TRUNK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to trunk but do not perform switch logic forwarding\n modifications.\n",
    },
    {
        .name  = ACTION_UNMODIFIED_REDIRECT_TO_PORTs,  /* ACTION_UNMODIFIED_REDIRECT_TO_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to system physical port and do not perform switch logic\n forwarding modifications.\n",
    },
    {
        .name  = ACTION_REDIRECT_TO_NHOPs,  /* ACTION_REDIRECT_TO_NHOP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to next hop.",
    },
    {
        .name  = ACTION_REDIRECT_TO_ECMPs,  /* ACTION_REDIRECT_TO_ECMP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to ECMP group.",
    },
    {
        .name  = ACTION_REDIRECT_TO_ECMP_RESET_OVERLAY_NHOP_IDs,  /* ACTION_REDIRECT_TO_ECMP_RESET_OVERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect to ECMP group resetting the overlay next hop index assigned\n by the pipeline.\n",
    },
    {
        .name  = ACTION_REDIRECT_UC_CANCELs,  /* ACTION_REDIRECT_UC_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not redirect to unicast destination.\n Cancel all unicast redirect actions set by the lower prioirty rule.\n",
    },
    {
        .name  = ACTION_REDIRECT_PORTS_BROADCAST_PKTs,  /* ACTION_REDIRECT_PORTS_BROADCAST_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to replace the pipeline generated egress port bitmap with the\n new egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_ADD_PORTS_BROADCASTs,  /* ACTION_REDIRECT_ADD_PORTS_BROADCAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add ports to the pipeline generated egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_REMOVE_PORTS_BROADCASTs,  /* ACTION_REDIRECT_REMOVE_PORTS_BROADCAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove ports from the pipeline generated egress port\n bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_PORTS_VLAN_BROADCASTs,  /* ACTION_REDIRECT_PORTS_VLAN_BROADCAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to redirect packets to all ports associated with the incoming\n VLAN instead of the pipeline generated egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_PORTS_VLAN_BROADCAST_FP_INGs,  /* ACTION_REDIRECT_PORTS_VLAN_BROADCAST_FP_ING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to redirect packets to new ports in the incoming VLAN instead\n of pipeline generated egress port bitmap.\n",
    },
    {
        .name  = ACTION_REDIRECT_L2_MC_GROUP_IDs,  /* ACTION_REDIRECT_L2_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L2_MC_GROUP logical table index.",
    },
    {
        .name  = ACTION_REDIRECT_L3_MC_NHOP_IDs,  /* ACTION_REDIRECT_L3_MC_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3_MC_NHOP logical table index.",
    },
    {
        .name  = ACTION_FP_ING_REDIRECT_DATA_IDs,  /* ACTION_FP_ING_REDIRECT_DATA_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP_ING_REDIRECT_DATA logical table index.",
    },
    {
        .name  = ACTION_FP_ING_REMOVE_REDIRECT_DATA_IDs,  /* ACTION_FP_ING_REMOVE_REDIRECT_DATA_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP_ING_REMOVE_REDIRECT_DATA logical table index.",
    },
    {
        .name  = ACTION_FP_ING_ADD_REDIRECT_DATA_IDs,  /* ACTION_FP_ING_ADD_REDIRECT_DATA_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP_ING_ADD_REDIRECT_DATA logical table index.",
    },
    {
        .name  = ACTION_NEW_HIGIG_EHs,  /* ACTION_NEW_HIGIG_EH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Add HiGiG extended header.",
    },
    {
        .name  = ACTION_HIGIG_EH_MASK_PROFILE_IDs,  /* ACTION_HIGIG_EH_MASK_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "HiGig extended header profile ID.",
    },
    {
        .name  = ACTION_NAT_EGR_OVERRIDEs,  /* ACTION_NAT_EGR_OVERRIDE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Override egress NAT.",
    },
    {
        .name  = ACTION_ING_TIMESTAMP_INSERTs,  /* ACTION_ING_TIMESTAMP_INSERT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Insert ingress pipe received time stamp.",
    },
    {
        .name  = ACTION_ING_TIMESTAMP_INSERT_CANCELs,  /* ACTION_ING_TIMESTAMP_INSERT_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the ingress timestamp action set by the lower priority rule.\n",
    },
    {
        .name  = ACTION_EGR_TIMESTAMP_INSERTs,  /* ACTION_EGR_TIMESTAMP_INSERT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Insert egress pipe trasmitted time stamp.",
    },
    {
        .name  = ACTION_EGR_TIMESTAMP_INSERT_CANCELs,  /* ACTION_EGR_TIMESTAMP_INSERT_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel the egress timestamp action set tby the lower priority rule.\n",
    },
    {
        .name  = ACTION_FLEX_CTR_R_COUNTs,  /* ACTION_FLEX_CTR_R_COUNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "0 - Don't count red packets.\n 1 - Count red packets and\n              counter index = CTR_ING_FLEX_BASE_INDEX + 0\n 2 - Count red packets and\n              counter index = CTR_ING_FLEX_BASE_INDEX + 1\n 3 - Count red packets and\n              counter index = CTR_ING_FLEX_BASE_INDEX + 2\n",
    },
    {
        .name  = ACTION_FLEX_CTR_Y_COUNTs,  /* ACTION_FLEX_CTR_Y_COUNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "0 - Don't count yellow packets.\n 1 - Count yellow packets and\n                counter index = CTR_ING_FLEX_BASE_INDEX + 0\n 2 - Count yellow packets and\n                counter index = CTR_ING_FLEX_BASE_INDEX + 1\n 3 - Count yellow packets and\n                counter index = CTR_ING_FLEX_BASE_INDEX + 2\n",
    },
    {
        .name  = ACTION_FLEX_CTR_G_COUNTs,  /* ACTION_FLEX_CTR_G_COUNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "0 - Don't count green packets.\n 1 - Count green packets and\n                counter index = CTR_ING_FLEX_BASE_INDEX + 0\n 2 - Count green packets and\n                counter index = CTR_ING_FLEX_BASE_INDEX + 1\n 3 - Count green packets and\n                counter index = CTR_ING_FLEX_BASE_INDEX + 2\n",
    },
    {
        .name  = ACTION_ETRAP_COLOR_DISABLEs,  /* ACTION_ETRAP_COLOR_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable color and COS for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_COLOR_ENABLEs,  /* ACTION_ETRAP_COLOR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable color and COS for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_LOOKUP_DISABLEs,  /* ACTION_ETRAP_LOOKUP_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable lookup for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_LOOKUP_ENABLEs,  /* ACTION_ETRAP_LOOKUP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable lookup for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_QUEUE_DISABLEs,  /* ACTION_ETRAP_QUEUE_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable queue assignment for elephant flows.",
    },
    {
        .name  = ACTION_ETRAP_QUEUE_ENABLEs,  /* ACTION_ETRAP_QUEUE_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable queue assignment for elephant flows.",
    },
    {
        .name  = ACTION_DLB_ECMP_MONITOR_DISABLEs,  /* ACTION_DLB_ECMP_MONITOR_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable ECMP monitor during Dynamic Load Balancing(DLB).",
    },
    {
        .name  = ACTION_DLB_ECMP_MONITOR_ENABLEs,  /* ACTION_DLB_ECMP_MONITOR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ECMP monitor during Dynamic Load Balancing(DLB).",
    },
    {
        .name  = ACTION_MIRROR_EGR_ZERO_PAYLOAD_PROFILE_IDs,  /* ACTION_MIRROR_EGR_ZERO_PAYLOAD_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enable zeroing (payload wiping) on any mirrored packet\n and sets the corresponding profile ID to determine the\n offsets to start for zeroing for the payload.\n",
    },
    {
        .name  = ACTION_DELAYED_DROP_ENABLEs,  /* ACTION_DELAYED_DROP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable delayed drop action specified by ACTION_FP_DELAYED_DROP_ID.\n",
    },
    {
        .name  = ACTION_FP_DELAYED_DROP_IDs,  /* ACTION_FP_DELAYED_DROP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index to FP_DELAYED_DROP table used to program\n delayed drop action related controls. Applicable when\n ACTION_DELAYED_DROP_ENABLE is enabled.\n",
    },
    {
        .name  = ACTION_DELAYED_REDIRECT_ENABLEs,  /* ACTION_DELAYED_REDIRECT_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable delayed redirect action specified by\n ACTION_FP_DELAYED_REDIRECT_ID and ACTION_DELAYED_REDIRECT_PORT.\n",
    },
    {
        .name  = ACTION_FP_DELAYED_REDIRECT_IDs,  /* ACTION_FP_DELAYED_REDIRECT_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index to FP_DELAYED_REDIRECT table used to program\n delayed redirect action related controls.\n This should be programmed along with ACTION_DELAYED_REDIRECT_PORT\n for the action to take effect. Applicable when\n ACTION_DELAYED_REDIRECT_ENABLE is enabled.\n",
    },
    {
        .name  = ACTION_DELAYED_REDIRECT_PORTs,  /* ACTION_DELAYED_REDIRECT_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect port where the packets need to be redirected to, in case\n of a delayed redirection action.\n This should be programmed along with ACTION_FP_DELAYED_REDIRECT_ID.\n for the action to take effect. Applicable when\n ACTION_DELAYED_REDIRECT_ENABLE is enabled.\n",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_CONTAINER_IDs,  /* CTR_ING_EFLEX_CONTAINER_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter container ID.",
    },
    {
        .name  = ACTION_MIRROR_ON_DROP_TM_ENABLEs,  /* ACTION_MIRROR_ON_DROP_TM_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mirror on DROP enable for TM.\n",
    },
    {
        .name  = ACTION_MIRROR_ON_DROP_TM_DISABLEs,  /* ACTION_MIRROR_ON_DROP_TM_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mirror on DROP disable for TM.\n",
    },
    {
        .name  = ACTION_MIRROR_ON_DROP_TM_PROFILE_IDs,  /* ACTION_MIRROR_ON_DROP_TM_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Points to the TM_MIRROR_ON_DROP_PROFILE logical table index.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_ENCAP_ENABLEs,  /* ACTION_INBAND_TELEMETRY_ENCAP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable inband network telemetry encapsulation. This action triggers\n to encapsulate the inband network telemetry (INT) metadata in the\n egress stage for a given packet.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_ENCAP_DISABLEs,  /* ACTION_INBAND_TELEMETRY_ENCAP_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable inband network telemetry encapsulation. This action force\n disables the encapsulation which is triggered by the INT module in\n the ingress stage.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_PROFILE_IDXs,  /* ACTION_INBAND_TELEMETRY_PROFILE_IDX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inband network telemetry action profile index.",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_SAMPLE_ENABLEs,  /* ACTION_INBAND_TELEMETRY_SAMPLE_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to apply the inband network telemetry action profile scope\n only to sampled packets matching this flow.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_FLOW_CLASS_IDs,  /* ACTION_INBAND_TELEMETRY_FLOW_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inband network telemetry flow class ID. Used to index\n INT_FLOW_METADATA table and this will overrides the FLOW_CLASS_ID\n assigned by LPM.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_TERM_ACTION_PROFILE_IDXs,  /* ACTION_INBAND_TELEMETRY_TERM_ACTION_PROFILE_IDX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inband network telemetry action profile index assigned when the\n destination port bitmap check result is TRUE. This overrides the\n INBAND_ACTION_PROFILE_IDX.\n",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_EGR_LOOPBACK_PROFILE_IDXs,  /* ACTION_INBAND_TELEMETRY_EGR_LOOPBACK_PROFILE_IDX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index to EGR_LOOPBACK_PROFILE table.",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_0s,  /* ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_0 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inband network telemetry MMU request 0.",
    },
    {
        .name  = ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_1s,  /* ACTION_INBAND_TELEMETRY_MMU_STAT_REQ_1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inband network telemetry MMU request 1.",
    },
    {
        .name  = ACTION_NEW_SERVICE_POOL_PRECEDENCEs,  /* ACTION_NEW_SERVICE_POOL_PRECEDENCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set the service pool ID's new precedence.\n",
    },
    {
        .name  = ACTION_DGMs,  /* ACTION_DGM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set dynamic group multipath enable for load balancing.\n",
    },
    {
        .name  = ACTION_DGM_BIASs,  /* ACTION_DGM_BIAS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set alternate path bias for dynamic group multipath.\n",
    },
    {
        .name  = ACTION_DGM_COSTs,  /* ACTION_DGM_COST */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set alternate path cost for dynamic group multipath.\n",
    },
    {
        .name  = ACTION_DGM_THRESHOLDs,  /* ACTION_DGM_THRESHOLD */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set alternate path threshold for dynamic group multipath.\n",
    },
    {
        .name  = ACTION_PROTECTION_SWITCHING_DROP_OVERRIDEs,  /* ACTION_PROTECTION_SWITCHING_DROP_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to override the protection switching drop.\n",
    },
    {
        .name  = ACTION_DYNAMIC_ECMP_CANCELs,  /* ACTION_DYNAMIC_ECMP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to prefer hash based load balancing over dynamic.",
    },
    {
        .name  = ACTION_DYNAMIC_ECMP_ENABLEs,  /* ACTION_DYNAMIC_ECMP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to prefer dynamic load balancing over hash based.",
    },
    {
        .name  = ACTION_DISABLE_SRC_PRUNINGs,  /* ACTION_DISABLE_SRC_PRUNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable source pruning.",
    },
    {
        .name  = ACTION_DCN_ENABLEs,  /* ACTION_DCN_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mark packets as eligible for DCN",
    },
    {
        .name  = ACTION_DCN_DISABLEs,  /* ACTION_DCN_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mark packets as not eligible for DCN",
    },
    {
        .name  = ACTION_GREEN_TO_PIDs,  /* ACTION_GREEN_TO_PID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Treat all packets as green",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_policy_template_t = {
    .name = FP_ING_POLICY_TEMPLATEs, /* FP_ING_POLICY_TEMPLATE */
    .flags = 0,
    .fields = 186,
    .field = bcmltd_fp_ing_policy_template_t_fields,
    .desc = "The FP_ING_POLICY_TEMPLATE table specifies the set\n of ingress FP policies that can be attached to an ingress FP entry.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_PRESEL_ENTRY_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_presel_entry_template_t_fields[] = {
    {
        .name  = FP_ING_PRESEL_ENTRY_TEMPLATE_IDs,  /* FP_ING_PRESEL_ENTRY_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress preselection entry identifier.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Presel entry priority. Scope of this priority is within other\n presel IDs associated to a group to which this presel id is\n associated.\n",
    },
    {
        .name  = QUAL_IP_TYPEs,  /* QUAL_IP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IP specific information.",
    },
    {
        .name  = QUAL_L4_PKTs,  /* QUAL_L4_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier if valid L4 Src and Dest Port.",
    },
    {
        .name  = QUAL_L4_PKT_MASKs,  /* QUAL_L4_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L4.",
    },
    {
        .name  = QUAL_TNL_TYPEs,  /* QUAL_TNL_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for tunnel type.",
    },
    {
        .name  = QUAL_LOOPBACK_TYPEs,  /* QUAL_LOOPBACK_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for loopback type.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_HITs,  /* QUAL_MYSTATIONTCAM_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for my station TCAM hit Status.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_HIT_MASKs,  /* QUAL_MYSTATIONTCAM_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MYSTATIONTCAM_HIT.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_2_HITs,  /* QUAL_MYSTATIONTCAM_2_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for my station 2 TCAM hit Status.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_2_HIT_MASKs,  /* QUAL_MYSTATIONTCAM_2_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MYSTATIONTCAM_2_HIT.",
    },
    {
        .name  = QUAL_SRC_VP_VALIDs,  /* QUAL_SRC_VP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier if packet has valid SVP.",
    },
    {
        .name  = QUAL_SRC_VP_VALID_MASKs,  /* QUAL_SRC_VP_VALID_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_SRC_VP_VALID.",
    },
    {
        .name  = QUAL_MPLS_BOS_TERMINATEDs,  /* QUAL_MPLS_BOS_TERMINATED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for BOS label terminated in MPLS packet.",
    },
    {
        .name  = QUAL_MPLS_BOS_TERMINATED_MASKs,  /* QUAL_MPLS_BOS_TERMINATED_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MPLS_BOS_TERMINATED.",
    },
    {
        .name  = QUAL_MPLSENTRY_FIRSTLOOKUP_HITs,  /* QUAL_MPLSENTRY_FIRSTLOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for First Lookup hit in MPLS_ENTRY table.",
    },
    {
        .name  = QUAL_MPLSENTRY_FIRSTLOOKUP_HIT_MASKs,  /* QUAL_MPLSENTRY_FIRSTLOOKUP_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MPLSENTRY_FIRSTLOOKUP_HIT.",
    },
    {
        .name  = QUAL_MPLSENTRY_SECONDLOOKUP_HITs,  /* QUAL_MPLSENTRY_SECONDLOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for second Lookup hit in MPLS_ENTRY table.",
    },
    {
        .name  = QUAL_MPLSENTRY_SECONDLOOKUP_HIT_MASKs,  /* QUAL_MPLSENTRY_SECONDLOOKUP_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MPLSENTRY_SECONDLOOKUP_HIT.",
    },
    {
        .name  = QUAL_L3_TNL_HITs,  /* QUAL_L3_TNL_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for IP address hit in L3 Tunnel table.",
    },
    {
        .name  = QUAL_L3_TNL_HIT_MASKs,  /* QUAL_L3_TNL_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L3_TNL_HIT.",
    },
    {
        .name  = QUAL_DOSATTACK_PKTs,  /* QUAL_DOSATTACK_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for DOS Attack packet.",
    },
    {
        .name  = QUAL_DOSATTACK_PKT_MASKs,  /* QUAL_DOSATTACK_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_DOSATTACK_PKT.",
    },
    {
        .name  = QUAL_L3_DST_LPM_HITs,  /* QUAL_L3_DST_LPM_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for destination IP address hit in L3 Route table.",
    },
    {
        .name  = QUAL_L3_DST_LPM_HIT_MASKs,  /* QUAL_L3_DST_LPM_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L3_DST_LPM_HIT.",
    },
    {
        .name  = QUAL_L3_DST_HOST_HITs,  /* QUAL_L3_DST_HOST_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for destination IP address hit in L3_ENTRY table.",
    },
    {
        .name  = QUAL_L3_DST_HOST_HIT_MASKs,  /* QUAL_L3_DST_HOST_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L3_DST_HOST_HIT.",
    },
    {
        .name  = QUAL_L3_SRC_HOST_HITs,  /* QUAL_L3_SRC_HOST_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for source IP address hit in L3_ENTRY table.",
    },
    {
        .name  = QUAL_L3_SRC_HOST_HIT_MASKs,  /* QUAL_L3_SRC_HOST_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L3_SRC_HOST_HIT.",
    },
    {
        .name  = QUAL_L2CACHE_HITs,  /* QUAL_L2CACHE_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L2 User Entry Lookup hit Status.",
    },
    {
        .name  = QUAL_L2CACHE_HIT_MASKs,  /* QUAL_L2CACHE_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L2CACHE_HIT.",
    },
    {
        .name  = QUAL_L2_DST_HITs,  /* QUAL_L2_DST_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for destination MAC Lookup hit in L2_Entry table.",
    },
    {
        .name  = QUAL_L2_DST_HIT_MASKs,  /* QUAL_L2_DST_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L2_DST_HIT.",
    },
    {
        .name  = QUAL_L2_SRC_HITs,  /* QUAL_L2_SRC_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for source MAC Lookup hit in L2_Entry table.",
    },
    {
        .name  = QUAL_L2_SRC_HIT_MASKs,  /* QUAL_L2_SRC_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L2_SRC_HIT.",
    },
    {
        .name  = QUAL_L2_SRC_STATICs,  /* QUAL_L2_SRC_STATIC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L2 source is a Static Entry.",
    },
    {
        .name  = QUAL_L2_SRC_STATIC_MASKs,  /* QUAL_L2_SRC_STATIC_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_L2_SRC_STATIC.",
    },
    {
        .name  = QUAL_ING_STP_STATEs,  /* QUAL_ING_STP_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for ingress Spanning tree state.",
    },
    {
        .name  = QUAL_FWD_VLAN_VALIDs,  /* QUAL_FWD_VLAN_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for Forwarding VLAN valid.",
    },
    {
        .name  = QUAL_FWD_VLAN_VALID_MASKs,  /* QUAL_FWD_VLAN_VALID_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_FWD_VLAN_VALID.",
    },
    {
        .name  = QUAL_VXLT_LOOKUP_HITs,  /* QUAL_VXLT_LOOKUP_HIT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for VLAN translate lookup hit.",
    },
    {
        .name  = QUAL_FWD_TYPEs,  /* QUAL_FWD_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for Forwarding type.",
    },
    {
        .name  = QUAL_PKT_RESOLUTIONs,  /* QUAL_PKT_RESOLUTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for packet resolution.",
    },
    {
        .name  = QUAL_PKT_RESOLUTION_MASKs,  /* QUAL_PKT_RESOLUTION_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask of QUAL_PKT_RESOLUTION.",
    },
    {
        .name  = QUAL_DROP_PKTs,  /* QUAL_DROP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet is flagged to be dropped.",
    },
    {
        .name  = QUAL_DROP_PKT_MASKs,  /* QUAL_DROP_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_DROP_PKT.",
    },
    {
        .name  = QUAL_HIGIG_PKTs,  /* QUAL_HIGIG_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet received on HiGig Port.",
    },
    {
        .name  = QUAL_HIGIG_PKT_MASKs,  /* QUAL_HIGIG_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_HIGIG_PKT.",
    },
    {
        .name  = QUAL_MIRROR_PKTs,  /* QUAL_MIRROR_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for Replication copy of Original packet.",
    },
    {
        .name  = QUAL_MIRROR_PKT_MASKs,  /* QUAL_MIRROR_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_MIRROR_PKT.",
    },
    {
        .name  = QUAL_VISIBILITY_PKTs,  /* QUAL_VISIBILITY_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for visibility packet(CPU masquerade packet).",
    },
    {
        .name  = QUAL_VISIBILITY_PKT_MASKs,  /* QUAL_VISIBILITY_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_VISIBILITY_PKT.",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKTs,  /* QUAL_HIGIGLOOKUP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet received on HiGig Port\n and lookup happened.\n",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKT_MASKs,  /* QUAL_HIGIGLOOKUP_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_HIGIGLOOKUP_PKT.",
    },
    {
        .name  = QUAL_MIXED_SRC_CLASSs,  /* QUAL_MIXED_SRC_CLASS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for mixed source class.",
    },
    {
        .name  = QUAL_MIXED_SRC_CLASS_MASKs,  /* QUAL_MIXED_SRC_CLASS_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask of QUAL_MIXED_SRC_CLASS.",
    },
    {
        .name  = QUAL_EM_FIRST_LOOKUP_LTIDs,  /* QUAL_EM_FIRST_LOOKUP_LTID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for EM first lookup LTID.",
    },
    {
        .name  = QUAL_EM_FIRST_LOOKUP_LTID_MASKs,  /* QUAL_EM_FIRST_LOOKUP_LTID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask of QUAL_EM_FIRST_LOOKUP_LTID.",
    },
    {
        .name  = QUAL_EM_SECOND_LOOKUP_LTIDs,  /* QUAL_EM_SECOND_LOOKUP_LTID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for EM second lookup LTID.",
    },
    {
        .name  = QUAL_EM_SECOND_LOOKUP_LTID_MASKs,  /* QUAL_EM_SECOND_LOOKUP_LTID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask of QUAL_EM_SECOND_LOOKUP_LTID.",
    },
    {
        .name  = PRESEL_CLASSs,  /* PRESEL_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "User can assign class ID in presel. This class ID can be\n used as a qualifier in IFP.\n",
    },
    {
        .name  = NORMALIZE_L2s,  /* NORMALIZE_L2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "User can set normalize MAC in case of presel rule match.\n This value can be used as a qualifier in IFP.\n By setting to 1, MAC qualifiers in IFP are normalized.\n",
    },
    {
        .name  = NORMALIZE_L3_L4s,  /* NORMALIZE_L3_L4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "User can set normalize IP and L4 Port in case of presel rule\n match. This value can be matched in IFP.\n By setting to 1, IP and L4 PORT qualifiers in IFP are normalized.\n",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_presel_entry_template_t = {
    .name = FP_ING_PRESEL_ENTRY_TEMPLATEs, /* FP_ING_PRESEL_ENTRY_TEMPLATE */
    .flags = 0,
    .fields = 64,
    .field = bcmltd_fp_ing_presel_entry_template_t_fields,
    .desc = "The FP_ING_PRESEL_ENTRY_TEMPLATE table specifies the preselection entry for\n ingress FP\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_PRESEL_GRP_TEMPLATE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_presel_grp_template_info_t_fields[] = {
    {
        .name  = FP_ING_PRESEL_GRP_TEMPLATE_IDs,  /* FP_ING_PRESEL_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP group template ID.",
    },
    {
        .name  = NUM_QUAL_L4_VALID_INFOs,  /* NUM_QUAL_L4_VALID_INFO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid indexes in all the offsets, widths, partids arrays for\n L4 packet qualifier.\n",
    },
    {
        .name  = QUAL_L4_VALID_OFFSETs,  /* QUAL_L4_VALID_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Offsets of L4 packet qualifier in the final KEY.",
    },
    {
        .name  = QUAL_L4_VALID_WIDTHs,  /* QUAL_L4_VALID_WIDTH */
        .flags = 0,
        .width = 16,
        .depth = 20,
        .desc = "Widths of L4 Packet qualifier in the final KEY. Width at each index\n is corresponding to offset at the same index.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_presel_grp_template_info_t = {
    .name = FP_ING_PRESEL_GRP_TEMPLATE_INFOs, /* FP_ING_PRESEL_GRP_TEMPLATE_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_ing_presel_grp_template_info_t_fields,
    .desc = "The FP_ING_PRESEL_GRP_TEMPLATE_INFO table provide\n FP preselection group specific\n information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_RANGE_CHECK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_range_check_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = FP_ING_RANGE_CHECK_IDs,  /* FP_ING_RANGE_CHECK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Range check identifier.",
    },
    {
        .name  = RC_FIELD_TYPEs,  /* RC_FIELD_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Range check module can do range checking on packet fields\n or metadata fields. This field specifies on which field this\n entry do range checking.\n",
    },
    {
        .name  = MAX_VALUEs,  /* MAX_VALUE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Max Value in the range.",
    },
    {
        .name  = MIN_VALUEs,  /* MIN_VALUE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Min value in the range.",
    },
    {
        .name  = UDF1_CHUNK2_MASKs,  /* UDF1_CHUNK2_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "If RC_TYPE is set to UDF, this field apply this mask\n Udf Chunk before doing the range check.\n",
    },
    {
        .name  = NUM_RULESs,  /* NUM_RULES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of rules created in FP_ING_RULE_TEMPLATE LT that are\n qualifying on this RC_ID. This is read only field and if this\n is not zero RC_ID cannot be deleted.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_range_check_t = {
    .name = FP_ING_RANGE_CHECKs, /* FP_ING_RANGE_CHECK */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_fp_ing_range_check_t_fields,
    .desc = "The FP_ING_RANGE_CHECK specifies range check for different packet and meta\n data fields.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_RANGE_CHECK_GROUP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_range_check_group_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = FP_ING_RANGE_CHECK_GROUP_IDs,  /* FP_ING_RANGE_CHECK_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Range group identifier.",
    },
    {
        .name  = FP_ING_RANGE_GROUPs,  /* FP_ING_RANGE_GROUP */
        .flags = 0,
        .width = 1,
        .depth = 64,
        .desc = "Enable if the range check ID created in the FP_ING_RANGE_CHECK table\n is to be added to this range group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_range_check_group_t = {
    .name = FP_ING_RANGE_CHECK_GROUPs, /* FP_ING_RANGE_CHECK_GROUP */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_ing_range_check_group_t_fields,
    .desc = "The FP_ING_RANGE_CHECK_GROUP table specifies a set of range check IDs that need\n to be grouped together. The specified group will get a hit when one of the range\n conditions in the set of range IDs is met.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_REDIRECT_DATA.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_redirect_data_t_fields[] = {
    {
        .name  = FP_ING_REDIRECT_DATA_IDs,  /* FP_ING_REDIRECT_DATA_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Redirect data identifier.",
    },
    {
        .name  = REDIRECT_PORTSs,  /* REDIRECT_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to add/remove the specified port to the pipeline generated\n egress port bitmap.\n The specified ports are removed from the pipeline generated egress\n ports bitmap when ACTION_REDIRECT_REMOVE_PORTS_BROADCAST is enabled.\n",
    },
    {
        .name  = HIGIG_TRUNK_OVERRIDE_BITMAP_IDs,  /* HIGIG_TRUNK_OVERRIDE_BITMAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "When FP redirection is to an broadcast to outgoing VLAN,\n then this field gives the higig trunk override profile pointer\n to the ING_HIGIG_TRUNK_OVERRIDE_PROFILE table. The bitmap from\n the ING_HIGIG_TRUNK_OVERRIDE_PROFILE table is used to disable\n higig trunk resolution for each trunk group in the BITMAP field\n of this table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_redirect_data_t = {
    .name = FP_ING_REDIRECT_DATAs, /* FP_ING_REDIRECT_DATA */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_fp_ing_redirect_data_t_fields,
    .desc = "The FP_ING_REDIRECT_DATA table specifies a set of redirect ports that can be\n added to or removed from the pipeline generated egress port bitmap. The\n redirect actions can be specified in the FP_ING_POLICY_TEMPLATE and\n FP_EM_POLICY_TEMPLATE tables.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_REMOVE_REDIRECT_DATA.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_remove_redirect_data_t_fields[] = {
    {
        .name  = FP_ING_REMOVE_REDIRECT_DATA_IDs,  /* FP_ING_REMOVE_REDIRECT_DATA_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Redirect data identifier.",
    },
    {
        .name  = REDIRECT_PORTSs,  /* REDIRECT_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to remove the specified port from the pipeline generated\n egress port bitmap.\n Disable to preserve the specified port in the pipeline generated\n egress port bitmap.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_remove_redirect_data_t = {
    .name = FP_ING_REMOVE_REDIRECT_DATAs, /* FP_ING_REMOVE_REDIRECT_DATA */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_fp_ing_remove_redirect_data_t_fields,
    .desc = "The FP_ING_REMOVE_REDIRECT_DATA table specifies a set of redirect ports that\n can be removed from the pipeline generated egress port bitmap. The redirect\n actions can be specified in the FP_ING_POLICY_TEMPLATE and\n FP_EM_POLICY_TEMPLATE tables.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_RULE_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_rule_template_t_fields[] = {
    {
        .name  = FP_ING_RULE_TEMPLATE_IDs,  /* FP_ING_RULE_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Rule identifier.",
    },
    {
        .name  = NUM_COMPRESSION_TYPEs,  /* NUM_COMPRESSION_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of elements in COMPRESSION_TYPE array.",
    },
    {
        .name  = COMPRESSION_TYPEs,  /* COMPRESSION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 4,
        .edata = BCMLTD_COMMON_FP_COMPRESSION_TYPE_T_DATA,
        .desc = "Array of compression types to be tried on group qualifer bitmaps",
    },
    {
        .name  = QUAL_OUTER_VLAN_IDs,  /* QUAL_OUTER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier for outer VLAN ID.",
    },
    {
        .name  = QUAL_OUTER_VLAN_ID_MASKs,  /* QUAL_OUTER_VLAN_ID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OUTER_VLAN_ID.",
    },
    {
        .name  = QUAL_OUTER_VLAN_PRIs,  /* QUAL_OUTER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier for outer VLAN priority.\n  Qualifies on priority value set in field NEW_PRI\n  which is a part of PHB_ING_L2_OTAG_REMAP LT.\n",
    },
    {
        .name  = QUAL_OUTER_VLAN_PRI_MASKs,  /* QUAL_OUTER_VLAN_PRI_MASK */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OUTER_VLAN_PRI.",
    },
    {
        .name  = QUAL_OUTER_VLAN_CFIs,  /* QUAL_OUTER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for outer VLAN CFI.",
    },
    {
        .name  = QUAL_OUTER_VLAN_CFI_MASKs,  /* QUAL_OUTER_VLAN_CFI_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OUTER_VLAN_CFI.",
    },
    {
        .name  = QUAL_INNER_VLAN_IDs,  /* QUAL_INNER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier for inner VLAN ID.",
    },
    {
        .name  = QUAL_INNER_VLAN_ID_MASKs,  /* QUAL_INNER_VLAN_ID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_VLAN_ID.",
    },
    {
        .name  = QUAL_INNER_VLAN_PRIs,  /* QUAL_INNER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier for inner VLAN priority.",
    },
    {
        .name  = QUAL_INNER_VLAN_PRI_MASKs,  /* QUAL_INNER_VLAN_PRI_MASK */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_VLAN_PRI.",
    },
    {
        .name  = QUAL_INNER_VLAN_CFIs,  /* QUAL_INNER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for inner VLAN CFI.",
    },
    {
        .name  = QUAL_INNER_VLAN_CFI_MASKs,  /* QUAL_INNER_VLAN_CFI_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_VLAN_CFI.",
    },
    {
        .name  = QUAL_SRC_MACs,  /* QUAL_SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier for source MAC address.",
    },
    {
        .name  = QUAL_SRC_MAC_MASKs,  /* QUAL_SRC_MAC_MASK */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_MAC.",
    },
    {
        .name  = QUAL_DST_MACs,  /* QUAL_DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier for destination MAC address.",
    },
    {
        .name  = QUAL_DST_MAC_MASKs,  /* QUAL_DST_MAC_MASK */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_MAC.",
    },
    {
        .name  = QUAL_SRC_IP4s,  /* QUAL_SRC_IP4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IPv4 source address.",
    },
    {
        .name  = QUAL_SRC_IP4_MASKs,  /* QUAL_SRC_IP4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_IP4.",
    },
    {
        .name  = QUAL_DST_IP4s,  /* QUAL_DST_IP4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IPv4 destination address.",
    },
    {
        .name  = QUAL_DST_IP4_MASKs,  /* QUAL_DST_IP4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP4.",
    },
    {
        .name  = QUAL_SRC_IP6_UPPERs,  /* QUAL_SRC_IP6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 source address.",
    },
    {
        .name  = QUAL_SRC_IP6_LOWERs,  /* QUAL_SRC_IP6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 source address.",
    },
    {
        .name  = QUAL_SRC_IP6_MASK_UPPERs,  /* QUAL_SRC_IP6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_IP6.",
    },
    {
        .name  = QUAL_SRC_IP6_MASK_LOWERs,  /* QUAL_SRC_IP6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_IP6.",
    },
    {
        .name  = QUAL_DST_IP6_UPPERs,  /* QUAL_DST_IP6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 destination address.",
    },
    {
        .name  = QUAL_DST_IP6_LOWERs,  /* QUAL_DST_IP6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for IPv6 destination address.",
    },
    {
        .name  = QUAL_DST_IP6_MASK_UPPERs,  /* QUAL_DST_IP6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP6.",
    },
    {
        .name  = QUAL_DST_IP6_MASK_LOWERs,  /* QUAL_DST_IP6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP6.",
    },
    {
        .name  = QUAL_INNER_DST_IP6_UPPERs,  /* QUAL_INNER_DST_IP6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for inner IPv6 destination address.",
    },
    {
        .name  = QUAL_INNER_DST_IP6_LOWERs,  /* QUAL_INNER_DST_IP6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for inner IPv6 destination address.",
    },
    {
        .name  = QUAL_INNER_DST_IP6_MASK_UPPERs,  /* QUAL_INNER_DST_IP6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_DST_IP6.",
    },
    {
        .name  = QUAL_INNER_DST_IP6_MASK_LOWERs,  /* QUAL_INNER_DST_IP6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_DST_IP6.",
    },
    {
        .name  = QUAL_ETHERTYPEs,  /* QUAL_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L2 ethertype.",
    },
    {
        .name  = QUAL_ETHERTYPE_MASKs,  /* QUAL_ETHERTYPE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_ETHERTYPE.",
    },
    {
        .name  = QUAL_L4SRC_PORTs,  /* QUAL_L4SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L4 source port.",
    },
    {
        .name  = QUAL_L4SRC_PORT_MASKs,  /* QUAL_L4SRC_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L4SRC_PORT.",
    },
    {
        .name  = QUAL_ICMP_TYPE_CODEs,  /* QUAL_ICMP_TYPE_CODE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for ICMP type code.",
    },
    {
        .name  = QUAL_ICMP_TYPE_CODE_MASKs,  /* QUAL_ICMP_TYPE_CODE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_ICMP_TYPE_CODE.",
    },
    {
        .name  = QUAL_L4DST_PORTs,  /* QUAL_L4DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L4 destination port.",
    },
    {
        .name  = QUAL_L4DST_PORT_MASKs,  /* QUAL_L4DST_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L4DST_PORT.",
    },
    {
        .name  = QUAL_MIM_ISIDs,  /* QUAL_MIM_ISID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for ISID in MiM packet header.",
    },
    {
        .name  = QUAL_MIM_ISID_MASKs,  /* QUAL_MIM_ISID_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MIM_ISID.",
    },
    {
        .name  = QUAL_NVGRE_VSIDs,  /* QUAL_NVGRE_VSID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for VPNID in NVGRE packet header.",
    },
    {
        .name  = QUAL_NVGRE_VSID_MASKs,  /* QUAL_NVGRE_VSID_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_NVGRE_VSID.",
    },
    {
        .name  = QUAL_VXLAN_VNIDs,  /* QUAL_VXLAN_VNID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for VNID in VXLAN packet header.",
    },
    {
        .name  = QUAL_VXLAN_VNID_MASKs,  /* QUAL_VXLAN_VNID_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VXLAN_VNID.",
    },
    {
        .name  = QUAL_VXLAN_FLAGSs,  /* QUAL_VXLAN_FLAGS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for flags in VXLAN packet header.",
    },
    {
        .name  = QUAL_VXLAN_FLAGS_MASKs,  /* QUAL_VXLAN_FLAGS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VXLAN_FLAGS.",
    },
    {
        .name  = QUAL_VXLAN_RSVD_24s,  /* QUAL_VXLAN_RSVD_24 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for 24 reserved bits in VXLAN.",
    },
    {
        .name  = QUAL_VXLAN_RSVD_24_MASKs,  /* QUAL_VXLAN_RSVD_24_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VXLAN_RSVD_24.",
    },
    {
        .name  = QUAL_VXLAN_RSVD_8s,  /* QUAL_VXLAN_RSVD_8 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for 8 reserved bits in VXLAN.",
    },
    {
        .name  = QUAL_VXLAN_RSVD_8_MASKs,  /* QUAL_VXLAN_RSVD_8_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VXLAN_RSVD_8.",
    },
    {
        .name  = QUAL_ETAGs,  /* QUAL_ETAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for extended port tag.",
    },
    {
        .name  = QUAL_ETAG_MASKs,  /* QUAL_ETAG_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_ETAG.",
    },
    {
        .name  = QUAL_VNTAGs,  /* QUAL_VNTAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for VN tag.",
    },
    {
        .name  = QUAL_VNTAG_MASKs,  /* QUAL_VNTAG_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VNTAG.",
    },
    {
        .name  = QUAL_CNTAGs,  /* QUAL_CNTAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for CNTAG.",
    },
    {
        .name  = QUAL_CNTAG_MASKs,  /* QUAL_CNTAG_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_CNTAG.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_IDs,  /* QUAL_MPLS_FWD_LABEL_ID */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Qualifier for MPLS forwarding label ID.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_ID_MASKs,  /* QUAL_MPLS_FWD_LABEL_ID_MASK */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MPLS_FWD_LABEL_ID.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_TTLs,  /* QUAL_MPLS_FWD_LABEL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for MPLS forwarding label TTL.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_TTL_MASKs,  /* QUAL_MPLS_FWD_LABEL_TTL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MPLS_FWD_LABEL_TTL.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_EXPs,  /* QUAL_MPLS_FWD_LABEL_EXP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for MPLS forwarding exp label.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_EXP_MASKs,  /* QUAL_MPLS_FWD_LABEL_EXP_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MPLS_FWD_LABEL_EXP.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_BOSs,  /* QUAL_MPLS_FWD_LABEL_BOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for MPLS forwarding label BOS.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_BOS_MASKs,  /* QUAL_MPLS_FWD_LABEL_BOS_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MPLS_FWD_LABEL_BOS.",
    },
    {
        .name  = QUAL_RTAG7A_HASH_LOWERs,  /* QUAL_RTAG7A_HASH_LOWER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for lower half of RTAG7 hash A result.",
    },
    {
        .name  = QUAL_RTAG7A_HASH_LOWER_MASKs,  /* QUAL_RTAG7A_HASH_LOWER_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_RTAG7A_HASH_LOWER.",
    },
    {
        .name  = QUAL_RTAG7A_HASH_UPPERs,  /* QUAL_RTAG7A_HASH_UPPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for lower half of RTAG7 hash A result.",
    },
    {
        .name  = QUAL_RTAG7A_HASH_UPPER_MASKs,  /* QUAL_RTAG7A_HASH_UPPER_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_RTAG7A_HASH_UPPER.",
    },
    {
        .name  = QUAL_RTAG7B_HASH_LOWERs,  /* QUAL_RTAG7B_HASH_LOWER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for lower half of RTAG7 hash B result.",
    },
    {
        .name  = QUAL_RTAG7B_HASH_LOWER_MASKs,  /* QUAL_RTAG7B_HASH_LOWER_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_RTAG7B_HASH_LOWER.",
    },
    {
        .name  = QUAL_RTAG7B_HASH_UPPERs,  /* QUAL_RTAG7B_HASH_UPPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for lower half of RTAG7 hash B result.",
    },
    {
        .name  = QUAL_RTAG7B_HASH_UPPER_MASKs,  /* QUAL_RTAG7B_HASH_UPPER_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_RTAG7B_HASH_UPPER.",
    },
    {
        .name  = QUAL_MPLS_CTRL_WORDs,  /* QUAL_MPLS_CTRL_WORD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for MPLS control word.",
    },
    {
        .name  = QUAL_MPLS_CTRL_WORD_MASKs,  /* QUAL_MPLS_CTRL_WORD_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MPLS_CTRL_WORD.",
    },
    {
        .name  = QUAL_IP6_FLOW_LABELs,  /* QUAL_IP6_FLOW_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Qualifier for flow label for IPv6 packet.",
    },
    {
        .name  = QUAL_IP6_FLOW_LABEL_MASKs,  /* QUAL_IP6_FLOW_LABEL_MASK */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP6_FLOW_LABEL.",
    },
    {
        .name  = QUAL_TTLs,  /* QUAL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for packet TTL.",
    },
    {
        .name  = QUAL_TTL_MASKs,  /* QUAL_TTL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TTL.",
    },
    {
        .name  = QUAL_TOSs,  /* QUAL_TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for type of service.",
    },
    {
        .name  = QUAL_TOS_MASKs,  /* QUAL_TOS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TOS.",
    },
    {
        .name  = QUAL_IP_PROTOCOLs,  /* QUAL_IP_PROTOCOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for protocol number in IPv4/IPv6 packets.",
    },
    {
        .name  = QUAL_IP_PROTOCOL_MASKs,  /* QUAL_IP_PROTOCOL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_PROTO.",
    },
    {
        .name  = QUAL_TCP_FLAGSs,  /* QUAL_TCP_FLAGS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for TCP control flags.",
    },
    {
        .name  = QUAL_TCP_FLAGS_MASKs,  /* QUAL_TCP_FLAGS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TCP_FLAGS.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_PROTOs,  /* QUAL_IP_FIRST_EH_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP first extension header protocol type.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_PROTO_MASKs,  /* QUAL_IP_FIRST_EH_PROTO_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_FIRST_EH_PROTO.",
    },
    {
        .name  = QUAL_IP_SECOND_EH_PROTOs,  /* QUAL_IP_SECOND_EH_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP second extension header protocol type.",
    },
    {
        .name  = QUAL_IP_SECOND_EH_PROTO_MASKs,  /* QUAL_IP_SECOND_EH_PROTO_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_SECOND_EH_PROTO.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_SUBCODEs,  /* QUAL_IP_FIRST_EH_SUBCODE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP first extension header subcode.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_SUBCODE_MASKs,  /* QUAL_IP_FIRST_EH_SUBCODE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_FIRST_EH_SUBCODE.",
    },
    {
        .name  = QUAL_PRE_LOGICAL_TBL_IDs,  /* QUAL_PRE_LOGICAL_TBL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for pre logical table ID.",
    },
    {
        .name  = QUAL_PRE_LOGICAL_TBL_ID_MASKs,  /* QUAL_PRE_LOGICAL_TBL_ID_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_PRE_LOGICAL_TBL_ID.",
    },
    {
        .name  = QUAL_IP_FLAGS_MFs,  /* QUAL_IP_FLAGS_MF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for more fragment flag in IP header.",
    },
    {
        .name  = QUAL_IP_FLAGS_MF_MASKs,  /* QUAL_IP_FLAGS_MF_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_FLAGS_MF.",
    },
    {
        .name  = QUAL_IP_FLAGS_DFs,  /* QUAL_IP_FLAGS_DF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for do not fragment flag in IP header.",
    },
    {
        .name  = QUAL_IP_FLAGS_DF_MASKs,  /* QUAL_IP_FLAGS_DF_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_FLAGS_DF.",
    },
    {
        .name  = QUAL_IP_FRAGs,  /* QUAL_IP_FRAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IP fragment.",
    },
    {
        .name  = QUAL_HIGIG_PKTs,  /* QUAL_HIGIG_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet received on HiGig port.",
    },
    {
        .name  = QUAL_HIGIG_PKT_MASKs,  /* QUAL_HIGIG_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_HIGIG_PKT.",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKTs,  /* QUAL_HIGIGLOOKUP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet received on HiGig port and\n lookup happened.\n",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKT_MASKs,  /* QUAL_HIGIGLOOKUP_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_HIGIGLOOKUP_PKT.",
    },
    {
        .name  = QUAL_DROP_PKTs,  /* QUAL_DROP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet is flagged to be dropped.",
    },
    {
        .name  = QUAL_DROP_PKT_MASKs,  /* QUAL_DROP_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DROP_PKT.",
    },
    {
        .name  = QUAL_VISIBILITY_PKTs,  /* QUAL_VISIBILITY_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for visibility packet(CPU masquerade packet).",
    },
    {
        .name  = QUAL_VISIBILITY_PKT_MASKs,  /* QUAL_VISIBILITY_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VISIBILITY_PKT.",
    },
    {
        .name  = QUAL_DOSATTACK_PKTs,  /* QUAL_DOSATTACK_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for DOS Attack packet.",
    },
    {
        .name  = QUAL_DOSATTACK_PKT_MASKs,  /* QUAL_DOSATTACK_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DOSATTACK_PKT.",
    },
    {
        .name  = QUAL_L4_PKTs,  /* QUAL_L4_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L4 packet (valid L4 SRC and DST port).",
    },
    {
        .name  = QUAL_L4_PKT_MASKs,  /* QUAL_L4_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L4_PKT.",
    },
    {
        .name  = QUAL_MIRROR_PKTs,  /* QUAL_MIRROR_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for mirror packet.",
    },
    {
        .name  = QUAL_MIRROR_PKT_MASKs,  /* QUAL_MIRROR_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MIRROR_PKT.",
    },
    {
        .name  = QUAL_NON_OR_FIRST_FRAGMENTs,  /* QUAL_NON_OR_FIRST_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for no fragment or first fragment packet.",
    },
    {
        .name  = QUAL_NON_OR_FIRST_FRAGMENT_MASKs,  /* QUAL_NON_OR_FIRST_FRAGMENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask for QUAL_NON_OR_FIRST_FRAGMENT.",
    },
    {
        .name  = QUAL_ICMP_ERROR_PKTs,  /* QUAL_ICMP_ERROR_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for ICMP error packet.",
    },
    {
        .name  = QUAL_ICMP_ERROR_PKT_MASKs,  /* QUAL_ICMP_ERROR_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_ICMP_ERROR_PKT.",
    },
    {
        .name  = QUAL_REPLICATION_PKTs,  /* QUAL_REPLICATION_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for replication copy of original packet.",
    },
    {
        .name  = QUAL_REPLICATION_PKT_MASKs,  /* QUAL_REPLICATION_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_REPLICATION_PKT.",
    },
    {
        .name  = QUAL_L2_SRC_HITs,  /* QUAL_L2_SRC_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for source MAC lookup hit in L2_Entry table.",
    },
    {
        .name  = QUAL_L2_SRC_HIT_MASKs,  /* QUAL_L2_SRC_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L2_SRC_HIT.",
    },
    {
        .name  = QUAL_L2_DST_HITs,  /* QUAL_L2_DST_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for destination MAC lookup hit in L2_ENTRY table.",
    },
    {
        .name  = QUAL_L2_DST_HIT_MASKs,  /* QUAL_L2_DST_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L2_DST_HIT.",
    },
    {
        .name  = QUAL_COMPRESSED_L3_SRC_HITs,  /* QUAL_COMPRESSED_L3_SRC_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for compressed source IP address hit in L3 host table.",
    },
    {
        .name  = QUAL_COMPRESSED_L3_SRC_HIT_MASKs,  /* QUAL_COMPRESSED_L3_SRC_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_COMPRESSED_L3_DST_HIT.",
    },
    {
        .name  = QUAL_COMPRESSED_L3_DST_HITs,  /* QUAL_COMPRESSED_L3_DST_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for compressed destination IP address hit in L3 host table.",
    },
    {
        .name  = QUAL_COMPRESSED_L3_DST_HIT_MASKs,  /* QUAL_COMPRESSED_L3_DST_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_COMPRESSED_L3_DST_HIT.",
    },
    {
        .name  = QUAL_L3_SRC_HOST_HITs,  /* QUAL_L3_SRC_HOST_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for source IP address hit in L3_ENTRY table.",
    },
    {
        .name  = QUAL_L3_SRC_HOST_HIT_MASKs,  /* QUAL_L3_SRC_HOST_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_SRC_HOST_HIT.",
    },
    {
        .name  = QUAL_L3_DST_HOST_HITs,  /* QUAL_L3_DST_HOST_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for destination IP address hit in L3_ENTRY table.",
    },
    {
        .name  = QUAL_L3_DST_HOST_HIT_MASKs,  /* QUAL_L3_DST_HOST_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_DST_HOST_HIT.",
    },
    {
        .name  = QUAL_L3_SRC_LPM_HITs,  /* QUAL_L3_SRC_LPM_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for source IP address hit in L3 route table.",
    },
    {
        .name  = QUAL_L3_SRC_LPM_HIT_MASKs,  /* QUAL_L3_SRC_LPM_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_SRC_LPM_HIT.",
    },
    {
        .name  = QUAL_L3_DST_LPM_HITs,  /* QUAL_L3_DST_LPM_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for destination IP address hit in L3 route table.",
    },
    {
        .name  = QUAL_L3_DST_LPM_HIT_MASKs,  /* QUAL_L3_DST_LPM_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_DST_LPM_HIT.",
    },
    {
        .name  = QUAL_L3_TNL_HITs,  /* QUAL_L3_TNL_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for IP address hit in L3 tunnel table.",
    },
    {
        .name  = QUAL_L3_TNL_HIT_MASKs,  /* QUAL_L3_TNL_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_TNL_HIT.",
    },
    {
        .name  = QUAL_VXLT_LOOKUP_HITs,  /* QUAL_VXLT_LOOKUP_HIT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for first/second/all/none lookup hit for\n VLAN translation.\n",
    },
    {
        .name  = QUAL_L2CACHE_HITs,  /* QUAL_L2CACHE_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L2 user entry lookup hit status.",
    },
    {
        .name  = QUAL_L2CACHE_HIT_MASKs,  /* QUAL_L2CACHE_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L2CACHE_HIT.",
    },
    {
        .name  = QUAL_MPLSENTRY_FIRSTLOOKUP_HITs,  /* QUAL_MPLSENTRY_FIRSTLOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for first lookup hit in MPLS_ENTRY table.",
    },
    {
        .name  = QUAL_MPLSENTRY_FIRSTLOOKUP_HIT_MASKs,  /* QUAL_MPLSENTRY_FIRSTLOOKUP_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MPLSENTRY_FIRSTLOOKUP_HIT.",
    },
    {
        .name  = QUAL_MPLSENTRY_SECONDLOOKUP_HITs,  /* QUAL_MPLSENTRY_SECONDLOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for second lookup hit in MPLS_ENTRY table.",
    },
    {
        .name  = QUAL_MPLSENTRY_SECONDLOOKUP_HIT_MASKs,  /* QUAL_MPLSENTRY_SECONDLOOKUP_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MPLSENTRY_SECONDLOOKUP_HIT.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_HITs,  /* QUAL_MYSTATIONTCAM_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for my station TCAM hit status.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_HIT_MASKs,  /* QUAL_MYSTATIONTCAM_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MYSTATIONTCAM_HIT.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_2_HITs,  /* QUAL_MYSTATIONTCAM_2_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for my station 2 TCAM hit status.",
    },
    {
        .name  = QUAL_MYSTATIONTCAM_2_HIT_MASKs,  /* QUAL_MYSTATIONTCAM_2_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MYSTATIONTCAM_2_HIT.",
    },
    {
        .name  = QUAL_L2_SRC_STATICs,  /* QUAL_L2_SRC_STATIC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L2 source is a static Entry.",
    },
    {
        .name  = QUAL_L2_SRC_STATIC_MASKs,  /* QUAL_L2_SRC_STATIC_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L2_SRC_STATIC.",
    },
    {
        .name  = QUAL_L2STATION_MOVEs,  /* QUAL_L2STATION_MOVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L2 station move status.",
    },
    {
        .name  = QUAL_L2STATION_MOVE_MASKs,  /* QUAL_L2STATION_MOVE_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L2STATION_MOVE.",
    },
    {
        .name  = QUAL_MPLS_BOS_TERMINATEDs,  /* QUAL_MPLS_BOS_TERMINATED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for BOS label terminated in MPLS packet.",
    },
    {
        .name  = QUAL_MPLS_BOS_TERMINATED_MASKs,  /* QUAL_MPLS_BOS_TERMINATED_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MPLS_BOS_TERMINATED.",
    },
    {
        .name  = QUAL_DST_IP_LOCALs,  /* QUAL_DST_IP_LOCAL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for destination IP address is local.",
    },
    {
        .name  = QUAL_DST_IP_LOCAL_MASKs,  /* QUAL_DST_IP_LOCAL_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP_LOCAL.",
    },
    {
        .name  = QUAL_L3_ROUTABLE_PKTs,  /* QUAL_L3_ROUTABLE_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet is L3 routable status.",
    },
    {
        .name  = QUAL_L3_ROUTABLE_PKT_MASKs,  /* QUAL_L3_ROUTABLE_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_ROUTABLE_PKT.",
    },
    {
        .name  = QUAL_INNER_L2_L3_ROUTABLE_PKTs,  /* QUAL_INNER_L2_L3_ROUTABLE_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet is inner L2 L3 routable status.",
    },
    {
        .name  = QUAL_INNER_L2_L3_ROUTABLE_PKT_MASKs,  /* QUAL_INNER_L2_L3_ROUTABLE_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_L2_L3_ROUTABLE_PKT.",
    },
    {
        .name  = QUAL_PORT_SYSTEM_CLASSs,  /* QUAL_PORT_SYSTEM_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for port system class ID.",
    },
    {
        .name  = QUAL_PORT_SYSTEM_CLASS_MASKs,  /* QUAL_PORT_SYSTEM_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_PORT_SYSTEM_CLASS.",
    },
    {
        .name  = QUAL_L3_IIF_CLASS_IDs,  /* QUAL_L3_IIF_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L3 ingress interface class ID.",
    },
    {
        .name  = QUAL_L3_IIF_CLASS_ID_MASKs,  /* QUAL_L3_IIF_CLASS_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_IIF_CLASS_ID.",
    },
    {
        .name  = QUAL_SVP_CLASSs,  /* QUAL_SVP_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source VP class ID.",
    },
    {
        .name  = QUAL_SVP_CLASS_MASKs,  /* QUAL_SVP_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SVP_CLASS.",
    },
    {
        .name  = QUAL_VLAN_CLASSs,  /* QUAL_VLAN_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for VLAN Clas ID.",
    },
    {
        .name  = QUAL_VLAN_CLASS_MASKs,  /* QUAL_VLAN_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VLAN_CLASS.",
    },
    {
        .name  = QUAL_FP_VLAN_CLASS0s,  /* QUAL_FP_VLAN_CLASS0 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for first VLAN FP class ID.",
    },
    {
        .name  = QUAL_FP_VLAN_CLASS0_MASKs,  /* QUAL_FP_VLAN_CLASS0_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_FP_VLAN_CLASS0.",
    },
    {
        .name  = QUAL_FP_VLAN_CLASS1s,  /* QUAL_FP_VLAN_CLASS1 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for second VLAN FP class ID.",
    },
    {
        .name  = QUAL_FP_VLAN_CLASS1_MASKs,  /* QUAL_FP_VLAN_CLASS1_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_FP_VLAN_CLASS1.",
    },
    {
        .name  = QUAL_FP_VLAN_PORT_GRPs,  /* QUAL_FP_VLAN_PORT_GRP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for VLAN FP port group ID from port.",
    },
    {
        .name  = QUAL_FP_VLAN_PORT_GRP_MASKs,  /* QUAL_FP_VLAN_PORT_GRP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_FP_VLAN_PORT_GRP.",
    },
    {
        .name  = QUAL_FP_ING_GRP_SEL_CLASSs,  /* QUAL_FP_ING_GRP_SEL_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for FP ingress FP key select class ID from port.",
    },
    {
        .name  = QUAL_FP_ING_GRP_SEL_CLASS_MASKs,  /* QUAL_FP_ING_GRP_SEL_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask ofQUAL_FP_ING_GRP_SEL_CLASS.",
    },
    {
        .name  = QUAL_UDF_CLASSs,  /* QUAL_UDF_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for UDF class ID.",
    },
    {
        .name  = QUAL_UDF_CLASS_MASKs,  /* QUAL_UDF_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_UDF_CLASS.",
    },
    {
        .name  = QUAL_L2_SRC_CLASSs,  /* QUAL_L2_SRC_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for class ID from L2 source lookup hit in L2_ENTRY.",
    },
    {
        .name  = QUAL_L2_SRC_CLASS_MASKs,  /* QUAL_L2_SRC_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L2_SRC_CLASS.",
    },
    {
        .name  = QUAL_L2_DST_CLASSs,  /* QUAL_L2_DST_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for class ID from L2 destination lookup hit in L2_ENTRY.",
    },
    {
        .name  = QUAL_L2_DST_CLASS_MASKs,  /* QUAL_L2_DST_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L2_DST_CLASS.",
    },
    {
        .name  = QUAL_L3_SRC_CLASSs,  /* QUAL_L3_SRC_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for class ID from L3 source lookup in L3 host table.",
    },
    {
        .name  = QUAL_L3_SRC_CLASS_MASKs,  /* QUAL_L3_SRC_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_SRC_CLASS.",
    },
    {
        .name  = QUAL_L3_DST_CLASSs,  /* QUAL_L3_DST_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for class ID from L3 destination lookup in\n L3 Host Table.\n",
    },
    {
        .name  = QUAL_L3_DST_CLASS_MASKs,  /* QUAL_L3_DST_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_DST_CLASS.",
    },
    {
        .name  = QUAL_PRESEL_CLASSs,  /* QUAL_PRESEL_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for presel class.",
    },
    {
        .name  = QUAL_PRESEL_CLASS_MASKs,  /* QUAL_PRESEL_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_PRESEL_CLASS.",
    },
    {
        .name  = QUAL_EM_GROUP_CLASS_ID_0s,  /* QUAL_EM_GROUP_CLASS_ID_0 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for exact match group class 0.",
    },
    {
        .name  = QUAL_EM_GROUP_CLASS_ID_0_MASKs,  /* QUAL_EM_GROUP_CLASS_ID_0_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_EM_GROUP_CLASS_ID_0.",
    },
    {
        .name  = QUAL_EM_GROUP_CLASS_ID_1s,  /* QUAL_EM_GROUP_CLASS_ID_1 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for exact match group class 1.",
    },
    {
        .name  = QUAL_EM_GROUP_CLASS_ID_1_MASKs,  /* QUAL_EM_GROUP_CLASS_ID_1_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_EM_GROUP_CLASS_ID_1.",
    },
    {
        .name  = QUAL_FWD_VLAN_VALIDs,  /* QUAL_FWD_VLAN_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if forwarding VLAN Valid.",
    },
    {
        .name  = QUAL_FWD_VLAN_VALID_MASKs,  /* QUAL_FWD_VLAN_VALID_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_FWD_VLAN_VALID.",
    },
    {
        .name  = QUAL_SRC_VP_VALIDs,  /* QUAL_SRC_VP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if source VP valid.",
    },
    {
        .name  = QUAL_SRC_VP_VALID_MASKs,  /* QUAL_SRC_VP_VALID_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_VP_VALID.",
    },
    {
        .name  = QUAL_DST_VP_VALIDs,  /* QUAL_DST_VP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if destination VP valid.",
    },
    {
        .name  = QUAL_DST_VP_VALID_MASKs,  /* QUAL_DST_VP_VALID_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_DST_VP_VALID.",
    },
    {
        .name  = QUAL_SRC_MODULEs,  /* QUAL_SRC_MODULE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source module ID (SGPP).",
    },
    {
        .name  = QUAL_SRC_MODULE_MASKs,  /* QUAL_SRC_MODULE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask for source module ID (SGPP).",
    },
    {
        .name  = QUAL_SRC_MOD_PORTs,  /* QUAL_SRC_MOD_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source module port.",
    },
    {
        .name  = QUAL_SRC_MOD_PORT_MASKs,  /* QUAL_SRC_MOD_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_MOD_PORT.",
    },
    {
        .name  = QUAL_SRC_PORTs,  /* QUAL_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source port (SGPP).",
    },
    {
        .name  = QUAL_SRC_PORT_MASKs,  /* QUAL_SRC_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_PORT.",
    },
    {
        .name  = QUAL_SRC_TRUNKs,  /* QUAL_SRC_TRUNK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source trunk (SGLP).",
    },
    {
        .name  = QUAL_SRC_TRUNK_MASKs,  /* QUAL_SRC_TRUNK_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_TRUNK.",
    },
    {
        .name  = QUAL_SRC_VPs,  /* QUAL_SRC_VP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source VP.",
    },
    {
        .name  = QUAL_SRC_VP_MASKs,  /* QUAL_SRC_VP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier of QUAL_SRC_VP.",
    },
    {
        .name  = QUAL_DST_MODULEs,  /* QUAL_DST_MODULE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for destination module ID (DGLP).",
    },
    {
        .name  = QUAL_DST_MODULE_MASKs,  /* QUAL_DST_MODULE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask for destination module ID (DGLP).",
    },
    {
        .name  = QUAL_DST_PORTs,  /* QUAL_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for destination port (DGLP).",
    },
    {
        .name  = QUAL_DST_PORT_MASKs,  /* QUAL_DST_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_PORT.",
    },
    {
        .name  = QUAL_DST_TRUNKs,  /* QUAL_DST_TRUNK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for destination LAG (DGLP )",
    },
    {
        .name  = QUAL_DST_TRUNK_MASKs,  /* QUAL_DST_TRUNK_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_TRUNK.",
    },
    {
        .name  = QUAL_DST_VP_TRUNKs,  /* QUAL_DST_VP_TRUNK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for destination LAG VP (DVPLAG )",
    },
    {
        .name  = QUAL_DST_VP_TRUNK_MASKs,  /* QUAL_DST_VP_TRUNK_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_VP_TRUNK.",
    },
    {
        .name  = QUAL_DST_VPs,  /* QUAL_DST_VP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for destination virtual port (DVP).",
    },
    {
        .name  = QUAL_DST_VP_MASKs,  /* QUAL_DST_VP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier of QUAL_DST_VP.",
    },
    {
        .name  = QUAL_OVERLAY_DST_VPs,  /* QUAL_OVERLAY_DST_VP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for overlay destination virtual port (DVP).",
    },
    {
        .name  = QUAL_OVERLAY_DST_VP_MASKs,  /* QUAL_OVERLAY_DST_VP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier of QUAL_OVERLAY_DST_VP.",
    },
    {
        .name  = QUAL_NHOPs,  /* QUAL_NHOP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for next hop.",
    },
    {
        .name  = QUAL_NHOP_MASKs,  /* QUAL_NHOP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_NHOP.",
    },
    {
        .name  = QUAL_OVERLAY_ECMPs,  /* QUAL_OVERLAY_ECMP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for overlay ECMP.",
    },
    {
        .name  = QUAL_OVERLAY_ECMP_MASKs,  /* QUAL_OVERLAY_ECMP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OVERLAY_ECMP.",
    },
    {
        .name  = QUAL_UNDERLAY_ECMPs,  /* QUAL_UNDERLAY_ECMP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for underlay ECMP.",
    },
    {
        .name  = QUAL_UNDERLAY_ECMP_MASKs,  /* QUAL_UNDERLAY_ECMP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_UNDERLAY_ECMP.",
    },
    {
        .name  = QUAL_L3_MC_GROUPs,  /* QUAL_L3_MC_GROUP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L3 IP multicast group.",
    },
    {
        .name  = QUAL_L3_MC_GROUP_MASKs,  /* QUAL_L3_MC_GROUP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_MC_GROUP.",
    },
    {
        .name  = QUAL_L2_MC_GROUPs,  /* QUAL_L2_MC_GROUP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L2 multicast group",
    },
    {
        .name  = QUAL_L2_MC_GROUP_MASKs,  /* QUAL_L2_MC_GROUP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L2_MC_GROUP.",
    },
    {
        .name  = QUAL_FWD_VLAN_IDs,  /* QUAL_FWD_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier for forwarding VLAN ID.",
    },
    {
        .name  = QUAL_FWD_VLAN_ID_MASKs,  /* QUAL_FWD_VLAN_ID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_FWD_VLAN_ID.",
    },
    {
        .name  = QUAL_VRFs,  /* QUAL_VRF */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for VRF.",
    },
    {
        .name  = QUAL_VRF_MASKs,  /* QUAL_VRF_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VRF.",
    },
    {
        .name  = QUAL_VFIs,  /* QUAL_VFI */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Qualifier for VFI.",
    },
    {
        .name  = QUAL_VFI_MASKs,  /* QUAL_VFI_MASK */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VFI.",
    },
    {
        .name  = QUAL_VPNs,  /* QUAL_VPN */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for VPN.",
    },
    {
        .name  = QUAL_VPN_MASKs,  /* QUAL_VPN_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VPN.",
    },
    {
        .name  = QUAL_L3_IIFs,  /* QUAL_L3_IIF */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L3 ingress interface.",
    },
    {
        .name  = QUAL_L3_IIF_MASKs,  /* QUAL_L3_IIF_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L3_IIF.",
    },
    {
        .name  = QUAL_INPORTs,  /* QUAL_INPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for inport.",
    },
    {
        .name  = QUAL_INPORT_MASKs,  /* QUAL_INPORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INPORT.",
    },
    {
        .name  = QUAL_INPORTSs,  /* QUAL_INPORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier for inports.",
    },
    {
        .name  = QUAL_INPORTS_MASKs,  /* QUAL_INPORTS_MASK */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier mask of QUAL_INPORTS.",
    },
    {
        .name  = QUAL_SYSTEM_PORTSs,  /* QUAL_SYSTEM_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier for system ports.",
    },
    {
        .name  = QUAL_SYSTEM_PORTS_MASKs,  /* QUAL_SYSTEM_PORTS_MASK */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier mask of QUAL_SYSTEM_PORTS.",
    },
    {
        .name  = QUAL_SVP_PORTSs,  /* QUAL_SVP_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier for source virtual ports.",
    },
    {
        .name  = QUAL_SVP_PORTS_MASKs,  /* QUAL_SVP_PORTS_MASK */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier mask of QUAL_SVP_PORTS.",
    },
    {
        .name  = QUAL_GSH_SYSTEM_DSTs,  /* QUAL_GSH_SYSTEM_DST */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for GSH system destination.",
    },
    {
        .name  = QUAL_GSH_SYSTEM_DST_MASKs,  /* QUAL_GSH_SYSTEM_DST_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_GSH_SYSTEM_DST.",
    },
    {
        .name  = QUAL_GSH_ETHERTYPE_LSB_4BITs,  /* QUAL_GSH_ETHERTYPE_LSB_4BIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for last 4 bits for GSH ether_type.\n",
    },
    {
        .name  = QUAL_GSH_ETHERTYPE_LSB_4BIT_MASKs,  /* QUAL_GSH_ETHERTYPE_LSB_4BIT_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_GSH_ETHERTYPE_LSB_4BIT.",
    },
    {
        .name  = QUAL_GSH_OPCODEs,  /* QUAL_GSH_OPCODE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for GSH opcode.\n",
    },
    {
        .name  = QUAL_GSH_OPCODE_MASKs,  /* QUAL_GSH_OPCODE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_GSH_OPCODE.",
    },
    {
        .name  = QUAL_DEVICE_PORTSs,  /* QUAL_DEVICE_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier for device ports.",
    },
    {
        .name  = QUAL_DEVICE_PORTS_MASKs,  /* QUAL_DEVICE_PORTS_MASK */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Qualifier mask of QUAL_DEVICE_PORTS.",
    },
    {
        .name  = QUAL_INT_PRIs,  /* QUAL_INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Qualifier for internal Priority of packet.",
    },
    {
        .name  = QUAL_INT_PRI_MASKs,  /* QUAL_INT_PRI_MASK */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INT_PRI.",
    },
    {
        .name  = QUAL_COLORs,  /* QUAL_COLOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for packet color.",
    },
    {
        .name  = QUAL_RAL_PRESENTs,  /* QUAL_RAL_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if RAL label present.",
    },
    {
        .name  = QUAL_RAL_PRESENT_MASKs,  /* QUAL_RAL_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_RAL_PRESENT.",
    },
    {
        .name  = QUAL_GAL_PRESENTs,  /* QUAL_GAL_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if GAL label present.",
    },
    {
        .name  = QUAL_GAL_PRESENT_MASKs,  /* QUAL_GAL_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_GAL_PRESENT.",
    },
    {
        .name  = QUAL_MPLS_CW_VALIDs,  /* QUAL_MPLS_CW_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier is MPLS psuedo wire control word valid.",
    },
    {
        .name  = QUAL_MPLS_CW_VALID_MASKs,  /* QUAL_MPLS_CW_VALID_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MPLS_CW_VALID.",
    },
    {
        .name  = QUAL_NAT_NEEDEDs,  /* QUAL_NAT_NEEDED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for NAT needed.",
    },
    {
        .name  = QUAL_NAT_NEEDED_MASKs,  /* QUAL_NAT_NEEDED_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for NAT needed.",
    },
    {
        .name  = QUAL_NAT_SRC_REALM_IDs,  /* QUAL_NAT_SRC_REALM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for NAT source realm ID from L3_IIF table.",
    },
    {
        .name  = QUAL_NAT_SRC_REALM_ID_MASKs,  /* QUAL_NAT_SRC_REALM_ID_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_NAT_SRC_REALM_ID.",
    },
    {
        .name  = QUAL_NAT_DST_REALM_IDs,  /* QUAL_NAT_DST_REALM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for NAT destination realm ID from ING_L3_NEXT_HOP table.",
    },
    {
        .name  = QUAL_NAT_DST_REALM_ID_MASKs,  /* QUAL_NAT_DST_REALM_ID_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_NAT_DST_REALM_ID.",
    },
    {
        .name  = QUAL_INT_CNs,  /* QUAL_INT_CN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for internal congestion.",
    },
    {
        .name  = QUAL_INT_CN_MASKs,  /* QUAL_INT_CN_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INT_CN.",
    },
    {
        .name  = QUAL_MACADDR_NORMALIZEs,  /* QUAL_MACADDR_NORMALIZE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for normalized L2 Fields.",
    },
    {
        .name  = QUAL_MACADDR_NORMALIZE_MASKs,  /* QUAL_MACADDR_NORMALIZE_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_MACADDR_NORMALIZE.",
    },
    {
        .name  = QUAL_IPADDR_NORMALIZEs,  /* QUAL_IPADDR_NORMALIZE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L3/L4 fields normalized.",
    },
    {
        .name  = QUAL_IPADDR_NORMALIZE_MASKs,  /* QUAL_IPADDR_NORMALIZE_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IPADDR_NORMALIZE.",
    },
    {
        .name  = QUAL_VLAN_INNER_PRESENTs,  /* QUAL_VLAN_INNER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if inner VLAN present in packet.",
    },
    {
        .name  = QUAL_VLAN_INNER_PRESENT_MASKs,  /* QUAL_VLAN_INNER_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VLAN_INNER_PRESENT.",
    },
    {
        .name  = QUAL_VLAN_OUTER_PRESENTs,  /* QUAL_VLAN_OUTER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if outer VLAN present in packet.",
    },
    {
        .name  = QUAL_VLAN_OUTER_PRESENT_MASKs,  /* QUAL_VLAN_OUTER_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_VLAN_OUTER_PRESENT.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_PRESENTs,  /* QUAL_OPAQUE_TAG_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if opaque tag present in packet.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_PRESENT_MASKs,  /* QUAL_OPAQUE_TAG_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_OPAQUE_TAG_PRESENT.",
    },
    {
        .name  = QUAL_INNER_L2_VLAN_OUTER_PRESENTs,  /* QUAL_INNER_L2_VLAN_OUTER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if inner L2 outer VLAN present in packet.",
    },
    {
        .name  = QUAL_INNER_L2_VLAN_OUTER_PRESENT_MASKs,  /* QUAL_INNER_L2_VLAN_OUTER_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_INNER_L2_VLAN_OUTER_PRESENT.",
    },
    {
        .name  = QUAL_INNER_L2_OPAQUE_TAG_PRESENTs,  /* QUAL_INNER_L2_OPAQUE_TAG_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if opaque tag present in packet.",
    },
    {
        .name  = QUAL_INNER_L2_OPAQUE_TAG_PRESENT_MASKs,  /* QUAL_INNER_L2_OPAQUE_TAG_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_INNER_L2_OPAQUE_TAG_PRESENT.",
    },
    {
        .name  = QUAL_TRANSLATED_VLAN_OUTER_PRESENTs,  /* QUAL_TRANSLATED_VLAN_OUTER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for outer VLAN tag status after VLAN\n assignment and VLAN translation.\n",
    },
    {
        .name  = QUAL_TRANSLATED_VLAN_OUTER_PRESENT_MASKs,  /* QUAL_TRANSLATED_VLAN_OUTER_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TRANSLATED_VLAN_OUTER_PRESENT.",
    },
    {
        .name  = QUAL_TRANSLATED_VLAN_INNER_PRESENTs,  /* QUAL_TRANSLATED_VLAN_INNER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for inner VLAN tag status after VLAN\n assignment and VLAN translation.\n",
    },
    {
        .name  = QUAL_TRANSLATED_VLAN_INNER_PRESENT_MASKs,  /* QUAL_TRANSLATED_VLAN_INNER_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TRANSLATED_VLAN_INNER_PRESENT.",
    },
    {
        .name  = QUAL_BYTES_0_7_AFTER_L2HEADERs,  /* QUAL_BYTES_0_7_AFTER_L2HEADER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for first 8 bytes after L2 header.",
    },
    {
        .name  = QUAL_BYTES_0_7_AFTER_L2HEADER_MASKs,  /* QUAL_BYTES_0_7_AFTER_L2HEADER_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifer mask of QUAL_FIRST_BYTES_0_7_AFTER_L2HEADER.",
    },
    {
        .name  = QUAL_BYTES_8_15_AFTER_L2HEADERs,  /* QUAL_BYTES_8_15_AFTER_L2HEADER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for bytes 8 - 15 after L2 header.",
    },
    {
        .name  = QUAL_BYTES_8_15_AFTER_L2HEADER_MASKs,  /* QUAL_BYTES_8_15_AFTER_L2HEADER_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifer mask of QUAL_BYTES_8_15_AFTER_L2HEADER.",
    },
    {
        .name  = QUAL_BYTES_16_23_AFTER_L2HEADERs,  /* QUAL_BYTES_16_23_AFTER_L2HEADER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for bytes 16 - 23 after L2 header.",
    },
    {
        .name  = QUAL_BYTES_16_23_AFTER_L2HEADER_MASKs,  /* QUAL_BYTES_16_23_AFTER_L2HEADER_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifer mask of QUAL_BYTES_16_23_AFTER_L2HEADER.",
    },
    {
        .name  = QUAL_BYTES_24_31_AFTER_L2HEADERs,  /* QUAL_BYTES_24_31_AFTER_L2HEADER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for bytes 24 - 31 after L2 header.",
    },
    {
        .name  = QUAL_BYTES_24_31_AFTER_L2HEADER_MASKs,  /* QUAL_BYTES_24_31_AFTER_L2HEADER_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifer mask of QUAL_BYTES_24_31_AFTER_L2HEADER.",
    },
    {
        .name  = QUAL_IP_CHECKSUM_VALIDs,  /* QUAL_IP_CHECKSUM_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if packet has matching IP checksum.",
    },
    {
        .name  = QUAL_IP_CHECKSUM_VALID_MASKs,  /* QUAL_IP_CHECKSUM_VALID_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_CHECKSUM_VALID.",
    },
    {
        .name  = QUAL_BFD_DISCRIMINATORs,  /* QUAL_BFD_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for BFD descriminator.",
    },
    {
        .name  = QUAL_BFD_DISCRIMINATOR_MASKs,  /* QUAL_BFD_DISCRIMINATOR_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask of QUAL_BFD_DESCRIMINATOR.",
    },
    {
        .name  = QUAL_PKT_LENGTHs,  /* QUAL_PKT_LENGTH */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for length of packet.",
    },
    {
        .name  = QUAL_PKT_LENGTH_MASKs,  /* QUAL_PKT_LENGTH_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask of QUAL_PKT_LENGTH.",
    },
    {
        .name  = QUAL_RANGE_CHECKID_BMPs,  /* QUAL_RANGE_CHECKID_BMP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for range check ID bitmap.",
    },
    {
        .name  = QUAL_RANGE_CHECKID_BMP_MASKs,  /* QUAL_RANGE_CHECKID_BMP_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask of QUAL_RANGE_CHECKID_BMP.",
    },
    {
        .name  = QUAL_RANGE_CHECK_GRP_ID_BMPs,  /* QUAL_RANGE_CHECK_GRP_ID_BMP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for range check group ID bitmap.",
    },
    {
        .name  = QUAL_RANGE_CHECK_GRP_ID_BMP_MASKs,  /* QUAL_RANGE_CHECK_GRP_ID_BMP_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask of QUAL_RANGE_CHECKID_BMP.",
    },
    {
        .name  = QUAL_MPLS_FWD_LABEL_ACTIONs,  /* QUAL_MPLS_FWD_LABEL_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for MPLS forwarding label action.",
    },
    {
        .name  = QUAL_TNL_TYPEs,  /* QUAL_TNL_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for tunnel type.",
    },
    {
        .name  = QUAL_LOOPBACK_TYPEs,  /* QUAL_LOOPBACK_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for loopback type.",
    },
    {
        .name  = QUAL_LOOPBACKs,  /* QUAL_LOOPBACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier loopback packet.",
    },
    {
        .name  = QUAL_LOOPBACK_MASKs,  /* QUAL_LOOPBACK_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_LOOPBACK.",
    },
    {
        .name  = QUAL_EM_FIRST_LOOKUP_HITs,  /* QUAL_EM_FIRST_LOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for exact match first lookup hit.",
    },
    {
        .name  = QUAL_EM_FIRST_LOOKUP_HIT_MASKs,  /* QUAL_EM_FIRST_LOOKUP_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_EM_FIRST_LOOKUP_HIT",
    },
    {
        .name  = QUAL_EM_SECOND_LOOKUP_HITs,  /* QUAL_EM_SECOND_LOOKUP_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for exact match second lookup hit.",
    },
    {
        .name  = QUAL_EM_SECOND_LOOKUP_HIT_MASKs,  /* QUAL_EM_SECOND_LOOKUP_HIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Mask of QUAL_EM_SECOND_LOOKUP_HIT.",
    },
    {
        .name  = QUAL_PKT_RESOLUTIONs,  /* QUAL_PKT_RESOLUTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for packet resolution.",
    },
    {
        .name  = QUAL_PKT_RESOLUTION_MASKs,  /* QUAL_PKT_RESOLUTION_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask of QUAL_PKT_RESOLUTION.",
    },
    {
        .name  = QUAL_EM_FIRST_LOOKUP_CLASS_IDs,  /* QUAL_EM_FIRST_LOOKUP_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for exact match first lookup class ID.",
    },
    {
        .name  = QUAL_EM_FIRST_LOOKUP_CLASS_ID_MASKs,  /* QUAL_EM_FIRST_LOOKUP_CLASS_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask of QUAL_EM_FIRST_LOOKUP_CLASS_ID.",
    },
    {
        .name  = QUAL_EM_SECOND_LOOKUP_CLASS_IDs,  /* QUAL_EM_SECOND_LOOKUP_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for exact match second lookup class ID .",
    },
    {
        .name  = QUAL_EM_SECOND_LOOKUP_CLASS_ID_MASKs,  /* QUAL_EM_SECOND_LOOKUP_CLASS_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask of QUAL_EM_SECOND_LOOKUP_CLASS_ID.",
    },
    {
        .name  = QUAL_IP_TYPEs,  /* QUAL_IP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for IP type in packet.",
    },
    {
        .name  = QUAL_L2_FORMATs,  /* QUAL_L2_FORMAT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for L2 format in packet.",
    },
    {
        .name  = QUAL_INNER_TPIDs,  /* QUAL_INNER_TPID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for inner TPID.",
    },
    {
        .name  = QUAL_OUTER_TPIDs,  /* QUAL_OUTER_TPID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for outer TPID.",
    },
    {
        .name  = QUAL_INNER_L2_OUTER_TPIDs,  /* QUAL_INNER_L2_OUTER_TPID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for inner L2 outer TPID.",
    },
    {
        .name  = QUAL_FWD_TYPEs,  /* QUAL_FWD_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for forwarding type.",
    },
    {
        .name  = QUAL_ING_STP_STATEs,  /* QUAL_ING_STP_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier enum for ingress STP state.",
    },
    {
        .name  = QUAL_UDF_CHUNKSs,  /* QUAL_UDF_CHUNKS */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "Qualifier array for UDF chunk.",
    },
    {
        .name  = QUAL_UDF_CHUNKS_MASKs,  /* QUAL_UDF_CHUNKS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "Qualifier mask of QUAL_UDF_CHUNKS.",
    },
    {
        .name  = QUAL_C_L4SRC_PORTs,  /* QUAL_C_L4SRC_PORT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed L4 source port.",
    },
    {
        .name  = QUAL_C_L4SRC_PORT_MASKs,  /* QUAL_C_L4SRC_PORT_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_L4SRC_PORT.",
    },
    {
        .name  = QUAL_C_L4DST_PORTs,  /* QUAL_C_L4DST_PORT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed L4 destination port.",
    },
    {
        .name  = QUAL_C_L4DST_PORT_MASKs,  /* QUAL_C_L4DST_PORT_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_L4DST_PORT.",
    },
    {
        .name  = QUAL_C_SRC_IPs,  /* QUAL_C_SRC_IP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for compressed IP source address.",
    },
    {
        .name  = QUAL_C_SRC_IP_MASKs,  /* QUAL_C_SRC_IP_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_SRC_IP.",
    },
    {
        .name  = QUAL_C_DST_IPs,  /* QUAL_C_DST_IP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for compressed IP destination Adrress.",
    },
    {
        .name  = QUAL_C_DST_IP_MASKs,  /* QUAL_C_DST_IP_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_DST_IP.",
    },
    {
        .name  = QUAL_C_IP_PROTOCOLs,  /* QUAL_C_IP_PROTOCOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed IP protocol.",
    },
    {
        .name  = QUAL_C_IP_PROTOCOL_MASKs,  /* QUAL_C_IP_PROTOCOL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_IP_PROTOCOL.",
    },
    {
        .name  = QUAL_C_ETHERTYPEs,  /* QUAL_C_ETHERTYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed ethertype.",
    },
    {
        .name  = QUAL_C_ETHERTYPE_MASKs,  /* QUAL_C_ETHERTYPE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_ETHERTYPE.",
    },
    {
        .name  = QUAL_C_TTL0s,  /* QUAL_C_TTL0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed or remapped first TTL\n Original packet TTL can be mapped to 2 different values\n This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TTL0_MASKs,  /* QUAL_C_TTL0_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_TTL0.",
    },
    {
        .name  = QUAL_C_TTL1s,  /* QUAL_C_TTL1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed or remapped second TTL\n Original packet TTL can be mapped to 2 different values\n This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_C_TTL1_MASKs,  /* QUAL_C_TTL1_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_TTL1.",
    },
    {
        .name  = QUAL_C_TOS0s,  /* QUAL_C_TOS0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed or remapped first TOS\n Original packet TOS can be mapped to 2 different values\n This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TOS0_MASKs,  /* QUAL_C_TOS0_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_TOS0.",
    },
    {
        .name  = QUAL_C_TOS1s,  /* QUAL_C_TOS1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed or remapped second TOS\n Original packet TOS can be mapped to 2 different values\n This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_C_TOS1_MASKs,  /* QUAL_C_TOS1_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_TOS1.",
    },
    {
        .name  = QUAL_C_TCP_FLAGS0s,  /* QUAL_C_TCP_FLAGS0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed/remapped first TCP control flags\n Original packet TCP control flags can be mapped to 2 different\n values. This field represents first mapped value.\n",
    },
    {
        .name  = QUAL_C_TCP_FLAGS0_MASKs,  /* QUAL_C_TCP_FLAGS0_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_TCP_FLAGS0.",
    },
    {
        .name  = QUAL_C_TCP_FLAGS1s,  /* QUAL_C_TCP_FLAGS1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed/remapped second TCP control flags\n Original packet TCP control flags can be mapped to 2 different\n values. This field represents second mapped value.\n",
    },
    {
        .name  = QUAL_C_TCP_FLAGS1_MASKs,  /* QUAL_C_TCP_FLAGS1_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_TCP_FLAGS1.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_LOWs,  /* QUAL_OPAQUE_TAG_LOW */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Lower 32 bits of opaque tag.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_LOW_MASKs,  /* QUAL_OPAQUE_TAG_LOW_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OPAQUE_TAG_LOW.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_HIGHs,  /* QUAL_OPAQUE_TAG_HIGH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Upper 32 bits of opaque tag.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_HIGH_MASKs,  /* QUAL_OPAQUE_TAG_HIGH_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OPAQUE_TAG_HIGH.",
    },
    {
        .name  = QUAL_INNER_L2_OPAQUE_TAGs,  /* QUAL_INNER_L2_OPAQUE_TAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for inner L2 opaque tag.",
    },
    {
        .name  = QUAL_INNER_L2_OPAQUE_TAG_MASKs,  /* QUAL_INNER_L2_OPAQUE_TAG_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_L2_OPAQUE_TAG.",
    },
    {
        .name  = QUAL_TNL_IP_TTLs,  /* QUAL_TNL_IP_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP tunnel TTL.\n",
    },
    {
        .name  = QUAL_TNL_IP_TTL_MASKs,  /* QUAL_TNL_IP_TTL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_TNL_IP_TTL.",
    },
    {
        .name  = QUAL_C_TNL_IP_TTLs,  /* QUAL_C_TNL_IP_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for compressed or remapped IP tunnel TTL.\n The outer TTL in the terminated tunnel can be mapped to\n a compressed value represented by this field.\n",
    },
    {
        .name  = QUAL_C_TNL_IP_TTL_MASKs,  /* QUAL_C_TNL_IP_TTL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_C_TNL_IP_TTL.",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_FLAGSs,  /* QUAL_INBAND_TELEMETRY_FLAGS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifiers bitmap for the inband network telemetry flag fields from\n the INT/IOAM/IFA header.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_FLAGS_MASKs,  /* QUAL_INBAND_TELEMETRY_FLAGS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INBAND_TELEMETRY_FLAGS.",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_MD_HDR_TYPEs,  /* QUAL_INBAND_TELEMETRY_MD_HDR_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for incoming inband network telemetry MD header type.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_MD_HDR_TYPE_MASKs,  /* QUAL_INBAND_TELEMETRY_MD_HDR_TYPE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INBAND_TELEMETRY_MD_HDR_TYPE.",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HOP_LIMIT_CHECK_STATUSs,  /* QUAL_INBAND_TELEMETRY_HOP_LIMIT_CHECK_STATUS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for inband network telemetry hop limit check status.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HOP_LIMIT_CHECK_STATUS_MASKs,  /* QUAL_INBAND_TELEMETRY_HOP_LIMIT_CHECK_STATUS_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INBAND_TELEMETRY_HOP_LIMIT_CHECK_STATUS.",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_MAX_LENGTH_CHECKs,  /* QUAL_INBAND_TELEMETRY_MAX_LENGTH_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for inband network telemetry max length check status.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_MAX_LENGTH_CHECK_MASKs,  /* QUAL_INBAND_TELEMETRY_MAX_LENGTH_CHECK_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INBAND_TELEMETRY_MAX_LENGTH_CHECK.",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HDR_TYPEs,  /* QUAL_INBAND_TELEMETRY_HDR_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for incoming inband network telemetry header type.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HDR_TYPE_MASKs,  /* QUAL_INBAND_TELEMETRY_HDR_TYPE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INBAND_TELEMETRY_HDR_TYPE.",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_UDP_CHECKSUM_ZEROs,  /* QUAL_INBAND_TELEMETRY_UDP_CHECKSUM_ZERO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for inband network telemetry UDP checksum zero check.\n",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_UDP_CHECKSUM_ZERO_MASKs,  /* QUAL_INBAND_TELEMETRY_UDP_CHECKSUM_ZERO_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INBAND_TELEMETRY_UDP_CHECKSUM_ZERO.",
    },
    {
        .name  = QUAL_MH_OPCODEs,  /* QUAL_MH_OPCODE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for module header opcode.",
    },
    {
        .name  = QUAL_MH_OPCODE_MASKs,  /* QUAL_MH_OPCODE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask for module header opcode.",
    },
    {
        .name  = QUAL_PROTECTION_DATA_DROPs,  /* QUAL_PROTECTION_DATA_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for protection data drop packet.",
    },
    {
        .name  = QUAL_PROTECTION_DATA_DROP_MASKs,  /* QUAL_PROTECTION_DATA_DROP_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_PROTECTION_DATA_DROP.",
    },
    {
        .name  = QUAL_DCN_PKTs,  /* QUAL_DCN_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for drop congestion notification packet.",
    },
    {
        .name  = QUAL_DCN_PKT_MASKs,  /* QUAL_DCN_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DCN_PKT.",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HDR_IN_TNLs,  /* QUAL_INBAND_TELEMETRY_HDR_IN_TNL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for inband network telemetry header in tunnel.",
    },
    {
        .name  = QUAL_INBAND_TELEMETRY_HDR_IN_TNL_MASKs,  /* QUAL_INBAND_TELEMETRY_HDR_IN_TNL_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask for QUAL_INBAND_TELEMETRY_IN_TNL.",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_RAL_DETECTEDs,  /* QUAL_MPLS_SPECIAL_LABEL_RAL_DETECTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for MPLS RAL detected.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_RAL_DETECTED_MASKs,  /* QUAL_MPLS_SPECIAL_LABEL_RAL_DETECTED_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask for MPLS RAL detected.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_GAL_DETECTEDs,  /* QUAL_MPLS_SPECIAL_LABEL_GAL_DETECTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for MPLS GAL detected.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_GAL_DETECTED_MASKs,  /* QUAL_MPLS_SPECIAL_LABEL_GAL_DETECTED_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask for MPLS GAL detected.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_CW_DETECTEDs,  /* QUAL_MPLS_SPECIAL_LABEL_CW_DETECTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for MPLS CW detected.\n",
    },
    {
        .name  = QUAL_MPLS_SPECIAL_LABEL_CW_DETECTED_MASKs,  /* QUAL_MPLS_SPECIAL_LABEL_CW_DETECTED_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask for MPLS CW detected.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_A_0_15s,  /* QUAL_L3_L4_COMPRESSION_ID_A_0_15 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for l3 l4 compression ID first 2 bytes in part A.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_A_0_15_MASKs,  /* QUAL_L3_L4_COMPRESSION_ID_A_0_15_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask for l3 l4 compression ID first 2 bytes in part A.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_A_31_16s,  /* QUAL_L3_L4_COMPRESSION_ID_A_31_16 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for l3 l4 compression ID next 2 bytes in part A.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_A_31_16_MASKs,  /* QUAL_L3_L4_COMPRESSION_ID_A_31_16_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask for l3 l4 compression ID next 2 bytes in part A.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_B_0_15s,  /* QUAL_L3_L4_COMPRESSION_ID_B_0_15 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for l3 l4 compression ID first 2 bytes in part B.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_B_0_15_MASKs,  /* QUAL_L3_L4_COMPRESSION_ID_B_0_15_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask for l3 l4 compression ID first 2 bytes in part B.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_B_31_16s,  /* QUAL_L3_L4_COMPRESSION_ID_B_31_16 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for l3 l4 compression ID next 2 bytes in part B.\n",
    },
    {
        .name  = QUAL_L3_L4_COMPRESSION_ID_B_31_16_MASKs,  /* QUAL_L3_L4_COMPRESSION_ID_B_31_16_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask for l3 l4 compression ID next 2 bytes in part B.\n",
    },
    {
        .name  = QUAL_RH_FIRST_4_BYTESs,  /* QUAL_RH_FIRST_4_BYTES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for first 4 bytes of IPv6 routing ext header.\n",
    },
    {
        .name  = QUAL_RH_FIRST_4_BYTES_MASKs,  /* QUAL_RH_FIRST_4_BYTES_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask for first 4 bytes of IPv6 routing ext header.\n",
    },
    {
        .name  = QUAL_RH_NEXT_4_BYTESs,  /* QUAL_RH_NEXT_4_BYTES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for next 4 bytes of IPv6 routing ext header.\n",
    },
    {
        .name  = QUAL_RH_NEXT_4_BYTES_MASKs,  /* QUAL_RH_NEXT_4_BYTES_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask for next 4 bytes of IPv6 routing ext header.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_rule_template_t = {
    .name = FP_ING_RULE_TEMPLATEs, /* FP_ING_RULE_TEMPLATE */
    .flags = 0,
    .fields = 408,
    .field = bcmltd_fp_ing_rule_template_t_fields,
    .desc = "The FP_ING_RULE_TEMPLATE table specifies the ingress FP rule that can be\n attached to an ingress FP entry.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_SLICE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_slice_info_t_fields[] = {
    {
        .name  = FP_ING_SLICE_IDs,  /* FP_ING_SLICE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP slice ID.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = ENTRY_INUSE_CNTs,  /* ENTRY_INUSE_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries created.",
    },
    {
        .name  = ENTRY_MAXIMUMs,  /* ENTRY_MAXIMUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of entries.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_slice_info_t = {
    .name = FP_ING_SLICE_INFOs, /* FP_ING_SLICE_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_ing_slice_info_t_fields,
    .desc = "The FP_ING_SLICE_INFO table provides ingress FP slice-specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_ING_SRC_CLASS_MODE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_ing_src_class_mode_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe ID",
    },
    {
        .name  = SRC_CLASS_MODEs,  /* SRC_CLASS_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "This field configure mode for Class IDs input to preselection.\n It is a 2 bit field in IFP_LOGICAL_TABLE_CONFIG_SELECT\n register.\n MODE = LEGACY for Legacy XGS style devices.\n MODE = SDN for SDN deployments.\n MODE = BALANCED for balanced.\n MODE = OVERLAY for overlay networks.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_ing_src_class_mode_t = {
    .name = FP_ING_SRC_CLASS_MODEs, /* FP_ING_SRC_CLASS_MODE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_fp_ing_src_class_mode_t_fields,
    .desc = "The FP_ING_SRC_CLASS_MODE specifies the mixed source class mode for the\n ingress FP stage. Different modes supported in this table are mutually\n exclusive to each other.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_VLAN_ENTRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_vlan_entry_t_fields[] = {
    {
        .name  = FP_VLAN_ENTRY_IDs,  /* FP_VLAN_ENTRY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "VLAN FP entry identifier.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operational state of the entry.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Priority associated with entry.",
    },
    {
        .name  = FP_VLAN_GRP_TEMPLATE_IDs,  /* FP_VLAN_GRP_TEMPLATE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Associated group ID from FP_VLAN_GROUP_TEMPLATE LT.",
    },
    {
        .name  = FP_VLAN_RULE_TEMPLATE_IDs,  /* FP_VLAN_RULE_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated rule ID from FP_VLAN_RULE_TEMPLATE LT.",
    },
    {
        .name  = FP_VLAN_POLICY_TEMPLATE_IDs,  /* FP_VLAN_POLICY_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated policy ID from FP_VLAN_POLICY_TEMPLATE LT.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated flex counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Associated flex counter offset mode.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Associated flex counter pool ID.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_fp_vlan_entry_t = {
    .name = FP_VLAN_ENTRYs, /* FP_VLAN_ENTRY */
    .flags = 0,
    .fields = 11,
    .field = bcmltd_fp_vlan_entry_t_fields,
    .desc = "The FP_VLAN_ENTRY associates group ID, rule ID, action ID, counter ID and\n meter ID to the entries in the group. Operations on this logical table will\n provision the device VFP logic, if sufficient resources are available.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_VLAN_GRP_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_vlan_grp_template_t_fields[] = {
    {
        .name  = FP_VLAN_GRP_TEMPLATE_IDs,  /* FP_VLAN_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VLAN FP group identifier.",
    },
    {
        .name  = MODE_OPERs,  /* MODE_OPER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational group mode.\n If MODE_AUTO is enabled, then the MODE_OPER field will updated with\n the mode assigned to the group by the SDK.\n If MODE_AUTO is disabled and if the group fits in the mode specified\n in the MODE field, then the MODE field will be assigned to the\n MODE_OPER field.\n",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Group priority. Groups with same priority will share the same\n physical resources(VLAN FP slices) if enough free entries is\n available to accommodate all groups with that priority.\n",
    },
    {
        .name  = AUTO_EXPANDs,  /* AUTO_EXPAND */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to disable auto expansion of the group.\n",
    },
    {
        .name  = MODE_AUTOs,  /* MODE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to auto calculate the group mode and ignore the user specified\n mode in MODE field in this table.\n",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Configurable group mode.\n    SINGLE     : Single wide mode\n    DBLINTRA   : Double wide intra-slice mode\n    DBLINTER   : Double wide inter-slice mode\n    QUAD       : Quad wide mode\n Applicable only if MODE_AUTO is disabled.\n",
    },
    {
        .name  = VIRTUAL_SLICE_GRPs,  /* VIRTUAL_SLICE_GRP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Virtual slice group.\n Field groups created with same virtual slice group\n will be under one virtual group set.\n Policy resolution among groups in a virtual group set\n will result in policy (actions and counter) belonging to\n higher priority group in the virtual group set.\n Policy resolution among different virtual group sets\n will result in combined counter, non-conflicting actions\n from all virtual group sets and for conflicting actions group\n with the highest priority will take precedence across\n all such virtual group sets.\n Allowed values [0 to number of slices-1].\n",
    },
    {
        .name  = QUAL_VLAN_OUTER_PRESENTs,  /* QUAL_VLAN_OUTER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet outer VLAN tag status.",
    },
    {
        .name  = QUAL_OUTER_VLAN_IDs,  /* QUAL_OUTER_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = QUAL_OUTER_VLAN_CFIs,  /* QUAL_OUTER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = QUAL_OUTER_VLAN_PRIs,  /* QUAL_OUTER_VLAN_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN priority.",
    },
    {
        .name  = QUAL_VLAN_INNER_PRESENTs,  /* QUAL_VLAN_INNER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet inner VLAN tag status.",
    },
    {
        .name  = QUAL_INNER_VLAN_IDs,  /* QUAL_INNER_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = QUAL_INNER_VLAN_CFIs,  /* QUAL_INNER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = QUAL_INNER_VLAN_PRIs,  /* QUAL_INNER_VLAN_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN priority.",
    },
    {
        .name  = QUAL_INNER_IP_PROTO_COMMONs,  /* QUAL_INNER_IP_PROTO_COMMON */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner IP protocol common field.",
    },
    {
        .name  = QUAL_IP_PROTO_COMMONs,  /* QUAL_IP_PROTO_COMMON */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Common IP protocols.",
    },
    {
        .name  = QUAL_TNL_TERMINATEDs,  /* QUAL_TNL_TERMINATED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Tunnel terminated traffic.",
    },
    {
        .name  = QUAL_IP_CHECKSUM_VALIDs,  /* QUAL_IP_CHECKSUM_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet has matching IP checksum.",
    },
    {
        .name  = QUAL_INNER_TPIDs,  /* QUAL_INNER_TPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner TPID of the packet.",
    },
    {
        .name  = QUAL_OUTER_TPIDs,  /* QUAL_OUTER_TPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer TPID of the packet",
    },
    {
        .name  = QUAL_L2_FORMATs,  /* QUAL_L2_FORMAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "L2 packet format",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKTs,  /* QUAL_HIGIGLOOKUP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet is received on HiGiG port and Table lookup happened.",
    },
    {
        .name  = QUAL_HIGIG_PKTs,  /* QUAL_HIGIG_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet Received on HiGiG port.",
    },
    {
        .name  = QUAL_INNER_IP_TYPEs,  /* QUAL_INNER_IP_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner IP header IP type.",
    },
    {
        .name  = QUAL_IP_TYPEs,  /* QUAL_IP_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IP type.",
    },
    {
        .name  = QUAL_SRC_TRUNKs,  /* QUAL_SRC_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "SGLP - source Trunk Group ID.",
    },
    {
        .name  = QUAL_SRC_VPs,  /* QUAL_SRC_VP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Source VP.",
    },
    {
        .name  = QUAL_SRC_PORTs,  /* QUAL_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Source port.",
    },
    {
        .name  = QUAL_SRC_MODULEs,  /* QUAL_SRC_MODULE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Source Module.",
    },
    {
        .name  = QUAL_INPORTs,  /* QUAL_INPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Single Input port.",
    },
    {
        .name  = QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASSs,  /* QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Class ID from PORT_FP (PORT_FP.USE_TABLE_FP_VLAN_PORT_GRP = 1) or\n PORT_SYSTEM (PORT_FP.USE_TABLE_FP_VLAN_PORT_GRP = 0).\n",
    },
    {
        .name  = QUAL_L4_PKTs,  /* QUAL_L4_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "L4 packet (has Valid L4 source and destination port).",
    },
    {
        .name  = QUAL_INNER_TTLs,  /* QUAL_INNER_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner packet TTL.",
    },
    {
        .name  = QUAL_TTLs,  /* QUAL_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet TTL.",
    },
    {
        .name  = QUAL_TCP_FLAGSs,  /* QUAL_TCP_FLAGS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "TCP control flags.",
    },
    {
        .name  = QUAL_INNER_IP_FRAGs,  /* QUAL_INNER_IP_FRAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on inner IP fragment flag in IP header as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_IP_FRAGs,  /* QUAL_IP_FRAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match on IP fragment flag in IP header as specified in\n rule template entries that are associated with FP entries which\n reference this group template.\n",
    },
    {
        .name  = QUAL_INNER_TOSs,  /* QUAL_INNER_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner packet TOS.",
    },
    {
        .name  = QUAL_TOSs,  /* QUAL_TOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet TOS.",
    },
    {
        .name  = QUAL_INNER_L4DST_PORTs,  /* QUAL_INNER_L4DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner L4 header destination port.",
    },
    {
        .name  = QUAL_L4DST_PORTs,  /* QUAL_L4DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "L4 header destination port.",
    },
    {
        .name  = QUAL_INNER_L4SRC_PORTs,  /* QUAL_INNER_L4SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner L4 header source port.",
    },
    {
        .name  = QUAL_L4SRC_PORTs,  /* QUAL_L4SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "L4 header source port.",
    },
    {
        .name  = QUAL_ICMP_TYPE_CODEs,  /* QUAL_ICMP_TYPE_CODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "ICMP type code.",
    },
    {
        .name  = QUAL_INNER_IP_PROTOCOLs,  /* QUAL_INNER_IP_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IP protocol field.",
    },
    {
        .name  = QUAL_IP_PROTOCOLs,  /* QUAL_IP_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IP protocol.",
    },
    {
        .name  = QUAL_INNER_DST_IP4s,  /* QUAL_INNER_DST_IP4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner destination IPv4 address.",
    },
    {
        .name  = QUAL_DST_IP4s,  /* QUAL_DST_IP4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = QUAL_INNER_SRC_IP4s,  /* QUAL_INNER_SRC_IP4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner source IPv4 address.",
    },
    {
        .name  = QUAL_SRC_IP4s,  /* QUAL_SRC_IP4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = QUAL_INNER_SRC_IP6s,  /* QUAL_INNER_SRC_IP6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner ip header source IPv6 address.",
    },
    {
        .name  = QUAL_SRC_IP6s,  /* QUAL_SRC_IP6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = QUAL_INNER_DST_IP6s,  /* QUAL_INNER_DST_IP6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner ip header destination IPv6 address.",
    },
    {
        .name  = QUAL_DST_IP6s,  /* QUAL_DST_IP6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Destination IPV6 address.",
    },
    {
        .name  = QUAL_ETHERTYPEs,  /* QUAL_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = QUAL_SRC_MACs,  /* QUAL_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = QUAL_DST_MACs,  /* QUAL_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = QUAL_INNER_SRC_IP6_HIGHs,  /* QUAL_INNER_SRC_IP6_HIGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner IP header source IPv6 address (High/Upper 64 bits).",
    },
    {
        .name  = QUAL_SRC_IP6_HIGHs,  /* QUAL_SRC_IP6_HIGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Source IPv6 address (High/Upper 64 bits).",
    },
    {
        .name  = QUAL_INNER_DST_IP6_HIGHs,  /* QUAL_INNER_DST_IP6_HIGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner IP header destination IPv6 address (High/Upper 64 bits).",
    },
    {
        .name  = QUAL_DST_IP6_HIGHs,  /* QUAL_DST_IP6_HIGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Destination IPv6 address (High/Upper 64 bits).",
    },
    {
        .name  = QUAL_VNTAGs,  /* QUAL_VNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "NIV VN tag (Network interface virtualization virtual network tag).",
    },
    {
        .name  = QUAL_SNAP_HEADERs,  /* QUAL_SNAP_HEADER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Sub-Network attachment point header (SNAP header).",
    },
    {
        .name  = QUAL_LLC_HEADERs,  /* QUAL_LLC_HEADER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Logical link control header.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_SUBCODEs,  /* QUAL_IP_FIRST_EH_SUBCODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "First byte after the extension header length field.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_PROTOs,  /* QUAL_IP_FIRST_EH_PROTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Next header field in first header extension header.",
    },
    {
        .name  = QUAL_TNL_CLASS_IDs,  /* QUAL_TNL_CLASS_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Tunnel class ID.",
    },
    {
        .name  = QUAL_UDF_CHUNKSs,  /* QUAL_UDF_CHUNKS */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "Bitmap for UDF Chunks qualifiers.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_TYPEs,  /* QUAL_OPAQUE_TAG_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to match on the tag type configured for opaque\n tags. This tag type is the value configured in the TAG_TYPE\n field in the L2_OPAQUE_TAG table.\n",
    },
    {
        .name  = QUAL_OPAQUE_TAG_PRESENTs,  /* QUAL_OPAQUE_TAG_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Packet opaque tag status.",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable the entry",
    },
};
const bcmltd_table_rep_t bcmltd_fp_vlan_grp_template_t = {
    .name = FP_VLAN_GRP_TEMPLATEs, /* FP_VLAN_GRP_TEMPLATE */
    .flags = 0,
    .fields = 73,
    .field = bcmltd_fp_vlan_grp_template_t_fields,
    .desc = "The FP_VLAN_GRP_TEMPLATE table specifies groups\n in the VLAN field processor stage.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_VLAN_GRP_TEMPLATE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_vlan_grp_template_info_t_fields[] = {
    {
        .name  = FP_VLAN_GRP_TEMPLATE_IDs,  /* FP_VLAN_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Vlan FP group template ID.",
    },
    {
        .name  = HW_LTIDs,  /* HW_LTID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hardware logical table ID used in action resolution or partition\n resolution in case of group auto expansion. This logical table ID is\n different from the SDKLT logical table ID. Priority can be assigned to\n the hardware logical table ID and is used to resolve conflicting\n actions when a packet matches FP entries from two different FP groups.\n",
    },
    {
        .name  = NUM_ENTRIES_CREATEDs,  /* NUM_ENTRIES_CREATED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries created in this group.",
    },
    {
        .name  = NUM_ENTRIES_TENTATIVEs,  /* NUM_ENTRIES_TENTATIVE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries that can be created in this group.",
    },
    {
        .name  = NUM_PARTITION_IDs,  /* NUM_PARTITION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of partitions(a.k.a physical slices) used for groups width\n expansion.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_vlan_grp_template_info_t = {
    .name = FP_VLAN_GRP_TEMPLATE_INFOs, /* FP_VLAN_GRP_TEMPLATE_INFO */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_vlan_grp_template_info_t_fields,
    .desc = "The FP_VLAN_GRP_TEMPLATE_INFO table provides FP group-specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_VLAN_GRP_TEMPLATE_PARTITION_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_vlan_grp_template_partition_info_t_fields[] = {
    {
        .name  = FP_VLAN_GRP_TEMPLATE_IDs,  /* FP_VLAN_GRP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Ingress FP group template ID.",
    },
    {
        .name  = PARTITION_IDs,  /* PARTITION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Partition ID.",
    },
    {
        .name  = NUM_SLICE_IDs,  /* NUM_SLICE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of slices to which a group is auto expanded.\n This field specifies\n the number of valid indexes in the SLICE_ID arrays of partitions.\n",
    },
    {
        .name  = SLICE_IDs,  /* SLICE_ID */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Physical slice IDs allocated for the group in the order of expansion\n in the given partition ID.\n",
    },
    {
        .name  = VIRTUAL_SLICE_IDs,  /* VIRTUAL_SLICE_ID */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "Virtual slice IDs allocated for the group in the order of expansion\n in the given partition ID.\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_vlan_grp_template_partition_info_t = {
    .name = FP_VLAN_GRP_TEMPLATE_PARTITION_INFOs, /* FP_VLAN_GRP_TEMPLATE_PARTITION_INFO */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_fp_vlan_grp_template_partition_info_t_fields,
    .desc = "The FP_VLAN_GRP_TEMPLATE_PARTITION_INFO table provides\n FP group partition specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_VLAN_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_vlan_info_t_fields[] = {
    {
        .name  = NUM_SLICESs,  /* NUM_SLICES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of slices.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_vlan_info_t = {
    .name = FP_VLAN_INFOs, /* FP_VLAN_INFO */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_fp_vlan_info_t_fields,
    .desc = "The FP_VLAN_INFO table provides vlan FP stage-specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_VLAN_POLICY_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_vlan_policy_template_t_fields[] = {
    {
        .name  = FP_VLAN_POLICY_TEMPLATE_IDs,  /* FP_VLAN_POLICY_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "VLAN FP policy identifier.",
    },
    {
        .name  = ACTION_DROPs,  /* ACTION_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Drop packets.",
    },
    {
        .name  = ACTION_DROP_CANCELs,  /* ACTION_DROP_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel lower priority drop action.",
    },
    {
        .name  = ACTION_COPY_TO_CPUs,  /* ACTION_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy to CPU.",
    },
    {
        .name  = ACTION_COPY_TO_CPU_CANCELs,  /* ACTION_COPY_TO_CPU_CANCEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Cancel lower priority copy to CPU action.",
    },
    {
        .name  = ACTION_NEW_OUTER_DOT1Ps,  /* ACTION_NEW_OUTER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Change outer dot1p priority to new value.",
    },
    {
        .name  = ACTION_ADD_INNER_TAGs,  /* ACTION_ADD_INNER_TAG */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Add a new inner VLAN tag.",
    },
    {
        .name  = ACTION_REPLACE_INNER_TAGs,  /* ACTION_REPLACE_INNER_TAG */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Replace inner VLAN tag.",
    },
    {
        .name  = ACTION_DELETE_INNER_TAGs,  /* ACTION_DELETE_INNER_TAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Delete inner VLAN tag.",
    },
    {
        .name  = ACTION_ADD_OUTER_TAGs,  /* ACTION_ADD_OUTER_TAG */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Add outer VLAN tag.",
    },
    {
        .name  = ACTION_REPLACE_OUTER_TAGs,  /* ACTION_REPLACE_OUTER_TAG */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Replace outer VLAN tag.",
    },
    {
        .name  = ACTION_SET_FWD_VLAN_TAGs,  /* ACTION_SET_FWD_VLAN_TAG */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Set forwarding VLAN tag.",
    },
    {
        .name  = ACTION_NEW_CPU_COSs,  /* ACTION_NEW_CPU_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Change COS queue when copy to CPU.",
    },
    {
        .name  = ACTION_NEW_INTPRIs,  /* ACTION_NEW_INTPRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Change internal priority.",
    },
    {
        .name  = ACTION_NEW_COLORs,  /* ACTION_NEW_COLOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Change color of packets.",
    },
    {
        .name  = ACTION_DO_NOT_LEARNs,  /* ACTION_DO_NOT_LEARN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable L2 learning.",
    },
    {
        .name  = ACTION_DISABLE_VLAN_CHECKs,  /* ACTION_DISABLE_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not check VLAN membership and STG STP state.",
    },
    {
        .name  = ACTION_ENABLE_VLAN_CHECKs,  /* ACTION_ENABLE_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Check VLAN membership and STG STP state.",
    },
    {
        .name  = ACTION_VLAN_CLASS_0s,  /* ACTION_VLAN_CLASS_0 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Set lower class ID.",
    },
    {
        .name  = ACTION_VLAN_CLASS_1s,  /* ACTION_VLAN_CLASS_1 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Set upper class ID.",
    },
    {
        .name  = ACTION_NEW_SVPs,  /* ACTION_NEW_SVP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "SVP set.",
    },
    {
        .name  = ACTION_INNER_DOT1P_TO_OUTER_DOT1Ps,  /* ACTION_INNER_DOT1P_TO_OUTER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy inner dot1p to outer dot1p.",
    },
    {
        .name  = ACTION_NEW_INNER_DOT1Ps,  /* ACTION_NEW_INNER_DOT1P */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = ACTION_OUTER_DOT1P_TO_INNER_DOT1Ps,  /* ACTION_OUTER_DOT1P_TO_INNER_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy outer dot1p to inner dot1p.",
    },
    {
        .name  = ACTION_NEW_VRFs,  /* ACTION_NEW_VRF */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "VRF set.",
    },
    {
        .name  = ACTION_NEW_VFIs,  /* ACTION_NEW_VFI */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Set VFI based on port.",
    },
    {
        .name  = ACTION_NEW_OUTER_CFIs,  /* ACTION_NEW_OUTER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Replace packet outer 802.1p CFI with a new one.",
    },
    {
        .name  = ACTION_OUTER_CFI_TO_INNER_CFIs,  /* ACTION_OUTER_CFI_TO_INNER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy the CFI bit from the inner tag to the outer.",
    },
    {
        .name  = ACTION_NEW_INNER_CFIs,  /* ACTION_NEW_INNER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Replace packet inner 802.1p CFI with a new one.",
    },
    {
        .name  = ACTION_INNER_CFI_TO_OUTER_CFIs,  /* ACTION_INNER_CFI_TO_OUTER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy the 802.1p priority from the outer tag to the inner.",
    },
    {
        .name  = ACTION_INNER_VLANID_TO_OUTER_VLANIDs,  /* ACTION_INNER_VLANID_TO_OUTER_VLANID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy the VLAN id from the outer tag to the inner.",
    },
    {
        .name  = ACTION_OUTER_VLANID_TO_INNER_VLANIDs,  /* ACTION_OUTER_VLANID_TO_INNER_VLANID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Copy the VLAN id from the inner tag to the outer.",
    },
    {
        .name  = ACTION_MPLS_ENABLEs,  /* ACTION_MPLS_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS lookup for the current flow.\n Enabling this field overrides the setting in the PORT and VLAN tables.\n",
    },
    {
        .name  = ACTION_MPLS_DISABLEs,  /* ACTION_MPLS_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable MPLS lookup for the current flow.\n Enabling this field overrides the setting in the PORT and VLAN tables.\n",
    },
    {
        .name  = ACTION_MPLS_TERMINATIONs,  /* ACTION_MPLS_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow MPLS termination.\n Enabling this field overrides the setting in the L2_MY_STATION table.\n",
    },
    {
        .name  = ACTION_IPV4_TERMINATIONs,  /* ACTION_IPV4_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 termination.\n Enabling this field overrides the setting in the L2_MY_STATION table.\n",
    },
    {
        .name  = ACTION_IPV6_TERMINATIONs,  /* ACTION_IPV6_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 termination.\n Enabling this field overrides the setting in the L2_MY_STATION table.\n",
    },
    {
        .name  = ACTION_IPV4_MC_TERMINATIONs,  /* ACTION_IPV4_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 multicast termination.\n Enabling this field overrides the setting in the L2_MY_STATION table.\n",
    },
    {
        .name  = ACTION_IPV6_MC_TERMINATIONs,  /* ACTION_IPV6_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 multicast termination.\n Enabling this field overrides the setting in the L2_MY_STATION table.\n",
    },
    {
        .name  = ACTION_ARP_RARP_TERMINATIONs,  /* ACTION_ARP_RARP_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow ARP/RARP termination.\n Enabling this field overrides the setting in the L2_MY_STATION table.\n",
    },
    {
        .name  = ACTION_L3_TNL_TERMINATIONs,  /* ACTION_L3_TNL_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow L3 tunnel termination.\n Enabling this field overrides the setting in the L2_MY_STATION table.\n",
    },
    {
        .name  = ACTION_VISIBILITY_ENABLEs,  /* ACTION_VISIBILITY_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to mark an ingress packet as a visibility packet,\n similar to CPU masquerading feature.\n",
    },
    {
        .name  = ACTION_PRI_MODIFIERs,  /* ACTION_PRI_MODIFIER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the VLAN FP's strength over various\n sources of L3_IIF assignment such as  L3 tunnels, L3 MPLS,\n port and L2 MPLS.\n ACTION_PRI_MODIFIER = 0  Priority above all other sources.\n ACTION_PRI_MODIFIER = 1  Priority below L3 tunnels\n and L3 MPLS based value but above other sources.\n ACTION_PRI_MODIFIER = 2  Priority above L2 MPLS based value but below\n other sources.\n",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = ACTION_BFD_ENABLEs,  /* ACTION_BFD_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable BFD.",
    },
    {
        .name  = ACTION_INNER_HDR_DSCP_CHANGE_DISABLEs,  /* ACTION_INNER_HDR_DSCP_CHANGE_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Do not change inner header DSCP.",
    },
    {
        .name  = ACTION_L3_IIF_SETs,  /* ACTION_L3_IIF_SET */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Set L3_IIF value.",
    },
    {
        .name  = ACTION_PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs,  /* ACTION_PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_IP_DSCP_TO_INT_PRI_REMAP logical table index.",
    },
    {
        .name  = ACTION_TNL_AUTOs,  /* ACTION_TNL_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate the tunnel is auto set.",
    },
    {
        .name  = ACTION_USE_OUTER_HDR_DSCPs,  /* ACTION_USE_OUTER_HDR_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header DSCP.",
    },
    {
        .name  = ACTION_USE_OUTER_HDR_TTLs,  /* ACTION_USE_OUTER_HDR_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header TTL.",
    },
    {
        .name  = ACTION_MATCH_IDs,  /* ACTION_MATCH_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Set the match ID to packets copied to CPU. This action\n is applied only if COPY_TO_CPU action is present in\n the same POLICY_TEMPLATE entry.\n",
    },
    {
        .name  = ACTION_L3_TNL_TYPEs,  /* ACTION_L3_TNL_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Set L3 tunnel type\n",
    },
};
const bcmltd_table_rep_t bcmltd_fp_vlan_policy_template_t = {
    .name = FP_VLAN_POLICY_TEMPLATEs, /* FP_VLAN_POLICY_TEMPLATE */
    .flags = 0,
    .fields = 53,
    .field = bcmltd_fp_vlan_policy_template_t_fields,
    .desc = "The FP_VLAN_POLICY_TEMPLATE table provides the set of FP policies\n that can be attached to the VLAN FP entry.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_VLAN_RULE_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_vlan_rule_template_t_fields[] = {
    {
        .name  = FP_VLAN_RULE_TEMPLATE_IDs,  /* FP_VLAN_RULE_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "VLAN FP rule identifier.",
    },
    {
        .name  = QUAL_VLAN_OUTER_PRESENTs,  /* QUAL_VLAN_OUTER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet outer VLAN tag status.",
    },
    {
        .name  = QUAL_VLAN_OUTER_PRESENT_MASKs,  /* QUAL_VLAN_OUTER_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VLAN_OUTER_PRESENT.",
    },
    {
        .name  = QUAL_OUTER_VLAN_IDs,  /* QUAL_OUTER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier for outer VLAN ID.",
    },
    {
        .name  = QUAL_OUTER_VLAN_ID_MASKs,  /* QUAL_OUTER_VLAN_ID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OUTER_VLAN_ID.",
    },
    {
        .name  = QUAL_OUTER_VLAN_CFIs,  /* QUAL_OUTER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for outer VLAN CFI.",
    },
    {
        .name  = QUAL_OUTER_VLAN_CFI_MASKs,  /* QUAL_OUTER_VLAN_CFI_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier of QUAL_OUTER_VLAN_CFI.",
    },
    {
        .name  = QUAL_OUTER_VLAN_PRIs,  /* QUAL_OUTER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier for outer VLAN Priority.",
    },
    {
        .name  = QUAL_OUTER_VLAN_PRI_MASKs,  /* QUAL_OUTER_VLAN_PRI_MASK */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OUTER_VLAN_PRI.",
    },
    {
        .name  = QUAL_VLAN_INNER_PRESENTs,  /* QUAL_VLAN_INNER_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet inner VLAN tag status.",
    },
    {
        .name  = QUAL_VLAN_INNER_PRESENT_MASKs,  /* QUAL_VLAN_INNER_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VLAN_INNER_PRESENT.",
    },
    {
        .name  = QUAL_INNER_VLAN_IDs,  /* QUAL_INNER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier for inner VLAN ID.",
    },
    {
        .name  = QUAL_INNER_VLAN_ID_MASKs,  /* QUAL_INNER_VLAN_ID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_VLAN_ID.",
    },
    {
        .name  = QUAL_INNER_VLAN_CFIs,  /* QUAL_INNER_VLAN_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for inner VLAN CFI.",
    },
    {
        .name  = QUAL_INNER_VLAN_CFI_MASKs,  /* QUAL_INNER_VLAN_CFI_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_VLAN_CFI.",
    },
    {
        .name  = QUAL_INNER_VLAN_PRIs,  /* QUAL_INNER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier for inner VLAN Priority.",
    },
    {
        .name  = QUAL_INNER_VLAN_PRI_MASKs,  /* QUAL_INNER_VLAN_PRI_MASK */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_VLAN_PRI.",
    },
    {
        .name  = QUAL_INNER_IP_PROTO_COMMONs,  /* QUAL_INNER_IP_PROTO_COMMON */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for inner IP Protocol Common field.",
    },
    {
        .name  = QUAL_IP_PROTO_COMMONs,  /* QUAL_IP_PROTO_COMMON */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for Common IP protocols.",
    },
    {
        .name  = QUAL_TNL_TERMINATEDs,  /* QUAL_TNL_TERMINATED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for Tunnel terminated traffic.",
    },
    {
        .name  = QUAL_TNL_TERMINATED_MASKs,  /* QUAL_TNL_TERMINATED_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TNL_TERMINATED.",
    },
    {
        .name  = QUAL_IP_CHECKSUM_VALIDs,  /* QUAL_IP_CHECKSUM_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier to check if packet has matching IP Checksum.",
    },
    {
        .name  = QUAL_IP_CHECKSUM_VALID_MASKs,  /* QUAL_IP_CHECKSUM_VALID_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_CHECKSUM_VALID.",
    },
    {
        .name  = QUAL_INNER_TPIDs,  /* QUAL_INNER_TPID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for inner TPID of the packet.",
    },
    {
        .name  = QUAL_OUTER_TPIDs,  /* QUAL_OUTER_TPID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for outer TPID of the packet",
    },
    {
        .name  = QUAL_L2_FORMATs,  /* QUAL_L2_FORMAT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for L2 packet format",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKTs,  /* QUAL_HIGIGLOOKUP_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet is received on HiGiG port and Table\n lookup happened.\n",
    },
    {
        .name  = QUAL_HIGIGLOOKUP_PKT_MASKs,  /* QUAL_HIGIGLOOKUP_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_HIGIGLOOKUP_PKT.",
    },
    {
        .name  = QUAL_HIGIG_PKTs,  /* QUAL_HIGIG_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet Received on HiGiG port.",
    },
    {
        .name  = QUAL_HIGIG_PKT_MASKs,  /* QUAL_HIGIG_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_HIGIG_PKT.",
    },
    {
        .name  = QUAL_INNER_IP_TYPEs,  /* QUAL_INNER_IP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for inner ip header IP type.",
    },
    {
        .name  = QUAL_IP_TYPEs,  /* QUAL_IP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for IP type.",
    },
    {
        .name  = QUAL_SRC_TRUNKs,  /* QUAL_SRC_TRUNK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for SGLP - source Trunk Group ID.",
    },
    {
        .name  = QUAL_SRC_TRUNK_MASKs,  /* QUAL_SRC_TRUNK_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_TRUNK.",
    },
    {
        .name  = QUAL_SRC_VPs,  /* QUAL_SRC_VP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for source VP.",
    },
    {
        .name  = QUAL_SRC_VP_MASKs,  /* QUAL_SRC_VP_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_VP.",
    },
    {
        .name  = QUAL_SRC_PORTs,  /* QUAL_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for source port.",
    },
    {
        .name  = QUAL_SRC_PORT_MASKs,  /* QUAL_SRC_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_PORT.",
    },
    {
        .name  = QUAL_SRC_MODULEs,  /* QUAL_SRC_MODULE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for source Module.",
    },
    {
        .name  = QUAL_SRC_MODULE_MASKs,  /* QUAL_SRC_MODULE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_MODULE.",
    },
    {
        .name  = QUAL_INPORTs,  /* QUAL_INPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for single Input port.",
    },
    {
        .name  = QUAL_INPORT_MASKs,  /* QUAL_INPORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INPORT.",
    },
    {
        .name  = QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASSs,  /* QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID from PORT_FP (PORT_FP.USE_TABLE_FP_VLAN_PORT_GRP = 1) or\n PORT_SYSTEM (PORT_FP.USE_TABLE_FP_VLAN_PORT_GRP = 0).\n",
    },
    {
        .name  = QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS_MASKs,  /* QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS.",
    },
    {
        .name  = QUAL_L4_PKTs,  /* QUAL_L4_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for L4 packet (has Valid L4 source and destination\n port).\n",
    },
    {
        .name  = QUAL_L4_PKT_MASKs,  /* QUAL_L4_PKT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L4_PKT.",
    },
    {
        .name  = QUAL_INNER_TTLs,  /* QUAL_INNER_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for inner packet TTL.",
    },
    {
        .name  = QUAL_INNER_TTL_MASKs,  /* QUAL_INNER_TTL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_TTL.",
    },
    {
        .name  = QUAL_TTLs,  /* QUAL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for packet TTL.",
    },
    {
        .name  = QUAL_TTL_MASKs,  /* QUAL_TTL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TTL.",
    },
    {
        .name  = QUAL_TCP_FLAGSs,  /* QUAL_TCP_FLAGS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for TCP control flags.",
    },
    {
        .name  = QUAL_TCP_FLAGS_MASKs,  /* QUAL_TCP_FLAGS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TCP_FLAGS.",
    },
    {
        .name  = QUAL_INNER_IP_FRAGs,  /* QUAL_INNER_IP_FRAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for flags in inner IP fragment.",
    },
    {
        .name  = QUAL_IP_FRAGs,  /* QUAL_IP_FRAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for flags in IP fragment.",
    },
    {
        .name  = QUAL_INNER_TOSs,  /* QUAL_INNER_TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for inner packet TOS.",
    },
    {
        .name  = QUAL_INNER_TOS_MASKs,  /* QUAL_INNER_TOS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_TOS.",
    },
    {
        .name  = QUAL_TOSs,  /* QUAL_TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for packet TOS.",
    },
    {
        .name  = QUAL_TOS_MASKs,  /* QUAL_TOS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TOS.",
    },
    {
        .name  = QUAL_INNER_L4DST_PORTs,  /* QUAL_INNER_L4DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for inner L4 header destination port.",
    },
    {
        .name  = QUAL_INNER_L4DST_PORT_MASKs,  /* QUAL_INNER_L4DST_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_L4DST_PORT.",
    },
    {
        .name  = QUAL_L4DST_PORTs,  /* QUAL_L4DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L4 header destination port.",
    },
    {
        .name  = QUAL_L4DST_PORT_MASKs,  /* QUAL_L4DST_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L4DST_PORT.",
    },
    {
        .name  = QUAL_INNER_L4SRC_PORTs,  /* QUAL_INNER_L4SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for inner L4 header source port.",
    },
    {
        .name  = QUAL_INNER_L4SRC_PORT_MASKs,  /* QUAL_INNER_L4SRC_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_L4SRC_PORT.",
    },
    {
        .name  = QUAL_L4SRC_PORTs,  /* QUAL_L4SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for L4 header source port.",
    },
    {
        .name  = QUAL_L4SRC_PORT_MASKs,  /* QUAL_L4SRC_PORT_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_L4SRC_PORT.",
    },
    {
        .name  = QUAL_ICMP_TYPE_CODEs,  /* QUAL_ICMP_TYPE_CODE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for ICMP type code.",
    },
    {
        .name  = QUAL_ICMP_TYPE_CODE_MASKs,  /* QUAL_ICMP_TYPE_CODE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_ICMP_TYPE_CODE.",
    },
    {
        .name  = QUAL_INNER_IP_PROTOCOLs,  /* QUAL_INNER_IP_PROTOCOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP Protocol Field.",
    },
    {
        .name  = QUAL_INNER_IP_PROTOCOL_MASKs,  /* QUAL_INNER_IP_PROTOCOL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_IP_PROTOCOL.",
    },
    {
        .name  = QUAL_IP_PROTOCOLs,  /* QUAL_IP_PROTOCOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for IP protocol.",
    },
    {
        .name  = QUAL_IP_PROTOCOL_MASKs,  /* QUAL_IP_PROTOCOL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_PROTOCOL.",
    },
    {
        .name  = QUAL_INNER_DST_IP4s,  /* QUAL_INNER_DST_IP4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for inner destination IPv4 address.",
    },
    {
        .name  = QUAL_INNER_DST_IP4_MASKs,  /* QUAL_INNER_DST_IP4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_DST_IP4.",
    },
    {
        .name  = QUAL_DST_IP4s,  /* QUAL_DST_IP4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for destination IPv4 address.",
    },
    {
        .name  = QUAL_DST_IP4_MASKs,  /* QUAL_DST_IP4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP4.",
    },
    {
        .name  = QUAL_INNER_SRC_IP4s,  /* QUAL_INNER_SRC_IP4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for inner source IPv4 address.",
    },
    {
        .name  = QUAL_INNER_SRC_IP4_MASKs,  /* QUAL_INNER_SRC_IP4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_SRC_IP4.",
    },
    {
        .name  = QUAL_SRC_IP4s,  /* QUAL_SRC_IP4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for source IPv4 address.",
    },
    {
        .name  = QUAL_SRC_IP4_MASKs,  /* QUAL_SRC_IP4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_IP4.",
    },
    {
        .name  = QUAL_INNER_SRC_IP6_UPPERs,  /* QUAL_INNER_SRC_IP6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for inner IP header source IPv6 address.",
    },
    {
        .name  = QUAL_INNER_SRC_IP6_LOWERs,  /* QUAL_INNER_SRC_IP6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for inner IP header source IPv6 address.",
    },
    {
        .name  = QUAL_INNER_SRC_IP6_MASK_UPPERs,  /* QUAL_INNER_SRC_IP6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_SRC_IP6.",
    },
    {
        .name  = QUAL_INNER_SRC_IP6_MASK_LOWERs,  /* QUAL_INNER_SRC_IP6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_SRC_IP6.",
    },
    {
        .name  = QUAL_SRC_IP6_UPPERs,  /* QUAL_SRC_IP6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for source IPv6 Address.",
    },
    {
        .name  = QUAL_SRC_IP6_LOWERs,  /* QUAL_SRC_IP6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for source IPv6 Address.",
    },
    {
        .name  = QUAL_SRC_IP6_MASK_UPPERs,  /* QUAL_SRC_IP6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_IP6.",
    },
    {
        .name  = QUAL_SRC_IP6_MASK_LOWERs,  /* QUAL_SRC_IP6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_IP6.",
    },
    {
        .name  = QUAL_INNER_DST_IP6_UPPERs,  /* QUAL_INNER_DST_IP6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for inner IP header destination IPv6 address.",
    },
    {
        .name  = QUAL_INNER_DST_IP6_LOWERs,  /* QUAL_INNER_DST_IP6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for inner IP header destination IPv6 address.",
    },
    {
        .name  = QUAL_INNER_DST_IP6_MASK_UPPERs,  /* QUAL_INNER_DST_IP6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_DST_IP6.",
    },
    {
        .name  = QUAL_INNER_DST_IP6_MASK_LOWERs,  /* QUAL_INNER_DST_IP6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_DST_IP6.",
    },
    {
        .name  = QUAL_DST_IP6_UPPERs,  /* QUAL_DST_IP6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for destination IPV6 Address.",
    },
    {
        .name  = QUAL_DST_IP6_LOWERs,  /* QUAL_DST_IP6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for destination IPV6 Address.",
    },
    {
        .name  = QUAL_DST_IP6_MASK_UPPERs,  /* QUAL_DST_IP6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP6.",
    },
    {
        .name  = QUAL_DST_IP6_MASK_LOWERs,  /* QUAL_DST_IP6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP6.",
    },
    {
        .name  = QUAL_ETHERTYPEs,  /* QUAL_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for ethertype.",
    },
    {
        .name  = QUAL_ETHERTYPE_MASKs,  /* QUAL_ETHERTYPE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_ETHERTYPE.",
    },
    {
        .name  = QUAL_SRC_MACs,  /* QUAL_SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier for source MAC address.",
    },
    {
        .name  = QUAL_SRC_MAC_MASKs,  /* QUAL_SRC_MAC_MASK */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_MAC.",
    },
    {
        .name  = QUAL_DST_MACs,  /* QUAL_DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier for destination MAC address.",
    },
    {
        .name  = QUAL_DST_MAC_MASKs,  /* QUAL_DST_MAC_MASK */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_MAC.",
    },
    {
        .name  = QUAL_INNER_SRC_IP6_HIGHs,  /* QUAL_INNER_SRC_IP6_HIGH */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for inner IP header source IPv6 Address\n (High/Upper 64 bits).\n",
    },
    {
        .name  = QUAL_INNER_SRC_IP6_HIGH_MASKs,  /* QUAL_INNER_SRC_IP6_HIGH_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_SRC_IP6_HIGH.",
    },
    {
        .name  = QUAL_SRC_IP6_HIGHs,  /* QUAL_SRC_IP6_HIGH */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for source IPv6 Address (High/Upper 64 bits).",
    },
    {
        .name  = QUAL_SRC_IP6_HIGH_MASKs,  /* QUAL_SRC_IP6_HIGH_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SRC_IP6_HIGH.",
    },
    {
        .name  = QUAL_INNER_DST_IP6_HIGHs,  /* QUAL_INNER_DST_IP6_HIGH */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for inner IP header destination IPv6 Address\n (High/Upper 64 bits).\n",
    },
    {
        .name  = QUAL_INNER_DST_IP6_HIGH_MASKs,  /* QUAL_INNER_DST_IP6_HIGH_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_INNER_DST_IP6_HIGH.",
    },
    {
        .name  = QUAL_DST_IP6_HIGHs,  /* QUAL_DST_IP6_HIGH */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier for destination IPv6 Address (High/Upper 64 bits).",
    },
    {
        .name  = QUAL_DST_IP6_HIGH_MASKs,  /* QUAL_DST_IP6_HIGH_MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_DST_IP6_HIGH.",
    },
    {
        .name  = QUAL_VNTAGs,  /* QUAL_VNTAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier for NIV VN tag (Network interface Virtualization virtual\n network tag).\n",
    },
    {
        .name  = QUAL_VNTAG_MASKs,  /* QUAL_VNTAG_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_VNTAG.",
    },
    {
        .name  = QUAL_SNAP_HEADERs,  /* QUAL_SNAP_HEADER */
        .flags = 0,
        .width = 40,
        .depth = 0,
        .desc = "Qualifier for Sub-Network Attachment Point header (SNAP header).",
    },
    {
        .name  = QUAL_SNAP_HEADER_MASKs,  /* QUAL_SNAP_HEADER_MASK */
        .flags = 0,
        .width = 40,
        .depth = 0,
        .desc = "Qualifier for Sub-Network Attachment Point header (SNAP header).",
    },
    {
        .name  = QUAL_LLC_HEADERs,  /* QUAL_LLC_HEADER */
        .flags = 0,
        .width = 24,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_SNAP_HEADER.",
    },
    {
        .name  = QUAL_LLC_HEADER_MASKs,  /* QUAL_LLC_HEADER_MASK */
        .flags = 0,
        .width = 24,
        .depth = 0,
        .desc = "Qualifier mask of LLC_HEADER.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_SUBCODEs,  /* QUAL_IP_FIRST_EH_SUBCODE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for First byte after the extension header length field.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_SUBCODE_MASKs,  /* QUAL_IP_FIRST_EH_SUBCODE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_FIRST_EH_SUBCODE.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_PROTOs,  /* QUAL_IP_FIRST_EH_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier for Next header field in first header extension header.",
    },
    {
        .name  = QUAL_IP_FIRST_EH_PROTO_MASKs,  /* QUAL_IP_FIRST_EH_PROTO_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_IP_FIRST_EH_PROTO.",
    },
    {
        .name  = QUAL_TNL_CLASS_IDs,  /* QUAL_TNL_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier for tunnel class ID.",
    },
    {
        .name  = QUAL_TNL_CLASS_ID_MASKs,  /* QUAL_TNL_CLASS_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_TNL_CLASS.",
    },
    {
        .name  = QUAL_UDF_CHUNKSs,  /* QUAL_UDF_CHUNKS */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "Qualifier for UDF chunks.",
    },
    {
        .name  = QUAL_UDF_CHUNKS_MASKs,  /* QUAL_UDF_CHUNKS_MASK */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "Qualifier mask for QUAL_UDF_CHUNKS.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_TYPEs,  /* QUAL_OPAQUE_TAG_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Qualifier to match on the tag type configured for opaque\n tags. This tag type is the value configured in the TAG_TYPE\n field in the L2_OPAQUE_TAG table.\n",
    },
    {
        .name  = QUAL_OPAQUE_TAG_TYPE_MASKs,  /* QUAL_OPAQUE_TAG_TYPE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask of opaque tag type.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_PRESENTs,  /* QUAL_OPAQUE_TAG_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier for packet opaque tag status.",
    },
    {
        .name  = QUAL_OPAQUE_TAG_PRESENT_MASKs,  /* QUAL_OPAQUE_TAG_PRESENT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Qualifier mask of QUAL_OPAQUE_TAG_PRESENT.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_vlan_rule_template_t = {
    .name = FP_VLAN_RULE_TEMPLATEs, /* FP_VLAN_RULE_TEMPLATE */
    .flags = 0,
    .fields = 128,
    .field = bcmltd_fp_vlan_rule_template_t_fields,
    .desc = "The FP_VLAN_RULE_TEMPLATE table specifies the VLAN FP rule that can be\n attached to a VLAN FP entry.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/fp/FP_VLAN_SLICE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_fp_vlan_slice_info_t_fields[] = {
    {
        .name  = FP_VLAN_SLICE_IDs,  /* FP_VLAN_SLICE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Lookup FP slice ID.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = ENTRY_INUSE_CNTs,  /* ENTRY_INUSE_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries created.",
    },
    {
        .name  = ENTRY_MAXIMUMs,  /* ENTRY_MAXIMUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of entries.",
    },
};
const bcmltd_table_rep_t bcmltd_fp_vlan_slice_info_t = {
    .name = FP_VLAN_SLICE_INFOs, /* FP_VLAN_SLICE_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_fp_vlan_slice_info_t_fields,
    .desc = "The FP_VLAN_SLICE_INFO table provides FP slice-specific information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_control_t_fields[] = {
    {
        .name  = NON_STATIC_MAC_MOVE_TO_CPUs,  /* NON_STATIC_MAC_MOVE_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets resulting in non-static MAC move\n to the CPU.\n",
    },
    {
        .name  = STATIC_MAC_MOVE_TO_CPUs,  /* STATIC_MAC_MOVE_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets resulting in static MAC move to the CPU.",
    },
    {
        .name  = DROP_ON_PRI_TO_CPUs,  /* DROP_ON_PRI_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets dropped due to VLAN priority admittance\n check (PORT_POLICY.DROP_ON_PRI) failure to the CPU.\n",
    },
    {
        .name  = SRC_MC_MAC_TO_CPUs,  /* SRC_MC_MAC_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with source MAC address bit 40 set\n to the CPU.\n",
    },
    {
        .name  = UNKNOWN_UC_TO_CPUs,  /* UNKNOWN_UC_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy unknown unicast packets to the CPU.",
    },
    {
        .name  = MAC_MOVE_FAILURE_TO_CPUs,  /* MAC_MOVE_FAILURE_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets to the CPU when the MAC in the L2_FDB_VLAN\n logical table fails to be re-learnt to a new port.\n",
    },
    {
        .name  = DROP_ALL_ZERO_SRC_MACs,  /* DROP_ALL_ZERO_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets with a source MAC address of all zeros.",
    },
    {
        .name  = DROP_MAC_MOVE_FAILUREs,  /* DROP_MAC_MOVE_FAILURE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets when the MAC in the L2_FDB_VLAN\n logical table fails to be re-learnt to a new port.\n",
    },
    {
        .name  = SKIP_LEARNING_DHCPs,  /* SKIP_LEARNING_DHCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to disable L2 learning for DHCP packets.",
    },
    {
        .name  = SKIP_HIT_DST_MACs,  /* SKIP_HIT_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to not set the destination MAC address hit indicator\n L2_FDB_VLAN.HIT_DST_MAC on a destination MAC address lookup.\n",
    },
    {
        .name  = SKIP_SRC_DROPs,  /* SKIP_SRC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip dropping of packets if L2_FDB_VLAN.SRC_DROP\n is enabled and the packets match the condition.\n",
    },
    {
        .name  = L2_MC_FID_LOOKUPs,  /* L2_MC_FID_LOOKUP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2 lookups for L2MC packets using their destination MAC\n address and shared VLAN (filtering database ID).\n",
    },
    {
        .name  = UNKNOWN_MC_TO_CPUs,  /* UNKNOWN_MC_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy unknown multicast packets to the CPU.",
    },
    {
        .name  = PARITY_ERR_TO_CPUs,  /* PARITY_ERR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with parity error to the CPU.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_control_t = {
    .name = L2_CONTROLs, /* L2_CONTROL */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_l2_control_t_fields,
    .desc = "The L2_CONTROL table specifies the device level\n L2 functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_DST_BLOCK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_dst_block_t_fields[] = {
    {
        .name  = L2_DST_BLOCK_IDs,  /* L2_DST_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "L2_DST_BLOCK logical table index.",
    },
    {
        .name  = DST_BLOCK_MASKs,  /* DST_BLOCK_MASK */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Dest block mask with the port bitmap.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_dst_block_t = {
    .name = L2_DST_BLOCKs, /* L2_DST_BLOCK */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l2_dst_block_t_fields,
    .desc = "The L2_DST_BLOCK table mask out a set of egress ports.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_EIF_SYSTEM_DESTINATION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_eif_system_destination_t_fields[] = {
    {
        .name  = L2_EIF_IDs,  /* L2_EIF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L2 outgoing interface identifier.",
    },
    {
        .name  = IS_TRUNKs,  /* IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the system destination is a trunk.",
    },
    {
        .name  = SYSTEM_PORTs,  /* SYSTEM_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "System port. Applicable only when IS_TRUNK is disabled.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Trunk ID. Applicable only when IS_TRUNK is enabled.",
    },
    {
        .name  = FLEX_CTR_ACTION_IDs,  /* FLEX_CTR_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Attached flex counter action identifier.",
    },
    {
        .name  = DLB_ID_VALIDs,  /* DLB_ID_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dynamic load balancing for TRUNK.\n Applicable only when IS_TRUNK is enabled.\n",
    },
    {
        .name  = DLB_IDs,  /* DLB_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Dynamic load balancing identifier for TRUNK.\n Index into DLB_TRUNK table.\n Applicable only when IS_TRUNK is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l2_eif_system_destination_t = {
    .name = L2_EIF_SYSTEM_DESTINATIONs, /* L2_EIF_SYSTEM_DESTINATION */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_l2_eif_system_destination_t_fields,
    .desc = "The L2_EIF_SYSTEM_DESTINATION table is used to specify the system\n destination of the layer 2 outgoing interface. The system destination\n for the layer 2 can be a system port or a trunk.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_FDB_VLAN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_fdb_vlan_t_fields[] = {
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of L2 packets.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MAC address of L2 packets.",
    },
    {
        .name  = DEST_TYPEs,  /* DEST_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type which is used to indicate the destination is\n a trunk group <TRUNK_ID>, or a normal port <MODID, MODPORT>,\n or an L2 multicast group <L2_MC_GRP_ID>.\n",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination trunk Group ID.\n Applicable only if DEST_TYPE == TRUNK.\n",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Destination module ID.\n Applicable only if DEST_TYPE == PORT.\n",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination port ID.\n Applicable only if DEST_TYPE == PORT.\n",
    },
    {
        .name  = L2_MC_GRP_IDs,  /* L2_MC_GRP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination L2 multicast group.\n Applicable only if DEST_TYPE == L2_MC_GRP.\n",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID for the ingress FP.",
    },
    {
        .name  = ASSIGN_INT_PRIs,  /* ASSIGN_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the assignment of the internal priority with\n INT_PRI if the destination MAC address is hit.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Applicable only if ASSIGN_INT_PRI is enabled.",
    },
    {
        .name  = DST_DROPs,  /* DST_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet\n if the destination MAC address is hit.\n",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to CPU\n if the destination MAC address is hit.\n",
    },
    {
        .name  = SRC_DROPs,  /* SRC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet if the source MAC address is hit.",
    },
    {
        .name  = TRUST_SRC_INT_PRIs,  /* TRUST_SRC_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable trusting the internal priority associated with\n the source of the packet over the internal priority associated\n with the packet destination when both the source MAC address and\n the destination MAC address are hit.\n",
    },
    {
        .name  = STATICs,  /* STATIC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the entry is static.",
    },
    {
        .name  = HIT_SRC_MACs,  /* HIT_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the source MAC address is hit.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = HIT_DST_MACs,  /* HIT_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the destination MAC address is hit.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = HIT_LOCAL_SRC_MACs,  /* HIT_LOCAL_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the source MAC address is locally hit.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = L2_DST_BLOCK_IDs,  /* L2_DST_BLOCK_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Read-only field which indicates L2_DST_BLOCK logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_fdb_vlan_t = {
    .name = L2_FDB_VLANs, /* L2_FDB_VLAN */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 19,
    .field = bcmltd_l2_fdb_vlan_t_fields,
    .desc = "The L2_FDB_VLAN table specifies the L2 forwarding database controls.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_FDB_VLAN_CC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_fdb_vlan_cc_t_fields[] = {
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID.",
    },
    {
        .name  = DST_1_IS_TRUNKs,  /* DST_1_IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use DST_1_TRUNK_ID as the destination.\n Disable to use DST_1_MODPORT as the destination.\n",
    },
    {
        .name  = DST_1_TRUNK_IDs,  /* DST_1_TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination trunk group ID 1.\n Applicable only if DST_1_IS_TRUNK is enabled.\n",
    },
    {
        .name  = DST_1_MODPORTs,  /* DST_1_MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination port ID 1.\n Applicable only if DST_1_IS_TRUNK is disabled.\n",
    },
    {
        .name  = DST_2_IS_TRUNKs,  /* DST_2_IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use DST_2_TRUNK_ID as the destination.\n Disable to use DST_2_MODPORT as the destination.\n",
    },
    {
        .name  = DST_2_TRUNK_IDs,  /* DST_2_TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination trunk group ID 2.\n Applicable only if DST_2_IS_TRUNK is enabled.\n",
    },
    {
        .name  = DST_2_MODPORTs,  /* DST_2_MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination port ID 2.\n Applicable only if DST_2_IS_TRUNK is disabled.\n",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID for the ingress FP.",
    },
    {
        .name  = ASSIGN_INT_PRIs,  /* ASSIGN_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the assignment of the internal priority with INT_PRI.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority.\n Applicable only if ASSIGN_INT_PRI is enabled.\n",
    },
    {
        .name  = DST_DROPs,  /* DST_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet if the VLAN ID is hit.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to CPU if the VLAN ID is hit.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_fdb_vlan_cc_t = {
    .name = L2_FDB_VLAN_CCs, /* L2_FDB_VLAN_CC */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 12,
    .field = bcmltd_l2_fdb_vlan_cc_t_fields,
    .desc = "The L2_FDB_VLAN_CC table specifies the VLAN cross connect\n configuration which creates a L2 bridge between a pair of\n ports/trunks.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_FDB_VLAN_STATIC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_fdb_vlan_static_t_fields[] = {
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the packet.",
    },
    {
        .name  = VLAN_ID_MASKs,  /* VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for VLAN_ID.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MAC address of the packet.",
    },
    {
        .name  = MAC_ADDR_MASKs,  /* MAC_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC_ADDR.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = IS_TRUNKs,  /* IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use TRUNK_ID from the logical table as the destination.\n Else, use MODID and MODPORT from the logical table as the destination.\n",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination trunk group ID.\n Applicable only if IS_TRUNK is enabled.\n",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Destination module ID.\n Applicable only if IS_TRUNK is disabled.\n",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination port.\n Applicable only if IS_TRUNK is disabled.\n",
    },
    {
        .name  = SKIP_LEARNINGs,  /* SKIP_LEARNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable bypass of MAC source address if\n the MAC destination address is hit.\n",
    },
    {
        .name  = BPDUs,  /* BPDU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the entry is a BPDU.",
    },
    {
        .name  = L2_PROTOCOL_PKTs,  /* L2_PROTOCOL_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the packet matches as\n an L2 protocol packet.\n",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID for the ingress FP.",
    },
    {
        .name  = ASSIGN_INT_PRIs,  /* ASSIGN_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the assignment of the internal priority with PRI\n if the MAC destination address is hit.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet if the MAC destination address is hit.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to CPU if the MAC destination address is hit.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_fdb_vlan_static_t = {
    .name = L2_FDB_VLAN_STATICs, /* L2_FDB_VLAN_STATIC */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 17,
    .field = bcmltd_l2_fdb_vlan_static_t_fields,
    .desc = "The L2_FDB_VLAN_STATIC table specifies the static L2 forwarding database controls\n and BPDU packets controls.\n Unlike the L2_FDB_VLAN table, the MAC address entries populated in this table\n will not prevent those same MAC addresses from being learnt and reported\n in the L2_LEARN_DATA table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_HEADER_VALIDATION_1_DST_MAC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_header_validation_1_dst_mac_t_fields[] = {
    {
        .name  = L2_HEADER_VALIDATION_1_DST_MAC_IDs,  /* L2_HEADER_VALIDATION_1_DST_MAC_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the destination MAC address validation table.",
    },
    {
        .name  = MASKs,  /* MASK */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Mask to be applied to the destination MAC address\n before comparing.\n",
    },
    {
        .name  = VALUEs,  /* VALUE */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Value to be compared with the destination MAC address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified destination MAC address type. Applicable when\n the destination MAC address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l2_header_validation_1_dst_mac_t = {
    .name = L2_HEADER_VALIDATION_1_DST_MACs, /* L2_HEADER_VALIDATION_1_DST_MAC */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l2_header_validation_1_dst_mac_t_fields,
    .desc = "The L2_HEADER_VALIDATION_1_DST_MAC table specifies L2\n destination MAC address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_HEADER_VALIDATION_1_SRC_MAC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_header_validation_1_src_mac_t_fields[] = {
    {
        .name  = L2_HEADER_VALIDATION_1_SRC_MAC_IDs,  /* L2_HEADER_VALIDATION_1_SRC_MAC_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the source MAC address validation table.",
    },
    {
        .name  = MASKs,  /* MASK */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Mask to be applied to the source MAC address\n before comparing.\n",
    },
    {
        .name  = VALUEs,  /* VALUE */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Value to be compared with the source MAC address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified source MAC address type. Applicable when\n the source MAC address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l2_header_validation_1_src_mac_t = {
    .name = L2_HEADER_VALIDATION_1_SRC_MACs, /* L2_HEADER_VALIDATION_1_SRC_MAC */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l2_header_validation_1_src_mac_t_fields,
    .desc = "The L2_HEADER_VALIDATION_1_SRC_MAC table specifies L2\n source MAC address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_HEADER_VALIDATION_2_DST_MAC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_header_validation_2_dst_mac_t_fields[] = {
    {
        .name  = L2_HEADER_VALIDATION_2_DST_MAC_IDs,  /* L2_HEADER_VALIDATION_2_DST_MAC_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the destination MAC address validation table.",
    },
    {
        .name  = MASKs,  /* MASK */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Mask to be applied to the destination MAC address\n before comparing.\n",
    },
    {
        .name  = VALUEs,  /* VALUE */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Value to be compared with the destination MAC address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified destination MAC address type. Applicable when\n the destination MAC address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l2_header_validation_2_dst_mac_t = {
    .name = L2_HEADER_VALIDATION_2_DST_MACs, /* L2_HEADER_VALIDATION_2_DST_MAC */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l2_header_validation_2_dst_mac_t_fields,
    .desc = "The L2_HEADER_VALIDATION_2_DST_MAC table specifies L2\n destination MAC address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_HEADER_VALIDATION_2_SRC_MAC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_header_validation_2_src_mac_t_fields[] = {
    {
        .name  = L2_HEADER_VALIDATION_2_SRC_MAC_IDs,  /* L2_HEADER_VALIDATION_2_SRC_MAC_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the source MAC address validation table.",
    },
    {
        .name  = MASKs,  /* MASK */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Mask to be applied to the source MAC address\n before comparing.\n",
    },
    {
        .name  = VALUEs,  /* VALUE */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Value to be compared with the source MAC address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified source MAC address type. Applicable when\n the source MAC address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l2_header_validation_2_src_mac_t = {
    .name = L2_HEADER_VALIDATION_2_SRC_MACs, /* L2_HEADER_VALIDATION_2_SRC_MAC */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l2_header_validation_2_src_mac_t_fields,
    .desc = "The L2_HEADER_VALIDATION_2_SRC_MAC table specifies L2\n source MAC address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_LEARN_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_learn_control_t_fields[] = {
    {
        .name  = REPORTs,  /* REPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable reporting MAC addresses of packets.",
    },
    {
        .name  = SLOW_POLLs,  /* SLOW_POLL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use slow poll for learn cache.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_learn_control_t = {
    .name = L2_LEARN_CONTROLs, /* L2_LEARN_CONTROL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l2_learn_control_t_fields,
    .desc = "The L2_LEARN_CONTROL table is used to enable reporting\n the MAC addresses of packets to end users.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_LEARN_DATA.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_learn_data_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Packet processor pipe number.",
    },
    {
        .name  = L2_LEARN_DATA_IDs,  /* L2_LEARN_DATA_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L2_LEARN_DATA logical table index.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the L2 packet.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "MAC address of the L2 packet.",
    },
    {
        .name  = SRC_TYPEs,  /* SRC_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Port type used to indicate whether the source port is\n a trunk group <TRUNK_ID> or a normal port <MODID, MODPORT>.\n",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source trunk group ID. Applicable only if SRC_TYPE == TRUNK.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Source module ID. Applicable only if SRC_TYPE == PORT.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source port ID. Applicable only if SRC_TYPE == PORT.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_learn_data_t = {
    .name = L2_LEARN_DATAs, /* L2_LEARN_DATA */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_l2_learn_data_t_fields,
    .desc = "The L2_LEARN_DATA table is used to report learnt MAC addresses.\n Once an application retrieves the reported MAC addresses from this table,\n it must delete existing table entries in order to\n accommodate learning of new MAC addresses.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_LEARN_OVERRIDE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_learn_override_t_fields[] = {
    {
        .name  = MAC_LEARN_OVERRIDEs,  /* MAC_LEARN_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable override of the equivalent MAC learning\n fields in the PORT_LEARN logical table.\n",
    },
    {
        .name  = MAC_LEARNs,  /* MAC_LEARN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MAC address learning.\n Applicable only if MAC_LEARN_OVERRIDE is enabled.\n",
    },
    {
        .name  = MAC_COPY_TO_CPUs,  /* MAC_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copying to CPU for packets with\n unknown source MAC address.\n Applicable only if MAC_LEARN_OVERRIDE is enabled.\n",
    },
    {
        .name  = MAC_LEARN_AS_PENDINGs,  /* MAC_LEARN_AS_PENDING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable learning new MAC addresses as pending.\n Applicable only if MAC_LEARN_OVERRIDE is enabled.\n",
    },
    {
        .name  = MAC_DROPs,  /* MAC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping packets with\n unknown source MAC address.\n Applicable only if MAC_LEARN_OVERRIDE is enabled.\n",
    },
    {
        .name  = MAC_MOVE_OVERRIDEs,  /* MAC_MOVE_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable override of the equivalent MAC move\n fields in the PORT_LEARN logical table.\n",
    },
    {
        .name  = MAC_MOVEs,  /* MAC_MOVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MAC address station move.\n Applicable only if MAC_MOVE_OVERRIDE is enabled.\n",
    },
    {
        .name  = MAC_MOVE_COPY_TO_CPUs,  /* MAC_MOVE_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copying to CPU for station move packets.\n Applicable only if MAC_MOVE_OVERRIDE is enabled.\n",
    },
    {
        .name  = MAC_MOVE_AS_PENDINGs,  /* MAC_MOVE_AS_PENDING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable learning station move\n MAC addresses as pending.\n Applicable only if MAC_MOVE_OVERRIDE is enabled.\n",
    },
    {
        .name  = MAC_MOVE_DROPs,  /* MAC_MOVE_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping station move packets.\n Applicable only if MAC_MOVE_OVERRIDE is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l2_learn_override_t = {
    .name = L2_LEARN_OVERRIDEs, /* L2_LEARN_OVERRIDE */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_l2_learn_override_t_fields,
    .desc = "The L2_LEARN_OVERRIDE table specifies the device level\n MAC address learning functionality which overrides the\n corresponding functions in the the PORT_LEARN table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_MC_GROUP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_mc_group_t_fields[] = {
    {
        .name  = L2_MC_GROUP_IDs,  /* L2_MC_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the L2 multicast group table.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to specify logical ports that are part of\n the L2 multicast group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l2_mc_group_t = {
    .name = L2_MC_GROUPs, /* L2_MC_GROUP */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l2_mc_group_t_fields,
    .desc = "The L2_MC_GROUP table maps an L2 multicast index to\n one or more front panel ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_MY_STATION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_my_station_t_fields[] = {
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the matched L2 packet.",
    },
    {
        .name  = VLAN_ID_MASKs,  /* VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for VLAN_ID.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the matched L2 packet.",
    },
    {
        .name  = MAC_ADDR_MASKs,  /* MAC_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC_ADDR.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = IPV6_TERMINATIONs,  /* IPV6_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 unicast packet termination.",
    },
    {
        .name  = IPV6_MC_TERMINATIONs,  /* IPV6_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 multicast packet termination.",
    },
    {
        .name  = IPV4_TERMINATIONs,  /* IPV4_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 unicast packet termination.",
    },
    {
        .name  = IPV4_MC_TERMINATIONs,  /* IPV4_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 multicast packet termination.",
    },
    {
        .name  = ARP_RARP_TERMINATIONs,  /* ARP_RARP_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ARP or RARP packet termination.",
    },
    {
        .name  = MPLS_TERMINATIONs,  /* MPLS_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS packet termination.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to the CPU.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_my_station_t = {
    .name = L2_MY_STATIONs, /* L2_MY_STATION */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 13,
    .field = bcmltd_l2_my_station_t_fields,
    .desc = "The L2_MY_STATION table specifies per-packet destination MAC address\n behavior for packets that are either sourced from trunks or ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_MY_STATION_MODPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_my_station_modport_t_fields[] = {
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the matched L2 packet.",
    },
    {
        .name  = VLAN_ID_MASKs,  /* VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for VLAN_ID.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the matched L2 packet.",
    },
    {
        .name  = MAC_ADDR_MASKs,  /* MAC_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC_ADDR.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Source module ID of the matched L2 packet.",
    },
    {
        .name  = MODID_MASKs,  /* MODID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for MODID.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Source port ID of the matched L2 packet.",
    },
    {
        .name  = MODPORT_MASKs,  /* MODPORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for MODPORT.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = IPV6_TERMINATIONs,  /* IPV6_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 unicast packet termination.",
    },
    {
        .name  = IPV6_MC_TERMINATIONs,  /* IPV6_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 multicast packet termination.",
    },
    {
        .name  = IPV4_TERMINATIONs,  /* IPV4_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 unicast packet termination.",
    },
    {
        .name  = IPV4_MC_TERMINATIONs,  /* IPV4_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 multicast packet termination.",
    },
    {
        .name  = ARP_RARP_TERMINATIONs,  /* ARP_RARP_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ARP or RARP packet termination.",
    },
    {
        .name  = MPLS_TERMINATIONs,  /* MPLS_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS packet termination.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to the CPU.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_my_station_modport_t = {
    .name = L2_MY_STATION_MODPORTs, /* L2_MY_STATION_MODPORT */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 17,
    .field = bcmltd_l2_my_station_modport_t_fields,
    .desc = "The L2_MY_STATION_MODPORT table specifies per-packet destination MAC address\n behavior for packets that are only sourced from ports (not trunks).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_MY_STATION_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_my_station_trunk_t_fields[] = {
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the matched L2 packet.",
    },
    {
        .name  = VLAN_ID_MASKs,  /* VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for VLAN_ID.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the matched L2 packet.",
    },
    {
        .name  = MAC_ADDR_MASKs,  /* MAC_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC_ADDR.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = TRUNK_ID_MASKs,  /* TRUNK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for TRUNK_ID.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = IPV6_TERMINATIONs,  /* IPV6_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 unicast packet termination.",
    },
    {
        .name  = IPV6_MC_TERMINATIONs,  /* IPV6_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 multicast packet termination.",
    },
    {
        .name  = IPV4_TERMINATIONs,  /* IPV4_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 unicast packet termination.",
    },
    {
        .name  = IPV4_MC_TERMINATIONs,  /* IPV4_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 multicast packet termination.",
    },
    {
        .name  = ARP_RARP_TERMINATIONs,  /* ARP_RARP_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ARP or RARP packet termination.",
    },
    {
        .name  = MPLS_TERMINATIONs,  /* MPLS_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS packet termination.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to the CPU.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_my_station_trunk_t = {
    .name = L2_MY_STATION_TRUNKs, /* L2_MY_STATION_TRUNK */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 15,
    .field = bcmltd_l2_my_station_trunk_t_fields,
    .desc = "The L2_MY_STATION_TRUNK table specifies per-packet destination MAC address\n behavior for packets that are only sourced from trunks (not ports).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_OPAQUE_TAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_opaque_tag_t_fields[] = {
    {
        .name  = L2_OPAQUE_TAG_IDs,  /* L2_OPAQUE_TAG_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L2 opaque tag table.",
    },
    {
        .name  = TAG_SIZEs,  /* TAG_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Size of the opaque tag.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype used to identify the opaque tag.",
    },
    {
        .name  = TAG_TYPEs,  /* TAG_TYPE */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Type of the opaque tag.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_opaque_tag_t = {
    .name = L2_OPAQUE_TAGs, /* L2_OPAQUE_TAG */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l2_opaque_tag_t_fields,
    .desc = "The L2_OPAQUE_TAG logical table specifies opaque tags\n which can be identified by tag parser and will be skipped\n by the device accordingly.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_PARSER_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_parser_control_t_fields[] = {
    {
        .name  = MMRP_DST_MACs,  /* MMRP_DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address to match for multiple MAC registration\n protocol (MMRP) frame detection.\n",
    },
    {
        .name  = MMRP_ETHERTYPEs,  /* MMRP_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype to match for multiple MAC registration protocol (MMRP)\n frame detection.\n",
    },
    {
        .name  = SRP_DST_MACs,  /* SRP_DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address to match for stream reservation\n protocol (SRP) frame detection.\n",
    },
    {
        .name  = SRP_ETHERTYPEs,  /* SRP_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype to match for stream reservation protocol (SRP)\n frame detection.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l2_parser_control_t = {
    .name = L2_PARSER_CONTROLs, /* L2_PARSER_CONTROL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l2_parser_control_t_fields,
    .desc = "The L2_PARSER_CONTROL logical table specifies L2 protocol parsing controls\n for frame detection.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_PAYLOAD_OPAQUE_TAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_payload_opaque_tag_t_fields[] = {
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype used to identify the opaque tag.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_payload_opaque_tag_t = {
    .name = L2_PAYLOAD_OPAQUE_TAGs, /* L2_PAYLOAD_OPAQUE_TAG */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_l2_payload_opaque_tag_t_fields,
    .desc = "The L2_PAYLOAD_OPAQUE_TAG logical table specifies the opaque tags for\n payload during tunnel decapsulation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_TAG_ACTION_NHOP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_tag_action_nhop_t_fields[] = {
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the L2_TAG_ACTION_NHOP logical table.",
    },
    {
        .name  = IS_TRUNKs,  /* IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the next hop is a trunk (LAG) port.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination logical port to reach the Next Hop.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Trunk Group Identifier. Applicable only if IS_TRUNK is enabled.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the next hop.",
    },
    {
        .name  = ING_UNDERLAY_NHOP_VALIDs,  /* ING_UNDERLAY_NHOP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate ING_UNDERLAY_NHOP_ID is valid.\n Applicable only when NHOP_ID is used as an overlay next hop.\n",
    },
    {
        .name  = ING_UNDERLAY_NHOP_IDs,  /* ING_UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index to the logical table L3_UC_NHOP.\n It is derived from this overlay next hop in the ingress pipeline.\n Applicable only if ING_UNDERLAY_NHOP_VALID is enabled.\n",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packet to CPU.",
    },
    {
        .name  = DO_NOT_CUT_THROUGHs,  /* DO_NOT_CUT_THROUGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate the packet is not eligible for cut-through.\n",
    },
    {
        .name  = L3_EIF_VALIDs,  /* L3_EIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate L3_EIF_ID is valid.\n L3_EIF_ID is applicable only if L3_EIF_VALID is enabled.\n",
    },
    {
        .name  = L3_EIF_IDs,  /* L3_EIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the L3_EIF logical table.",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Destination VP derived from this next hop.",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_VALIDs,  /* EGR_UNDERLAY_NHOP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate EGR_UNDERLAY_NHOP_ID is valid.\n Applicable only when NHOP_ID is used as an underlay next hop.\n",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_IDs,  /* EGR_UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Underlay next hop ID which overrides\n the underlay next hop in the egress pipeline.\n Applicable only if EGR_UNDERLAY_NHOP_VALID is enabled.\n",
    },
    {
        .name  = VLAN_TAG_PRESENT_ACTIONs,  /* VLAN_TAG_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 tag action if the tag is present.",
    },
    {
        .name  = VLAN_TAG_NOT_PRESENT_ACTIONs,  /* VLAN_TAG_NOT_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 tag action if the tag is not present.",
    },
    {
        .name  = L2_OPAQUE_TAG_PRESENT_ACTIONs,  /* L2_OPAQUE_TAG_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 opaque tag action if the tag is present.",
    },
    {
        .name  = L2_OPAQUE_TAG_NOT_PRESENT_ACTIONs,  /* L2_OPAQUE_TAG_NOT_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 opaque tag action if the tag is not present.",
    },
    {
        .name  = IS_PHB_MAP_IDs,  /* IS_PHB_MAP_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate a PHB map table index is used.",
    },
    {
        .name  = REMARK_CFIs,  /* REMARK_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable remarking CFI.",
    },
    {
        .name  = OCFIs,  /* OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI. Applicable only if IS_PHB_MAP_ID is disabled.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority. Applicable only if IS_PHB_MAP_ID\n is disabled.\n",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_OTAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_OTAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into logical table PHB_EGR_L2_INT_PRI_TO_OTAG.\n Applicable only if IS_PHB_MAP_ID is enabled.\n",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = VLAN_OUTER_TPID_IDs,  /* VLAN_OUTER_TPID_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_OUTER_TPID logical table index.",
    },
    {
        .name  = CTR_EGR_EFLEX_OBJECTs,  /* CTR_EGR_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter object.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 class ID for egress FP.",
    },
    {
        .name  = ES_IDENTIFIERs,  /* ES_IDENTIFIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ethernet segment (ES) identifier.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_tag_action_nhop_t = {
    .name = L2_TAG_ACTION_NHOPs, /* L2_TAG_ACTION_NHOP */
    .flags = BCMLTD_TABLE_F_TYPE_INDEX_ALLOC,
    .fields = 30,
    .field = bcmltd_l2_tag_action_nhop_t_fields,
    .desc = "The L2_TAG_ACTION_NHOP table provides layer 2 tag controls at L3 nexthop.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_VFI_FDB.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_vfi_fdb_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance assigned to the matched L2 packet.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MAC address of L2 packets.",
    },
    {
        .name  = DEST_TYPEs,  /* DEST_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Destination module ID.\n Applicable only if DEST_TYPE == PORT.\n",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination port ID.\n Applicable only if DEST_TYPE == PORT.\n",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination trunk Group ID.\n Applicable only if DEST_TYPE == TRUNK.\n",
    },
    {
        .name  = L2_MC_GROUP_IDs,  /* L2_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination L2 multicast group ID.\n Applicable only if DEST_TYPE == L2_MC_GRP.\n",
    },
    {
        .name  = TM_MC_GROUP_IDs,  /* TM_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination L3 multicast group ID.\n Applicable only if DEST_TYPE == L3_MC_GRP.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination next hop ID.\n Applicable only if DEST_TYPE == NHOP.\n",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination ECMP group ID.\n Applicable only if DEST_TYPE == ECMP_GRP.\n",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID for the ingress FP.",
    },
    {
        .name  = ASSIGN_INT_PRIs,  /* ASSIGN_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the assignment of the internal priority with\n INT_PRI if the destination MAC address is hit.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Applicable only if ASSIGN_INT_PRI is enabled.",
    },
    {
        .name  = DST_DROPs,  /* DST_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet\n if the destination MAC address is hit.\n",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to CPU\n if the destination MAC address is hit.\n",
    },
    {
        .name  = SRC_DROPs,  /* SRC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet if the source MAC address is hit.",
    },
    {
        .name  = TRUST_SRC_INT_PRIs,  /* TRUST_SRC_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable trusting the internal priority associated with\n the source of the packet over the internal priority associated\n with the packet destination when both the source MAC address and\n the destination MAC address are hit.\n",
    },
    {
        .name  = STATICs,  /* STATIC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the entry is static.",
    },
    {
        .name  = PENDINGs,  /* PENDING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the entry is pending.",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Destination virtual port.",
    },
    {
        .name  = HIT_SRC_MACs,  /* HIT_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the source MAC address is hit.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = HIT_DST_MACs,  /* HIT_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the destination MAC address is hit.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = HIT_LOCAL_SRC_MACs,  /* HIT_LOCAL_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the source MAC address is locally hit.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = L2_DST_BLOCK_IDs,  /* L2_DST_BLOCK_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Read-only field which indicates L2_DST_BLOCK logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_vfi_fdb_t = {
    .name = L2_VFI_FDBs, /* L2_VFI_FDB */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 24,
    .field = bcmltd_l2_vfi_fdb_t_fields,
    .desc = "The L2_VFI_FDB table specifies the L2 forwarding database controls.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_VFI_FDB_CC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_vfi_fdb_cc_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance assigned to the matched L2 packet.",
    },
    {
        .name  = DST_1_TYPEs,  /* DST_1_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type.",
    },
    {
        .name  = DST_1_MODPORTs,  /* DST_1_MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 1 port ID.\n Applicable only if DST_1_TYPE == PORT.\n",
    },
    {
        .name  = DST_1_TRUNK_IDs,  /* DST_1_TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 1 trunk Group ID.\n Applicable only if DST_1_TYPE == TRUNK.\n",
    },
    {
        .name  = DST_1_L2_MC_GROUP_IDs,  /* DST_1_L2_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 1 L2 multicast group ID.\n Applicable only if DST_1_TYPE == L2_MC_GRP.\n",
    },
    {
        .name  = DST_1_TM_MC_GROUP_IDs,  /* DST_1_TM_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 1 L3 multicast group ID.\n Applicable only if DST_1_TYPE == L3_MC_GRP.\n",
    },
    {
        .name  = DST_1_NHOP_IDs,  /* DST_1_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 1 next hop ID.\n Applicable only if DST_1_TYPE == NHOP.\n",
    },
    {
        .name  = DST_1_ECMP_IDs,  /* DST_1_ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 1 ECMP group ID.\n Applicable only if DST_1_TYPE == ECMP_GRP.\n",
    },
    {
        .name  = DST_1_DVPs,  /* DST_1_DVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Destination 1 virtual port.",
    },
    {
        .name  = DST_2_TYPEs,  /* DST_2_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type.",
    },
    {
        .name  = DST_2_MODPORTs,  /* DST_2_MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 2 port ID.\n Applicable only if DST_2_TYPE == PORT.\n",
    },
    {
        .name  = DST_2_TRUNK_IDs,  /* DST_2_TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 2 trunk Group ID.\n Applicable only if DST_2_TYPE == TRUNK.\n",
    },
    {
        .name  = DST_2_L2_MC_GROUP_IDs,  /* DST_2_L2_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 2 L2 multicast group ID.\n Applicable only if DST_2_TYPE == L2_MC_GRP.\n",
    },
    {
        .name  = DST_2_TM_MC_GROUP_IDs,  /* DST_2_TM_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 2 L3 multicast group ID.\n Applicable only if DST_2_TYPE == L3_MC_GRP.\n",
    },
    {
        .name  = DST_2_NHOP_IDs,  /* DST_2_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 2 next hop ID.\n Applicable only if DST_2_TYPE == NHOP.\n",
    },
    {
        .name  = DST_2_ECMP_IDs,  /* DST_2_ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination 2 ECMP group ID.\n Applicable only if DST_2_TYPE == ECMP_GRP.\n",
    },
    {
        .name  = DST_2_DVPs,  /* DST_2_DVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Destination 2 virtual port.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID for the ingress FP.",
    },
    {
        .name  = ASSIGN_INT_PRIs,  /* ASSIGN_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the assignment of the internal priority with INT_PRI.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority.\n Applicable only if ASSIGN_INT_PRI is enabled.\n",
    },
    {
        .name  = DST_DROPs,  /* DST_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet if the VFI is hit.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to CPU if the VFI is hit.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_vfi_fdb_cc_t = {
    .name = L2_VFI_FDB_CCs, /* L2_VFI_FDB_CC */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 22,
    .field = bcmltd_l2_vfi_fdb_cc_t_fields,
    .desc = "The L2_VFI_FDB_CC table specifies the VFI cross connect\n configuration which creates a L2 bridge between a pair of\n ports/trunks.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_VFI_FDB_STATIC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_vfi_fdb_static_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance assigned to the matched L2 packet.",
    },
    {
        .name  = VFI_ID_MASKs,  /* VFI_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "MASK for VFI_ID.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MAC address of the packet.",
    },
    {
        .name  = MAC_ADDR_MASKs,  /* MAC_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC_ADDR.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = DEST_TYPEs,  /* DEST_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Destination module ID.\n Applicable only if DEST_TYPE == PORT.\n",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination port ID.\n Applicable only if DEST_TYPE == PORT.\n",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination trunk Group ID.\n Applicable only if DEST_TYPE == TRUNK.\n",
    },
    {
        .name  = L2_MC_GROUP_IDs,  /* L2_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination L2 multicast group ID.\n Applicable only if DEST_TYPE == L2_MC_GRP.\n",
    },
    {
        .name  = TM_MC_GROUP_IDs,  /* TM_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination L3 multicast group ID.\n Applicable only if DEST_TYPE == L3_MC_GRP.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination next hop ID.\n Applicable only if DEST_TYPE == NHOP.\n",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination ECMP group ID.\n Applicable only if DEST_TYPE == ECMP_GRP.\n",
    },
    {
        .name  = SKIP_LEARNINGs,  /* SKIP_LEARNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable bypass of MAC source address if\n the MAC destination address is hit.\n",
    },
    {
        .name  = BPDUs,  /* BPDU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the entry is a BPDU.",
    },
    {
        .name  = L2_PROTOCOL_PKTs,  /* L2_PROTOCOL_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the packet matches as\n an L2 protocol packet.\n",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID for the ingress FP.",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Destination virtual port.",
    },
    {
        .name  = ASSIGN_INT_PRIs,  /* ASSIGN_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the assignment of the internal priority with PRI\n if the MAC destination address is hit.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet if the MAC destination address is hit.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to CPU if the MAC destination\n address is hit.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l2_vfi_fdb_static_t = {
    .name = L2_VFI_FDB_STATICs, /* L2_VFI_FDB_STATIC */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 22,
    .field = bcmltd_l2_vfi_fdb_static_t_fields,
    .desc = "The L2_VFI_FDB_STATIC table specifies the static L2 forwarding database\n controls and BPDU packets controls.\n Unlike the L2_VFI_FDB table, the MAC address entries populated in this table\n will not prevent those same MAC addresses from being learnt and reported\n in the L2_VFI_LEARN_DATA table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_VFI_LEARN_DATA.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_vfi_learn_data_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Packet processor pipe number.",
    },
    {
        .name  = L2_VFI_LEARN_DATA_IDs,  /* L2_VFI_LEARN_DATA_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L2_VFI_LEARN_DATA logical table index.",
    },
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance assigned to the matched L2 packet.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "MAC address of the L2 packet.",
    },
    {
        .name  = SVPs,  /* SVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Source virtual port.",
    },
    {
        .name  = SRC_TYPEs,  /* SRC_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Source type.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Source module ID.\n Applicable only if SRC_TYPE == PORT.\n",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source port ID.\n Applicable only if SRC_TYPE == PORT.\n",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source trunk Group ID.\n Applicable only if SRC_TYPE == TRUNK.\n",
    },
    {
        .name  = L2_MC_GROUP_IDs,  /* L2_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source L2 multicast group ID.\n Applicable only if SRC_TYPE == L2_MC_GRP.\n",
    },
    {
        .name  = TM_MC_GROUP_IDs,  /* TM_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source L3 multicast group ID.\n Applicable only if SRC_TYPE == L3_MC_GRP.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source next hop ID.\n Applicable only if SRC_TYPE == NHOP.\n",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source ECMP group ID.\n Applicable only if SRC_TYPE == ECMP_GRP.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l2_vfi_learn_data_t = {
    .name = L2_VFI_LEARN_DATAs, /* L2_VFI_LEARN_DATA */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_l2_vfi_learn_data_t_fields,
    .desc = "The L2_VFI_LEARN_DATA table is used to report learned MAC addresses.\n Once an application retrieves the reported MAC addresses from this table,\n it must delete existing table entries in order to accommodate learning of\n new MAC addresses.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_VFI_MY_STATION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_vfi_my_station_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance assigned to the matched L2 packet.",
    },
    {
        .name  = VFI_ID_MASKs,  /* VFI_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "MASK for VFI_ID.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the matched L2 packet.",
    },
    {
        .name  = MAC_ADDR_MASKs,  /* MAC_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC_ADDR.",
    },
    {
        .name  = OVERLAYs,  /* OVERLAY */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate overlay termination.",
    },
    {
        .name  = OVERLAY_MASKs,  /* OVERLAY_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for OVERLAY.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = IPV6_TERMINATIONs,  /* IPV6_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 unicast packet termination.",
    },
    {
        .name  = IPV6_MC_TERMINATIONs,  /* IPV6_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 multicast packet termination.",
    },
    {
        .name  = IPV4_TERMINATIONs,  /* IPV4_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 unicast packet termination.",
    },
    {
        .name  = IPV4_MC_TERMINATIONs,  /* IPV4_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 multicast packet termination.",
    },
    {
        .name  = ARP_RARP_TERMINATIONs,  /* ARP_RARP_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ARP or RARP packet termination.",
    },
    {
        .name  = MPLS_TERMINATIONs,  /* MPLS_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS packet termination.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to the CPU.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_vfi_my_station_t = {
    .name = L2_VFI_MY_STATIONs, /* L2_VFI_MY_STATION */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 15,
    .field = bcmltd_l2_vfi_my_station_t_fields,
    .desc = "The L2_VFI_MY_STATION table specifies per-packet destination MAC address\n behavior for underlay or overlay packets that are either sourced from\n trunks or ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_VFI_MY_STATION_MODPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_vfi_my_station_modport_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance assigned to the matched L2 packet.",
    },
    {
        .name  = VFI_ID_MASKs,  /* VFI_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "MASK for VFI_ID.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the matched L2 packet.",
    },
    {
        .name  = MAC_ADDR_MASKs,  /* MAC_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC_ADDR.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Source module ID of the matched L2 packet.",
    },
    {
        .name  = MODID_MASKs,  /* MODID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for MODID.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Source port ID of the matched L2 packet.",
    },
    {
        .name  = MODPORT_MASKs,  /* MODPORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for MODPORT.",
    },
    {
        .name  = OVERLAYs,  /* OVERLAY */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate overlay termination.",
    },
    {
        .name  = OVERLAY_MASKs,  /* OVERLAY_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for OVERLAY.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = IPV6_TERMINATIONs,  /* IPV6_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 unicast packet termination.",
    },
    {
        .name  = IPV6_MC_TERMINATIONs,  /* IPV6_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 multicast packet termination.",
    },
    {
        .name  = IPV4_TERMINATIONs,  /* IPV4_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 unicast packet termination.",
    },
    {
        .name  = IPV4_MC_TERMINATIONs,  /* IPV4_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 multicast packet termination.",
    },
    {
        .name  = ARP_RARP_TERMINATIONs,  /* ARP_RARP_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ARP or RARP packet termination.",
    },
    {
        .name  = MPLS_TERMINATIONs,  /* MPLS_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS packet termination.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to the CPU.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_vfi_my_station_modport_t = {
    .name = L2_VFI_MY_STATION_MODPORTs, /* L2_VFI_MY_STATION_MODPORT */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 19,
    .field = bcmltd_l2_vfi_my_station_modport_t_fields,
    .desc = "The L2_VFI_MY_STATION_MODPORT table specifies per-packet destination MAC\n address behavior for underlay or overlay packets that are only sourced\n from ports (not trunks).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_VFI_MY_STATION_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_vfi_my_station_trunk_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance assigned to the matched L2 packet.",
    },
    {
        .name  = VFI_ID_MASKs,  /* VFI_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "MASK for VFI_ID.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the matched L2 packet.",
    },
    {
        .name  = MAC_ADDR_MASKs,  /* MAC_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC_ADDR.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = TRUNK_ID_MASKs,  /* TRUNK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for TRUNK_ID.",
    },
    {
        .name  = OVERLAYs,  /* OVERLAY */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate overlay termination.",
    },
    {
        .name  = OVERLAY_MASKs,  /* OVERLAY_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for OVERLAY.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = IPV6_TERMINATIONs,  /* IPV6_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 unicast packet termination.",
    },
    {
        .name  = IPV6_MC_TERMINATIONs,  /* IPV6_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 multicast packet termination.",
    },
    {
        .name  = IPV4_TERMINATIONs,  /* IPV4_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 unicast packet termination.",
    },
    {
        .name  = IPV4_MC_TERMINATIONs,  /* IPV4_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 multicast packet termination.",
    },
    {
        .name  = ARP_RARP_TERMINATIONs,  /* ARP_RARP_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ARP or RARP packet termination.",
    },
    {
        .name  = MPLS_TERMINATIONs,  /* MPLS_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS packet termination.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to the CPU.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_vfi_my_station_trunk_t = {
    .name = L2_VFI_MY_STATION_TRUNKs, /* L2_VFI_MY_STATION_TRUNK */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 17,
    .field = bcmltd_l2_vfi_my_station_trunk_t_fields,
    .desc = "The L2_VFI_MY_STATION_TRUNK table specifies per-packet destination MAC\n address behavior for underlay or overlay packets that are only sourced\n from trunks (not ports).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_VFI_UNDERLAY_MY_STATION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_vfi_underlay_my_station_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance assigned to the matched L2 packet.",
    },
    {
        .name  = VFI_ID_MASKs,  /* VFI_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "MASK for VFI_ID.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the matched L2 packet.",
    },
    {
        .name  = MAC_ADDR_MASKs,  /* MAC_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC_ADDR.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = IPV6_TERMINATIONs,  /* IPV6_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 unicast packet termination.",
    },
    {
        .name  = IPV6_MC_TERMINATIONs,  /* IPV6_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 multicast packet termination.",
    },
    {
        .name  = IPV4_TERMINATIONs,  /* IPV4_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 unicast packet termination.",
    },
    {
        .name  = IPV4_MC_TERMINATIONs,  /* IPV4_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 multicast packet termination.",
    },
    {
        .name  = ARP_RARP_TERMINATIONs,  /* ARP_RARP_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ARP or RARP packet termination.",
    },
    {
        .name  = MPLS_TERMINATIONs,  /* MPLS_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS packet termination.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to the CPU.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_vfi_underlay_my_station_t = {
    .name = L2_VFI_UNDERLAY_MY_STATIONs, /* L2_VFI_UNDERLAY_MY_STATION */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 13,
    .field = bcmltd_l2_vfi_underlay_my_station_t_fields,
    .desc = "The L2_VFI_UNDERLAY_MY_STATION table specifies per-packet destination MAC\n address behavior for underlay packets that are either sourced from trunks\n or ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_VFI_UNDERLAY_MY_STATION_MODPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_vfi_underlay_my_station_modport_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance assigned to the matched L2 packet.",
    },
    {
        .name  = VFI_ID_MASKs,  /* VFI_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "MASK for VFI_ID.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the matched L2 packet.",
    },
    {
        .name  = MAC_ADDR_MASKs,  /* MAC_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC_ADDR.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Source module ID of the matched L2 packet.",
    },
    {
        .name  = MODID_MASKs,  /* MODID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for MODID.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Source port ID of the matched L2 packet.",
    },
    {
        .name  = MODPORT_MASKs,  /* MODPORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for MODPORT.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = IPV6_TERMINATIONs,  /* IPV6_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 unicast packet termination.",
    },
    {
        .name  = IPV6_MC_TERMINATIONs,  /* IPV6_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 multicast packet termination.",
    },
    {
        .name  = IPV4_TERMINATIONs,  /* IPV4_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 unicast packet termination.",
    },
    {
        .name  = IPV4_MC_TERMINATIONs,  /* IPV4_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 multicast packet termination.",
    },
    {
        .name  = ARP_RARP_TERMINATIONs,  /* ARP_RARP_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ARP or RARP packet termination.",
    },
    {
        .name  = MPLS_TERMINATIONs,  /* MPLS_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS packet termination.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to the CPU.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_vfi_underlay_my_station_modport_t = {
    .name = L2_VFI_UNDERLAY_MY_STATION_MODPORTs, /* L2_VFI_UNDERLAY_MY_STATION_MODPORT */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 17,
    .field = bcmltd_l2_vfi_underlay_my_station_modport_t_fields,
    .desc = "The L2_VFI_UNDERLAY_MY_STATION_MODPORT table specifies per-packet\n destination MAC address behavior for underlay packets that are only\n sourced from ports (not trunks).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l2/L2_VFI_UNDERLAY_MY_STATION_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l2_vfi_underlay_my_station_trunk_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance assigned to the matched L2 packet.",
    },
    {
        .name  = VFI_ID_MASKs,  /* VFI_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "MASK for VFI_ID.",
    },
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the matched L2 packet.",
    },
    {
        .name  = MAC_ADDR_MASKs,  /* MAC_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC_ADDR.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = TRUNK_ID_MASKs,  /* TRUNK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for TRUNK_ID.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = IPV6_TERMINATIONs,  /* IPV6_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 unicast packet termination.",
    },
    {
        .name  = IPV6_MC_TERMINATIONs,  /* IPV6_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 multicast packet termination.",
    },
    {
        .name  = IPV4_TERMINATIONs,  /* IPV4_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 unicast packet termination.",
    },
    {
        .name  = IPV4_MC_TERMINATIONs,  /* IPV4_MC_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 multicast packet termination.",
    },
    {
        .name  = ARP_RARP_TERMINATIONs,  /* ARP_RARP_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ARP or RARP packet termination.",
    },
    {
        .name  = MPLS_TERMINATIONs,  /* MPLS_TERMINATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS packet termination.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of the packet to the CPU.",
    },
};
const bcmltd_table_rep_t bcmltd_l2_vfi_underlay_my_station_trunk_t = {
    .name = L2_VFI_UNDERLAY_MY_STATION_TRUNKs, /* L2_VFI_UNDERLAY_MY_STATION_TRUNK */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 15,
    .field = bcmltd_l2_vfi_underlay_my_station_trunk_t_fields,
    .desc = "The L2_VFI_UNDERLAY_MY_STATION_TRUNK table specifies per-packet\n destination MAC address behavior for underlay packets that are only\n sourced from trunks (not ports).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_ALPM_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_alpm_control_t_fields[] = {
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field which reflects the operational state of the entry.\n  The OPERATIONAL_STATE of the entry becomes invalid if the\n  configuration conflicts with settings in the DEVICE_EM_GROUP table.\n  For example, multi-level ALPM mode is configured in L3_ALPM_CONTROL\n  but no banks are allocated for ALPM in DEVICE_EM_GROUP.\n",
    },
    {
        .name  = ALPM_MODEs,  /* ALPM_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "ALPM mode.",
    },
    {
        .name  = NUM_DB_0_LEVELSs,  /* NUM_DB_0_LEVELS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of ALPM levels in database 0.\n Increasing the levels increases the total number of\n supported ALPM route entries of database 0.\n",
    },
    {
        .name  = NUM_DB_1_LEVELSs,  /* NUM_DB_1_LEVELS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of ALPM levels in database 1.",
    },
    {
        .name  = NUM_DB_2_LEVELSs,  /* NUM_DB_2_LEVELS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of ALPM levels in database 2.",
    },
    {
        .name  = NUM_DB_3_LEVELSs,  /* NUM_DB_3_LEVELS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of ALPM levels in database 3.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_0s,  /* KEY_INPUT_LEVEL_1_BLOCK_0 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 0.\n Level 1 resources are partitioned into several blocks,\n each with its own key input and database. This\n provides flexibility in terms of level-1\n capacity and hence the overall route capacity.\n The key input determines the packing mode, wich can\n be customized in order to achieve maximum capacity for\n specific route databases.\n",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_1s,  /* KEY_INPUT_LEVEL_1_BLOCK_1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 1.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_2s,  /* KEY_INPUT_LEVEL_1_BLOCK_2 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 2.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_3s,  /* KEY_INPUT_LEVEL_1_BLOCK_3 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 3.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_4s,  /* KEY_INPUT_LEVEL_1_BLOCK_4 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 4.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_5s,  /* KEY_INPUT_LEVEL_1_BLOCK_5 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 5.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_6s,  /* KEY_INPUT_LEVEL_1_BLOCK_6 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 6.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_7s,  /* KEY_INPUT_LEVEL_1_BLOCK_7 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 7.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_8s,  /* KEY_INPUT_LEVEL_1_BLOCK_8 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 8.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_9s,  /* KEY_INPUT_LEVEL_1_BLOCK_9 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 9.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_0s,  /* DB_LEVEL_1_BLOCK_0 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 0.\n Level 1 resources are partitioned into several blocks,\n each with its own key input and database. This\n provides flexibility in terms of level-1\n capacity and hence the overall route capacity.\n The DB_LEVEL_1 controls are applicable only if\n ALPM_MODE=ALPM_MODE_PARALLEL. Each level-1 block\n can be used by either DB_0 or DB_1.\n It is recommended that the lower numbered blocks\n are specified for DB_0 with the remaining blocks\n specified for DB_1.\n If ALPM_MODE=ALPM_MODE_COMBINED, all level-1\n blocks are used by DB_0 and the DB_LEVEL_1 controls\n are ignored.\n",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_1s,  /* DB_LEVEL_1_BLOCK_1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 1.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_2s,  /* DB_LEVEL_1_BLOCK_2 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 2.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_3s,  /* DB_LEVEL_1_BLOCK_3 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 3.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_4s,  /* DB_LEVEL_1_BLOCK_4 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 4.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_5s,  /* DB_LEVEL_1_BLOCK_5 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 5.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_6s,  /* DB_LEVEL_1_BLOCK_6 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 6.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_7s,  /* DB_LEVEL_1_BLOCK_7 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 7.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_8s,  /* DB_LEVEL_1_BLOCK_8 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 8.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_9s,  /* DB_LEVEL_1_BLOCK_9 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 9.",
    },
    {
        .name  = HIT_MODEs,  /* HIT_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hit support mode.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination value, used in conjunction with DESTINATION_MASK\n in order to determine the destination type for an L3 UC route\n lookup result.\n Applicable only when the L3 UC route is occupying a\n reduced policy mode.\n",
    },
    {
        .name  = DESTINATION_MASKs,  /* DESTINATION_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination mask, used in conjunction with DESTINATION\n in order to determine the destination type for an L3 UC route\n lookup result.\n Applicable only when the L3 UC route is occupying a\n reduced policy mode.\n",
    },
    {
        .name  = DESTINATION_TYPE_MATCHs,  /* DESTINATION_TYPE_MATCH */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type when the DESTINATION value from an L3 UC route\n lookup result (L3_UC_ROUTE.DESTINATION) meets the\n following criteria:\n (L3_UC_ROUTE.DESTINATION & DESTINATION_MASK) ==\n (DESTINATION & DESTINATION_MASK).\n Applicable only when the L3 UC route is occupying a\n reduced policy mode.\n",
    },
    {
        .name  = DESTINATION_TYPE_NON_MATCHs,  /* DESTINATION_TYPE_NON_MATCH */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type when the DESTINATION value from an L3 UC route\n lookup result (L3_UC_ROUTE.DESTINATION) meets the\n following criteria:\n (L3_UC_ROUTE.DESTINATION & DESTINATION_MASK) !=\n (DESTINATION & DESTINATION_MASK).\n Applicable only when the L3 UC route is occupying a\n reduced policy mode.\n",
    },
    {
        .name  = IPV4_UC_STRENGTH_PROFILE_INDEXs,  /* IPV4_UC_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv4 unicast global low routes strength profile index.",
    },
    {
        .name  = IPV4_UC_VRF_STRENGTH_PROFILE_INDEXs,  /* IPV4_UC_VRF_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv4 unicast private routes strength profile index.",
    },
    {
        .name  = IPV4_UC_OVERRIDE_STRENGTH_PROFILE_INDEXs,  /* IPV4_UC_OVERRIDE_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv4 unicast override routes strength profile index.",
    },
    {
        .name  = IPV6_UC_STRENGTH_PROFILE_INDEXs,  /* IPV6_UC_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv6 unicast global low routes strength profile index.",
    },
    {
        .name  = IPV6_UC_VRF_STRENGTH_PROFILE_INDEXs,  /* IPV6_UC_VRF_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv6 unicast private routes strength profile index.",
    },
    {
        .name  = IPV6_UC_OVERRIDE_STRENGTH_PROFILE_INDEXs,  /* IPV6_UC_OVERRIDE_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv6 unicast override routes strength profile index.",
    },
    {
        .name  = IPV4_COMPRESSION_STRENGTH_PROFILE_INDEXs,  /* IPV4_COMPRESSION_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv4 compression strength profile index.",
    },
    {
        .name  = IPV6_COMPRESSION_STRENGTH_PROFILE_INDEXs,  /* IPV6_COMPRESSION_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv6 compression strength profile index.",
    },
    {
        .name  = LARGE_VRFs,  /* LARGE_VRF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable large vrf.",
    },
    {
        .name  = COMP_KEY_TYPEs,  /* COMP_KEY_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Compression key type.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_alpm_control_t = {
    .name = L3_ALPM_CONTROLs, /* L3_ALPM_CONTROL */
    .flags = 0,
    .fields = 41,
    .field = bcmltd_l3_alpm_control_t_fields,
    .desc = "The L3_ALPM_CONTROL table is used to specify device level ALPM\n controls.\n When ALPM_MODE=ALPM_MODE_COMBINED, only a single database (DB_0)\n is used for global override, global and VRF routes.\n When ALPM_MODE=ALPM_MODE_PARALLEL, two databases (DB_0 and DB_1)\n are used. Global override and global routes share DB_1, VRF\n routes are contained in DB_0.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_ALPM_CONTROL_MTOP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_alpm_control_mtop_t_fields[] = {
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field which reflects the operational state of the entry.\n  The OPERATIONAL_STATE of the entry becomes invalid if the\n  configuration conflicts with settings in the DEVICE_EM_GROUP table.\n  For example, multi-level ALPM mode is configured in\n  L3_ALPM_CONTROL_MTOP but no banks are allocated\n  for ALPM in DEVICE_EM_GROUP.\n",
    },
    {
        .name  = ALPM_MODEs,  /* ALPM_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "ALPM mode.",
    },
    {
        .name  = NUM_DB_0_LEVELSs,  /* NUM_DB_0_LEVELS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of ALPM levels in database 0.\n Increasing the levels increases the total number of\n supported ALPM route entries of database 0.\n",
    },
    {
        .name  = NUM_DB_1_LEVELSs,  /* NUM_DB_1_LEVELS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of ALPM levels in database 1.",
    },
    {
        .name  = NUM_DB_2_LEVELSs,  /* NUM_DB_2_LEVELS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of ALPM levels in database 2.",
    },
    {
        .name  = NUM_DB_3_LEVELSs,  /* NUM_DB_3_LEVELS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of ALPM levels in database 3.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_0s,  /* KEY_INPUT_LEVEL_1_BLOCK_0 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 0.\n Level 1 resources are partitioned into several blocks,\n each with its own key input and database. This\n provides flexibility in terms of level-1\n capacity and hence the overall route capacity.\n The key input determines the packing mode, wich can\n be customized in order to achieve maximum capacity for\n specific route databases.\n",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_1s,  /* KEY_INPUT_LEVEL_1_BLOCK_1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 1.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_2s,  /* KEY_INPUT_LEVEL_1_BLOCK_2 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 2.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_3s,  /* KEY_INPUT_LEVEL_1_BLOCK_3 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 3.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_4s,  /* KEY_INPUT_LEVEL_1_BLOCK_4 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 4.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_5s,  /* KEY_INPUT_LEVEL_1_BLOCK_5 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 5.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_6s,  /* KEY_INPUT_LEVEL_1_BLOCK_6 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 6.",
    },
    {
        .name  = KEY_INPUT_LEVEL_1_BLOCK_7s,  /* KEY_INPUT_LEVEL_1_BLOCK_7 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key input for level 1 block 7.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_0s,  /* DB_LEVEL_1_BLOCK_0 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 0.\n Level 1 resources are partitioned into several blocks,\n each with its own key input and database. This\n provides flexibility in terms of level-1\n capacity and hence the overall route capacity.\n The DB_LEVEL_1 controls are applicable only if\n ALPM_MODE=ALPM_MODE_PARALLEL. Each level-1 block\n can be used by either DB_0 or DB_1.\n It is recommended that the lower numbered blocks\n are specified for DB_0 with the remaining blocks\n specified for DB_1.\n If ALPM_MODE=ALPM_MODE_COMBINED, all level-1\n blocks are used by DB_0 and the DB_LEVEL_1 controls\n are ignored.\n",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_1s,  /* DB_LEVEL_1_BLOCK_1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 1.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_2s,  /* DB_LEVEL_1_BLOCK_2 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 2.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_3s,  /* DB_LEVEL_1_BLOCK_3 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 3.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_4s,  /* DB_LEVEL_1_BLOCK_4 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 4.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_5s,  /* DB_LEVEL_1_BLOCK_5 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 5.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_6s,  /* DB_LEVEL_1_BLOCK_6 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 6.",
    },
    {
        .name  = DB_LEVEL_1_BLOCK_7s,  /* DB_LEVEL_1_BLOCK_7 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Database for level 1 block 7.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination value, used in conjunction with DESTINATION_MASK\n in order to determine the destination type for an L3 UC route\n lookup result.\n Applicable only when the L3 UC route is occupying a\n reduced policy mode.\n",
    },
    {
        .name  = DESTINATION_MASKs,  /* DESTINATION_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination mask, used in conjunction with DESTINATION\n in order to determine the destination type for an L3 UC route\n lookup result.\n Applicable only when the L3 UC route is occupying a\n reduced policy mode.\n",
    },
    {
        .name  = DESTINATION_TYPE_MATCHs,  /* DESTINATION_TYPE_MATCH */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type when the DESTINATION value from an L3 UC route\n lookup result (L3_UC_ROUTE.DESTINATION) meets the\n following criteria:\n (L3_UC_ROUTE.DESTINATION & DESTINATION_MASK) ==\n (DESTINATION & DESTINATION_MASK).\n Applicable only when the L3 UC route is occupying a\n reduced policy mode.\n",
    },
    {
        .name  = DESTINATION_TYPE_NON_MATCHs,  /* DESTINATION_TYPE_NON_MATCH */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type when the DESTINATION value from an L3 UC route\n lookup result (L3_UC_ROUTE.DESTINATION) meets the\n following criteria:\n (L3_UC_ROUTE.DESTINATION & DESTINATION_MASK) !=\n (DESTINATION & DESTINATION_MASK).\n Applicable only when the L3 UC route is occupying a\n reduced policy mode.\n",
    },
    {
        .name  = IPV4_UC_STRENGTH_PROFILE_INDEXs,  /* IPV4_UC_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv4 unicast global low routes strength profile index.",
    },
    {
        .name  = IPV4_UC_VRF_STRENGTH_PROFILE_INDEXs,  /* IPV4_UC_VRF_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv4 unicast private routes strength profile index.",
    },
    {
        .name  = IPV4_UC_OVERRIDE_STRENGTH_PROFILE_INDEXs,  /* IPV4_UC_OVERRIDE_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv4 unicast override routes strength profile index.",
    },
    {
        .name  = IPV6_UC_STRENGTH_PROFILE_INDEXs,  /* IPV6_UC_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv6 unicast global low routes strength profile index.",
    },
    {
        .name  = IPV6_UC_VRF_STRENGTH_PROFILE_INDEXs,  /* IPV6_UC_VRF_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv6 unicast private routes strength profile index.",
    },
    {
        .name  = IPV6_UC_OVERRIDE_STRENGTH_PROFILE_INDEXs,  /* IPV6_UC_OVERRIDE_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv6 unicast override routes strength profile index.",
    },
    {
        .name  = IPV4_COMPRESSION_STRENGTH_PROFILE_INDEXs,  /* IPV4_COMPRESSION_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv4 compression strength profile index.",
    },
    {
        .name  = IPV6_COMPRESSION_STRENGTH_PROFILE_INDEXs,  /* IPV6_COMPRESSION_STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "IPv6 compression strength profile index.",
    },
    {
        .name  = LARGE_VRFs,  /* LARGE_VRF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable large vrf.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_alpm_control_mtop_t = {
    .name = L3_ALPM_CONTROL_MTOPs, /* L3_ALPM_CONTROL_MTOP */
    .flags = 0,
    .fields = 35,
    .field = bcmltd_l3_alpm_control_mtop_t_fields,
    .desc = "The L3_ALPM_CONTROL_MTOP table is used to specify device level ALPM\n controls.\n When ALPM_MODE=ALPM_MODE_COMBINED, only a single database (DB_0)\n is used for global override, global and VRF routes.\n When ALPM_MODE=ALPM_MODE_PARALLEL, two databases (DB_0 and DB_1)\n are used. Global override and global routes share DB_1, VRF\n routes are contained in DB_0.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_ALPM_LEVEL_1_USAGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_alpm_level_1_usage_t_fields[] = {
    {
        .name  = KEY_TYPEs,  /* KEY_TYPE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Level 1 entry key type.",
    },
    {
        .name  = MAX_ENTRIESs,  /* MAX_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Absolute maximum number of entries.",
    },
    {
        .name  = INUSE_ENTRIESs,  /* INUSE_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "In use number of entries.",
    },
    {
        .name  = ENTRY_UTILIZATIONs,  /* ENTRY_UTILIZATION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "A result of INUSE_ENTRIES * 100 / MAX_ENTRIES.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_alpm_level_1_usage_t = {
    .name = L3_ALPM_LEVEL_1_USAGEs, /* L3_ALPM_LEVEL_1_USAGE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l3_alpm_level_1_usage_t_fields,
    .desc = "The L3_ALPM_LEVEL_1_USAGE table is used to retrieve the ALPM level-1\n resource usage statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_ALPM_LEVEL_2_USAGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_alpm_level_2_usage_t_fields[] = {
    {
        .name  = DBs,  /* DB */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Level 2 database.",
    },
    {
        .name  = MAX_RAW_BUCKETSs,  /* MAX_RAW_BUCKETS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Absolute maximum number of raw buckets.",
    },
    {
        .name  = INUSE_RAW_BUCKETSs,  /* INUSE_RAW_BUCKETS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "In use number of raw buckets.",
    },
    {
        .name  = RAW_BUCKET_UTILIZATIONs,  /* RAW_BUCKET_UTILIZATION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "A result of INUSE_RAW_BUCKETS * 100 / MAX_RAW_BUCKETS.",
    },
    {
        .name  = MAX_ENTRIESs,  /* MAX_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of entries relative to INUSE_RAW_BUCKETS.",
    },
    {
        .name  = INUSE_ENTRIESs,  /* INUSE_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "In use number of entries relative to INUSE_RAW_BUCKETS.",
    },
    {
        .name  = ENTRY_UTILIZATIONs,  /* ENTRY_UTILIZATION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "A result of INUSE_ENTRIES * 100 / MAX_ENTRIES.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_alpm_level_2_usage_t = {
    .name = L3_ALPM_LEVEL_2_USAGEs, /* L3_ALPM_LEVEL_2_USAGE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_l3_alpm_level_2_usage_t_fields,
    .desc = "The L3_ALPM_LEVEL_2_USAGE table is used to retrieve the ALPM level-2\n resource usage statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_ALPM_LEVEL_3_USAGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_alpm_level_3_usage_t_fields[] = {
    {
        .name  = DBs,  /* DB */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Level 3 database.",
    },
    {
        .name  = MAX_RAW_BUCKETSs,  /* MAX_RAW_BUCKETS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Absolute maximum number of raw buckets.",
    },
    {
        .name  = INUSE_RAW_BUCKETSs,  /* INUSE_RAW_BUCKETS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "In use number of raw buckets.",
    },
    {
        .name  = RAW_BUCKET_UTILIZATIONs,  /* RAW_BUCKET_UTILIZATION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "A result INUSE_RAW_BUCKETS * 100 / MAX_RAW_BUCKETS.",
    },
    {
        .name  = MAX_ENTRIESs,  /* MAX_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of entries relative to INUSE_RAW_BUCKETS.",
    },
    {
        .name  = INUSE_ENTRIESs,  /* INUSE_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "In use maximum number of entries relative to INUSE_RAW_BUCKETS.",
    },
    {
        .name  = ENTRY_UTILIZATIONs,  /* ENTRY_UTILIZATION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "A result of INUSE_ENTRIES * 100 / MAX_ENTRIES.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_alpm_level_3_usage_t = {
    .name = L3_ALPM_LEVEL_3_USAGEs, /* L3_ALPM_LEVEL_3_USAGE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_l3_alpm_level_3_usage_t_fields,
    .desc = "The L3_ALPM_LEVEL_3_USAGE table is used to retrieve the ALPM level-3\n resource usage statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_EIF.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_eif_t_fields[] = {
    {
        .name  = L3_EIF_IDs,  /* L3_EIF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Layer 3 unicast egress interface identifier.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to be used for replacement.",
    },
    {
        .name  = MAC_SAs,  /* MAC_SA */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "MAC Address to be used for SA Replacement.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TTL Threshold to be used for L3 TTL Checks.",
    },
    {
        .name  = PHB_EGR_DSCP_ACTIONs,  /* PHB_EGR_DSCP_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies whether DSCP value of the packet should be changed.",
    },
    {
        .name  = DSCPs,  /* DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "DSCP value to set in the packet when DSCP_ACTION == FIXED.",
    },
    {
        .name  = PHB_EGR_IP_INT_PRI_TO_DSCP_IDs,  /* PHB_EGR_IP_INT_PRI_TO_DSCP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_IP_INT_PRI_TO_DSCP logical table index. Applicable only if\n PHB_EGR_DSCP_ACTION == MAP.\n",
    },
    {
        .name  = PHB_EGR_L2_OTAG_ACTIONs,  /* PHB_EGR_L2_OTAG_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies whether the 802.1p priority and CFI values of the outer tag\n of the packet should be changed.\n",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer 802.1p priority value.",
    },
    {
        .name  = OCFIs,  /* OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer CFI value",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_OTAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_OTAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_L2_INT_PRI_TO_OTAG logical table index.\n Applicable only if PHB_EGR_L2_OTAG_ACTION == MAP.\n",
    },
    {
        .name  = PHB_EGR_L2_ITAG_ACTIONs,  /* PHB_EGR_L2_ITAG_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies whether the 802.1p priority and CFI values of the inner tag\n of the packet should be changed.\n",
    },
    {
        .name  = IPRIs,  /* IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner 802.1p priority value.",
    },
    {
        .name  = ICFIs,  /* ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner CFI value",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_ITAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_ITAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_L2_INT_PRI_TO_ITAG logical table index.\n Applicable only if PHB_EGR_L2_ITAG_ACTION == MAP.\n",
    },
    {
        .name  = L2_SWITCHs,  /* L2_SWITCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if the packet should only be L2 switched and only\n L2 modifications needs to be done.\n",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 Next Hop Class ID for match in Egress FP.",
    },
    {
        .name  = TNL_TYPEs,  /* TNL_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Tunnel type. Applicable only for L3 tunnel interfaces.",
    },
    {
        .name  = TNL_IPV4_ENCAP_INDEXs,  /* TNL_IPV4_ENCAP_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "IPv4 tunnel encapsulation instance as specified in\n TNL_IPV4_ENCAP.ENCAP_INDEX. Applicable only when\n TNL_TYPE == IPV4.\n",
    },
    {
        .name  = TNL_IPV6_ENCAP_INDEXs,  /* TNL_IPV6_ENCAP_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "IPv6 tunnel encapsulation instance as specified in\n TNL_IPV6_ENCAP.ENCAP_INDEX. Applicable only when\n TNL_TYPE == IPV6.\n",
    },
    {
        .name  = TNL_MPLS_ENCAP_INDEXs,  /* TNL_MPLS_ENCAP_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "MPLS tunnel encapsulation instance as specified in\n TNL_MPLS_ENCAP.ENCAP_INDEX. Applicable only when\n TNL_TYPE == MPLS.\n",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Logical table VFI index. VFI assigned for egress pipeline.",
    },
    {
        .name  = EGR_ADAPT_LOOKUP_KEY_MODEs,  /* EGR_ADAPT_LOOKUP_KEY_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Key mode for the egress adaptation lookup.",
    },
    {
        .name  = EGR_ADAPT_PORT_GRP_MODEs,  /* EGR_ADAPT_PORT_GRP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Port group mode for the egress adaptation lookup.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_eif_t = {
    .name = L3_EIFs, /* L3_EIF */
    .flags = 0,
    .fields = 25,
    .field = bcmltd_l3_eif_t_fields,
    .desc = "The L3_EIF table is used to configure L3 egress interfaces.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_HEADER_VALIDATION_1_DST_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_header_validation_1_dst_ipv4_t_fields[] = {
    {
        .name  = L3_HEADER_VALIDATION_1_DST_IPV4_IDs,  /* L3_HEADER_VALIDATION_1_DST_IPV4_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the destination IPv4 address validation table.",
    },
    {
        .name  = MASKs,  /* MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask to be applied to the destination IPv4 address\n before comparing.\n",
    },
    {
        .name  = VALUEs,  /* VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Value to be compared with the destination IPv4 address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified destination IPv4 address type. Applicable when\n the destination IPv4 address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_header_validation_1_dst_ipv4_t = {
    .name = L3_HEADER_VALIDATION_1_DST_IPV4s, /* L3_HEADER_VALIDATION_1_DST_IPV4 */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l3_header_validation_1_dst_ipv4_t_fields,
    .desc = "The L3_HEADER_VALIDATION_1_DST_IPV4 table specifies L3\n destination IPv4 address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_HEADER_VALIDATION_1_DST_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_header_validation_1_dst_ipv6_t_fields[] = {
    {
        .name  = L3_HEADER_VALIDATION_1_DST_IPV6_IDs,  /* L3_HEADER_VALIDATION_1_DST_IPV6_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the destination IPv6 address validation table.",
    },
    {
        .name  = MASK_UPPERs,  /* MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask to be applied to the destination IPv6 address\n before comparing.\n",
    },
    {
        .name  = MASK_LOWERs,  /* MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask to be applied to the destination IPv6 address\n before comparing.\n",
    },
    {
        .name  = VALUE_UPPERs,  /* VALUE_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Value to be compared with the destination IPv6 address.",
    },
    {
        .name  = VALUE_LOWERs,  /* VALUE_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Value to be compared with the destination IPv6 address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified destination IPv6 address type. Applicable when\n the destination IPv6 address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_header_validation_1_dst_ipv6_t = {
    .name = L3_HEADER_VALIDATION_1_DST_IPV6s, /* L3_HEADER_VALIDATION_1_DST_IPV6 */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_l3_header_validation_1_dst_ipv6_t_fields,
    .desc = "The L3_HEADER_VALIDATION_1_DST_IPV6 table specifies L3\n destination IPv6 address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_HEADER_VALIDATION_1_SRC_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_header_validation_1_src_ipv4_t_fields[] = {
    {
        .name  = L3_HEADER_VALIDATION_1_SRC_IPV4_IDs,  /* L3_HEADER_VALIDATION_1_SRC_IPV4_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the source IPv4 address validation table.",
    },
    {
        .name  = MASKs,  /* MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask to be applied to the source IPv4 address\n before comparing.\n",
    },
    {
        .name  = VALUEs,  /* VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Value to be compared with the source IPv4 address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified source IPv4 address type. Applicable when\n the source IPv4 address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_header_validation_1_src_ipv4_t = {
    .name = L3_HEADER_VALIDATION_1_SRC_IPV4s, /* L3_HEADER_VALIDATION_1_SRC_IPV4 */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l3_header_validation_1_src_ipv4_t_fields,
    .desc = "The L3_HEADER_VALIDATION_1_SRC_IPV4 table specifies L3\n source IPv4 address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_HEADER_VALIDATION_1_SRC_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_header_validation_1_src_ipv6_t_fields[] = {
    {
        .name  = L3_HEADER_VALIDATION_1_SRC_IPV6_IDs,  /* L3_HEADER_VALIDATION_1_SRC_IPV6_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the source IPv6 address validation table.",
    },
    {
        .name  = MASK_UPPERs,  /* MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask to be applied to the source IPv6 address\n before comparing.\n",
    },
    {
        .name  = MASK_LOWERs,  /* MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask to be applied to the source IPv6 address\n before comparing.\n",
    },
    {
        .name  = VALUE_UPPERs,  /* VALUE_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Value to be compared with the source IPv6 address.",
    },
    {
        .name  = VALUE_LOWERs,  /* VALUE_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Value to be compared with the source IPv6 address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified source IPv6 address type. Applicable when\n the source IPv6 address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_header_validation_1_src_ipv6_t = {
    .name = L3_HEADER_VALIDATION_1_SRC_IPV6s, /* L3_HEADER_VALIDATION_1_SRC_IPV6 */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_l3_header_validation_1_src_ipv6_t_fields,
    .desc = "The L3_HEADER_VALIDATION_1_SRC_IPV6 table specifies L3\n source IPv6 address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_HEADER_VALIDATION_2_DST_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_header_validation_2_dst_ipv4_t_fields[] = {
    {
        .name  = L3_HEADER_VALIDATION_2_DST_IPV4_IDs,  /* L3_HEADER_VALIDATION_2_DST_IPV4_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the destination IPv4 address validation table.",
    },
    {
        .name  = MASKs,  /* MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask to be applied to the destination IPv4 address\n before comparing.\n",
    },
    {
        .name  = VALUEs,  /* VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Value to be compared with the destination IPv4 address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified destination IPv4 address type. Applicable when\n the destination IPv4 address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_header_validation_2_dst_ipv4_t = {
    .name = L3_HEADER_VALIDATION_2_DST_IPV4s, /* L3_HEADER_VALIDATION_2_DST_IPV4 */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l3_header_validation_2_dst_ipv4_t_fields,
    .desc = "The L3_HEADER_VALIDATION_2_DST_IPV4 table specifies L3\n destination IPv4 address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_HEADER_VALIDATION_2_DST_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_header_validation_2_dst_ipv6_t_fields[] = {
    {
        .name  = L3_HEADER_VALIDATION_2_DST_IPV6_IDs,  /* L3_HEADER_VALIDATION_2_DST_IPV6_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the destination IPv6 address validation table.",
    },
    {
        .name  = MASK_UPPERs,  /* MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask to be applied to the destination IPv6 address\n before comparing.\n",
    },
    {
        .name  = MASK_LOWERs,  /* MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask to be applied to the destination IPv6 address\n before comparing.\n",
    },
    {
        .name  = VALUE_UPPERs,  /* VALUE_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Value to be compared with the destination IPv6 address.",
    },
    {
        .name  = VALUE_LOWERs,  /* VALUE_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Value to be compared with the destination IPv6 address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified destination IPv6 address type. Applicable when\n the destination IPv6 address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_header_validation_2_dst_ipv6_t = {
    .name = L3_HEADER_VALIDATION_2_DST_IPV6s, /* L3_HEADER_VALIDATION_2_DST_IPV6 */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_l3_header_validation_2_dst_ipv6_t_fields,
    .desc = "The L3_HEADER_VALIDATION_2_DST_IPV6 table specifies L3\n destination IPv6 address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_HEADER_VALIDATION_2_SRC_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_header_validation_2_src_ipv4_t_fields[] = {
    {
        .name  = L3_HEADER_VALIDATION_2_SRC_IPV4_IDs,  /* L3_HEADER_VALIDATION_2_SRC_IPV4_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the source IPv4 address validation table.",
    },
    {
        .name  = MASKs,  /* MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask to be applied to the source IPv4 address\n before comparing.\n",
    },
    {
        .name  = VALUEs,  /* VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Value to be compared with the source IPv4 address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified source IPv4 address type. Applicable when\n the source IPv4 address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_header_validation_2_src_ipv4_t = {
    .name = L3_HEADER_VALIDATION_2_SRC_IPV4s, /* L3_HEADER_VALIDATION_2_SRC_IPV4 */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l3_header_validation_2_src_ipv4_t_fields,
    .desc = "The L3_HEADER_VALIDATION_2_SRC_IPV4 table specifies L3\n source IPv4 address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_HEADER_VALIDATION_2_SRC_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_header_validation_2_src_ipv6_t_fields[] = {
    {
        .name  = L3_HEADER_VALIDATION_2_SRC_IPV6_IDs,  /* L3_HEADER_VALIDATION_2_SRC_IPV6_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the source IPv6 address validation table.",
    },
    {
        .name  = MASK_UPPERs,  /* MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask to be applied to the source IPv6 address\n before comparing.\n",
    },
    {
        .name  = MASK_LOWERs,  /* MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask to be applied to the source IPv6 address\n before comparing.\n",
    },
    {
        .name  = VALUE_UPPERs,  /* VALUE_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Value to be compared with the source IPv6 address.",
    },
    {
        .name  = VALUE_LOWERs,  /* VALUE_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Value to be compared with the source IPv6 address.",
    },
    {
        .name  = ADDRESS_TYPEs,  /* ADDRESS_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Classified source IPv6 address type. Applicable when\n the source IPv6 address is matched via MASK and VALUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_header_validation_2_src_ipv6_t = {
    .name = L3_HEADER_VALIDATION_2_SRC_IPV6s, /* L3_HEADER_VALIDATION_2_SRC_IPV6 */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_l3_header_validation_2_src_ipv6_t_fields,
    .desc = "The L3_HEADER_VALIDATION_2_SRC_IPV6 table specifies L3\n source IPv6 address validation and classification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IIF.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_iif_t_fields[] = {
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Layer 3 unicast ingress interface identifier.",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "VRF for L3 lookup.",
    },
    {
        .name  = L3_IIF_PROFILE_IDs,  /* L3_IIF_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_IIF_PROFILE logical table index.",
    },
    {
        .name  = TRUST_IP_DSCPs,  /* TRUST_IP_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust the ingress IP DSCP.\n L3_IIF_PROFILE.PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_ID will be used when\n TRUST_IP_DSCP is enabled.\n",
    },
    {
        .name  = L3_MC_RPA_PROFILE_IDs,  /* L3_MC_RPA_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3_MC_RPA_PROFILE logical table index.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = L3_IP_OPTION_CONTROL_PROFILE_IDs,  /* L3_IP_OPTION_CONTROL_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_IP_OPTION_CONTROL_PROFILE logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID value for this L3 interface.",
    },
    {
        .name  = IPV6_MCs,  /* IPV6_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv6 multicast packets.",
    },
    {
        .name  = IPV4_MCs,  /* IPV4_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv4 multicast packets.",
    },
    {
        .name  = IPV6_UCs,  /* IPV6_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv6 unicast packets.",
    },
    {
        .name  = IPV4_UCs,  /* IPV4_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv4 unicast packets.",
    },
    {
        .name  = L3_OVERRIDE_IP_MC_DO_VLANs,  /* L3_OVERRIDE_IP_MC_DO_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable override of the IPMC_USE_L3_IIF field in the\n PORT logical table in the IP multicast lookup key.\n If set, the L3_IIF will not be part of the lookup key.\n",
    },
    {
        .name  = L3_MC_IIF_IDs,  /* L3_MC_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_MC_IIF_ID value for IPMC lookup keys.",
    },
    {
        .name  = INBAND_TELEMETRY_IFAs,  /* INBAND_TELEMETRY_IFA */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable Inband Flow Analyzer (IFA).",
    },
    {
        .name  = INBAND_TELEMETRY_IOAMs,  /* INBAND_TELEMETRY_IOAM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable In-situ Operations, Administration, and\n Maintenance (IOAM).\n",
    },
    {
        .name  = INBAND_TELEMETRY_DATAPLANEs,  /* INBAND_TELEMETRY_DATAPLANE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable In-band Network Telemetry Data-plane Probe (INT-DP).",
    },
    {
        .name  = ECN_TNL_DECAP_IDs,  /* ECN_TNL_DECAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_TNL_DECAP_IP_PAYLOAD logical table index\n if the terminating tunnel has IP payload, or\n ECN_TNL_DECAP_NON_IP_PAYLOAD logical table index\n if the terminating tunnel has non IP payload.\n",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_iif_t = {
    .name = L3_IIFs, /* L3_IIF */
    .flags = 0,
    .fields = 21,
    .field = bcmltd_l3_iif_t_fields,
    .desc = "The L3_IIF table is used to configure L3 ingress interfaces.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IIF_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_iif_profile_t_fields[] = {
    {
        .name  = L3_IIF_PROFILE_IDs,  /* L3_IIF_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into L3 Ingress Interface Profile Table.",
    },
    {
        .name  = ALLOW_GLOBAL_ROUTEs,  /* ALLOW_GLOBAL_ROUTE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable using global routes if no VRF-specific route is found.",
    },
    {
        .name  = PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs,  /* PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_IP_DSCP_TO_INT_PRI_REMAP logical table index. Used to map packet DSCP\n to internal PRI and CNG.\n",
    },
    {
        .name  = URPF_DEFAULT_ROUTE_CHECKs,  /* URPF_DEFAULT_ROUTE_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable unicast RPF check for default routes.",
    },
    {
        .name  = ICMP_REDIRECT_PKT_TO_CPUs,  /* ICMP_REDIRECT_PKT_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to perform ICMP redirect checks. If enabled, L3 routed\n packets are copied to the CPU if the route necessitates an\n ICMP redirect.\n",
    },
    {
        .name  = IPV6_MCs,  /* IPV6_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv6 multicast packets.",
    },
    {
        .name  = IPV4_MCs,  /* IPV4_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv4 multicast packets.",
    },
    {
        .name  = IPV6_UCs,  /* IPV6_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv6 unicast packets.",
    },
    {
        .name  = IPV4_UCs,  /* IPV4_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv4 unicast packets.",
    },
    {
        .name  = IPV4_UNKNOWN_MC_TO_CPUs,  /* IPV4_UNKNOWN_MC_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable sending of unknown IPv4 multicast packets to CPU.",
    },
    {
        .name  = IPV6_UNKNOWN_MC_TO_CPUs,  /* IPV6_UNKNOWN_MC_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable sending of unknown IPv6 multicast packets to CPU.",
    },
    {
        .name  = UNRESOLVED_SIP_TO_CPUs,  /* UNRESOLVED_SIP_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable sending of IP packets with unresolved\n L3 source address to CPU.\n",
    },
    {
        .name  = IPV6_ROUTING_HDR_TYPE_0_DROPs,  /* IPV6_ROUTING_HDR_TYPE_0_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable drop of IPv6 packets with type 0 routing header.",
    },
    {
        .name  = L3_OVERRIDE_IP_MC_DO_VLANs,  /* L3_OVERRIDE_IP_MC_DO_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable override of the IPMC_USE_L3_IIF field in the\n PORT logical table in the IP multicast lookup key.\n If set, the L3_IIF will not be part of the lookup key.\n",
    },
    {
        .name  = IP_UNKNOWN_MC_AS_L2_MCs,  /* IP_UNKNOWN_MC_AS_L2_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2 multicast of unknown IP multicast packets.",
    },
    {
        .name  = TM_STATs,  /* TM_STAT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 2,
        .desc = "Select type for stat generated by traffic manager.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_iif_profile_t = {
    .name = L3_IIF_PROFILEs, /* L3_IIF_PROFILE */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_l3_iif_profile_t_fields,
    .desc = "The L3_IIF_PROFILE table is used to configure L3 ingress interface profiles.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV4_COMP_DST.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv4_comp_dst_t_fields[] = {
    {
        .name  = IPV4s,  /* IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 destination address.",
    },
    {
        .name  = IPV4_MASKs,  /* IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for IPV4.",
    },
    {
        .name  = L4_PORTs,  /* L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L4 destination port.",
    },
    {
        .name  = L4_PORT_MASKs,  /* L4_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for L4_PORT.",
    },
    {
        .name  = MACs,  /* MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MAC address.",
    },
    {
        .name  = MAC_MASKs,  /* MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC.",
    },
    {
        .name  = VRFs,  /* VRF */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF.",
    },
    {
        .name  = VRF_MASKs,  /* VRF_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF.",
    },
    {
        .name  = IP_PROTOCOLs,  /* IP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Protocol number.",
    },
    {
        .name  = IP_PROTOCOL_MASKs,  /* IP_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for IP_PROTOCOL.",
    },
    {
        .name  = TCP_FLAGSs,  /* TCP_FLAGS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TCP flags.",
    },
    {
        .name  = TCP_FLAGS_MASKs,  /* TCP_FLAGS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for TCP_FLAGS.",
    },
    {
        .name  = IP_FLAGSs,  /* IP_FLAGS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP flags.",
    },
    {
        .name  = IP_FLAGS_MASKs,  /* IP_FLAGS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for IP_FLAGS.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP Compression ID.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry Hit indicator\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv4_comp_dst_t = {
    .name = L3_IPV4_COMP_DSTs, /* L3_IPV4_COMP_DST */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 17,
    .field = bcmltd_l3_ipv4_comp_dst_t_fields,
    .desc = "The L3_IPV4_COMP_DST table is used to fetch ALPM FP IPv4 destination\n address compression entries installed in HW.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV4_COMP_SRC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv4_comp_src_t_fields[] = {
    {
        .name  = IPV4s,  /* IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 source address.",
    },
    {
        .name  = IPV4_MASKs,  /* IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for IPV4.",
    },
    {
        .name  = L4_PORTs,  /* L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L4 source port.",
    },
    {
        .name  = L4_PORT_MASKs,  /* L4_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for L4_PORT.",
    },
    {
        .name  = MACs,  /* MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MAC address.",
    },
    {
        .name  = MAC_MASKs,  /* MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for MAC.",
    },
    {
        .name  = VRFs,  /* VRF */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF.",
    },
    {
        .name  = VRF_MASKs,  /* VRF_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF.",
    },
    {
        .name  = IP_PROTOCOLs,  /* IP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Protocol number.",
    },
    {
        .name  = IP_PROTOCOL_MASKs,  /* IP_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for IP_PROTOCOL.",
    },
    {
        .name  = TCP_FLAGSs,  /* TCP_FLAGS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TCP flags.",
    },
    {
        .name  = TCP_FLAGS_MASKs,  /* TCP_FLAGS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for TCP_FLAGS.",
    },
    {
        .name  = IP_FLAGSs,  /* IP_FLAGS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP flags.",
    },
    {
        .name  = IP_FLAGS_MASKs,  /* IP_FLAGS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for IP_FLAGS.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP Compression ID.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry Hit indicator\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv4_comp_src_t = {
    .name = L3_IPV4_COMP_SRCs, /* L3_IPV4_COMP_SRC */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 17,
    .field = bcmltd_l3_ipv4_comp_src_t_fields,
    .desc = "The L3_IPV4_COMP_SRC table is used to fetch the ALPM FP IPv4 source\n address compression entries installed in hardware.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV4_MC_CTR_ING_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv4_mc_ctr_ing_eflex_action_t_fields[] = {
    {
        .name  = L3_IPV4_MC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV4_MC_CTR_ING_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L3_IPV4_MC_CTR_ING_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv4_mc_ctr_ing_eflex_action_t = {
    .name = L3_IPV4_MC_CTR_ING_EFLEX_ACTIONs, /* L3_IPV4_MC_CTR_ING_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_ipv4_mc_ctr_ing_eflex_action_t_fields,
    .desc = "The L3_IPV4_MC_CTR_ING_EFLEX_ACTION table is used to configure the\n IPv4 multicast ingress enhanced flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV4_MC_PIM_BIDIR_RANGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv4_mc_pim_bidir_range_t_fields[] = {
    {
        .name  = MC_GROUPs,  /* MC_GROUP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 multicast group address.",
    },
    {
        .name  = MC_GROUP_MASKs,  /* MC_GROUP_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for MC_GROUP.",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF ID for L3 routing lookups.",
    },
    {
        .name  = VRF_ID_MASKs,  /* VRF_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF_ID.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv4_mc_pim_bidir_range_t = {
    .name = L3_IPV4_MC_PIM_BIDIR_RANGEs, /* L3_IPV4_MC_PIM_BIDIR_RANGE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 5,
    .field = bcmltd_l3_ipv4_mc_pim_bidir_range_t_fields,
    .desc = "The L3_IPV4_MC_PIM_BIDIR_RANGE table is used to specify whether the multicast\n packet is forwarded using the Bidirectional PIM algorithm.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV4_MC_ROUTE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv4_mc_route_t_fields[] = {
    {
        .name  = MC_GROUPs,  /* MC_GROUP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 multicast group address.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 source address. A value of 0 should be specified for\n non-source-specific multicast, when the LT is hash type in\n a given device.\n",
    },
    {
        .name  = SRC_IPV4_MASKs,  /* SRC_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 source address mask. Applicable when the LT is tcam type\n in a given device. The value must be either all 0 or all 1's.\n",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF ID for L3 routing lookups.",
    },
    {
        .name  = L3_MC_IIF_IDs,  /* L3_MC_IIF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "L3_MC_IIF ID for L3 routing lookups. A value of 0 should be specified\n when PORT.IPMC_USE_L3_IIF is disabled.\n",
    },
    {
        .name  = TM_MC_GROUP_IDs,  /* TM_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TM_MC_GROUP logical table index. Specifies the multicast replication group\n associated with this route.\n",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IP multicast packets to the CPU if the incoming\n L3 interface does not match the expected L3 interface specified in EXPECTED_L3_IIF_ID.\n",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IP multicast packets if the incoming\n L3 interface does not match the expected L3 interface specified in EXPECTED_L3_IIF_ID.\n",
    },
    {
        .name  = EXPECTED_L3_MC_IIF_IDs,  /* EXPECTED_L3_MC_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Expected incoming L3 multicast interface ID for PIM-SM/DVMRP multicast group,\n a value of 0 indicates that the incoming interface check is bypassed.\n",
    },
    {
        .name  = RPA_IDs,  /* RPA_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Rendezvous Point Address (RPA) ID used for PIM-BiDir\n forwarding of IP multicast packets.\n",
    },
    {
        .name  = ASSIGN_INT_PRIs,  /* ASSIGN_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use INT_PRI value from this logical table\n for the packet.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Applicable only if ASSIGN_INT_PRI\n is enabled.\n",
    },
    {
        .name  = DROP_ON_GROUP_MATCHs,  /* DROP_ON_GROUP_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard packets matching the group address.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification ID for ingress FP match.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Module ID. Applicable when IS_TRUNK is disabled.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source port ID. Applicable when IS_TRUNK is disabled.",
    },
    {
        .name  = IS_TRUNKs,  /* IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the source is a trunk (LAG) port.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Trunk group identifier. Applicable when IS_TRUNK is enabled.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_IPV4_MC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV4_MC_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_IPV4_MC_CTR_ING_EFLEX_ACTION logical table index.",
    },
    {
        .name  = USE_PORT_TRUNK_IDs,  /* USE_PORT_TRUNK_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use the incoming port or trunk for RPF checks.\n Disable to use the expected incoming L3 interface for RPF checks.\n",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry Hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv4_mc_route_t = {
    .name = L3_IPV4_MC_ROUTEs, /* L3_IPV4_MC_ROUTE */
    .flags = BCMLTD_TABLE_F_TYPE_MAPPED,
    .fields = 22,
    .field = bcmltd_l3_ipv4_mc_route_t_fields,
    .desc = "The L3_IPv4_MC_ROUTE logical table is used to configure IPv4\n multicast routes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV4_UC_HOST.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv4_uc_host_t_fields[] = {
    {
        .name  = IPV4s,  /* IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 Address.",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF ID for L3 Routing Lookups.",
    },
    {
        .name  = ECMP_NHOPs,  /* ECMP_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates whether ECMP_ID or NHOP_ID is used.",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "If ECMP_NHOP is set, ECMP_ID is used.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "If ECMP_NHOP is unset, NHOP_ID is used.\n",
    },
    {
        .name  = REPLACE_INT_PRIs,  /* REPLACE_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use INT_PRI value from this logical table\n for the packet.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Only used if REPLACE_INT_PRI is enabled.",
    },
    {
        .name  = DROP_ON_DIP_MATCHs,  /* DROP_ON_DIP_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard the packet on destination IP address match.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 Classification ID for ingress FP match.",
    },
    {
        .name  = HOST_LOCALs,  /* HOST_LOCAL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to send packet to the CPU.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry Hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv4_uc_host_t = {
    .name = L3_IPV4_UC_HOSTs, /* L3_IPV4_UC_HOST */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 11,
    .field = bcmltd_l3_ipv4_uc_host_t_fields,
    .desc = "The L3_IPV4_UC_HOST table is used to configure IPv4 unicast\n host entries.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV4_UC_ROUTE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv4_uc_route_t_fields[] = {
    {
        .name  = IPV4s,  /* IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 address.",
    },
    {
        .name  = IPV4_MASKs,  /* IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for IPV4.",
    },
    {
        .name  = ECMP_NHOPs,  /* ECMP_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify an ECMP_ID.",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "ECMP group ID. Applicable only when ECMP_NHOP is enabled.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next-hop ID. Applicable only when ECMP_NHOP is disabled.\n",
    },
    {
        .name  = REPLACE_INT_PRIs,  /* REPLACE_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use INT_PRI value from this logical table.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Applicable only when REPLACE_INT_PRI is enabled.\n",
    },
    {
        .name  = DROP_ON_DIP_MATCHs,  /* DROP_ON_DIP_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard the packet on destination IP address match.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION logical table index.\n",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MON_INBAND_TELEMETRY_ACTION_PROFILE logical\n table.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE logical\n table.\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.\n NHOP_ID = NHOP_ID_BASE +\n           (IPV4 >> HOST_NUMBER_START_OFFSET) & (2^HOST_NUMBER_WIDTH - 1).\n",
    },
    {
        .name  = HOST_NUMBER_START_OFFSETs,  /* HOST_NUMBER_START_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Start offset of the host number subfield in the destination IP address.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = HOST_NUMBER_WIDTHs,  /* HOST_NUMBER_WIDTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Width (in bits) of the host number subfield in the destination IP\n address. Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = NHOP_ID_BASEs,  /* NHOP_ID_BASE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next hop ID base.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv4_uc_route_t = {
    .name = L3_IPV4_UC_ROUTEs, /* L3_IPV4_UC_ROUTE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 26,
    .field = bcmltd_l3_ipv4_uc_route_t_fields,
    .desc = "The L3_IPV4_UC_ROUTE table is used to configure standard priority\n global IPv4 routes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv4_uc_route_ctr_ing_eflex_action_t_fields[] = {
    {
        .name  = L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv4_uc_route_ctr_ing_eflex_action_t = {
    .name = L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTIONs, /* L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_ipv4_uc_route_ctr_ing_eflex_action_t_fields,
    .desc = "The L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION table is used to configure the\n IPv4 unicast route ingress enhanced flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV4_UC_ROUTE_OVERRIDE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv4_uc_route_override_t_fields[] = {
    {
        .name  = IPV4s,  /* IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 address.",
    },
    {
        .name  = IPV4_MASKs,  /* IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for IPV4.",
    },
    {
        .name  = ECMP_NHOPs,  /* ECMP_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify an ECMP_ID.",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "ECMP group ID. Applicable only when ECMP_NHOP is enabled.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next-hop ID. Applicable only when ECMP_NHOP is disabled.\n",
    },
    {
        .name  = REPLACE_INT_PRIs,  /* REPLACE_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use INT_PRI value from this logical table.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Applicable only when REPLACE_INT_PRI is enabled.\n",
    },
    {
        .name  = DROP_ON_DIP_MATCHs,  /* DROP_ON_DIP_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard the packet on destination IP address match.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION logical table index.\n",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MON_INBAND_TELEMETRY_ACTION_PROFILE logical\n table.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE logical\n table.\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.\n Final NHOP = NHOP_ID_BASE +\n           (IPV4 >> HOST_NUMBER_START_OFFSET) & (2^HOST_NUMBER_WIDTH - 1).\n",
    },
    {
        .name  = HOST_NUMBER_START_OFFSETs,  /* HOST_NUMBER_START_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Start offset of the host number subfield in the destination IP address.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = HOST_NUMBER_WIDTHs,  /* HOST_NUMBER_WIDTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Width (in bits) of the host number subfield in the destination IP\n address. Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = NHOP_ID_BASEs,  /* NHOP_ID_BASE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next hop ID base.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv4_uc_route_override_t = {
    .name = L3_IPV4_UC_ROUTE_OVERRIDEs, /* L3_IPV4_UC_ROUTE_OVERRIDE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 26,
    .field = bcmltd_l3_ipv4_uc_route_override_t_fields,
    .desc = "The L3_IPV4_UC_ROUTE_OVERRIDE table is used to configure high priority\n global IPv4 routes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV4_UC_ROUTE_VRF.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv4_uc_route_vrf_t_fields[] = {
    {
        .name  = IPV4s,  /* IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 address.",
    },
    {
        .name  = IPV4_MASKs,  /* IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for IPV4.",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF ID.",
    },
    {
        .name  = VRF_ID_MASKs,  /* VRF_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF_ID.",
    },
    {
        .name  = ECMP_NHOPs,  /* ECMP_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify an ECMP_ID.",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "ECMP group ID. Applicable only when ECMP_NHOP is enabled.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next-hop ID. Applicable only when ECMP_NHOP is disabled.\n",
    },
    {
        .name  = REPLACE_INT_PRIs,  /* REPLACE_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use INT_PRI value from this logical table.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Applicable only when REPLACE_INT_PRI is enabled.\n",
    },
    {
        .name  = DROP_ON_DIP_MATCHs,  /* DROP_ON_DIP_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard the packet on destination IP address match.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_IPV4_UC_ROUTE_CTR_ING_EFLEX_ACTION logical table index.\n",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MON_INBAND_TELEMETRY_ACTION_PROFILE logical\n table.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE logical\n table.\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.\n Final NHOP = NHOP_ID_BASE +\n           (IPV4 >> HOST_NUMBER_START_OFFSET) & (2^HOST_NUMBER_WIDTH - 1).\n",
    },
    {
        .name  = HOST_NUMBER_START_OFFSETs,  /* HOST_NUMBER_START_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Start offset of the host number subfield in the destination IP address.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = HOST_NUMBER_WIDTHs,  /* HOST_NUMBER_WIDTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Width (in bits) of the host number subfield in the destination IP\n address. Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = NHOP_ID_BASEs,  /* NHOP_ID_BASE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next hop ID base.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv4_uc_route_vrf_t = {
    .name = L3_IPV4_UC_ROUTE_VRFs, /* L3_IPV4_UC_ROUTE_VRF */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 28,
    .field = bcmltd_l3_ipv4_uc_route_vrf_t_fields,
    .desc = "The L3_IPV4_UC_ROUTE_VRF table is used to configure VRF IPv4 routes.\n Note that if ALPM_MODE in the L3_ALPM_CONTROL logical table is\n set to ALPM_MODE_COMBINED, a default route with IPV4_MASK=0\n must be installed in order for L3_IPV4_UC_ROUTE to take effect.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_COMP_DST.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_comp_dst_t_fields[] = {
    {
        .name  = IPV6_UPPERs,  /* IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 destination address.",
    },
    {
        .name  = IPV6_UPPER_MASKs,  /* IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_UPPER.",
    },
    {
        .name  = IPV6_LOWERs,  /* IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 destination address.",
    },
    {
        .name  = IPV6_LOWER_MASKs,  /* IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_LOWER.",
    },
    {
        .name  = L4_PORTs,  /* L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L4 destination port.",
    },
    {
        .name  = L4_PORT_MASKs,  /* L4_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for L4_PORT.",
    },
    {
        .name  = VRFs,  /* VRF */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF.",
    },
    {
        .name  = VRF_MASKs,  /* VRF_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF.",
    },
    {
        .name  = IP_PROTOCOLs,  /* IP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Protocol number.",
    },
    {
        .name  = IP_PROTOCOL_MASKs,  /* IP_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for IP_PROTOCOL.",
    },
    {
        .name  = TCP_FLAGSs,  /* TCP_FLAGS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TCP flags.",
    },
    {
        .name  = TCP_FLAGS_MASKs,  /* TCP_FLAGS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for TCP_FLAGS.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP Compression ID.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry Hit indicator\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_comp_dst_t = {
    .name = L3_IPV6_COMP_DSTs, /* L3_IPV6_COMP_DST */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 15,
    .field = bcmltd_l3_ipv6_comp_dst_t_fields,
    .desc = "The L3_IPV6_COMP_DST table is used to fetch ALPM FP IPv6 destination\n address compression entries in hardware.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_COMP_SRC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_comp_src_t_fields[] = {
    {
        .name  = IPV6_UPPERs,  /* IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 source address.",
    },
    {
        .name  = IPV6_UPPER_MASKs,  /* IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_UPPER.",
    },
    {
        .name  = IPV6_LOWERs,  /* IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 source address.",
    },
    {
        .name  = IPV6_LOWER_MASKs,  /* IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_LOWER.",
    },
    {
        .name  = L4_PORTs,  /* L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L4 source port.",
    },
    {
        .name  = L4_PORT_MASKs,  /* L4_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for L4_PORT.",
    },
    {
        .name  = VRFs,  /* VRF */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF.",
    },
    {
        .name  = VRF_MASKs,  /* VRF_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF.",
    },
    {
        .name  = IP_PROTOCOLs,  /* IP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Protocol number.",
    },
    {
        .name  = IP_PROTOCOL_MASKs,  /* IP_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for IP_PROTOCOL.",
    },
    {
        .name  = TCP_FLAGSs,  /* TCP_FLAGS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TCP flags.",
    },
    {
        .name  = TCP_FLAGS_MASKs,  /* TCP_FLAGS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for TCP_FLAGS.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP Compression ID.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry Hit indicator\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_comp_src_t = {
    .name = L3_IPV6_COMP_SRCs, /* L3_IPV6_COMP_SRC */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 15,
    .field = bcmltd_l3_ipv6_comp_src_t_fields,
    .desc = "The L3_IPV6_COMP_SRC table is used to fetch ALPM FP IPv6 source\n address compression entries installed in hardware.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_MC_CTR_ING_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_mc_ctr_ing_eflex_action_t_fields[] = {
    {
        .name  = L3_IPV6_MC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV6_MC_CTR_ING_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L3_IPV6_MC_CTR_ING_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_mc_ctr_ing_eflex_action_t = {
    .name = L3_IPV6_MC_CTR_ING_EFLEX_ACTIONs, /* L3_IPV6_MC_CTR_ING_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_ipv6_mc_ctr_ing_eflex_action_t_fields,
    .desc = "The L3_IPV6_MC_CTR_ING_EFLEX_ACTION table is used to configure the\n IPv6 multicast ingress enhanced flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_MC_PIM_BIDIR_RANGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_mc_pim_bidir_range_t_fields[] = {
    {
        .name  = MC_GROUP_UPPERs,  /* MC_GROUP_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 multicast group address.",
    },
    {
        .name  = MC_GROUP_UPPER_MASKs,  /* MC_GROUP_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for MC_GROUP_UPPER.",
    },
    {
        .name  = MC_GROUP_LOWERs,  /* MC_GROUP_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 multicast group address.",
    },
    {
        .name  = MC_GROUP_LOWER_MASKs,  /* MC_GROUP_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for MC_GROUP_LOWER.",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF ID for L3 routing lookups.",
    },
    {
        .name  = VRF_ID_MASKs,  /* VRF_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF_ID.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_mc_pim_bidir_range_t = {
    .name = L3_IPV6_MC_PIM_BIDIR_RANGEs, /* L3_IPV6_MC_PIM_BIDIR_RANGE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 7,
    .field = bcmltd_l3_ipv6_mc_pim_bidir_range_t_fields,
    .desc = "The L3_IPV6_MC_PIM_BIDIR_RANGE table is used to specify whether the multicast\n packet is forwarded using the Bidirectional PIM algorithm.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_MC_ROUTE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_mc_route_t_fields[] = {
    {
        .name  = MC_GROUP_UPPERs,  /* MC_GROUP_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 multicast group address.",
    },
    {
        .name  = MC_GROUP_LOWERs,  /* MC_GROUP_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 multicast group address.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 source address. A value of 0 should be specified for\n non-source-specific multicast, when the LT is hash type in\n a given device.\n",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 source address. A value of 0 should be specified for\n non-source-specific multicast, when the LT is hash type in\n a given device.\n",
    },
    {
        .name  = SRC_IPV6_MASK_UPPERs,  /* SRC_IPV6_MASK_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 source address mask. Applicable when the LT is tcam type\n in a given device. The value must be either all 0 or all 1's.\n",
    },
    {
        .name  = SRC_IPV6_MASK_LOWERs,  /* SRC_IPV6_MASK_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 source address mask. Applicable when the LT is tcam type\n in a given device. The value must be either all 0 or all 1's.\n",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF ID for L3 routing lookups.",
    },
    {
        .name  = L3_MC_IIF_IDs,  /* L3_MC_IIF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "L3_MC_IIF ID for L3 routing lookups. A value of 0 should be specified\n when PORT.IPMC_USE_L3_IIF is disabled.\n",
    },
    {
        .name  = TM_MC_GROUP_IDs,  /* TM_MC_GROUP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TM_MC_GROUP logical table index. Specifies the multicast replication group\n associated with this route.\n",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IP multicast packets to the CPU if the incoming\n L3 interface does not match the expected L3 interface specified in EXPECTED_L3_IIF_ID.\n",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IP multicast packets if the incoming\n L3 interface does not match the expected L3 interface specified in EXPECTED_L3_IIF_ID.\n",
    },
    {
        .name  = EXPECTED_L3_MC_IIF_IDs,  /* EXPECTED_L3_MC_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Expected incoming L3 multicast interface ID for PIM-SM/DVMRP multicast group,\n a value of 0 indicates that the incoming interface check is bypassed.\n",
    },
    {
        .name  = RPA_IDs,  /* RPA_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Rendezvous Point Address (RPA) ID used for PIM-Bidir\n forwarding of IP multicast packets.\n",
    },
    {
        .name  = ASSIGN_INT_PRIs,  /* ASSIGN_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use INT_PRI value from this logical table\n for the packet.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Applicable only if ASSIGN_INT_PRI\n is enabled.\n",
    },
    {
        .name  = DROP_ON_GROUP_MATCHs,  /* DROP_ON_GROUP_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard the packet on destination IP address match.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification ID for ingress FP match.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Module ID. Applicable when IS_TRUNK is disabled.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source port ID. Applicable when IS_TRUNK is disabled.",
    },
    {
        .name  = IS_TRUNKs,  /* IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the source is a trunk (LAG) port.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Trunk group identifier. Applicable when IS_TRUNK is enabled.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_IPV6_MC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV6_MC_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_IPV6_MC_CTR_ING_EFLEX_ACTION logical table index.",
    },
    {
        .name  = USE_PORT_TRUNK_IDs,  /* USE_PORT_TRUNK_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use the incoming port or trunk for RPF checks.\n Disable to use the expected incoming L3 interface for RPF checks.\n",
    },
    {
        .name  = DROP_SRC_IPV6_LINK_LOCALs,  /* DROP_SRC_IPV6_LINK_LOCAL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IPv6 packets with link local sources.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry Hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_mc_route_t = {
    .name = L3_IPV6_MC_ROUTEs, /* L3_IPV6_MC_ROUTE */
    .flags = BCMLTD_TABLE_F_TYPE_MAPPED,
    .fields = 26,
    .field = bcmltd_l3_ipv6_mc_route_t_fields,
    .desc = "The L3_IPv6_MC_ROUTE logical table is used to configure IPv6\n multicast routes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_PREFIX_TO_IPV4_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_prefix_to_ipv4_map_t_fields[] = {
    {
        .name  = L3_IPV6_PREFIX_TO_IPV4_MAP_IDs,  /* L3_IPV6_PREFIX_TO_IPV4_MAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into L3 IPv6 prefix to IPv4 map table.",
    },
    {
        .name  = MATCHs,  /* MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match agaist the value specified in IPV6_PREFIX.",
    },
    {
        .name  = IPV6_PREFIX_UPPERs,  /* IPV6_PREFIX_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address prefix. The upper 96 bits are used.",
    },
    {
        .name  = IPV6_PREFIX_LOWERs,  /* IPV6_PREFIX_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address prefix. The upper 96 bits are used.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_prefix_to_ipv4_map_t = {
    .name = L3_IPV6_PREFIX_TO_IPV4_MAPs, /* L3_IPV6_PREFIX_TO_IPV4_MAP */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l3_ipv6_prefix_to_ipv4_map_t_fields,
    .desc = "The L3_IPV6_PREFIX_TO_IPV4_MAP table is used to specify 96-bit prefixes\n for IPv4-mapped IPv6 address. If the outer or inner IPv6 address\n of a packet is matched against the prefix, the lower 32-bit\n of the IPv6 address will be used as the IPv4 address for\n the L3 unicast source or destination IPv4 address lookups.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_RESERVED_MC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_reserved_mc_t_fields[] = {
    {
        .name  = L3_IPV6_RESERVED_MC_IDs,  /* L3_IPV6_RESERVED_MC_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L3_IPV6_RESERVED_MC table.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_MASK_UPPERs,  /* DST_IPV6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask value to be applied to both DST_IPV6 and the packet's\n destination IPv6 address for matching.\n",
    },
    {
        .name  = DST_IPV6_MASK_LOWERs,  /* DST_IPV6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask value to be applied to both DST_IPV6 and the packet's\n destination IPv6 address for matching.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_reserved_mc_t = {
    .name = L3_IPV6_RESERVED_MCs, /* L3_IPV6_RESERVED_MC */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_l3_ipv6_reserved_mc_t_fields,
    .desc = "The L3_IPV6_RESERVED_MC logical table specifies additional reserved IPv6\n multicast addresses to match against IPv6 multicast packets. The match\n values specified in this table are applied in addition to the default\n reserved multicast address (FF0X:0:0:0:0:0:0:0).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_UC_HOST.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_uc_host_t_fields[] = {
    {
        .name  = IPV6_UPPERs,  /* IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPV6 address.",
    },
    {
        .name  = IPV6_LOWERs,  /* IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPV6 address.",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF id for L3 routing lookups.",
    },
    {
        .name  = ECMP_NHOPs,  /* ECMP_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates whether ECMP_ID or NHOP_ID is used.",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "If ECMP_NHOP is set, ECMP_ID is used.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "If ECMP_NHOP is unset, NHOP_ID is used.\n",
    },
    {
        .name  = REPLACE_INT_PRIs,  /* REPLACE_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use INT_PRI value from this logical table\n for the packet.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Only used if REPLACE_INT_PRI is enabled.",
    },
    {
        .name  = DROP_ON_DIP_MATCHs,  /* DROP_ON_DIP_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard the packet on destination IP address match.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 Classification ID for ingress FP match.",
    },
    {
        .name  = HOST_LOCALs,  /* HOST_LOCAL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to send packet to the CPU.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry Hit indicator\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_uc_host_t = {
    .name = L3_IPV6_UC_HOSTs, /* L3_IPV6_UC_HOST */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 12,
    .field = bcmltd_l3_ipv6_uc_host_t_fields,
    .desc = "The L3_IPV6_UC_HOST table is used to configure IPv6 unicast\n host entries.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_UC_ROUTE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_uc_route_t_fields[] = {
    {
        .name  = IPV6_UPPERs,  /* IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_UPPER_MASKs,  /* IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_UPPER.",
    },
    {
        .name  = IPV6_LOWERs,  /* IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_LOWER_MASKs,  /* IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_LOWER.",
    },
    {
        .name  = ECMP_NHOPs,  /* ECMP_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify an ECMP_ID.",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "ECMP group ID. Applicable only when ECMP_NHOP is enabled.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next-hop ID. Applicable only when ECMP_NHOP is disabled.\n",
    },
    {
        .name  = REPLACE_INT_PRIs,  /* REPLACE_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use INT_PRI value from this logical table.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Applicable only when REPLACE_INT_PRI is enabled.\n",
    },
    {
        .name  = DROP_ON_DIP_MATCHs,  /* DROP_ON_DIP_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard the packet on destination IP address match.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION logical table index.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MON_INBAND_TELEMETRY_ACTION_PROFILE logical\n table.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE logical\n table.\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.\n Final NHOP = NHOP_ID_BASE +\n           (IPV6 >> HOST_NUMBER_START_OFFSET) & (2^HOST_NUMBER_WIDTH - 1).\n",
    },
    {
        .name  = HOST_NUMBER_START_OFFSETs,  /* HOST_NUMBER_START_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Start offset of the host number subfield in the destination IP address.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = HOST_NUMBER_WIDTHs,  /* HOST_NUMBER_WIDTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Width (in bits) of the host number subfield in the destination IP\n address. Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = NHOP_ID_BASEs,  /* NHOP_ID_BASE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next hop ID base.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_uc_route_t = {
    .name = L3_IPV6_UC_ROUTEs, /* L3_IPV6_UC_ROUTE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 28,
    .field = bcmltd_l3_ipv6_uc_route_t_fields,
    .desc = "The L3_IPV6_UC_ROUTE table is used to configure standard priority\n global IPv6 routes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_uc_route_ctr_ing_eflex_action_t_fields[] = {
    {
        .name  = L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_uc_route_ctr_ing_eflex_action_t = {
    .name = L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTIONs, /* L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_ipv6_uc_route_ctr_ing_eflex_action_t_fields,
    .desc = "The L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION table is used to configure the\n IPv6 unicast route ingress enhanced flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_UC_ROUTE_OVERRIDE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_uc_route_override_t_fields[] = {
    {
        .name  = IPV6_UPPERs,  /* IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_UPPER_MASKs,  /* IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_UPPER.",
    },
    {
        .name  = IPV6_LOWERs,  /* IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_LOWER_MASKs,  /* IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_LOWER.",
    },
    {
        .name  = ECMP_NHOPs,  /* ECMP_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify an ECMP_ID.",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "ECMP group ID. Applicable only when ECMP_NHOP is enabled.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next-hop ID. Applicable only when ECMP_NHOP is disabled.\n",
    },
    {
        .name  = REPLACE_INT_PRIs,  /* REPLACE_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use INT_PRI value from this logical table.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Applicable only when REPLACE_INT_PRI is enabled.\n",
    },
    {
        .name  = DROP_ON_DIP_MATCHs,  /* DROP_ON_DIP_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard the packet on destination IP address match.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION logical table index.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MON_INBAND_TELEMETRY_ACTION_PROFILE logical\n table.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE logical\n table.\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.\n Final NHOP = NHOP_ID_BASE +\n           (IPV6 >> HOST_NUMBER_START_OFFSET) & (2^HOST_NUMBER_WIDTH - 1).\n",
    },
    {
        .name  = HOST_NUMBER_START_OFFSETs,  /* HOST_NUMBER_START_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Start offset of the host number subfield in the destination IP address.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = HOST_NUMBER_WIDTHs,  /* HOST_NUMBER_WIDTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Width (in bits) of the host number subfield in the destination IP\n address. Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = NHOP_ID_BASEs,  /* NHOP_ID_BASE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next hop ID base.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_uc_route_override_t = {
    .name = L3_IPV6_UC_ROUTE_OVERRIDEs, /* L3_IPV6_UC_ROUTE_OVERRIDE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 28,
    .field = bcmltd_l3_ipv6_uc_route_override_t_fields,
    .desc = "The L3_IPV6_UC_ROUTE_OVERRIDE table is used to configure high priority\n global IPv6 routes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IPV6_UC_ROUTE_VRF.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ipv6_uc_route_vrf_t_fields[] = {
    {
        .name  = IPV6_UPPERs,  /* IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_UPPER_MASKs,  /* IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_UPPER.",
    },
    {
        .name  = IPV6_LOWERs,  /* IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_LOWER_MASKs,  /* IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_LOWER.",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF ID.",
    },
    {
        .name  = VRF_ID_MASKs,  /* VRF_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF_ID.",
    },
    {
        .name  = ECMP_NHOPs,  /* ECMP_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify an ECMP_ID.",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "ECMP group ID. Applicable only when ECMP_NHOP is enabled.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next-hop ID. Applicable only when ECMP_NHOP is disabled.\n",
    },
    {
        .name  = REPLACE_INT_PRIs,  /* REPLACE_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use INT_PRI value from this logical table.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority. Applicable only when REPLACE_INT_PRI is enabled.\n",
    },
    {
        .name  = DROP_ON_DIP_MATCHs,  /* DROP_ON_DIP_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard the packet on destination IP address match.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION_IDs,  /* L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_IPV6_UC_ROUTE_CTR_ING_EFLEX_ACTION logical table index.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MON_INBAND_TELEMETRY_ACTION_PROFILE logical\n table.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE logical\n table.\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.\n Final NHOP = NHOP_ID_BASE +\n           (IPV6 >> HOST_NUMBER_START_OFFSET) & (2^HOST_NUMBER_WIDTH - 1).\n",
    },
    {
        .name  = HOST_NUMBER_START_OFFSETs,  /* HOST_NUMBER_START_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Start offset of the host number subfield in the destination IP address.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = HOST_NUMBER_WIDTHs,  /* HOST_NUMBER_WIDTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Width (in bits) of the host number subfield in the destination IP\n address. Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
    {
        .name  = NHOP_ID_BASEs,  /* NHOP_ID_BASE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Next hop ID base.\n Applicable only when HOST_NUMBER_MODE is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ipv6_uc_route_vrf_t = {
    .name = L3_IPV6_UC_ROUTE_VRFs, /* L3_IPV6_UC_ROUTE_VRF */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 30,
    .field = bcmltd_l3_ipv6_uc_route_vrf_t_fields,
    .desc = "The L3_IPV6_UC_ROUTE_VRF table is used to configure VRF IPv6 routes.\n Note that if ALPM_MODE in the L3_ALPM_CONTROL logical table is\n set to ALPM_MODE_COMBINED, a default route with IPV6_MASK=0\n must be installed in order for L3_IPV6_UC_ROUTE to take effect.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_IP_OPTION_CONTROL_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_ip_option_control_profile_t_fields[] = {
    {
        .name  = L3_IP_OPTION_CONTROL_PROFILE_IDs,  /* L3_IP_OPTION_CONTROL_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the IP option control profile table.",
    },
    {
        .name  = PKT_IP_OPTION_NUMBERs,  /* PKT_IP_OPTION_NUMBER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 option number.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the IPv4 packet with this option number.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy to CPU the IPv4 packet with this option number.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_ip_option_control_profile_t = {
    .name = L3_IP_OPTION_CONTROL_PROFILEs, /* L3_IP_OPTION_CONTROL_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l3_ip_option_control_profile_t_fields,
    .desc = "The L3_IP_OPTION_CONTROL_PROFILE table provides controls to configure\n actions on IP packets with options.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_LIMIT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_limit_control_t_fields[] = {
    {
        .name  = NHOP_OVERLAY_LIMITs,  /* NHOP_OVERLAY_LIMIT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Overlay next hop limit.",
    },
    {
        .name  = EIF_OVERLAY_LIMITs,  /* EIF_OVERLAY_LIMIT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Overlay egress interface limit.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_limit_control_t = {
    .name = L3_LIMIT_CONTROLs, /* L3_LIMIT_CONTROL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_limit_control_t_fields,
    .desc = "The L3_LIMIT_CONTROL table is used to specify limits for L3 index tables.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_MC_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_mc_control_t_fields[] = {
    {
        .name  = IGMP_RESERVED_MCs,  /* IGMP_RESERVED_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to treat IGMP packets with reserved multicast destination\n address as IGMP packets.\n",
    },
    {
        .name  = MLD_RESERVED_MCs,  /* MLD_RESERVED_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to treat MLD packets with reserved multicast destination\n address as MLD packets.\n",
    },
    {
        .name  = IGNORE_UC_IGMP_PAYLOADs,  /* IGNORE_UC_IGMP_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to do not treat unicast packets with IGMP payload\n as IGMP packets.\n",
    },
    {
        .name  = IGNORE_UC_MLD_PAYLOADs,  /* IGNORE_UC_MLD_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to do not treat unicast packets with MLD payload\n as MLD packets.\n",
    },
    {
        .name  = IPV4_MC_DST_MAC_CHECKs,  /* IPV4_MC_DST_MAC_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check for a match of the lower 23 bits of the\n destination MAC address with the lower 23 bits of the IPv4\n destination address for IPv4 multicast packets.\n",
    },
    {
        .name  = IPV6_MC_DST_MAC_CHECKs,  /* IPV6_MC_DST_MAC_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check for a match of the lower 32 bits of the\n destination MAC address with the lower 32 bits of the IPv6\n destination address for IPv6 multicast packets.\n",
    },
    {
        .name  = STRICT_MLD_CHECKs,  /* STRICT_MLD_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable strict check with MLD packets for the IP address and\n hop limit.\n",
    },
    {
        .name  = L2_L3_MC_COMBINED_MODEs,  /* L2_L3_MC_COMBINED_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to egress both L2 and L3 packet copies on an egress port\n if the switching logic indicates that both an L2 and L3 copy\n should be done for an egress port. If disabled, only the L3\n packet copy will be egressed.\n",
    },
    {
        .name  = IPMC_ROUTE_SAME_VLANs,  /* IPMC_ROUTE_SAME_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to route IP multicast packets when the outgoing VLAN is\n the same as the incoming VLAN.\n",
    },
    {
        .name  = TTL_1_TO_CPUs,  /* TTL_1_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with time-to-live (TTL) equals 1\n to the CPU.\n",
    },
    {
        .name  = TTL_ERROR_TO_CPUs,  /* TTL_ERROR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with TTL error to the CPU.",
    },
    {
        .name  = L3_MC_INDEX_ERROR_TO_CPUs,  /* L3_MC_INDEX_ERROR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with multicast index error\n to the CPU.\n",
    },
    {
        .name  = L3_MC_PORT_MISS_TO_CPUs,  /* L3_MC_PORT_MISS_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with multicast port mismatch error\n to the CPU.\n",
    },
    {
        .name  = L3_MC_ERROR_TO_CPUs,  /* L3_MC_ERROR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with multicast error to the CPU.",
    },
    {
        .name  = L3_MC_MISS_TO_L2s,  /* L3_MC_MISS_TO_L2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to redirect unknown IP multicast packets to an L2\n multicast group using the destination MAC and VLAN lookup.\n The default behavior is to flood the VLAN.\n",
    },
    {
        .name  = L3_MC_TNL_DROPs,  /* L3_MC_TNL_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop unknown IP multicast packets for ingress tunnels.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_mc_control_t = {
    .name = L3_MC_CONTROLs, /* L3_MC_CONTROL */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_l3_mc_control_t_fields,
    .desc = "The L3_MC_CONTROL table is used to specify global L3\n multicast configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_MC_MTU.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_mc_mtu_t_fields[] = {
    {
        .name  = TM_MC_GROUP_IDs,  /* TM_MC_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Multicast group Index.",
    },
    {
        .name  = L3_MTUs,  /* L3_MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 payload MTU for IP packets.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_mc_mtu_t = {
    .name = L3_MC_MTUs, /* L3_MC_MTU */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_mc_mtu_t_fields,
    .desc = "The L3_MC_MTU table is used to configure the MTU size for\n multicast packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_MC_NHOP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_mc_nhop_t_fields[] = {
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L3 multicast next hop ID.",
    },
    {
        .name  = L3_EIF_IDs,  /* L3_EIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_EIF logical table index.",
    },
    {
        .name  = UNDERLAY_L3_EIF_VALIDs,  /* UNDERLAY_L3_EIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate UNDERLAY_L3_EIF_ID is valid.",
    },
    {
        .name  = UNDERLAY_L3_EIF_IDs,  /* UNDERLAY_L3_EIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_EIF logical table index.\n Applicable only when UNDERLAY_L3_EIF_VALID is enabled.\n",
    },
    {
        .name  = OVERLAY_L3_EIF_VALIDs,  /* OVERLAY_L3_EIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate OVERLAY_L3_EIF_ID is valid.\n Applicable only when NHOP_ID is used as an overlay next hop.\n",
    },
    {
        .name  = OVERLAY_L3_EIF_IDs,  /* OVERLAY_L3_EIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_EIF logical table index.\n Applicable only when OVERLAY_L3_EIF_VALID is enabled.\n",
    },
    {
        .name  = REPLACE_DST_MACs,  /* REPLACE_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use DST_MAC value from this logical table.\n DST_MAC is applicable only when KEEP_DST_MAC is disabled.\n",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "MAC address to be used for destination MAC address replacement.\n Applicable only if REPLACE_DST_MAC is enabled and KEEP_DST_MAC is disabled.\n The combination of REPLACE_DST_MAC and KEEP_DST_MAC as both enabled or\n both disabled is not supported.\n",
    },
    {
        .name  = KEEP_DST_MACs,  /* KEEP_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip destination MAC address replacement.",
    },
    {
        .name  = KEEP_SRC_MACs,  /* KEEP_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip source MAC address replacement.",
    },
    {
        .name  = KEEP_TTLs,  /* KEEP_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip decrement of TTL.",
    },
    {
        .name  = KEEP_VLAN_IDs,  /* KEEP_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip outer VLAN ID replacement.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 class ID for egress FP.\n Applicable only when REPLACE_DST_MAC is disabled.\n",
    },
    {
        .name  = DROP_L2s,  /* DROP_L2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IP multicast replication copies\n if replication forwarding domain is the same as\n incoming forwarding domain, i.e. L2 copies.\n",
    },
    {
        .name  = DROP_L3s,  /* DROP_L3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IP multicast replication copies\n if replication forwarding domain is the same as\n incoming forwarding domain, i.e. L3 copies.\n",
    },
    {
        .name  = CTR_EGR_FLEX_POOL_NUMBERs,  /* CTR_EGR_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter pool number.",
    },
    {
        .name  = CTR_EGR_FLEX_BASE_INDEXs,  /* CTR_EGR_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_EGR_FLEX_OFFSET_MODEs,  /* CTR_EGR_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = CTR_EGR_EFLEX_OBJECTs,  /* CTR_EGR_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter object.",
    },
    {
        .name  = L3_MC_NHOP_CTR_EGR_EFLEX_ACTION_IDs,  /* L3_MC_NHOP_CTR_EGR_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_MC_NHOP_CTR_EGR_EFLEX_ACTION logical table index.\n L3_MC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION logical table index\n when NHOP_ID is used as an overlay next hop.\n",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Destination VP derived from this next hop.",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_VALIDs,  /* EGR_UNDERLAY_NHOP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate EGR_UNDERLAY_NHOP_ID is valid.\n Applicable only when NHOP_ID is used as an overlay next hop.\n",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_IDs,  /* EGR_UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Underlay next hop ID derived from this overlay next hop\n in the egress pipeline. Applicable only\n if EGR_UNDERLAY_NHOP_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_mc_nhop_t = {
    .name = L3_MC_NHOPs, /* L3_MC_NHOP */
    .flags = BCMLTD_TABLE_F_TYPE_INDEX_ALLOC,
    .fields = 23,
    .field = bcmltd_l3_mc_nhop_t_fields,
    .desc = "The L3_MC_NHOP table provides L3 multicast next-hop controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_MC_NHOP_CTR_EGR_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_mc_nhop_ctr_egr_eflex_action_t_fields[] = {
    {
        .name  = L3_MC_NHOP_CTR_EGR_EFLEX_ACTION_IDs,  /* L3_MC_NHOP_CTR_EGR_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L3_MC_NHOP_CTR_EGR_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_mc_nhop_ctr_egr_eflex_action_t = {
    .name = L3_MC_NHOP_CTR_EGR_EFLEX_ACTIONs, /* L3_MC_NHOP_CTR_EGR_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_mc_nhop_ctr_egr_eflex_action_t_fields,
    .desc = "The L3_MC_NHOP_CTR_EGR_EFLEX_ACTION table is used to configure the\n L3 multicast next hop egress flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_MC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_mc_overlay_nhop_ctr_egr_eflex_action_t_fields[] = {
    {
        .name  = L3_MC_NHOP_CTR_EGR_EFLEX_ACTION_IDs,  /* L3_MC_NHOP_CTR_EGR_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L3_MC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_mc_overlay_nhop_ctr_egr_eflex_action_t = {
    .name = L3_MC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTIONs, /* L3_MC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_mc_overlay_nhop_ctr_egr_eflex_action_t_fields,
    .desc = "The L3_MC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION table is used to configure the\n L3 multicast overlay next hop egress flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_MC_PORT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_mc_port_control_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = SKIP_TTL_DECs,  /* SKIP_TTL_DEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to bypass TTL decrement.",
    },
    {
        .name  = SKIP_TTL_CHECKs,  /* SKIP_TTL_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to bypass TTL check.",
    },
    {
        .name  = SKIP_SA_REPLACEs,  /* SKIP_SA_REPLACE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to bypass source address replacement.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to untag the packet.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID",
    },
    {
        .name  = IVID_VALIDs,  /* IVID_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify the inner VLAN ID is valid.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID",
    },
};
const bcmltd_table_rep_t bcmltd_l3_mc_port_control_t = {
    .name = L3_MC_PORT_CONTROLs, /* L3_MC_PORT_CONTROL */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_l3_mc_port_control_t_fields,
    .desc = "The L3_MC_PORT_CONTROL table is used to configure per-port L3 multicast functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_MC_RPA_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_mc_rpa_profile_t_fields[] = {
    {
        .name  = L3_MC_RPA_PROFILE_IDs,  /* L3_MC_RPA_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress active L3_IIF profile table ID.",
    },
    {
        .name  = RPAs,  /* RPA */
        .flags = 0,
        .width = 1,
        .depth = 64,
        .desc = "Rendezvous Point Address (RPA) ID used for PIM-Bidir\n forwarding of IP multicast packets. RPA_ID is\n used to identify the group rendezvous point address.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_mc_rpa_profile_t = {
    .name = L3_MC_RPA_PROFILEs, /* L3_MC_RPA_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_mc_rpa_profile_t_fields,
    .desc = "The L3_MC_RPA_PROFILE table is used to specify the\n Rendezvous Point Address (RPA) profile. The RPA\n profile indicates whether the packet should use a\n PIM-Bidir algorithm.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_MTU_ADJUST_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_mtu_adjust_profile_t_fields[] = {
    {
        .name  = L3_MTU_ADJUST_PROFILE_IDs,  /* L3_MTU_ADJUST_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L3 MTU adjust profile ID.",
    },
    {
        .name  = ADJUSTs,  /* ADJUST */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "MTU length adjustment value applied to the incoming packet.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Adjustment mode applied to the incoming packet.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_mtu_adjust_profile_t = {
    .name = L3_MTU_ADJUST_PROFILEs, /* L3_MTU_ADJUST_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_l3_mtu_adjust_profile_t_fields,
    .desc = "The L3_MTU_ADJUST_PROFILE profile table is used to specify the MTU\n adjustment for L3 MTU validation. It is used to store the per-flow\n length adjust in 2's complement and is needed in cases such as MPLS\n to derive the L3 length from the L2 frame length.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_MTU_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_mtu_profile_t_fields[] = {
    {
        .name  = L3_MTU_PROFILE_IDs,  /* L3_MTU_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L3 MTU profile ID.",
    },
    {
        .name  = L3_MTUs,  /* L3_MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 payload MTU length for IP packets.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_mtu_profile_t = {
    .name = L3_MTU_PROFILEs, /* L3_MTU_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_mtu_profile_t_fields,
    .desc = "The L3_MTU_PROFILE profile table is used to specify the L3 MTU.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_PARSER_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_parser_control_t_fields[] = {
    {
        .name  = ING_WESPs,  /* ING_WESP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to parse wrapped encapsulating security payload (WESP)\n protocol packets in the ingress pipeline.\n",
    },
    {
        .name  = ING_WESP_IP_PROTOs,  /* ING_WESP_IP_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Protocol value to be compared against a packet's IP protocol or next\n header field in order to identify and parse WESP protocol packets in\n the ingress pipeline. Applicable if ING_WESP is enabled.\n",
    },
    {
        .name  = EGR_WESPs,  /* EGR_WESP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to parse wrapped encapsulating security payload (WESP)\n protocol packets in the egress pipeline.\n",
    },
    {
        .name  = EGR_WESP_IP_PROTOs,  /* EGR_WESP_IP_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Protocol Value to be compared against a packet's IP protocol or next\n header field in order to identify and parse WESP protocol packets in\n the egress pipeline. Applicable if EGR_WESP is enabled.\n",
    },
    {
        .name  = ING_IPV6_EXT_HDR_PROTOs,  /* ING_IPV6_EXT_HDR_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "User defined IPv6 extenion header value to be parsed in the ingress\n pipeline in order to get the L4 header. Applicable only if set to a\n non-zero value.\n",
    },
    {
        .name  = EGR_IPV6_EXT_HDR_PROTOs,  /* EGR_IPV6_EXT_HDR_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "User defined IPv6 extenion header value to be parsed in the egress\n pipeline and recognized by the egress FP parser. Applicable only if\n set to a non-zero value.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_parser_control_t = {
    .name = L3_PARSER_CONTROLs, /* L3_PARSER_CONTROL */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_l3_parser_control_t_fields,
    .desc = "The L3_PARSER_CONTROL logical table specifies L3 protocol parsing controls\n for packet detection.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_PROTECTION_ENABLE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_protection_enable_t_fields[] = {
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L3_PROTECTION_ENABLE logical table index.",
    },
    {
        .name  = PROTECTIONs,  /* PROTECTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to switch to protection path.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_protection_enable_t = {
    .name = L3_PROTECTION_ENABLEs, /* L3_PROTECTION_ENABLE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_protection_enable_t_fields,
    .desc = "The L3_PROTECTION_ENABLE table is used to\n enable protection switching for a L3 next hop.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_src_ipv4_uc_ctr_ing_eflex_action_t_fields[] = {
    {
        .name  = L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_src_ipv4_uc_ctr_ing_eflex_action_t = {
    .name = L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTIONs, /* L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_src_ipv4_uc_ctr_ing_eflex_action_t_fields,
    .desc = "The L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION table is used to configure the\n source IPv4 unicast ingress enhanced flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_SRC_IPV4_UC_ROUTE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_src_ipv4_uc_route_t_fields[] = {
    {
        .name  = IPV4s,  /* IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 address.",
    },
    {
        .name  = IPV4_MASKs,  /* IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for IPV4.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION logical table index.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = STRENGTH_PROFILE_INDEXs,  /* STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Index of the strength profile table for this entry.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_src_ipv4_uc_route_t = {
    .name = L3_SRC_IPV4_UC_ROUTEs, /* L3_SRC_IPV4_UC_ROUTE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 16,
    .field = bcmltd_l3_src_ipv4_uc_route_t_fields,
    .desc = "The L3_SRC_IPV4_UC_ROUTE table is used to configure standard priority\n global source IPv4 routes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_SRC_IPV4_UC_ROUTE_OVERRIDE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_src_ipv4_uc_route_override_t_fields[] = {
    {
        .name  = IPV4s,  /* IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 address.",
    },
    {
        .name  = IPV4_MASKs,  /* IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for IPV4.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION logical table index.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = STRENGTH_PROFILE_INDEXs,  /* STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Index of the strength profile table for this entry.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_src_ipv4_uc_route_override_t = {
    .name = L3_SRC_IPV4_UC_ROUTE_OVERRIDEs, /* L3_SRC_IPV4_UC_ROUTE_OVERRIDE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 16,
    .field = bcmltd_l3_src_ipv4_uc_route_override_t_fields,
    .desc = "The L3_SRC_IPV4_UC_ROUTE_OVERRIDE table is used to configure high priority\n global source IPv4 routes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_SRC_IPV4_UC_ROUTE_VRF.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_src_ipv4_uc_route_vrf_t_fields[] = {
    {
        .name  = IPV4s,  /* IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 address.",
    },
    {
        .name  = IPV4_MASKs,  /* IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for IPV4.",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF ID.",
    },
    {
        .name  = VRF_ID_MASKs,  /* VRF_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF_ID.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_SRC_IPV4_UC_CTR_ING_EFLEX_ACTION logical table index.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = STRENGTH_PROFILE_INDEXs,  /* STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Index of the strength profile table for this entry.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_src_ipv4_uc_route_vrf_t = {
    .name = L3_SRC_IPV4_UC_ROUTE_VRFs, /* L3_SRC_IPV4_UC_ROUTE_VRF */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 18,
    .field = bcmltd_l3_src_ipv4_uc_route_vrf_t_fields,
    .desc = "The L3_SRC_IPV4_UC_ROUTE_VRF table is used to configure VRF source\n IPv4 routes.\n Note that if ALPM_MODE in the L3_ALPM_CONTROL logical table is\n set to ALPM_MODE_COMBINED, a default route with IPV4_MASK=0\n must be installed in order for L3_SRC_IPV4_UC_ROUTE to take effect.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_src_ipv6_uc_ctr_ing_eflex_action_t_fields[] = {
    {
        .name  = L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_src_ipv6_uc_ctr_ing_eflex_action_t = {
    .name = L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTIONs, /* L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_src_ipv6_uc_ctr_ing_eflex_action_t_fields,
    .desc = "The L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION table is used to configure the\n source IPv4 unicast ingress enhanced flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_SRC_IPV6_UC_ROUTE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_src_ipv6_uc_route_t_fields[] = {
    {
        .name  = IPV6_UPPERs,  /* IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_UPPER_MASKs,  /* IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_UPPER.",
    },
    {
        .name  = IPV6_LOWERs,  /* IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_LOWER_MASKs,  /* IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_LOWER.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION logical table index.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = STRENGTH_PROFILE_INDEXs,  /* STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Index of the strength profile table for this entry.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_src_ipv6_uc_route_t = {
    .name = L3_SRC_IPV6_UC_ROUTEs, /* L3_SRC_IPV6_UC_ROUTE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 18,
    .field = bcmltd_l3_src_ipv6_uc_route_t_fields,
    .desc = "The L3_SRC_IPV6_UC_ROUTE table is used to configure standard priority\n global source IPv6 routes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_SRC_IPV6_UC_ROUTE_OVERRIDE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_src_ipv6_uc_route_override_t_fields[] = {
    {
        .name  = IPV6_UPPERs,  /* IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_UPPER_MASKs,  /* IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_UPPER.",
    },
    {
        .name  = IPV6_LOWERs,  /* IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_LOWER_MASKs,  /* IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_LOWER.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION logical table index.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = STRENGTH_PROFILE_INDEXs,  /* STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Index of the strength profile table for this entry.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_src_ipv6_uc_route_override_t = {
    .name = L3_SRC_IPV6_UC_ROUTE_OVERRIDEs, /* L3_SRC_IPV6_UC_ROUTE_OVERRIDE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 18,
    .field = bcmltd_l3_src_ipv6_uc_route_override_t_fields,
    .desc = "The L3_SRC_IPV6_UC_ROUTE_OVERRIDE table is used to configure high priority\n global source IPv6 routes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_SRC_IPV6_UC_ROUTE_VRF.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_src_ipv6_uc_route_vrf_t_fields[] = {
    {
        .name  = IPV6_UPPERs,  /* IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_UPPER_MASKs,  /* IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_UPPER.",
    },
    {
        .name  = IPV6_LOWERs,  /* IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "IPv6 address.",
    },
    {
        .name  = IPV6_LOWER_MASKs,  /* IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for IPV6_LOWER.",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF ID.",
    },
    {
        .name  = VRF_ID_MASKs,  /* VRF_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for VRF_ID.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 classification identifier for match in ingress FP.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION_IDs,  /* L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_SRC_IPV6_UC_CTR_ING_EFLEX_ACTION logical table index.",
    },
    {
        .name  = HITs,  /* HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Entry hit indicator.\n Requires BCMLT_ENT_ATTR_GET_FROM_HW attribute to be set\n during LOOKUP in order to obtain directly from hardware.\n",
    },
    {
        .name  = STRENGTH_PROFILE_INDEXs,  /* STRENGTH_PROFILE_INDEX */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Index of the strength profile table for this entry.\n",
    },
    {
        .name  = DATA_TYPEs,  /* DATA_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Assoc Policy data format.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type assigned from this table.",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination object assigned from this table.",
    },
    {
        .name  = MISC_CTRL_0s,  /* MISC_CTRL_0 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_0\n     misc_ctrl_0[0:0]: If set, entry is valid;\n     misc_ctrl_0[3:1]: Unused;\n",
    },
    {
        .name  = MISC_CTRL_1s,  /* MISC_CTRL_1 */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Encoding for misc_ctrl_1 for Destination lookup:\n     misc_ctrl_1[0:0]: If set, Packet discard;\n     misc_ctrl_1[1:1]: If set, Packet copy to CPU;\n     misc_ctrl_1[2:2]: If set, Destination IP is a local address;\n     misc_ctrl_1[3:3]: Unused;\n Encoding for misc_ctrl_1 for Source lookup:\n     misc_ctrl_1[0:0]: If set, this entry is a default route for uRPF check;\n     misc_ctrl_1[3:1]: Unused;\n",
    },
    {
        .name  = HOST_NUMBER_MODEs,  /* HOST_NUMBER_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the host number lookup mode.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_src_ipv6_uc_route_vrf_t = {
    .name = L3_SRC_IPV6_UC_ROUTE_VRFs, /* L3_SRC_IPV6_UC_ROUTE_VRF */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 20,
    .field = bcmltd_l3_src_ipv6_uc_route_vrf_t_fields,
    .desc = "The L3_SRC_IPV6_UC_ROUTE_VRF table is used to configure VRF source IPv6\n routes.\n Note that if ALPM_MODE in the L3_ALPM_CONTROL logical table is\n set to ALPM_MODE_COMBINED, a default route with IPV6_MASK=0\n must be installed in order for L3_SRC_IPV6_UC_ROUTE to take effect.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_UC_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_uc_control_t_fields[] = {
    {
        .name  = TTL_1_TO_CPUs,  /* TTL_1_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with time-to-live (TTL) equals 1\n to the CPU.\n",
    },
    {
        .name  = TTL_ERROR_TO_CPUs,  /* TTL_ERROR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with TTL error to the CPU.",
    },
    {
        .name  = L3_MTU_CHECK_FAIL_TO_CPUs,  /* L3_MTU_CHECK_FAIL_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with maximum transmission unit (MTU) failure\n to the CPU\n",
    },
    {
        .name  = L3_SLOW_PATH_TO_CPUs,  /* L3_SLOW_PATH_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy L3 slow path packets to the CPU.",
    },
    {
        .name  = MARTIAN_ADDRESS_TO_CPUs,  /* MARTIAN_ADDRESS_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with martian address to the CPU.",
    },
    {
        .name  = NON_IP_ERROR_TO_CPUs,  /* NON_IP_ERROR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with non-IP L3 error to the CPU.",
    },
    {
        .name  = IPV4_UC_DST_MISS_TO_CPUs,  /* IPV4_UC_DST_MISS_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with IPv4 unicast destination miss\n to the CPU.\n",
    },
    {
        .name  = IPV4_ERROR_TO_CPUs,  /* IPV4_ERROR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with IPv4 error to the CPU.",
    },
    {
        .name  = IPV6_UC_MISS_TO_CPUs,  /* IPV6_UC_MISS_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with IPv6 unicast destination miss\n to the CPU.\n",
    },
    {
        .name  = IPV6_ERROR_TO_CPUs,  /* IPV6_ERROR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with IPv6 error to the CPU.",
    },
    {
        .name  = L3_SRC_HITs,  /* L3_SRC_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set the hit indicator L3_IPV4_UC_HOST.HIT/L3_IPV6_UC_HOST.HIT\n on a source IP address lookup.\n",
    },
    {
        .name  = DROP_SRC_IPV6_LINK_LOCALs,  /* DROP_SRC_IPV6_LINK_LOCAL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IPv6 packets with link local sources.",
    },
    {
        .name  = DO_NOT_DROP_SRC_IPV6_AND_DIP_LINK_LOCALs,  /* DO_NOT_DROP_SRC_IPV6_AND_DIP_LINK_LOCAL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to not drop IPv6 packets whose source IP and destination IP\n are link local if L3_UC_CONTROL.DROP_SRC_IPV6_LINK_LOCAL is set.\n",
    },
    {
        .name  = URPF_DROPs,  /* URPF_DROP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Unicast RPF drop functionality.\n 0 - Do not drop packets whenever L3_IIF is equal to L3_EIF.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_uc_control_t = {
    .name = L3_UC_CONTROLs, /* L3_UC_CONTROL */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_l3_uc_control_t_fields,
    .desc = "The L3_UC_CONTROL table provides controls to configure the device level\n L3 unicast functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_UC_MTU.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_uc_mtu_t_fields[] = {
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID.",
    },
    {
        .name  = L3_MTUs,  /* L3_MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 payload MTU for IP packets.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_uc_mtu_t = {
    .name = L3_UC_MTUs, /* L3_UC_MTU */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_uc_mtu_t_fields,
    .desc = "The L3_UC_MTU table determines the L3 MTU values used for MTU checks\n on IP unicast packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_UC_NHOP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_uc_nhop_t_fields[] = {
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "L3 unicast next hop ID.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Destination module ID to reach the Next Hop.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination logical port to reach the Next Hop.",
    },
    {
        .name  = IS_TRUNKs,  /* IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the next hop is a trunk (LAG) port.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Trunk Group Identifier. Applicable only if IS_TRUNK is enabled.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the next hop.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packet to CPU.",
    },
    {
        .name  = L3_EIF_VALIDs,  /* L3_EIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate L3_EIF_ID is valid.\n",
    },
    {
        .name  = L3_EIF_IDs,  /* L3_EIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_EIF logical table index.\n L3_EIF_ID should be in the same layer (underlay or overlay)\n as NHOP_ID for unicast traffic based on L3_BANK_CONTROL.\n Applicable only if L3_EIF_VALID is enabled.\n",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "MAC address to be used for destination MAC address replacement.",
    },
    {
        .name  = KEEP_DST_MACs,  /* KEEP_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip destination MAC address replacement.",
    },
    {
        .name  = KEEP_SRC_MACs,  /* KEEP_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip source MAC address replacement.",
    },
    {
        .name  = KEEP_TTLs,  /* KEEP_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip decrement of TTL.",
    },
    {
        .name  = KEEP_VLAN_IDs,  /* KEEP_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip outer VLAN ID replacement.",
    },
    {
        .name  = CTR_EGR_FLEX_POOL_NUMBERs,  /* CTR_EGR_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter pool number.",
    },
    {
        .name  = CTR_EGR_FLEX_BASE_INDEXs,  /* CTR_EGR_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_EGR_FLEX_OFFSET_MODEs,  /* CTR_EGR_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 class ID for egress FP.",
    },
    {
        .name  = CTR_EGR_EFLEX_OBJECTs,  /* CTR_EGR_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter object.",
    },
    {
        .name  = L3_UC_NHOP_CTR_EGR_EFLEX_ACTION_IDs,  /* L3_UC_NHOP_CTR_EGR_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "L3_UC_NHOP_CTR_EGR_EFLEX_ACTION logical table index\n when NHOP_ID is used as an underlay next hop.\n L3_UC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION logical table index\n when NHOP_ID is used as an overlay next hop.\n",
    },
    {
        .name  = DO_NOT_CUT_THROUGHs,  /* DO_NOT_CUT_THROUGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate the packet is not eligible for cut-through.\n",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Destination VP derived from this next hop.",
    },
    {
        .name  = ING_UNDERLAY_NHOP_VALIDs,  /* ING_UNDERLAY_NHOP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate ING_UNDERLAY_NHOP_ID is valid.\n Applicable only when NHOP_ID is used as an overlay next hop.\n",
    },
    {
        .name  = ING_UNDERLAY_NHOP_IDs,  /* ING_UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index to the logical table L3_UC_NHOP.\n It is derived from this overlay next hop in the ingress pipeline.\n Applicable only if ING_UNDERLAY_NHOP_VALID is enabled.\n",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_VALIDs,  /* EGR_UNDERLAY_NHOP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate EGR_UNDERLAY_NHOP_ID is valid.\n Applicable only when NHOP_ID is used as an underlay next hop.\n",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_IDs,  /* EGR_UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index to the logical table L3_UC_NHOP.\n It overrides the underlay next hop in the egress pipeline.\n Applicable only if EGR_UNDERLAY_NHOP_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_l3_uc_nhop_t = {
    .name = L3_UC_NHOPs, /* L3_UC_NHOP */
    .flags = BCMLTD_TABLE_F_TYPE_INDEX_ALLOC,
    .fields = 27,
    .field = bcmltd_l3_uc_nhop_t_fields,
    .desc = "The L3_UC_NHOP table provides both ingress and egress L3 nexthop controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_UC_NHOP_CTR_EGR_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_uc_nhop_ctr_egr_eflex_action_t_fields[] = {
    {
        .name  = L3_UC_NHOP_CTR_EGR_EFLEX_ACTION_IDs,  /* L3_UC_NHOP_CTR_EGR_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L3_UC_NHOP_CTR_EGR_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_uc_nhop_ctr_egr_eflex_action_t = {
    .name = L3_UC_NHOP_CTR_EGR_EFLEX_ACTIONs, /* L3_UC_NHOP_CTR_EGR_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_uc_nhop_ctr_egr_eflex_action_t_fields,
    .desc = "The L3_UC_NHOP_CTR_EGR_EFLEX_ACTION table is used to configure the\n L3 unicast next hop egress flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_UC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_uc_overlay_nhop_ctr_egr_eflex_action_t_fields[] = {
    {
        .name  = L3_UC_NHOP_CTR_EGR_EFLEX_ACTION_IDs,  /* L3_UC_NHOP_CTR_EGR_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the L3_UC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_uc_overlay_nhop_ctr_egr_eflex_action_t = {
    .name = L3_UC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTIONs, /* L3_UC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_uc_overlay_nhop_ctr_egr_eflex_action_t_fields,
    .desc = "The L3_UC_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION table is used to configure the\n L3 unicast overlay next hop egress flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_UC_TNL_MTU.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_uc_tnl_mtu_t_fields[] = {
    {
        .name  = L3_EIF_IDs,  /* L3_EIF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "L3_EIF ID.",
    },
    {
        .name  = L3_MTUs,  /* L3_MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3 payload MTU for IP packets.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_uc_tnl_mtu_t = {
    .name = L3_UC_TNL_MTUs, /* L3_UC_TNL_MTU */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_l3_uc_tnl_mtu_t_fields,
    .desc = "The L3_UC_TNL_MTU table determines the L3 MTU values used for MTU checks\n on tunneled IP unicast packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/l3/L3_VRF.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_l3_vrf_t_fields[] = {
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VRF for L3 lookup.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
};
const bcmltd_table_rep_t bcmltd_l3_vrf_t = {
    .name = L3_VRFs, /* L3_VRF */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_l3_vrf_t_fields,
    .desc = "The L3_VRF table is used to configure L3 VRF properties.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_ALGORITHM.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_algorithm_t_fields[] = {
    {
        .name  = HASH0_INSTANCE0_ALGs,  /* HASH0_INSTANCE0_ALG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Algorithm to be used for Hash 0 Instance 0 computation.",
    },
    {
        .name  = HASH0_INSTANCE1_ALGs,  /* HASH0_INSTANCE1_ALG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Algorithm to be used for Hash 0 Instance 1 computation.",
    },
    {
        .name  = HASH1_INSTANCE0_ALGs,  /* HASH1_INSTANCE0_ALG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Algorithm to be used for Hash 1 Instance 0 computation.",
    },
    {
        .name  = HASH1_INSTANCE1_ALGs,  /* HASH1_INSTANCE1_ALG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Algorithm to be used for Hash 1 Instance 1 computation.",
    },
    {
        .name  = MACRO_FLOW_HASH_ALGs,  /* MACRO_FLOW_HASH_ALG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Algorithm to be used for generation of LB Hash Macro Flow\n Identifier.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_algorithm_t = {
    .name = LB_HASH_ALGORITHMs, /* LB_HASH_ALGORITHM */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_lb_hash_algorithm_t_fields,
    .desc = "Hash algorithm selection for various hash types.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_BINS_ASSIGNMENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_bins_assignment_t_fields[] = {
    {
        .name  = HASH0_BIN0s,  /* HASH0_BIN0 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Per-chip control that indicates whether hash bin 0 in\n field selection block 0 is populated with the destination module\n ID or the source virtual interface from the VNTAG.\n",
    },
    {
        .name  = HASH1_BIN0s,  /* HASH1_BIN0 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Per-chip control that indicates whether hash bin 0 in\n field selection block 1 is populated with the destination module\n ID or the source virtual interface from the VNTAG.\n",
    },
    {
        .name  = HASH0_BIN1s,  /* HASH0_BIN1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Per-chip control that indicates whether hash bin 1 in\n field selection block 0 is populated with the destination port\n ID or the destination virtual interface from the VNTAG.\n",
    },
    {
        .name  = HASH1_BIN1s,  /* HASH1_BIN1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Per-chip control that indicates whether hash bin 1 in\n field selection block 1 is populated with the destination port\n ID or the destination virtual interface from the VNTAG.\n",
    },
    {
        .name  = HASH0_BINS0_1_IPV6_FLOW_LABEL_ENs,  /* HASH0_BINS0_1_IPV6_FLOW_LABEL_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 flow label hashing to hash bin 0 and 1\n on hash key 0.\n",
    },
    {
        .name  = HASH1_BINS0_1_IPV6_FLOW_LABEL_ENs,  /* HASH1_BINS0_1_IPV6_FLOW_LABEL_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv6 flow label hashing to hash bin 0 and 1\n on hash key 1.\n",
    },
    {
        .name  = HASH0_BIN2_FLEX_ENs,  /* HASH0_BIN2_FLEX_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable flexible hashing scheme on 1st byte of hash key 0.",
    },
    {
        .name  = HASH1_BIN2_FLEX_ENs,  /* HASH1_BIN2_FLEX_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable flexible hashing scheme on 1st byte of hash key 1.",
    },
    {
        .name  = HASH0_BIN3_FLEX_ENs,  /* HASH0_BIN3_FLEX_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable flexible hashing scheme on 2nd byte of hash key 0.",
    },
    {
        .name  = HASH1_BIN3_FLEX_ENs,  /* HASH1_BIN3_FLEX_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable flexible hashing scheme on 2nd byte of hash key 1.",
    },
    {
        .name  = HASH0_BIN2_UDF_ENs,  /* HASH0_BIN2_UDF_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable driving UDF1.6 and UDF1.7 output vectors\n to hash bin 2 of hash key 0.\n",
    },
    {
        .name  = HASH1_BIN2_UDF_ENs,  /* HASH1_BIN2_UDF_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable driving UDF1.6 and UDF1.7 output vectors\n to hash bin 2 of hash key 1.\n",
    },
    {
        .name  = HASH0_BIN3_UDF_ENs,  /* HASH0_BIN3_UDF_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable driving UDF2.6 and UDF2.7 output vectors\n to hash bin 3 of hash key 0.\n",
    },
    {
        .name  = HASH1_BIN3_UDF_ENs,  /* HASH1_BIN3_UDF_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable driving UDF2.6 and UDF2.7 output vectors\n to hash bin 3 of hash key 1.\n",
    },
    {
        .name  = HASH0_BINS5_6_GTP_ENs,  /* HASH0_BINS5_6_GTP_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable driving GTP tunnel endpoint identifier to hash bin 5 and 6\n on hash key 0.\n",
    },
    {
        .name  = HASH1_BINS5_6_GTP_ENs,  /* HASH1_BINS5_6_GTP_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable driving GTP tunnel endpoint identifier to hash bin 5 and 6\n on hash key 1.\n",
    },
    {
        .name  = HASH0_BINS5_6_L2GRE_KEY_ENs,  /* HASH0_BINS5_6_L2GRE_KEY_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to place GRE key extracted from the L2 GRE header in hash\n bins 5 and 6 of hash key 0.\n",
    },
    {
        .name  = HASH1_BINS5_6_L2GRE_KEY_ENs,  /* HASH1_BINS5_6_L2GRE_KEY_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to place GRE key extracted from the L2 GRE header in hash\n bins 5 and 6 of hash key 1.\n",
    },
    {
        .name  = HASH0_BIN5_6_L2GRE_MASKs,  /* HASH0_BIN5_6_L2GRE_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask used for the GRE key in hash bin 5 and 6 of hash key 0.\n Applicable only if HASH0_BINS5_6_L2GRE_KEY_EN is enabled.\n",
    },
    {
        .name  = HASH1_BIN5_6_L2GRE_MASKs,  /* HASH1_BIN5_6_L2GRE_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask used for the GRE key in hash bin 5 and 6 of hash key 1.\n Applicable only if HASH1_BINS5_6_L2GRE_KEY_EN is enabled.\n",
    },
    {
        .name  = HASH0_BIN5_6_IPSEC_SELECTs,  /* HASH0_BIN5_6_IPSEC_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select used to driving IPsec SPI to hash bin 5 and 6 of hash key 0.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = HASH1_BIN5_6_IPSEC_SELECTs,  /* HASH1_BIN5_6_IPSEC_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select used to driving IPsec SPI to hash bin 5 and 6 of hash key 1.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = HASH0_BINS0_3_EGR_PORT_ID_ENs,  /* HASH0_BINS0_3_EGR_PORT_ID_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable destination port hashing to hash bin 0 and 3\n on hash key 0.\n",
    },
    {
        .name  = HASH1_BINS0_3_EGR_PORT_ID_ENs,  /* HASH1_BINS0_3_EGR_PORT_ID_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable destination port hashing to hash bin 0 and 3\n on hash key 1.\n",
    },
    {
        .name  = HASH0_BIN12_SEED_OVERLAY_ENs,  /* HASH0_BIN12_SEED_OVERLAY_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable overlay where the 224-bit input to CRC/XOR computations will\n be\n {LB_HASH_SEED_CONTROL.HASH0_SEED[31:16], bin 12, bin 11 to bin 0}.\n",
    },
    {
        .name  = HASH1_BIN12_SEED_OVERLAY_ENs,  /* HASH1_BIN12_SEED_OVERLAY_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable overlay where the 224-bit input to CRC/XOR computations will\n be\n {LB_HASH_SEED_CONTROL.HASH1_SEED[31:16], bin 12, bin 11 to bin 0}.\n",
    },
    {
        .name  = HASH0_ALL_BINS_PRE_PROCESSING_ENs,  /* HASH0_ALL_BINS_PRE_PROCESSING_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables the pre-processing function\n to each of the hash bins in hash computation block 0.\n",
    },
    {
        .name  = HASH1_ALL_BINS_PRE_PROCESSING_ENs,  /* HASH1_ALL_BINS_PRE_PROCESSING_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables the pre-processing function\n to each of the hash bins in hash computation block 1.\n",
    },
    {
        .name  = HASH0_BIN_FLEX_FIELD_SELECTs,  /* HASH0_BIN_FLEX_FIELD_SELECT */
        .flags = 0,
        .width = 1,
        .depth = 11,
        .desc = "Enable to use flex fields 3 to 13 for flexible hash key 0:\n Flex fields 1 and 2 are mapped to bins 2 and 3 by\n LB_HASH_BINS_ASSIGNMENT.HASH0_BIN2_FLEX_EN and\n LB_HASH_BINS_ASSIGNMENT.HASH0_BIN3_FLEX_EN.\n When flex fields 3 to 13 are enabled, flex field 3 is mapped to\n bin 4, flex field 4 to bin 5 until wrap around, and\n flex field 13 is mapped to bin 1.\n",
    },
    {
        .name  = HASH1_BIN_FLEX_FIELD_SELECTs,  /* HASH1_BIN_FLEX_FIELD_SELECT */
        .flags = 0,
        .width = 1,
        .depth = 11,
        .desc = "Enable to use flex fields 3 to 13 for flexible hash key 1:\n Flex fields 1 and 2 are mapped to bins 2 and 3 by\n LB_HASH_BINS_ASSIGNMENT.HASH1_BIN2_FLEX_EN and\n LB_HASH_BINS_ASSIGNMENT.HASH1_BIN3_FLEX_EN.\n When flex fields 3 to 13 are enabled, flex field 3 is mapped to\n bin 4, flex field 4 to bin 5 until wrap around, and\n flex field 13 is mapped to bin 1.\n",
    },
    {
        .name  = HASH0_BIN_EXT_FLEX_FIELD_SELECTs,  /* HASH0_BIN_EXT_FLEX_FIELD_SELECT */
        .flags = 0,
        .width = 1,
        .depth = 12,
        .desc = "Enable to use flex fields 14 to 15 for flexible hash key 0:\n When flex fields 14 to 25 are enabled, flex field 14 is mapped to\n bin 13, flex field 15 to bin 14 until flex field 25 is mapped\n to bin 24.\n",
    },
    {
        .name  = HASH1_BIN_EXT_FLEX_FIELD_SELECTs,  /* HASH1_BIN_EXT_FLEX_FIELD_SELECT */
        .flags = 0,
        .width = 1,
        .depth = 12,
        .desc = "Enable to use flex fields 14 to 15 for flexible hash key 1:\n When flex fields 14 to 25 are enabled, flex field 14 is mapped to\n bin 13, flex field 15 to bin 14 until flex field 25 is mapped\n to bin 24.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_bins_assignment_t = {
    .name = LB_HASH_BINS_ASSIGNMENTs, /* LB_HASH_BINS_ASSIGNMENT */
    .flags = 0,
    .fields = 32,
    .field = bcmltd_lb_hash_bins_assignment_t_fields,
    .desc = "The LB_HASH_BINS_ASSIGNMENT table specifies the hash bin assignment\n for various hash types.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_control_t_fields[] = {
    {
        .name  = L3_HASH_ALGs,  /* L3_HASH_ALG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select hashing algorithm used for L3 table lookups.",
    },
    {
        .name  = L2_HASH_ALGs,  /* L2_HASH_ALG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select hashing algorithm used for L2 table lookups.",
    },
    {
        .name  = LBID_COMPUTEs,  /* LBID_COMPUTE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Select how LBID is computed.",
    },
    {
        .name  = USE_TCP_UDP_PORTs,  /* USE_TCP_UDP_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Select to use TCP and UDP port for hashing.",
    },
    {
        .name  = USE_SCTP_SRC_AND_DST_L4_PORTs,  /* USE_SCTP_SRC_AND_DST_L4_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use source and destination ports in the stream\n control transmission protocol (SCTP) for hashing.\n",
    },
    {
        .name  = USE_GTP_TEIDs,  /* USE_GTP_TEID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use tunnel endpoint identifier (TEID) in\n GPRS tunneling protocol (GTP) for hashing.\n GTP packets are identified by matching the L4 ports in the\n packet with those specified in the LB_HASH_GTP_L4_PORT_MATCH\n table. TEID is identified by matching the first byte in the\n packet header (masked with GTP_HDR_FIRST_BYTE_MASK) with the\n value specified in GTP_HDR_FIRST_BYTE.\n",
    },
    {
        .name  = GTP_HDR_FIRST_BYTEs,  /* GTP_HDR_FIRST_BYTE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to match against the first byte in the GPRS tunneling\n protocol (GTP) packet header to identify TEID.\n",
    },
    {
        .name  = GTP_HDR_FIRST_BYTE_MASKs,  /* GTP_HDR_FIRST_BYTE_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask value to be applied to the first byte in the GPRS\n tunneling protocol (GTP) packet header before matching with\n GTP_HDR_FIRST_BYTE.\n",
    },
    {
        .name  = ENTROPY_LABEL_FLOW_BASEDs,  /* ENTROPY_LABEL_FLOW_BASED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use the flow based hash output selection mechanism\n for entropy label.\n",
    },
    {
        .name  = FLEX_HASHs,  /* FLEX_HASH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable lookup in LB_HASH_FLEX_FIELDS_SELECTION LT",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_control_t = {
    .name = LB_HASH_CONTROLs, /* LB_HASH_CONTROL */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_lb_hash_control_t_fields,
    .desc = "Hash control configuration.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_DEVICE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_device_info_t_fields[] = {
    {
        .name  = NUM_NONCONCAT_SUB_FIELDs,  /* NUM_NONCONCAT_SUB_FIELD */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of elements in the array of NONCONCAT_SUB_FIELD_WIDTH",
    },
    {
        .name  = NONCONCAT_SUB_FIELD_WIDTHs,  /* NONCONCAT_SUB_FIELD_WIDTH */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "Array of sub-field widths (bits) for non-concatenate mode.",
    },
    {
        .name  = NUM_CONCAT_SUB_FIELDs,  /* NUM_CONCAT_SUB_FIELD */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of elements in the array of CONCAT_SUB_FIELD_WIDTH",
    },
    {
        .name  = CONCAT_SUB_FIELD_WIDTHs,  /* CONCAT_SUB_FIELD_WIDTH */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "Array of sub-field widths (bits) for concatenate mode.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_device_info_t = {
    .name = LB_HASH_DEVICE_INFOs, /* LB_HASH_DEVICE_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_lb_hash_device_info_t_fields,
    .desc = "The LB_HASH_DEVICE_INFO is an read-only table which specifies\n device specific load balance hashing information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_DLB_ECMP_LEVEL0_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_dlb_ecmp_level0_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_DLB_ECMP_LEVEL0_OUTPUT_SELECTION_IDs,  /* LB_HASH_DLB_ECMP_LEVEL0_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into LB_HASH_DLB_ECMP_LEVEL0_OUTPUT_SELECTION table.\n",
    },
    {
        .name  = LB_HASH_INSTANCEs,  /* LB_HASH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Hash table instance.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenation mode:\n treats hash output as 1 * 64-bit field.\n Disable to use non-concatenation mode:\n treats hash output as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the selection of subset of hash value\n from flex digest output.\n",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies the offset of the least significant bit\n in the selected subset hash value.\n",
    },
    {
        .name  = RESULT_SIZEs,  /* RESULT_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicates the number of bits required in the final hash result\n value, this final hash value is used in the group member offset\n index calculation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_dlb_ecmp_level0_output_selection_t = {
    .name = LB_HASH_DLB_ECMP_LEVEL0_OUTPUT_SELECTIONs, /* LB_HASH_DLB_ECMP_LEVEL0_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_lb_hash_dlb_ecmp_level0_output_selection_t_fields,
    .desc = "The LB_HASH_DLB_ECMP_LEVEL0_OUTPUT_SELECTION table specifies\n the hash output selection used for the ECMP level0 resolution using DLB.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_DLB_TRUNK_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_dlb_trunk_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_DLB_TRUNK_OUTPUT_SELECTION_IDs,  /* LB_HASH_DLB_TRUNK_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into LB_HASH_DLB_TRUNK_OUTPUT_SELECTION table.\n",
    },
    {
        .name  = LB_HASH_INSTANCEs,  /* LB_HASH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Hash table instance.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenation mode:\n treats hash output as 1 * 64-bit field.\n Disable to use non-concatenation mode:\n treats hash output as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the selection of subset of hash value\n from flex digest output.\n",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies the offset of the least significant bit\n in the selected subset hash value.\n",
    },
    {
        .name  = RESULT_SIZEs,  /* RESULT_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicates the number of bits required in the final hash result\n value, this final hash value is used in the group member offset\n index calculation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_dlb_trunk_output_selection_t = {
    .name = LB_HASH_DLB_TRUNK_OUTPUT_SELECTIONs, /* LB_HASH_DLB_TRUNK_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_lb_hash_dlb_trunk_output_selection_t_fields,
    .desc = "The LB_HASH_DLB_TRUNK_OUTPUT_SELECTION table specifies\n the hash output selection used for the trunk resolution using DLB.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_ECMP_LEVEL0_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_ecmp_level0_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_TABLE_INSTANCEs,  /* LB_HASH_TABLE_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "The ECMP hash output table instance that will be used for generating\n the final ECMP hash value for this ECMP level.\n\n The value specified here must match the value specified in\n ECMP_LEVEL0_HASH_OUTPUT_CONTROL_PROFILE.LB_HASH_TABLE_INSTANCE\n logical table field.\n",
    },
    {
        .name  = LB_HASH_ECMP_LEVEL0_OUTPUT_SELECTION_IDs,  /* LB_HASH_ECMP_LEVEL0_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "The ECMP hash table flow identifier value generated by the source\n specified in ECMP_LEVEL0_HASH_OUTPUT_CONTROL_PROFILE\n .LB_HASH_ECMP_LEVEL0_OUTPUT_SELECTION_ID_SRC logical table field.\n",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable this control to use concatenate mode and treat the hash\n outputs as single 64-bit hash field.\n Disable this control to use non-concatenate mode and treat the hash\n outputs as four 16-bit hash fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The hash subset selection for the first level ECMP resolution\n function.\n",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The offset of LSB for picking the hash value from the subset\n selected for first level ECMP resolution function.\n",
    },
    {
        .name  = RESULT_SIZEs,  /* RESULT_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicates the number of bits required in the final ECMP hash result\n value, this final hash value is used in the group member offset\n index calculation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_ecmp_level0_output_selection_t = {
    .name = LB_HASH_ECMP_LEVEL0_OUTPUT_SELECTIONs, /* LB_HASH_ECMP_LEVEL0_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_lb_hash_ecmp_level0_output_selection_t_fields,
    .desc = "The LB_HASH_ECMP_LEVEL0_OUTPUT_SELECTION logical table is indexed by\n the hash table instance and  hash table flow ID key fields pair.\n The data fields in this logical table are inputs for generating the final\n ECMP hash value, which is used in member offset index computation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_ECMP_LEVEL1_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_ecmp_level1_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_TABLE_INSTANCEs,  /* LB_HASH_TABLE_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "The ECMP hash output table instance that will be used for generating\n the final ECMP hash value for this ECMP level.\n\n The value specified here must match the value specified in\n ECMP_LEVEL1_HASH_OUTPUT_CONTROL_PROFILE\n .HASH_TABLE_INSTANCE logical table field.\n",
    },
    {
        .name  = LB_HASH_ECMP_LEVEL1_OUTPUT_SELECTION_IDs,  /* LB_HASH_ECMP_LEVEL1_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "The ECMP hash table flow identifier value generated by the source\n specified in ECMP_LEVEL1_HASH_OUTPUT_CONTROL_PROFILE\n .LB_HASH_ECMP_LEVEL1_OUTPUT_SELECTION_ID logical table field.\n",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable this control to use concatenate mode and treat the hash\n outputs as single 64-bit hash field.\n Disable this control to use non-concatenate mode and treat the hash\n outputs as four 16-bit hash fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The hash subset selection for the second level ECMP resolution\n function.\n",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The offset of LSB for picking the hash value from the subset\n selected for second level ECMP resolution function.\n",
    },
    {
        .name  = RESULT_SIZEs,  /* RESULT_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicates the number of bits required in the final ECMP hash result\n value, this final hash value is used in the group member offset\n index calculation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_ecmp_level1_output_selection_t = {
    .name = LB_HASH_ECMP_LEVEL1_OUTPUT_SELECTIONs, /* LB_HASH_ECMP_LEVEL1_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_lb_hash_ecmp_level1_output_selection_t_fields,
    .desc = "The LB_HASH_ECMP_LEVEL1_OUTPUT_SELECTION logical table is indexed by\n the hash table instance and hash table flow ID key fields pair.\n The data fields in this logical table are inputs for generating the final\n ECMP hash value, which is used in member offset index computation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_ENTROPY_HASH_SELECTION_CONTROL_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_entropy_hash_selection_control_profile_t_fields[] = {
    {
        .name  = PROFILE_IDs,  /* PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Entropy profile identifier.",
    },
    {
        .name  = HASH_INSTANCEs,  /* HASH_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The hash output table instance (0/1) selected for generating\n the final entropy value.\n LB_HASH_ENTROPY_LABEL_OUTPUT_SELECTION.HASH_TABLE_INSTANCE\n key field value.\n",
    },
    {
        .name  = HASH_FLOW_ID_SRCs,  /* HASH_FLOW_ID_SRC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The Flex Digest output sub-field selected as the source for\n generating LB_HASH_ENTROPY_LABEL_OUTPUT_SELECTION.HASH_FLOW_ID_SRC\n key field value, which is used in combination with\n HASH_TABLE_INSTANCE key field to index into the\n LB_HASH_ENTROPY_LABEL_OUTPUT_SELECTION logical table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_entropy_hash_selection_control_profile_t = {
    .name = LB_HASH_ENTROPY_HASH_SELECTION_CONTROL_PROFILEs, /* LB_HASH_ENTROPY_HASH_SELECTION_CONTROL_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_lb_hash_entropy_hash_selection_control_profile_t_fields,
    .desc = "The LB_HASH_ENTROPY_HASH_SELECTION_CONTROL_PROFILE logical table is used\n for selecting a hash output table instance and the source for\n generating an index into the selected hash output table for computing\n the entropy.\n\n This logical table is indexed by an entropy PROFILE_ID value that is defined\n in the NPL application.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_ENTROPY_LABEL_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_entropy_label_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_INSTANCEs,  /* LB_HASH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "The hash output table instance that will be used for\n generating the final hash value.\n",
    },
    {
        .name  = LB_HASH_ENTROPY_LABEL_OUTPUT_SELECTION_IDs,  /* LB_HASH_ENTROPY_LABEL_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "The hash table flow identifier value generated by the source.\n This index is generated from the\n LB_HASH_ENTROPY_HASH_SELECTION_CONTROL_PROFILE table.\n",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable this control to use concatenate mode and treat the hash\n outputs as single 64-bit hash field.\n Disable this control to use non-concatenate mode and treat the hash\n outputs as four 16-bit hash fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The hash subset selection for entropy computation.\n",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The offset of LSB for picking the hash value from the subset\n selected for entropy computation.\n",
    },
    {
        .name  = RESULT_SIZEs,  /* RESULT_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicates the number of bits required in the final entropy result\n value, this final hash value is used in the group member offset\n index calculation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_entropy_label_output_selection_t = {
    .name = LB_HASH_ENTROPY_LABEL_OUTPUT_SELECTIONs, /* LB_HASH_ENTROPY_LABEL_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_lb_hash_entropy_label_output_selection_t_fields,
    .desc = "LB_HASH_ENTROPY_LABEL_OUTPUT_SELECTION is used to specify the hash outputs\n selection controls which are used for the entropy label calculation.\n\n Each application can select the subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n The LB_HASH_ENTROPY_LABEL_OUTPUT_SELECTION logical table is indexed by\n the hash table instance and  hash table flow ID key fields pair.\n The data fields in this logical table are inputs for generating the final\n entropy value.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_EXT_FLEX_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_ext_flex_fields_selection_t_fields[] = {
    {
        .name  = UDF0_DATAs,  /* UDF0_DATA */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Packet data extracted via UDF chunk 12.",
    },
    {
        .name  = UDF0_DATA_MASKs,  /* UDF0_DATA_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDF0_DATA.",
    },
    {
        .name  = UDF1_DATAs,  /* UDF1_DATA */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Packet data extracted via UDF chunk 13.",
    },
    {
        .name  = UDF1_DATA_MASKs,  /* UDF1_DATA_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDF1_DATA.",
    },
    {
        .name  = UDF2_DATAs,  /* UDF2_DATA */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Packet data extracted via UDF chunk 14.",
    },
    {
        .name  = UDF2_DATA_MASKs,  /* UDF2_DATA_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDF2_DATA.",
    },
    {
        .name  = UDF3_DATAs,  /* UDF3_DATA */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Packet data extracted via UDF chunk 15.",
    },
    {
        .name  = UDF3_DATA_MASKs,  /* UDF3_DATA_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDF3_DATA.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Class ID assigned by UDF.",
    },
    {
        .name  = CLASS_ID_MASKs,  /* CLASS_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for CLASS_ID.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Entry Priority.",
    },
    {
        .name  = BIN2_FIELD_SELECTs,  /* BIN2_FIELD_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Field selection criteria for field 1. The field data is\n overlaid with RTAG7 hash Bin 2 when flexible hashing is\n enabled for bin 2 using\n LB_HASH_BINS_ASSIGNMENT.HASH0_BIN2_FLEX_EN /\n LB_HASH_BINS_ASSIGNMENT.HASH0_BIN2_FLEX_EN.\n",
    },
    {
        .name  = BIN2_L4_OFFSETs,  /* BIN2_L4_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset from the end of L3 header to select 16 bits for\n hash bin 2.\n Applicable when BIN2_FIELD_SELECT == L4_DATA.\n",
    },
    {
        .name  = BIN2_UDF_CHUNKs,  /* BIN2_UDF_CHUNK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "UDF chunk from which data is extracted to select 16 bits\n for hash bin 2.\n Applicable when BIN2_FIELD_SELECT == UDF.\n",
    },
    {
        .name  = BIN2_FIELD_MASKs,  /* BIN2_FIELD_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask to be AND'ed with output of field selected for\n hash bin 2.\n",
    },
    {
        .name  = BIN3_FIELD_SELECTs,  /* BIN3_FIELD_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Field selection criteria for field 2. The field data is\n overlaid with RTAG7 hash Bin 3 when flexible hashing is\n enabled for bin 3 using\n LB_HASH_BINS_ASSIGNMENT.HASH0_BIN3_FLEX_EN /\n LB_HASH_BINS_ASSIGNMENT.HASH3_BIN2_FLEX_EN.\n",
    },
    {
        .name  = BIN3_L4_OFFSETs,  /* BIN3_L4_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset from the end of L3 header to select 16 bits for\n hash bin 3.\n Applicable when BIN3_FIELD_SEL_TYPE == L4_DATA.\n",
    },
    {
        .name  = BIN3_UDF_CHUNKs,  /* BIN3_UDF_CHUNK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "UDF chunk from which data is extracted to select 16 bits\n for hash bin 3.\n Applicable when BIN3_FIELD_SEL_TYPE == UDF.\n",
    },
    {
        .name  = BIN3_FIELD_MASKs,  /* BIN3_FIELD_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask to be AND'ed with output of field selected for\n hash bin 3.\n",
    },
    {
        .name  = BIN_FIELD_SELECTs,  /* BIN_FIELD_SELECT */
        .flags = 0,
        .width = 1,
        .depth = 23,
        .desc = "Enable field selection for fields 3 to 13. When field 3 is\n enabled, field 3 is mapped to bin 4, field 4 is mapped to\n bin 5 until wrap around, and field 13 is mapped to bin 1.\n",
    },
    {
        .name  = BIN_UDF_CHUNKs,  /* BIN_UDF_CHUNK */
        .flags = 0,
        .width = 8,
        .depth = 23,
        .desc = "UDF chunk from which data is extracted to select bits\n for flexible hashing.\n",
    },
    {
        .name  = BIN_FIELD_MASKs,  /* BIN_FIELD_MASK */
        .flags = 0,
        .width = 16,
        .depth = 23,
        .desc = "Mask to be AND'ed with output of fields selected for\n hashing bins.\n",
    },
    {
        .name  = USE_TNL_TRANSIT_INNER_HDRs,  /* USE_TNL_TRANSIT_INNER_HDR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use TNL_TRANSIT_INNER_HDR.",
    },
    {
        .name  = TNL_TRANSIT_INNER_HDRs,  /* TNL_TRANSIT_INNER_HDR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate the inner header fields are used for\n flex hashing for tunnel transit packets. Otherwise, outer\n header fields are used for hashing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_ext_flex_fields_selection_t = {
    .name = LB_HASH_EXT_FLEX_FIELDS_SELECTIONs, /* LB_HASH_EXT_FLEX_FIELDS_SELECTION */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 24,
    .field = bcmltd_lb_hash_ext_flex_fields_selection_t_fields,
    .desc = "The LB_HASH_EXT_FLEX_FIELDS_SELECTION table specifies hash field\n selection for flexible hashing.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_FLEX_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_flex_fields_selection_t_fields[] = {
    {
        .name  = UDF0_DATAs,  /* UDF0_DATA */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Packet data extracted via UDF chunk 12.",
    },
    {
        .name  = UDF0_DATA_MASKs,  /* UDF0_DATA_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDF0_DATA.",
    },
    {
        .name  = UDF1_DATAs,  /* UDF1_DATA */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Packet data extracted via UDF chunk 13.",
    },
    {
        .name  = UDF1_DATA_MASKs,  /* UDF1_DATA_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDF1_DATA.",
    },
    {
        .name  = UDF2_DATAs,  /* UDF2_DATA */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Packet data extracted via UDF chunk 14.",
    },
    {
        .name  = UDF2_DATA_MASKs,  /* UDF2_DATA_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDF2_DATA.",
    },
    {
        .name  = UDF3_DATAs,  /* UDF3_DATA */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Packet data extracted via UDF chunk 15.",
    },
    {
        .name  = UDF3_DATA_MASKs,  /* UDF3_DATA_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDF3_DATA.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Entry Priority",
    },
    {
        .name  = BIN2_FIELD_SELECTs,  /* BIN2_FIELD_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Field selection criteria for field 1. The field data is\n overlaid with RTAG7 hash Bin 2 when flexible hashing is\n enabled for bin 2 using\n LB_HASH_BINS_ASSIGNMENT.HASH0_BIN2_FLEX_EN /\n LB_HASH_BINS_ASSIGNMENT.HASH0_BIN2_FLEX_EN\n",
    },
    {
        .name  = BIN2_L4_OFFSETs,  /* BIN2_L4_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset from the end of L3 header to select 16 bits for\n hash bin 2.\n Applicable when BIN2_FIELD_SELECT == L4_DATA\n",
    },
    {
        .name  = BIN2_UDF_CHUNKs,  /* BIN2_UDF_CHUNK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "UDF chunk from which data is extracted to select 16 bits\n for hash bin 2.\n Applicable when BIN2_FIELD_SELECT == UDF\n",
    },
    {
        .name  = BIN2_FIELD_MASKs,  /* BIN2_FIELD_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask to be AND'ed with output of field selected for\n hash bin 2.\n",
    },
    {
        .name  = BIN3_FIELD_SELECTs,  /* BIN3_FIELD_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Field selection criteria for field 2. The field data is\n overlaid with RTAG7 hash Bin 3 when flexible hashing is\n enabled for bin 3 using\n LB_HASH_BINS_ASSIGNMENT.HASH0_BIN3_FLEX_EN /\n LB_HASH_BINS_ASSIGNMENT.HASH3_BIN2_FLEX_EN\n",
    },
    {
        .name  = BIN3_L4_OFFSETs,  /* BIN3_L4_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset from the end of L3 header to select 16 bits for\n hash bin 3.\n Applicable when BIN3_FIELD_SEL_TYPE == L4_DATA\n",
    },
    {
        .name  = BIN3_UDF_CHUNKs,  /* BIN3_UDF_CHUNK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "UDF chunk from which data is extracted to select 16 bits\n for hash bin 3.\n Applicable when BIN3_FIELD_SEL_TYPE == UDF\n",
    },
    {
        .name  = BIN3_FIELD_MASKs,  /* BIN3_FIELD_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask to be AND'ed with output of field selected for\n hash bin 3.\n",
    },
    {
        .name  = BIN_FIELD_SELECTs,  /* BIN_FIELD_SELECT */
        .flags = 0,
        .width = 1,
        .depth = 11,
        .desc = "Enable field selection for fields 3 to 13. When field 3 is\n enabled, field 3 is mapped to bin 4, field 4 is mapped to\n bin 5 until wrap around, and field 13 is mapped to bin 1.\n",
    },
    {
        .name  = BIN_UDF_CHUNKs,  /* BIN_UDF_CHUNK */
        .flags = 0,
        .width = 8,
        .depth = 11,
        .desc = "UDF chunk from which data is extracted to select bits\n for flexible hashing\n",
    },
    {
        .name  = BIN_FIELD_MASKs,  /* BIN_FIELD_MASK */
        .flags = 0,
        .width = 16,
        .depth = 11,
        .desc = "Mask to be AND'ed with output of fields selected for\n hashing bins.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_flex_fields_selection_t = {
    .name = LB_HASH_FLEX_FIELDS_SELECTIONs, /* LB_HASH_FLEX_FIELDS_SELECTION */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 20,
    .field = bcmltd_lb_hash_flex_fields_selection_t_fields,
    .desc = "The LB_HASH_FLEX_FIELDS_SELECTION table specifies hash field\n selection for flexible hashing.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_FLOW_DLB_ECMP_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_flow_dlb_ecmp_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_FLOW_DLB_ECMP_OUTPUT_SELECTION_IDs,  /* LB_HASH_FLOW_DLB_ECMP_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Selection ID based on flow number.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as\n                                 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as\n                                      4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for DLB ECMP.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for DLB ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_flow_dlb_ecmp_output_selection_t = {
    .name = LB_HASH_FLOW_DLB_ECMP_OUTPUT_SELECTIONs, /* LB_HASH_FLOW_DLB_ECMP_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_lb_hash_flow_dlb_ecmp_output_selection_t_fields,
    .desc = "The LB_HASH_FLOW_DLB_ECMP_OUTPUT_SELECTION table specifies hash output\n selection control for flow based DLB ECMP - mode, subset and offset.\n\n Flow based hash output selection indexed by Macro Flow ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least\n significant bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least\n     significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_FLOW_ECMP_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_flow_ecmp_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_FLOW_ECMP_OUTPUT_SELECTION_IDs,  /* LB_HASH_FLOW_ECMP_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Selection ID based on flow number.",
    },
    {
        .name  = LEVEL2_CONCATs,  /* LEVEL2_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = LEVEL2_SUBSET_SELECTs,  /* LEVEL2_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for ECMP level 2.",
    },
    {
        .name  = LEVEL2_OFFSETs,  /* LEVEL2_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for ECMP level 2.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for ECMP.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for ECMP.",
    },
    {
        .name  = MEMBER_WEIGHT_CONCATs,  /* MEMBER_WEIGHT_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for member weight of enhanced\n weighted ECMP: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as\n                                      4 * 16-bit fields.\n",
    },
    {
        .name  = MEMBER_WEIGHT_SUBSET_SELECTs,  /* MEMBER_WEIGHT_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for member weight of enhanced weighted ECMP.\n",
    },
    {
        .name  = MEMBER_WEIGHT_OFFSETs,  /* MEMBER_WEIGHT_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for member weight of enhanced weighted ECMP.",
    },
    {
        .name  = OVERLAY_CONCATs,  /* OVERLAY_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for overlay ECMP.",
    },
    {
        .name  = OVERLAY_SUBSET_SELECTs,  /* OVERLAY_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for overlay ECMP.",
    },
    {
        .name  = OVERLAY_OFFSETs,  /* OVERLAY_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for overlay ECMP.",
    },
    {
        .name  = OVERLAY_MEMBER_WEIGHT_CONCATs,  /* OVERLAY_MEMBER_WEIGHT_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for member weight of overlay\n enhanced weighted ECMP.",
    },
    {
        .name  = OVERLAY_MEMBER_WEIGHT_SUBSET_SELECTs,  /* OVERLAY_MEMBER_WEIGHT_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for member weight of overlay enhanced\n weighted ECMP.\n",
    },
    {
        .name  = OVERLAY_MEMBER_WEIGHT_OFFSETs,  /* OVERLAY_MEMBER_WEIGHT_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for member weight of overlay enhanced weighted\n ECMP.\n",
    },
    {
        .name  = PROTECTION_ECMP_CONCATs,  /* PROTECTION_ECMP_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for protection switching ECMP.",
    },
    {
        .name  = PROTECTION_ECMP_SUBSET_SELECTs,  /* PROTECTION_ECMP_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for protection switching ECMP.",
    },
    {
        .name  = PROTECTION_ECMP_OFFSETs,  /* PROTECTION_ECMP_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for protection switching ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_flow_ecmp_output_selection_t = {
    .name = LB_HASH_FLOW_ECMP_OUTPUT_SELECTIONs, /* LB_HASH_FLOW_ECMP_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 19,
    .field = bcmltd_lb_hash_flow_ecmp_output_selection_t_fields,
    .desc = "Hash output selection control for flow based ECMP - mode, subset and offset.\n\n Flow based hash output selection indexed by Macro Flow ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_FLOW_ID_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_flow_id_selection_t_fields[] = {
    {
        .name  = USE_MOST_SIGNIFICANT_BYTE_AS_FLOW_IDs,  /* USE_MOST_SIGNIFICANT_BYTE_AS_FLOW_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use most significant byte as flow identifier.\n\n Macro flow identifier is 8 bit long. It is first derived from\n packet fields by Hash 0 or Hash 1 which is 16 bits and then\n uses either most significant or least significant byte to\n derive the 8 bit final value.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_flow_id_selection_t = {
    .name = LB_HASH_FLOW_ID_SELECTIONs, /* LB_HASH_FLOW_ID_SELECTION */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_lb_hash_flow_id_selection_t_fields,
    .desc = "Flow identifier selection.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_FLOW_L2_ECMP_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_flow_l2_ecmp_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_FLOW_L2_ECMP_OUTPUT_SELECTION_IDs,  /* LB_HASH_FLOW_L2_ECMP_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Selection ID based on flow number.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB.",
    },
    {
        .name  = OVERLAY_CONCATs,  /* OVERLAY_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for overlay L2 ECMP.",
    },
    {
        .name  = OVERLAY_SUBSET_SELECTs,  /* OVERLAY_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for overlay L2 ECMP.",
    },
    {
        .name  = OVERLAY_OFFSETs,  /* OVERLAY_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for overlay L2 ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_flow_l2_ecmp_output_selection_t = {
    .name = LB_HASH_FLOW_L2_ECMP_OUTPUT_SELECTIONs, /* LB_HASH_FLOW_L2_ECMP_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_lb_hash_flow_l2_ecmp_output_selection_t_fields,
    .desc = "Hash output selection control for flow based Layer 2 ECMP - mode, subset\n and offset.\n\n Flow based hash output selection indexed by Macro Flow ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_FLOW_LBID_OR_ENTROPY_LABEL_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_flow_lbid_or_entropy_label_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_FLOW_LBID_OR_ENTROPY_LABEL_OUTPUT_SELECTION_IDs,  /* LB_HASH_FLOW_LBID_OR_ENTROPY_LABEL_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Selection ID based on flow number.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_flow_lbid_or_entropy_label_output_selection_t = {
    .name = LB_HASH_FLOW_LBID_OR_ENTROPY_LABEL_OUTPUT_SELECTIONs, /* LB_HASH_FLOW_LBID_OR_ENTROPY_LABEL_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_lb_hash_flow_lbid_or_entropy_label_output_selection_t_fields,
    .desc = "Hash output selection control for flow based Load Balancing ID or\n entropy label - mode, subset and offset.\n\n Flow based hash output selection indexed by Macro Flow ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_FLOW_MPLS_ECMP_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_flow_mpls_ecmp_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_FLOW_MPLS_ECMP_OUTPUT_SELECTION_IDs,  /* LB_HASH_FLOW_MPLS_ECMP_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Selection ID based on flow number.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB.",
    },
    {
        .name  = OVERLAY_CONCATs,  /* OVERLAY_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for overlay MPLS ECMP.",
    },
    {
        .name  = OVERLAY_SUBSET_SELECTs,  /* OVERLAY_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for overlay MPLS ECMP.",
    },
    {
        .name  = OVERLAY_OFFSETs,  /* OVERLAY_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for overlay MPLS ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_flow_mpls_ecmp_output_selection_t = {
    .name = LB_HASH_FLOW_MPLS_ECMP_OUTPUT_SELECTIONs, /* LB_HASH_FLOW_MPLS_ECMP_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_lb_hash_flow_mpls_ecmp_output_selection_t_fields,
    .desc = "Hash output selection control for flow based MPLS ECMP - mode, subset\n and offset.\n\n Flow based hash output selection indexed by Macro Flow ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_FLOW_PLFS_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_flow_plfs_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_FLOW_PLFS_OUTPUT_SELECTION_IDs,  /* LB_HASH_FLOW_PLFS_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Selection ID based on flow number.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_flow_plfs_output_selection_t = {
    .name = LB_HASH_FLOW_PLFS_OUTPUT_SELECTIONs, /* LB_HASH_FLOW_PLFS_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_lb_hash_flow_plfs_output_selection_t_fields,
    .desc = "Hash output selection control for flow based Port LAG Failover Set - mode, subset and offset.\n\n Flow based hash output selection indexed by Macro Flow ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_FLOW_RH_ECMP_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_flow_rh_ecmp_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_FLOW_RH_ECMP_OUTPUT_SELECTION_IDs,  /* LB_HASH_FLOW_RH_ECMP_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Selection ID based on flow number.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB.",
    },
    {
        .name  = OVERLAY_CONCATs,  /* OVERLAY_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for overlay Resilient Hash ECMP.",
    },
    {
        .name  = OVERLAY_SUBSET_SELECTs,  /* OVERLAY_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for overlay Resilient Hash ECMP.",
    },
    {
        .name  = OVERLAY_OFFSETs,  /* OVERLAY_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for overlay Resilient Hash ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_flow_rh_ecmp_output_selection_t = {
    .name = LB_HASH_FLOW_RH_ECMP_OUTPUT_SELECTIONs, /* LB_HASH_FLOW_RH_ECMP_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_lb_hash_flow_rh_ecmp_output_selection_t_fields,
    .desc = "Hash output selection control for flow based Resilient Hash ECMP - mode, subset and offset.\n\n Flow based hash output selection indexed by Macro Flow ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_FLOW_SYMMETRY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_flow_symmetry_t_fields[] = {
    {
        .name  = HASH0_SYMMETRIC_IPV4s,  /* HASH0_SYMMETRIC_IPV4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable symmetric key hashing on hash 0 for IPv4 packets.\n Symmetry operation is applied to source IP, destination IP,\n layer 4 source port and layer 4 destination port fields.\n",
    },
    {
        .name  = HASH1_SYMMETRIC_IPV4s,  /* HASH1_SYMMETRIC_IPV4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable symmetric key hashing on hash 1 for IPv4 packets.\n Symmetry operation is applied to source IP, destination IP,\n layer 4 source port and layer 4 destination port fields.\n",
    },
    {
        .name  = HASH0_SYMMETRIC_IPV6s,  /* HASH0_SYMMETRIC_IPV6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable symmetric key hashing on hash 0 for IPv6 packets.\n Symmetry operation is applied to source IP, destination IP,\n layer 4 source port and layer 4 destination port fields.\n",
    },
    {
        .name  = HASH1_SYMMETRIC_IPV6s,  /* HASH1_SYMMETRIC_IPV6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable symmetric key hashing on hash 1 for IPv6 packets.\n Symmetry operation is applied to source IP, destination IP,\n layer 4 source port and layer 4 destination port fields.\n",
    },
    {
        .name  = HASH0_SYMMETRIC_FCOEs,  /* HASH0_SYMMETRIC_FCOE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable symmetric key hashing on hash 0 for FCoE packets.\n Symmetry operation is applied to source ID, destination ID,\n originator exchange ID and responder exchange ID fields.\n",
    },
    {
        .name  = HASH1_SYMMETRIC_FCOEs,  /* HASH1_SYMMETRIC_FCOE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable symmetric key hashing on hash 1 for FCoE packets.\n Symmetry operation is applied to source ID, destination ID,\n originator exchange ID and responder exchange ID fields.\n",
    },
    {
        .name  = HASH0_SYMMETRIC_SUPPRESS_UNIDIR_FIELDs,  /* HASH0_SYMMETRIC_SUPPRESS_UNIDIR_FIELD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable setting SPI, TEID, L2GRE key to zero before\n feeding to hashing buckets for hash 0.\n",
    },
    {
        .name  = HASH1_SYMMETRIC_SUPPRESS_UNIDIR_FIELDs,  /* HASH1_SYMMETRIC_SUPPRESS_UNIDIR_FIELD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable setting SPI, TEID, L2GRE key to zero before\n feeding to hashing buckets for hash 1.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_flow_symmetry_t = {
    .name = LB_HASH_FLOW_SYMMETRYs, /* LB_HASH_FLOW_SYMMETRY */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_lb_hash_flow_symmetry_t_fields,
    .desc = "Enable symmetric key hashing for various packet type.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_FLOW_TRUNK_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_flow_trunk_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_FLOW_TRUNK_OUTPUT_SELECTION_IDs,  /* LB_HASH_FLOW_TRUNK_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Selection ID based on flow number.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB.",
    },
    {
        .name  = UC_CONCATs,  /* UC_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for trunk unicast.",
    },
    {
        .name  = UC_SUBSET_SELECTs,  /* UC_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for trunk unicast.",
    },
    {
        .name  = UC_OFFSETs,  /* UC_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for trunk unicast.",
    },
    {
        .name  = NONUC_CONCATs,  /* NONUC_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for trunk non-unicast.",
    },
    {
        .name  = NONUC_SUBSET_SELECTs,  /* NONUC_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for trunk non-unicast.",
    },
    {
        .name  = NONUC_OFFSETs,  /* NONUC_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for trunk non-unicast.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_flow_trunk_output_selection_t = {
    .name = LB_HASH_FLOW_TRUNK_OUTPUT_SELECTIONs, /* LB_HASH_FLOW_TRUNK_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_lb_hash_flow_trunk_output_selection_t_fields,
    .desc = "Hash output selection control for flow based trunk - mode, subset and offset.\n\n Flow based hash output selection indexed by Macro Flow ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_GTP_L4_PORT_MATCH.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_gtp_l4_port_match_t_fields[] = {
    {
        .name  = LB_HASH_GTP_L4_PORT_MATCH_IDs,  /* LB_HASH_GTP_L4_PORT_MATCH_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the GTP L4 port match table.",
    },
    {
        .name  = MATCHs,  /* MATCH */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_LB_HASH_GTP_L4_PORT_MATCH_T_DATA,
        .desc = "Match criteria.",
    },
    {
        .name  = SRC_L4_PORTs,  /* SRC_L4_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 source port.",
    },
    {
        .name  = DST_L4_PORTs,  /* DST_L4_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 destination port.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_gtp_l4_port_match_t = {
    .name = LB_HASH_GTP_L4_PORT_MATCHs, /* LB_HASH_GTP_L4_PORT_MATCH */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_lb_hash_gtp_l4_port_match_t_fields,
    .desc = "The LB_HASH_GTP_L4_PORT_MATCH table specifies the L4 ports to be matched\n for a packet to be identified as a GPRS tunneling protocol (GTP) packet.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_IPV4_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_ipv4_fields_selection_t_fields[] = {
    {
        .name  = HASH0_DST_MODIDs,  /* HASH0_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_VNTAG_SRC_VIFs,  /* HASH0_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_DST_PORTs,  /* HASH0_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_VNTAG_DST_VIFs,  /* HASH0_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_SRC_MODIDs,  /* HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_SRC_PORTs,  /* HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_PROTOCOLs,  /* HASH0_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_L4_DSTs,  /* HASH0_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_L4_SRCs,  /* HASH0_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_VIDs,  /* HASH0_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_DST_IP_LOWERs,  /* HASH0_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_DST_IP_UPPERs,  /* HASH0_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_SRC_IP_LOWERs,  /* HASH0_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_SRC_IP_UPPERs,  /* HASH0_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_CNTAG_RPIDs,  /* HASH0_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_DST_MODIDs,  /* HASH1_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_VNTAG_SRC_VIFs,  /* HASH1_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_DST_PORTs,  /* HASH1_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_VNTAG_DST_VIFs,  /* HASH1_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_SRC_MODIDs,  /* HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_SRC_PORTs,  /* HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_PROTOCOLs,  /* HASH1_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_L4_DSTs,  /* HASH1_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_L4_SRCs,  /* HASH1_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_VIDs,  /* HASH1_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_DST_IP_LOWERs,  /* HASH1_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_DST_IP_UPPERs,  /* HASH1_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_SRC_IP_LOWERs,  /* HASH1_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_SRC_IP_UPPERs,  /* HASH1_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_CNTAG_RPIDs,  /* HASH1_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_L4_DST_PORTs,  /* HASH0_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_L4_SRC_PORTs,  /* HASH0_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_FLOW_LABEL_15_0s,  /* HASH0_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_VLAN_IDs,  /* HASH0_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_VRF_IDs,  /* HASH0_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_DST_IP_15_0s,  /* HASH0_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_DST_IP_31_15s,  /* HASH0_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_DST_IP_47_32s,  /* HASH0_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_DST_IP_63_48s,  /* HASH0_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_SRC_IP_15_0s,  /* HASH0_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_SRC_IP_31_15s,  /* HASH0_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_SRC_IP_47_32s,  /* HASH0_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_SRC_IP_63_48s,  /* HASH0_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_LOWERs,  /* HASH0_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_UPPERs,  /* HASH0_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_1s,  /* HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_2s,  /* HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_3s,  /* HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_4s,  /* HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_5s,  /* HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_6s,  /* HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_7s,  /* HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_8s,  /* HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_L4_DST_PORTs,  /* HASH1_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_L4_SRC_PORTs,  /* HASH1_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_FLOW_LABEL_15_0s,  /* HASH1_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_VLAN_IDs,  /* HASH1_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_VRF_IDs,  /* HASH1_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_DST_IP_15_0s,  /* HASH1_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_DST_IP_31_15s,  /* HASH1_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_DST_IP_47_32s,  /* HASH1_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_DST_IP_63_48s,  /* HASH1_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_SRC_IP_15_0s,  /* HASH1_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_SRC_IP_31_15s,  /* HASH1_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_SRC_IP_47_32s,  /* HASH1_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_SRC_IP_63_48s,  /* HASH1_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_LOWERs,  /* HASH1_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_UPPERs,  /* HASH1_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_1s,  /* HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_2s,  /* HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_3s,  /* HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_4s,  /* HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_5s,  /* HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_6s,  /* HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_7s,  /* HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_8s,  /* HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv4 packets.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_ipv4_fields_selection_t = {
    .name = LB_HASH_IPV4_FIELDS_SELECTIONs, /* LB_HASH_IPV4_FIELDS_SELECTION */
    .flags = 0,
    .fields = 82,
    .field = bcmltd_lb_hash_ipv4_fields_selection_t_fields,
    .desc = "IPv4 based hash field selection.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_IPV4_TCP_UDP_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_ipv4_tcp_udp_fields_selection_t_fields[] = {
    {
        .name  = HASH0_DST_MODIDs,  /* HASH0_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_VNTAG_SRC_VIFs,  /* HASH0_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_DST_PORTs,  /* HASH0_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_VNTAG_DST_VIFs,  /* HASH0_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_SRC_MODIDs,  /* HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_SRC_PORTs,  /* HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_PROTOCOLs,  /* HASH0_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_L4_DSTs,  /* HASH0_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_L4_SRCs,  /* HASH0_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_VIDs,  /* HASH0_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_DST_IP_LOWERs,  /* HASH0_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_DST_IP_UPPERs,  /* HASH0_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_SRC_IP_LOWERs,  /* HASH0_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_SRC_IP_UPPERs,  /* HASH0_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_CNTAG_RPIDs,  /* HASH0_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_DST_MODIDs,  /* HASH1_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_VNTAG_SRC_VIFs,  /* HASH1_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_DST_PORTs,  /* HASH1_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_VNTAG_DST_VIFs,  /* HASH1_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_SRC_MODIDs,  /* HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_SRC_PORTs,  /* HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_PROTOCOLs,  /* HASH1_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_L4_DSTs,  /* HASH1_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_L4_SRCs,  /* HASH1_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_VIDs,  /* HASH1_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_DST_IP_LOWERs,  /* HASH1_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_DST_IP_UPPERs,  /* HASH1_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_SRC_IP_LOWERs,  /* HASH1_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_SRC_IP_UPPERs,  /* HASH1_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_CNTAG_RPIDs,  /* HASH1_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_L4_DST_PORTs,  /* HASH0_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_L4_SRC_PORTs,  /* HASH0_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_FLOW_LABEL_15_0s,  /* HASH0_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_IDs,  /* HASH0_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_VRF_IDs,  /* HASH0_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_15_0s,  /* HASH0_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_31_15s,  /* HASH0_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_47_32s,  /* HASH0_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_63_48s,  /* HASH0_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_15_0s,  /* HASH0_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_31_15s,  /* HASH0_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_47_32s,  /* HASH0_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_63_48s,  /* HASH0_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_LOWERs,  /* HASH0_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_UPPERs,  /* HASH0_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_1s,  /* HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_2s,  /* HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_3s,  /* HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_4s,  /* HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_5s,  /* HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_6s,  /* HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_7s,  /* HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_8s,  /* HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_L4_DST_PORTs,  /* HASH1_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_L4_SRC_PORTs,  /* HASH1_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_FLOW_LABEL_15_0s,  /* HASH1_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_IDs,  /* HASH1_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_VRF_IDs,  /* HASH1_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_15_0s,  /* HASH1_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_31_15s,  /* HASH1_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_47_32s,  /* HASH1_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_63_48s,  /* HASH1_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_15_0s,  /* HASH1_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_31_15s,  /* HASH1_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_47_32s,  /* HASH1_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_63_48s,  /* HASH1_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_LOWERs,  /* HASH1_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_UPPERs,  /* HASH1_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_1s,  /* HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_2s,  /* HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_3s,  /* HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_4s,  /* HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_5s,  /* HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_6s,  /* HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_7s,  /* HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_8s,  /* HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_ipv4_tcp_udp_fields_selection_t = {
    .name = LB_HASH_IPV4_TCP_UDP_FIELDS_SELECTIONs, /* LB_HASH_IPV4_TCP_UDP_FIELDS_SELECTION */
    .flags = 0,
    .fields = 82,
    .field = bcmltd_lb_hash_ipv4_tcp_udp_fields_selection_t_fields,
    .desc = "IPv4 TCP and UDP based hash field selection.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_IPV4_TCP_UDP_PORTS_EQUAL_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_ipv4_tcp_udp_ports_equal_fields_selection_t_fields[] = {
    {
        .name  = HASH0_DST_MODIDs,  /* HASH0_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_VNTAG_SRC_VIFs,  /* HASH0_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_DST_PORTs,  /* HASH0_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_VNTAG_DST_VIFs,  /* HASH0_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_SRC_MODIDs,  /* HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_SRC_PORTs,  /* HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_PROTOCOLs,  /* HASH0_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_L4_DSTs,  /* HASH0_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_L4_SRCs,  /* HASH0_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_VIDs,  /* HASH0_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_DST_IP_LOWERs,  /* HASH0_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_DST_IP_UPPERs,  /* HASH0_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_SRC_IP_LOWERs,  /* HASH0_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_SRC_IP_UPPERs,  /* HASH0_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_CNTAG_RPIDs,  /* HASH0_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_DST_MODIDs,  /* HASH1_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_VNTAG_SRC_VIFs,  /* HASH1_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_DST_PORTs,  /* HASH1_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_VNTAG_DST_VIFs,  /* HASH1_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_SRC_MODIDs,  /* HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_SRC_PORTs,  /* HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_PROTOCOLs,  /* HASH1_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_L4_DSTs,  /* HASH1_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_L4_SRCs,  /* HASH1_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_VIDs,  /* HASH1_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_DST_IP_LOWERs,  /* HASH1_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_DST_IP_UPPERs,  /* HASH1_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_SRC_IP_LOWERs,  /* HASH1_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_SRC_IP_UPPERs,  /* HASH1_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH1_CNTAG_RPIDs,  /* HASH1_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv4 packets carrying\n TCP or UDP payloads, where L4 source port equals the\n L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_L4_DST_PORTs,  /* HASH0_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_L4_SRC_PORTs,  /* HASH0_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_FLOW_LABEL_15_0s,  /* HASH0_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_IDs,  /* HASH0_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_VRF_IDs,  /* HASH0_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_15_0s,  /* HASH0_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_31_15s,  /* HASH0_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_47_32s,  /* HASH0_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_63_48s,  /* HASH0_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_15_0s,  /* HASH0_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_31_15s,  /* HASH0_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_47_32s,  /* HASH0_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_63_48s,  /* HASH0_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_LOWERs,  /* HASH0_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_UPPERs,  /* HASH0_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_1s,  /* HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_2s,  /* HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_3s,  /* HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_4s,  /* HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_5s,  /* HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_6s,  /* HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_7s,  /* HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_8s,  /* HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_L4_DST_PORTs,  /* HASH1_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_L4_SRC_PORTs,  /* HASH1_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_FLOW_LABEL_15_0s,  /* HASH1_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_IDs,  /* HASH1_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_VRF_IDs,  /* HASH1_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_15_0s,  /* HASH1_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_31_15s,  /* HASH1_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_47_32s,  /* HASH1_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_63_48s,  /* HASH1_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_15_0s,  /* HASH1_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_31_15s,  /* HASH1_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_47_32s,  /* HASH1_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_63_48s,  /* HASH1_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_LOWERs,  /* HASH1_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_UPPERs,  /* HASH1_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_1s,  /* HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_2s,  /* HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_3s,  /* HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_4s,  /* HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_5s,  /* HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_6s,  /* HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_7s,  /* HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_8s,  /* HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv4\n packets carrying TCP or UDP payloads, where L4 source port\n equals the L4 destination port.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_ipv4_tcp_udp_ports_equal_fields_selection_t = {
    .name = LB_HASH_IPV4_TCP_UDP_PORTS_EQUAL_FIELDS_SELECTIONs, /* LB_HASH_IPV4_TCP_UDP_PORTS_EQUAL_FIELDS_SELECTION */
    .flags = 0,
    .fields = 82,
    .field = bcmltd_lb_hash_ipv4_tcp_udp_ports_equal_fields_selection_t_fields,
    .desc = "IPv4 TCP and UDP based hash field selection when L4 source\n port and destination port are equal.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_IPV6_COLLAPSE_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_ipv6_collapse_selection_t_fields[] = {
    {
        .name  = HASH0_SELECTIONs,  /* HASH0_SELECTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 0 selection for collapsing IPv6 addresses.",
    },
    {
        .name  = HASH1_SELECTIONs,  /* HASH1_SELECTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 1 selection for collapsing IPv6 addresses.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_ipv6_collapse_selection_t = {
    .name = LB_HASH_IPV6_COLLAPSE_SELECTIONs, /* LB_HASH_IPV6_COLLAPSE_SELECTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_lb_hash_ipv6_collapse_selection_t_fields,
    .desc = "The LB_HASH_IPV6_COLLAPSE_SELECTION table specifies method for\n collapsing IPv6 addresses.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_IPV6_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_ipv6_fields_selection_t_fields[] = {
    {
        .name  = HASH0_DST_MODIDs,  /* HASH0_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_FLOW_ID_LOs,  /* HASH0_FLOW_ID_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_VNTAG_SRC_VIFs,  /* HASH0_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_DST_PORTs,  /* HASH0_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_FLOW_ID_HIs,  /* HASH0_FLOW_ID_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_VNTAG_DST_VIFs,  /* HASH0_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_SRC_MODIDs,  /* HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_SRC_PORTs,  /* HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_PROTOCOLs,  /* HASH0_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_L4_DSTs,  /* HASH0_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_L4_SRCs,  /* HASH0_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_VIDs,  /* HASH0_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_DST_IP_LOWERs,  /* HASH0_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_DST_IP_UPPERs,  /* HASH0_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_SRC_IP_LOWERs,  /* HASH0_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_SRC_IP_UPPERs,  /* HASH0_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_CNTAG_RPIDs,  /* HASH0_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_DST_MODIDs,  /* HASH1_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_FLOW_ID_LOs,  /* HASH1_FLOW_ID_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_VNTAG_SRC_VIFs,  /* HASH1_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_DST_PORTs,  /* HASH1_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_FLOW_ID_HIs,  /* HASH1_FLOW_ID_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_VNTAG_DST_VIFs,  /* HASH1_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_SRC_MODIDs,  /* HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_SRC_PORTs,  /* HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_PROTOCOLs,  /* HASH1_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_L4_DSTs,  /* HASH1_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_L4_SRCs,  /* HASH1_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_VIDs,  /* HASH1_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_DST_IP_LOWERs,  /* HASH1_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_DST_IP_UPPERs,  /* HASH1_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_SRC_IP_LOWERs,  /* HASH1_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_SRC_IP_UPPERs,  /* HASH1_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_CNTAG_RPIDs,  /* HASH1_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_L4_DST_PORTs,  /* HASH0_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_L4_SRC_PORTs,  /* HASH0_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_FLOW_LABEL_15_0s,  /* HASH0_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_VLAN_IDs,  /* HASH0_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_VRF_IDs,  /* HASH0_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_DST_IP_15_0s,  /* HASH0_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_DST_IP_31_15s,  /* HASH0_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_DST_IP_47_32s,  /* HASH0_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_DST_IP_63_48s,  /* HASH0_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_SRC_IP_15_0s,  /* HASH0_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_SRC_IP_31_15s,  /* HASH0_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_SRC_IP_47_32s,  /* HASH0_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_SRC_IP_63_48s,  /* HASH0_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_LOWERs,  /* HASH0_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_UPPERs,  /* HASH0_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_1s,  /* HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_2s,  /* HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_3s,  /* HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_4s,  /* HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_5s,  /* HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_6s,  /* HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_7s,  /* HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_8s,  /* HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_L4_DST_PORTs,  /* HASH1_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_L4_SRC_PORTs,  /* HASH1_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_FLOW_LABEL_15_0s,  /* HASH1_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_VLAN_IDs,  /* HASH1_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_VRF_IDs,  /* HASH1_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_DST_IP_15_0s,  /* HASH1_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_DST_IP_31_15s,  /* HASH1_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_DST_IP_47_32s,  /* HASH1_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_DST_IP_63_48s,  /* HASH1_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_SRC_IP_15_0s,  /* HASH1_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_SRC_IP_31_15s,  /* HASH1_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_SRC_IP_47_32s,  /* HASH1_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_SRC_IP_63_48s,  /* HASH1_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_LOWERs,  /* HASH1_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_UPPERs,  /* HASH1_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_1s,  /* HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_2s,  /* HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_3s,  /* HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_4s,  /* HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_5s,  /* HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_6s,  /* HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_7s,  /* HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_8s,  /* HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for IPv6 packets.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_ipv6_fields_selection_t = {
    .name = LB_HASH_IPV6_FIELDS_SELECTIONs, /* LB_HASH_IPV6_FIELDS_SELECTION */
    .flags = 0,
    .fields = 86,
    .field = bcmltd_lb_hash_ipv6_fields_selection_t_fields,
    .desc = "IPv6 based hash fields selection.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_IPV6_TCP_UDP_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_ipv6_tcp_udp_fields_selection_t_fields[] = {
    {
        .name  = HASH0_DST_MODIDs,  /* HASH0_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_FLOW_ID_LOs,  /* HASH0_FLOW_ID_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_VNTAG_SRC_VIFs,  /* HASH0_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_DST_PORTs,  /* HASH0_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_FLOW_ID_HIs,  /* HASH0_FLOW_ID_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_VNTAG_DST_VIFs,  /* HASH0_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_SRC_MODIDs,  /* HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_SRC_PORTs,  /* HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_PROTOCOLs,  /* HASH0_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_L4_DSTs,  /* HASH0_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_L4_SRCs,  /* HASH0_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_VIDs,  /* HASH0_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_DST_IP_LOWERs,  /* HASH0_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_DST_IP_UPPERs,  /* HASH0_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_SRC_IP_LOWERs,  /* HASH0_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_SRC_IP_UPPERs,  /* HASH0_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_CNTAG_RPIDs,  /* HASH0_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_DST_MODIDs,  /* HASH1_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_FLOW_ID_LOs,  /* HASH1_FLOW_ID_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_VNTAG_SRC_VIFs,  /* HASH1_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_DST_PORTs,  /* HASH1_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_FLOW_ID_HIs,  /* HASH1_FLOW_ID_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_VNTAG_DST_VIFs,  /* HASH1_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_SRC_MODIDs,  /* HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_SRC_PORTs,  /* HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_PROTOCOLs,  /* HASH1_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_L4_DSTs,  /* HASH1_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_L4_SRCs,  /* HASH1_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_VIDs,  /* HASH1_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_DST_IP_LOWERs,  /* HASH1_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_DST_IP_UPPERs,  /* HASH1_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_SRC_IP_LOWERs,  /* HASH1_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_SRC_IP_UPPERs,  /* HASH1_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_CNTAG_RPIDs,  /* HASH1_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_L4_DST_PORTs,  /* HASH0_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_L4_SRC_PORTs,  /* HASH0_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_FLOW_LABEL_15_0s,  /* HASH0_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_IDs,  /* HASH0_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_VRF_IDs,  /* HASH0_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_15_0s,  /* HASH0_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_31_15s,  /* HASH0_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_47_32s,  /* HASH0_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_63_48s,  /* HASH0_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_15_0s,  /* HASH0_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_31_15s,  /* HASH0_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_47_32s,  /* HASH0_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_63_48s,  /* HASH0_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_LOWERs,  /* HASH0_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_UPPERs,  /* HASH0_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_1s,  /* HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_2s,  /* HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_3s,  /* HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_4s,  /* HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_5s,  /* HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_6s,  /* HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_7s,  /* HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_8s,  /* HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_L4_DST_PORTs,  /* HASH1_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_L4_SRC_PORTs,  /* HASH1_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_FLOW_LABEL_15_0s,  /* HASH1_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_IDs,  /* HASH1_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_VRF_IDs,  /* HASH1_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_15_0s,  /* HASH1_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_31_15s,  /* HASH1_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_47_32s,  /* HASH1_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_63_48s,  /* HASH1_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_15_0s,  /* HASH1_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_31_15s,  /* HASH1_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_47_32s,  /* HASH1_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_63_48s,  /* HASH1_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_LOWERs,  /* HASH1_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_UPPERs,  /* HASH1_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_1s,  /* HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_2s,  /* HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_3s,  /* HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_4s,  /* HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_5s,  /* HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_6s,  /* HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_7s,  /* HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_8s,  /* HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented IPv6\n packets carrying TCP or UDP payloads.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_ipv6_tcp_udp_fields_selection_t = {
    .name = LB_HASH_IPV6_TCP_UDP_FIELDS_SELECTIONs, /* LB_HASH_IPV6_TCP_UDP_FIELDS_SELECTION */
    .flags = 0,
    .fields = 86,
    .field = bcmltd_lb_hash_ipv6_tcp_udp_fields_selection_t_fields,
    .desc = "IPv6 TCP or UDP based hash field selection.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_IPV6_TCP_UDP_PORTS_EQUAL_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_ipv6_tcp_udp_ports_equal_fields_selection_t_fields[] = {
    {
        .name  = HASH0_DST_MODIDs,  /* HASH0_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_FLOW_ID_LOs,  /* HASH0_FLOW_ID_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_VNTAG_SRC_VIFs,  /* HASH0_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_DST_PORTs,  /* HASH0_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_FLOW_ID_HIs,  /* HASH0_FLOW_ID_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_VNTAG_DST_VIFs,  /* HASH0_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_SRC_MODIDs,  /* HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_SRC_PORTs,  /* HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_PROTOCOLs,  /* HASH0_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_L4_DSTs,  /* HASH0_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_L4_SRCs,  /* HASH0_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_VIDs,  /* HASH0_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_DST_IP_LOWERs,  /* HASH0_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_DST_IP_UPPERs,  /* HASH0_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_SRC_IP_LOWERs,  /* HASH0_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_SRC_IP_UPPERs,  /* HASH0_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_CNTAG_RPIDs,  /* HASH0_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_DST_MODIDs,  /* HASH1_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_FLOW_ID_LOs,  /* HASH1_FLOW_ID_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_VNTAG_SRC_VIFs,  /* HASH1_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_DST_PORTs,  /* HASH1_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_FLOW_ID_HIs,  /* HASH1_FLOW_ID_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_VNTAG_DST_VIFs,  /* HASH1_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_SRC_MODIDs,  /* HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_SRC_PORTs,  /* HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_PROTOCOLs,  /* HASH1_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_L4_DSTs,  /* HASH1_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_L4_SRCs,  /* HASH1_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_VIDs,  /* HASH1_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_DST_IP_LOWERs,  /* HASH1_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_DST_IP_UPPERs,  /* HASH1_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_SRC_IP_LOWERs,  /* HASH1_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_SRC_IP_UPPERs,  /* HASH1_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_CNTAG_RPIDs,  /* HASH1_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_L4_DST_PORTs,  /* HASH0_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_L4_SRC_PORTs,  /* HASH0_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_FLOW_LABEL_15_0s,  /* HASH0_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_IDs,  /* HASH0_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_VRF_IDs,  /* HASH0_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_15_0s,  /* HASH0_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_31_15s,  /* HASH0_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_47_32s,  /* HASH0_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_63_48s,  /* HASH0_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_15_0s,  /* HASH0_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_31_15s,  /* HASH0_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_47_32s,  /* HASH0_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_63_48s,  /* HASH0_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_LOWERs,  /* HASH0_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_UPPERs,  /* HASH0_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_1s,  /* HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_2s,  /* HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_3s,  /* HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_4s,  /* HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_5s,  /* HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_6s,  /* HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_7s,  /* HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH0_EXT_UDF_8s,  /* HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_L4_DST_PORTs,  /* HASH1_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_L4_SRC_PORTs,  /* HASH1_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_FLOW_LABEL_15_0s,  /* HASH1_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_IDs,  /* HASH1_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_VRF_IDs,  /* HASH1_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_15_0s,  /* HASH1_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_31_15s,  /* HASH1_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_47_32s,  /* HASH1_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_63_48s,  /* HASH1_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_15_0s,  /* HASH1_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_31_15s,  /* HASH1_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_47_32s,  /* HASH1_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_63_48s,  /* HASH1_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_LOWERs,  /* HASH1_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_UPPERs,  /* HASH1_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_1s,  /* HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_2s,  /* HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_3s,  /* HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_4s,  /* HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_5s,  /* HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_6s,  /* HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_7s,  /* HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
    {
        .name  = HASH1_EXT_UDF_8s,  /* HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for unfragmented\n IPv6 packets carrying TCP or UDP payloads,\n where L4 source port equals the L4 destination port.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_ipv6_tcp_udp_ports_equal_fields_selection_t = {
    .name = LB_HASH_IPV6_TCP_UDP_PORTS_EQUAL_FIELDS_SELECTIONs, /* LB_HASH_IPV6_TCP_UDP_PORTS_EQUAL_FIELDS_SELECTION */
    .flags = 0,
    .fields = 86,
    .field = bcmltd_lb_hash_ipv6_tcp_udp_ports_equal_fields_selection_t_fields,
    .desc = "IPv6 TCP and UDP based hash field selection where L4\n destination port and source port are the same.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_L2_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_l2_fields_selection_t_fields[] = {
    {
        .name  = HASH0_DST_MODIDs,  /* HASH0_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_VNTAG_SRC_VIFs,  /* HASH0_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_DST_PORTs,  /* HASH0_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_VNTAG_DST_VIFs,  /* HASH0_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_SRC_MODIDs,  /* HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_SRC_PORTs,  /* HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_VIDs,  /* HASH0_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_ETH_TYPEs,  /* HASH0_ETH_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_MAC_DA_LOs,  /* HASH0_MAC_DA_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_MAC_DA_MEDs,  /* HASH0_MAC_DA_MED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_MAC_DA_HIs,  /* HASH0_MAC_DA_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_MAC_SA_LOs,  /* HASH0_MAC_SA_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_MAC_SA_MEDs,  /* HASH0_MAC_SA_MED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_MAC_SA_HIs,  /* HASH0_MAC_SA_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_CNTAG_RPIDs,  /* HASH0_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_DST_MODIDs,  /* HASH1_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_VNTAG_SRC_VIFs,  /* HASH1_VNTAG_SRC_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_DST_PORTs,  /* HASH1_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_VNTAG_DST_VIFs,  /* HASH1_VNTAG_DST_VIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_SRC_MODIDs,  /* HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_SRC_PORTs,  /* HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_VIDs,  /* HASH1_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_ETH_TYPEs,  /* HASH1_ETH_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_MAC_DA_LOs,  /* HASH1_MAC_DA_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_MAC_DA_MEDs,  /* HASH1_MAC_DA_MED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_MAC_DA_HIs,  /* HASH1_MAC_DA_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_MAC_SA_LOs,  /* HASH1_MAC_SA_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_MAC_SA_MEDs,  /* HASH1_MAC_SA_MED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_MAC_SA_HIs,  /* HASH1_MAC_SA_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_CNTAG_RPIDs,  /* HASH1_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_EGR_PORT_ID_LOWERs,  /* HASH0_EXT_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_ETHERTYPEs,  /* HASH0_EXT_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_VLAN_IDs,  /* HASH0_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_MAC_DA_15_0s,  /* HASH0_EXT_MAC_DA_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_MAC_DA_31_16s,  /* HASH0_EXT_MAC_DA_31_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_MAC_DA_47_32s,  /* HASH0_EXT_MAC_DA_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_MAC_SA_15_0s,  /* HASH0_EXT_MAC_SA_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_MAC_SA_31_16s,  /* HASH0_EXT_MAC_SA_31_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_MAC_SA_47_32s,  /* HASH0_EXT_MAC_SA_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_1s,  /* HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_2s,  /* HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_3s,  /* HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_4s,  /* HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_5s,  /* HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_6s,  /* HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_7s,  /* HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH0_EXT_UDF_8s,  /* HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_EGR_PORT_ID_LOWERs,  /* HASH1_EXT_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_ETHERTYPEs,  /* HASH1_EXT_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_VLAN_IDs,  /* HASH1_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_MAC_DA_15_0s,  /* HASH1_EXT_MAC_DA_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_MAC_DA_31_16s,  /* HASH1_EXT_MAC_DA_31_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_MAC_DA_47_32s,  /* HASH1_EXT_MAC_DA_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_MAC_SA_15_0s,  /* HASH1_EXT_MAC_SA_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_MAC_SA_31_16s,  /* HASH1_EXT_MAC_SA_31_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_MAC_SA_47_32s,  /* HASH1_EXT_MAC_SA_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_1s,  /* HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_2s,  /* HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_3s,  /* HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_4s,  /* HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_5s,  /* HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_6s,  /* HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_7s,  /* HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
    {
        .name  = HASH1_EXT_UDF_8s,  /* HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for L2 packets.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_l2_fields_selection_t = {
    .name = LB_HASH_L2_FIELDS_SELECTIONs, /* LB_HASH_L2_FIELDS_SELECTION */
    .flags = 0,
    .fields = 66,
    .field = bcmltd_lb_hash_l2_fields_selection_t_fields,
    .desc = "Hash field selection for L2 packets.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_L3MPLS_PAYLOAD_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_l3mpls_payload_fields_selection_t_fields[] = {
    {
        .name  = HASH0_DST_MODIDs,  /* HASH0_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_FLOW_ID_LOs,  /* HASH0_FLOW_ID_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_DST_PORTs,  /* HASH0_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_FLOW_ID_HIs,  /* HASH0_FLOW_ID_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_SRC_MODIDs,  /* HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_SRC_PORTs,  /* HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_PROTOCOLs,  /* HASH0_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_NEXT_HEADERs,  /* HASH0_NEXT_HEADER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_L4_DSTs,  /* HASH0_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_L4_SRCs,  /* HASH0_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_TUNNEL_VIDs,  /* HASH0_TUNNEL_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_DST_IP_LOWERs,  /* HASH0_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_DST_IP_UPPERs,  /* HASH0_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_SRC_IP_LOWERs,  /* HASH0_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_SRC_IP_UPPERs,  /* HASH0_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_DST_MODIDs,  /* HASH1_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_FLOW_ID_LOs,  /* HASH1_FLOW_ID_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_DST_PORTs,  /* HASH1_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_FLOW_ID_HIs,  /* HASH1_FLOW_ID_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_SRC_MODIDs,  /* HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_SRC_PORTs,  /* HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_PROTOCOLs,  /* HASH1_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_NEXT_HEADERs,  /* HASH1_NEXT_HEADER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_L4_DSTs,  /* HASH1_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_L4_SRCs,  /* HASH1_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_TUNNEL_VIDs,  /* HASH1_TUNNEL_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_DST_IP_LOWERs,  /* HASH1_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_DST_IP_UPPERs,  /* HASH1_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_SRC_IP_LOWERs,  /* HASH1_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_SRC_IP_UPPERs,  /* HASH1_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_L4_DST_PORTs,  /* HASH0_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_L4_SRC_PORTs,  /* HASH0_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_FLOW_LABEL_15_0s,  /* HASH0_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_IDs,  /* HASH0_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_VRF_IDs,  /* HASH0_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_15_0s,  /* HASH0_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_31_15s,  /* HASH0_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_47_32s,  /* HASH0_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_63_48s,  /* HASH0_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_15_0s,  /* HASH0_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_31_15s,  /* HASH0_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_47_32s,  /* HASH0_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_63_48s,  /* HASH0_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_LOWERs,  /* HASH0_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_UPPERs,  /* HASH0_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_1s,  /* HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_2s,  /* HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_3s,  /* HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_4s,  /* HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_5s,  /* HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_6s,  /* HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_7s,  /* HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_8s,  /* HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_L4_DST_PORTs,  /* HASH1_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_L4_SRC_PORTs,  /* HASH1_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_FLOW_LABEL_15_0s,  /* HASH1_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_IDs,  /* HASH1_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_VRF_IDs,  /* HASH1_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_15_0s,  /* HASH1_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_31_15s,  /* HASH1_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_47_32s,  /* HASH1_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_63_48s,  /* HASH1_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_15_0s,  /* HASH1_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_31_15s,  /* HASH1_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_47_32s,  /* HASH1_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_63_48s,  /* HASH1_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_LOWERs,  /* HASH1_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_UPPERs,  /* HASH1_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_1s,  /* HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_2s,  /* HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_3s,  /* HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_4s,  /* HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_5s,  /* HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_6s,  /* HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_7s,  /* HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_8s,  /* HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS terminated\n packets with L3 payloads.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_l3mpls_payload_fields_selection_t = {
    .name = LB_HASH_L3MPLS_PAYLOAD_FIELDS_SELECTIONs, /* LB_HASH_L3MPLS_PAYLOAD_FIELDS_SELECTION */
    .flags = 0,
    .fields = 82,
    .field = bcmltd_lb_hash_l3mpls_payload_fields_selection_t_fields,
    .desc = "Hash field selection for MPLS terminated packets with L3 payloads.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_PKT_HDR_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_pkt_hdr_selection_t_fields[] = {
    {
        .name  = HASH0_IGNORE_IPV4s,  /* HASH0_IGNORE_IPV4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hash selection for IPv4 packets default to Ethernet\n packets for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_IPV4s,  /* HASH1_IGNORE_IPV4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hash selection for IPv4 packets default to Ethernet\n packets for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_IPV6s,  /* HASH0_IGNORE_IPV6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hash selection for IPv6 packets default to Ethernet\n packets for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_IPV6s,  /* HASH1_IGNORE_IPV6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hash selection for IPv6 packets default to Ethernet\n packets for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_INNER_4OVER4_IP_TUNNELs,  /* HASH0_IGNORE_INNER_4OVER4_IP_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv4 packet header for IPv4 over IPv4\n packets (outer ip.protocol = 4) for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_INNER_4OVER4_IP_TUNNELs,  /* HASH1_IGNORE_INNER_4OVER4_IP_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv4 packet header for IPv4 over IPv4\n packets (outer ip.protocol = 4) for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_INNER_6OVER4_IP_TUNNELs,  /* HASH0_IGNORE_INNER_6OVER4_IP_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv6 packet header for\n IPv6 over IPv4 packets for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_INNER_6OVER4_IP_TUNNELs,  /* HASH1_IGNORE_INNER_6OVER4_IP_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv6 packet header for\n IPv6 over IPv4 packets for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_INNER_4OVER4_GRE_TUNNELs,  /* HASH0_IGNORE_INNER_4OVER4_GRE_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv4 packet header for\n IPv4 over GRE-IPv4 packets (outer ip.protocol = 47)\n for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_INNER_4OVER4_GRE_TUNNELs,  /* HASH1_IGNORE_INNER_4OVER4_GRE_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv4 packet header for\n IPv4 over GRE-IPv4 packets (outer ip.protocol = 47)\n for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_INNER_6OVER4_GRE_TUNNELs,  /* HASH0_IGNORE_INNER_6OVER4_GRE_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv6 packet header for\n IPv6 over GRE-IPv4 packets (outer ip.protocol = 47)\n for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_INNER_6OVER4_GRE_TUNNELs,  /* HASH1_IGNORE_INNER_6OVER4_GRE_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv6 packet header for\n IPv6 over GRE-IPv4 packets (outer ip.protocol = 47)\n for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_INNER_4OVER6_IP_TUNNELs,  /* HASH0_IGNORE_INNER_4OVER6_IP_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv4 packet header for\n IPv4 over IPv6 packets for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_INNER_4OVER6_IP_TUNNELs,  /* HASH1_IGNORE_INNER_4OVER6_IP_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv4 packet header for\n IPv4 over IPv6 packets for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_INNER_6OVER6_IP_TUNNELs,  /* HASH0_IGNORE_INNER_6OVER6_IP_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv6 packet header for\n IPv6 over IPv6 packets for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_INNER_6OVER6_IP_TUNNELs,  /* HASH1_IGNORE_INNER_6OVER6_IP_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv6 packet header for\n IPv6 over IPv6 packets for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_INNER_6OVER6_GRE_TUNNELs,  /* HASH0_IGNORE_INNER_6OVER6_GRE_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv6 packet header for\n IPv6 over GRE-IPv6 packets (outer ip.protocol = 47)\n for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_INNER_6OVER6_GRE_TUNNELs,  /* HASH1_IGNORE_INNER_6OVER6_GRE_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv6 packet header for\n IPv6 over GRE-IPv6 packets (outer ip.protocol = 47)\n for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_INNER_4OVER6_GRE_TUNNELs,  /* HASH0_IGNORE_INNER_4OVER6_GRE_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv4 packet header for\n IPv4 over GRE-IPv6 packets (outer ip.protocol = 47)\n for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_INNER_4OVER6_GRE_TUNNELs,  /* HASH1_IGNORE_INNER_4OVER6_GRE_TUNNEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable hashing based on inner IPv4 packet header for\n IPv4 over GRE-IPv6 packets (outer ip.protocol = 47)\n for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_MPLSs,  /* HASH0_IGNORE_MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hash selection for MPLS packets default to Ethernet\n packets for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_MPLSs,  /* HASH1_IGNORE_MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hash selection for MPLS packets default to Ethernet\n packets for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_MIMs,  /* HASH0_IGNORE_MIM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hash selection for MiM packets default to Ethernet\n packets for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_MIMs,  /* HASH1_IGNORE_MIM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hash selection for MiM packets default to Ethernet\n packets for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_FCOEs,  /* HASH0_IGNORE_FCOE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to hash based on outer L2 fields for hash key 0.\n Disable to hash based on FCoE headers for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_FCOEs,  /* HASH1_IGNORE_FCOE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to hash based on outer L2 fields for hash key 1.\n Disable to hash based on FCoE headers for hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_L2GREs,  /* HASH0_IGNORE_L2GRE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hash selection for L2 GRE packets default to Ethernet\n packets for hash key 0.\n",
    },
    {
        .name  = HASH1_IGNORE_L2GREs,  /* HASH1_IGNORE_L2GRE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hash selection for L2 GRE packets default to Ethernet\n packets for hash key 1.\n",
    },
    {
        .name  = HASH0_MIM_USE_TUNNEL_HEADERs,  /* HASH0_MIM_USE_TUNNEL_HEADER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use tunnel header fields for MiM trafic for\n hash key 0.\n Disable to use payload fields for MiM traffic for\n hash key 0.\n",
    },
    {
        .name  = HASH1_MIM_USE_TUNNEL_HEADERs,  /* HASH1_MIM_USE_TUNNEL_HEADER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use tunnel header fields for MiM trafic for\n hash key 1.\n Disable to use payload fields for MiM traffic for\n hash key 1.\n",
    },
    {
        .name  = HASH0_IGNORE_VXLANs,  /* HASH0_IGNORE_VXLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hashing based on outer L3 header fields for hash key 0,\n if that is also disabled then it will default to\n outer L2 header fields.\n",
    },
    {
        .name  = HASH1_IGNORE_VXLANs,  /* HASH1_IGNORE_VXLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hashing based on outer L3 header fields for hash key 1,\n if that is also disabled then it will default to\n outer L2 header fields.\n",
    },
    {
        .name  = IGNORE_IP_EXTN_HDRs,  /* IGNORE_IP_EXTN_HDR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hashing to use protocol directly from IP header,\n ignoring presence of extension headers.\n Disable hashing to use 'last next header' in protocol bucket.\n",
    },
    {
        .name  = IGNORE_MPLS_RESERVED_LABELSs,  /* IGNORE_MPLS_RESERVED_LABELS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hashing to exclude reserved MPLS labels.",
    },
    {
        .name  = HASH_USE_MPLS_STACKs,  /* HASH_USE_MPLS_STACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to hash on up to the top 5 tunnel labels for MPLS.\n Disable to hash on up to the top 3 tunnel labels + tunnel payload\n IPv4/IPv6 source and destination address fields for MPLS.\n",
    },
    {
        .name  = HASH0_IP_TUNNEL_TERMs,  /* HASH0_IP_TUNNEL_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 0 selection for IP tunnel terminated packets.",
    },
    {
        .name  = HASH1_IP_TUNNEL_TERMs,  /* HASH1_IP_TUNNEL_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 1 selection for IP tunnel terminated packets.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_pkt_hdr_selection_t = {
    .name = LB_HASH_PKT_HDR_SELECTIONs, /* LB_HASH_PKT_HDR_SELECTION */
    .flags = 0,
    .fields = 37,
    .field = bcmltd_lb_hash_pkt_hdr_selection_t_fields,
    .desc = "The LB_HASH_PKT_HDR_SELECTION table specifies the packet header selection\n for various packet types.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_PORT_DLB_ECMP_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_port_dlb_ecmp_output_selection_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as\n                                 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as\n                                      4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for DLB ECMP.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for DLB ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_port_dlb_ecmp_output_selection_t = {
    .name = LB_HASH_PORT_DLB_ECMP_OUTPUT_SELECTIONs, /* LB_HASH_PORT_DLB_ECMP_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_lb_hash_port_dlb_ecmp_output_selection_t_fields,
    .desc = "The LB_HASH_PORT_DLB_ECMP_OUTPUT_SELECTION table specifies hash output\n selection control for port based DLB ECMP - mode, subset and offset.\n\n Port based hash output selection indexed by port ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least\n significant bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least\n     significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_PORT_ENTROPY_LABEL_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_port_entropy_label_output_selection_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_port_entropy_label_output_selection_t = {
    .name = LB_HASH_PORT_ENTROPY_LABEL_OUTPUT_SELECTIONs, /* LB_HASH_PORT_ENTROPY_LABEL_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_lb_hash_port_entropy_label_output_selection_t_fields,
    .desc = "Hash output selection control for port based entropy label - mode, subset and offset.\n\n Port based hash output selection indexed by port ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_PORT_L2_ECMP_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_port_l2_ecmp_output_selection_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB.",
    },
    {
        .name  = OVERLAY_CONCATs,  /* OVERLAY_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for overlay L2 ECMP.",
    },
    {
        .name  = OVERLAY_SUBSET_SELECTs,  /* OVERLAY_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for overlay L2 ECMP.",
    },
    {
        .name  = OVERLAY_OFFSETs,  /* OVERLAY_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for overlay L2 ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_port_l2_ecmp_output_selection_t = {
    .name = LB_HASH_PORT_L2_ECMP_OUTPUT_SELECTIONs, /* LB_HASH_PORT_L2_ECMP_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_lb_hash_port_l2_ecmp_output_selection_t_fields,
    .desc = "Hash output selection control for Layer 2 ECMP - mode, subset and offset.\n\n Port based hash output selection indexed by port ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_PORT_L3_ECMP_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_port_l3_ecmp_output_selection_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = LEVEL2_CONCATs,  /* LEVEL2_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = LEVEL2_SUBSET_SELECTs,  /* LEVEL2_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for L3 ECMP level 2.",
    },
    {
        .name  = LEVEL2_OFFSETs,  /* LEVEL2_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for L3 ECMP level 2.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for L3 ECMP.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for L3 ECMP.",
    },
    {
        .name  = MEMBER_WEIGHT_CONCATs,  /* MEMBER_WEIGHT_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for member weight of enhanced\n weighted ECMP: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as\n                                      4 * 16-bit fields.\n",
    },
    {
        .name  = MEMBER_WEIGHT_SUBSET_SELECTs,  /* MEMBER_WEIGHT_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for member weight of enhanced weighted ECMP.\n",
    },
    {
        .name  = MEMBER_WEIGHT_OFFSETs,  /* MEMBER_WEIGHT_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for member weight of enhanced weighted ECMP.",
    },
    {
        .name  = OVERLAY_CONCATs,  /* OVERLAY_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for overlay ECMP.",
    },
    {
        .name  = OVERLAY_SUBSET_SELECTs,  /* OVERLAY_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for overlay ECMP.",
    },
    {
        .name  = OVERLAY_OFFSETs,  /* OVERLAY_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for overlay ECMP.",
    },
    {
        .name  = OVERLAY_MEMBER_WEIGHT_CONCATs,  /* OVERLAY_MEMBER_WEIGHT_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for member weight of overlay\n enhanced weighted ECMP.",
    },
    {
        .name  = OVERLAY_MEMBER_WEIGHT_SUBSET_SELECTs,  /* OVERLAY_MEMBER_WEIGHT_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for member weight of overlay enhanced\n weighted ECMP.\n",
    },
    {
        .name  = OVERLAY_MEMBER_WEIGHT_OFFSETs,  /* OVERLAY_MEMBER_WEIGHT_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for member weight of overlay enhanced weighted\n ECMP.\n",
    },
    {
        .name  = PROTECTION_ECMP_CONCATs,  /* PROTECTION_ECMP_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for protection switching ECMP.",
    },
    {
        .name  = PROTECTION_ECMP_SUBSET_SELECTs,  /* PROTECTION_ECMP_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for protection switching ECMP.",
    },
    {
        .name  = PROTECTION_ECMP_OFFSETs,  /* PROTECTION_ECMP_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for protection switching ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_port_l3_ecmp_output_selection_t = {
    .name = LB_HASH_PORT_L3_ECMP_OUTPUT_SELECTIONs, /* LB_HASH_PORT_L3_ECMP_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 19,
    .field = bcmltd_lb_hash_port_l3_ecmp_output_selection_t_fields,
    .desc = "Hash output selection control for port based L3_ECMP - mode, subset and offset.\n\n Port based hash output selection indexed by port ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_PORT_LBID_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_port_lbid_output_selection_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = UC_CONCATs,  /* UC_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = UC_SUBSET_SELECTs,  /* UC_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for Load Balancing ID unicast.",
    },
    {
        .name  = UC_OFFSETs,  /* UC_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for Load Balancing ID unicast.",
    },
    {
        .name  = NONUC_CONCATs,  /* NONUC_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = NONUC_SUBSET_SELECTs,  /* NONUC_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for Load Balancing ID non-unicast.",
    },
    {
        .name  = NONUC_OFFSETs,  /* NONUC_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for Load Balancing ID non-unicast.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_port_lbid_output_selection_t = {
    .name = LB_HASH_PORT_LBID_OUTPUT_SELECTIONs, /* LB_HASH_PORT_LBID_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_lb_hash_port_lbid_output_selection_t_fields,
    .desc = "Hash output selection control for port based Load Balancing ID - mode, subset and offset.\n\n Port based hash output selection indexed by port ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_PORT_MPLS_ECMP_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_port_mpls_ecmp_output_selection_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB.",
    },
    {
        .name  = OVERLAY_CONCATs,  /* OVERLAY_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for overlay MPLS ECMP.",
    },
    {
        .name  = OVERLAY_SUBSET_SELECTs,  /* OVERLAY_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for overlay MPLS ECMP.",
    },
    {
        .name  = OVERLAY_OFFSETs,  /* OVERLAY_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for overlay MPLS ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_port_mpls_ecmp_output_selection_t = {
    .name = LB_HASH_PORT_MPLS_ECMP_OUTPUT_SELECTIONs, /* LB_HASH_PORT_MPLS_ECMP_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_lb_hash_port_mpls_ecmp_output_selection_t_fields,
    .desc = "Hash output selection control for MPLS ECMP - mode, subset and offset.\n\n Port based hash output selection indexed by port ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_PORT_PLFS_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_port_plfs_output_selection_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_port_plfs_output_selection_t = {
    .name = LB_HASH_PORT_PLFS_OUTPUT_SELECTIONs, /* LB_HASH_PORT_PLFS_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_lb_hash_port_plfs_output_selection_t_fields,
    .desc = "Hash output selection control for Port LAG Failover Set - mode, subset and offset.\n\n Port based hash output selection indexed by port ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_PORT_RH_ECMP_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_port_rh_ecmp_output_selection_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB.",
    },
    {
        .name  = OVERLAY_CONCATs,  /* OVERLAY_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode for overlay Resilient Hash ECMP.",
    },
    {
        .name  = OVERLAY_SUBSET_SELECTs,  /* OVERLAY_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for overlay Resilient Hash ECMP.",
    },
    {
        .name  = OVERLAY_OFFSETs,  /* OVERLAY_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for overlay Resilient Hash ECMP.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_port_rh_ecmp_output_selection_t = {
    .name = LB_HASH_PORT_RH_ECMP_OUTPUT_SELECTIONs, /* LB_HASH_PORT_RH_ECMP_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_lb_hash_port_rh_ecmp_output_selection_t_fields,
    .desc = "Hash output selection control for Resilient Hash ECMP - mode, subset and offset.\n\n Port based hash output selection indexed by port ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_PORT_TRUNK_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_port_trunk_output_selection_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = UC_CONCATs,  /* UC_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = UC_SUBSET_SELECTs,  /* UC_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for trunk unicast.",
    },
    {
        .name  = UC_OFFSETs,  /* UC_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for trunk unicast.",
    },
    {
        .name  = NONUC_CONCATs,  /* NONUC_CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenate mode: treat hash outputs as 1 * 64-bit field.\n Disable to use non-concatenate mode: treat hash outputs as 4 * 16-bit fields.\n",
    },
    {
        .name  = NONUC_SUBSET_SELECTs,  /* NONUC_SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash subset selection for trunk non-unicast.",
    },
    {
        .name  = NONUC_OFFSETs,  /* NONUC_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset of LSB for trunk non-unicast.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_port_trunk_output_selection_t = {
    .name = LB_HASH_PORT_TRUNK_OUTPUT_SELECTIONs, /* LB_HASH_PORT_TRUNK_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_lb_hash_port_trunk_output_selection_t_fields,
    .desc = "Hash output selection control for port based trunk - mode, subset and offset.\n\n Port based hash output selection indexed by port ID.\n\n Hash results from hash 0 instance 0/1 and hash 1 instance 0/1 together\n with other information form the final hash set which has 8 subsets.\n\n Each application can select which subset (SUBSET_SELECT) and least significant\n bit position in that subset (OFFSET) to derive final hash value.\n\n For example, if a subset is 16 bits long:\n     b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 b4 b3 b2 b1 b0\n when it is selected and offset is set to 5, the final hash value will be:\n     b4 b3 b2 b1 b0 b15 b14 b13 b12 b11 b10 b9 b8 b7 b6 b5 (bit 5 is least significant bit)\n\n Bit operation for non-concatenate mode: (sub-field value >> offset) |\n                                         (sub-field value << (16 - offset))\n Bit operation for concatenate mode    : (sub-field value >> offset) |\n                                         (sub-field value << (64 - offset))\n\n Subset example for non-concatenate mode (GE port):\n     Subset 0: Hash 0/0\n     Subset 1: Hash 1/0\n     Subset 2: IPORT.LBN\n     Subset 3: Hash 0/0\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: Hash 0/1\n     Subset 7: Hash 1/1\n\n Subset example for concatenate mode (GE port):\n     Subset 0: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 1: reserved\n     Subset 2: IPORT.LBN\n     Subset 3: Hash {1/1, 1/0, 0/1, 0/0}\n     Subset 4: LBID\n     Subset 5: LBID\n     Subset 6: reserved\n     Subset 7: reserved\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_SEED_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_seed_control_t_fields[] = {
    {
        .name  = HASH0_SEEDs,  /* HASH0_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Hash seed input for hash 0.",
    },
    {
        .name  = HASH1_SEEDs,  /* HASH1_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Hash seed input for hash 1.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_seed_control_t = {
    .name = LB_HASH_SEED_CONTROLs, /* LB_HASH_SEED_CONTROL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_lb_hash_seed_control_t_fields,
    .desc = "Hash seed configuration.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_TNL_MPLS_TRANSIT_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_tnl_mpls_transit_fields_selection_t_fields[] = {
    {
        .name  = HASH0_DST_MODIDs,  /* HASH0_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_DST_PORTs,  /* HASH0_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_SRC_MODIDs,  /* HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_SRC_PORTs,  /* HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_MPLS_3RD_LABELs,  /* HASH0_MPLS_3RD_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_SRC_IP_LOWERs,  /* HASH0_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_SRC_IP_UPPERs,  /* HASH0_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_DST_IP_LOWERs,  /* HASH0_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_DST_IP_UPPERs,  /* HASH0_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_MPLS_LABELS_4MSBs,  /* HASH0_MPLS_LABELS_4MSB */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_MPLS_2ND_LABELs,  /* HASH0_MPLS_2ND_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_MPLS_TOP_LABELs,  /* HASH0_MPLS_TOP_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_CNTAG_RPIDs,  /* HASH0_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_DST_MODIDs,  /* HASH1_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_DST_PORTs,  /* HASH1_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_SRC_MODIDs,  /* HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_SRC_PORTs,  /* HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_MPLS_3RD_LABELs,  /* HASH1_MPLS_3RD_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_SRC_IP_LOWERs,  /* HASH1_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_SRC_IP_UPPERs,  /* HASH1_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_DST_IP_LOWERs,  /* HASH1_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_DST_IP_UPPERs,  /* HASH1_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_MPLS_LABELS_4MSBs,  /* HASH1_MPLS_LABELS_4MSB */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_MPLS_2ND_LABELs,  /* HASH1_MPLS_2ND_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_MPLS_TOP_LABELs,  /* HASH1_MPLS_TOP_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_CNTAG_RPIDs,  /* HASH1_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_DST_MODIDs,  /* USE_MPLS_STACK_HASH0_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_DST_PORTs,  /* USE_MPLS_STACK_HASH0_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_SRC_MODIDs,  /* USE_MPLS_STACK_HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_SRC_PORTs,  /* USE_MPLS_STACK_HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_MPLS_3RD_LABELs,  /* USE_MPLS_STACK_HASH0_MPLS_3RD_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_MPLS_4MSB_5TH_LABELs,  /* USE_MPLS_STACK_HASH0_MPLS_4MSB_5TH_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_MPLS_4MSB_4TH_LABELs,  /* USE_MPLS_STACK_HASH0_MPLS_4MSB_4TH_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_MPLS_5TH_LABELs,  /* USE_MPLS_STACK_HASH0_MPLS_5TH_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_MPLS_4TH_LABELs,  /* USE_MPLS_STACK_HASH0_MPLS_4TH_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_MPLS_LABELS_4MSBs,  /* USE_MPLS_STACK_HASH0_MPLS_LABELS_4MSB */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_MPLS_2ND_LABELs,  /* USE_MPLS_STACK_HASH0_MPLS_2ND_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_MPLS_TOP_LABELs,  /* USE_MPLS_STACK_HASH0_MPLS_TOP_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_CNTAG_RPIDs,  /* USE_MPLS_STACK_HASH0_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_DST_MODIDs,  /* USE_MPLS_STACK_HASH1_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_DST_PORTs,  /* USE_MPLS_STACK_HASH1_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_SRC_MODIDs,  /* USE_MPLS_STACK_HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_SRC_PORTs,  /* USE_MPLS_STACK_HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_MPLS_3RD_LABELs,  /* USE_MPLS_STACK_HASH1_MPLS_3RD_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_MPLS_4MSB_5TH_LABELs,  /* USE_MPLS_STACK_HASH1_MPLS_4MSB_5TH_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_MPLS_4MSB_4TH_LABELs,  /* USE_MPLS_STACK_HASH1_MPLS_4MSB_4TH_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_MPLS_5TH_LABELs,  /* USE_MPLS_STACK_HASH1_MPLS_5TH_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_MPLS_4TH_LABELs,  /* USE_MPLS_STACK_HASH1_MPLS_4TH_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_MPLS_LABELS_4MSBs,  /* USE_MPLS_STACK_HASH1_MPLS_LABELS_4MSB */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_MPLS_2ND_LABELs,  /* USE_MPLS_STACK_HASH1_MPLS_2ND_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_MPLS_TOP_LABELs,  /* USE_MPLS_STACK_HASH1_MPLS_TOP_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_CNTAG_RPIDs,  /* USE_MPLS_STACK_HASH1_CNTAG_RPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for MPLS packets when tunneling\n fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_MPLS_3RD_LABEL_15_0s,  /* HASH0_EXT_MPLS_3RD_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_MPLS_LABELS_19_16s,  /* HASH0_EXT_MPLS_LABELS_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_EGR_PORT_ID_LOWERs,  /* HASH0_EXT_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_FLOW_LABEL_15_0s,  /* HASH0_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_VRF_IDs,  /* HASH0_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_15_0s,  /* HASH0_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_31_15s,  /* HASH0_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_47_32s,  /* HASH0_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_63_48s,  /* HASH0_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_15_0s,  /* HASH0_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_31_15s,  /* HASH0_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_47_32s,  /* HASH0_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_63_48s,  /* HASH0_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_MPLS_2ND_LABEL_15_0s,  /* HASH0_EXT_MPLS_2ND_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_MPLS_TOP_LABEL_15_0s,  /* HASH0_EXT_MPLS_TOP_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_UDF_1s,  /* HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_UDF_2s,  /* HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_UDF_3s,  /* HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_UDF_4s,  /* HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_UDF_5s,  /* HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_UDF_6s,  /* HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_UDF_7s,  /* HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH0_EXT_UDF_8s,  /* HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_MPLS_3RD_LABEL_15_0s,  /* HASH1_EXT_MPLS_3RD_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_MPLS_LABELS_19_16s,  /* HASH1_EXT_MPLS_LABELS_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_EGR_PORT_ID_LOWERs,  /* HASH1_EXT_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_FLOW_LABEL_15_0s,  /* HASH1_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_VRF_IDs,  /* HASH1_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_15_0s,  /* HASH1_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_31_15s,  /* HASH1_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_47_32s,  /* HASH1_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_63_48s,  /* HASH1_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_15_0s,  /* HASH1_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_31_15s,  /* HASH1_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_47_32s,  /* HASH1_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_63_48s,  /* HASH1_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_MPLS_2ND_LABEL_15_0s,  /* HASH1_EXT_MPLS_2ND_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_MPLS_TOP_LABEL_15_0s,  /* HASH1_EXT_MPLS_TOP_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_UDF_1s,  /* HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_UDF_2s,  /* HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_UDF_3s,  /* HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_UDF_4s,  /* HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_UDF_5s,  /* HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_UDF_6s,  /* HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_UDF_7s,  /* HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = HASH1_EXT_UDF_8s,  /* HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS).\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* USE_MPLS_STACK_HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_MPLS_3RD_LABEL_15_0s,  /* USE_MPLS_STACK_HASH0_EXT_MPLS_3RD_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_MPLS_LABELS_19_16s,  /* USE_MPLS_STACK_HASH0_EXT_MPLS_LABELS_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_EGR_PORT_ID_LOWERs,  /* USE_MPLS_STACK_HASH0_EXT_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_VLAN_IDs,  /* USE_MPLS_STACK_HASH0_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_VRF_IDs,  /* USE_MPLS_STACK_HASH0_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_MPLS_5TH_LABEL_19_16s,  /* USE_MPLS_STACK_HASH0_EXT_MPLS_5TH_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_MPLS_4TH_LABEL_19_16s,  /* USE_MPLS_STACK_HASH0_EXT_MPLS_4TH_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_MPLS_5TH_LABEL_15_0s,  /* USE_MPLS_STACK_HASH0_EXT_MPLS_5TH_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_MPLS_4TH_LABEL_15_0s,  /* USE_MPLS_STACK_HASH0_EXT_MPLS_4TH_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_MPLS_2ND_LABEL_15_0s,  /* USE_MPLS_STACK_HASH0_EXT_MPLS_2ND_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_MPLS_TOP_LABEL_15_0s,  /* USE_MPLS_STACK_HASH0_EXT_MPLS_TOP_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_UDF_1s,  /* USE_MPLS_STACK_HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_UDF_2s,  /* USE_MPLS_STACK_HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_UDF_3s,  /* USE_MPLS_STACK_HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_UDF_4s,  /* USE_MPLS_STACK_HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_UDF_5s,  /* USE_MPLS_STACK_HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_UDF_6s,  /* USE_MPLS_STACK_HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_UDF_7s,  /* USE_MPLS_STACK_HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH0_EXT_UDF_8s,  /* USE_MPLS_STACK_HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* USE_MPLS_STACK_HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_MPLS_3RD_LABEL_15_0s,  /* USE_MPLS_STACK_HASH1_EXT_MPLS_3RD_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_MPLS_LABELS_19_16s,  /* USE_MPLS_STACK_HASH1_EXT_MPLS_LABELS_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_EGR_PORT_ID_LOWERs,  /* USE_MPLS_STACK_HASH1_EXT_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_VLAN_IDs,  /* USE_MPLS_STACK_HASH1_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_VRF_IDs,  /* USE_MPLS_STACK_HASH1_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_MPLS_5TH_LABEL_19_16s,  /* USE_MPLS_STACK_HASH1_EXT_MPLS_5TH_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_MPLS_4TH_LABEL_19_16s,  /* USE_MPLS_STACK_HASH1_EXT_MPLS_4TH_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_MPLS_5TH_LABEL_15_0s,  /* USE_MPLS_STACK_HASH1_EXT_MPLS_5TH_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_MPLS_4TH_LABEL_15_0s,  /* USE_MPLS_STACK_HASH1_EXT_MPLS_4TH_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_MPLS_2ND_LABEL_15_0s,  /* USE_MPLS_STACK_HASH1_EXT_MPLS_2ND_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_MPLS_TOP_LABEL_15_0s,  /* USE_MPLS_STACK_HASH1_EXT_MPLS_TOP_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_UDF_1s,  /* USE_MPLS_STACK_HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_UDF_2s,  /* USE_MPLS_STACK_HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_UDF_3s,  /* USE_MPLS_STACK_HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_UDF_4s,  /* USE_MPLS_STACK_HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_UDF_5s,  /* USE_MPLS_STACK_HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_UDF_6s,  /* USE_MPLS_STACK_HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_UDF_7s,  /* USE_MPLS_STACK_HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
    {
        .name  = USE_MPLS_STACK_HASH1_EXT_UDF_8s,  /* USE_MPLS_STACK_HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for MPLS packets when\n tunneling fields are selected (non-terminated MPLS) and\n LB_HASH_PKT_HDR_SELECTION.HASH_USE_MPLS_STACK is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_tnl_mpls_transit_fields_selection_t = {
    .name = LB_HASH_TNL_MPLS_TRANSIT_FIELDS_SELECTIONs, /* LB_HASH_TNL_MPLS_TRANSIT_FIELDS_SELECTION */
    .flags = 0,
    .fields = 142,
    .field = bcmltd_lb_hash_tnl_mpls_transit_fields_selection_t_fields,
    .desc = "The LB_HASH_TNL_MPLS_TRANSIT_FIELDS_SELECTION table specifies hash field\n selection for non-terminated (transit) MPLS tunneled packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_TRUNK_FAILOVER_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_trunk_failover_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_TRUNK_FAILOVER_OUTPUT_SELECTION_IDs,  /* LB_HASH_TRUNK_FAILOVER_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into LB_HASH_TRUNK_FAILOVER_OUTPUT_SELECTION table.\n",
    },
    {
        .name  = LB_HASH_INSTANCEs,  /* LB_HASH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Hash table instance.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenation mode:\n treats hash output as 1 * 64-bit field.\n Disable to use non-concatenation mode:\n treats hash output as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the selection of subset of hash value\n from flex digest output.\n",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies the offset of the least significant bit\n in the selected subset hash value.\n",
    },
    {
        .name  = RESULT_SIZEs,  /* RESULT_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicates the number of bits required in the final hash result\n value, this final hash value is used in the group member offset\n index calculation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_trunk_failover_output_selection_t = {
    .name = LB_HASH_TRUNK_FAILOVER_OUTPUT_SELECTIONs, /* LB_HASH_TRUNK_FAILOVER_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_lb_hash_trunk_failover_output_selection_t_fields,
    .desc = "The LB_HASH_TRUNK_FAILOVER_OUTPUT_SELECTION table specifies\n the hash output selection used for the failover trunk resolution.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_TRUNK_NONUC_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_trunk_nonuc_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_TRUNK_NONUC_OUTPUT_SELECTION_IDs,  /* LB_HASH_TRUNK_NONUC_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into LB_HASH_TRUNK_NONUC_OUTPUT_SELECTION table.\n",
    },
    {
        .name  = LB_HASH_INSTANCEs,  /* LB_HASH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Hash table instance.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenation mode:\n treats hash output as 1 * 64-bit field.\n Disable to use non-concatenation mode:\n treats hash output as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the selection of subset of hash value\n from flex digest output.\n",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies the offset of the least significant bit\n in the selected subset hash value.\n",
    },
    {
        .name  = RESULT_SIZEs,  /* RESULT_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicates the number of bits required in the final hash result\n value, this final hash value is used in the group member offset\n index calculation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_trunk_nonuc_output_selection_t = {
    .name = LB_HASH_TRUNK_NONUC_OUTPUT_SELECTIONs, /* LB_HASH_TRUNK_NONUC_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_lb_hash_trunk_nonuc_output_selection_t_fields,
    .desc = "The LB_HASH_TRUNK_NONUC_OUTPUT_SELECTION table specifies\n the hash output selection used for the non-unicast trunk resolution.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_TRUNK_SYSTEM_FAILOVER_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_trunk_system_failover_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_TRUNK_SYSTEM_FAILOVER_OUTPUT_SELECTION_IDs,  /* LB_HASH_TRUNK_SYSTEM_FAILOVER_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into LB_HASH_TRUNK_SYSTEM_FAILOVER_OUTPUT_SELECTION table.\n",
    },
    {
        .name  = LB_HASH_INSTANCEs,  /* LB_HASH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Hash table instance.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenation mode:\n treats hash output as 1 * 64-bit field.\n Disable to use non-concatenation mode:\n treats hash output as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the selection of subset of hash value\n from flex digest output.\n",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies the offset of the least significant bit\n in the selected subset hash value.\n",
    },
    {
        .name  = RESULT_SIZEs,  /* RESULT_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicates the number of bits required in the final hash result\n value, this final hash value is used in the group member offset\n index calculation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_trunk_system_failover_output_selection_t = {
    .name = LB_HASH_TRUNK_SYSTEM_FAILOVER_OUTPUT_SELECTIONs, /* LB_HASH_TRUNK_SYSTEM_FAILOVER_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_lb_hash_trunk_system_failover_output_selection_t_fields,
    .desc = "The LB_HASH_TRUNK_SYSTEM_FAILOVER_OUTPUT_SELECTION table specifies\n the hash output selection used for the failover system trunk resolution.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_TRUNK_SYSTEM_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_trunk_system_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_TRUNK_SYSTEM_OUTPUT_SELECTION_IDs,  /* LB_HASH_TRUNK_SYSTEM_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into LB_HASH_TRUNK_SYSTEM_OUTPUT_SELECTION table.\n",
    },
    {
        .name  = LB_HASH_INSTANCEs,  /* LB_HASH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Hash table instance.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenation mode:\n treats hash output as 1 * 64-bit field.\n Disable to use non-concatenation mode:\n treats hash output as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the selection of subset of hash value\n from flex digest output.\n",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies the offset of the least significant bit\n in the selected subset hash value.\n",
    },
    {
        .name  = RESULT_SIZEs,  /* RESULT_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicates the number of bits required in the final hash result\n value, this final hash value is used in the group member offset\n index calculation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_trunk_system_output_selection_t = {
    .name = LB_HASH_TRUNK_SYSTEM_OUTPUT_SELECTIONs, /* LB_HASH_TRUNK_SYSTEM_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_lb_hash_trunk_system_output_selection_t_fields,
    .desc = "The LB_HASH_TRUNK_SYSTEM_OUTPUT_SELECTION table specifies\n the hash output selection used for the system trunk resolution.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_TRUNK_UC_OUTPUT_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_trunk_uc_output_selection_t_fields[] = {
    {
        .name  = LB_HASH_TRUNK_UC_OUTPUT_SELECTION_IDs,  /* LB_HASH_TRUNK_UC_OUTPUT_SELECTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into LB_HASH_TRUNK_UC_OUTPUT_SELECTION table.\n",
    },
    {
        .name  = LB_HASH_INSTANCEs,  /* LB_HASH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Hash table instance.",
    },
    {
        .name  = CONCATs,  /* CONCAT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use concatenation mode:\n treats hash output as 1 * 64-bit field.\n Disable to use non-concatenation mode:\n treats hash output as 4 * 16-bit fields.\n",
    },
    {
        .name  = SUBSET_SELECTs,  /* SUBSET_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Determines the selection of subset of hash value\n from flex digest output.\n",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies the offset of the least significant bit\n in the selected subset hash value.\n",
    },
    {
        .name  = RESULT_SIZEs,  /* RESULT_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicates the number of bits required in the final hash result\n value, this final hash value is used in the group member offset\n index calculation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_trunk_uc_output_selection_t = {
    .name = LB_HASH_TRUNK_UC_OUTPUT_SELECTIONs, /* LB_HASH_TRUNK_UC_OUTPUT_SELECTION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_lb_hash_trunk_uc_output_selection_t_fields,
    .desc = "The LB_HASH_TRUNK_UC_OUTPUT_SELECTION table specifies\n the hash output selection used for the unicast trunk resolution.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_TUNNEL_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_tunnel_fields_selection_t_fields[] = {
    {
        .name  = HASH0_TRILL_TERMs,  /* HASH0_TRILL_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 0 selection for TRILL terminated packets.",
    },
    {
        .name  = HASH1_TRILL_TERMs,  /* HASH1_TRILL_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 1 selection for TRILL terminated packets.",
    },
    {
        .name  = HASH0_MIM_TERMs,  /* HASH0_MIM_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 0 selection for MIM terminated packets.",
    },
    {
        .name  = HASH1_MIM_TERMs,  /* HASH1_MIM_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 1 selection for MIM terminated packets.",
    },
    {
        .name  = HASH0_MPLS_TERMs,  /* HASH0_MPLS_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 0 selection for MPLS terminated packets.",
    },
    {
        .name  = HASH1_MPLS_TERMs,  /* HASH1_MPLS_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 1 selection for MPLS terminated packets.",
    },
    {
        .name  = HASH0_VXLAN_TERMs,  /* HASH0_VXLAN_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 0 selection for VXLAN terminated packets.",
    },
    {
        .name  = HASH1_VXLAN_TERMs,  /* HASH1_VXLAN_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 1 selection for VXLAN terminated packets.",
    },
    {
        .name  = HASH0_L2GRE_TERMs,  /* HASH0_L2GRE_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 0 selection for L2GRE terminated packets\n and LB_HASH_BINS_ASSIGNMENT.HASH0_BINS5_6_L2GRE_KEY_EN is enabled.\n",
    },
    {
        .name  = HASH1_L2GRE_TERMs,  /* HASH1_L2GRE_TERM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 1 selection for L2GRE terminated packets\n and LB_HASH_BINS_ASSIGNMENT.HASH1_BINS5_6_L2GRE_KEY_EN is enabled.\n",
    },
    {
        .name  = HASH0_TRILL_TRANSITs,  /* HASH0_TRILL_TRANSIT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 0 selection for TRILL tunnel payload type.\n",
    },
    {
        .name  = HASH1_TRILL_TRANSITs,  /* HASH1_TRILL_TRANSIT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash 1 selection for TRILL tunnel payload type.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_tunnel_fields_selection_t = {
    .name = LB_HASH_TUNNEL_FIELDS_SELECTIONs, /* LB_HASH_TUNNEL_FIELDS_SELECTION */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_lb_hash_tunnel_fields_selection_t_fields,
    .desc = "Hash field selection for various tunnel packets.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_VERSATILE_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_versatile_control_t_fields[] = {
    {
        .name  = INITIAL_VALUE_0s,  /* INITIAL_VALUE_0 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Initial value 0.",
    },
    {
        .name  = INITIAL_VALUE_1s,  /* INITIAL_VALUE_1 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Initial value 1.",
    },
    {
        .name  = HASH0_INITIAL_VALUE_0s,  /* HASH0_INITIAL_VALUE_0 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Initial value 0 for hash 0.",
    },
    {
        .name  = HASH0_INITIAL_VALUE_1s,  /* HASH0_INITIAL_VALUE_1 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Initial value 1 for hash 0.",
    },
    {
        .name  = HASH1_INITIAL_VALUE_0s,  /* HASH1_INITIAL_VALUE_0 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Initial value 0 for hash 1.",
    },
    {
        .name  = HASH1_INITIAL_VALUE_1s,  /* HASH1_INITIAL_VALUE_1 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Initial value 1 for hash 1.",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_versatile_control_t = {
    .name = LB_HASH_VERSATILE_CONTROLs, /* LB_HASH_VERSATILE_CONTROL */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_lb_hash_versatile_control_t_fields,
    .desc = "The LB_HASH_VERSATILE_CONTROL table specifies initial values for versatile\n hash.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_VXLAN_L2_PAYLOAD_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_vxlan_l2_payload_fields_selection_t_fields[] = {
    {
        .name  = HASH0_SRC_MODIDs,  /* HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH0_SRC_PORTs,  /* HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH0_VIDs,  /* HASH0_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH0_ETH_TYPEs,  /* HASH0_ETH_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH0_MAC_DA_LOs,  /* HASH0_MAC_DA_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH0_MAC_DA_MEDs,  /* HASH0_MAC_DA_MED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH0_MAC_DA_HIs,  /* HASH0_MAC_DA_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH0_MAC_SA_LOs,  /* HASH0_MAC_SA_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH0_MAC_SA_MEDs,  /* HASH0_MAC_SA_MED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH0_MAC_SA_HIs,  /* HASH0_MAC_SA_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH1_SRC_MODIDs,  /* HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH1_SRC_PORTs,  /* HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH1_VIDs,  /* HASH1_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH1_ETH_TYPEs,  /* HASH1_ETH_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH1_MAC_DA_LOs,  /* HASH1_MAC_DA_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH1_MAC_DA_MEDs,  /* HASH1_MAC_DA_MED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH1_MAC_DA_HIs,  /* HASH1_MAC_DA_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH1_MAC_SA_LOs,  /* HASH1_MAC_SA_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH1_MAC_SA_MEDs,  /* HASH1_MAC_SA_MED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH1_MAC_SA_HIs,  /* HASH1_MAC_SA_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_EGR_PORT_ID_LOWERs,  /* HASH0_EXT_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_ETHERTYPEs,  /* HASH0_EXT_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_IDs,  /* HASH0_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_MAC_DA_15_0s,  /* HASH0_EXT_MAC_DA_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_MAC_DA_31_16s,  /* HASH0_EXT_MAC_DA_31_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_MAC_DA_47_32s,  /* HASH0_EXT_MAC_DA_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_MAC_SA_15_0s,  /* HASH0_EXT_MAC_SA_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_MAC_SA_31_16s,  /* HASH0_EXT_MAC_SA_31_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_MAC_SA_47_32s,  /* HASH0_EXT_MAC_SA_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_1s,  /* HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_2s,  /* HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_3s,  /* HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_4s,  /* HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_5s,  /* HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_6s,  /* HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_7s,  /* HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_8s,  /* HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_EGR_PORT_ID_LOWERs,  /* HASH1_EXT_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_ETHERTYPEs,  /* HASH1_EXT_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_IDs,  /* HASH1_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_MAC_DA_15_0s,  /* HASH1_EXT_MAC_DA_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_MAC_DA_31_16s,  /* HASH1_EXT_MAC_DA_31_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_MAC_DA_47_32s,  /* HASH1_EXT_MAC_DA_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_MAC_SA_15_0s,  /* HASH1_EXT_MAC_SA_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_MAC_SA_31_16s,  /* HASH1_EXT_MAC_SA_31_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_MAC_SA_47_32s,  /* HASH1_EXT_MAC_SA_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_1s,  /* HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_2s,  /* HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_3s,  /* HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_4s,  /* HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_5s,  /* HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_6s,  /* HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_7s,  /* HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_8s,  /* HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L2 payloads.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_vxlan_l2_payload_fields_selection_t = {
    .name = LB_HASH_VXLAN_L2_PAYLOAD_FIELDS_SELECTIONs, /* LB_HASH_VXLAN_L2_PAYLOAD_FIELDS_SELECTION */
    .flags = 0,
    .fields = 56,
    .field = bcmltd_lb_hash_vxlan_l2_payload_fields_selection_t_fields,
    .desc = "The LB_HASH_VXLAN_L2_PAYLOAD_FIELDS_SELECTION table specifies hash field selection\n for VXLAN terminated packets with L2 payloads.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lb_hash/LB_HASH_VXLAN_L3_PAYLOAD_FIELDS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lb_hash_vxlan_l3_payload_fields_selection_t_fields[] = {
    {
        .name  = HASH0_DST_MODIDs,  /* HASH0_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_FLOW_ID_LOs,  /* HASH0_FLOW_ID_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_DST_PORTs,  /* HASH0_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_FLOW_ID_HIs,  /* HASH0_FLOW_ID_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_SRC_MODIDs,  /* HASH0_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_SRC_PORTs,  /* HASH0_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_PROTOCOLs,  /* HASH0_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_NEXT_HEADERs,  /* HASH0_NEXT_HEADER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_L4_DSTs,  /* HASH0_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_SPI_LOWERs,  /* HASH0_SPI_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_TEID_LOWERs,  /* HASH0_TEID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_L4_SRCs,  /* HASH0_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_SPI_UPPERs,  /* HASH0_SPI_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_TEID_UPPERs,  /* HASH0_TEID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_VIDs,  /* HASH0_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_DST_IP_LOWERs,  /* HASH0_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_DST_IP_UPPERs,  /* HASH0_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_SRC_IP_LOWERs,  /* HASH0_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_SRC_IP_UPPERs,  /* HASH0_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_DST_MODIDs,  /* HASH1_DST_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_FLOW_ID_LOs,  /* HASH1_FLOW_ID_LO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_DST_PORTs,  /* HASH1_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_FLOW_ID_HIs,  /* HASH1_FLOW_ID_HI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_SRC_MODIDs,  /* HASH1_SRC_MODID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_SRC_PORTs,  /* HASH1_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_PROTOCOLs,  /* HASH1_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_NEXT_HEADERs,  /* HASH1_NEXT_HEADER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_L4_DSTs,  /* HASH1_L4_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_SPI_LOWERs,  /* HASH1_SPI_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_TEID_LOWERs,  /* HASH1_TEID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_L4_SRCs,  /* HASH1_L4_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_SPI_UPPERs,  /* HASH1_SPI_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_TEID_UPPERs,  /* HASH1_TEID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_VIDs,  /* HASH1_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_DST_IP_LOWERs,  /* HASH1_DST_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_DST_IP_UPPERs,  /* HASH1_DST_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_SRC_IP_LOWERs,  /* HASH1_SRC_IP_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH1_SRC_IP_UPPERs,  /* HASH1_SRC_IP_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 hash field selection for VXLAN terminated packets with\n L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH0_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_L4_DST_PORTs,  /* HASH0_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_L4_SRC_PORTs,  /* HASH0_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH0_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_FLOW_LABEL_15_0s,  /* HASH0_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH0_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_VLAN_IDs,  /* HASH0_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_VRF_IDs,  /* HASH0_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_15_0s,  /* HASH0_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_31_15s,  /* HASH0_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_47_32s,  /* HASH0_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_DST_IP_63_48s,  /* HASH0_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_15_0s,  /* HASH0_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_31_15s,  /* HASH0_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_47_32s,  /* HASH0_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_SRC_IP_63_48s,  /* HASH0_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_LOWERs,  /* HASH0_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_L2GRE_KEY_UPPERs,  /* HASH0_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_1s,  /* HASH0_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_2s,  /* HASH0_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_3s,  /* HASH0_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_4s,  /* HASH0_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_5s,  /* HASH0_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_6s,  /* HASH0_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_7s,  /* HASH0_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH0_EXT_UDF_8s,  /* HASH0_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 0 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPERs,  /* HASH1_EXT_ING_PORT_ID_EGR_PORT_ID_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_L4_DST_PORTs,  /* HASH1_EXT_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_L4_SRC_PORTs,  /* HASH1_EXT_L4_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWERs,  /* HASH1_EXT_PROTOCOL_EGR_PORT_ID_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_FLOW_LABEL_15_0s,  /* HASH1_EXT_FLOW_LABEL_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16s,  /* HASH1_EXT_VLAN_ID_FLOW_LABEL_19_16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_VLAN_IDs,  /* HASH1_EXT_VLAN_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_VRF_IDs,  /* HASH1_EXT_VRF_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_15_0s,  /* HASH1_EXT_DST_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_31_15s,  /* HASH1_EXT_DST_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_47_32s,  /* HASH1_EXT_DST_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_DST_IP_63_48s,  /* HASH1_EXT_DST_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_15_0s,  /* HASH1_EXT_SRC_IP_15_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_31_15s,  /* HASH1_EXT_SRC_IP_31_15 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_47_32s,  /* HASH1_EXT_SRC_IP_47_32 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_SRC_IP_63_48s,  /* HASH1_EXT_SRC_IP_63_48 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_LOWERs,  /* HASH1_EXT_L2GRE_KEY_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_L2GRE_KEY_UPPERs,  /* HASH1_EXT_L2GRE_KEY_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_1s,  /* HASH1_EXT_UDF_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_2s,  /* HASH1_EXT_UDF_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_3s,  /* HASH1_EXT_UDF_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_4s,  /* HASH1_EXT_UDF_4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_5s,  /* HASH1_EXT_UDF_5 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_6s,  /* HASH1_EXT_UDF_6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_7s,  /* HASH1_EXT_UDF_7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
    {
        .name  = HASH1_EXT_UDF_8s,  /* HASH1_EXT_UDF_8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Hash 1 extended hash field selection for VXLAN terminated\n packets with L3 payloads.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lb_hash_vxlan_l3_payload_fields_selection_t = {
    .name = LB_HASH_VXLAN_L3_PAYLOAD_FIELDS_SELECTIONs, /* LB_HASH_VXLAN_L3_PAYLOAD_FIELDS_SELECTION */
    .flags = 0,
    .fields = 90,
    .field = bcmltd_lb_hash_vxlan_l3_payload_fields_selection_t_fields,
    .desc = "The LB_HASH_VXLAN_L3_PAYLOAD_FIELDS_SELECTION table specifies hash field\n selection for VXLAN terminated packets with L3 payloads.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/learn/LEARN_CACHE_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_learn_cache_control_t_fields[] = {
    {
        .name  = REPORTs,  /* REPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable reporting.",
    },
    {
        .name  = SLOW_POLLs,  /* SLOW_POLL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use slow poll for learn cache.",
    },
};
const bcmltd_table_rep_t bcmltd_learn_cache_control_t = {
    .name = LEARN_CACHE_CONTROLs, /* LEARN_CACHE_CONTROL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_learn_cache_control_t_fields,
    .desc = "The LEARN_CACHE_CONTROL table is used to enable/disable reporting\n the learnt cache fields of packets to end users.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/learn/LEARN_CACHE_DATA.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_learn_cache_data_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Packet processor pipe number.",
    },
    {
        .name  = LEARN_CACHE_DATA_IDs,  /* LEARN_CACHE_DATA_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "LEARN_CACHE_DATA logical table index.",
    },
    {
        .name  = CACHE_FIELD0s,  /* CACHE_FIELD0 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Cache field 0.",
    },
    {
        .name  = CACHE_FIELD1s,  /* CACHE_FIELD1 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Cache field 1.",
    },
    {
        .name  = CACHE_FIELD2s,  /* CACHE_FIELD2 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Cache field 2.",
    },
    {
        .name  = CACHE_FIELD3s,  /* CACHE_FIELD3 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Cache field 3.",
    },
    {
        .name  = CACHE_FIELD4s,  /* CACHE_FIELD4 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Cache field 4.",
    },
    {
        .name  = CACHE_FIELD5s,  /* CACHE_FIELD5 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Cache field 5.",
    },
    {
        .name  = CACHE_FIELD6s,  /* CACHE_FIELD6 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Cache field 6.",
    },
    {
        .name  = CACHE_FIELD7s,  /* CACHE_FIELD7 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Cache field 7.",
    },
    {
        .name  = LEARN_CACHE_DATA_INFO_IDs,  /* LEARN_CACHE_DATA_INFO_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "LEARN_CACHE_DATA_INFO logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_learn_cache_data_t = {
    .name = LEARN_CACHE_DATAs, /* LEARN_CACHE_DATA */
    .flags = 0,
    .fields = 11,
    .field = bcmltd_learn_cache_data_t_fields,
    .desc = "The LEARN_CACHE_DATA table is used to report learnt cache fields.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/learn/LEARN_CACHE_DATA_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_learn_cache_data_control_t_fields[] = {
    {
        .name  = LEARN_CACHE_DATA_INFO_IDs,  /* LEARN_CACHE_DATA_INFO_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the LEARN_CACHE_DATA_INFO table.",
    },
    {
        .name  = LEARN_CACHEs,  /* LEARN_CACHE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable learn cache.",
    },
};
const bcmltd_table_rep_t bcmltd_learn_cache_data_control_t = {
    .name = LEARN_CACHE_DATA_CONTROLs, /* LEARN_CACHE_DATA_CONTROL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_learn_cache_data_control_t_fields,
    .desc = "The LEARN_CACHE_DATA_CONTROL table is used to specify\n learn cache instance attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lm/LM_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lm_control_t_fields[] = {
    {
        .name  = SCAN_ENABLEs,  /* SCAN_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable Link scan.",
    },
    {
        .name  = SCAN_INTERVALs,  /* SCAN_INTERVAL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Time between scans (in usecs).",
    },
};
const bcmltd_table_rep_t bcmltd_lm_control_t = {
    .name = LM_CONTROLs, /* LM_CONTROL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_lm_control_t_fields,
    .desc = "Link manager configuration.\n\n This one entry table defines configuration of link manager.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lm/LM_LINK_STATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lm_link_state_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port number.",
    },
    {
        .name  = LINK_STATEs,  /* LINK_STATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Logical link state indicates whether the logical port (MAC,\n MMU, etc.) is able to forward packets.\n",
    },
    {
        .name  = PHY_LINKs,  /* PHY_LINK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Physical link state indicates whether the physical link\n (SerDes/PHY) is able to forward packets.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lm_link_state_t = {
    .name = LM_LINK_STATEs, /* LM_LINK_STATE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_lm_link_state_t_fields,
    .desc = "Link state maintained by the Link Manager.\n\n This read-only table provides the link state of the ports\n maintained by the Link Manager.\n\n Entries in this table are created as a result of entries being\n created in the LM_PORT_CONTROL table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/lm/LM_PORT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_lm_port_control_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port number.",
    },
    {
        .name  = LINKSCAN_MODEs,  /* LINKSCAN_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_LM_LINKSCAN_MODE_T_DATA,
        .desc = "Linkscan mode of logical port.",
    },
    {
        .name  = OVERRIDE_LINK_STATEs,  /* OVERRIDE_LINK_STATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Physical link status of those ports with override mode.",
    },
    {
        .name  = MANUAL_SYNCs,  /* MANUAL_SYNC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable automatic synchronization of the port state when a\n link state change is detected. Normally a link-up event will\n result in a port-up sequence, and a link-down event will result\n in a port-down sequence.\n\n Note that the link transition may be missed if running manual\n synchronization with software/hardware linkscan mode.\n",
    },
};
const bcmltd_table_rep_t bcmltd_lm_port_control_t = {
    .name = LM_PORT_CONTROLs, /* LM_PORT_CONTROL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_lm_port_control_t_fields,
    .desc = "Link scan configuration of port.\n\n This table defines per-port link scan configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/MACSEC_TMP_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_macsec_tmp_config_t_fields[] = {
    {
        .name  = MACSEC_SRC_PM13_OVER_PM19s,  /* MACSEC_SRC_PM13_OVER_PM19 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC_SRC_PM12_OVER_PM18s,  /* MACSEC_SRC_PM12_OVER_PM18 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC_SRC_PM11_OVER_PM17s,  /* MACSEC_SRC_PM11_OVER_PM17 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC_SRC_PM10_OVER_PM16s,  /* MACSEC_SRC_PM10_OVER_PM16 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC_SRC_PM3_OVER_PM9s,  /* MACSEC_SRC_PM3_OVER_PM9 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC_SRC_PM2_OVER_PM8s,  /* MACSEC_SRC_PM2_OVER_PM8 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC_SRC_PM1_OVER_PM7s,  /* MACSEC_SRC_PM1_OVER_PM7 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC_SRC_PM0_OVER_PM6s,  /* MACSEC_SRC_PM0_OVER_PM6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC0_ACTIVEs,  /* MACSEC0_ACTIVE */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC1_ACTIVEs,  /* MACSEC1_ACTIVE */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC2_ACTIVEs,  /* MACSEC2_ACTIVE */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC3_ACTIVEs,  /* MACSEC3_ACTIVE */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC4_ACTIVEs,  /* MACSEC4_ACTIVE */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = MACSEC5_ACTIVEs,  /* MACSEC5_ACTIVE */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
};
const bcmltd_table_rep_t bcmltd_macsec_tmp_config_t = {
    .name = MACSEC_TMP_CONFIGs, /* MACSEC_TMP_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 15,
    .field = bcmltd_macsec_tmp_config_t_fields,
    .desc = "The MACSEC_TMP_CONFIG table programs the Macsec bootup parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_EGR_FP_DEVICE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_egr_fp_device_info_t_fields[] = {
    {
        .name  = NUM_METER_POOLSs,  /* NUM_METER_POOLS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of meter pools.\n",
    },
    {
        .name  = NUM_METERS_PER_POOLs,  /* NUM_METERS_PER_POOL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of meters per pool.\n",
    },
    {
        .name  = NUM_METERS_PER_PIPEs,  /* NUM_METERS_PER_PIPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Total number of meters per pipe.\n",
    },
    {
        .name  = NUM_METERSs,  /* NUM_METERS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Total number of meters.\n",
    },
    {
        .name  = NUM_METERS_IN_USEs,  /* NUM_METERS_IN_USE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of meters in use.\n",
    },
    {
        .name  = NUM_GRANULARITYs,  /* NUM_GRANULARITY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of granularities supported.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_egr_fp_device_info_t = {
    .name = METER_EGR_FP_DEVICE_INFOs, /* METER_EGR_FP_DEVICE_INFO */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_meter_egr_fp_device_info_t_fields,
    .desc = "The METER_EGR_FP_DEVICE_INFO table is used to\n provide information about EFP meters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_EGR_FP_GRANULARITY_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_egr_fp_granularity_info_t_fields[] = {
    {
        .name  = METER_EGR_FP_GRANULARITY_INFO_IDs,  /* METER_EGR_FP_GRANULARITY_INFO_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Meter granularity.",
    },
    {
        .name  = MIN_RATE_KBPSs,  /* MIN_RATE_KBPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum rate in kbps supported at this granularity level.\n",
    },
    {
        .name  = MAX_RATE_KBPSs,  /* MAX_RATE_KBPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum rate in kbps supported at this granularity level.\n",
    },
    {
        .name  = MIN_BURST_KBITSs,  /* MIN_BURST_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum burst size in kits supported at this granularity level.\n",
    },
    {
        .name  = MAX_BURST_KBITSs,  /* MAX_BURST_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum burst size in kits supported at this granularity level.\n",
    },
    {
        .name  = MIN_RATE_PPSs,  /* MIN_RATE_PPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum rate in pps supported at this granularity level.\n",
    },
    {
        .name  = MAX_RATE_PPSs,  /* MAX_RATE_PPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum rate in pps supported at this granularity level.\n",
    },
    {
        .name  = MIN_BURST_PKTSs,  /* MIN_BURST_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum burst size in pkts supported at this granularity level.\n",
    },
    {
        .name  = MAX_BURST_PKTSs,  /* MAX_BURST_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum burst size in pkts supported at this granularity level.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_egr_fp_granularity_info_t = {
    .name = METER_EGR_FP_GRANULARITY_INFOs, /* METER_EGR_FP_GRANULARITY_INFO */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_meter_egr_fp_granularity_info_t_fields,
    .desc = "The METER_EGR_FP_GRANULARITY_INFO table is used to\n provide information about the metering rates and\n burst sizes supported at each granularity level by\n EFP Meters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_EGR_FP_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_egr_fp_template_t_fields[] = {
    {
        .name  = METER_EGR_FP_TEMPLATE_IDs,  /* METER_EGR_FP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Meter identifier.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = POOL_INSTANCEs,  /* POOL_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Meter pool instance.",
    },
    {
        .name  = PKT_MODEs,  /* PKT_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable for packet mode metering, disable for byte mode metering.",
    },
    {
        .name  = METER_MODEs,  /* METER_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_METER_FP_MODE_T_DATA,
        .desc = "Metering mode.",
    },
    {
        .name  = COLOR_MODEs,  /* COLOR_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable for color aware metering, disable for color blind metering.",
    },
    {
        .name  = MIN_RATE_KBPSs,  /* MIN_RATE_KBPS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Committed rate in kbps.\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MAX_RATE_KBPSs,  /* MAX_RATE_KBPS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Peak rate in kbps.\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_KBITSs,  /* MIN_BURST_SIZE_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Committed burst size in kbits.\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MAX_BURST_SIZE_KBITSs,  /* MAX_BURST_SIZE_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Peak burst size in kbits.\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MIN_RATE_KBPS_OPERs,  /* MIN_RATE_KBPS_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational committed rate. This is a read-only field which\n reflects any modification to the configured MIN_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MAX_RATE_KBPS_OPERs,  /* MAX_RATE_KBPS_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational peak rate. This is a read-only field which\n reflects any modification to the configured MAX_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_KBITS_OPERs,  /* MIN_BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational committed burst size. This is a read-only field\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MAX_BURST_SIZE_KBITS_OPERs,  /* MAX_BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational peak burst size. This is a read-only field\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MIN_RATE_PPSs,  /* MIN_RATE_PPS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Committed rate in pps.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MAX_RATE_PPSs,  /* MAX_RATE_PPS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Peak rate in pps.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_PKTSs,  /* MIN_BURST_SIZE_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Committed burst size in packet.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MAX_BURST_SIZE_PKTSs,  /* MAX_BURST_SIZE_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Peak burst size in packets.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MIN_RATE_PPS_OPERs,  /* MIN_RATE_PPS_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational committed rate. This is a read-only field which\n reflects any modification to the configured MIN_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MAX_RATE_PPS_OPERs,  /* MAX_RATE_PPS_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational peak rate. This is a read-only field which\n reflects any modification to the configured MAX_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_PKTS_OPERs,  /* MIN_BURST_SIZE_PKTS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational committed burst size. This is a read-only field.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MAX_BURST_SIZE_PKTS_OPERs,  /* MAX_BURST_SIZE_PKTS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational peak burst size. This is a read-only field.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = FP_METER_ACTION_SETs,  /* FP_METER_ACTION_SET */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Read-only field which reflects the hardware values\n corresponding to this meter entry. This field can be\n used to program METER_ACTION_SET fields in\n the DT_EFP_ACTION_TEMPLATE table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_egr_fp_template_t = {
    .name = METER_EGR_FP_TEMPLATEs, /* METER_EGR_FP_TEMPLATE */
    .flags = 0,
    .fields = 23,
    .field = bcmltd_meter_egr_fp_template_t_fields,
    .desc = "The METER_EGR_FP_TEMPLATE table specifies\n egress field processor meters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_EGR_PKT_LEN_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_egr_pkt_len_profile_t_fields[] = {
    {
        .name  = METER_EGR_PKT_LEN_PROFILE_IDs,  /* METER_EGR_PKT_LEN_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index to the packet length profile table.",
    },
    {
        .name  = BYTESs,  /* BYTES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of bytes that should be incremented or decremented\n from the packet length.\n",
    },
    {
        .name  = DECREMENTs,  /* DECREMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to decrement the specified BYTES value from the\n packet length. Disable to increment the packet length with\n the specified BYTES value.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_egr_pkt_len_profile_t = {
    .name = METER_EGR_PKT_LEN_PROFILEs, /* METER_EGR_PKT_LEN_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_meter_egr_pkt_len_profile_t_fields,
    .desc = "The METER_EGR_PKT_LEN_PROFILE table specifies the packet length\n adjustment for counters, meters and shapers.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_FP_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_fp_config_t_fields[] = {
    {
        .name  = METER_ING_OPERMODE_PIPEUNIQUEs,  /* METER_ING_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify ingress FP meter in pipe unique\n operating mode.\n",
    },
    {
        .name  = METER_EGR_OPERMODE_PIPEUNIQUEs,  /* METER_EGR_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify egress FP meter in pipe unique\n operating mode.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_fp_config_t = {
    .name = METER_FP_CONFIGs, /* METER_FP_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 2,
    .field = bcmltd_meter_fp_config_t_fields,
    .desc = "The METER_FP_CONFIG table is used to configure the operating\n modes for ingress and egress FP meters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_FP_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_fp_control_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = BYTE_COUNT_INGs,  /* BYTE_COUNT_ING */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bytes to add in addition to the packet\n byte count in Ingress metering.\n",
    },
    {
        .name  = BYTE_COUNT_EGRs,  /* BYTE_COUNT_EGR */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Bytes to add in addition to the packet\n byte count in Egress counters and meters.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_fp_control_t = {
    .name = METER_FP_CONTROLs, /* METER_FP_CONTROL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_meter_fp_control_t_fields,
    .desc = "The METER_FP_CONTROL table is used to configure\n the number of extra bytes to be added to\n the packet byte count for metering.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_FP_SBR_OFFSET.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_fp_sbr_offset_t_fields[] = {
    {
        .name  = GREEN_OFFSET_EGRs,  /* GREEN_OFFSET_EGR */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Egress meter SBR profile table\n (DT_EFP_METER_ACTION_SBR_TEMPLATE) index\n offset for green packets.\n",
    },
    {
        .name  = YELLOW_OFFSET_EGRs,  /* YELLOW_OFFSET_EGR */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Egress meter SBR profile table\n (DT_EFP_METER_ACTION_SBR_TEMPLATE) index\n offset for yellow packets.\n",
    },
    {
        .name  = RED_OFFSET_EGRs,  /* RED_OFFSET_EGR */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Egress meter SBR profile table\n (DT_EFP_METER_ACTION_SBR_TEMPLATE) index\n offset for red packets.\n",
    },
    {
        .name  = GREEN_OFFSET_INGs,  /* GREEN_OFFSET_ING */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress meter SBR profile table\n (DT_IFP_METER_ACTION_SBR_TEMPLATE) index\n offset for green packets.\n",
    },
    {
        .name  = YELLOW_OFFSET_INGs,  /* YELLOW_OFFSET_ING */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress meter SBR profile table\n (DT_IFP_METER_ACTION_SBR_TEMPLATE) index\n offset for yellow packets.\n",
    },
    {
        .name  = RED_OFFSET_INGs,  /* RED_OFFSET_ING */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress meter SBR profile table\n (DT_IFP_METER_ACTION_SBR_TEMPLATE) index\n offset for red packets.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_fp_sbr_offset_t = {
    .name = METER_FP_SBR_OFFSETs, /* METER_FP_SBR_OFFSET */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_meter_fp_sbr_offset_t_fields,
    .desc = "The METER_FP_SBR_OFFSET table is used to configure\n the SBR (Strength Based Resolution) profile table\n index offset for each color.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_ING_FP_DEVICE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_ing_fp_device_info_t_fields[] = {
    {
        .name  = NUM_METER_POOLSs,  /* NUM_METER_POOLS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of meter pools.\n",
    },
    {
        .name  = NUM_METERS_PER_POOLs,  /* NUM_METERS_PER_POOL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of meters per pool.\n",
    },
    {
        .name  = NUM_METERS_PER_PIPEs,  /* NUM_METERS_PER_PIPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Total number of meters per pipe.\n",
    },
    {
        .name  = NUM_METERSs,  /* NUM_METERS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Total number of meters.\n",
    },
    {
        .name  = NUM_METERS_IN_USEs,  /* NUM_METERS_IN_USE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of meters in use.\n",
    },
    {
        .name  = NUM_GRANULARITYs,  /* NUM_GRANULARITY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of granularities supported.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_ing_fp_device_info_t = {
    .name = METER_ING_FP_DEVICE_INFOs, /* METER_ING_FP_DEVICE_INFO */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_meter_ing_fp_device_info_t_fields,
    .desc = "The METER_ING_FP_DEVICE_INFO table is used to\n provide information about IFP meters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_ING_FP_GRANULARITY_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_ing_fp_granularity_info_t_fields[] = {
    {
        .name  = METER_ING_FP_GRANULARITY_INFO_IDs,  /* METER_ING_FP_GRANULARITY_INFO_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Meter granularity.",
    },
    {
        .name  = MIN_RATE_KBPSs,  /* MIN_RATE_KBPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum rate in kbps supported at this granularity level.\n",
    },
    {
        .name  = MAX_RATE_KBPSs,  /* MAX_RATE_KBPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum rate in kbps supported at this granularity level.\n",
    },
    {
        .name  = MIN_BURST_KBITSs,  /* MIN_BURST_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum burst size in kits supported at this granularity level.\n",
    },
    {
        .name  = MAX_BURST_KBITSs,  /* MAX_BURST_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum burst size in kits supported at this granularity level.\n",
    },
    {
        .name  = MIN_RATE_PPSs,  /* MIN_RATE_PPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum rate in pps supported at this granularity level.\n",
    },
    {
        .name  = MAX_RATE_PPSs,  /* MAX_RATE_PPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum rate in pps supported at this granularity level.\n",
    },
    {
        .name  = MIN_BURST_PKTSs,  /* MIN_BURST_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum burst size in pkts supported at this granularity level.\n",
    },
    {
        .name  = MAX_BURST_PKTSs,  /* MAX_BURST_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum burst size in pkts supported at this granularity level.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_ing_fp_granularity_info_t = {
    .name = METER_ING_FP_GRANULARITY_INFOs, /* METER_ING_FP_GRANULARITY_INFO */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_meter_ing_fp_granularity_info_t_fields,
    .desc = "The METER_ING_FP_GRANULARITY_INFO table is used to\n provide information about the metering rates and\n burst sizes supported at each granularity level by\n IFP Meters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_ING_FP_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_ing_fp_template_t_fields[] = {
    {
        .name  = METER_ING_FP_TEMPLATE_IDs,  /* METER_ING_FP_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Meter identifier.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = POOL_INSTANCEs,  /* POOL_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Meter pool instance.",
    },
    {
        .name  = PKT_MODEs,  /* PKT_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable for packet mode metering, disable for byte mode metering.",
    },
    {
        .name  = METER_MODEs,  /* METER_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_METER_FP_MODE_T_DATA,
        .desc = "Metering mode.",
    },
    {
        .name  = COLOR_MODEs,  /* COLOR_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable for color aware metering, disable for color blind metering.",
    },
    {
        .name  = MIN_RATE_KBPSs,  /* MIN_RATE_KBPS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Committed rate in kbps.\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MAX_RATE_KBPSs,  /* MAX_RATE_KBPS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Peak rate in kbps.\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_KBITSs,  /* MIN_BURST_SIZE_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Committed burst size in kbits.\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MAX_BURST_SIZE_KBITSs,  /* MAX_BURST_SIZE_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Peak burst size in kbits.\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MIN_RATE_KBPS_OPERs,  /* MIN_RATE_KBPS_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational committed rate. This is a read-only field which\n reflects any modification to the configured MIN_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MAX_RATE_KBPS_OPERs,  /* MAX_RATE_KBPS_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational peak rate. This is a read-only field which\n reflects any modification to the configured MAX_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_KBITS_OPERs,  /* MIN_BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational committed burst size. This is a read-only field\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MAX_BURST_SIZE_KBITS_OPERs,  /* MAX_BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational peak burst size. This is a read-only field\n Valid only if PKT_MODE is disabled.\n",
    },
    {
        .name  = MIN_RATE_PPSs,  /* MIN_RATE_PPS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Committed rate in pps.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MAX_RATE_PPSs,  /* MAX_RATE_PPS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Peak rate in pps.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_PKTSs,  /* MIN_BURST_SIZE_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Committed burst size in packet.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MAX_BURST_SIZE_PKTSs,  /* MAX_BURST_SIZE_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Peak burst size in packets.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MIN_RATE_PPS_OPERs,  /* MIN_RATE_PPS_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational committed rate. This is a read-only field which\n reflects any modification to the configured MIN_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MAX_RATE_PPS_OPERs,  /* MAX_RATE_PPS_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational peak rate. This is a read-only field which\n reflects any modification to the configured MAX_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_PKTS_OPERs,  /* MIN_BURST_SIZE_PKTS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational committed burst size. This is a read-only field.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = MAX_BURST_SIZE_PKTS_OPERs,  /* MAX_BURST_SIZE_PKTS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational peak burst size. This is a read-only field.\n Valid only if PKT_MODE is enabled.\n",
    },
    {
        .name  = FP_METER_ACTION_SETs,  /* FP_METER_ACTION_SET */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Read-only field which reflects the hardware values\n corresponding to this meter entry. This field can be\n used to program METER_ACTION_SET fields in\n the DT_IFP_ACTION_TEMPLATE table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_ing_fp_template_t = {
    .name = METER_ING_FP_TEMPLATEs, /* METER_ING_FP_TEMPLATE */
    .flags = 0,
    .fields = 23,
    .field = bcmltd_meter_ing_fp_template_t_fields,
    .desc = "The METER_ING_FP_TEMPLATE table specifies\n ingress field processor meters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_L2_IIF_STORM_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_l2_iif_storm_control_t_fields[] = {
    {
        .name  = METER_L2_IIF_STORM_CONTROL_IDs,  /* METER_L2_IIF_STORM_CONTROL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "STORM_CONTROL_METER index.\n",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = BYTE_MODEs,  /* BYTE_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable for byte mode metering. Disable for packet mode metering.",
    },
    {
        .name  = METER_OFFSETs,  /* METER_OFFSET */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable to activate the meter offset.",
    },
    {
        .name  = METER_RATE_KBPSs,  /* METER_RATE_KBPS */
        .flags = 0,
        .width = 64,
        .depth = 4,
        .desc = "Metering rate in kbps.\n Valid only if BYTE_MODE is enabled.\n",
    },
    {
        .name  = BURST_SIZE_KBITSs,  /* BURST_SIZE_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 4,
        .desc = "Burst size in kbits.\n Valid only if BYTE_MODE is enabled.\n",
    },
    {
        .name  = METER_RATE_KBPS_OPERs,  /* METER_RATE_KBPS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 4,
        .desc = "Operational meter rate. This is a read-only field which\n reflects any modification to the configured METER_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields.\n Valid only if BYTE_MODE is enabled.\n",
    },
    {
        .name  = BURST_SIZE_KBITS_OPERs,  /* BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 4,
        .desc = "Operational burst size. This is a read-only field.\n Valid only if BYTE_MODE is enabled.\n",
    },
    {
        .name  = METER_RATE_PPSs,  /* METER_RATE_PPS */
        .flags = 0,
        .width = 64,
        .depth = 4,
        .desc = "Metering rate in pps.\n Valid only if BYTE_MODE is disabled.\n",
    },
    {
        .name  = BURST_SIZE_PKTSs,  /* BURST_SIZE_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 4,
        .desc = "Burst size in packets.\n Valid only if BYTE_MODE is disabled.\n",
    },
    {
        .name  = METER_RATE_PPS_OPERs,  /* METER_RATE_PPS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 4,
        .desc = "Operational meter rate. This is a read-only field which\n reflects any modification to the configured METER_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields.\n Valid only if BYTE_MODE is disabled.\n",
    },
    {
        .name  = BURST_SIZE_PKTS_OPERs,  /* BURST_SIZE_PKTS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 4,
        .desc = "Operational burst size. This is a read-only field.\n Valid only if BYTE_MODE is disabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_l2_iif_storm_control_t = {
    .name = METER_L2_IIF_STORM_CONTROLs, /* METER_L2_IIF_STORM_CONTROL */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_meter_l2_iif_storm_control_t_fields,
    .desc = "The METER_L2_IIF_STORM_CONTROL table is used to\n configure the metering rate and burst size for\n each storm control meter.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_L2_IIF_STORM_CONTROL_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_l2_iif_storm_control_info_t_fields[] = {
    {
        .name  = METER_L2_IIF_STORM_CONTROL_IDs,  /* METER_L2_IIF_STORM_CONTROL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the storm control meter info table.",
    },
    {
        .name  = PKT_QUANTUMs,  /* PKT_QUANTUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of refresh tokens consumed by each packet\n when the port is configured in packet mode i.e.\n METER_L2_IIF_STORM_CONTROL.BYTE_MODE == 0.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_l2_iif_storm_control_info_t = {
    .name = METER_L2_IIF_STORM_CONTROL_INFOs, /* METER_L2_IIF_STORM_CONTROL_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_meter_l2_iif_storm_control_info_t_fields,
    .desc = "The METER_L2_IIF_STORM_CONTROL_INFO table is used to\n provide information about storm control meters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_STORM_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_storm_control_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = METER_STORM_CONTROL_IDs,  /* METER_STORM_CONTROL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "STORM_CONTROL_METER index.\n",
    },
    {
        .name  = METER_RATE_KBPSs,  /* METER_RATE_KBPS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Metering rate in kbps.\n Valid only if METER_STORM_CONTROL_ENABLE.BYTE_MODE is enabled.\n",
    },
    {
        .name  = BURST_SIZE_KBITSs,  /* BURST_SIZE_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Burst size in kbits.\n Valid only if METER_STORM_CONTROL_ENABLE.BYTE_MODE is enabled.\n",
    },
    {
        .name  = METER_RATE_KBPS_OPERs,  /* METER_RATE_KBPS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational meter rate. This is a read-only field which\n reflects any modification to the configured METER_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields.\n Valid only if METER_STORM_CONTROL_ENABLE.BYTE_MODE is enabled.\n",
    },
    {
        .name  = BURST_SIZE_KBITS_OPERs,  /* BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational burst size. This is a read-only field.\n Valid only if METER_STORM_CONTROL_ENABLE.BYTE_MODE is enabled.\n",
    },
    {
        .name  = METER_RATE_PPSs,  /* METER_RATE_PPS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Metering rate in pps.\n Valid only if METER_STORM_CONTROL_ENABLE.BYTE_MODE is disabled.\n",
    },
    {
        .name  = BURST_SIZE_PKTSs,  /* BURST_SIZE_PKTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Burst size in packets.\n Valid only if METER_STORM_CONTROL_ENABLE.BYTE_MODE is disabled.\n",
    },
    {
        .name  = METER_RATE_PPS_OPERs,  /* METER_RATE_PPS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational meter rate. This is a read-only field which\n reflects any modification to the configured METER_RATE value\n as a function of REFRESHCOUNT and BUCKETSIZE fields.\n Valid only if METER_STORM_CONTROL_ENABLE.BYTE_MODE is disabled.\n",
    },
    {
        .name  = BURST_SIZE_PKTS_OPERs,  /* BURST_SIZE_PKTS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational burst size. This is a read-only field.\n Valid only if METER_STORM_CONTROL_ENABLE.BYTE_MODE is disabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_storm_control_t = {
    .name = METER_STORM_CONTROLs, /* METER_STORM_CONTROL */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_meter_storm_control_t_fields,
    .desc = "The METER_STORM_CONTROL table is used to\n configure the metering rate and burst size for\n each per-port storm control meter.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_STORM_CONTROL_ENABLE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_storm_control_enable_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = BYTE_MODEs,  /* BYTE_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable for byte mode metering. Disable for packet mode metering.",
    },
    {
        .name  = BCASTs,  /* BCAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable storm control metering for broadcast traffic.",
    },
    {
        .name  = KNOWN_L2MCs,  /* KNOWN_L2MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable storm control metering for known L2 multicast traffic.",
    },
    {
        .name  = UNKNOWN_L2MCs,  /* UNKNOWN_L2MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable storm control metering for unknown L2 multicast traffic.",
    },
    {
        .name  = KNOWN_IPMCs,  /* KNOWN_IPMC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable storm control metering for known IP multicast traffic.",
    },
    {
        .name  = UNKNOWN_IPMCs,  /* UNKNOWN_IPMC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable storm control metering for unknown IP multicast traffic.",
    },
    {
        .name  = DLFBCs,  /* DLFBC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable storm control metering for traffic with destination lookup failure.",
    },
};
const bcmltd_table_rep_t bcmltd_meter_storm_control_enable_t = {
    .name = METER_STORM_CONTROL_ENABLEs, /* METER_STORM_CONTROL_ENABLE */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_meter_storm_control_enable_t_fields,
    .desc = "The METER_STORM_CONTROL_ENABLE table is used to\n enable per-port metering for specific packet types.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_STORM_CONTROL_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_storm_control_info_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = PKT_QUANTUMs,  /* PKT_QUANTUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of refresh tokens consumed by each packet\n when the port is configured in packet mode i.e.\n METER_STORM_CONTROL_ENABLE.BYTE_MODE == 0.\n",
    },
};
const bcmltd_table_rep_t bcmltd_meter_storm_control_info_t = {
    .name = METER_STORM_CONTROL_INFOs, /* METER_STORM_CONTROL_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_meter_storm_control_info_t_fields,
    .desc = "The METER_STORM_CONTROL_INFO table is used to\n provide information about storm control meters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/meter/METER_STORM_CONTROL_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_meter_storm_control_map_t_fields[] = {
    {
        .name  = BCAST_METER_IDs,  /* BCAST_METER_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "METER_STORM_CONTROL_ID logical table index for broadcast packets",
    },
    {
        .name  = KNOWN_L2MC_METER_IDs,  /* KNOWN_L2MC_METER_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "METER_STORM_CONTROL_ID logical table index for known L2 multicast packets.",
    },
    {
        .name  = UNKNOWN_L2MC_METER_IDs,  /* UNKNOWN_L2MC_METER_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "METER_STORM_CONTROL_ID logical table index for unknown L2 multicast packets.",
    },
    {
        .name  = KNOWN_IPMC_METER_IDs,  /* KNOWN_IPMC_METER_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "METER_STORM_CONTROL_ID logical table index for known IP multicast packets.",
    },
    {
        .name  = UNKNOWN_IPMC_METER_IDs,  /* UNKNOWN_IPMC_METER_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "METER_STORM_CONTROL_ID logical table index for unknown IP multicast packets.",
    },
    {
        .name  = DLF_METER_IDs,  /* DLF_METER_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "METER_STORM_CONTROL_ID logical table index for destination lookup failure packets.",
    },
};
const bcmltd_table_rep_t bcmltd_meter_storm_control_map_t = {
    .name = METER_STORM_CONTROL_MAPs, /* METER_STORM_CONTROL_MAP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_meter_storm_control_map_t_fields,
    .desc = "The METER_STORM_CONTROL_MAP table is used to map\n packet type to meter index for storm control meters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_config_t_fields[] = {
    {
        .name  = SFLOW_ING_FLEX_OPERMODE_PIPEUNIQUEs,  /* SFLOW_ING_FLEX_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Ingres flex sFlow operating mode.\n Enable to specify pipe unique operating mode.\n Disable to specify global operating mode.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_config_t = {
    .name = MIRROR_CONFIGs, /* MIRROR_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 1,
    .field = bcmltd_mirror_config_t_fields,
    .desc = "The MIRROR_CONFIG table specifies the device-level\n mirror configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_CONTAINER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_container_t_fields[] = {
    {
        .name  = MIRROR_CONTAINER_IDs,  /* MIRROR_CONTAINER_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Index into the mirror container table.",
    },
    {
        .name  = EGRs,  /* EGR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that this is an egress mirror container.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_container_t = {
    .name = MIRROR_CONTAINERs, /* MIRROR_CONTAINER */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mirror_container_t_fields,
    .desc = "The MIRROR_CONTAINER logical table specifies\n mirror container configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_control_t_fields[] = {
    {
        .name  = SFLOW_ING_SEEDs,  /* SFLOW_ING_SEED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sampled flow (sFlow) ingress random number generation seed.",
    },
    {
        .name  = SFLOW_EGR_SEEDs,  /* SFLOW_EGR_SEED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Sampled flow (sFlow) egress random number generation seed.",
    },
    {
        .name  = SFLOW_ING_FLEX_SEEDs,  /* SFLOW_ING_FLEX_SEED */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Flex sampled flow (sFlow) ingress random number generation seed.",
    },
    {
        .name  = SFLOW_VERSIONs,  /* SFLOW_VERSION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Sampled flow (sFlow) version number.",
    },
    {
        .name  = SFLOW_ING_MIRRORs,  /* SFLOW_ING_MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable sampled flow (sFlow) ingress mirror per container. Array is\n indexed by container ID.\n",
    },
    {
        .name  = SFLOW_ING_MIRROR_INSTANCE_IDs,  /* SFLOW_ING_MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "Array of sampled flow (sFlow) ingress mirror instances per\n container.\n",
    },
    {
        .name  = SFLOW_EGR_CPU_COS_STRENGTHs,  /* SFLOW_EGR_CPU_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Strength of COS value for sFlow egress packets in the ingress\n pipeline. The following COS fields of sFlow egress packets will\n override those derived from TM_COS_Q_CPU_MAP\n if SFLOW_EGR_CPU_COS_STRENGTH is greater than\n TM_COS_Q_CPU_MAP.STRENGTH.\n",
    },
    {
        .name  = SFLOW_EGR_CPU_COSs,  /* SFLOW_EGR_CPU_COS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "COS value for sFlow egress packets from the ingress pipeline.",
    },
    {
        .name  = SFLOW_EGR_TRUNCATE_CPU_COPYs,  /* SFLOW_EGR_TRUNCATE_CPU_COPY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to truncate sFlow egress CPU copy.\n Disable to not truncate sFlow egress CPU copy.\n",
    },
    {
        .name  = SFLOW_EGR_CPU_Q_HI_PRIs,  /* SFLOW_EGR_CPU_Q_HI_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select high priority queue for sFlow egress packets.\n Disable to select low priority queue for sFlow egress packets.\n",
    },
    {
        .name  = PSAMP_IPFIX_VERSIONs,  /* PSAMP_IPFIX_VERSION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Packet sampling (PSAMP) IP flow information\n export (IPFIX) version number.\n",
    },
    {
        .name  = PSAMP_DLB_EPOCHs,  /* PSAMP_DLB_EPOCH */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "PSAMP epoch / revision number. Used in conjunction with DLB flow\n monitoring in order to allow reconciliation of the next-hop table\n by an external collector.\n",
    },
    {
        .name  = UC_PKT_MC_COS_OVERRIDEs,  /* UC_PKT_MC_COS_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to override the default multicast COS for mirror copies\n of unicast packets using the value specified in UC_PKT_MC_COS.\n",
    },
    {
        .name  = UC_PKT_MC_COSs,  /* UC_PKT_MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast COS value for mirrored unicast packets.\n Applicable only if UC_PKT_MC_COS_OVERRIDE is enabled.\n",
    },
    {
        .name  = MC_PKT_MC_COS_OVERRIDEs,  /* MC_PKT_MC_COS_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to override the default multicast COS for mirror copies\n of multicast packets using the value specified in MC_PKT_MC_COS.\n",
    },
    {
        .name  = MC_PKT_MC_COSs,  /* MC_PKT_MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast COS value for mirrored multicast packets.\n Applicable only if MC_PKT_MC_COS_OVERRIDE is enabled.\n",
    },
    {
        .name  = TM_CPU_COS_OVERRIDEs,  /* TM_CPU_COS_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to override the CPU COS value for mirror-to-CPU\n copies in the MMU using the value specified in TM_CPU_COS.\n",
    },
    {
        .name  = TM_CPU_COSs,  /* TM_CPU_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "CPU COS value for mirror-to-CPU packets in the MMU.\n Applicable only if TM_CPU_COS_OVERRIDE is enabled.\n",
    },
    {
        .name  = CPU_COS_STRENGTHs,  /* CPU_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Strength of COS value for mirror-to-CPU packets\n The following COS fields of mirror-to-CPU packets will\n override those derived from TM_COS_Q_CPU_MAP if CPU_COS_STRENGTH\n is greater than TM_COS_Q_CPU_MAP.STRENGTH.\n",
    },
    {
        .name  = CPU_COSs,  /* CPU_COS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "COS value for mirror-to-CPU packets.",
    },
    {
        .name  = TRUNCATE_CPU_COPYs,  /* TRUNCATE_CPU_COPY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to truncate mirror to CPU copy.\n Disable to not truncate mirror to CPU copy.\n",
    },
    {
        .name  = CPU_Q_HI_PRIs,  /* CPU_Q_HI_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select high priority queue for mirror-to-CPU packets.\n Disable to select low priority queue for mirror-to-CPU packets.\n",
    },
    {
        .name  = INVALID_VLAN_DROPs,  /* INVALID_VLAN_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the mirror instance member to drop packets\n with invalid VLAN.\n",
    },
    {
        .name  = SKIP_PKT_CHECKSs,  /* SKIP_PKT_CHECKS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip packet checks for mirror packets.",
    },
    {
        .name  = UNMARKEDs,  /* UNMARKED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to send mirror packets as simple unicast packets.",
    },
    {
        .name  = TRUNCATE_ACTIONs,  /* TRUNCATE_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Type of truncation (if any) of the non-encap mirrored packet.\n",
    },
    {
        .name  = MIRROR_TRUNCATE_LENGTH_IDs,  /* MIRROR_TRUNCATE_LENGTH_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into truncate length table.\n Applicable only if TRUNCATE_ACTION == TRUNCATE_ADJUST.\n",
    },
    {
        .name  = MIRROR_DUPLICATEs,  /* MIRROR_DUPLICATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow duplicate mirror packets with the\n same destination and encapsulation type.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_control_t = {
    .name = MIRROR_CONTROLs, /* MIRROR_CONTROL */
    .flags = 0,
    .fields = 28,
    .field = bcmltd_mirror_control_t_fields,
    .desc = "The MIRROR_CONTROL logical table specifies device level mirroring controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_DST_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_dst_ipv4_t_fields[] = {
    {
        .name  = MIRROR_DST_IPV4_IDs,  /* MIRROR_DST_IPV4_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index to the MIRROR_DST_IPV4 logical table.",
    },
    {
        .name  = IPV4s,  /* IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 2,
        .desc = "Destination IPv4 addresses.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_dst_ipv4_t = {
    .name = MIRROR_DST_IPV4s, /* MIRROR_DST_IPV4 */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mirror_dst_ipv4_t_fields,
    .desc = "The MIRROR_DST_IPV4 logical table specifies the IPv4 addresses used for\n multiple mirror destinations.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_DST_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_dst_ipv6_t_fields[] = {
    {
        .name  = MIRROR_DST_IPV6_IDs,  /* MIRROR_DST_IPV6_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index to the MIRROR_DST_IPV6 logical table.",
    },
    {
        .name  = IPV6s,  /* IPV6 */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Lower or upper 64 bits of the destination IPv6 address. For even\n values of MIRROR_DST_IPV6_ID, this field represents the lower 64 bits\n of MIRROR_DST_IPV6_ID. For odd values of MIRROR_DST_IPV6_ID, this\n field represents the upper 64 bits of the IPv6 address.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_dst_ipv6_t = {
    .name = MIRROR_DST_IPV6s, /* MIRROR_DST_IPV6 */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mirror_dst_ipv6_t_fields,
    .desc = "The MIRROR_DST_IPV6 logical table specifies the IPv6 addresses used for\n multiple mirror destinations.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_EGR_INSTANCE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_egr_instance_t_fields[] = {
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MIRROR_EGR_INSTANCE table.",
    },
    {
        .name  = IS_TRUNKs,  /* IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate destination is a trunk.",
    },
    {
        .name  = HASHs,  /* HASH */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Trunk hash control. Applicable only if IS_TRUNK is enabled.",
    },
    {
        .name  = MEMBER_CNTs,  /* MEMBER_CNT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of mirror destination ports.\n Set the field to 1 for non-trunk ports.\n",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "Destination module ID. Index 0 in the array is used\n for non-trunk ports.\n",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 8,
        .desc = "Destination port ID. Index 0 in the array is used\n for non-trunk ports.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_egr_instance_t = {
    .name = MIRROR_EGR_INSTANCEs, /* MIRROR_EGR_INSTANCE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_mirror_egr_instance_t_fields,
    .desc = "The MIRROR_EGR_INSTANCE table specifies\n the egress mirror destination index for trunk and non-trunk ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_EGR_MEMBER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_egr_member_t_fields[] = {
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Mirror instance to compute index into MIRROR_EGR_INSTANCE table.",
    },
    {
        .name  = MIRROR_MEMBER_IDs,  /* MIRROR_MEMBER_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Trunk member to compute index into the MIRROR_EGR_MEMBER table.",
    },
    {
        .name  = REPLACE_INT_PRIs,  /* REPLACE_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to change the internal priority of the mirrored packet.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Internal priority. Applicable only if REPLACE_INT_PRI is enabled.",
    },
    {
        .name  = ENCAPs,  /* ENCAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate the mirrored packet.",
    },
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MIRROR_ENCAP table index. Applicable only if ENCAP is enabled.",
    },
    {
        .name  = TRUNCATEs,  /* TRUNCATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to truncate the mirror copy to 1 cell.",
    },
    {
        .name  = TRUNCATE_ACTIONs,  /* TRUNCATE_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Type of truncation (if any) of the mirrored packet.",
    },
    {
        .name  = TIMESTAMP_MODEs,  /* TIMESTAMP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TIMESTAMP_MODE_T_DATA,
        .desc = "Timestamp mode for mirror encapsulation.",
    },
    {
        .name  = MULTIPLE_MIRROR_DSTs,  /* MULTIPLE_MIRROR_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mirroring to multiple destinations.",
    },
    {
        .name  = MIRROR_DST_IP_IDs,  /* MIRROR_DST_IP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MIRROR_DST_IPV4 or MIRROR_DST_IPV6 logical table index. Applicable\n when MULTIPLE_MIRROR_DST is enabled. MIRROR_ENCAP_ID represents an\n IPv4 or IPv6 mirror encapsulation, which decides if a MIRROR_DST_IPV4\n or MIRROR_DST_IPV6 index should be used.\n",
    },
    {
        .name  = NUM_IP_ENTRYs,  /* NUM_IP_ENTRY */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries occupied by a group of IPv4 or IPv6 addresses in\n MIRROR_DST_IPV4 or MIRROR_DST_IPV6. Applicable when\n MULTIPLE_MIRROR_DST is enabled.\n",
    },
    {
        .name  = IPV4_INDEXs,  /* IPV4_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index of the selected destination IPv4 address in the\n MIRROR_DST_IPV4.IPV4 array. Applicable when MULTIPLE_MIRROR_DST\n is enabled.\n",
    },
    {
        .name  = OVERLAY_NHOPs,  /* OVERLAY_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to overlay next hop, otherwise underlay next hop.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_egr_member_t = {
    .name = MIRROR_EGR_MEMBERs, /* MIRROR_EGR_MEMBER */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_mirror_egr_member_t_fields,
    .desc = "The MIRROR_EGR_MEMBER logical table specifies\n the egress mirror destination member configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_EGR_SEQ.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_egr_seq_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into encapsulation table.",
    },
    {
        .name  = SEQs,  /* SEQ */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to generate sequence number.",
    },
    {
        .name  = TNL_ENCAP_SEQUENCE_NUMBER_IDs,  /* TNL_ENCAP_SEQUENCE_NUMBER_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_ENCAP_SEQUENCE_NUMBER table index.",
    },
    {
        .name  = TNL_ENCAP_SEQUENCE_PROFILE_IDs,  /* TNL_ENCAP_SEQUENCE_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TNL_ENCAP_SEQUENCE_PROFILE table index.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_egr_seq_t = {
    .name = MIRROR_EGR_SEQs, /* MIRROR_EGR_SEQ */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_mirror_egr_seq_t_fields,
    .desc = "The MIRROR_EGR_SEQ logical table specifies\n sequence number generation configuration for\n cases such as Egress Mirroring where a sequence\n number is required for a header that is being added\n as part of a mirror encapsulation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_EGR_ZERO_PAYLOAD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_egr_zero_payload_t_fields[] = {
    {
        .name  = IP_PROTOCOLs,  /* IP_PROTOCOL */
        .flags = 0,
        .width = 8,
        .depth = 3,
        .desc = "If the IPv4 protocol type is identical to IP_PROTOCOL[x],\n then use IP_PROTOCOL_OFFSET[x] as the offset from the end of the\n header to start zeroing.\n",
    },
    {
        .name  = IP_PROTOCOL_OFFSETs,  /* IP_PROTOCOL_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 3,
        .desc = "Offset (in bytes) corresponding to the associated IP_PROTOCOL.",
    },
    {
        .name  = IPV6_NEXT_HEADERs,  /* IPV6_NEXT_HEADER */
        .flags = 0,
        .width = 8,
        .depth = 3,
        .desc = "If the IPv6 next header is identical to IPV6_NEXT_HEADER[x],\n then use IPV6_NEXT_HEADER_OFFSET[x] as the offset from the end of the\n header to start zeroing.\n",
    },
    {
        .name  = IPV6_NEXT_HEADER_OFFSETs,  /* IPV6_NEXT_HEADER_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 3,
        .desc = "Offset (in bytes) corresponding to the associated\n IPV6_NEXT_HEADER.\n",
    },
    {
        .name  = DST_L4_PORTs,  /* DST_L4_PORT */
        .flags = 0,
        .width = 16,
        .depth = 2,
        .desc = "If the IPv4/IPv6 UDP destination port is identical to\n DST_L4_PORT[x], then use DST_L4_PORT_OFFSET[x] as the offset from\n the end of the header to start zeroing.\n",
    },
    {
        .name  = DST_L4_PORT_OFFSETs,  /* DST_L4_PORT_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 2,
        .desc = "Offset (in bytes) corresponding to the associated DST_L4_PORT.",
    },
    {
        .name  = IP_IN_IP_OFFSETs,  /* IP_IN_IP_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The offset from the end of the IP in IP header to start zeroing.",
    },
    {
        .name  = L2_OFFSETs,  /* L2_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The offset from the end of the layer 2 header to start zeroing.",
    },
    {
        .name  = L3_OFFSETs,  /* L3_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The offset from the end of the layer 3 header to start zeroing.",
    },
    {
        .name  = MPLS_OFFSETs,  /* MPLS_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The offset from the end of the multiple protocol label switching\n (MPLS) labels to start zeroing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_egr_zero_payload_t = {
    .name = MIRROR_EGR_ZERO_PAYLOADs, /* MIRROR_EGR_ZERO_PAYLOAD */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_mirror_egr_zero_payload_t_fields,
    .desc = "The MIRROR_EGR_ZERO_PAYLOAD logical table specifies\n device level payload wiping configuration for zeroing out\n packet payloads.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_EGR_ZERO_PAYLOAD_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_egr_zero_payload_profile_t_fields[] = {
    {
        .name  = MIRROR_EGR_ZERO_PAYLOAD_PROFILE_IDs,  /* MIRROR_EGR_ZERO_PAYLOAD_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the FP based payload wiping profile table.",
    },
    {
        .name  = L2_OFFSETs,  /* L2_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset (in 2 bytes) from the end of the layer 2 header to start\n zeroing.\n",
    },
    {
        .name  = SKIP_L2_OFFSETs,  /* SKIP_L2_OFFSET */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip the offset for zeroing payloads of layer 2 packets.\n",
    },
    {
        .name  = L3_NON_UDP_OFFSETs,  /* L3_NON_UDP_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset (in 2 bytes) from the end of the layer 3 header to\n start zeroing for non-UDP packets.\n",
    },
    {
        .name  = SKIP_L3_NON_UDP_OFFSETs,  /* SKIP_L3_NON_UDP_OFFSET */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip the offset for zeroing payloads of layer 3 packets\n with non-UDP header.\n",
    },
    {
        .name  = L3_UDP_OFFSETs,  /* L3_UDP_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Offset (in 2 bytes) from the end of the layer 3 header to start\n zeroing for UDP packets.\n",
    },
    {
        .name  = SKIP_L3_UDP_OFFSETs,  /* SKIP_L3_UDP_OFFSET */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip the offset for zeroing payloads of layer 3 packets\n with UDP header.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_egr_zero_payload_profile_t = {
    .name = MIRROR_EGR_ZERO_PAYLOAD_PROFILEs, /* MIRROR_EGR_ZERO_PAYLOAD_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_mirror_egr_zero_payload_profile_t_fields,
    .desc = "The MIRROR_EGR_ZERO_PAYLOAD_PROFILE logical table specifies\n field processor (FP) based payload wiping profiles for zeroing out packet\n payloads.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_BASIC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_basic_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the basic encapsulation table.",
    },
    {
        .name  = ENCAP_MODEs,  /* ENCAP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Encapsulation mode.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_basic_t = {
    .name = MIRROR_ENCAP_BASICs, /* MIRROR_ENCAP_BASIC */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mirror_encap_basic_t_fields,
    .desc = "The MIRROR_ENCAP_BASIC logical table specifies basic encapsulation\n configuration, like non encap mirroring and In-band Flow Analyzer 2.0\n (IFA 2.0) to loopback port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_ERSPAN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_erspan_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror ERSPAN encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 type of service.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 time to live.",
    },
    {
        .name  = PROTOs,  /* PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 protocol type.",
    },
    {
        .name  = DO_NOT_FRAGMENTs,  /* DO_NOT_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IPv4 don't fragment flag.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = GRE_HEADERs,  /* GRE_HEADER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "GRE header.\n 0x88BE for GRE protocol type 2.\n 0x22EB for GRE protocol type 3.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_PDU_FRAMEs,  /* ERSPAN3_SUB_HDR_PDU_FRAME */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_FRAME_TYPEs,  /* ERSPAN3_SUB_HDR_FRAME_TYPE */
        .flags = 0,
        .width = 5,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_HW_IDs,  /* ERSPAN3_SUB_HDR_HW_ID */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_DIRECTIONs,  /* ERSPAN3_SUB_HDR_DIRECTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_TS_GRAs,  /* ERSPAN3_SUB_HDR_TS_GRA */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_OPT_SUB_HDRs,  /* ERSPAN3_SUB_HDR_OPT_SUB_HDR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = SESSION_IDs,  /* SESSION_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Session ID.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = SWITCH_IDs,  /* SWITCH_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Switch ID.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = SEQs,  /* SEQ */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with sequence number.",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_erspan_t = {
    .name = MIRROR_ENCAP_ERSPANs, /* MIRROR_ENCAP_ERSPAN */
    .flags = 0,
    .fields = 29,
    .field = bcmltd_mirror_encap_erspan_t_fields,
    .desc = "The MIRROR_ENCAP_ERSPAN logical table specifies encapsulated\n remote switched port analyzer (ERSPAN) encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_ERSPAN_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_erspan_ipv6_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror IPv6 ERSPAN encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = TRAFFIC_CLASSs,  /* TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 traffic class.",
    },
    {
        .name  = HOP_LIMITs,  /* HOP_LIMIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 hop limit.",
    },
    {
        .name  = NEXT_HEADERs,  /* NEXT_HEADER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 next header.",
    },
    {
        .name  = FLOW_LABELs,  /* FLOW_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "IPv6 flow label.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = GRE_HEADERs,  /* GRE_HEADER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "GRE header.\n 0x88BE for GRE protocol type 2.\n 0x22EB for GRE protocol type 3.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_PDU_FRAMEs,  /* ERSPAN3_SUB_HDR_PDU_FRAME */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_FRAME_TYPEs,  /* ERSPAN3_SUB_HDR_FRAME_TYPE */
        .flags = 0,
        .width = 5,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_HW_IDs,  /* ERSPAN3_SUB_HDR_HW_ID */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_DIRECTIONs,  /* ERSPAN3_SUB_HDR_DIRECTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_TS_GRAs,  /* ERSPAN3_SUB_HDR_TS_GRA */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = ERSPAN3_SUB_HDR_OPT_SUB_HDRs,  /* ERSPAN3_SUB_HDR_OPT_SUB_HDR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "16-bit sub-header of ERSPAN type 3, which is constructed by\n PDU frame, frame type, hardware ID, direction, timestamp granularity\n and optional sub-header.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = SESSION_IDs,  /* SESSION_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Session ID.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = SWITCH_IDs,  /* SWITCH_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Switch ID.\n Applicable only if GRE_HEADER == 0x22EB.\n",
    },
    {
        .name  = SEQs,  /* SEQ */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with sequence number.",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_erspan_ipv6_t = {
    .name = MIRROR_ENCAP_ERSPAN_IPV6s, /* MIRROR_ENCAP_ERSPAN_IPV6 */
    .flags = 0,
    .fields = 31,
    .field = bcmltd_mirror_encap_erspan_ipv6_t_fields,
    .desc = "The MIRROR_ENCAP_ERSPAN_IPV6 logical table specifies IPv6 encapsulated\n remote switched port analyzer (ERSPAN) encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_IFA_1_PROBE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_ifa_1_probe_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the IFA_1_PROBE encapsulation table.",
    },
    {
        .name  = PROBE_MARKER_1s,  /* PROBE_MARKER_1 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Probe marker 1.",
    },
    {
        .name  = PROBE_MARKER_2s,  /* PROBE_MARKER_2 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Probe marker 2.",
    },
    {
        .name  = VERSIONs,  /* VERSION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Version.",
    },
    {
        .name  = MSG_TYPEs,  /* MSG_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Message type.",
    },
    {
        .name  = REQUEST_VECTORs,  /* REQUEST_VECTOR */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Telemetry request vector.",
    },
    {
        .name  = ACTION_VECTORs,  /* ACTION_VECTOR */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Telemetry action vector.",
    },
    {
        .name  = HOP_LIMITs,  /* HOP_LIMIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hop limit.",
    },
    {
        .name  = MAX_LENGTHs,  /* MAX_LENGTH */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum length.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_ifa_1_probe_t = {
    .name = MIRROR_ENCAP_IFA_1_PROBEs, /* MIRROR_ENCAP_IFA_1_PROBE */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_mirror_encap_ifa_1_probe_t_fields,
    .desc = "The MIRROR_ENCAP_IFA_1_PROBE logical table specifies\n In-band Flow Analyzer (IFA) 1.0 encapsulation to the loopback port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_INSTANCE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_instance_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the encapsulation table.",
    },
    {
        .name  = EGRs,  /* EGR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that this is an egress mirror encap instance.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_instance_t = {
    .name = MIRROR_ENCAP_INSTANCEs, /* MIRROR_ENCAP_INSTANCE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mirror_encap_instance_t_fields,
    .desc = "The MIRROR_ENCAP_INSTANCE logical table specifies\n mirror encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_INSTANCE_ATTR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_instance_attr_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the encapsulation attributes table.",
    },
    {
        .name  = TRUNCATEs,  /* TRUNCATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to truncate the mirror copy.",
    },
    {
        .name  = TRUNCATE_ACTIONs,  /* TRUNCATE_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Type of truncation (if any) of the encap mirrored packet.\n Applicable only if TRUNCATE is enabled.\n",
    },
    {
        .name  = MIRROR_TRUNCATE_LENGTH_IDs,  /* MIRROR_TRUNCATE_LENGTH_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into truncate length table.\n Applicable only if TRUNCATE_ACTION == TRUNCATE_ADJUST.\n",
    },
    {
        .name  = SYSTEM_PORT_TABLE_IDs,  /* SYSTEM_PORT_TABLE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination system port ID.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_instance_attr_t = {
    .name = MIRROR_ENCAP_INSTANCE_ATTRs, /* MIRROR_ENCAP_INSTANCE_ATTR */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_mirror_encap_instance_attr_t_fields,
    .desc = "The MIRROR_ENCAP_INSTANCE_ATTR logical table specifies\n mirror encapsulation attributes configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_MIRROR_ON_DROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_mirror_on_drop_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror-on-drop encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 type of service.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 time to live.",
    },
    {
        .name  = PROTOs,  /* PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 protocol type.",
    },
    {
        .name  = DO_NOT_FRAGMENTs,  /* DO_NOT_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IPv4 don't fragment flag.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = INITIAL_SEQ_NUMs,  /* INITIAL_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Starting sequence number in mirror-on-drop header.",
    },
    {
        .name  = OBSERVATION_DOMAINs,  /* OBSERVATION_DOMAIN */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Observation domain for IP flow information export (IPFIX)\n header.\n",
    },
    {
        .name  = TEMPLATE_IDENTIFIERs,  /* TEMPLATE_IDENTIFIER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Template identifier for IPFIX header.",
    },
    {
        .name  = METADATA_TYPEs,  /* METADATA_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the type of metadata.",
    },
    {
        .name  = METADATAs,  /* METADATA */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Encapsulation header metadata.\n Applicable only if METADATA_TYPE == TABLE_METADATA.\n",
    },
    {
        .name  = IPFIX_VERSIONs,  /* IPFIX_VERSION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Packet sampling (PSAMP) IP flow information\n export (IPFIX) version number.\n",
    },
    {
        .name  = SWITCH_IDs,  /* SWITCH_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Switch ID.",
    },
    {
        .name  = VARIABLE_FLAGs,  /* VARIABLE_FLAG */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Variable flag.",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mirror-on-drop mode.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_mirror_on_drop_t = {
    .name = MIRROR_ENCAP_MIRROR_ON_DROPs, /* MIRROR_ENCAP_MIRROR_ON_DROP */
    .flags = 0,
    .fields = 30,
    .field = bcmltd_mirror_encap_mirror_on_drop_t_fields,
    .desc = "The MIRROR_ENCAP_MIRROR_ON_DROP logical table specifies\n mirror-on-drop encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_MIRROR_ON_DROP_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_mirror_on_drop_ipv6_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the IPv6 mirror-on-drop encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = TRAFFIC_CLASSs,  /* TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 traffic class.",
    },
    {
        .name  = HOP_LIMITs,  /* HOP_LIMIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 hop limit.",
    },
    {
        .name  = NEXT_HEADERs,  /* NEXT_HEADER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 next header.",
    },
    {
        .name  = FLOW_LABELs,  /* FLOW_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "IPv6 flow label.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = INITIAL_SEQ_NUMs,  /* INITIAL_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Starting sequence number in mirror-on-drop header.",
    },
    {
        .name  = OBSERVATION_DOMAINs,  /* OBSERVATION_DOMAIN */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Observation domain for IP flow information export (IPFIX)\n header.\n",
    },
    {
        .name  = TEMPLATE_IDENTIFIERs,  /* TEMPLATE_IDENTIFIER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Template identifier for IPFIX header.",
    },
    {
        .name  = METADATA_TYPEs,  /* METADATA_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the type of metadata.",
    },
    {
        .name  = METADATAs,  /* METADATA */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Encapsulation header metadata.\n Applicable only if METADATA_TYPE == TABLE_METADATA.\n",
    },
    {
        .name  = IPFIX_VERSIONs,  /* IPFIX_VERSION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Packet sampling (PSAMP) IP flow information\n export (IPFIX) version number.\n",
    },
    {
        .name  = SWITCH_IDs,  /* SWITCH_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Switch ID.",
    },
    {
        .name  = VARIABLE_FLAGs,  /* VARIABLE_FLAG */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Variable flag.",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mirror-on-drop mode.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_mirror_on_drop_ipv6_t = {
    .name = MIRROR_ENCAP_MIRROR_ON_DROP_IPV6s, /* MIRROR_ENCAP_MIRROR_ON_DROP_IPV6 */
    .flags = 0,
    .fields = 32,
    .field = bcmltd_mirror_encap_mirror_on_drop_ipv6_t_fields,
    .desc = "The MIRROR_ENCAP_MIRROR_ON_DROP_IPV6 logical table specifies\n IPv6 mirror-on-drop encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_PSAMP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_psamp_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror PSAMP encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 type of service.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 time to live.",
    },
    {
        .name  = PROTOs,  /* PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 protocol type.",
    },
    {
        .name  = DO_NOT_FRAGMENTs,  /* DO_NOT_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IPv4 don't fragment flag.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = INITIAL_SEQ_NUMs,  /* INITIAL_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Starting sequence number in PSAMP header.",
    },
    {
        .name  = OBSERVATION_DOMAINs,  /* OBSERVATION_DOMAIN */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Observation domain for IP flow information export (IPFIX)\n header.\n",
    },
    {
        .name  = TEMPLATE_IDENTIFIERs,  /* TEMPLATE_IDENTIFIER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Template identifier for IPFIX header.",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_psamp_t = {
    .name = MIRROR_ENCAP_PSAMPs, /* MIRROR_ENCAP_PSAMP */
    .flags = 0,
    .fields = 24,
    .field = bcmltd_mirror_encap_psamp_t_fields,
    .desc = "The MIRROR_ENCAP_PSAMP logical table specifies\n packet sampling (PSAMP) encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_PSAMP_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_psamp_ipv6_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror IPv6 PSAMP encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = TRAFFIC_CLASSs,  /* TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 traffic class.",
    },
    {
        .name  = HOP_LIMITs,  /* HOP_LIMIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 hop limit.",
    },
    {
        .name  = NEXT_HEADERs,  /* NEXT_HEADER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 next header.",
    },
    {
        .name  = FLOW_LABELs,  /* FLOW_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "IPv6 flow label.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = INITIAL_SEQ_NUMs,  /* INITIAL_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Starting sequence number in PSAMP header.",
    },
    {
        .name  = OBSERVATION_DOMAINs,  /* OBSERVATION_DOMAIN */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Observation domain for IP flow information export (IPFIX)\n header.\n",
    },
    {
        .name  = TEMPLATE_IDENTIFIERs,  /* TEMPLATE_IDENTIFIER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Template identifier for IPFIX header.",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_psamp_ipv6_t = {
    .name = MIRROR_ENCAP_PSAMP_IPV6s, /* MIRROR_ENCAP_PSAMP_IPV6 */
    .flags = 0,
    .fields = 26,
    .field = bcmltd_mirror_encap_psamp_ipv6_t_fields,
    .desc = "The MIRROR_ENCAP_PSAMP_IPV6 logical table specifies\n IPv6 packet sampling (PSAMP) encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_PSAMP_METADATA.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_psamp_metadata_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror PSAMP with metadata encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 type of service.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 time to live.",
    },
    {
        .name  = PROTOs,  /* PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 protocol type.",
    },
    {
        .name  = DO_NOT_FRAGMENTs,  /* DO_NOT_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IPv4 don't fragment flag.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4      UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = INITIAL_SEQ_NUMs,  /* INITIAL_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Starting sequence number in PSAMP header.",
    },
    {
        .name  = OBSERVATION_DOMAINs,  /* OBSERVATION_DOMAIN */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Observation domain for IP flow information export (IPFIX)\n header.\n",
    },
    {
        .name  = TEMPLATE_IDENTIFIERs,  /* TEMPLATE_IDENTIFIER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Template identifier for IPFIX header.",
    },
    {
        .name  = METADATA_TYPEs,  /* METADATA_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the type of metadata.",
    },
    {
        .name  = METADATAs,  /* METADATA */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Encapsulation header metadata.\n Applicable only if METADATA_TYPE == TABLE_METADATA.\n",
    },
    {
        .name  = IPFIX_VERSIONs,  /* IPFIX_VERSION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Packet sampling (PSAMP) IP flow information\n export (IPFIX) version number.\n",
    },
    {
        .name  = PSAMP_EPOCHs,  /* PSAMP_EPOCH */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Packet sampling (PSAMP) epoch / revision number.\n",
    },
    {
        .name  = VARIABLE_FLAGs,  /* VARIABLE_FLAG */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Variable flag (default to 0xFF).",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_psamp_metadata_t = {
    .name = MIRROR_ENCAP_PSAMP_METADATAs, /* MIRROR_ENCAP_PSAMP_METADATA */
    .flags = 0,
    .fields = 29,
    .field = bcmltd_mirror_encap_psamp_metadata_t_fields,
    .desc = "The MIRROR_ENCAP_PSAMP_METADATA logical table specifies\n packet sampling (PSAMP) encapsulation configuration and provides for\n additional encapsulation metadata such as class ID.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_PSAMP_METADATA_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_psamp_metadata_ipv6_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror IPv6 PSAMP with metadata encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = TRAFFIC_CLASSs,  /* TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 traffic class.",
    },
    {
        .name  = HOP_LIMITs,  /* HOP_LIMIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 hop limit.",
    },
    {
        .name  = NEXT_HEADERs,  /* NEXT_HEADER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 next header.",
    },
    {
        .name  = FLOW_LABELs,  /* FLOW_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "IPv6 flow label.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = INITIAL_SEQ_NUMs,  /* INITIAL_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Starting sequence number in PSAMP header.",
    },
    {
        .name  = OBSERVATION_DOMAINs,  /* OBSERVATION_DOMAIN */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Observation domain for IP flow information export (IPFIX)\n header.\n",
    },
    {
        .name  = TEMPLATE_IDENTIFIERs,  /* TEMPLATE_IDENTIFIER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Template identifier for IPFIX header.",
    },
    {
        .name  = METADATA_TYPEs,  /* METADATA_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the type of metadata.",
    },
    {
        .name  = METADATAs,  /* METADATA */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Encapsulation header metadata.\n Applicable only if METADATA_TYPE == TABLE_METADATA.\n",
    },
    {
        .name  = IPFIX_VERSIONs,  /* IPFIX_VERSION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Packet sampling (PSAMP) IP flow information\n export (IPFIX) version number.\n",
    },
    {
        .name  = PSAMP_EPOCHs,  /* PSAMP_EPOCH */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Packet sampling (PSAMP) epoch / revision number.\n",
    },
    {
        .name  = VARIABLE_FLAGs,  /* VARIABLE_FLAG */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Variable flag (default to 0xFF).",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_psamp_metadata_ipv6_t = {
    .name = MIRROR_ENCAP_PSAMP_METADATA_IPV6s, /* MIRROR_ENCAP_PSAMP_METADATA_IPV6 */
    .flags = 0,
    .fields = 31,
    .field = bcmltd_mirror_encap_psamp_metadata_ipv6_t_fields,
    .desc = "The MIRROR_ENCAP_PSAMP_METADATA_IPV6 logical table specifies\n IPv6 packet sampling (PSAMP) encapsulation configuration and provides for\n additional encapsulation metadata such as class ID.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_RSPAN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_rspan_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror RSPAN encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the mirrored packet.",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID to insert into the mirrored packet.",
    },
    {
        .name  = VNTAGs,  /* VNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add Virtual Network Tag (VN-Tag) in Network Interface\n Virtualization (NIV) mirror tunneling.\n",
    },
    {
        .name  = SRC_NIV_VIFs,  /* SRC_NIV_VIF */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source virtual interface of NIV tag.\n Applicable only if VNTAG is enabled.\n",
    },
    {
        .name  = DST_NIV_VIFs,  /* DST_NIV_VIF */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination virtual interface of NIV tag.\n Applicable only if VNTAG is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_rspan_t = {
    .name = MIRROR_ENCAP_RSPANs, /* MIRROR_ENCAP_RSPAN */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_mirror_encap_rspan_t_fields,
    .desc = "The MIRROR_ENCAP_RSPAN logical table specifies\n remote switch port analyzer (RSPAN) encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_SFLOW.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_sflow_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror sFlow encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 type of service.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 time to live.",
    },
    {
        .name  = PROTOs,  /* PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 protocol type.",
    },
    {
        .name  = DO_NOT_FRAGMENTs,  /* DO_NOT_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IPv4 don't fragment flag.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_sflow_t = {
    .name = MIRROR_ENCAP_SFLOWs, /* MIRROR_ENCAP_SFLOW */
    .flags = 0,
    .fields = 21,
    .field = bcmltd_mirror_encap_sflow_t_fields,
    .desc = "The MIRROR_ENCAP_SFLOW logical table specifies\n sampled flow (sFlow) encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_SFLOW_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_sflow_ipv6_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror IPv6 sFlow encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = TRAFFIC_CLASSs,  /* TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 traffic class.",
    },
    {
        .name  = HOP_LIMITs,  /* HOP_LIMIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 hop limit.",
    },
    {
        .name  = NEXT_HEADERs,  /* NEXT_HEADER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 next header.",
    },
    {
        .name  = FLOW_LABELs,  /* FLOW_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "IPv6 flow label.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_sflow_ipv6_t = {
    .name = MIRROR_ENCAP_SFLOW_IPV6s, /* MIRROR_ENCAP_SFLOW_IPV6 */
    .flags = 0,
    .fields = 23,
    .field = bcmltd_mirror_encap_sflow_ipv6_t_fields,
    .desc = "The MIRROR_ENCAP_SFLOW_IPV6 logical table specifies\n IPv6 sampled flow (sFlow) encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_SFLOW_SEQ.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_sflow_seq_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror sFlow encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 type of service.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 time to live.",
    },
    {
        .name  = PROTOs,  /* PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 protocol type.",
    },
    {
        .name  = DO_NOT_FRAGMENTs,  /* DO_NOT_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IPv4 don't fragment flag.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = INITIAL_SEQ_NUMs,  /* INITIAL_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Starting sequence number in sFlow header.",
    },
    {
        .name  = METADATA_TYPEs,  /* METADATA_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the type of metadata.",
    },
    {
        .name  = METADATAs,  /* METADATA */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Encapsulation header metadata.\n Applicable only if METADATA_TYPE == TABLE_METADATA.\n",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_sflow_seq_t = {
    .name = MIRROR_ENCAP_SFLOW_SEQs, /* MIRROR_ENCAP_SFLOW_SEQ */
    .flags = 0,
    .fields = 24,
    .field = bcmltd_mirror_encap_sflow_seq_t_fields,
    .desc = "The MIRROR_ENCAP_SFLOW_SEQ logical table specifies\n sampled flow (sFlow) encapsulation configuration for\n sFlow headers containing sequence numbers.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_SFLOW_SEQ_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_sflow_seq_ipv6_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror IPv6 sFlow encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = TRAFFIC_CLASSs,  /* TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 traffic class.",
    },
    {
        .name  = HOP_LIMITs,  /* HOP_LIMIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 hop limit.",
    },
    {
        .name  = NEXT_HEADERs,  /* NEXT_HEADER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 next header.",
    },
    {
        .name  = FLOW_LABELs,  /* FLOW_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "IPv6 flow label.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = INITIAL_SEQ_NUMs,  /* INITIAL_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Starting sequence number in sFlow header.",
    },
    {
        .name  = METADATA_TYPEs,  /* METADATA_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the type of metadata.",
    },
    {
        .name  = METADATAs,  /* METADATA */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Encapsulation header metadata.\n Applicable only if METADATA_TYPE == TABLE_METADATA.\n",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_sflow_seq_ipv6_t = {
    .name = MIRROR_ENCAP_SFLOW_SEQ_IPV6s, /* MIRROR_ENCAP_SFLOW_SEQ_IPV6 */
    .flags = 0,
    .fields = 26,
    .field = bcmltd_mirror_encap_sflow_seq_ipv6_t_fields,
    .desc = "The MIRROR_ENCAP_SFLOW_SEQ_IPV6 logical table specifies\n IPv6 sampled flow (sFlow) encapsulation configuration for\n sFlow headers containing sequence numbers.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_VXLAN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_vxlan_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror VXLAN encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 type of service.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 time to live.",
    },
    {
        .name  = PROTOs,  /* PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 protocol type.",
    },
    {
        .name  = DO_NOT_FRAGMENTs,  /* DO_NOT_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "IPv4 don't fragment flag.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VXLAN_TYPEs,  /* VXLAN_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the type of VXLAN header.",
    },
    {
        .name  = VXLAN_VNIDs,  /* VXLAN_VNID */
        .flags = 0,
        .width = 24,
        .depth = 0,
        .desc = "Encapsulation VNID in VXLAN packet Header.\n Applicable only if VXLAN_TYPE == TABLE_VXLAN.\n",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_vxlan_t = {
    .name = MIRROR_ENCAP_VXLANs, /* MIRROR_ENCAP_VXLAN */
    .flags = 0,
    .fields = 23,
    .field = bcmltd_mirror_encap_vxlan_t_fields,
    .desc = "The MIRROR_ENCAP_VXLAN logical table specifies\n Virtual eXtensible Local Area Network (VXLAN) encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ENCAP_VXLAN_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_encap_vxlan_ipv6_t_fields[] = {
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror IPv6 VXLAN encapsulation table.",
    },
    {
        .name  = UNTAGs,  /* UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the outer VLAN tag from the mirrored packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = TRAFFIC_CLASSs,  /* TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 traffic class.",
    },
    {
        .name  = HOP_LIMITs,  /* HOP_LIMIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 hop limit.",
    },
    {
        .name  = NEXT_HEADERs,  /* NEXT_HEADER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 next header.",
    },
    {
        .name  = FLOW_LABELs,  /* FLOW_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "IPv6 flow label.",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP destination port.",
    },
    {
        .name  = L4_SRC_PORTs,  /* L4_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer-4 UDP source port.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype.",
    },
    {
        .name  = OUTER_VLANs,  /* OUTER_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add an outer VLAN tag into the encapsulation header.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID to insert into the encapsulation header.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag.\n Applicable only if OUTER_VLAN is enabled.\n",
    },
    {
        .name  = VXLAN_TYPEs,  /* VXLAN_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the type of VXLAN header.",
    },
    {
        .name  = VXLAN_VNIDs,  /* VXLAN_VNID */
        .flags = 0,
        .width = 24,
        .depth = 0,
        .desc = "Encapsulation VNID in VXLAN packet Header.\n Applicable only if VXLAN_TYPE == TABLE_VXLAN.\n",
    },
    {
        .name  = HIGIG3s,  /* HIGIG3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate with HiGig3 base header.",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "HiGig3 - Ethertype.\n Applicable only if HIGIG3 is enabled.\n",
    },
    {
        .name  = HIGIG3_BASE_HDRs,  /* HIGIG3_BASE_HDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "HiGig3 - Base Header.\n Applicable only if HIGIG3 is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_encap_vxlan_ipv6_t = {
    .name = MIRROR_ENCAP_VXLAN_IPV6s, /* MIRROR_ENCAP_VXLAN_IPV6 */
    .flags = 0,
    .fields = 25,
    .field = bcmltd_mirror_encap_vxlan_ipv6_t_fields,
    .desc = "The MIRROR_ENCAP_VXLAN_IPV6 logical table specifies\n IPv6 Virtual eXtensible Local Area Network (VXLAN) encapsulation\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ING_EVENT_CONTAINER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_ing_event_container_t_fields[] = {
    {
        .name  = MIRROR_ING_EVENT_CONTAINER_IDs,  /* MIRROR_ING_EVENT_CONTAINER_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Index to the MIRROR_ING_EVENT_CONTAINER logical table.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mirror.",
    },
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MIRROR_INSTANCE_ID logical table index.  Used to compute the index\n into the MIRROR_ING/EGR_INSTANCE table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_ing_event_container_t = {
    .name = MIRROR_ING_EVENT_CONTAINERs, /* MIRROR_ING_EVENT_CONTAINER */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_mirror_ing_event_container_t_fields,
    .desc = "The MIRROR_ING_EVENT_CONTAINER logical table specifies the\n mirror containers for mirror on drop in the ingress pipeline.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ING_EVENT_GROUP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_ing_event_group_t_fields[] = {
    {
        .name  = MIRROR_ING_EVENT_GROUP_IDs,  /* MIRROR_ING_EVENT_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index to the MIRROR_ING_EVENT_GROUP logical table.",
    },
    {
        .name  = INVALID_VLANs,  /* INVALID_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to invalid VLAN.",
    },
    {
        .name  = TAG_UNTAG_DISCARDs,  /* TAG_UNTAG_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count packets dropped due to port configuration for dropping\n all tagged packets or untagged packets.\n",
    },
    {
        .name  = INVALID_TPIDs,  /* INVALID_TPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to TPID mismatch.",
    },
    {
        .name  = PVLAN_VID_MISMATCHs,  /* PVLAN_VID_MISMATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to PVLAN VID mismatch.",
    },
    {
        .name  = PORT_ING_VLAN_MEMBERSHIPs,  /* PORT_ING_VLAN_MEMBERSHIP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to ingress port not in\n VLAN membership.\n",
    },
    {
        .name  = VLAN_CC_OR_PBTs,  /* VLAN_CC_OR_PBT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select VLAN cross-connect drop.",
    },
    {
        .name  = VLAN_FPs,  /* VLAN_FP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to VLAN FP.",
    },
    {
        .name  = MC_INDEX_ERRs,  /* MC_INDEX_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets with multicast index error.",
    },
    {
        .name  = MPLS_TTL_CHECK_FAILs,  /* MPLS_TTL_CHECK_FAIL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to MPLS TTL check fail.",
    },
    {
        .name  = MPLS_LABEL_MISSs,  /* MPLS_LABEL_MISS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to MPLS label lookup miss.",
    },
    {
        .name  = MPLS_INVALID_PAYLOADs,  /* MPLS_INVALID_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to MPLS invalid payload.",
    },
    {
        .name  = MPLS_INVALID_CWs,  /* MPLS_INVALID_CW */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to MPLS invalid control word.",
    },
    {
        .name  = MPLS_INVALID_ACTIONs,  /* MPLS_INVALID_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to MPLS invalid action.",
    },
    {
        .name  = MPLS_GAL_LABELs,  /* MPLS_GAL_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to MPLS generic associated label\n lookup miss.\n",
    },
    {
        .name  = TNL_DECAP_ECN_DROPs,  /* TNL_DECAP_ECN_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select tunnel decap ECN error drop.",
    },
    {
        .name  = TIME_SYNC_DROPs,  /* TIME_SYNC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select time sync drop.",
    },
    {
        .name  = SRC_ROUTEs,  /* SRC_ROUTE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to source route.",
    },
    {
        .name  = SPANNING_TREE_STATEs,  /* SPANNING_TREE_STATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to spanning tree.",
    },
    {
        .name  = TNL_ERRs,  /* TNL_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to tunnel errors.",
    },
    {
        .name  = PROTECTION_DATA_DROPs,  /* PROTECTION_DATA_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to protection.",
    },
    {
        .name  = NHOP_DROPs,  /* NHOP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to next hop indication.",
    },
    {
        .name  = FP_ING_DROPs,  /* FP_ING_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to ingress FP drop.",
    },
    {
        .name  = FP_REDIRECT_DROPs,  /* FP_REDIRECT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to invalid FP redirection.",
    },
    {
        .name  = ECMP_RESOLUTION_ERRs,  /* ECMP_RESOLUTION_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to ECMP resolution error.",
    },
    {
        .name  = PROTCOL_PKT_CTRL_DROPs,  /* PROTCOL_PKT_CTRL_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to protocol packet drop\n control.\n",
    },
    {
        .name  = PORT_FILTERING_MODEs,  /* PORT_FILTERING_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select port filtering mode drop.",
    },
    {
        .name  = L2_MY_STATIONs,  /* L2_MY_STATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to L2 my station lookup miss.",
    },
    {
        .name  = MPLS_STAGEs,  /* MPLS_STAGE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select MPLS stage drop.",
    },
    {
        .name  = SRC_MAC_ZEROs,  /* SRC_MAC_ZERO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select source MAC address is zero.",
    },
    {
        .name  = L3_TTL_ERRs,  /* L3_TTL_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select L3 TTL error drop.",
    },
    {
        .name  = L3_HDR_ERRs,  /* L3_HDR_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select L3 header error drop.",
    },
    {
        .name  = DST_L3_LOOKUP_MISSs,  /* DST_L3_LOOKUP_MISS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select L3 destination lookup miss drop.",
    },
    {
        .name  = DST_L3_DISCARDs,  /* DST_L3_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select L3 destination discard drop.",
    },
    {
        .name  = SRC_L2_STATIC_MOVEs,  /* SRC_L2_STATIC_MOVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select L2 source static move drop.",
    },
    {
        .name  = SRC_L2_DISCARDs,  /* SRC_L2_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to L2 source discard.",
    },
    {
        .name  = DST_L2_DISCARDs,  /* DST_L2_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to L2 destination discard.",
    },
    {
        .name  = IP_MC_DROPs,  /* IP_MC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select IP multicast header error drop.",
    },
    {
        .name  = SRC_MAC_EQUALS_DST_MACs,  /* SRC_MAC_EQUALS_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to source MAC address equals to\n destination MAC address.\n",
    },
    {
        .name  = TRUNK_FAIL_LOOPBACKs,  /* TRUNK_FAIL_LOOPBACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets looped back because of trunk failover\n in packet discard stage.\n",
    },
    {
        .name  = DOS_L4_ATTACKs,  /* DOS_L4_ATTACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to L4 DoS attack.",
    },
    {
        .name  = DOS_L3_ATTACKs,  /* DOS_L3_ATTACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to L3 DoS attack.",
    },
    {
        .name  = IPV6_PROTOCOL_ERRs,  /* IPV6_PROTOCOL_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to IPv6 protocol error.",
    },
    {
        .name  = IPV4_PROTOCOL_ERRs,  /* IPV4_PROTOCOL_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to IPv4 protocol error.",
    },
    {
        .name  = MAC_CONTROL_FRAMEs,  /* MAC_CONTROL_FRAME */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to MAC control frame.",
    },
    {
        .name  = COMPOSITE_ERRORs,  /* COMPOSITE_ERROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to parity/ecc errors.",
    },
    {
        .name  = CPU_MANAGED_LEARNINGs,  /* CPU_MANAGED_LEARNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to CPU managed learning (CML).",
    },
    {
        .name  = CFI_OR_L3_DISABLEs,  /* CFI_OR_L3_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to CFI or L3 disable.",
    },
    {
        .name  = BPDUs,  /* BPDU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to BPDU.",
    },
    {
        .name  = VFI_ING_ADAPT_LOOKUP_MISSs,  /* VFI_ING_ADAPT_LOOKUP_MISS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select VFI ingress adaptation first lookup miss drop\n or both first and second lookup miss drop.\n",
    },
    {
        .name  = OVERLAY_UNDERLAY_NHOP_EIF_RANGE_ERRORs,  /* OVERLAY_UNDERLAY_NHOP_EIF_RANGE_ERROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select overlay and underlay next hop or L3 egress\n interface ID range error drop.\n",
    },
    {
        .name  = BFD_TERMINATEDs,  /* BFD_TERMINATED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select BFD terminated drop.",
    },
    {
        .name  = BFD_UNKNOWN_VER_OR_DISCARDs,  /* BFD_UNKNOWN_VER_OR_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for unknown BFD version or discard\n dropped.\n",
    },
    {
        .name  = BFD_UNKNOWN_ACH_ERRs,  /* BFD_UNKNOWN_ACH_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for BFD\n packets with non-zero version in the ACH header\n or the ACH channel type unknown.\n",
    },
    {
        .name  = BFD_UNKNOWN_CTRL_PKTs,  /* BFD_UNKNOWN_CTRL_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for unrecognized\n BFD control packets received from the\n PW VCCM type 1/2/3 or MPLS-TP control channel.\n",
    },
    {
        .name  = DOS_L2s,  /* DOS_L2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for L2 DoS attack packets.",
    },
    {
        .name  = PARITY_ERR_DROPs,  /* PARITY_ERR_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to\n parity error.\n",
    },
    {
        .name  = TRUNK_FAILOVER_LOOPBACK_DISCARDs,  /* TRUNK_FAILOVER_LOOPBACK_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for trunk\n failover loopback packets discarded\n due to the backup port being down in packet pre-processing stage.\n",
    },
    {
        .name  = TRUNK_FAILOVER_LOOPBACKs,  /* TRUNK_FAILOVER_LOOPBACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for trunk failover loopback packets in\n packet pre-processing stage.\n",
    },
    {
        .name  = DOS_FRAGMENTs,  /* DOS_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for DoS fragment error packets.",
    },
    {
        .name  = DOS_ICMPs,  /* DOS_ICMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for DoS ICMP error packets.",
    },
    {
        .name  = RX_TNL_ERRs,  /* RX_TNL_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for received tunnel error packets.",
    },
    {
        .name  = RX_TNLs,  /* RX_TNL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for the number of tunnel packets\n received.\n",
    },
    {
        .name  = RX_DROPs,  /* RX_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for zero port bitmap drop\n condition.\n",
    },
    {
        .name  = RX_MC_DROPs,  /* RX_MC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for multicast (L2+L3) packets\n that are dropped.\n",
    },
    {
        .name  = MC_BRIDGEDs,  /* MC_BRIDGED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for bridged multicast packets.",
    },
    {
        .name  = RX_PORT_DROPs,  /* RX_PORT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped\n when the ingress port is not\n in a forwarding state.\n",
    },
    {
        .name  = RX_UCs,  /* RX_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for good received unicast\n (L2+L3) packets.\n",
    },
    {
        .name  = IPV6_MC_ROUTEDs,  /* IPV6_MC_ROUTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for routed IPv6 multicast packets.",
    },
    {
        .name  = RX_IPV6_HDR_ERRs,  /* RX_IPV6_HDR_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for received IPv6 header error packets\n (IPv6 martian error addresses + link local).\n",
    },
    {
        .name  = RX_IPV6s,  /* RX_IPV6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for good received IPv6 L3 packets,\n including tunneled packets.\n",
    },
    {
        .name  = RX_IPV6_DISCARDs,  /* RX_IPV6_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for received L3 IPv6 discarded\n  packets.\n",
    },
    {
        .name  = IPV4_MC_ROUTEDs,  /* IPV4_MC_ROUTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for routed IPv4 multicast packets.",
    },
    {
        .name  = RX_IPV4_HDR_ERRs,  /* RX_IPV4_HDR_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for received IPv4 header error packets\n (martian error address + unicast with Class D + multicast & ~ClassD)\n",
    },
    {
        .name  = RX_IPV4s,  /* RX_IPV4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for good received IPv4 L3,\n including tunneled packets.\n",
    },
    {
        .name  = RX_IPV4_DISCARDs,  /* RX_IPV4_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for received L3 IPv4 discarded\n packets.\n",
    },
    {
        .name  = VLAN_MEMBERSHIP_DROPs,  /* VLAN_MEMBERSHIP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to mismatched\n egress port for the VLAN.\n",
    },
    {
        .name  = VLAN_BLOCKED_DROPs,  /* VLAN_BLOCKED_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to\n VLAN blocked ports.\n",
    },
    {
        .name  = VLAN_STG_DROPs,  /* VLAN_STG_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to spanning\n tree group state.\n",
    },
    {
        .name  = NONUC_TRUNK_RESOLUTION_MASKs,  /* NONUC_TRUNK_RESOLUTION_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped\n due to multicast and broadcast trunk\n block mask.\n",
    },
    {
        .name  = NONUC_MASKs,  /* NONUC_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to\n unknown unicast, unknown multicast, known multicast,\n and broadcast block masks.\n",
    },
    {
        .name  = MC_DROPs,  /* MC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to\n multicast errors.\n",
    },
    {
        .name  = MAC_MASKs,  /* MAC_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to MAC block\n mask.\n",
    },
    {
        .name  = ING_EGR_MASKs,  /* ING_EGR_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to block\n traffic from egressing based on the ingress port.\n",
    },
    {
        .name  = FP_ING_DELAYED_DROPs,  /* FP_ING_DELAYED_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to ingress FP\n delayed action.\n",
    },
    {
        .name  = FP_REDIRECT_MASKs,  /* FP_REDIRECT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to FP\n redirection mask.\n",
    },
    {
        .name  = EGR_MASKs,  /* EGR_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to egress\n mask.\n",
    },
    {
        .name  = SRC_PORT_KNOCKOUT_DROPs,  /* SRC_PORT_KNOCKOUT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to\n source port knockout.\n",
    },
    {
        .name  = NON_IP_DISCARDs,  /* NON_IP_DISCARD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for non-IP packet discard dropped.",
    },
    {
        .name  = MTU_CHECK_FAILs,  /* MTU_CHECK_FAIL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to MTU check\n fail.\n",
    },
    {
        .name  = BLOCK_MASK_DROPs,  /* BLOCK_MASK_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select counter update for packets dropped due to block\n masks.\n",
    },
    {
        .name  = BFD_ERRORs,  /* BFD_ERROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to BFD error.",
    },
    {
        .name  = BFD_SLOWPATHs,  /* BFD_SLOWPATH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to BFD slow path.",
    },
    {
        .name  = TIME_SYNC_TO_CPUs,  /* TIME_SYNC_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select network time sync packet copied to CPU.",
    },
    {
        .name  = IEEE1588_UNKNOWN_VERSIONs,  /* IEEE1588_UNKNOWN_VERSION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to IEEE 1588\n unknown version.\n",
    },
    {
        .name  = MPLS_UNKNOWN_ACH_TYPEs,  /* MPLS_UNKNOWN_ACH_TYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to MPLS unknown generic\n associated channel type or version.\n",
    },
    {
        .name  = MPLS_ILLEGAL_RESERVED_LABELs,  /* MPLS_ILLEGAL_RESERVED_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to illegal reserved\n MPLS label. Such packets have GAL (Generic Associated Channel Label)\n that is not at the bottom of the stack.\n",
    },
    {
        .name  = MPLS_ALERT_LABEL_EXPOSEDs,  /* MPLS_ALERT_LABEL_EXPOSED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to GAL\n (Generic Associated channel Label)\n or RAL (Router Alert Label) being exposed.\n",
    },
    {
        .name  = MPLS_TTL_CHECK_FAIL_TO_CPUs,  /* MPLS_TTL_CHECK_FAIL_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to\n MPLS Header TTL value being 0 or 1.\n",
    },
    {
        .name  = MPLS_INVALID_PAYLOAD_TO_CPUs,  /* MPLS_INVALID_PAYLOAD_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to MPLS payload being\n invalid. Packet has an IPv4 payload and TNL_MPLS_DECAP.IPV4_PAYLOAD is\n not enabled, or packet has an IPv6 payload and TNL_MPLS_DECAP.\n IPV6_PAYLOAD is not enabled.\n",
    },
    {
        .name  = MPLS_INVALID_ACTION_TO_CPUs,  /* MPLS_INVALID_ACTION_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to MPLS invalid action.\n Label is  BOS (Bottom Of Stack) and TNL_MPLS_DECAP.BOS_ACTIONS is\n set to in valid, or label is NON_BOS (Not Bottom Of Stack) and\n TNL_MPLS_DECAP.NON_BOS_ACTIONS is set to invalid.\n",
    },
    {
        .name  = MPLS_LABEL_MISS_TO_CPUs,  /* MPLS_LABEL_MISS_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to MPLS label lookup miss.\n Applicable only for MPLS tunnel termination.\n",
    },
    {
        .name  = VXLAN_VFI_ASSIGN_FAIL_DROPs,  /* VXLAN_VFI_ASSIGN_FAIL_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet dropped due to VXLAN packets with VFI\n assignment failure.\n Applicable if there is no match in\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID or\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4 or\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6 during\n tunnel decapsulation.\n",
    },
    {
        .name  = VXLAN_SVP_ASSIGN_FAIL_DROPs,  /* VXLAN_SVP_ASSIGN_FAIL_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet dropped due to VXLAN packets with source\n virtual port assignment failure.\n Applicable if there is no match in\n TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4 or\n TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6.\n",
    },
    {
        .name  = VXLAN_TNL_ERR_DROPs,  /* VXLAN_TNL_ERR_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packets dropped due to VXLAN tunnel errors.",
    },
    {
        .name  = SFLOW_FLEX_SAMPLEs,  /* SFLOW_FLEX_SAMPLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select SFLOW flex sampled packet copied to CPU.",
    },
    {
        .name  = SFLOW_ING_SAMPLEs,  /* SFLOW_ING_SAMPLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select SFLOW ingress sampled packet copied to CPU.",
    },
    {
        .name  = SFLOW_EGR_SAMPLEs,  /* SFLOW_EGR_SAMPLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select SFLOW egress sampled packet copied to CPU.",
    },
    {
        .name  = TNL_DECAP_ECN_TO_CPUs,  /* TNL_DECAP_ECN_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU from tunnel decap ECN.",
    },
    {
        .name  = TNL_ERR_TO_CPUs,  /* TNL_ERR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to tunnel error.",
    },
    {
        .name  = CBSM_PREVENTEDs,  /* CBSM_PREVENTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to CBSM\n (Class Based Station Movement) prevention.\n",
    },
    {
        .name  = DLB_MONITORs,  /* DLB_MONITOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU by DLB monitor.\n",
    },
    {
        .name  = ETRAP_MONITORs,  /* ETRAP_MONITOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU by Etrap (elephant trap)\n monitor.\n",
    },
    {
        .name  = FP_INGs,  /* FP_ING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to ingress FP action.",
    },
    {
        .name  = VFPs,  /* VFP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to VFP action.",
    },
    {
        .name  = VXLAN_VFI_ASSIGN_FAIL_TO_CPUs,  /* VXLAN_VFI_ASSIGN_FAIL_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to VXLAN packets with VFI\n assignment failure.\n Applicable if there is no match in\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID or\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4 or\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6 during\n tunnel decapsulation.\n",
    },
    {
        .name  = VXLAN_SVP_ASSIGN_FAIL_TO_CPUs,  /* VXLAN_SVP_ASSIGN_FAIL_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to VXLAN packets with source\n virtual port assignment failure.\n Applicable if there is no match in\n TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4 or\n TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6.\n",
    },
    {
        .name  = MC_INDEX_ERR_TO_CPUs,  /* MC_INDEX_ERR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to multicast index error.",
    },
    {
        .name  = ICMP_REDIRECTs,  /* ICMP_REDIRECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select ICMP redirect packet copied to CPU.",
    },
    {
        .name  = NHOPs,  /* NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU from next hop table.",
    },
    {
        .name  = MARTIAN_ADDRs,  /* MARTIAN_ADDR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to Martian address.",
    },
    {
        .name  = L3_HDR_ERR_TO_CPUs,  /* L3_HDR_ERR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L3 header error.",
    },
    {
        .name  = IP_MC_MISSs,  /* IP_MC_MISS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to IPMC miss.",
    },
    {
        .name  = IP_MC_L3_IIF_MISMATCHs,  /* IP_MC_L3_IIF_MISMATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to IP multicast\n interface mismatch.",
    },
    {
        .name  = L3_SRC_MOVEs,  /* L3_SRC_MOVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L3 station movement.",
    },
    {
        .name  = L3_DST_MISSs,  /* L3_DST_MISS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L3 destination IP\n miss or broadcast destination IP.\n",
    },
    {
        .name  = L3_SRC_MISSs,  /* L3_SRC_MISS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L3 source IP miss.",
    },
    {
        .name  = MTU_CHECK_FAIL_TO_CPUs,  /* MTU_CHECK_FAIL_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L3 MTU check failure.",
    },
    {
        .name  = IP_OPTIONS_PKTs,  /* IP_OPTIONS_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to an IP packet with\n options.\n",
    },
    {
        .name  = TTL_1s,  /* TTL_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select IPMC or L3UC packet with TTL equal to 1\n copied to CPU.\n",
    },
    {
        .name  = PBT_NONUC_PKTs,  /* PBT_NONUC_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to PBT\n (Provider Backbone Transport) packet being non unicast.\n",
    },
    {
        .name  = L2s,  /* L2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU from L2 table.",
    },
    {
        .name  = L2_MOVEs,  /* L2_MOVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L2 station movement.",
    },
    {
        .name  = L2_DST_LOOKUP_FAILUREs,  /* L2_DST_LOOKUP_FAILURE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L2 destination\n lookup failure.i\n",
    },
    {
        .name  = L2_SRC_LOOKUP_FAILUREs,  /* L2_SRC_LOOKUP_FAILURE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU\n due to L2 source lookup failure.\n",
    },
    {
        .name  = L2_MY_STATION_HITs,  /* L2_MY_STATION_HIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU\n due to MY_STATION hit.\n",
    },
    {
        .name  = L2_MC_MISSs,  /* L2_MC_MISS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L2MC miss.",
    },
    {
        .name  = PARITY_ERRORs,  /* PARITY_ERROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to parity error\n in ingress pipeline tables.\n",
    },
    {
        .name  = PKT_TRACEs,  /* PKT_TRACE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to packet trace function.",
    },
    {
        .name  = DOS_ATTACKs,  /* DOS_ATTACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select DOS attack packet copied to CPU.",
    },
    {
        .name  = PVLAN_ID_MISMATCH_TO_CPUs,  /* PVLAN_ID_MISMATCH_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select Private VLAN ID mismatch packet copied to CPU.",
    },
    {
        .name  = UNKNOWN_VLANs,  /* UNKNOWN_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select Unknown VLAN packet copied to CPU.",
    },
    {
        .name  = L2_PROTOs,  /* L2_PROTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select L2 protocol packet copied to CPU.",
    },
    {
        .name  = SRP_PROTOCOLs,  /* SRP_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select SRP (Stream Registration Protocol)\n packet copied to CPU.\n",
    },
    {
        .name  = MMRP_PROTOCOLs,  /* MMRP_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select MMRP (Multiple Mac Registration Protocol) packet\n copied to CPU.\n",
    },
    {
        .name  = ARP_PROTOCOLs,  /* ARP_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select ARP packet copied to CPU.",
    },
    {
        .name  = IGMP_PROTOCOLs,  /* IGMP_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select IGMP packet copied to CPU.",
    },
    {
        .name  = DHCP_PROTOCOLs,  /* DHCP_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select DHCP packet copied to CPU.",
    },
    {
        .name  = IP_MC_RSVD_PROTOCOLs,  /* IP_MC_RSVD_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select IPMC reserved packet copied to CPU.",
    },
    {
        .name  = BPDU_PROTOCOLs,  /* BPDU_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select BPDU packet copied to CPU.",
    },
    {
        .name  = INBAND_TELEMETRY_DATAPLANE_TURNAROUNDs,  /* INBAND_TELEMETRY_DATAPLANE_TURNAROUND */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select In-band Network Telemetry Data-plane\n Probe (INT-DP) turned around packets copied to CPU.\n",
    },
    {
        .name  = INBAND_TELEMETRY_DATAPLANE_HOP_LIMIT_EXCEEDEDs,  /* INBAND_TELEMETRY_DATAPLANE_HOP_LIMIT_EXCEEDED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select In-band Network Telemetry Data-plane\n Probe (INT-DP) packets with HOP_COUNT no less than HOP_LIMIT\n copied to CPU.\n",
    },
    {
        .name  = VFI_ING_ADAPT_LOOKUP_MISS_TO_CPUs,  /* VFI_ING_ADAPT_LOOKUP_MISS_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select VFI ingress adaptation first lookup miss\n or both first and second lookup miss copied to CPU.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_ing_event_group_t = {
    .name = MIRROR_ING_EVENT_GROUPs, /* MIRROR_ING_EVENT_GROUP */
    .flags = 0,
    .fields = 153,
    .field = bcmltd_mirror_ing_event_group_t_fields,
    .desc = "The MIRROR_ING_EVENT_GROUP logical table specifies the\n event groups which can trigger mirror on drop in ingress pipeline.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ING_EVENT_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_ing_event_profile_t_fields[] = {
    {
        .name  = EVENT_GROUP_0s,  /* EVENT_GROUP_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "An event in group 0 of MIRROR_ING_EVENT_GROUP\n is triggered.\n",
    },
    {
        .name  = EVENT_GROUP_0_MASKs,  /* EVENT_GROUP_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for EVENT_GROUP_0.",
    },
    {
        .name  = EVENT_GROUP_1s,  /* EVENT_GROUP_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "An event in group 1 of MIRROR_ING_EVENT_GROUP\n is triggered.\n",
    },
    {
        .name  = EVENT_GROUP_1_MASKs,  /* EVENT_GROUP_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for EVENT_GROUP_1.",
    },
    {
        .name  = EVENT_GROUP_2s,  /* EVENT_GROUP_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "An event in group 2 of MIRROR_ING_EVENT_GROUP\n is triggered.\n",
    },
    {
        .name  = EVENT_GROUP_2_MASKs,  /* EVENT_GROUP_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for EVENT_GROUP_2.",
    },
    {
        .name  = EVENT_GROUP_3s,  /* EVENT_GROUP_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "An event in group 3 of MIRROR_ING_EVENT_GROUP\n is triggered.\n",
    },
    {
        .name  = EVENT_GROUP_3_MASKs,  /* EVENT_GROUP_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for EVENT_GROUP_3.",
    },
    {
        .name  = EVENT_GROUP_4s,  /* EVENT_GROUP_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "An event in group 4 of MIRROR_ING_EVENT_GROUP\n is triggered.\n",
    },
    {
        .name  = EVENT_GROUP_4_MASKs,  /* EVENT_GROUP_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for EVENT_GROUP_4.",
    },
    {
        .name  = EVENT_GROUP_5s,  /* EVENT_GROUP_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "An event in group 5 of MIRROR_ING_EVENT_GROUP\n is triggered.\n",
    },
    {
        .name  = EVENT_GROUP_5_MASKs,  /* EVENT_GROUP_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for EVENT_GROUP_5.",
    },
    {
        .name  = EVENT_GROUP_6s,  /* EVENT_GROUP_6 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "An event in group 6 of MIRROR_ING_EVENT_GROUP\n is triggered.\n",
    },
    {
        .name  = EVENT_GROUP_6_MASKs,  /* EVENT_GROUP_6_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for EVENT_GROUP_6.",
    },
    {
        .name  = EVENT_GROUP_7s,  /* EVENT_GROUP_7 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "An event in group 7 of MIRROR_ING_EVENT_GROUP\n is triggered.\n",
    },
    {
        .name  = EVENT_GROUP_7_MASKs,  /* EVENT_GROUP_7_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for EVENT_GROUP_7.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to mirror on this event.",
    },
    {
        .name  = REASON_CODEs,  /* REASON_CODE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Event reason code.",
    },
    {
        .name  = SAMPLEs,  /* SAMPLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to sample for mirror rate limiting.",
    },
    {
        .name  = SAMPLE_RATEs,  /* SAMPLE_RATE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Sample the mirror packets if the generated sFlow random\n number is smaller than the rate. A greater rate leads to\n higher sampling frequency.\n",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_ing_event_profile_t = {
    .name = MIRROR_ING_EVENT_PROFILEs, /* MIRROR_ING_EVENT_PROFILE */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 21,
    .field = bcmltd_mirror_ing_event_profile_t_fields,
    .desc = "The MIRROR_ING_EVENT_PROFILE logical table specifies the\n mirror profile for mirror on drop in the ingress pipeline triggered by event\n groups in the MIRROR_ING_EVENT_GROUP table. The key of this table is\n EVENT_GROUP_N, which indicates at least one event in the\n group N happens. The key mask is set as 1 to select the group for\n matching.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ING_FLEX_SFLOW.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_ing_flex_sflow_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = MIRROR_ING_FLEX_SFLOW_IDs,  /* MIRROR_ING_FLEX_SFLOW_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index to the MIRROR_ING_FLEX_SFLOW table.",
    },
    {
        .name  = SAMPLEs,  /* SAMPLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to sample ingress flex sFlow packets.",
    },
    {
        .name  = SAMPLE_TO_CPUs,  /* SAMPLE_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy ingress flex sFlow packet samples to CPU.",
    },
    {
        .name  = SAMPLE_MIRROR_ING_INSTANCEs,  /* SAMPLE_MIRROR_ING_INSTANCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy ingress flex sFlow packet samples to the ingress\n mirror member using the sFlow mirror instance configuration.\n",
    },
    {
        .name  = SAMPLE_RATEs,  /* SAMPLE_RATE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Sample ingress flex sFlow packet if the generated sFlow random\n number is not greater than the threshold. A greater threshold leads\n to a higher sampling frequency.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_ing_flex_sflow_t = {
    .name = MIRROR_ING_FLEX_SFLOWs, /* MIRROR_ING_FLEX_SFLOW */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_mirror_ing_flex_sflow_t_fields,
    .desc = "The MIRROR_ING_FLEX_SFLOW logical table specifies the ingress flex sFlow\n sample configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ING_INSTANCE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_ing_instance_t_fields[] = {
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MIRROR_ING_INSTANCE table.",
    },
    {
        .name  = IS_TRUNKs,  /* IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate destination is a trunk.",
    },
    {
        .name  = HASHs,  /* HASH */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Trunk hash control. Applicable only if IS_TRUNK is enabled.",
    },
    {
        .name  = MEMBER_CNTs,  /* MEMBER_CNT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of mirror destination ports.\n  Set the field to 1 for non-trunk ports.\n",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "Destination module ID. Index 0 in the array is used\n for non-trunk ports.\n",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 8,
        .desc = "Destination port ID. Index 0 in the array is used\n for non-trunk ports.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_ing_instance_t = {
    .name = MIRROR_ING_INSTANCEs, /* MIRROR_ING_INSTANCE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_mirror_ing_instance_t_fields,
    .desc = "The MIRROR_ING_INSTANCE table specifies\n the ingress mirror destination index for trunk and non-trunk ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_ING_MEMBER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_ing_member_t_fields[] = {
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Mirror instance to compute index into MIRROR_ING_INSTANCE table.",
    },
    {
        .name  = MIRROR_MEMBER_IDs,  /* MIRROR_MEMBER_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Trunk member to compute index into the MIRROR_ING_MEMBER table.",
    },
    {
        .name  = REPLACE_INT_PRIs,  /* REPLACE_INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to change the internal priority of the mirrored packet.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Internal priority. Applicable only if REPLACE_INT_PRI is enabled.",
    },
    {
        .name  = ENCAPs,  /* ENCAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate the mirrored packet.",
    },
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MIRROR_ENCAP table index. Applicable only if ENCAP is enabled.",
    },
    {
        .name  = TRUNCATE_ACTIONs,  /* TRUNCATE_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Type of truncation (if any) of the mirrored packet.",
    },
    {
        .name  = TIMESTAMP_MODEs,  /* TIMESTAMP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TIMESTAMP_MODE_T_DATA,
        .desc = "Timestamp mode for mirror encapsulation.",
    },
    {
        .name  = MULTIPLE_MIRROR_DSTs,  /* MULTIPLE_MIRROR_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mirroring to multiple destinations.",
    },
    {
        .name  = MIRROR_DST_IP_IDs,  /* MIRROR_DST_IP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MIRROR_DST_IPV4 or MIRROR_DST_IPV6 logical table index. Applicable\n when MULTIPLE_MIRROR_DST is enabled. MIRROR_ENCAP_ID represents an\n IPv4 or IPv6 mirror encapsulation, which decides if a MIRROR_DST_IPV4\n or MIRROR_DST_IPV6 index should be used.\n",
    },
    {
        .name  = NUM_IP_ENTRYs,  /* NUM_IP_ENTRY */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries occupied by a group of IPv4 or IPv6 addresses in\n MIRROR_DST_IPV4 or MIRROR_DST_IPV6. Applicable when\n MULTIPLE_MIRROR_DST is enabled.\n",
    },
    {
        .name  = IPV4_INDEXs,  /* IPV4_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index of the selected destination IPv4 address in the\n MIRROR_DST_IPV4.IPV4 array. Applicable when\n when MULTIPLE_MIRROR_DST is enabled.\n",
    },
    {
        .name  = OVERLAY_NHOPs,  /* OVERLAY_NHOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to overlay next hop, otherwise underlay next hop.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_ing_member_t = {
    .name = MIRROR_ING_MEMBERs, /* MIRROR_ING_MEMBER */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_mirror_ing_member_t_fields,
    .desc = "The MIRROR_ING_MEMBER logical table specifies\n the ingress mirror destination member configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_PORT_ENCAP_SFLOW.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_port_encap_sflow_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = SAMPLE_INGs,  /* SAMPLE_ING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to sample ingress port-based sFlow packets.",
    },
    {
        .name  = SAMPLE_EGRs,  /* SAMPLE_EGR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to sample egress port-based sFlow packets.",
    },
    {
        .name  = SAMPLE_ING_FLEXs,  /* SAMPLE_ING_FLEX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to sample ingress port-based flex sFlow packets.",
    },
    {
        .name  = SAMPLE_ING_CPUs,  /* SAMPLE_ING_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy ingress sFlow packet samples to CPU.",
    },
    {
        .name  = SAMPLE_ING_MIRROR_INSTANCEs,  /* SAMPLE_ING_MIRROR_INSTANCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy ingress sFlow packet samples to the ingress\n mirror member using the sFlow mirror instance configuration.\n",
    },
    {
        .name  = SAMPLE_ING_FLEX_CPUs,  /* SAMPLE_ING_FLEX_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy ingress flex sFlow packet samples to CPU.",
    },
    {
        .name  = SAMPLE_ING_FLEX_MIRROR_INSTANCEs,  /* SAMPLE_ING_FLEX_MIRROR_INSTANCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy ingress flex sFlow packet samples to the ingress\n mirror member using the sFlow mirror instance configuration.\n",
    },
    {
        .name  = SAMPLE_ING_RATEs,  /* SAMPLE_ING_RATE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Sample ingress sFlow packet if the generated sFlow random number is\n lower than the threshold. A higher threshold leads to\n higher sampling frequency.\n",
    },
    {
        .name  = SAMPLE_EGR_RATEs,  /* SAMPLE_EGR_RATE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Sample egress sFlow packet if the generated sFlow random number is\n lower than the threshold. A higher threshold leads to\n higher sampling frequency.\n",
    },
    {
        .name  = SAMPLE_ING_FLEX_RATEs,  /* SAMPLE_ING_FLEX_RATE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Sample ingress flex sFlow packet if the generated sFlow random\n number is lower than the threshold. A higher threshold leads to\n higher sampling frequency.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_port_encap_sflow_t = {
    .name = MIRROR_PORT_ENCAP_SFLOWs, /* MIRROR_PORT_ENCAP_SFLOW */
    .flags = 0,
    .fields = 11,
    .field = bcmltd_mirror_port_encap_sflow_t_fields,
    .desc = "The MIRROR_PORT_ENCAP_SFLOW logical table specifies\n per-port sFlow encapsulation sample configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_SESSION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_session_t_fields[] = {
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Mirror instance to compute index into MIRROR_SESSION table.",
    },
    {
        .name  = MIRROR_SESSION_IDs,  /* MIRROR_SESSION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Session to compute index into the MIRROR_SESSION table.",
    },
    {
        .name  = EGRs,  /* EGR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that this is an egress session.",
    },
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MIRROR_ENCAP table index.",
    },
    {
        .name  = MC_COSs,  /* MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "COS value for mirrored multicast packets.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies the priority of the entry.",
    },
    {
        .name  = SYSTEM_PORT_TABLE_IDs,  /* SYSTEM_PORT_TABLE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination system port ID.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination port ID.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_session_t = {
    .name = MIRROR_SESSIONs, /* MIRROR_SESSION */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_mirror_session_t_fields,
    .desc = "The MIRROR_SESSION logical table specifies the mirror session configuration\n like mirroring destination port, priority, COS value, and encapsulation\n instance.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_SFLOW.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_sflow_t_fields[] = {
    {
        .name  = CTR_ING_FLEX_POOL_IDs,  /* CTR_ING_FLEX_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter pool ID.",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the ingress sFlow sampler table.",
    },
    {
        .name  = SAMPLE_ING_FLEXs,  /* SAMPLE_ING_FLEX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to sample ingress flex sFlow packets.",
    },
    {
        .name  = SAMPLE_ING_FLEX_TRACE_EVENTs,  /* SAMPLE_ING_FLEX_TRACE_EVENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trace packets seen by this sampler.\n Applicable only if SAMPLE_ING_FLEX_MIRROR_MODE is\n SAMPLER_IS_BELOW_RATE.\n",
    },
    {
        .name  = SAMPLE_ING_FLEX_POOLs,  /* SAMPLE_ING_FLEX_POOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count the number of packets seen by this sampler.",
    },
    {
        .name  = SAMPLE_ING_FLEX_COUNTERs,  /* SAMPLE_ING_FLEX_COUNTER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to count the number of packets sampled by this sampler.",
    },
    {
        .name  = SAMPLE_ING_FLEX_MIRROR_MODEs,  /* SAMPLE_ING_FLEX_MIRROR_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Ingress flex sFlow packet mirror control.",
    },
    {
        .name  = SAMPLE_ING_FLEX_MIRROR_SESSION_IDs,  /* SAMPLE_ING_FLEX_MIRROR_SESSION_ID */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Ingress flex sFlow packet mirror session member.\n Applicable only if SAMPLE_ING_FLEX_MIRROR_MODE is\n SAMPLER_IS_ABOVE_RATE or SAMPLER_IS_BELOW_RATE.\n",
    },
    {
        .name  = SAMPLE_ING_FLEX_MIRROR_INSTANCE_IDs,  /* SAMPLE_ING_FLEX_MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress flex sFlow packet mirror instance configuration.\n Applicable only if SAMPLE_ING_FLEX_MIRROR_MODE is\n SAMPLER_IS_ABOVE_RATE or SAMPLER_IS_BELOW_RATE.\n",
    },
    {
        .name  = SAMPLE_ING_FLEX_RATEs,  /* SAMPLE_ING_FLEX_RATE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Sample ingress flex sFlow packet if the generated sFlow random\n number is greater than the threshold. A lower threshold leads to\n higher sampling frequency.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_sflow_t = {
    .name = MIRROR_SFLOWs, /* MIRROR_SFLOW */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_mirror_sflow_t_fields,
    .desc = "The MIRROR_SFLOW logical table specifies\n sFlow sampler configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_SFLOW_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_sflow_control_t_fields[] = {
    {
        .name  = CTR_ING_FLEX_POOL_IDs,  /* CTR_ING_FLEX_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter pool ID.",
    },
    {
        .name  = SAMPLE_ING_FLEX_SEEDs,  /* SAMPLE_ING_FLEX_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Sampled flow (sFlow) ingress random number generation seed.",
    },
    {
        .name  = SAMPLE_ING_FLEX_POOL_ACTIONs,  /* SAMPLE_ING_FLEX_POOL_ACTION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter action of packets seen by this sampler.",
    },
    {
        .name  = SAMPLE_ING_FLEX_CTR_ACTIONs,  /* SAMPLE_ING_FLEX_CTR_ACTION */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter action of packets sampled by this sampler.",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_sflow_control_t = {
    .name = MIRROR_SFLOW_CONTROLs, /* MIRROR_SFLOW_CONTROL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_mirror_sflow_control_t_fields,
    .desc = "The MIRROR_SFLOW_CONTROL logical table specifies\n per-pool sFlow sampler controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mirror/MIRROR_TRUNCATE_LENGTH.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mirror_truncate_length_t_fields[] = {
    {
        .name  = MIRROR_TRUNCATE_LENGTH_IDs,  /* MIRROR_TRUNCATE_LENGTH_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index to the MIRROR_TRUNCATE_LENGTH logical table.",
    },
    {
        .name  = TRUNCATEs,  /* TRUNCATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to truncate the mirror copy.\n",
    },
    {
        .name  = CELL_TRUNCATEs,  /* CELL_TRUNCATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to truncate the mirror copy to a variable number of cells.\n The truncated length is specified in CELL_TRUNCATE_LENGTH.\n Applicable only if TRUNCATE is enabled and\n CELL_TRUNCATE_LENGTH_SRC is disabled.\n",
    },
    {
        .name  = CELL_TRUNCATE_LENGTHs,  /* CELL_TRUNCATE_LENGTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Multi-cell truncate length in units of 64 bytes.\n A value of 1 specifies 64 bytes, 2 specifies 128 bytes.\n",
    },
    {
        .name  = CELL_TRUNCATE_LENGTH_SRCs,  /* CELL_TRUNCATE_LENGTH_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to truncate the mirror copy to a variable number of cells.\n The truncated length is specified in the object bus.\n Applicable only if TRUNCATE is enabled.\n",
    },
    {
        .name  = TRUNCATE_ZONEs,  /* TRUNCATE_ZONE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Last zone number included in the truncated mirror copy.\n Applicable only if TRUNCATE is enabled,\n CELL_TRUNCATE is disabled and\n TRUNCATE_ACTION == TRUNCATE_ADJUST.\n",
    },
    {
        .name  = TRUNCATE_ACTIONs,  /* TRUNCATE_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Type of truncation of the mirrored packet.\n Applicable only if TRUNCATE is enabled and\n CELL_TRUNCATE is disabled.\n",
    },
    {
        .name  = TRUNCATE_LENGTHs,  /* TRUNCATE_LENGTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Truncate adjustment size after mirror encapsulation headers.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mirror_truncate_length_t = {
    .name = MIRROR_TRUNCATE_LENGTHs, /* MIRROR_TRUNCATE_LENGTH */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_mirror_truncate_length_t_fields,
    .desc = "The MIRROR_TRUNCATE_LENGTH table specifies the length adjustment for\n truncate case which is added to the total zone size as the new truncate\n length.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_AGM.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_agm_t_fields[] = {
    {
        .name  = MON_AGM_IDs,  /* MON_AGM_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "AGM identifier.",
    },
    {
        .name  = SCALEs,  /* SCALE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Encoded number of a single period length.",
    },
    {
        .name  = PERIOD_MAXs,  /* PERIOD_MAX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of periods for statistics collection.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter ingress pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flexible counter base index.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_agm_t = {
    .name = MON_AGMs, /* MON_AGM */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_mon_agm_t_fields,
    .desc = "The MON_AGM table specifies the aggregation group monitor properties.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_AGM_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_agm_control_t_fields[] = {
    {
        .name  = MON_AGM_IDs,  /* MON_AGM_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "AGM identifier.",
    },
    {
        .name  = START_TIME_AUTOs,  /* START_TIME_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to automatically set the current time as the START_TIME.\n When START_TIME_AUTO is enabled, the calculated start time is reflected in\n the START_TIME_OPER.\n",
    },
    {
        .name  = START_TIMEs,  /* START_TIME */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Start timestamp value. It`s an IEEE 1588 or local switch time.\n Refer to timesync base drvier for the exact definition.\n Applicable only when START_TIME_AUTO is disabled.\n",
    },
    {
        .name  = START_TIME_OPERs,  /* START_TIME_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Computed valued of START_TIME. Read-Only field is applicable only\n when START_TIME_AUTO is enabled.\n",
    },
    {
        .name  = MONITORs,  /* MONITOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to start the aggregation group monitor",
    },
};
const bcmltd_table_rep_t bcmltd_mon_agm_control_t = {
    .name = MON_AGM_CONTROLs, /* MON_AGM_CONTROL */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_mon_agm_control_t_fields,
    .desc = "The MON_AGM_CONTROL table is used to enable/disable the aggregation group monitor.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_COLLECTOR_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_collector_ipv4_t_fields[] = {
    {
        .name  = MON_COLLECTOR_IPV4_IDs,  /* MON_COLLECTOR_IPV4_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_COLLECTOR_IPV4 table.",
    },
    {
        .name  = TAG_STRUCTUREs,  /* TAG_STRUCTURE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "VLAN tag type.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID. Applicable only when TAG_STRUCTURE\n is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "VLAN CFI. Applicable only when TAG_STRUCTURE\n is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority. Applicable only when\n TAG_STRUCTURE is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_IDs,  /* INNER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_CFIs,  /* INNER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_PRIs,  /* INNER_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag. Applicable only when\n TAG_STRUCTURE is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_TPIDs,  /* INNER_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inner TPID for VLAN tag. Applicable only when\n  TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 type of service.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 time to live.",
    },
    {
        .name  = DST_L4_UDP_PORTs,  /* DST_L4_UDP_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 UDP destination port.",
    },
    {
        .name  = SRC_L4_UDP_PORTs,  /* SRC_L4_UDP_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 UDP source port.",
    },
    {
        .name  = UDP_CHKSUMs,  /* UDP_CHKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable UDP checksum calculation for the packets\n sent to the collector.\n",
    },
    {
        .name  = SYSTEM_ID_LENs,  /* SYSTEM_ID_LEN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Protobuf system ID length. Applicable when the WIRE_FORMAT\n field in the MON_EXPORT_PROFILE table is PROTOBUF.\n",
    },
    {
        .name  = SYSTEM_IDs,  /* SYSTEM_ID */
        .flags = 0,
        .width = 8,
        .depth = 32,
        .desc = "Identification of the system being monitored. Applicable when\n the WIRE_FORMAT field in the MON_EXPORT_PROFILE table is PROTOBUF.\n",
    },
    {
        .name  = COMPONENT_IDs,  /* COMPONENT_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Component ID of the protobuf. Applicable when the WIRE_FORMAT\n field in the MON_EXPORT_PROFILE table is PROTOBUF.\n",
    },
    {
        .name  = OBSERVATION_DOMAINs,  /* OBSERVATION_DOMAIN */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IP flow information export (IPFIX) observation domain. Applicable\n when the WIRE_FORMAT field in the MON_EXPORT_PROFILE table is IPFIX.\n",
    },
    {
        .name  = IPFIX_ENTERPRISE_NUMBERs,  /* IPFIX_ENTERPRISE_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IP flow information export (IPFIX) enterprise number to be used when\n exporting template sets containing enterprise specific information\n elements. Applicable when the WIRE_FORMAT field in the\n MON_EXPORT_PROFILE table is IPFIX.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_collector_ipv4_t = {
    .name = MON_COLLECTOR_IPV4s, /* MON_COLLECTOR_IPV4 */
    .flags = 0,
    .fields = 24,
    .field = bcmltd_mon_collector_ipv4_t_fields,
    .desc = "The MON_COLLECTOR_IPV4 table is used to specify\n IPv4 collector entity configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_COLLECTOR_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_collector_ipv6_t_fields[] = {
    {
        .name  = MON_COLLECTOR_IPV6_IDs,  /* MON_COLLECTOR_IPV6_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_COLLECTOR_IPV6 table.",
    },
    {
        .name  = TAG_STRUCTUREs,  /* TAG_STRUCTURE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "VLAN tag type.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID. Applicable only when TAG_STRUCTURE is\n SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "VLAN CFI. Applicable only when TAG_STRUCTURE\n is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority. Applicable only when\n TAG_STRUCTURE is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_IDs,  /* INNER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_CFIs,  /* INNER_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_PRIs,  /* INNER_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID for VLAN tag. Applicable only when\n TAG_STRUCTURE is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_TPIDs,  /* INNER_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inner TPID for VLAN tag. Applicable only when\n  TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 type of service.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 time to live.",
    },
    {
        .name  = FLOW_LABELs,  /* FLOW_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "IPv6 flow label.",
    },
    {
        .name  = DST_L4_UDP_PORTs,  /* DST_L4_UDP_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 UDP destination port.",
    },
    {
        .name  = SRC_L4_UDP_PORTs,  /* SRC_L4_UDP_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 UDP source port.",
    },
    {
        .name  = UDP_CHKSUMs,  /* UDP_CHKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable UDP checksum calculation for the packets\n sent to the collector.\n",
    },
    {
        .name  = SYSTEM_ID_LENs,  /* SYSTEM_ID_LEN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Protobuf system ID length. Applicable when the WIRE_FORMAT\n field in the MON_EXPORT_PROFILE table is PROTOBUF.\n",
    },
    {
        .name  = SYSTEM_IDs,  /* SYSTEM_ID */
        .flags = 0,
        .width = 8,
        .depth = 32,
        .desc = "Identification of the system being monitored. Applicable when\n the WIRE_FORMAT field in the MON_EXPORT_PROFILE table is PROTOBUF.\n",
    },
    {
        .name  = COMPONENT_IDs,  /* COMPONENT_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Component ID of the protobuf. Applicable when the WIRE_FORMAT\n field in the MON_EXPORT_PROFILE table is PROTOBUF.\n",
    },
    {
        .name  = OBSERVATION_DOMAINs,  /* OBSERVATION_DOMAIN */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IP flow information export (IPFIX) observation domain. Applicable\n when the WIRE_FORMAT field in the MON_EXPORT_PROFILE table is IPFIX.\n",
    },
    {
        .name  = IPFIX_ENTERPRISE_NUMBERs,  /* IPFIX_ENTERPRISE_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IP flow information export (IPFIX) enterprise number to be used when\n exporting template sets containing enterprise specific information\n elements. Applicable when the WIRE_FORMAT field in the\n MON_EXPORT_PROFILE table is IPFIX.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_collector_ipv6_t = {
    .name = MON_COLLECTOR_IPV6s, /* MON_COLLECTOR_IPV6 */
    .flags = 0,
    .fields = 27,
    .field = bcmltd_mon_collector_ipv6_t_fields,
    .desc = "The MON_COLLECTOR_IPV6 table is used to specify\n IPv6 collector entity configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_EGR_LDH_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_egr_ldh_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = MONITOR_STATEs,  /* MONITOR_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 16,
        .edata = BCMLTD_COMMON_LDH_MONITOR_STATE_T_DATA,
        .desc = "Monitor state.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_egr_ldh_port_t = {
    .name = MON_EGR_LDH_PORTs, /* MON_EGR_LDH_PORT */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_egr_ldh_port_t_fields,
    .desc = "The MON_EGR_LDH_PORT table specifies the egress logical port\n associated with the latency monitor.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_EGR_REDIRECT_TRACE_EVENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_egr_redirect_trace_event_t_fields[] = {
    {
        .name  = MON_EGR_REDIRECT_TRACE_EVENT_IDs,  /* MON_EGR_REDIRECT_TRACE_EVENT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_EGR_REDIRECT_TRACE_EVENT table.",
    },
    {
        .name  = REDIRECTs,  /* REDIRECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to recirculate the packet into the ingress\n pipeline for the egress trace event.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_egr_redirect_trace_event_t = {
    .name = MON_EGR_REDIRECT_TRACE_EVENTs, /* MON_EGR_REDIRECT_TRACE_EVENT */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_egr_redirect_trace_event_t_fields,
    .desc = "The MON_EGR_REDIRECT_TRACE_EVENT table is used to enable\n recirculating packets into the ingress pipeline for the specified egress\n trace event.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_EGR_REDIRECT_TRACE_EVENT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_egr_redirect_trace_event_control_t_fields[] = {
    {
        .name  = REDIRECTs,  /* REDIRECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to recirculate the packet into the ingress pipeline\n for all of the egress trace events across the device.\n",
    },
    {
        .name  = REDIRECT_PROFILEs,  /* REDIRECT_PROFILE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect profile index used to calculate the index\n into the MON_REDIRECT_PROFILE table for the egress trace events.\n MON_REDIRECT_PROFILE_ID =\n (((Redirect profile index derived from the ingress pipeline) &\n REDIRECT_PROFILE_MASK) | REDIRECT_PROFILE).\n",
    },
    {
        .name  = REDIRECT_PROFILE_MASKs,  /* REDIRECT_PROFILE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask for the redirect profile index used to\n calculate the index into the MON_REDIRECT_PROFILE table\n for the egress trace events.\n MON_REDIRECT_PROFILE_ID =\n (((Redirect profile index derived from the ingress pipeline) &\n REDIRECT_PROFILE_MASK) | REDIRECT_PROFILE).\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_egr_redirect_trace_event_control_t = {
    .name = MON_EGR_REDIRECT_TRACE_EVENT_CONTROLs, /* MON_EGR_REDIRECT_TRACE_EVENT_CONTROL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_mon_egr_redirect_trace_event_control_t_fields,
    .desc = "The MON_EGR_REDIRECT_TRACE_EVENT_CONTROL table is used to\n specify the packet recirculation trace event controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_ETRAP_CANDIDATE_FILTER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_etrap_candidate_filter_t_fields[] = {
    {
        .name  = FILTER_HASH_SELECTs,  /* FILTER_HASH_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 4,
        .desc = "LB hash function for filter table banks\n (0 - MAX_FILTER_BANKS).\n",
    },
    {
        .name  = FILTER_HASH_ROTATE_BITSs,  /* FILTER_HASH_ROTATE_BITS */
        .flags = 0,
        .width = 8,
        .depth = 4,
        .desc = "Specify the bit count for right shifting the\n LB hash function value for filter table banks.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_etrap_candidate_filter_t = {
    .name = MON_ETRAP_CANDIDATE_FILTERs, /* MON_ETRAP_CANDIDATE_FILTER */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_etrap_candidate_filter_t_fields,
    .desc = "The MON_ETRAP_CANDIDATE_FILTER table specifies the\n attributes for elephant trap (ETRAP) filter tables.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_ETRAP_COLOR_ASSIGNMENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_etrap_color_assignment_t_fields[] = {
    {
        .name  = ETRAP_COLORs,  /* ETRAP_COLOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to treat elephant trap (ETRAP) color output as valid.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 16,
        .desc = "Set to enable ETRAP color assignment for the specified internal\n priority value. The color passed to the TM is modified.\n",
    },
    {
        .name  = EGR_COLOR_UPDATEs,  /* EGR_COLOR_UPDATE */
        .flags = 0,
        .width = 1,
        .depth = 16,
        .desc = "Set to update the color passed to the egress pipeline in addition\n to the color output to the TM. Applicable only when TM color\n assignment is enabled by MON_ETRAP_COLOR_ASSIGNMENT.INT_PRI.\n",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Set to enable ETRAP color assignment for the specified egress\n logical port IDs.\n",
    },
    {
        .name  = IPV4_TCPs,  /* IPV4_TCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP color assignment for IPv4 TCP packets.",
    },
    {
        .name  = IPV4_UDPs,  /* IPV4_UDP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP color assignment for IPv4 UDP packets.",
    },
    {
        .name  = IPV4_OTHERs,  /* IPV4_OTHER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP color assignment for non-TCP, non-UDP IPv4\n packets.\n",
    },
    {
        .name  = IPV6_TCPs,  /* IPV6_TCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP color assignment for IPv6 TCP packets.",
    },
    {
        .name  = IPV6_UDPs,  /* IPV6_UDP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP color assignment for IPv6 UDP packets.",
    },
    {
        .name  = IPV6_OTHERs,  /* IPV6_OTHER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP color assignment for non-TCP, non-UDP IPv6\n packets.\n",
    },
    {
        .name  = MPLSs,  /* MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP color assignment for MPLS packets.",
    },
    {
        .name  = NON_IPV4_IPV6_MPLSs,  /* NON_IPV4_IPV6_MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP color assignment for non-IPv4, non-IPv6 and\n non-MPLS packets.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_etrap_color_assignment_t = {
    .name = MON_ETRAP_COLOR_ASSIGNMENTs, /* MON_ETRAP_COLOR_ASSIGNMENT */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_mon_etrap_color_assignment_t_fields,
    .desc = "The MON_ETRAP_COLOR_ASSIGNMENT table provides controls to\n enable/disable color assignment for elephant flows.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_ETRAP_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_etrap_control_t_fields[] = {
    {
        .name  = ETRAPs,  /* ETRAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable elephant trap (ETRAP) processing.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 16,
        .desc = "Set to enable ETRAP processing for the specified internal\n priority values.\n",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Set to enable ETRAP processing for the specified ingress\n logical port IDs.\n",
    },
    {
        .name  = IPV4_TCPs,  /* IPV4_TCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP processing for IPv4 TCP packets.",
    },
    {
        .name  = IPV4_UDPs,  /* IPV4_UDP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP processing for IPv4 UDP packets.",
    },
    {
        .name  = IPV4_OTHERs,  /* IPV4_OTHER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP processing for non-TCP, non-UDP IPv4 packets.",
    },
    {
        .name  = IPV6_TCPs,  /* IPV6_TCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP processing for IPv6 TCP packets.",
    },
    {
        .name  = IPV6_UDPs,  /* IPV6_UDP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP processing for IPv6 UDP packets.",
    },
    {
        .name  = IPV6_OTHERs,  /* IPV6_OTHER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP processing for non-TCP, non-UDP IPv6 packets.",
    },
    {
        .name  = MPLSs,  /* MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP processing for MPLS packets.",
    },
    {
        .name  = NON_IPV4_IPV6_MPLSs,  /* NON_IPV4_IPV6_MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP processing for non-IPv4, non-IPv6 and\n non-MPLS packets.\n",
    },
    {
        .name  = MONITORs,  /* MONITOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP monitoring.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy ETRAP packets to CPU for monitoring.\n Applicable only if MON_ETRAP_CONTROL.MONITOR is enabled.\n",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to send ETRAP packets to mirroring destination\n for monitoring.\n Applicable only if MON_ETRAP_CONTROL.MONITOR is enabled.\n",
    },
    {
        .name  = MONITOR_SEEDs,  /* MONITOR_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Seed for elephant flow monitor random number generator.",
    },
    {
        .name  = SAMPLE_THRESHOLDs,  /* SAMPLE_THRESHOLD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Threshold for sampling packets. Selects the packet for\n mirroring when the random number generated exceeds\n this SAMPLE_THRESHOLD value.\n",
    },
    {
        .name  = MIRROR_ENABLEs,  /* MIRROR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable active elephant flow monitoring mirror per container.\n Array is indexed by container ID.\n",
    },
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "Array of elephant flow monitoring mirror instances\n per container.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_etrap_control_t = {
    .name = MON_ETRAP_CONTROLs, /* MON_ETRAP_CONTROL */
    .flags = 0,
    .fields = 18,
    .field = bcmltd_mon_etrap_control_t_fields,
    .desc = "The MON_ETRAP_CONTROL table provides controls to\n enable or disable elephant trap (ETRAP) processing and to configure\n mirroring of elephant flows for the purpose of monitoring.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_ETRAP_FLOW.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_etrap_flow_t_fields[] = {
    {
        .name  = FLOW_HASH_SELECTs,  /* FLOW_HASH_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 2,
        .desc = "LB hash function for flow table banks\n (0 - MAX_FLOW_BANKS).\n",
    },
    {
        .name  = FLOW_HASH_ROTATE_BITSs,  /* FLOW_HASH_ROTATE_BITS */
        .flags = 0,
        .width = 8,
        .depth = 2,
        .desc = "Specify the bit count for right shifting the\n LB hash function value for flow table banks.\n",
    },
    {
        .name  = ETRAP_INTERVALs,  /* ETRAP_INTERVAL */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Time window for determining the flow rate in the\n flow table.\n",
    },
    {
        .name  = ETRAP_CRITICAL_TIMEs,  /* ETRAP_CRITICAL_TIME */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Time period at the end of ETRAP_INTERVAL. An elephant packet\n arriving in this time window is not demoted from elephant status.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_etrap_flow_t = {
    .name = MON_ETRAP_FLOWs, /* MON_ETRAP_FLOW */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_mon_etrap_flow_t_fields,
    .desc = "The MON_ETRAP_FLOW table specifies the attributes for the\n elephant trap (ETRAP) flow table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_ETRAP_INT_PRI_REMAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_etrap_int_pri_remap_t_fields[] = {
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority to be mapped.\n",
    },
    {
        .name  = NEW_INT_PRIs,  /* NEW_INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "New internal priority of the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_etrap_int_pri_remap_t = {
    .name = MON_ETRAP_INT_PRI_REMAPs, /* MON_ETRAP_INT_PRI_REMAP */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_etrap_int_pri_remap_t_fields,
    .desc = "The MON_ETRAP_INT_PRI_REMAP table is used to map the internal priority\n value of elephant flows into a new internal priority value.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_ETRAP_QUEUE_ASSIGNMENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_etrap_queue_assignment_t_fields[] = {
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 1,
        .depth = 16,
        .desc = "Set to enable ETRAP queue assignment for the specified internal\n priority values.\n",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Set to enable ETRAP queue assignment for the specified egress\n logical port IDs.\n",
    },
    {
        .name  = IPV4_TCPs,  /* IPV4_TCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP queue assignment for IPv4 TCP packets.",
    },
    {
        .name  = IPV4_UDPs,  /* IPV4_UDP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP queue assignment for IPv4 UDP packets.",
    },
    {
        .name  = IPV4_OTHERs,  /* IPV4_OTHER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP queue assignment for non-TCP, non-UDP IPv4\n packets.\n",
    },
    {
        .name  = IPV6_TCPs,  /* IPV6_TCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP queue assignment for IPv6 TCP packets.",
    },
    {
        .name  = IPV6_UDPs,  /* IPV6_UDP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP queue assignment for IPv6 UDP packets.",
    },
    {
        .name  = IPV6_OTHERs,  /* IPV6_OTHER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP queue assignment for non-TCP, non-UDP IPv6\n packets.\n",
    },
    {
        .name  = MPLSs,  /* MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP queue assignment for MPLS packets.",
    },
    {
        .name  = NON_IPV4_IPV6_MPLSs,  /* NON_IPV4_IPV6_MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ETRAP queue assignment for non-IPv4, non-IPv6 and\n non-MPLS packets.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_etrap_queue_assignment_t = {
    .name = MON_ETRAP_QUEUE_ASSIGNMENTs, /* MON_ETRAP_QUEUE_ASSIGNMENT */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_mon_etrap_queue_assignment_t_fields,
    .desc = "The MON_ETRAP_QUEUE_ASSIGNMENT table provides controls to\n configure queue assignment actions for elephant flows.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_ETRAP_THRESHOLD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_etrap_threshold_t_fields[] = {
    {
        .name  = CANDIDATE_BYTESs,  /* CANDIDATE_BYTES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Byte count threshold to qualify a flow as a candidate\n elephant. A flow whose byte count exceeds this threshold during\n the MON_ETRAP_FLOW.ETRAP_INTERVAL is inserted into the flow table\n as a potential elephant.\n",
    },
    {
        .name  = ELEPHANT_GREEN_BYTESs,  /* ELEPHANT_GREEN_BYTES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Byte count threshold to qualify a flow as an elephant.\n A flow whose byte count exceeds this threshold during the\n MON_ETRAP_FLOW.ETRAP_INTERVAL is promoted to an elephant\n from a potential elephant. Packet color is considered to\n be GREEN unless it exceeds ELEPHANT_RED_BYTES or\n ELEPHANT_YELLOW_BYTES.\n",
    },
    {
        .name  = ELEPHANT_YELLOW_BYTESs,  /* ELEPHANT_YELLOW_BYTES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Byte count threshold to determine the packet color as YELLOW.\n If the flow byte count exceeds this threshold and is below\n ELEPHANT_RED_BYTES, then the packet is considered as YELLOW.\n",
    },
    {
        .name  = ELEPHANT_RED_BYTESs,  /* ELEPHANT_RED_BYTES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Byte count threshold to determine the packet color as RED.\n If the flow byte count exceeds this threshold, then the\n packet is considered as RED.\n",
    },
    {
        .name  = RESET_BYTESs,  /* RESET_BYTES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Byte count threshold to be met by an existing elephant flow to\n continue to be considered as an elephant. An elephant flow that\n does not meet this threshold during the\n MON_ETRAP_FLOW.ETRAP_INTERVAL is demoted from elephant status.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_etrap_threshold_t = {
    .name = MON_ETRAP_THRESHOLDs, /* MON_ETRAP_THRESHOLD */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_mon_etrap_threshold_t_fields,
    .desc = "The MON_ETRAP_THRESHOLD table is used to specify\n the various elephant trap (ETRAP) thresholds.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_EVENT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_event_control_t_fields[] = {
    {
        .name  = TRACE_MIRROR_INSTANCE_ID_0s,  /* TRACE_MIRROR_INSTANCE_ID_0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Trace event mirror instance for session 0.",
    },
    {
        .name  = TRACE_MIRROR_INSTANCE_ID_1s,  /* TRACE_MIRROR_INSTANCE_ID_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Trace event mirror instance for session 1.",
    },
    {
        .name  = TRACE_MIRROR_INSTANCE_ID_2s,  /* TRACE_MIRROR_INSTANCE_ID_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Trace event mirror instance for session 2.",
    },
    {
        .name  = TRACE_MIRROR_INSTANCE_ID_3s,  /* TRACE_MIRROR_INSTANCE_ID_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Trace event mirror instance for session 3.",
    },
    {
        .name  = TRACE_MIRROR_INSTANCE_ID_4s,  /* TRACE_MIRROR_INSTANCE_ID_4 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Trace event mirror instance for session 4.",
    },
    {
        .name  = TRACE_MIRROR_INSTANCE_ID_5s,  /* TRACE_MIRROR_INSTANCE_ID_5 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Trace event mirror instance for session 5.",
    },
    {
        .name  = TRACE_MIRROR_INSTANCE_ID_6s,  /* TRACE_MIRROR_INSTANCE_ID_6 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Trace event mirror instance for session 6.",
    },
    {
        .name  = TRACE_MIRROR_INSTANCE_ID_7s,  /* TRACE_MIRROR_INSTANCE_ID_7 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Trace event mirror instance for session 7.",
    },
    {
        .name  = DROP_MIRROR_SESSION_IDs,  /* DROP_MIRROR_SESSION_ID */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Drop event mirror session.",
    },
    {
        .name  = DROP_MIRROR_INSTANCE_IDs,  /* DROP_MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Drop event mirror instance.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_event_control_t = {
    .name = MON_EVENT_CONTROLs, /* MON_EVENT_CONTROL */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_mon_event_control_t_fields,
    .desc = "The MON_EVENT_CONTROL table specifies device level trace and drop controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_EXPORT_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_export_profile_t_fields[] = {
    {
        .name  = MON_EXPORT_PROFILE_IDs,  /* MON_EXPORT_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_EXPORT_PROFILE table.",
    },
    {
        .name  = WIRE_FORMATs,  /* WIRE_FORMAT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_WIRE_FORMAT_T_DATA,
        .desc = "Wire format to be used for data export.",
    },
    {
        .name  = INTERVALs,  /* INTERVAL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Export interval in micro seconds.",
    },
    {
        .name  = PACKET_LEN_INDICATORs,  /* PACKET_LEN_INDICATOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_EXPORT_PACKET_LEN_INDICATOR_T_DATA,
        .desc = "Export packet length indicator.",
    },
    {
        .name  = MAX_PKT_LENGTHs,  /* MAX_PKT_LENGTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum possible export packet length in bytes.\n Applicable when field PACKET_LEN_INDICATOR is\n set to MAX_PKT_LENGTH.\n",
    },
    {
        .name  = NUM_RECORDSs,  /* NUM_RECORDS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of records to be sent in one packet.\n Applicable when field PACKET_LEN_INDICATOR is\n set to NUM_RECORDS.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_export_profile_t = {
    .name = MON_EXPORT_PROFILEs, /* MON_EXPORT_PROFILE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_mon_export_profile_t_fields,
    .desc = "The MON_EXPORT_PROFILE table is used to configure the\n parameters needed for statistics export to a collector.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWCOUNT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowcount_control_t_fields[] = {
    {
        .name  = SHIFTs,  /* SHIFT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Right shift amount applied to the hash value generated by\n LB_HASH.\n",
    },
    {
        .name  = MASKs,  /* MASK */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Mask ORed to shifted hash value.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowcount_control_t = {
    .name = MON_FLOWCOUNT_CONTROLs, /* MON_FLOWCOUNT_CONTROL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_mon_flowcount_control_t_fields,
    .desc = "The MON_FLOWCOUNT_CONTROL table specifies the flow count configuration\n attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWTRACKER_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowtracker_control_t_fields[] = {
    {
        .name  = FLOWTRACKERs,  /* FLOWTRACKER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable flowtracker feature.",
    },
    {
        .name  = OBSERVATION_DOMAINs,  /* OBSERVATION_DOMAIN */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Configure device level IPFIX observation domain. Observation domain\n is a unique 32 bit number that is assigned to an exporting device\n for the collecting device to uniquely identify the exporting device\n as per IPFIX RFC 7011.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = MAX_GROUPSs,  /* MAX_GROUPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of flowtracker groups. If the flowtracker embedded\n application has been initialized (FLOWTRACKER is enabled), it must\n be restarted by toggling FLOWTRACKER in order for this field to take\n effect.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = MAX_GROUPS_OPERs,  /* MAX_GROUPS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational maximum number of flowtracker groups. This is a\n read-only field which reflects the maximum number of flowtracker\n groups value that is currently in use.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = MAX_EXPORT_LENGTHs,  /* MAX_EXPORT_LENGTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum export packet length in bytes.\n If the flowtracker embedded application has been initialized\n (FLOWTRACKER is enabled), it must be restarted by toggling\n FLOWTRACKER in order for this field to take effect.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = MAX_EXPORT_LENGTH_OPERs,  /* MAX_EXPORT_LENGTH_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational maximum export length. This is a read-only field which\n reflects the maximum export length value that is currently in use.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = MAX_FLOWSs,  /* MAX_FLOWS */
        .flags = 0,
        .width = 32,
        .depth = 4,
        .desc = "Maximum number of flows that can be learnt by the flowtracker\n embedded application per pipe. If the flowtracker embedded\n application has been initialized (FLOWTRACKER is enabled),\n it must be restarted by toggling FLOWTRACKER in order for\n this field to take effect.\n",
    },
    {
        .name  = MAX_FLOWS_OPERs,  /* MAX_FLOWS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 4,
        .desc = "Operational maximum number of flows.\n This is a read-only field which reflects the maximum number\n of flows value that is currently in use.\n",
    },
    {
        .name  = PKT_BYTE_CTR_ING_EFLEX_ACTION_PROFILE_IDs,  /* PKT_BYTE_CTR_ING_EFLEX_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_ACTION_PROFILE table\n used for allocating flex counters to the flowtracker embedded\n application. These flex counters are used for\n counting packet and byte counts for learnt flows.\n If the flowtracker embedded application\n has been initialized (FLOWTRACKER is enabled),\n it must be restarted by toggling FLOWTRACKER in order for\n this field to take effect.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = PKT_BYTE_CTR_ING_EFLEX_ACTION_PROFILE_ID_OPERs,  /* PKT_BYTE_CTR_ING_EFLEX_ACTION_PROFILE_ID_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational index into the CTR_ING_EFLEX_ACTION_PROFILE table\n used for allocating flex counters to the flowtracker embedded\n application. This is a read-only field which reflects\n the flex counter action profile used for counting packet\n and byte counts of learnt flows currently in use by flowtracker\n embedded application.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = DOUBLE_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_IDs,  /* DOUBLE_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_ACTION_PROFILE table\n used for allocating flex counters to the flowtracker embedded\n application. These flex counters are used for\n storing hit indices of double base entry wide exact match entries.\n If the flowtracker embedded application\n has been initialized (FLOWTRACKER is enabled),\n it must be restarted by toggling FLOWTRACKER in order for\n this field to take effect.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = DOUBLE_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_ID_OPERs,  /* DOUBLE_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_ID_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational index into the CTR_ING_EFLEX_ACTION_PROFILE table\n used for allocating flex counters to the flowtracker embedded\n application. This is a read-only field which reflects\n the flex counter action profile used for storing hit indices\n of double base entry wide exact match entries currently\n in use by flowtracker embedded application.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = QUAD_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_IDs,  /* QUAD_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the CTR_ING_EFLEX_ACTION_PROFILE table\n used for allocating flex counters to the flowtracker embedded\n application. These flex counters are used for\n storing hit indices of quad base entry wide exact match entries.\n If the flowtracker embedded application\n has been initialized (FLOWTRACKER is enabled),\n it must be restarted by toggling FLOWTRACKER in order for\n this field to take effect.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = QUAD_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_ID_OPERs,  /* QUAD_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_ID_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational index into the CTR_ING_EFLEX_ACTION_PROFILE table\n used for allocating flex counters to the flowtracker embedded\n application. This is a read-only field which reflects\n the flex counter action profile used for storing hit indices\n of quad base entry wide exact match entries currently\n in use by flowtracker embedded application.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = DOUBLE_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_GROUP_ACTIONs,  /* DOUBLE_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_GROUP_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Hardware flex counter group action which is used for grouping flex\n counter actions represented by\n PKT_BYTE_CTR_ING_EFLEX_ACTION_PROFILE_ID\n and DOUBLE_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_ID.\n If the flowtracker embedded application\n has been initialized (FLOWTRACKER is enabled),\n it must be restarted by toggling FLOWTRACKER in order for\n this field to take effect.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = DOUBLE_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_GROUP_ACTION_OPERs,  /* DOUBLE_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_GROUP_ACTION_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational hardware flex counter group action which is used for\n grouping flex counter actions represented by\n PKT_BYTE_CTR_ING_EFLEX_ACTION_PROFILE_ID\n and DOUBLE_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_ID.\n This is a read-only field.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = QUAD_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_GROUP_ACTIONs,  /* QUAD_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_GROUP_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Hardware flex counter group action which is used for grouping flex\n counter actions represented by\n PKT_BYTE_CTR_ING_EFLEX_ACTION_PROFILE_ID\n and QUAD_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_ID.\n If the flowtracker embedded application\n has been initialized (FLOWTRACKER is enabled),\n it must be restarted by toggling FLOWTRACKER in order for\n this field to take effect.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = QUAD_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_GROUP_ACTION_OPERs,  /* QUAD_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_GROUP_ACTION_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational hardware flex counter group action which is used for\n grouping flex counter actions represented by\n PKT_BYTE_CTR_ING_EFLEX_ACTION_PROFILE_ID\n and QUAD_ENTRY_WIDE_HITBIT_CTR_ING_EFLEX_ACTION_PROFILE_ID.\n This is a read-only field.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = ETRAPs,  /* ETRAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to make flowtracker embedded app function in elephant\n trap mode. If the flowtracker embedded application has been\n initialized (FLOWTRACKER is enabled), it must be restarted by\n toggling FLOWTRACKER in order for this field to take effect.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = ETRAP_OPERs,  /* ETRAP_OPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Operational elephant trap mode enable. This is a read-only field\n which reflects the elephant trap mode enable value that is\n currently in use.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = SCAN_INTERVAL_USECSs,  /* SCAN_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Periodic interval at which flex counter tables are scanned\n in microseconds. If the flowtracker embedded application has\n been initialized (FLOWTRACKER is enabled), it must be restarted\n by toggling FLOWTRACKER in order for this field to take effect.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = SCAN_INTERVAL_USECS_OPERs,  /* SCAN_INTERVAL_USECS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational scan interval in microseconds. This is a read-only field\n which reflects the scan interval value that is currently in use.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = FLOW_START_TIMESTAMP_ENABLEs,  /* FLOW_START_TIMESTAMP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to turn on flow start timestamp feature. If the flowtracker\n embedded application has been initialized (FLOWTRACKER is enabled),\n it must be restarted by toggling FLOWTRACKER in order for this field\n to take effect.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = FLOW_START_TIMESTAMP_ENABLE_OPERs,  /* FLOW_START_TIMESTAMP_ENABLE_OPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Operational flow start timestamp feature enable. This is a read-only\n field which reflects the flow start timestamp feature enable value\n that is currently in use.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = HOST_MEMs,  /* HOST_MEM */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enable to use HOST CPU memory for flowtracker embedded application\n to allocate its data structures.\n If the flowtracker embedded application has been initialized\n (FLOWTRACKER is enabled),\n it must be restarted by toggling FLOWTRACKER in order for\n this field to take effect.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = HOST_MEM_OPERs,  /* HOST_MEM_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational value of HOST_MEM field.\n This is a read-only field which reflects\n the HOST CPU memory usage by flowtracker embedded application\n currently.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = HARDWARE_LEARNs,  /* HARDWARE_LEARN */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLOWTRACKER_HARDWARE_LEARN_T_DATA,
        .desc = "Hardware learn mechanism.\n If the FLOWTRACKER is enabled, it must toggled in order\n for this field to take effect.\n",
    },
    {
        .name  = HARDWARE_LEARN_OPERs,  /* HARDWARE_LEARN_OPER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLOWTRACKER_HARDWARE_LEARN_T_DATA,
        .desc = "Operational hardware learn mechanism.\n This is a read-only field which reflects\n the current hardware learn mechanism.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_MON_FLOWTRACKER_CONTROL_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of\n the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowtracker_control_t = {
    .name = MON_FLOWTRACKER_CONTROLs, /* MON_FLOWTRACKER_CONTROL */
    .flags = 0,
    .fields = 29,
    .field = bcmltd_mon_flowtracker_control_t_fields,
    .desc = "The MON_FLOWTRACKER_CONTROL table is used to configure chip-wide\n flowtracker embedded application properties.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWTRACKER_ELEPHANT_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowtracker_elephant_profile_t_fields[] = {
    {
        .name  = MON_FLOWTRACKER_ELEPHANT_PROFILE_IDs,  /* MON_FLOWTRACKER_ELEPHANT_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_FLOWTRACKER_ELEPHANT_PROFILE table.",
    },
    {
        .name  = NUM_PROMOTION_FILTERSs,  /* NUM_PROMOTION_FILTERS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of promotion filters.",
    },
    {
        .name  = PROMOTION_FILTERS_INCR_RATEs,  /* PROMOTION_FILTERS_INCR_RATE */
        .flags = 0,
        .width = 1,
        .depth = 2,
        .desc = "Promotion filters to promote a flow to elephant.",
    },
    {
        .name  = PROMOTION_FILTERS_MONITOR_INTERVAL_USECSs,  /* PROMOTION_FILTERS_MONITOR_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 2,
        .desc = "Promotion filters to promote a flow to elephant.",
    },
    {
        .name  = PROMOTION_FILTERS_RATE_LOW_THRESHOLD_KBITS_SECs,  /* PROMOTION_FILTERS_RATE_LOW_THRESHOLD_KBITS_SEC */
        .flags = 0,
        .width = 32,
        .depth = 2,
        .desc = "Promotion filters to promote a flow to elephant.",
    },
    {
        .name  = PROMOTION_FILTERS_RATE_HIGH_THRESHOLD_KBITS_SECs,  /* PROMOTION_FILTERS_RATE_HIGH_THRESHOLD_KBITS_SEC */
        .flags = 0,
        .width = 32,
        .depth = 2,
        .desc = "Promotion filters to promote a flow to elephant.",
    },
    {
        .name  = PROMOTION_FILTERS_SIZE_THRESHOLD_BYTESs,  /* PROMOTION_FILTERS_SIZE_THRESHOLD_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 2,
        .desc = "Promotion filters to promote a flow to elephant.",
    },
    {
        .name  = DEMOTION_FILTER_INCR_RATEs,  /* DEMOTION_FILTER_INCR_RATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Demotion filter to demote a flow to mouse.",
    },
    {
        .name  = DEMOTION_FILTER_MONITOR_INTERVAL_USECSs,  /* DEMOTION_FILTER_MONITOR_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Demotion filter to demote a flow to mouse.",
    },
    {
        .name  = DEMOTION_FILTER_RATE_LOW_THRESHOLD_KBITS_SECs,  /* DEMOTION_FILTER_RATE_LOW_THRESHOLD_KBITS_SEC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Demotion filter to demote a flow to mouse.",
    },
    {
        .name  = DEMOTION_FILTER_RATE_HIGH_THRESHOLD_KBITS_SECs,  /* DEMOTION_FILTER_RATE_HIGH_THRESHOLD_KBITS_SEC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Demotion filter to demote a flow to mouse.",
    },
    {
        .name  = DEMOTION_FILTER_SIZE_THRESHOLD_BYTESs,  /* DEMOTION_FILTER_SIZE_THRESHOLD_BYTES */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Demotion filter to demote a flow to mouse.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowtracker_elephant_profile_t = {
    .name = MON_FLOWTRACKER_ELEPHANT_PROFILEs, /* MON_FLOWTRACKER_ELEPHANT_PROFILE */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_mon_flowtracker_elephant_profile_t_fields,
    .desc = "The MON_FLOWTRACKER_ELEPHANT_PROFILE table is used for configuring\n elephant trap promotion and demotion filters.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWTRACKER_EXPORT_TEMPLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowtracker_export_template_t_fields[] = {
    {
        .name  = MON_FLOWTRACKER_EXPORT_TEMPLATE_IDs,  /* MON_FLOWTRACKER_EXPORT_TEMPLATE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_FLOWTRACKER_EXPORT_TEMPLATE table.",
    },
    {
        .name  = SET_IDs,  /* SET_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "IPFIX set ID for the template.",
    },
    {
        .name  = NUM_EXPORT_ELEMENTSs,  /* NUM_EXPORT_ELEMENTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of export elements in the template.",
    },
    {
        .name  = EXPORT_ELEMENTS_TYPEs,  /* EXPORT_ELEMENTS_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 9,
        .edata = BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_DATA,
        .desc = "The list of export elements in the template.",
    },
    {
        .name  = EXPORT_ELEMENTS_DATA_SIZEs,  /* EXPORT_ELEMENTS_DATA_SIZE */
        .flags = 0,
        .width = 32,
        .depth = 9,
        .desc = "The list of export elements in the template.",
    },
    {
        .name  = EXPORT_ELEMENTS_ENTERPRISEs,  /* EXPORT_ELEMENTS_ENTERPRISE */
        .flags = 0,
        .width = 1,
        .depth = 9,
        .desc = "The list of export elements in the template.",
    },
    {
        .name  = EXPORT_ELEMENTS_ENTERPRISE_IDs,  /* EXPORT_ELEMENTS_ENTERPRISE_ID */
        .flags = 0,
        .width = 16,
        .depth = 9,
        .desc = "The list of export elements in the template.",
    },
    {
        .name  = COLLECTOR_TYPEs,  /* COLLECTOR_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_MON_COLLECTOR_TYPE_T_DATA,
        .desc = "Specifies the collector type",
    },
    {
        .name  = MON_COLLECTOR_IPV4_IDs,  /* MON_COLLECTOR_IPV4_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_COLLECTOR_IPV4 table, if the collector to\n which the IPFIX template set for this export template needs to\n be periodically transmitted is an IPV4 collector. Applicable\n only if COLLECTOR_TYPE == IPV4.\n",
    },
    {
        .name  = MON_COLLECTOR_IPV6_IDs,  /* MON_COLLECTOR_IPV6_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_COLLECTOR_IPV6 table, if the collector to\n which the IPFIX template set for this export template needs to\n be periodically transmitted is an IPV6 collector.Applicable\n only if COLLECTOR_TYPE == IPV6.\n",
    },
    {
        .name  = TRANSMIT_INTERVALs,  /* TRANSMIT_INTERVAL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Interval in seconds at which the IPFIX template set has to be\n transmitted.\n",
    },
    {
        .name  = INITIAL_BURSTs,  /* INITIAL_BURST */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of times the IPFIX template set needs to be sent before\n settling to a periodic export.\n",
    },
    {
        .name  = OPERATIONAL_STATUSs,  /* OPERATIONAL_STATUS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_MON_FLOWTRACKER_EXPORT_TEMPLATE_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational\n state of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowtracker_export_template_t = {
    .name = MON_FLOWTRACKER_EXPORT_TEMPLATEs, /* MON_FLOWTRACKER_EXPORT_TEMPLATE */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_mon_flowtracker_export_template_t_fields,
    .desc = "The MON_FLOWTRACKER_EXPORT_TEMPLATE table is used to specify\n the IPFIX template in which flow information is exported.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWTRACKER_FLOW_DATA.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowtracker_flow_data_t_fields[] = {
    {
        .name  = MON_FLOWTRACKER_GROUP_IDs,  /* MON_FLOWTRACKER_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_FLOWTRACKER_GROUP table.",
    },
    {
        .name  = FLOW_KEY_SRC_IPV4s,  /* FLOW_KEY_SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_DST_IPV4s,  /* FLOW_KEY_DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_SRC_L4_PORTs,  /* FLOW_KEY_SRC_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_DST_L4_PORTs,  /* FLOW_KEY_DST_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_IP_PROTOs,  /* FLOW_KEY_IP_PROTO */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_INNER_SRC_IPV4s,  /* FLOW_KEY_INNER_SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_INNER_DST_IPV4s,  /* FLOW_KEY_INNER_DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_INNER_SRC_L4_PORTs,  /* FLOW_KEY_INNER_SRC_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_INNER_DST_L4_PORTs,  /* FLOW_KEY_INNER_DST_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_INNER_IP_PROTOs,  /* FLOW_KEY_INNER_IP_PROTO */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_VNIDs,  /* FLOW_KEY_VNID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_CUSTOM_KEY_UPPERs,  /* FLOW_KEY_CUSTOM_KEY_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_CUSTOM_KEY_LOWERs,  /* FLOW_KEY_CUSTOM_KEY_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_ING_PORT_IDs,  /* FLOW_KEY_ING_PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_INNER_SRC_IPV6_UPPERs,  /* FLOW_KEY_INNER_SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_INNER_SRC_IPV6_LOWERs,  /* FLOW_KEY_INNER_SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_INNER_DST_IPV6_UPPERs,  /* FLOW_KEY_INNER_DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = FLOW_KEY_INNER_DST_IPV6_LOWERs,  /* FLOW_KEY_INNER_DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Key corresponding to the flow whose data is to be retrieved.",
    },
    {
        .name  = DATA_PKT_COUNTs,  /* DATA_PKT_COUNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Flow data associated with the flow.",
    },
    {
        .name  = DATA_BYTE_COUNTs,  /* DATA_BYTE_COUNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Flow data associated with the flow.",
    },
    {
        .name  = DATA_FLOW_START_TIMESTAMP_MSECSs,  /* DATA_FLOW_START_TIMESTAMP_MSECS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Flow data associated with the flow.",
    },
    {
        .name  = DATA_OBSERVATION_TIMESTAMP_MSECSs,  /* DATA_OBSERVATION_TIMESTAMP_MSECS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Flow data associated with the flow.",
    },
    {
        .name  = STATICs,  /* STATIC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if flow was statically installed by the application.\n Disabled if flow was dynamically learnt by the flowtracker\n embedded application.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowtracker_flow_data_t = {
    .name = MON_FLOWTRACKER_FLOW_DATAs, /* MON_FLOWTRACKER_FLOW_DATA */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 24,
    .field = bcmltd_mon_flowtracker_flow_data_t_fields,
    .desc = "The MON_FLOWTRACKER_FLOW_DATA table is used to get a flow's\n data identified by the flow keys within a flow group.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWTRACKER_FLOW_STATIC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowtracker_flow_static_t_fields[] = {
    {
        .name  = MON_FLOWTRACKER_GROUP_IDs,  /* MON_FLOWTRACKER_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_FLOWTRACKER_GROUP table.",
    },
    {
        .name  = FLOW_KEY_SRC_IPV4s,  /* FLOW_KEY_SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_DST_IPV4s,  /* FLOW_KEY_DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_SRC_L4_PORTs,  /* FLOW_KEY_SRC_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_DST_L4_PORTs,  /* FLOW_KEY_DST_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_IP_PROTOs,  /* FLOW_KEY_IP_PROTO */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_INNER_SRC_IPV4s,  /* FLOW_KEY_INNER_SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_INNER_DST_IPV4s,  /* FLOW_KEY_INNER_DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_INNER_SRC_L4_PORTs,  /* FLOW_KEY_INNER_SRC_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_INNER_DST_L4_PORTs,  /* FLOW_KEY_INNER_DST_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_INNER_IP_PROTOs,  /* FLOW_KEY_INNER_IP_PROTO */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_VNIDs,  /* FLOW_KEY_VNID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_CUSTOM_KEY_UPPERs,  /* FLOW_KEY_CUSTOM_KEY_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_CUSTOM_KEY_LOWERs,  /* FLOW_KEY_CUSTOM_KEY_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_ING_PORT_IDs,  /* FLOW_KEY_ING_PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_INNER_SRC_IPV6_UPPERs,  /* FLOW_KEY_INNER_SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_INNER_SRC_IPV6_LOWERs,  /* FLOW_KEY_INNER_SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_INNER_DST_IPV6_UPPERs,  /* FLOW_KEY_INNER_DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
    {
        .name  = FLOW_KEY_INNER_DST_IPV6_LOWERs,  /* FLOW_KEY_INNER_DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Keys corresponding to the flow.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowtracker_flow_static_t = {
    .name = MON_FLOWTRACKER_FLOW_STATICs, /* MON_FLOWTRACKER_FLOW_STATIC */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 19,
    .field = bcmltd_mon_flowtracker_flow_static_t_fields,
    .desc = "The MON_FLOWTRACKER_FLOW_STATIC table is used to create an\n application specified static flow entry in the exact match\n table for tracking a flow.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWTRACKER_GROUP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowtracker_group_t_fields[] = {
    {
        .name  = MON_FLOWTRACKER_GROUP_IDs,  /* MON_FLOWTRACKER_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_FLOWTRACKER_GROUP table.",
    },
    {
        .name  = LEARNs,  /* LEARN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate to the flowtracker embedded application to\n start learning flows. If disabled, indicates flowtracker\n embedded application to stop learning and delete all\n the learnt flows.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = DT_EM_GRP_TEMPLATE_IDs,  /* DT_EM_GRP_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the DT_EM_GRP_TEMPLATE table. This index corresponds\n to the EM group created for tracking flows based on the flowtracker\n group tracking parameters defined in the TRACKING_PARAMETERS field.\n",
    },
    {
        .name  = NUM_TRACKING_PARAMETERSs,  /* NUM_TRACKING_PARAMETERS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of flow tracking parameters used to track a flow.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = TRACKING_PARAMETERS_TYPEs,  /* TRACKING_PARAMETERS_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .edata = BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_DATA,
        .desc = "List of flow tracking parameters used to track a flow.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = TRACKING_PARAMETERS_UDF_POLICY_IDs,  /* TRACKING_PARAMETERS_UDF_POLICY_ID */
        .flags = 0,
        .width = 16,
        .depth = 8,
        .desc = "List of flow tracking parameters used to track a flow.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = FLOW_LIMITs,  /* FLOW_LIMIT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of flows that can be learnt on this group.",
    },
    {
        .name  = AGING_INTERVAL_MSs,  /* AGING_INTERVAL_MS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Interval in milliseconds after which flows are aged out\n (removed from the flow table) if the flow is idle.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = NUM_EXPORT_TRIGGERSs,  /* NUM_EXPORT_TRIGGERS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of export triggers. Used to indicate the number of valid\n export triggers filled into the EXPORT_TRIGGERS field.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = EXPORT_TRIGGERSs,  /* EXPORT_TRIGGERS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 4,
        .edata = BCMLTD_COMMON_FLOWTRACKER_EXPORT_TRIGGER_TYPE_T_DATA,
        .desc = "List of triggers/events on which export to collector happens.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = NUM_ACTIONSs,  /* NUM_ACTIONS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of actions that are configured on the flow group.",
    },
    {
        .name  = ACTIONS_TYPEs,  /* ACTIONS_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 11,
        .edata = BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_DATA,
        .desc = "List of actions that are configured on the flow group.",
    },
    {
        .name  = ACTIONS_EM_FT_OPAQUE_OBJ0_VALs,  /* ACTIONS_EM_FT_OPAQUE_OBJ0_VAL */
        .flags = 0,
        .width = 16,
        .depth = 11,
        .desc = "List of actions that are configured on the flow group.",
    },
    {
        .name  = ACTIONS_EM_FT_IOAM_GBP_ACTION_VALs,  /* ACTIONS_EM_FT_IOAM_GBP_ACTION_VAL */
        .flags = 0,
        .width = 4,
        .depth = 11,
        .desc = "List of actions that are configured on the flow group.",
    },
    {
        .name  = ACTIONS_EM_FT_COPY_TO_CPU_VALs,  /* ACTIONS_EM_FT_COPY_TO_CPU_VAL */
        .flags = 0,
        .width = 1,
        .depth = 11,
        .desc = "List of actions that are configured on the flow group.",
    },
    {
        .name  = ACTIONS_EM_FT_DROP_ACTION_VALs,  /* ACTIONS_EM_FT_DROP_ACTION_VAL */
        .flags = 0,
        .width = 1,
        .depth = 11,
        .desc = "List of actions that are configured on the flow group.",
    },
    {
        .name  = ACTIONS_DESTINATION_VALs,  /* ACTIONS_DESTINATION_VAL */
        .flags = 0,
        .width = 16,
        .depth = 11,
        .desc = "List of actions that are configured on the flow group.",
    },
    {
        .name  = ACTIONS_DESTINATION_TYPE_VALs,  /* ACTIONS_DESTINATION_TYPE_VAL */
        .flags = 0,
        .width = 4,
        .depth = 11,
        .desc = "List of actions that are configured on the flow group.",
    },
    {
        .name  = ACTIONS_EM_FT_FLEX_STATE_ACTION_VALs,  /* ACTIONS_EM_FT_FLEX_STATE_ACTION_VAL */
        .flags = 0,
        .width = 4,
        .depth = 11,
        .desc = "List of actions that are configured on the flow group.",
    },
    {
        .name  = ACTIONS_FLEX_CTR_ACTION_VALs,  /* ACTIONS_FLEX_CTR_ACTION_VAL */
        .flags = 0,
        .width = 6,
        .depth = 11,
        .desc = "List of actions that are configured on the flow group.",
    },
    {
        .name  = ACTIONS_PKT_FLOW_ELIGIBILITY_VALs,  /* ACTIONS_PKT_FLOW_ELIGIBILITY_VAL */
        .flags = 0,
        .width = 6,
        .depth = 11,
        .desc = "List of actions that are configured on the flow group.",
    },
    {
        .name  = ACTIONS_L2_IIF_SVP_MIRROR_INDEX_0_VALs,  /* ACTIONS_L2_IIF_SVP_MIRROR_INDEX_0_VAL */
        .flags = 0,
        .width = 4,
        .depth = 11,
        .desc = "List of actions that are configured on the flow group.",
    },
    {
        .name  = MON_FLOWTRACKER_ELEPHANT_PROFILE_IDs,  /* MON_FLOWTRACKER_ELEPHANT_PROFILE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_FLOWTRACKER_ELEPHANT_PROFILE table.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of\n the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowtracker_group_t = {
    .name = MON_FLOWTRACKER_GROUPs, /* MON_FLOWTRACKER_GROUP */
    .flags = 0,
    .fields = 24,
    .field = bcmltd_mon_flowtracker_group_t_fields,
    .desc = "The MON_FLOWTRACKER_GROUP table is used to configure a flowtracker\n flow group's properties. A flow group is a collection of flows where\n each flow is characterized by a flow tuple (for example, IPv4 SIP, DIP,\n L4 SRC SPORT, DPORT, IP PROTOCOL).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWTRACKER_GROUP_COLLECTOR_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowtracker_group_collector_map_t_fields[] = {
    {
        .name  = MON_FLOWTRACKER_GROUP_COLLECTOR_MAP_IDs,  /* MON_FLOWTRACKER_GROUP_COLLECTOR_MAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_FLOWTRACKER_GROUP_COLLECTOR_MAP table.",
    },
    {
        .name  = MON_FLOWTRACKER_GROUP_IDs,  /* MON_FLOWTRACKER_GROUP_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_FLOWTRACKER_GROUP table.",
    },
    {
        .name  = COLLECTOR_TYPEs,  /* COLLECTOR_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_MON_COLLECTOR_TYPE_T_DATA,
        .desc = "Collector type.",
    },
    {
        .name  = MON_COLLECTOR_IPV4_IDs,  /* MON_COLLECTOR_IPV4_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_COLLECTOR_IPV4 table, if the collector is\n an IPV4 collector. Applicable only if COLLECTOR_TYPE == IPV4.\n",
    },
    {
        .name  = MON_COLLECTOR_IPV6_IDs,  /* MON_COLLECTOR_IPV6_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_COLLECTOR_IPV6 table, if the collector is\n an IPV6 collector. Applicable only if COLLECTOR_TYPE == IPV6.\n",
    },
    {
        .name  = MON_EXPORT_PROFILE_IDs,  /* MON_EXPORT_PROFILE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_EXPORT_PROFILE table.",
    },
    {
        .name  = MON_FLOWTRACKER_EXPORT_TEMPLATE_IDs,  /* MON_FLOWTRACKER_EXPORT_TEMPLATE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_FLOWTRACKER_EXPORT_TEMPLATE table.",
    },
    {
        .name  = OPERATIONAL_STATUSs,  /* OPERATIONAL_STATUS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_COLLECTOR_MAP_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational\n state of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowtracker_group_collector_map_t = {
    .name = MON_FLOWTRACKER_GROUP_COLLECTOR_MAPs, /* MON_FLOWTRACKER_GROUP_COLLECTOR_MAP */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_mon_flowtracker_group_collector_map_t_fields,
    .desc = "The MON_FLOWTRACKER_GROUP_COLLECTOR_MAP table is used to\n provide mapping of flowtracker group to collector, export\n profile and export template.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWTRACKER_GROUP_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowtracker_group_status_t_fields[] = {
    {
        .name  = MON_FLOWTRACKER_GROUP_IDs,  /* MON_FLOWTRACKER_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_FLOWTRACKER_GROUP table.",
    },
    {
        .name  = FLOW_COUNTs,  /* FLOW_COUNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of flows learnt in this group.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowtracker_group_status_t = {
    .name = MON_FLOWTRACKER_GROUP_STATUSs, /* MON_FLOWTRACKER_GROUP_STATUS */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_flowtracker_group_status_t_fields,
    .desc = "The MON_FLOWTRACKER_GROUP_STATUS table is used to retrieve flowtracker\n group status parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowtracker_hw_learn_flow_action_control_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe on which the flow was learnt.",
    },
    {
        .name  = EXACT_MATCH_INDEXs,  /* EXACT_MATCH_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Hardware exact match table index\n to be deleted/modified.\n",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_EXACT_MATCH_IDX_MODE_T_DATA,
        .desc = "HW exact match table index mode.",
    },
    {
        .name  = MON_FLOWTRACKER_GROUP_IDs,  /* MON_FLOWTRACKER_GROUP_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_FLOWTRACKER_GROUP table on which this\n flow was learnt.\n",
    },
    {
        .name  = ACTIONS_TYPEs,  /* ACTIONS_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 11,
        .edata = BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_DATA,
        .desc = "List of actions that need to be modified.\n Applicable only if CMD == MODIFY.\n",
    },
    {
        .name  = ACTIONS_EM_FT_OPAQUE_OBJ0_VALs,  /* ACTIONS_EM_FT_OPAQUE_OBJ0_VAL */
        .flags = 0,
        .width = 16,
        .depth = 11,
        .desc = "List of actions that need to be modified.\n Applicable only if CMD == MODIFY.\n",
    },
    {
        .name  = ACTIONS_EM_FT_IOAM_GBP_ACTION_VALs,  /* ACTIONS_EM_FT_IOAM_GBP_ACTION_VAL */
        .flags = 0,
        .width = 4,
        .depth = 11,
        .desc = "List of actions that need to be modified.\n Applicable only if CMD == MODIFY.\n",
    },
    {
        .name  = ACTIONS_EM_FT_COPY_TO_CPU_VALs,  /* ACTIONS_EM_FT_COPY_TO_CPU_VAL */
        .flags = 0,
        .width = 1,
        .depth = 11,
        .desc = "List of actions that need to be modified.\n Applicable only if CMD == MODIFY.\n",
    },
    {
        .name  = ACTIONS_EM_FT_DROP_ACTION_VALs,  /* ACTIONS_EM_FT_DROP_ACTION_VAL */
        .flags = 0,
        .width = 1,
        .depth = 11,
        .desc = "List of actions that need to be modified.\n Applicable only if CMD == MODIFY.\n",
    },
    {
        .name  = ACTIONS_DESTINATION_VALs,  /* ACTIONS_DESTINATION_VAL */
        .flags = 0,
        .width = 16,
        .depth = 11,
        .desc = "List of actions that need to be modified.\n Applicable only if CMD == MODIFY.\n",
    },
    {
        .name  = ACTIONS_DESTINATION_TYPE_VALs,  /* ACTIONS_DESTINATION_TYPE_VAL */
        .flags = 0,
        .width = 4,
        .depth = 11,
        .desc = "List of actions that need to be modified.\n Applicable only if CMD == MODIFY.\n",
    },
    {
        .name  = ACTIONS_EM_FT_FLEX_STATE_ACTION_VALs,  /* ACTIONS_EM_FT_FLEX_STATE_ACTION_VAL */
        .flags = 0,
        .width = 4,
        .depth = 11,
        .desc = "List of actions that need to be modified.\n Applicable only if CMD == MODIFY.\n",
    },
    {
        .name  = ACTIONS_FLEX_CTR_ACTION_VALs,  /* ACTIONS_FLEX_CTR_ACTION_VAL */
        .flags = 0,
        .width = 6,
        .depth = 11,
        .desc = "List of actions that need to be modified.\n Applicable only if CMD == MODIFY.\n",
    },
    {
        .name  = ACTIONS_PKT_FLOW_ELIGIBILITY_VALs,  /* ACTIONS_PKT_FLOW_ELIGIBILITY_VAL */
        .flags = 0,
        .width = 6,
        .depth = 11,
        .desc = "List of actions that need to be modified.\n Applicable only if CMD == MODIFY.\n",
    },
    {
        .name  = ACTIONS_L2_IIF_SVP_MIRROR_INDEX_0_VALs,  /* ACTIONS_L2_IIF_SVP_MIRROR_INDEX_0_VAL */
        .flags = 0,
        .width = 4,
        .depth = 11,
        .desc = "List of actions that need to be modified.\n Applicable only if CMD == MODIFY.\n",
    },
    {
        .name  = CMDs,  /* CMD */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_FLOW_CMD_T_DATA,
        .desc = "Command to execute on the exact match table entry.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowtracker_hw_learn_flow_action_control_t = {
    .name = MON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_CONTROLs, /* MON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_CONTROL */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_mon_flowtracker_hw_learn_flow_action_control_t_fields,
    .desc = "The MON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_CONTROL table is an\n action invocation table used for deleting or modifying flow\n entries learnt by HW.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_STATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowtracker_hw_learn_flow_action_state_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe on which the flow was learnt.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_STATE_T_DATA,
        .desc = "Read-only field that indicates the status of the\n action performed in the\n MON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_CONTROL table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowtracker_hw_learn_flow_action_state_t = {
    .name = MON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_STATEs, /* MON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_STATE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_flowtracker_hw_learn_flow_action_state_t_fields,
    .desc = "The MON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_STATE table is an\n event notification table used for looking up the status of\n last action performed in MON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_CONTROL\n table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_FLOWTRACKER_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_flowtracker_stats_t_fields[] = {
    {
        .name  = LEARN_PKT_DISCARD_PARSE_ERRORs,  /* LEARN_PKT_DISCARD_PARSE_ERROR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of packets not learnt because of parsing errors.",
    },
    {
        .name  = LEARN_PKT_DISCARD_INVALID_GROUPs,  /* LEARN_PKT_DISCARD_INVALID_GROUP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of packets not learnt because of invalid group index.",
    },
    {
        .name  = LEARN_PKT_DISCARD_FLOW_LIMIT_EXCEEDs,  /* LEARN_PKT_DISCARD_FLOW_LIMIT_EXCEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of packets not learnt because flow limit\n of group was exceeded.\n",
    },
    {
        .name  = LEARN_PKT_DISCARD_PIPE_LIMIT_EXCEEDs,  /* LEARN_PKT_DISCARD_PIPE_LIMIT_EXCEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of packets not learnt because pipe level maximum flows\n limit was exceeded.\n",
    },
    {
        .name  = LEARN_PKT_DISCARD_EM_FAILs,  /* LEARN_PKT_DISCARD_EM_FAIL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of packets not learnt because of exact match table\n access failures.\n",
    },
    {
        .name  = LEARN_PKT_DISCARD_DUPLICATEs,  /* LEARN_PKT_DISCARD_DUPLICATE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of packets not learnt because they are duplicates\n of already learnt flows.\n",
    },
    {
        .name  = NUM_FLOWS_LEARNTs,  /* NUM_FLOWS_LEARNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Total number of flows learnt by the flowtracker embedded\n application.\n",
    },
    {
        .name  = NUM_FLOWS_EXPORTEDs,  /* NUM_FLOWS_EXPORTED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Total number of flows exported by the flowtracker embedded\n application.\n",
    },
    {
        .name  = NUM_PACKETS_EXPORTEDs,  /* NUM_PACKETS_EXPORTED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Total number of packets exported by the flowtracker embedded\n application.\n",
    },
    {
        .name  = NUM_FLOWS_AGEDs,  /* NUM_FLOWS_AGED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Total number of flows aged out by the flowtracker embedded\n application.\n",
    },
    {
        .name  = NUM_FLOWS_ELEPHANTs,  /* NUM_FLOWS_ELEPHANT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Total number of flows that were promoted to elephant.\n This field is applicable only if\n MON_FLOWTRACKER_CONTROL.ETRAP was set to TRUE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_flowtracker_stats_t = {
    .name = MON_FLOWTRACKER_STATSs, /* MON_FLOWTRACKER_STATS */
    .flags = 0,
    .fields = 11,
    .field = bcmltd_mon_flowtracker_stats_t_fields,
    .desc = "The MON_FLOWTRACKER_STATS table is used to retrieve global debug\n statistics maintained in the flowtracker embedded application.\n Applicable only if\n MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is DISABLE or ENABLE.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_ACTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_action_profile_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MON_INBAND_TELEMETRY_ACTION_PROFILE table.",
    },
    {
        .name  = UPDATE_UDP_LENGTHs,  /* UPDATE_UDP_LENGTH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update UDP length after metadata insertion.",
    },
    {
        .name  = O_BIT_UPDATE_MODEs,  /* O_BIT_UPDATE_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select the updating mode for the O-bit in the flag field during\n metadata insertion. Applicable for IOAM packets.\n",
    },
    {
        .name  = UPDATE_IP_LENGTHs,  /* UPDATE_IP_LENGTH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to update IP length after metadata insertion.",
    },
    {
        .name  = TIMESTAMP_MODEs,  /* TIMESTAMP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Timestamp mode for ingress timestamp, egress timestamp\n and residence time.\n",
    },
    {
        .name  = RESIDENCE_TIME_FORMATs,  /* RESIDENCE_TIME_FORMAT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Format for residence time.",
    },
    {
        .name  = METADATA_INSERT_MODEs,  /* METADATA_INSERT_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Metadata insertion mode.",
    },
    {
        .name  = USE_METADATA_PROFILEs,  /* USE_METADATA_PROFILE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use\n MON_INBAND_TELEMETRY_METADATA_PROFILE_ID.\n This can be used to overwrite the profile assigned by\n MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH,\n MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH,\n MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_METADATA_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MON_INBAND_TELEMETRY_METADATA_PROFILE_ID\n table. Applicable when USE_METADATA_PROFILE is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_action_profile_t = {
    .name = MON_INBAND_TELEMETRY_ACTION_PROFILEs, /* MON_INBAND_TELEMETRY_ACTION_PROFILE */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_mon_inband_telemetry_action_profile_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_ACTION_PROFILE table specifies the\n controls for inband telemetry metadata generation and packet\n updating after metadata insertion.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_control_t_fields[] = {
    {
        .name  = INBAND_TELEMETRYs,  /* INBAND_TELEMETRY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to initialize the INT embedded application.",
    },
    {
        .name  = MAX_EXPORT_PKT_LENGTHs,  /* MAX_EXPORT_PKT_LENGTH */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum possible export packet length in bytes. MAX_PKT_LENGTH field\n in the MON_EXPORT_PROFILE LT entry used by INT cannot exceed this\n value. If the INT embedded application has been initialized\n (INBAND_TELEMETRY is enabled), it must be restarted by toggling\n INBAND_TELEMETRY in order for this field to take effect.\n",
    },
    {
        .name  = MAX_EXPORT_PKT_LENGTH_OPERs,  /* MAX_EXPORT_PKT_LENGTH_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational maximum possible export packet length in bytes. This is a\n read-only field which reflects the maximum possible export packet\n length currently in use.\n",
    },
    {
        .name  = MAX_RX_PKT_LENGTHs,  /* MAX_RX_PKT_LENGTH */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum possible incoming packet length in bytes. Any packet larger\n than this will be discarded and the RX_PKT_LENGTH_EXCEED_MAX_DISCARD\n field in INBAND_TELEMETRY_STATS LT is incremented. If the INT\n embedded application has been initialized (INBAND_TELEMETRY is\n enabled), it must be restarted by toggling INBAND_TELEMETRY in order\n for this field to take effect.\n",
    },
    {
        .name  = MAX_RX_PKT_LENGTH_OPERs,  /* MAX_RX_PKT_LENGTH_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational maximum possible incoming packet length in bytes. This is\n a read-only field which reflects the current maximum incoming packet\n length.\n",
    },
    {
        .name  = DEVICE_IDENTIFIERs,  /* DEVICE_IDENTIFIER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Inband Flow Analyzer (IFA) device identifier.",
    },
    {
        .name  = EXPORTs,  /* EXPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to export INT packets to collector.",
    },
    {
        .name  = RX_PKT_EXPORT_MAX_LENGTHs,  /* RX_PKT_EXPORT_MAX_LENGTH */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum length of the incoming packet that needs to be exported along\n with the metadata stack to the collector.\n",
    },
    {
        .name  = COLLECTOR_TYPEs,  /* COLLECTOR_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_MON_INBAND_TELEMETRY_CONTROL_COLLECTOR_TYPE_T_DATA,
        .desc = "Collector type.",
    },
    {
        .name  = MON_COLLECTOR_IPV4_IDs,  /* MON_COLLECTOR_IPV4_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_COLLECTOR_IPV4 table, if the collector is an IPV4\n collector. Applicable only if COLLECTOR_TYPE == IPV4.\n",
    },
    {
        .name  = MON_COLLECTOR_IPV6_IDs,  /* MON_COLLECTOR_IPV6_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_COLLECTOR_IPV6 table, if the collector is an IPV6\n collector. Applicable only if COLLECTOR_TYPE == IPV6.\n",
    },
    {
        .name  = MON_EXPORT_PROFILE_IDs,  /* MON_EXPORT_PROFILE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_EXPORT_PROFILE table.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_MON_INBAND_TELEMETRY_CONTROL_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_control_t = {
    .name = MON_INBAND_TELEMETRY_CONTROLs, /* MON_INBAND_TELEMETRY_CONTROL */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_mon_inband_telemetry_control_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_CONTROL table is used to set device level\n Inband Telemetry (INT) functions.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_DATAPLANE_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_dataplane_control_t_fields[] = {
    {
        .name  = EGR_PORTS_TURNAROUNDs,  /* EGR_PORTS_TURNAROUND */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to turnaround INT-DP packets at the specified egress\n ports.\n",
    },
    {
        .name  = TURNAROUND_COPY_TO_CPUs,  /* TURNAROUND_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy INT-DP packets turned around to CPU.\n The turnaround is enabled by EGR_PORTS_TURNAROUND.\n",
    },
    {
        .name  = HOPLIMIT_COPY_TO_CPUs,  /* HOPLIMIT_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy INT-DP packets with hop limit\n exception (hop count >= hop limit) to CPU.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_dataplane_control_t = {
    .name = MON_INBAND_TELEMETRY_DATAPLANE_CONTROLs, /* MON_INBAND_TELEMETRY_DATAPLANE_CONTROL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_mon_inband_telemetry_dataplane_control_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_DATAPLANE_CONTROL table specifies the\n global attributes for In-band Network Telemetry Data-plane\n Probe (INT-DP) packet handling.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_DATAPLANE_PARSE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_dataplane_parse_t_fields[] = {
    {
        .name  = VERSIONs,  /* VERSION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "INT-DP version number, specified as the maximum expected\n version.  All versions less than or equal to the specified\n version are supported.\n",
    },
    {
        .name  = USE_PROBE_MARKER_1s,  /* USE_PROBE_MARKER_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use the probe marker (1) for INT-DP packet\n detection.\n",
    },
    {
        .name  = PROBE_MARKER_1s,  /* PROBE_MARKER_1 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Probe marker (1).",
    },
    {
        .name  = USE_PROBE_MARKER_2s,  /* USE_PROBE_MARKER_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use the probe marker (2) for INT-DP packet\n detection.\n",
    },
    {
        .name  = PROBE_MARKER_2s,  /* PROBE_MARKER_2 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Probe marker (2).",
    },
    {
        .name  = USE_L4_DST_PORTs,  /* USE_L4_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 2,
        .desc = "Enable to use the L4 destination port for INT-DP\n packet detection.\n",
    },
    {
        .name  = L4_DST_PORTs,  /* L4_DST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 2,
        .desc = "L4 destination port value to be compared against the destination\n port in the UDP header in order to identify and parse INT-DP\n packets. Applicable if USE_L4_DST_PORT is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_dataplane_parse_t = {
    .name = MON_INBAND_TELEMETRY_DATAPLANE_PARSEs, /* MON_INBAND_TELEMETRY_DATAPLANE_PARSE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_mon_inband_telemetry_dataplane_parse_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_DATAPLANE_PARSE table specifies the attributes\n for In-band Network Telemetry Data-plane Probe (INT-DP) packet\n detection.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_dataplane_vector_match_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH_IDs,  /* MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the INT_DP vector match table.",
    },
    {
        .name  = REQUEST_VECTORs,  /* REQUEST_VECTOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Value to match against the telemetry request vector in the\n INT-DP packet.\n",
    },
    {
        .name  = REQUEST_VECTOR_MASKs,  /* REQUEST_VECTOR_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask value to be applied to the telemetry request vector in\n INT-DP packet before matching with REQUEST_VECTOR.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_METADATA_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into\n the MON_INBAND_TELEMETRY_METADATA_PROFILE table.\n Applicable if REQUEST_VECTOR is matched.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_dataplane_vector_match_t = {
    .name = MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCHs, /* MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_mon_inband_telemetry_dataplane_vector_match_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH table specifies\n the vector to be matched for In-band Network Telemetry Data-plane\n Probe (INT-DP) packets. A vector match indicates that the node is\n capable of handling this packet.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_IFA_PARSE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_ifa_parse_t_fields[] = {
    {
        .name  = VERSIONs,  /* VERSION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IFA version number.",
    },
    {
        .name  = IP_PROTOs,  /* IP_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Protocol value to be compared against a packet's IP\n protocol or next header field in order to identify and\n parse IFA packets.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_ifa_parse_t = {
    .name = MON_INBAND_TELEMETRY_IFA_PARSEs, /* MON_INBAND_TELEMETRY_IFA_PARSE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_inband_telemetry_ifa_parse_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_IFA_PARSE table specifies the attributes for\n Inband Flow Analyzer (IFA) packet detection.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_ifa_vector_match_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH_IDs,  /* MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the IFA vector match table.",
    },
    {
        .name  = GNSs,  /* GNS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to match against the global namespace (GNS) in the\n IFA packet.\n",
    },
    {
        .name  = GNS_MASKs,  /* GNS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask value to be applied to the global namespace in\n the IFA packet before matching with GNS.\n",
    },
    {
        .name  = LNSs,  /* LNS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to match against the local namespace (LNS) in the\n IFA packet.\n",
    },
    {
        .name  = LNS_MASKs,  /* LNS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask value to be applied to the local namespace in\n the IFA packet before matching with LNS.\n",
    },
    {
        .name  = REQUEST_VECTORs,  /* REQUEST_VECTOR */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to match against the request vector in the\n IFA packet.\n",
    },
    {
        .name  = REQUEST_VECTOR_MASKs,  /* REQUEST_VECTOR_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask value to be applied to the request vector in\n the IFA packet before matching with REQUEST_VECTOR.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_METADATA_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the\n MON_INBAND_TELEMETRY_METADATA_PROFILE table.\n Applicable if GNS, LNS and REQUEST_VECTOR are matched.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_ifa_vector_match_t = {
    .name = MON_INBAND_TELEMETRY_IFA_VECTOR_MATCHs, /* MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_mon_inband_telemetry_ifa_vector_match_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH table specifies the\n vector to be matched for Inband Flow Analyzer (IFA) packets. A\n vector match indicates that the node is capable of handling this\n packet.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_IOAM_PARSE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_ioam_parse_t_fields[] = {
    {
        .name  = GRE_ENCAPs,  /* GRE_ENCAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to parse IOAM packet with GRE encapsulation.",
    },
    {
        .name  = GRE_PROTOs,  /* GRE_PROTO */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Protocol value to be compared against IP protocol field in\n the GRE header in order to identify and parse IOAM packets.\n Applicable if GRE_ENCAP is enabled.\n",
    },
    {
        .name  = IPV6_ENCAPs,  /* IPV6_ENCAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to parse IOAM packet with IPV6 encapsulation.\n",
    },
    {
        .name  = INCREMENTAL_TRACE_OPTIONs,  /* INCREMENTAL_TRACE_OPTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Option type value to be compared against the option type\n in IPv6 Hop-by-Hop or destination extension header in\n order to identify and parse IOAM packets.\n Applicable if IPV6_ENCAP is enabled.\n",
    },
    {
        .name  = IOAM_TYPEs,  /* IOAM_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "IOAM type value to be compared against the IOAM type\n in packet in order to identify and parse IOAM packets.\n Applicable if IPV6_ENCAP and/or GRE_ENCAP is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_ioam_parse_t = {
    .name = MON_INBAND_TELEMETRY_IOAM_PARSEs, /* MON_INBAND_TELEMETRY_IOAM_PARSE */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_mon_inband_telemetry_ioam_parse_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_IOAM_PARSE table specifies the attributes for\n In-situ Operations, Administration, and Maintenance (IOAM)\n packet detection.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_ioam_vector_match_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH_IDs,  /* MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the IOAM vector match table.",
    },
    {
        .name  = NAMESPACE_IDs,  /* NAMESPACE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to match against the namespace identifier in the\n IOAM packet.\n",
    },
    {
        .name  = NAMESPACE_ID_MASKs,  /* NAMESPACE_ID_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask value to be applied to the namespace identifier in\n the IOAM packet before matching with NAMESPACE_ID.\n",
    },
    {
        .name  = IOAM_TRACE_TYPEs,  /* IOAM_TRACE_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Value to match against the trace type in the\n IOAM packet.\n",
    },
    {
        .name  = IOAM_TRACE_TYPE_MASKs,  /* IOAM_TRACE_TYPE_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mask value to be applied to the trace type in\n the IOAM packet before matching with IOAM_TRACE_TYPE.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_METADATA_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the\n MON_INBAND_TELEMETRY_METADATA_PROFILE table.\n Applicable if NAMESPACE_ID and IOAM_TRACE_TYPE are matched.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_ioam_vector_match_t = {
    .name = MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCHs, /* MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_mon_inband_telemetry_ioam_vector_match_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH table specifies the\n vector to be matched for In-situ Operations, Administration, and\n Maintenance (IOAM) packets. A vector match indicates that the\n node is capable of handling this packet.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_IPFIX_EXPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_ipfix_export_t_fields[] = {
    {
        .name  = SET_IDs,  /* SET_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "IPFIX set ID.",
    },
    {
        .name  = NUM_EXPORT_ELEMENTSs,  /* NUM_EXPORT_ELEMENTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of export elements.",
    },
    {
        .name  = EXPORT_ELEMENTs,  /* EXPORT_ELEMENT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 3,
        .desc = "Export elements.",
    },
    {
        .name  = ENTERPRISEs,  /* ENTERPRISE */
        .flags = 0,
        .width = 1,
        .depth = 3,
        .desc = "Enable to specify export element type as enterprise.",
    },
    {
        .name  = INFORMATION_ELEMENT_IDENTIFIERs,  /* INFORMATION_ELEMENT_IDENTIFIER */
        .flags = 0,
        .width = 16,
        .depth = 3,
        .desc = "IPFIX information element identifier for the export elements.",
    },
    {
        .name  = TX_INTERVALs,  /* TX_INTERVAL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Interval in seconds at which the IPFIX template set has to be\n transmitted.\n",
    },
    {
        .name  = INITIAL_BURSTs,  /* INITIAL_BURST */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of times the IPFIX template set needs to be sent before\n settling to a periodic export.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_MON_INBAND_TELEMETRY_IPFIX_EXPORT_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_ipfix_export_t = {
    .name = MON_INBAND_TELEMETRY_IPFIX_EXPORTs, /* MON_INBAND_TELEMETRY_IPFIX_EXPORT */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_mon_inband_telemetry_ipfix_export_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_IPFIX_EXPORT table specifies the IP flow\n information export (IPFIX) configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_METADATA_CHUNK_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_metadata_chunk_info_t_fields[] = {
    {
        .name  = WIDE_SIZEs,  /* WIDE_SIZE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Size of the wide chunk in bits.",
    },
    {
        .name  = NARROW_SIZEs,  /* NARROW_SIZE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Size of the narrow chunk in bits.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_metadata_chunk_info_t = {
    .name = MON_INBAND_TELEMETRY_METADATA_CHUNK_INFOs, /* MON_INBAND_TELEMETRY_METADATA_CHUNK_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_inband_telemetry_metadata_chunk_info_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_METADATA_CHUNK_INFO read only table provides\n chunk information for metadata selection.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_metadata_construct_narrow_profile_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the\n MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILE logical\n table.\n",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 12,
        .desc = "Enable the selected field to be included in metadata.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "The relative offset of the field within metadata, starting\n from the MSB of metadata, with byte as granularity.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_metadata_construct_narrow_profile_t = {
    .name = MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILEs, /* MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_mon_inband_telemetry_metadata_construct_narrow_profile_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILE\n table specifies the attributes to construct final metadata with fields\n selected by MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_metadata_construct_wide_profile_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the\n MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILE logical\n table.\n",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 12,
        .desc = "Enable the selected field to be included in metadata.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "The relative offset of the field within metadata, starting\n from the MSB of metadata, with byte as granularity.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_metadata_construct_wide_profile_t = {
    .name = MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILEs, /* MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_mon_inband_telemetry_metadata_construct_wide_profile_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILE table\n specifies the attributes to construct final metadata with fields\n selected by MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_METADATA_FIELD_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_metadata_field_control_t_fields[] = {
    {
        .name  = SWITCH_IDENTIFIERs,  /* SWITCH_IDENTIFIER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Switch identifier.",
    },
    {
        .name  = EGR_LATENCY_ADJUSTs,  /* EGR_LATENCY_ADJUST */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Time in nano-seconds added to the current egress timestamp to\n adjust latency from egress pipeline to port.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_metadata_field_control_t = {
    .name = MON_INBAND_TELEMETRY_METADATA_FIELD_CONTROLs, /* MON_INBAND_TELEMETRY_METADATA_FIELD_CONTROL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_inband_telemetry_metadata_field_control_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_METADATA_FIELD_CONTROL table specifies the\n attributes for metadata fields.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_METADATA_FIELD_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_metadata_field_info_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_FIELD_INFO_IDs,  /* MON_INBAND_TELEMETRY_METADATA_FIELD_INFO_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_INBAND_TELEMETRY_METADATA_FIELD_INFO\n logical table.\n",
    },
    {
        .name  = SIZEs,  /* SIZE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Size of the field in bits.",
    },
    {
        .name  = WIDE_INDEXs,  /* WIDE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Chunk index of field in a wide chunk.",
    },
    {
        .name  = WIDE_STARTs,  /* WIDE_START */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Starting bit position of the field within a wide chunk.",
    },
    {
        .name  = NARROW_INDEXs,  /* NARROW_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Chunk index of field in a narrow chunk.",
    },
    {
        .name  = NARROW_STARTs,  /* NARROW_START */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Starting bit position of the field within a narrow chunk.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_metadata_field_info_t = {
    .name = MON_INBAND_TELEMETRY_METADATA_FIELD_INFOs, /* MON_INBAND_TELEMETRY_METADATA_FIELD_INFO */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_mon_inband_telemetry_metadata_field_info_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_METADATA_FIELD_INFO read only table provides\n field information for metadata selection.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_METADATA_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_metadata_profile_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_METADATA_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the\n MON_INBAND_TELEMETRY_METADATA_PROFILE table.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the\n MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE and\n MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE logical\n tables.\n",
    },
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the\n MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NWRROW_PROFILE and\n MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILE logical\n tables.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_metadata_profile_t = {
    .name = MON_INBAND_TELEMETRY_METADATA_PROFILEs, /* MON_INBAND_TELEMETRY_METADATA_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_mon_inband_telemetry_metadata_profile_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_METADATA_PROFILE table specifies the\n attributes to control the final metadata generation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_metadata_select_narrow_profile_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the\n MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE logical\n table.\n",
    },
    {
        .name  = CHUNK_INDEXs,  /* CHUNK_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "Index of the narrow chunk on the bus, starting from the MSB\n of the bus.\n",
    },
    {
        .name  = STARTs,  /* START */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "Starting bit position of the field within the narrow bits chunk,\n from the MSB of the chunk.\n",
    },
    {
        .name  = SIZEs,  /* SIZE */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "Size of the field in bits.",
    },
    {
        .name  = SHIFTs,  /* SHIFT */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "Number of bits of the field to barrel shift towards LSB.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_metadata_select_narrow_profile_t = {
    .name = MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILEs, /* MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_mon_inband_telemetry_metadata_select_narrow_profile_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE table\n specifies the attributes to select desired fields from narrow chunk.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_metadata_select_wide_profile_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the\n MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE logical table.\n",
    },
    {
        .name  = CHUNK_INDEXs,  /* CHUNK_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "Index of the wide chunk on the bus, starting from the MSB\n of the bus.\n",
    },
    {
        .name  = STARTs,  /* START */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "Starting bit position of the field within the wide chunk,\n from the MSB of the chunk.\n",
    },
    {
        .name  = SIZEs,  /* SIZE */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "Size of the field in bits.",
    },
    {
        .name  = SHIFTs,  /* SHIFT */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "Number of bits of the field to barrel shift towards LSB.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_metadata_select_wide_profile_t = {
    .name = MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILEs, /* MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_mon_inband_telemetry_metadata_select_wide_profile_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE table\n specifies the attributes to select desired fields from wide chunk.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_MIRROR_ING_CONTAINER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_mirror_ing_container_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_MIRROR_ING_CONTAINER_IDs,  /* MON_INBAND_TELEMETRY_MIRROR_ING_CONTAINER_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Index to the MON_INBAND_TELEMETRY_MIRROR_ING_CONTAINER\n logical table.\n",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mirror.",
    },
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MIRROR_INSTANCE_ID logical table index. Used to compute the index\n into the MIRROR_ING/EGR_INSTANCE table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_mirror_ing_container_t = {
    .name = MON_INBAND_TELEMETRY_MIRROR_ING_CONTAINERs, /* MON_INBAND_TELEMETRY_MIRROR_ING_CONTAINER */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_mon_inband_telemetry_mirror_ing_container_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_MIRROR_ING_CONTAINER logical table specifies\n the mirror containers for inband telemetry packets in the ingress\n pipeline.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_opaque_data_profile_t_fields[] = {
    {
        .name  = MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,  /* MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE table.",
    },
    {
        .name  = OPAQUE_DATAs,  /* OPAQUE_DATA */
        .flags = 0,
        .width = 32,
        .depth = 3,
        .desc = "Opaque fields.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_opaque_data_profile_t = {
    .name = MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILEs, /* MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_inband_telemetry_opaque_data_profile_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE table specifies the\n opaque data for inband telemetry metadata construction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_stats_t_fields[] = {
    {
        .name  = RX_PKT_CNTs,  /* RX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received by the application.",
    },
    {
        .name  = TX_PKT_CNTs,  /* TX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets transmitted by the application.",
    },
    {
        .name  = TX_RECORD_CNTs,  /* TX_RECORD_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of INT records transmitted by the application.",
    },
    {
        .name  = RX_PKT_EXPORT_DISABLED_DISCARDs,  /* RX_PKT_EXPORT_DISABLED_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of received packets discarded due to export being disabled in\n the MON_INBAND_TELEMETRY_CONTROL table.\n",
    },
    {
        .name  = RX_PKT_NO_EXPORT_CONFIG_DISCARDs,  /* RX_PKT_NO_EXPORT_CONFIG_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of received packets discarded due to either collector or\n export profile not being configured in the\n MON_INBAND_TELEMETRY_CONTROL table.\n",
    },
    {
        .name  = RX_PKT_NO_IPFIX_CONFIG_DISCARDs,  /* RX_PKT_NO_IPFIX_CONFIG_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of received packets discarded as no IP flow information export\n (IPFIX) configuration is enabled in the\n MON_INBAND_TELEMETRY_IPFIX_EXPORT table.\n",
    },
    {
        .name  = RX_PKT_CURRENT_LENGTH_EXCEED_DISCARDs,  /* RX_PKT_CURRENT_LENGTH_EXCEED_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of received packets discarded as no current length field value\n in the IFA header exceeds the maximum length field value in the IFA\n header.\n",
    },
    {
        .name  = RX_PKT_LENGTH_EXCEED_MAX_DISCARDs,  /* RX_PKT_LENGTH_EXCEED_MAX_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of received packets discarded due to it's length being larger\n than the maximum value configured in\n MON_INBAND_TELEMETRY_CONTROL.MAX_RX_PKT_LENGTH_OPER.\n",
    },
    {
        .name  = RX_PKT_PARSE_ERROR_DISCARDs,  /* RX_PKT_PARSE_ERROR_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of received packets that were discarded due to errors in\n parsing.\n",
    },
    {
        .name  = RX_PKT_UNKNOWN_NAMESPACE_DISCARDs,  /* RX_PKT_UNKNOWN_NAMESPACE_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of received packets that were discarded due to unknown\n namespace in the IFA header.\n",
    },
    {
        .name  = RX_PKT_EXCESS_RATE_DISCARDs,  /* RX_PKT_EXCESS_RATE_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of received packets that were discarded due to high incoming\n rate.\n",
    },
    {
        .name  = RX_PKT_INCOMPLETE_METADATA_DISCARDs,  /* RX_PKT_INCOMPLETE_METADATA_DISCARD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of received packets discarded as the metadata stack is\n incomplete.\n",
    },
    {
        .name  = TX_PKT_FAILURE_CNTs,  /* TX_PKT_FAILURE_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of transmitted packets that could not be exported due to some\n failure.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_stats_t = {
    .name = MON_INBAND_TELEMETRY_STATSs, /* MON_INBAND_TELEMETRY_STATS */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_mon_inband_telemetry_stats_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_STATS table is used to collect the INT statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_TM_STATS_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_tm_stats_control_t_fields[] = {
    {
        .name  = USAGE_CELLSs,  /* USAGE_CELLS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select to report port or queue based usage in cells, including\n current and maximum usage.\n",
    },
    {
        .name  = USE_MAX_USAGE_CELLSs,  /* USE_MAX_USAGE_CELLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use MAX_USAGE_CELLS as maximum usage in cells when\n BST is not enabled.\n",
    },
    {
        .name  = MAX_USAGE_CELLSs,  /* MAX_USAGE_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum usage in cells. Applies for cut-through packets or\n when BST is not enabled.\n",
    },
    {
        .name  = CURRENT_USAGE_CELLSs,  /* CURRENT_USAGE_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Current usage in cells. Applies for cut-through packets.",
    },
    {
        .name  = CURRENT_AVAILABLE_CELLSs,  /* CURRENT_AVAILABLE_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Current available buffer in cells. Applies for cut-through\n packets.\n",
    },
    {
        .name  = MIN_AVAILABLE_CELLSs,  /* MIN_AVAILABLE_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum available buffer in cells. Applies for cut-through\n packets or when BST is not enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_tm_stats_control_t = {
    .name = MON_INBAND_TELEMETRY_TM_STATS_CONTROLs, /* MON_INBAND_TELEMETRY_TM_STATS_CONTROL */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_mon_inband_telemetry_tm_stats_control_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_TM_STATS_CONTROL table specifies the global\n attributes for statistics generated by the traffic manager as inband\n telemetry metadata.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_INBAND_TELEMETRY_VECTOR_MATCH_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_inband_telemetry_vector_match_control_t_fields[] = {
    {
        .name  = MISS_ACTIONs,  /* MISS_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Action for inband telemetry packets with no match in the\n MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH or\n MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH or\n MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH logical tables.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_inband_telemetry_vector_match_control_t = {
    .name = MON_INBAND_TELEMETRY_VECTOR_MATCH_CONTROLs, /* MON_INBAND_TELEMETRY_VECTOR_MATCH_CONTROL */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_mon_inband_telemetry_vector_match_control_t_fields,
    .desc = "The MON_INBAND_TELEMETRY_VECTOR_MATCH_CONTROL table specifies the\n attributes for request vector matching of inband telemetry\n packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_ING_DROP_EVENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_ing_drop_event_t_fields[] = {
    {
        .name  = MON_ING_DROP_EVENT_IDs,  /* MON_ING_DROP_EVENT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_DROP_EVENT table.",
    },
    {
        .name  = CPUs,  /* CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets to the CPU.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to mirror packets.",
    },
    {
        .name  = LOOPBACKs,  /* LOOPBACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets to the loopback port.\n PORT_ING_BLOCK_LOOPBACK:MASK_PORTS[] should be enabled to loopback\n traffic on the logical port.\n When PORT_ING_BLOCK_LOOPBACK:MASK_PORTS[] is enabled, by default the\n loopback action is enabled on the logical port.\n LOOPBACK should be set to 0 to disable the loopback action.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_ing_drop_event_t = {
    .name = MON_ING_DROP_EVENTs, /* MON_ING_DROP_EVENT */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_mon_ing_drop_event_t_fields,
    .desc = "The MON_ING_DROP_EVENT table specifies copy to CPU, mirror action and\n copy loopback action triggered based on ingress one or multiple drop events.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_ING_LDH_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_ing_ldh_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = MONITOR_STATEs,  /* MONITOR_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 16,
        .edata = BCMLTD_COMMON_LDH_MONITOR_STATE_T_DATA,
        .desc = "Monitor state.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_ing_ldh_port_t = {
    .name = MON_ING_LDH_PORTs, /* MON_ING_LDH_PORT */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_ing_ldh_port_t_fields,
    .desc = "The MON_ING_LDH_PORT table specifies the ingress logical port\n associated with the latency monitor.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_ING_TRACE_EVENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_ing_trace_event_t_fields[] = {
    {
        .name  = MON_ING_TRACE_EVENT_IDs,  /* MON_ING_TRACE_EVENT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_ING_TRACE_EVENT table.",
    },
    {
        .name  = CPUs,  /* CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets to the CPU.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable to mirror packets per session.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_ing_trace_event_t = {
    .name = MON_ING_TRACE_EVENTs, /* MON_ING_TRACE_EVENT */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_mon_ing_trace_event_t_fields,
    .desc = "The MON_ING_TRACE_EVENT table specifies copy to CPU and mirror action\n triggered based on ingress one or multiple trace events.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_LDH_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_ldh_control_t_fields[] = {
    {
        .name  = MON_LDH_INSTANCEs,  /* MON_LDH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Latency monitor instance.",
    },
    {
        .name  = MONITORs,  /* MONITOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable latency distribution histogram monitor.",
    },
    {
        .name  = COUNT_MODEs,  /* COUNT_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Packet count mode.",
    },
    {
        .name  = COLLECTION_MODEs,  /* COLLECTION_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Collection mode.",
    },
    {
        .name  = TIME_STEPs,  /* TIME_STEP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Time series step.",
    },
    {
        .name  = CTR_EGR_FLEX_POOL_NUMBERs,  /* CTR_EGR_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter egress pool number.",
    },
    {
        .name  = CTR_EGR_FLEX_OFFSET_MODEs,  /* CTR_EGR_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Flex counter offset mode.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Histogram start offset.",
    },
    {
        .name  = COUNTER_INCREMENTs,  /* COUNTER_INCREMENT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Histogram counter increment for each period. The specified counter\n increment value is multiplied by the factor in\n MON_LDH_DEVICE_INFO.COUNTER_INCREMENT_MULTIPLIER.\n",
    },
    {
        .name  = MAX_HISTOGRAM_GROUPs,  /* MAX_HISTOGRAM_GROUP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum number of latency histogram groups.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_ldh_control_t = {
    .name = MON_LDH_CONTROLs, /* MON_LDH_CONTROL */
    .flags = 0,
    .fields = 11,
    .field = bcmltd_mon_ldh_control_t_fields,
    .desc = "The MON_LDH_CONTROL table specifies the latency distribution histogram (LDH)\n configuration attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_LDH_DEVICE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_ldh_device_info_t_fields[] = {
    {
        .name  = LATENCY_LIMIT_QUANTAs,  /* LATENCY_LIMIT_QUANTA */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of quanta (ns) in latency limit.",
    },
    {
        .name  = COUNTER_INCREMENT_MULTIPLIERs,  /* COUNTER_INCREMENT_MULTIPLIER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Multiplier applied against histogram counter increment specified\n in MON_LDH_CONTROL.COUNTER_INCREMENT.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_ldh_device_info_t = {
    .name = MON_LDH_DEVICE_INFOs, /* MON_LDH_DEVICE_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_ldh_device_info_t_fields,
    .desc = "The MON_LDH_DEVICE_INFO read-only table specifies device specific\n latency distribution histogram (LDH) information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_LDH_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_ldh_info_t_fields[] = {
    {
        .name  = MON_LDH_INSTANCEs,  /* MON_LDH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Latency monitor instance.",
    },
    {
        .name  = HISTOGRAM_GROUPs,  /* HISTOGRAM_GROUP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Current latency histogram group.",
    },
    {
        .name  = LAST_INDEXs,  /* LAST_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Last counter index used.",
    },
    {
        .name  = WRAP_AROUNDs,  /* WRAP_AROUND */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of times the counter bank wrapped.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_ldh_info_t = {
    .name = MON_LDH_INFOs, /* MON_LDH_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_mon_ldh_info_t_fields,
    .desc = "The MON_LDH_INFO read only table specifies the runtime status of\n the latency monitor.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_LDH_LATENCY_LIMIT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_ldh_latency_limit_t_fields[] = {
    {
        .name  = MON_LDH_INSTANCEs,  /* MON_LDH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Monitor instance.",
    },
    {
        .name  = MON_LDH_QUEUE_INSTANCEs,  /* MON_LDH_QUEUE_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Queue instance.",
    },
    {
        .name  = MON_LDH_BUCKET_INSTANCEs,  /* MON_LDH_BUCKET_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Bucket instance.",
    },
    {
        .name  = MON_LDH_LATENCY_LIMIT_PROFILE_IDs,  /* MON_LDH_LATENCY_LIMIT_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Latency limit profile ID.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_ldh_latency_limit_t = {
    .name = MON_LDH_LATENCY_LIMITs, /* MON_LDH_LATENCY_LIMIT */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_mon_ldh_latency_limit_t_fields,
    .desc = "The MON_LDH_LATENCY_LIMIT table specifies the latency limit profile\n per monitor, per queue, per bucket.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_LDH_LATENCY_LIMIT_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_ldh_latency_limit_profile_t_fields[] = {
    {
        .name  = MON_LDH_LATENCY_LIMIT_PROFILE_IDs,  /* MON_LDH_LATENCY_LIMIT_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Latency limit profile ID.",
    },
    {
        .name  = LATENCY_LIMITs,  /* LATENCY_LIMIT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Latency limit. The quanta is specified in\n MON_LDH_DEVICE_INFO.LATENCY_LIMIT_QUANTA.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_ldh_latency_limit_profile_t = {
    .name = MON_LDH_LATENCY_LIMIT_PROFILEs, /* MON_LDH_LATENCY_LIMIT_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_mon_ldh_latency_limit_profile_t_fields,
    .desc = "The MON_LDH_LATENCY_LIMIT_PROFILE table specifies the limit of the\n latency distribution histogram. It corresponds to the upper limit\n of the latency bucket.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_LDH_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_ldh_stats_t_fields[] = {
    {
        .name  = MON_LDH_INSTANCEs,  /* MON_LDH_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Latency monitor instance.",
    },
    {
        .name  = MON_LDH_QUEUE_INSTANCEs,  /* MON_LDH_QUEUE_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Queue instance.",
    },
    {
        .name  = MON_LDH_BUCKET_INSTANCEs,  /* MON_LDH_BUCKET_INSTANCE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Bucket instance.",
    },
    {
        .name  = BYTEs,  /* BYTE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Byte counter.",
    },
    {
        .name  = PKTs,  /* PKT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Packet counter.",
    },
};
const bcmltd_table_rep_t bcmltd_mon_ldh_stats_t = {
    .name = MON_LDH_STATSs, /* MON_LDH_STATS */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_mon_ldh_stats_t_fields,
    .desc = "The MON_LDH_STATS table specifies the latency distribution histogram\n statistics when in accumulation mode.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_REDIRECT_DROP_EVENT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_redirect_drop_event_control_t_fields[] = {
    {
        .name  = REDIRECTs,  /* REDIRECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to recirculate the packet into the ingress pipeline\n for the drop events.\n",
    },
    {
        .name  = THRESHOLDs,  /* THRESHOLD */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Highest drop event used as threshold for\n enabling the packet recirculation into the ingress pipeline.\n Packet recirculation action will be enabled for all the drop\n events with higher or equal value than the configured THRESHOLD.\n",
    },
    {
        .name  = REDIRECT_PROFILEs,  /* REDIRECT_PROFILE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Redirect profile index used to calculate the index\n into the MON_REDIRECT_PROFILE table for the drop events.\n MON_REDIRECT_PROFILE_ID =\n (((Redirect profile index derived from the ingress pipeline) &\n REDIRECT_PROFILE_MASK) | REDIRECT_PROFILE).\n",
    },
    {
        .name  = REDIRECT_PROFILE_MASKs,  /* REDIRECT_PROFILE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask for the redirect profile index used to\n calculate the index into the MON_REDIRECT_PROFILE table\n for the drop events.\n MON_REDIRECT_PROFILE_ID =\n (((Redirect profile index derived from the ingress pipeline) &\n REDIRECT_PROFILE_MASK) | REDIRECT_PROFILE).\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_redirect_drop_event_control_t = {
    .name = MON_REDIRECT_DROP_EVENT_CONTROLs, /* MON_REDIRECT_DROP_EVENT_CONTROL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_mon_redirect_drop_event_control_t_fields,
    .desc = "The MON_REDIRECT_DROP_EVENT_CONTROL table is used to\n to specify the packet recirculation drop event controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_REDIRECT_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_redirect_profile_t_fields[] = {
    {
        .name  = MON_REDIRECT_PROFILE_IDs,  /* MON_REDIRECT_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MON_REDIRECT_PROFILE table.",
    },
    {
        .name  = CPU_DMA_HEADER_VERSIONs,  /* CPU_DMA_HEADER_VERSION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Version used in the CPU DMA header\n for the recirculated packet.\n",
    },
    {
        .name  = CPU_DMA_HEADER_WORDs,  /* CPU_DMA_HEADER_WORD */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "CPU DMA header fields to be copied from the\n object or command bus of the pipeline for the recirculated\n packet.\n",
    },
    {
        .name  = CPU_DMA_HEADER_FLEX_WORDs,  /* CPU_DMA_HEADER_FLEX_WORD */
        .flags = 0,
        .width = 1,
        .depth = 18,
        .desc = "CPU DMA header fields to be copied from the object or command bus\n of the pipeline for the CPU DMA header flex portion.\n",
    },
    {
        .name  = NIH_HEADER_STARTs,  /* NIH_HEADER_START */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "NIH header start for the recirculated packet.\n NIH_HEADER_START is used by the ingress data buffer (IDB) to\n identify the start of the NIH header in a recirculated packet.\n",
    },
    {
        .name  = NIH_HEADER_TYPEs,  /* NIH_HEADER_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "NIH header type used in the recirculated packet.",
    },
    {
        .name  = NIH_HEADER_FIELDs,  /* NIH_HEADER_FIELD */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "NIH header fields from the object or command bus\n of the pipeline for the recirculated packet.\n",
    },
    {
        .name  = NIH_HEADER_TRACE_EVENTs,  /* NIH_HEADER_TRACE_EVENT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select one of the sets of 16 contiguous trace events to\n be copied to the NIH header.\n",
    },
    {
        .name  = NIH_HEADER_DROP_ENABLEs,  /* NIH_HEADER_DROP_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy the highest and first drop event\n to the NIH header.\n",
    },
    {
        .name  = NIH_HEADER_OPAQUE_PROPERTYs,  /* NIH_HEADER_OPAQUE_PROPERTY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mirror session index copied to the recirculated packet.",
    },
    {
        .name  = RDB_ENQUEUE_PRIORITYs,  /* RDB_ENQUEUE_PRIORITY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Enqueue priority specified for redirect data buffer(RDB).",
    },
    {
        .name  = DESTINATIONs,  /* DESTINATION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination used for the recirculated packet.",
    },
    {
        .name  = DESTINATION_TYPEs,  /* DESTINATION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Destination type used for the recirculated packet.",
    },
    {
        .name  = CELL_TRUNCATE_LENGTHs,  /* CELL_TRUNCATE_LENGTH */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Truncated size (in cells) for the redirected packet.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the switched packet.",
    },
    {
        .name  = NON_CPU_PORT_COPY_CONTROLs,  /* NON_CPU_PORT_COPY_CONTROL */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Copy action for the recirculated packet\n destined to non-CPU ports.\n",
    },
    {
        .name  = CPU_COPY_CONTROLs,  /* CPU_COPY_CONTROL */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Copy action for the recirculated packet\n destined to CPU ports.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_redirect_profile_t = {
    .name = MON_REDIRECT_PROFILEs, /* MON_REDIRECT_PROFILE */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_mon_redirect_profile_t_fields,
    .desc = "The MON_REDIRECT_PROFILE table is used to specify the egress\n redirect profile attributes which are used to construct\n the NPL defined internal header (NIH) or CPU DMA header for\n the packets redirected into the ingress pipeline.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_TELEMETRY_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_telemetry_control_t_fields[] = {
    {
        .name  = STREAMING_TELEMETRYs,  /* STREAMING_TELEMETRY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to initialize the streaming telemetry embedded\n  application.\n",
    },
    {
        .name  = MAX_EXPORT_LENGTHs,  /* MAX_EXPORT_LENGTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum export packet length in bytes.\n If the telemetry embedded application has been initialized\n (STREAMING_TELEMETRY is enabled), it must be restarted by\n toggling STREAMING_TELEMETRY in order for this field to\n take effect.\n",
    },
    {
        .name  = MAX_EXPORT_LENGTH_OPERs,  /* MAX_EXPORT_LENGTH_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational maximum export length.\n This is a read-only field which reflects the maximum export\n length value that is currently in use.\n",
    },
    {
        .name  = MAX_NUM_PORTSs,  /* MAX_NUM_PORTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of ports that can be monitored by the\n streaming telemetry embedded application\n (STREAMING_TELEMETRY is enabled).\n",
    },
    {
        .name  = MAX_NUM_PORTS_OPERs,  /* MAX_NUM_PORTS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational maximum number of ports.\n This is a read-only field which reflects the maximum\n number of ports that are currently in use by the\n streaming telemetry application.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TELEMETRY_CONTROL_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational\n state of the control table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_telemetry_control_t = {
    .name = MON_TELEMETRY_CONTROLs, /* MON_TELEMETRY_CONTROL */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_mon_telemetry_control_t_fields,
    .desc = "The MON_TELEMETRY_CONTROL table specifies the telemetry\n subsystem controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_TELEMETRY_INSTANCE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_telemetry_instance_t_fields[] = {
    {
        .name  = MON_TELEMETRY_INSTANCE_IDs,  /* MON_TELEMETRY_INSTANCE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_TELEMETRY_INSTANCE table.",
    },
    {
        .name  = CORE_INSTANCEs,  /* CORE_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Core on which this instance needs to be run.",
    },
    {
        .name  = NUM_OBJECTSs,  /* NUM_OBJECTS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of telemetry objects.",
    },
    {
        .name  = MON_TELEMETRY_OBJECT_IDs,  /* MON_TELEMETRY_OBJECT_ID */
        .flags = 0,
        .width = 32,
        .depth = 255,
        .desc = "List of indexes into MON_TELEMETRY_OBJECT table.",
    },
    {
        .name  = MON_COLLECTOR_IDs,  /* MON_COLLECTOR_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "MON_COLLECTOR_IPV4 table index.\n  Collector to which this instance is associated.\n",
    },
    {
        .name  = MON_EXPORT_PROFILE_IDs,  /* MON_EXPORT_PROFILE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "MON_EXPORT_PROFILE table index.\n  Export profile to which this instance is associated.\n",
    },
    {
        .name  = TX_PKTSs,  /* TX_PKTS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets exported.",
    },
    {
        .name  = TX_PKT_FAILSs,  /* TX_PKT_FAILS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets that failed to export.",
    },
    {
        .name  = INSTANCE_OPERATIONAL_STATEs,  /* INSTANCE_OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TELEMETRY_INSTANCE_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of\n the instance entry. The INSTANCE_OPERATIONAL_STATE becomes\n invalid when required conditions are not met for instance\n entry to be operational.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_telemetry_instance_t = {
    .name = MON_TELEMETRY_INSTANCEs, /* MON_TELEMETRY_INSTANCE */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_mon_telemetry_instance_t_fields,
    .desc = "The MON_TELEMETRY_INSTANCE table will monitor a\n specified number of telemetry objects whose statistics need to exported.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/mon/MON_TELEMETRY_OBJECT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_mon_telemetry_object_t_fields[] = {
    {
        .name  = MON_TELEMETRY_OBJECT_IDs,  /* MON_TELEMETRY_OBJECT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the MON_TELEMETRY_OBJECT table.",
    },
    {
        .name  = TELEMETRY_STATs,  /* TELEMETRY_STAT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 5,
        .edata = BCMLTD_COMMON_TELEMETRY_STAT_T_DATA,
        .desc = "Type of statistics that need to be collected.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID of the port being monitored.",
    },
    {
        .name  = PORT_NAME_LENs,  /* PORT_NAME_LEN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Port name length.",
    },
    {
        .name  = PORT_NAMEs,  /* PORT_NAME */
        .flags = 0,
        .width = 8,
        .depth = 10,
        .desc = "Name of the port being monitored.\n  It should be filled with an interface name string.\n",
    },
};
const bcmltd_table_rep_t bcmltd_mon_telemetry_object_t = {
    .name = MON_TELEMETRY_OBJECTs, /* MON_TELEMETRY_OBJECT */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_mon_telemetry_object_t_fields,
    .desc = "The MON_TELEMETRY_OBJECT table is used to configure the statistics\n information associated with a telemetry object.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_AUTH_SHA1.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_auth_sha1_t_fields[] = {
    {
        .name  = OAM_BFD_AUTH_SHA1_IDs,  /* OAM_BFD_AUTH_SHA1_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_AUTH_SHA1 table.",
    },
    {
        .name  = SHA1_KEYs,  /* SHA1_KEY */
        .flags = 0,
        .width = 8,
        .depth = 20,
        .desc = "SHA1 key.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_AUTH_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_auth_sha1_t = {
    .name = OAM_BFD_AUTH_SHA1s, /* OAM_BFD_AUTH_SHA1 */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_oam_bfd_auth_sha1_t_fields,
    .desc = "The OAM_BFD_AUTH_SHA1 table specifies the SHA1 authentication used by BFD\n endpoints.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_AUTH_SIMPLE_PASSWORD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_auth_simple_password_t_fields[] = {
    {
        .name  = OAM_BFD_AUTH_SIMPLE_PASSWORD_IDs,  /* OAM_BFD_AUTH_SIMPLE_PASSWORD_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_AUTH_SIMPLE_PASSWORD table.",
    },
    {
        .name  = PASSWORD_LENs,  /* PASSWORD_LEN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Length of the password.",
    },
    {
        .name  = PASSWORDs,  /* PASSWORD */
        .flags = 0,
        .width = 8,
        .depth = 16,
        .desc = "Password.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_AUTH_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_auth_simple_password_t = {
    .name = OAM_BFD_AUTH_SIMPLE_PASSWORDs, /* OAM_BFD_AUTH_SIMPLE_PASSWORD */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_oam_bfd_auth_simple_password_t_fields,
    .desc = "The OAM_BFD_AUTH_SIMPLE_PASSWORD table specifies the simple password\n authentication used by BFD endpoints.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_control_t_fields[] = {
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to initialize the BFD embedded application.",
    },
    {
        .name  = MAX_ENDPOINTSs,  /* MAX_ENDPOINTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of BFD endpoints that can be created. If the BFD\n embedded application has been initialized (BFD is enabled), it must\n be restarted by toggling BFD in order for this field to take effect.\n",
    },
    {
        .name  = MAX_ENDPOINTS_OPERs,  /* MAX_ENDPOINTS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational maximum number of BFD endpoints. This is a read-only\n which reflects the maximum number of BFD sessions that can currently\n be created.\n",
    },
    {
        .name  = MAX_AUTH_SHA1_KEYSs,  /* MAX_AUTH_SHA1_KEYS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of BFD SHA1 authentication keys. If the BFD embedded\n application has been initialized (BFD is enabled), it must be\n restarted by toggling BFD in order for this field to take effect.\n",
    },
    {
        .name  = MAX_AUTH_SHA1_KEYS_OPERs,  /* MAX_AUTH_SHA1_KEYS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational maximum number of BFD SHA1 authentication keys. This is a\n read-only field which reflects the maximum number of SHA1\n authentication keys that can currently be created.\n",
    },
    {
        .name  = MAX_AUTH_SIMPLE_PASSWORD_KEYSs,  /* MAX_AUTH_SIMPLE_PASSWORD_KEYS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of BFD simple password authentication keys. If the BFD\n embedded application has been initialized (BFD is enabled), it must\n be restarted by toggling BFD in order for this field to take effect.\n",
    },
    {
        .name  = MAX_AUTH_SIMPLE_PASSWORD_KEYS_OPERs,  /* MAX_AUTH_SIMPLE_PASSWORD_KEYS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational maximum number of BFD simple password keys. This is a\n read-only field which reflects the maximum number of simple password\n keys that can currently be created.\n",
    },
    {
        .name  = MAX_PKT_SIZEs,  /* MAX_PKT_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum size of the BFD packet (in bytes) that is transmitted by the\n BFD embedded application. This field is used to allocate memory\n within the embedded application to store the packet to be transmitted\n per endpoint. If this field is set to 0, the application will\n allocate on a per-endpoint basis the exact memory required to store\n the transmit packet of that particular endpoint. If the BFD embedded\n application has been initialized (BFD is enabled), it must be\n restarted by toggling BFD in order for this field to take effect.\n",
    },
    {
        .name  = MAX_PKT_SIZE_OPERs,  /* MAX_PKT_SIZE_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational maximum size of the BFD packet. This is a read-only field\n which reflects the current maximum size of the BFD packet.\n",
    },
    {
        .name  = INTERNAL_LOCAL_DISCRIMINATORs,  /* INTERNAL_LOCAL_DISCRIMINATOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use an internally generated value for the My Discriminator\n field in the transmit BFD control packets. If this field is enabled,\n the Your Discriminator field in the received BFD control packets will\n be used to resolve the endpoint to which it belongs to. If the BFD\n embedded application has been initialized (BFD is enabled), it must\n be restarted by toggling BFD in order for this field to take effect.\n",
    },
    {
        .name  = INTERNAL_LOCAL_DISCRIMINATOR_OPERs,  /* INTERNAL_LOCAL_DISCRIMINATOR_OPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Operational value of the INTERNAL_LOCAL_DISCRIMINATOR field. This is\n a read-only field which reflects whether the endpoint ID is currently\n used as the discriminator.\n",
    },
    {
        .name  = STATIC_REMOTE_DISCRIMINATORs,  /* STATIC_REMOTE_DISCRIMINATOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to prevent the run-time update of the remote discriminator\n based on the received BFD packet's My Discriminator field. If this\n field is enabled, the remote discriminator of all the endpoints will\n be set using the REMOTE_DISCRIMINATOR field in the associated OAM_BFD\n IP or TNL endpoint tables. If this field is not enabled, the remote\n discriminator will change dynamically based on the received packet's\n My discriminator field. If the BFD embedded application has been\n initialized (BFD is enabled), it must be restarted by toggling BFD in\n order for this field to take effect.\n",
    },
    {
        .name  = STATIC_REMOTE_DISCRIMINATOR_OPERs,  /* STATIC_REMOTE_DISCRIMINATOR_OPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Operational value of the STATIC_REMOTE_DISCRIMINATOR field. This is a\n read-only field which reflects whether the remote discriminator is\n currently static or not.\n",
    },
    {
        .name  = LOCAL_STATE_DOWN_EVENT_ON_ENDPOINT_CREATIONs,  /* LOCAL_STATE_DOWN_EVENT_ON_ENDPOINT_CREATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to raise the LOCAL_STATE_DOWN event if the endpoint does not\n transition to Up state after creation within the prescribed interval.\n If this field is not enabled, the LOCAL_STATE_DOWN is only raised if\n the endpoint has transitioned to Up state at least once.\n",
    },
    {
        .name  = CONTROL_PLANE_INDEPENDENCEs,  /* CONTROL_PLANE_INDEPENDENCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set the C (Control Plane Independent) bit when transmitting\n BFD control packets.\n",
    },
    {
        .name  = TXs,  /* TX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow transmission of BFD packets from the endpoints.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_CONTROL_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_control_t = {
    .name = OAM_BFD_CONTROLs, /* OAM_BFD_CONTROL */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_oam_bfd_control_t_fields,
    .desc = "The OAM_BFD_CONTROL table is used to set device level Bidirectional\n Forwarding Detection (BFD) functions.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_EVENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_event_t_fields[] = {
    {
        .name  = OAM_BFD_EVENT_IDs,  /* OAM_BFD_EVENT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_EVENT table.",
    },
    {
        .name  = ENDPOINT_TYPEs,  /* ENDPOINT_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_TYPE_T_DATA,
        .desc = "Type of the BFD endpoint.",
    },
    {
        .name  = OAM_BFD_IPV4_ENDPOINT_IDs,  /* OAM_BFD_IPV4_ENDPOINT_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_IPV4_ENDPOINT table. Applicable when\n ENDPOINT_TYPE is set to IPV4.\n",
    },
    {
        .name  = OAM_BFD_IPV6_ENDPOINT_IDs,  /* OAM_BFD_IPV6_ENDPOINT_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_IPV6_ENDPOINT table. Applicable when\n ENDPOINT_TYPE is set to IPV6.\n",
    },
    {
        .name  = OAM_BFD_TNL_IPV4_ENDPOINT_IDs,  /* OAM_BFD_TNL_IPV4_ENDPOINT_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_IPV4_ENDPOINT table. Applicable when\n ENDPOINT_TYPE is set to TNL_IPV4.\n",
    },
    {
        .name  = OAM_BFD_TNL_IPV6_ENDPOINT_IDs,  /* OAM_BFD_TNL_IPV6_ENDPOINT_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_IPV6_ENDPOINT table. Applicable when\n ENDPOINT_TYPE is set to TNL_IPV6.\n",
    },
    {
        .name  = OAM_BFD_TNL_MPLS_ENDPOINT_IDs,  /* OAM_BFD_TNL_MPLS_ENDPOINT_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_MPLS_ENDPOINT table. Applicable when\n ENDPOINT_TYPE is set to MPLS.\n",
    },
    {
        .name  = EVENTs,  /* EVENT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_DATA,
        .desc = "Reported event.",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_event_t = {
    .name = OAM_BFD_EVENTs, /* OAM_BFD_EVENT */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_oam_bfd_event_t_fields,
    .desc = "The OAM_BFD_EVENT table specifies the events reported by the BFD\n embedded application.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_EVENT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_event_control_t_fields[] = {
    {
        .name  = LOCAL_STATE_ADMIN_DOWNs,  /* LOCAL_STATE_ADMIN_DOWN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report that the endpoint's state has changed to\n ADMIN_DOWN.\n",
    },
    {
        .name  = LOCAL_STATE_DOWNs,  /* LOCAL_STATE_DOWN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report that the endpoint's state has changed to DOWN.",
    },
    {
        .name  = LOCAL_STATE_INITs,  /* LOCAL_STATE_INIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report that the endpoint's state has changed to INIT.",
    },
    {
        .name  = LOCAL_STATE_UPs,  /* LOCAL_STATE_UP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report that the endpoint's state has changed to UP.",
    },
    {
        .name  = REMOTE_STATE_MODE_CHANGEs,  /* REMOTE_STATE_MODE_CHANGE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report that the remote endpoint's state or mode has\n changed.\n",
    },
    {
        .name  = REMOTE_DISCRIMINATOR_CHANGEs,  /* REMOTE_DISCRIMINATOR_CHANGE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report that the remote discriminator has changed.",
    },
    {
        .name  = REMOTE_PARAMETER_CHANGEs,  /* REMOTE_PARAMETER_CHANGE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report that one or more parameters of the remote endpoint\n has changed.\n",
    },
    {
        .name  = REMOTE_POLL_BIT_SETs,  /* REMOTE_POLL_BIT_SET */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report that a packet was received from the remote endpoint\n with the poll bit set.\n",
    },
    {
        .name  = REMOTE_FINAL_BIT_SETs,  /* REMOTE_FINAL_BIT_SET */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report that a packet was received from the remote endpoint\n with the final bit set.\n",
    },
    {
        .name  = MISCONNECTIVITY_DEFECTs,  /* MISCONNECTIVITY_DEFECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report misconnectivity defect.",
    },
    {
        .name  = MISCONNECTIVITY_DEFECT_CLEARs,  /* MISCONNECTIVITY_DEFECT_CLEAR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report that the misconnectivity defect has cleared.",
    },
    {
        .name  = UNEXPECTED_MEG_DEFECTs,  /* UNEXPECTED_MEG_DEFECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report the unexpected MEG defect.",
    },
    {
        .name  = UNEXPECTED_MEG_DEFECT_CLEARs,  /* UNEXPECTED_MEG_DEFECT_CLEAR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report that the unexpected MEG defect has cleared.",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_event_control_t = {
    .name = OAM_BFD_EVENT_CONTROLs, /* OAM_BFD_EVENT_CONTROL */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_oam_bfd_event_control_t_fields,
    .desc = "The OAM_BFD_EVENT_CONTROL table is used to enable event reporting for BFD\n BFD endpoints.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_EVENT_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_event_status_t_fields[] = {
    {
        .name  = OAM_BFD_EVENT_IDs,  /* OAM_BFD_EVENT_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index of the last written entry in the OAM_BFD_EVENT table.",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_event_status_t = {
    .name = OAM_BFD_EVENT_STATUSs, /* OAM_BFD_EVENT_STATUS */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_oam_bfd_event_status_t_fields,
    .desc = "The OAM_BFD_EVENT_STATUS table is a read-only table used to retrieve the\n index of the last written entry in the OAM_BFD_EVENT table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_IPV4_ENDPOINT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_ipv4_endpoint_t_fields[] = {
    {
        .name  = OAM_BFD_IPV4_ENDPOINT_IDs,  /* OAM_BFD_IPV4_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_IPV4_ENDPOINT table.",
    },
    {
        .name  = ROLEs,  /* ROLE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_SESSION_INIT_ROLE_T_DATA,
        .desc = "Role played by this endpoint during session initialization.",
    },
    {
        .name  = TYPEs,  /* TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_IP_ENDPOINT_TYPE_T_DATA,
        .desc = "Type of the IP endpoint.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_DATA,
        .desc = "Endpoint mode.",
    },
    {
        .name  = ECHOs,  /* ECHO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables the echo function on this endpoint.",
    },
    {
        .name  = LOCAL_DISCRIMINATORs,  /* LOCAL_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Local discriminator of this endpoint. Not applicable when\n OAM_BFD_CONTROL.INTERNAL_LOCAL_DISCRIMINATOR_OPER is enabled.\n",
    },
    {
        .name  = REMOTE_DISCRIMINATORs,  /* REMOTE_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Remote discriminator, which is filled as the Your Discriminator field\n in the BFD control packet. When\n OAM_BFD_CONTROL.STATIC_REMOTE_DISCRIMINATOR_OPER is disabled, this\n value may get updated during run-time depending on the BFD packets\n sent by the remote endpoint.\n",
    },
    {
        .name  = DIAG_CODEs,  /* DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the transmit BFD packets. The\n diagnostic code in the packet may change automatically during\n run-time. OAM_BFD_IPV4_ENDPOINT_STATUS.LOCAL_DIAG reflects latest\n diagnostic code being transmitted by this endpoint's BFD packets.\n",
    },
    {
        .name  = MIN_TX_INTERVAL_USECSs,  /* MIN_TX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Desired minimum transmit interval in microseconds. This is the\n minimum interval, in microseconds, that the local device would like\n to use when transmitting BFD control packets.\n",
    },
    {
        .name  = MIN_RX_INTERVAL_USECSs,  /* MIN_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Required minimum receive interval in microseconds. This is the\n minimum interval, in microseconds, between received BFD Control\n packets that this device is capable of supporting.\n",
    },
    {
        .name  = MIN_ECHO_RX_INTERVAL_USECSs,  /* MIN_ECHO_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum echo packet receive interval in microseconds. This is the\n minimum interval, in microseconds, between received BFD Echo packets\n that this device is capable of supporting.\n",
    },
    {
        .name  = DETECT_MULTIPLIERs,  /* DETECT_MULTIPLIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Detection interval multiplier. The negotiated transmit interval\n multiplied by this value, provides the detection time for the\n receiving system in asynchronous mode.\n",
    },
    {
        .name  = AUTH_TYPEs,  /* AUTH_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_AUTH_TYPE_T_DATA,
        .desc = "Authentication type.",
    },
    {
        .name  = OAM_BFD_AUTH_SIMPLE_PASSWORD_IDs,  /* OAM_BFD_AUTH_SIMPLE_PASSWORD_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_AUTH_SIMPLE_PASSWORD table. Applicable when\n AUTH_TYPE is set to SIMPLE_PASSWORD.\n",
    },
    {
        .name  = OAM_BFD_AUTH_SHA1_IDs,  /* OAM_BFD_AUTH_SHA1_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_AUTH_SHA1 table. Applicable when AUTH_TYPE is\n set to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = INITIAL_SHA1_SEQ_NUMs,  /* INITIAL_SHA1_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Initial SHA1 sequence number used when transmitting the BFD packet.\n The sequence number will get incremented during run time starting\n from this value. The latest sequence number used when transmitting\n the last packet can be found in\n OAM_BFD_IPV4_ENDPOINT_STATUS.LOCAL_SEQ_NUM. Applicable when AUTH_TYPE\n is set to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = SHA1_SEQ_NUM_INCREMENTs,  /* SHA1_SEQ_NUM_INCREMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to increment the SHA1 sequence number in the next packet\n transmitted. Applicable when the AUTH_TYPE is set to KEYED_SHA1.\n The value of the field needs to be toggled to re-increment the\n SHA1 sequence number.\n",
    },
    {
        .name  = POLL_SEQUENCEs,  /* POLL_SEQUENCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Initiate the poll sequence. Enabling this field will set the poll bit\n in the BFD transmit packet until the Final bit is received from the\n remote endpoint. The value of the field needs to be toggled to\n re-initiate the poll sequence.\n",
    },
    {
        .name  = RX_LOOKUP_VLAN_IDs,  /* RX_LOOKUP_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "The outer VLAN ID of the received BFD packet. If this field is set to\n a non-zero value, the VLAN ID is used in conjunction with the source\n IP address of the received packet to resolve the endpoint ID. This\n field is required if packets destined to multiple endpoints have the\n same source IP address.\n",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Port ID on which the BFD packets are sent. In case of micro BFD\n endpoints, the BFD packets need to also ingress the device on this\n port.\n",
    },
    {
        .name  = COSs,  /* COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Class of service queueing for the transmit BFD packets.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the transmit BFD packets.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address of the transmit BFD packets.",
    },
    {
        .name  = TAG_TYPEs,  /* TAG_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "VLAN tag type.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the transmit BFD packets. Applicable only when TAG_TYPE is\n DOUBLE_TAGGED.\n",
    },
    {
        .name  = VLAN_PRIs,  /* VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority of the transmit BFD packets. Applicable only when\n TAG_TYPE is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID of the transmit BFD packets. Applicable only when TAG_TYPE is\n SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_IDs,  /* INNER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID of the transmit BFD packets. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_PRIs,  /* INNER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN CFI of the transmit BFD control packets. Applicable only\n when TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_TPIDs,  /* INNER_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inner TPID of the transmit BFD packets. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address of the transmit BFD packets.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address of the transmit BFD packets. Incoming\n packets are resolved to this endpoint if the source IP address of the\n packets match the value configured here.\n",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 type of service of the transmit BFD packets.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 time to live of the transmit BFD packets. Applicable when the\n field is set to MULTI_HOP.\n",
    },
    {
        .name  = UDP_SRC_PORTs,  /* UDP_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source UDP port of the transmit BFD packets.",
    },
    {
        .name  = TX_MODEs,  /* TX_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_TX_MODE_T_DATA,
        .desc = "Endpoint transmission mode.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_ipv4_endpoint_t = {
    .name = OAM_BFD_IPV4_ENDPOINTs, /* OAM_BFD_IPV4_ENDPOINT */
    .flags = 0,
    .fields = 37,
    .field = bcmltd_oam_bfd_ipv4_endpoint_t_fields,
    .desc = "The OAM_BFD_IPV4_ENDPOINT table is used to create a BFD over IPv4 endpoint\n object.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_IPV4_ENDPOINT_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_ipv4_endpoint_stats_t_fields[] = {
    {
        .name  = OAM_BFD_IPV4_ENDPOINT_IDs,  /* OAM_BFD_IPV4_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_IPV4_ENDPOINT table.",
    },
    {
        .name  = RX_PKT_CNTs,  /* RX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of packets received by the endpoint.",
    },
    {
        .name  = RX_PKT_DISCARD_CNTs,  /* RX_PKT_DISCARD_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of received packets that were discarded by the\n endpoint.\n",
    },
    {
        .name  = RX_PKT_AUTH_FAILURE_DISCARD_CNTs,  /* RX_PKT_AUTH_FAILURE_DISCARD_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of received packets that were discarded by the endpoint\n due to authentication failures.\n",
    },
    {
        .name  = RX_ECHO_REPLY_PKT_CNTs,  /* RX_ECHO_REPLY_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of echo reply packets received by the endpoint.",
    },
    {
        .name  = TX_PKT_CNTs,  /* TX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of packets transmitted by the endpoint.",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_ipv4_endpoint_stats_t = {
    .name = OAM_BFD_IPV4_ENDPOINT_STATSs, /* OAM_BFD_IPV4_ENDPOINT_STATS */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_oam_bfd_ipv4_endpoint_stats_t_fields,
    .desc = "The OAM_BFD_IPV4_ENDPOINT_STATS table is used to retrieve BFD over IPv4\n endpoint statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_IPV4_ENDPOINT_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_ipv4_endpoint_status_t_fields[] = {
    {
        .name  = OAM_BFD_IPV4_ENDPOINT_IDs,  /* OAM_BFD_IPV4_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_IPV4_ENDPOINT table.",
    },
    {
        .name  = LOCAL_STATEs,  /* LOCAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_DATA,
        .desc = "Local session state.",
    },
    {
        .name  = REMOTE_STATEs,  /* REMOTE_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_DATA,
        .desc = "Remote session state.",
    },
    {
        .name  = LOCAL_DIAG_CODEs,  /* LOCAL_DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the transmit BFD packets.",
    },
    {
        .name  = REMOTE_DIAG_CODEs,  /* REMOTE_DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the BFD packets received from the\n remote endpoint.\n",
    },
    {
        .name  = LOCAL_AUTH_SEQ_NUMs,  /* LOCAL_AUTH_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The last authentication sequence number transmitted by the local\n endpoint. Applicable when OAM_BFD_IPV4_ENDPOINT.AUTH_TYPE is set to\n KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = REMOTE_AUTH_SEQ_NUMs,  /* REMOTE_AUTH_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Last authentication sequence number received from the remote\n endpoint. Applicable when OAM_BFD_IPV4_ENDPOINT.AUTH_TYPE is set to\n KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = POLL_SEQUENCE_ACTIVEs,  /* POLL_SEQUENCE_ACTIVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if the poll sequence is currently active.",
    },
    {
        .name  = REMOTE_MODEs,  /* REMOTE_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_DATA,
        .desc = "Remote endpoint mode.",
    },
    {
        .name  = LOCAL_DISCRIMINATORs,  /* LOCAL_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Discriminator of the local endpoint. Applicable when\n OAM_BFD_CONTROL.INTERNAL_LOCAL_DISCRIMINATOR_OPER is enabled.\n",
    },
    {
        .name  = REMOTE_DISCRIMINATORs,  /* REMOTE_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Discriminator of the remote endpoint. If\n OAM_BFD_CONTROL.STATIC_REMOTE_DISCRIMINATOR_OPER is enabled, this\n field contains the remote discriminator configured in\n OAM_BFD_IPV4_ENPOINT.REMOTE_DISCRIMINATOR.\n",
    },
    {
        .name  = REMOTE_DETECT_MULTIPLIERs,  /* REMOTE_DETECT_MULTIPLIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Detection interval multiplier of the remote endpoint.",
    },
    {
        .name  = REMOTE_MIN_TX_INTERVAL_USECSs,  /* REMOTE_MIN_TX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Desired minimum transmit interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = REMOTE_MIN_RX_INTERVAL_USECSs,  /* REMOTE_MIN_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Required minimum receive interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = REMOTE_MIN_ECHO_RX_INTERVAL_USECSs,  /* REMOTE_MIN_ECHO_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum echo packet receive interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = ENDPOINT_STATEs,  /* ENDPOINT_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_ID_STATE_T_DATA,
        .desc = "Reflects the state of the associated OAM_BFD_IPV4_ENDPOINT\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_ipv4_endpoint_status_t = {
    .name = OAM_BFD_IPV4_ENDPOINT_STATUSs, /* OAM_BFD_IPV4_ENDPOINT_STATUS */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_oam_bfd_ipv4_endpoint_status_t_fields,
    .desc = "The OAM_BFD_IPV4_ENDPOINT_STATUS table is a read only table used to retrieve\n the run-time status parameters of a BFD over IPv4 endpoint.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_IPV6_ENDPOINT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_ipv6_endpoint_t_fields[] = {
    {
        .name  = OAM_BFD_IPV6_ENDPOINT_IDs,  /* OAM_BFD_IPV6_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_IPV6_ENDPOINT table.",
    },
    {
        .name  = ROLEs,  /* ROLE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_SESSION_INIT_ROLE_T_DATA,
        .desc = "Role played by this endpoint during session initialization.",
    },
    {
        .name  = TYPEs,  /* TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_IP_ENDPOINT_TYPE_T_DATA,
        .desc = "Type of the IP endpoint.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_DATA,
        .desc = "Endpoint mode.",
    },
    {
        .name  = ECHOs,  /* ECHO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables the echo function on this endpoint.",
    },
    {
        .name  = LOCAL_DISCRIMINATORs,  /* LOCAL_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Local discriminator of this endpoint. Not applicable when\n OAM_BFD_CONTROL.INTERNAL_LOCAL_DISCRIMINATOR_OPER is enabled.\n",
    },
    {
        .name  = REMOTE_DISCRIMINATORs,  /* REMOTE_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Remote discriminator, which is filled as the Your Discriminator field\n in the BFD control packet. When\n OAM_BFD_CONTROL.STATIC_REMOTE_DISCRIMINATOR_OPER is disabled, this\n value may get updated during run-time depending on the BFD packets\n sent by the remote endpoint.\n",
    },
    {
        .name  = DIAG_CODEs,  /* DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the transmit BFD packets. The\n diagnostic code in the packet may change automatically during\n run-time. OAM_BFD_IPV6_ENDPOINT_STATUS.LOCAL_DIAG reflects latest\n diagnostic code being transmitted by this endpoint's BFD packets.\n",
    },
    {
        .name  = MIN_TX_INTERVAL_USECSs,  /* MIN_TX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Desired minimum transmit interval in microseconds. This is the\n minimum interval, in microseconds, that the local device would like\n to use when transmitting BFD control packets.\n",
    },
    {
        .name  = MIN_RX_INTERVAL_USECSs,  /* MIN_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Required minimum receive interval in microseconds. This is the\n minimum interval, in microseconds, between received BFD Control\n packets that this device is capable of supporting.\n",
    },
    {
        .name  = MIN_ECHO_RX_INTERVAL_USECSs,  /* MIN_ECHO_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum echo packet receive interval in microseconds. This is the\n minimum interval, in microseconds, between received BFD Echo packets\n that this device is capable of supporting.\n",
    },
    {
        .name  = DETECT_MULTIPLIERs,  /* DETECT_MULTIPLIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Detection interval multiplier. The negotiated transmit interval\n multiplied by this value, provides the detection time for the\n receiving system in asynchronous mode.\n",
    },
    {
        .name  = AUTH_TYPEs,  /* AUTH_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_AUTH_TYPE_T_DATA,
        .desc = "Authentication type.",
    },
    {
        .name  = OAM_BFD_AUTH_SIMPLE_PASSWORD_IDs,  /* OAM_BFD_AUTH_SIMPLE_PASSWORD_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_AUTH_SIMPLE_PASSWORD table. Applicable when\n AUTH_TYPE is set to SIMPLE_PASSWORD.\n",
    },
    {
        .name  = OAM_BFD_AUTH_SHA1_IDs,  /* OAM_BFD_AUTH_SHA1_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_AUTH_SHA1 table. Applicable when AUTH_TYPE is\n set to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = INITIAL_SHA1_SEQ_NUMs,  /* INITIAL_SHA1_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Initial SHA1 sequence number used when transmitting the BFD packet.\n The sequence number will get incremented during run time starting\n from this value. The latest sequence number used when transmitting\n the last packet can be found in\n OAM_BFD_IPV6_ENDPOINT_STATUS.LOCAL_SEQ_NUM. Applicable when AUTH_TYPE\n is set to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = SHA1_SEQ_NUM_INCREMENTs,  /* SHA1_SEQ_NUM_INCREMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to increment the SHA1 sequence number in the next packet\n transmitted. Applicable when the AUTH_TYPE is set to KEYED_SHA1.\n The value of the field needs to be toggled to re-increment the\n SHA1 sequence number.\n",
    },
    {
        .name  = POLL_SEQUENCEs,  /* POLL_SEQUENCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Initiate the poll sequence. Enabling this field will set the poll bit\n in the BFD transmit packet until the Final bit is received from the\n remote endpoint. The value of the field needs to be toggled to\n re-initiate the poll sequence.\n",
    },
    {
        .name  = RX_LOOKUP_VLAN_IDs,  /* RX_LOOKUP_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "The outer VLAN ID of the received BFD packet. If this field is set to\n a non-zero value, the VLAN ID is used in conjunction with the source\n IP address of the received packet to resolve the endpoint ID. This\n field is required if packets destined to multiple endpoints have the\n same source IP address.\n",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Port ID on which the BFD packets are sent. In case of micro BFD\n endpoints, the BFD packets need to also ingress the device on this\n port.\n",
    },
    {
        .name  = COSs,  /* COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Class of service queueing for the transmit BFD packets.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the transmit BFD packets.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address of the transmit BFD packets.",
    },
    {
        .name  = TAG_TYPEs,  /* TAG_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "VLAN tag type.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the transmit BFD packets. Applicable only when TAG_TYPE is\n DOUBLE_TAGGED.\n",
    },
    {
        .name  = VLAN_PRIs,  /* VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority of the transmit BFD packets. Applicable only when\n TAG_TYPE is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID of the transmit BFD packets. Applicable only when TAG_TYPE is\n SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_IDs,  /* INNER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID of the transmit BFD packets. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_PRIs,  /* INNER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN CFI of the transmit BFD control packets. Applicable only\n when TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_TPIDs,  /* INNER_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inner TPID of the transmit BFD packets. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address of the transmit BFD packets.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address of the transmit BFD packets.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address of the transmit BFD packets. Incoming\n packets are resolved to this endpoint if the source IP address of the\n packets match the value configured here.\n",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address of the transmit BFD packets. Incoming\n packets are resolved to this endpoint if the source IP address of the\n packets match the value configured here.\n",
    },
    {
        .name  = TRAFFIC_CLASSs,  /* TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 traffic class of the transmit BFD packets.",
    },
    {
        .name  = HOP_LIMITs,  /* HOP_LIMIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 hop limit of the transmit BFD packets. Applicable when the\n field is set to MULTI_HOP.\n",
    },
    {
        .name  = UDP_SRC_PORTs,  /* UDP_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source UDP port of the transmit BFD packets.",
    },
    {
        .name  = TX_MODEs,  /* TX_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_TX_MODE_T_DATA,
        .desc = "Endpoint transmission mode.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_ipv6_endpoint_t = {
    .name = OAM_BFD_IPV6_ENDPOINTs, /* OAM_BFD_IPV6_ENDPOINT */
    .flags = 0,
    .fields = 39,
    .field = bcmltd_oam_bfd_ipv6_endpoint_t_fields,
    .desc = "The OAM_BFD_IPV6_ENDPOINT table is used to create a BFD over IPv6\n endpoint object.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_IPV6_ENDPOINT_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_ipv6_endpoint_stats_t_fields[] = {
    {
        .name  = OAM_BFD_IPV6_ENDPOINT_IDs,  /* OAM_BFD_IPV6_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_IPV6_ENDPOINT table.",
    },
    {
        .name  = RX_PKT_CNTs,  /* RX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of packets received by the endpoint.",
    },
    {
        .name  = RX_PKT_DISCARD_CNTs,  /* RX_PKT_DISCARD_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of received packets that were discarded by the\n endpoint.\n",
    },
    {
        .name  = RX_PKT_AUTH_FAILURE_DISCARD_CNTs,  /* RX_PKT_AUTH_FAILURE_DISCARD_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of received packets that were discarded by the endpoint\n due to authentication failures.\n",
    },
    {
        .name  = RX_ECHO_REPLY_PKT_CNTs,  /* RX_ECHO_REPLY_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of echo reply packets received by the endpoint.",
    },
    {
        .name  = TX_PKT_CNTs,  /* TX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of packets transmitted by the endpoint.",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_ipv6_endpoint_stats_t = {
    .name = OAM_BFD_IPV6_ENDPOINT_STATSs, /* OAM_BFD_IPV6_ENDPOINT_STATS */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_oam_bfd_ipv6_endpoint_stats_t_fields,
    .desc = "The OAM_BFD_IPV6_ENDPOINT_STATS table is used to retrieve BFD over IPv6\n endpoint statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_IPV6_ENDPOINT_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_ipv6_endpoint_status_t_fields[] = {
    {
        .name  = OAM_BFD_IPV6_ENDPOINT_IDs,  /* OAM_BFD_IPV6_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_IPV6_ENDPOINT table.",
    },
    {
        .name  = LOCAL_STATEs,  /* LOCAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_DATA,
        .desc = "Local session state.",
    },
    {
        .name  = REMOTE_STATEs,  /* REMOTE_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_DATA,
        .desc = "Remote session state.",
    },
    {
        .name  = LOCAL_DIAG_CODEs,  /* LOCAL_DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the transmit BFD packets.",
    },
    {
        .name  = REMOTE_DIAG_CODEs,  /* REMOTE_DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the BFD packets received from the\n remote endpoint.\n",
    },
    {
        .name  = LOCAL_AUTH_SEQ_NUMs,  /* LOCAL_AUTH_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The last authentication sequence number transmitted by the local\n endpoint. Applicable when OAM_BFD_IPV6_ENDPOINT.AUTH_TYPE is set to\n KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = REMOTE_AUTH_SEQ_NUMs,  /* REMOTE_AUTH_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Last authentication sequence number received from the remote\n endpoint. Applicable when OAM_BFD_IPV6_ENDPOINT.AUTH_TYPE is set to\n KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = POLL_SEQUENCE_ACTIVEs,  /* POLL_SEQUENCE_ACTIVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if the poll sequence is currently active.",
    },
    {
        .name  = REMOTE_MODEs,  /* REMOTE_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_DATA,
        .desc = "Remote endpoint mode.",
    },
    {
        .name  = LOCAL_DISCRIMINATORs,  /* LOCAL_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Discriminator of the local endpoint. Applicable when\n OAM_BFD_CONTROL.INTERNAL_LOCAL_DISCRIMINATOR_OPER is enabled.\n",
    },
    {
        .name  = REMOTE_DISCRIMINATORs,  /* REMOTE_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Discriminator of the remote endpoint. If\n OAM_BFD_CONTROL.STATIC_REMOTE_DISCRIMINATOR_OPER is enabled, this\n field contains the remote discriminator configured in\n OAM_BFD_IPV6_ENPOINT.REMOTE_DISCRIMINATOR.\n",
    },
    {
        .name  = REMOTE_DETECT_MULTIPLIERs,  /* REMOTE_DETECT_MULTIPLIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Detection interval multiplier of the remote endpoint.",
    },
    {
        .name  = REMOTE_MIN_TX_INTERVAL_USECSs,  /* REMOTE_MIN_TX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Desired minimum transmit interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = REMOTE_MIN_RX_INTERVAL_USECSs,  /* REMOTE_MIN_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Required minimum receive interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = REMOTE_MIN_ECHO_RX_INTERVAL_USECSs,  /* REMOTE_MIN_ECHO_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum echo packet receive interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = ENDPOINT_STATEs,  /* ENDPOINT_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_ID_STATE_T_DATA,
        .desc = "Reflects the state of the associated OAM_BFD_IPV6_ENDPOINT\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_ipv6_endpoint_status_t = {
    .name = OAM_BFD_IPV6_ENDPOINT_STATUSs, /* OAM_BFD_IPV6_ENDPOINT_STATUS */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_oam_bfd_ipv6_endpoint_status_t_fields,
    .desc = "The OAM_BFD_IPV6_ENDPOINT_STATUS table is a read only table used to retrieve\n the run-time status parameters of a BFD over IPv6 endpoint.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_stats_t_fields[] = {
    {
        .name  = RX_PKT_VERSION_ERRORs,  /* RX_PKT_VERSION_ERROR */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received with version error.",
    },
    {
        .name  = RX_PKT_LENGTH_ERRORs,  /* RX_PKT_LENGTH_ERROR */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received with invalid length.",
    },
    {
        .name  = RX_PKT_ZERO_DETECT_MULTIPLIERs,  /* RX_PKT_ZERO_DETECT_MULTIPLIER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received with detect multiplier set to 0.",
    },
    {
        .name  = RX_PKT_ZERO_MY_DISCRIMINATORs,  /* RX_PKT_ZERO_MY_DISCRIMINATOR */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received with My Discriminator field set to 0.",
    },
    {
        .name  = RX_PKT_P_AND_F_BITS_SETs,  /* RX_PKT_P_AND_F_BITS_SET */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received with P (Poll) and F (Final) bits set.",
    },
    {
        .name  = RX_PKT_M_BIT_SETs,  /* RX_PKT_M_BIT_SET */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received with M (Multipoint) bit set.",
    },
    {
        .name  = RX_PKT_AUTH_MISMATCHs,  /* RX_PKT_AUTH_MISMATCH */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received with incorrect authentication type.",
    },
    {
        .name  = RX_PKT_AUTH_SIMPLE_PASSWORD_ERRORs,  /* RX_PKT_AUTH_SIMPLE_PASSWORD_ERROR */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received with simple password authentication\n error.\n",
    },
    {
        .name  = RX_PKT_AUTH_SHA1_ERRORs,  /* RX_PKT_AUTH_SHA1_ERROR */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received with SHA1 authentication error.",
    },
    {
        .name  = RX_PKT_ENDPOINT_NOT_FOUNDs,  /* RX_PKT_ENDPOINT_NOT_FOUND */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Number of packets received whose endpoints could not be resolved.",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_stats_t = {
    .name = OAM_BFD_STATSs, /* OAM_BFD_STATS */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_oam_bfd_stats_t_fields,
    .desc = "The OAM_BFD_STATS table is used to retrieve global BFD statistics.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_TNL_IPV4_ENDPOINT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_tnl_ipv4_endpoint_t_fields[] = {
    {
        .name  = OAM_BFD_TNL_IPV4_ENDPOINT_IDs,  /* OAM_BFD_TNL_IPV4_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_IP_ENDPOINT table.",
    },
    {
        .name  = ROLEs,  /* ROLE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_SESSION_INIT_ROLE_T_DATA,
        .desc = "Role played by this endpoint during session initialization.",
    },
    {
        .name  = INNER_IP_TYPEs,  /* INNER_IP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_TNL_IP_INNER_IP_TYPE_T_DATA,
        .desc = "Inner IP type.",
    },
    {
        .name  = GREs,  /* GRE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add GRE header needs to be added to the BFD packet.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_DATA,
        .desc = "Endpoint mode.",
    },
    {
        .name  = ECHOs,  /* ECHO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables the echo function on this endpoint.",
    },
    {
        .name  = LOCAL_DISCRIMINATORs,  /* LOCAL_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Local discriminator of this endpoint. Not applicable when\n OAM_BFD_CONTROL.INTERNAL_LOCAL_DISCRIMINATOR_OPER is enabled.\n",
    },
    {
        .name  = REMOTE_DISCRIMINATORs,  /* REMOTE_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Remote discriminator, which is filled as the Your Discriminator field\n in the BFD control packet. When\n OAM_BFD_CONTROL.STATIC_REMOTE_DISCRIMINATOR_OPER is disabled, this\n value may get updated during run-time depending on the BFD packets\n sent by the remote endpoint.\n",
    },
    {
        .name  = DIAG_CODEs,  /* DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the transmit BFD packets. The\n diagnostic code in the packet may change automatically during\n run-time. OAM_BFD_TNL_IPV4_ENDPOINT_STATUS.LOCAL_DIAG reflects the\n latest diagnostic code being transmitted by this endpoint's BFD\n packets.\n",
    },
    {
        .name  = MIN_TX_INTERVAL_USECSs,  /* MIN_TX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Desired minimum transmit interval in microseconds. This is the\n interval, in microseconds, that the local device would like to use\n when transmitting BFD control packets.\n",
    },
    {
        .name  = MIN_RX_INTERVAL_USECSs,  /* MIN_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Required minimum receive interval in microseconds. This is the\n minimum interval, in microseconds, between received BFD Control\n packets that this device is capable of supporting.\n",
    },
    {
        .name  = MIN_ECHO_RX_INTERVAL_USECSs,  /* MIN_ECHO_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum echo packet receive interval in microseconds. This is the\n minimum interval, in microseconds, between received BFD Echo packets\n that this device is capable of supporting.\n",
    },
    {
        .name  = DETECT_MULTIPLIERs,  /* DETECT_MULTIPLIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Detection interval multiplier. The negotiated transmit interval\n multiplied by this value, provides the detection time for the\n system in asynchronous mode.\n",
    },
    {
        .name  = AUTH_TYPEs,  /* AUTH_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_AUTH_TYPE_T_DATA,
        .desc = "Authentication type.",
    },
    {
        .name  = OAM_BFD_AUTH_SIMPLE_PASSWORD_IDs,  /* OAM_BFD_AUTH_SIMPLE_PASSWORD_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the BFD_AUTH_SIMPLE_PASSWORD table. Applicable when\n AUTH_TYPE is set to SIMPLE_PASSWORD.\n",
    },
    {
        .name  = OAM_BFD_AUTH_SHA1_IDs,  /* OAM_BFD_AUTH_SHA1_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_AUTH_SHA1 table. Applicable when AUTH_TYPE is\n set to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = INITIAL_SHA1_SEQ_NUMs,  /* INITIAL_SHA1_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Initial SHA1 sequence number used when transmitting the BFD packet.\n The sequence number will get incremented during run time starting\n from this value. The latest sequence number used when transmitting\n the last packet can be found in\n OAM_BFD_IPV4_ENDPOINT_STATUS.LOCAL_SEQ_NUM. Applicable when AUTH_TYPE\n is set to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = SHA1_SEQ_NUM_INCREMENTs,  /* SHA1_SEQ_NUM_INCREMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to increment the SHA1 sequence number in the next packet\n transmitted. Applicable when the AUTH_TYPE is set to KEYED_SHA1.\n The value of the field needs to be toggled to re-increment the\n SHA1 sequence number.\n",
    },
    {
        .name  = POLL_SEQUENCEs,  /* POLL_SEQUENCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Initiate the poll sequence. Enabling this field will set the poll bit\n in the BFD transmit packet until the Final bit is received from the\n remote endpoint. The value of the field needs to be toggled to\n re-initiate the poll sequence.\n",
    },
    {
        .name  = RX_LOOKUP_VLAN_IDs,  /* RX_LOOKUP_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "The outer VLAN ID of the received BFD packet. If this field is set to\n a non-zero value, the VLAN ID is used in conjunction with the source\n IP address of the received packet to resolve the endpoint ID. This\n field is required if packets destined to multiple endpoints have the\n same source IP address.\n",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Port ID on which the BFD packets are sent.",
    },
    {
        .name  = COSs,  /* COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Class of service queueing for the transmit BFD packets.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the transmit BFD packets.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address of the transmit BFD packets.",
    },
    {
        .name  = TAG_TYPEs,  /* TAG_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "VLAN tag type.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the transmit BFD packets. Applicable only when TAG_TYPE is\n DOUBLE_TAGGED.\n",
    },
    {
        .name  = VLAN_PRIs,  /* VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority of the transmit BFD packets. Applicable only when\n TAG_TYPE is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID of the transmit BFD packets. Applicable only when TAG_TYPE is\n SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_IDs,  /* INNER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID of the transmit BFD packets. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_PRIs,  /* INNER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN CFI of the transmit BFD control packets. Applicable only\n when TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_TPIDs,  /* INNER_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inner TPID of the transmit BFD packets. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address of the transmit BFD packets.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address of the transmit BFD packets. Incoming\n packets are resolved to this endpoint if the source IP address of the\n packets match the value configured here.\n",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 type of service of the transmit BFD packets.",
    },
    {
        .name  = TTLs,  /* TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 Time to live of the transmit BFD packets.",
    },
    {
        .name  = INNER_SRC_IPV4s,  /* INNER_SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Inner source IPv4 address of the transmit BFD packets. Applicable\n when the INNER_IP_TYPE field is set to IPV4.\n",
    },
    {
        .name  = INNER_DST_IPV4s,  /* INNER_DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Inner destination IPv4 address of the transmit BFD packets.\n Applicable when the INNER_IP_TYPE field is set to IPV4.\n",
    },
    {
        .name  = INNER_TOSs,  /* INNER_TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Inner IPv4 type of service of the transmit BFD packets. Applicable\n when the ENCAP_TYPE field is set to IPV4.\n",
    },
    {
        .name  = INNER_SRC_IPV6_UPPERs,  /* INNER_SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Inner source IPv6 address of the transmit BFD packets. Applicable\n when the ENCAP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = INNER_SRC_IPV6_LOWERs,  /* INNER_SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Inner source IPv6 address of the transmit BFD packets. Applicable\n when the ENCAP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = INNER_DST_IPV6_UPPERs,  /* INNER_DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Inner destination IPv6 address of the transmit BFD packets.\n Applicable when the INNER_IP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = INNER_DST_IPV6_LOWERs,  /* INNER_DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Inner destination IPv6 address of the transmit BFD packets.\n Applicable when the INNER_IP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = INNER_TRAFFIC_CLASSs,  /* INNER_TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Inner IPv6 traffic class of the transmit BFD packets. Applicable when\n the ENCAP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = UDP_SRC_PORTs,  /* UDP_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source UDP port of the transmit BFD packets.",
    },
    {
        .name  = TX_MODEs,  /* TX_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_TX_MODE_T_DATA,
        .desc = "Endpoint transmission mode.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_tnl_ipv4_endpoint_t = {
    .name = OAM_BFD_TNL_IPV4_ENDPOINTs, /* OAM_BFD_TNL_IPV4_ENDPOINT */
    .flags = 0,
    .fields = 46,
    .field = bcmltd_oam_bfd_tnl_ipv4_endpoint_t_fields,
    .desc = "The OAM_BFD_TNL_IPV4_ENDPOINT table is used to create a BFD over IPv4\n tunnel endpoint object.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_TNL_IPV4_ENDPOINT_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_tnl_ipv4_endpoint_stats_t_fields[] = {
    {
        .name  = OAM_BFD_TNL_IPV4_ENDPOINT_IDs,  /* OAM_BFD_TNL_IPV4_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_IPV4_ENDPOINT table.",
    },
    {
        .name  = RX_PKT_CNTs,  /* RX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of packets received by the endpoint.",
    },
    {
        .name  = RX_PKT_DISCARD_CNTs,  /* RX_PKT_DISCARD_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of received packets that were discarded by the\n endpoint.\n",
    },
    {
        .name  = RX_PKT_AUTH_FAILURE_DISCARD_CNTs,  /* RX_PKT_AUTH_FAILURE_DISCARD_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of received packets that were discarded by the endpoint\n due to authentication failures.\n",
    },
    {
        .name  = RX_ECHO_REPLY_PKT_CNTs,  /* RX_ECHO_REPLY_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of echo reply packets received by the endpoint.",
    },
    {
        .name  = TX_PKT_CNTs,  /* TX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of packets transmitted by the endpoint.",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_tnl_ipv4_endpoint_stats_t = {
    .name = OAM_BFD_TNL_IPV4_ENDPOINT_STATSs, /* OAM_BFD_TNL_IPV4_ENDPOINT_STATS */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_oam_bfd_tnl_ipv4_endpoint_stats_t_fields,
    .desc = "The OAM_BFD_TNL_IPV4_ENDPOINT_STATS table is used to retrieve BFD over IPv4\n tunnel endpoint statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_TNL_IPV4_ENDPOINT_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_tnl_ipv4_endpoint_status_t_fields[] = {
    {
        .name  = OAM_BFD_TNL_IPV4_ENDPOINT_IDs,  /* OAM_BFD_TNL_IPV4_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_IPV4_ENDPOINT table.",
    },
    {
        .name  = LOCAL_STATEs,  /* LOCAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_DATA,
        .desc = "Local session state.",
    },
    {
        .name  = REMOTE_STATEs,  /* REMOTE_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_DATA,
        .desc = "Remote session state.",
    },
    {
        .name  = LOCAL_DIAG_CODEs,  /* LOCAL_DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the transmit BFD packets.",
    },
    {
        .name  = REMOTE_DIAG_CODEs,  /* REMOTE_DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the BFD packets received from the\n remote endpoint.\n",
    },
    {
        .name  = LOCAL_AUTH_SEQ_NUMs,  /* LOCAL_AUTH_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The last authentication sequence number transmitted by the local\n endpoint. Applicable when OAM_BFD_TNL_IPV4_ENDPOINT.AUTH_TYPE is set\n to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = REMOTE_AUTH_SEQ_NUMs,  /* REMOTE_AUTH_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Last authentication sequence number received from the remote\n endpoint. Applicable when OAM_BFD_TNL_IPV4_ENDPOINT.AUTH_TYPE is set\n to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = POLL_SEQUENCE_ACTIVEs,  /* POLL_SEQUENCE_ACTIVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if the poll sequence is currently active.",
    },
    {
        .name  = REMOTE_MODEs,  /* REMOTE_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_DATA,
        .desc = "Remote endpoint mode.",
    },
    {
        .name  = LOCAL_DISCRIMINATORs,  /* LOCAL_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Discriminator of the local endpoint. Applicable when\n OAM_BFD_CONTROL.INTERNAL_LOCAL_DISCRIMINATOR_OPER is enabled.\n",
    },
    {
        .name  = REMOTE_DISCRIMINATORs,  /* REMOTE_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Discriminator of the remote endpoint. If\n OAM_BFD_CONTROL.STATIC_REMOTE_DISCRIMINATOR_OPER is enabled, this\n field contains the remote discriminator configured in\n OAM_BFD_TNL_IPV4_ENPOINT.REMOTE_DISCRIMINATOR.\n",
    },
    {
        .name  = REMOTE_DETECT_MULTIPLIERs,  /* REMOTE_DETECT_MULTIPLIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Detection interval multiplier of the remote endpoint.",
    },
    {
        .name  = REMOTE_MIN_TX_INTERVAL_USECSs,  /* REMOTE_MIN_TX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Desired minimum transmit interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = REMOTE_MIN_RX_INTERVAL_USECSs,  /* REMOTE_MIN_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Required minimum receive interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = REMOTE_MIN_ECHO_RX_INTERVAL_USECSs,  /* REMOTE_MIN_ECHO_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum echo packet receive interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = ENDPOINT_STATEs,  /* ENDPOINT_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_ID_STATE_T_DATA,
        .desc = "Reflects the state of the associated OAM_BFD_TNL_IPV4_ENDPOINT\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_tnl_ipv4_endpoint_status_t = {
    .name = OAM_BFD_TNL_IPV4_ENDPOINT_STATUSs, /* OAM_BFD_TNL_IPV4_ENDPOINT_STATUS */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_oam_bfd_tnl_ipv4_endpoint_status_t_fields,
    .desc = "The OAM_BFD_TNL_IPV4_ENDPOINT_STATUS table is a read only table used to\n retrieve the run-time status parameters of a BFD over IPv4 tunnel endpoint.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_TNL_IPV6_ENDPOINT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_tnl_ipv6_endpoint_t_fields[] = {
    {
        .name  = OAM_BFD_TNL_IPV6_ENDPOINT_IDs,  /* OAM_BFD_TNL_IPV6_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_IP_ENDPOINT table.",
    },
    {
        .name  = ROLEs,  /* ROLE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_SESSION_INIT_ROLE_T_DATA,
        .desc = "Role played by this endpoint during session initialization.",
    },
    {
        .name  = INNER_IP_TYPEs,  /* INNER_IP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_TNL_IP_INNER_IP_TYPE_T_DATA,
        .desc = "Inner IP type.",
    },
    {
        .name  = GREs,  /* GRE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add GRE header needs to be added to the BFD packet.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_DATA,
        .desc = "Endpoint mode.",
    },
    {
        .name  = ECHOs,  /* ECHO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables the echo function on this endpoint.",
    },
    {
        .name  = LOCAL_DISCRIMINATORs,  /* LOCAL_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Local discriminator of this endpoint. Not applicable when\n OAM_BFD_CONTROL.INTERNAL_LOCAL_DISCRIMINATOR_OPER is enabled.\n",
    },
    {
        .name  = REMOTE_DISCRIMINATORs,  /* REMOTE_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Remote discriminator, which is filled as the Your Discriminator field\n in the BFD control packet. When\n OAM_BFD_CONTROL.STATIC_REMOTE_DISCRIMINATOR_OPER is disabled, this\n value may get updated during run-time depending on the BFD packets\n sent by the remote endpoint.\n",
    },
    {
        .name  = DIAG_CODEs,  /* DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the transmit BFD packets. The\n diagnostic code in the packet may change automatically during\n run-time. OAM_BFD_TNL_IPV6_ENDPOINT_STATUS.LOCAL_DIAG reflects the\n latest diagnostic code being transmitted by this endpoint's BFD\n packets.\n",
    },
    {
        .name  = MIN_TX_INTERVAL_USECSs,  /* MIN_TX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Desired minimum transmit interval in microseconds. This is the\n interval, in microseconds, that the local device would like to use\n when transmitting BFD control packets.\n",
    },
    {
        .name  = MIN_RX_INTERVAL_USECSs,  /* MIN_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Required minimum receive interval in microseconds. This is the\n minimum interval, in microseconds, between received BFD Control\n packets that this device is capable of supporting.\n",
    },
    {
        .name  = MIN_ECHO_RX_INTERVAL_USECSs,  /* MIN_ECHO_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum echo packet receive interval in microseconds. This is the\n minimum interval, in microseconds, between received BFD Echo packets\n that this device is capable of supporting.\n",
    },
    {
        .name  = DETECT_MULTIPLIERs,  /* DETECT_MULTIPLIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Detection interval multiplier. The negotiated transmit interval\n multiplied by this value, provides the detection time for the\n system in asynchronous mode.\n",
    },
    {
        .name  = AUTH_TYPEs,  /* AUTH_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_AUTH_TYPE_T_DATA,
        .desc = "Authentication type.",
    },
    {
        .name  = OAM_BFD_AUTH_SIMPLE_PASSWORD_IDs,  /* OAM_BFD_AUTH_SIMPLE_PASSWORD_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the BFD_AUTH_SIMPLE_PASSWORD table. Applicable when\n AUTH_TYPE is set to SIMPLE_PASSWORD.\n",
    },
    {
        .name  = OAM_BFD_AUTH_SHA1_IDs,  /* OAM_BFD_AUTH_SHA1_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_AUTH_SHA1 table. Applicable when AUTH_TYPE is\n set to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = INITIAL_SHA1_SEQ_NUMs,  /* INITIAL_SHA1_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Initial SHA1 sequence number used when transmitting the BFD packet.\n The sequence number will get incremented during run time starting\n from this value. The latest sequence number used when transmitting\n the last packet can be found in\n OAM_BFD_IPV6_ENDPOINT_STATUS.LOCAL_SEQ_NUM. Applicable when AUTH_TYPE\n is set to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = SHA1_SEQ_NUM_INCREMENTs,  /* SHA1_SEQ_NUM_INCREMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to increment the SHA1 sequence number in the next packet\n transmitted. Applicable when the AUTH_TYPE is set to KEYED_SHA1.\n The value of the field needs to be toggled to re-increment the\n SHA1 sequence number.\n",
    },
    {
        .name  = POLL_SEQUENCEs,  /* POLL_SEQUENCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Initiate the poll sequence. Enabling this field will set the poll bit\n in the BFD transmit packet until the Final bit is received from the\n remote endpoint. The value of the field needs to be toggled to\n re-initiate the poll sequence.\n",
    },
    {
        .name  = RX_LOOKUP_VLAN_IDs,  /* RX_LOOKUP_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "The outer VLAN ID of the received BFD packet. If this field is set to\n a non-zero value, the VLAN ID is used in conjunction with the source\n IP address of the received packet to resolve the endpoint ID. This\n field is required if packets destined to multiple endpoints have the\n same source IP address.\n",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Port ID on which the BFD packets are sent.",
    },
    {
        .name  = COSs,  /* COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Class of service queueing for the transmit BFD packets.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the transmit BFD packets.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address of the transmit BFD packets.",
    },
    {
        .name  = TAG_TYPEs,  /* TAG_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "VLAN tag type.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the transmit BFD packets. Applicable only when TAG_TYPE is\n DOUBLE_TAGGED.\n",
    },
    {
        .name  = VLAN_PRIs,  /* VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority of the transmit BFD packets. Applicable only when\n TAG_TYPE is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID of the transmit BFD packets. Applicable only when TAG_TYPE is\n SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_IDs,  /* INNER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID of the transmit BFD packets. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_PRIs,  /* INNER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN CFI of the transmit BFD control packets. Applicable only\n when TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_TPIDs,  /* INNER_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inner TPID of the transmit BFD packets. Applicable only when\n TAG_STRUCTURE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address of the transmit BFD packets.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address of the transmit BFD packets.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address of the transmit BFD packets. Incoming\n packets are resolved to this endpoint if the source IP address of the\n packets match the value configured here.\n",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address of the transmit BFD packets. Incoming\n packets are resolved to this endpoint if the source IP address of the\n packets match the value configured here.\n",
    },
    {
        .name  = TRAFFIC_CLASSs,  /* TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 traffic class of the transmit BFD packets.",
    },
    {
        .name  = HOP_LIMITs,  /* HOP_LIMIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 hop limit of the transmit BFD packets.",
    },
    {
        .name  = INNER_SRC_IPV4s,  /* INNER_SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Inner source IPv4 address of the transmit BFD packets. Applicable\n when the INNER_IP_TYPE field is set to IPV4.\n",
    },
    {
        .name  = INNER_DST_IPV4s,  /* INNER_DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Inner destination IPv4 address of the transmit BFD packets.\n Applicable when the INNER_IP_TYPE field is set to IPV4.\n",
    },
    {
        .name  = INNER_TOSs,  /* INNER_TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Inner IPv4 type of service of the transmit BFD packets. Applicable\n when the ENCAP_TYPE field is set to IPV4.\n",
    },
    {
        .name  = INNER_SRC_IPV6_UPPERs,  /* INNER_SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Inner source IPv6 address of the transmit BFD packets. Applicable\n when the ENCAP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = INNER_SRC_IPV6_LOWERs,  /* INNER_SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Inner source IPv6 address of the transmit BFD packets. Applicable\n when the ENCAP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = INNER_DST_IPV6_UPPERs,  /* INNER_DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Inner destination IPv6 address of the transmit BFD packets.\n Applicable when the INNER_IP_TYPE field is set to IPV4.\n",
    },
    {
        .name  = INNER_DST_IPV6_LOWERs,  /* INNER_DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Inner destination IPv6 address of the transmit BFD packets.\n Applicable when the INNER_IP_TYPE field is set to IPV4.\n",
    },
    {
        .name  = INNER_TRAFFIC_CLASSs,  /* INNER_TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Inner IPv6 traffic class of the transmit BFD packets. Applicable when\n the ENCAP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = UDP_SRC_PORTs,  /* UDP_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source UDP port of the transmit BFD packets.",
    },
    {
        .name  = TX_MODEs,  /* TX_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_TX_MODE_T_DATA,
        .desc = "Endpoint transmission mode.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_tnl_ipv6_endpoint_t = {
    .name = OAM_BFD_TNL_IPV6_ENDPOINTs, /* OAM_BFD_TNL_IPV6_ENDPOINT */
    .flags = 0,
    .fields = 48,
    .field = bcmltd_oam_bfd_tnl_ipv6_endpoint_t_fields,
    .desc = "The OAM_BFD_TNL_IPV6_ENDPOINT table is used to create a BFD over IPv6\n tunnel endpoint object.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_TNL_IPV6_ENDPOINT_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_tnl_ipv6_endpoint_stats_t_fields[] = {
    {
        .name  = OAM_BFD_TNL_IPV6_ENDPOINT_IDs,  /* OAM_BFD_TNL_IPV6_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_IPV6_ENDPOINT table.",
    },
    {
        .name  = RX_PKT_CNTs,  /* RX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of packets received by the endpoint.",
    },
    {
        .name  = RX_PKT_DISCARD_CNTs,  /* RX_PKT_DISCARD_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of received packets that were discarded by the\n endpoint.\n",
    },
    {
        .name  = RX_PKT_AUTH_FAILURE_DISCARD_CNTs,  /* RX_PKT_AUTH_FAILURE_DISCARD_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of received packets that were discarded by the endpoint\n due to authentication failures.\n",
    },
    {
        .name  = RX_ECHO_REPLY_PKT_CNTs,  /* RX_ECHO_REPLY_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of echo reply packets received by the endpoint.",
    },
    {
        .name  = TX_PKT_CNTs,  /* TX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of packets transmitted by the endpoint.",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_tnl_ipv6_endpoint_stats_t = {
    .name = OAM_BFD_TNL_IPV6_ENDPOINT_STATSs, /* OAM_BFD_TNL_IPV6_ENDPOINT_STATS */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_oam_bfd_tnl_ipv6_endpoint_stats_t_fields,
    .desc = "The OAM_BFD_TNL_IPV6_ENDPOINT_STATS table is used to retrieve BFD over IPv6\n tunnel endpoint statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_TNL_IPV6_ENDPOINT_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_tnl_ipv6_endpoint_status_t_fields[] = {
    {
        .name  = OAM_BFD_TNL_IPV6_ENDPOINT_IDs,  /* OAM_BFD_TNL_IPV6_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_IPV6_ENDPOINT table.",
    },
    {
        .name  = LOCAL_STATEs,  /* LOCAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_DATA,
        .desc = "Local session state.",
    },
    {
        .name  = REMOTE_STATEs,  /* REMOTE_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_DATA,
        .desc = "Remote session state.",
    },
    {
        .name  = LOCAL_DIAG_CODEs,  /* LOCAL_DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the transmit BFD packets.",
    },
    {
        .name  = REMOTE_DIAG_CODEs,  /* REMOTE_DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the BFD packets received from the\n remote endpoint.\n",
    },
    {
        .name  = LOCAL_AUTH_SEQ_NUMs,  /* LOCAL_AUTH_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The last authentication sequence number transmitted by the local\n endpoint. Applicable when OAM_BFD_TNL_IPV6_ENDPOINT.AUTH_TYPE is set\n to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = REMOTE_AUTH_SEQ_NUMs,  /* REMOTE_AUTH_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Last authentication sequence number received from the remote\n endpoint. Applicable when OAM_BFD_TNL_IPV6_ENDPOINT.AUTH_TYPE is set\n to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = POLL_SEQUENCE_ACTIVEs,  /* POLL_SEQUENCE_ACTIVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if the poll sequence is currently active.",
    },
    {
        .name  = REMOTE_MODEs,  /* REMOTE_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_DATA,
        .desc = "Remote endpoint mode.",
    },
    {
        .name  = LOCAL_DISCRIMINATORs,  /* LOCAL_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Discriminator of the local endpoint. Applicable when\n OAM_BFD_CONTROL.INTERNAL_LOCAL_DISCRIMINATOR_OPER is enabled.\n",
    },
    {
        .name  = REMOTE_DISCRIMINATORs,  /* REMOTE_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Discriminator of the remote endpoint. If\n OAM_BFD_CONTROL.STATIC_REMOTE_DISCRIMINATOR_OPER is enabled, this\n field contains the remote discriminator configured in\n OAM_BFD_TNL_IPV6_ENPOINT.REMOTE_DISCRIMINATOR.\n",
    },
    {
        .name  = REMOTE_DETECT_MULTIPLIERs,  /* REMOTE_DETECT_MULTIPLIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Detection interval multiplier of the remote endpoint.",
    },
    {
        .name  = REMOTE_MIN_TX_INTERVAL_USECSs,  /* REMOTE_MIN_TX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Desired minimum transmit interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = REMOTE_MIN_RX_INTERVAL_USECSs,  /* REMOTE_MIN_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Required minimum receive interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = REMOTE_MIN_ECHO_RX_INTERVAL_USECSs,  /* REMOTE_MIN_ECHO_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum echo packet receive interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = ENDPOINT_STATEs,  /* ENDPOINT_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_ID_STATE_T_DATA,
        .desc = "Reflects the state of the associated OAM_BFD_TNL_IPV6_ENDPOINT\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_tnl_ipv6_endpoint_status_t = {
    .name = OAM_BFD_TNL_IPV6_ENDPOINT_STATUSs, /* OAM_BFD_TNL_IPV6_ENDPOINT_STATUS */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_oam_bfd_tnl_ipv6_endpoint_status_t_fields,
    .desc = "The OAM_BFD_TNL_IPV6_ENDPOINT_STATUS table is a read only table used to\n retrieve the run-time status parameters of a BFD over IPv6 tunnel endpoint.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_TNL_MPLS_ENDPOINT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_tnl_mpls_endpoint_t_fields[] = {
    {
        .name  = OAM_BFD_TNL_MPLS_ENDPOINT_IDs,  /* OAM_BFD_TNL_MPLS_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_MPLS_ENDPOINT table.",
    },
    {
        .name  = ROLEs,  /* ROLE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_SESSION_INIT_ROLE_T_DATA,
        .desc = "Role played by this endpoint during session initialization.",
    },
    {
        .name  = ENCAP_TYPEs,  /* ENCAP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_TNL_MPLS_ENDPOINT_ENCAP_TYPE_T_DATA,
        .desc = "Type of encapsulation to be used by the endpoint.",
    },
    {
        .name  = IP_ENCAP_TYPEs,  /* IP_ENCAP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_TNL_MPLS_ENDPOINT_IP_ENCAP_TYPE_T_DATA,
        .desc = "Type of IP encapsulation.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_DATA,
        .desc = "Mode of the endpoint.",
    },
    {
        .name  = LOCAL_DISCRIMINATORs,  /* LOCAL_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Local discriminator of this endpoint. Not applicable when\n OAM_BFD_CONTROL.INTERNAL_LOCAL_DISCRIMINATOR_OPER is enabled.\n",
    },
    {
        .name  = REMOTE_DISCRIMINATORs,  /* REMOTE_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Remote discriminator, which is filled as the Your Discriminator field\n in the BFD control packet. When\n OAM_BFD_CONTROL.STATIC_REMOTE_DISCRIMINATOR_OPER is disabled, this\n value may get updated during run-time depending on the BFD packets\n sent by the remote endpoint.\n",
    },
    {
        .name  = DIAG_CODEs,  /* DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the transmit BFD packets. The\n diagnostic code in the packet may change automatically during\n run-time. OAM_BFD_TNL_MPLS_ENDPOINT_STATUS.LOCAL_DIAG reflects the\n latest diagnostic code being transmitted by this endpoint's BFD\n packets.\n",
    },
    {
        .name  = MIN_TX_INTERVAL_USECSs,  /* MIN_TX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Desired minimum transmit interval in microseconds. This is the\n interval, in microseconds, that the local device would like to use\n when transmitting BFD control packets.\n",
    },
    {
        .name  = MIN_RX_INTERVAL_USECSs,  /* MIN_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Required minimum receive interval in microseconds. This is the\n minimum interval, in microseconds, between received BFD Control\n packets that this device is capable of supporting.\n",
    },
    {
        .name  = DETECT_MULTIPLIERs,  /* DETECT_MULTIPLIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Detection interval multiplier. The negotiated transmit interval\n multiplied by this value, provides the detection time for the\n system in asynchronous mode.\n",
    },
    {
        .name  = AUTH_TYPEs,  /* AUTH_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_AUTH_TYPE_T_DATA,
        .desc = "Authentication type.",
    },
    {
        .name  = OAM_BFD_AUTH_SIMPLE_PASSWORD_IDs,  /* OAM_BFD_AUTH_SIMPLE_PASSWORD_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the BFD_AUTH_SIMPLE_PASSWORD table. Applicable when\n AUTH_TYPE is set to SIMPLE_PASSWORD.\n",
    },
    {
        .name  = OAM_BFD_AUTH_SHA1_IDs,  /* OAM_BFD_AUTH_SHA1_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_AUTH_SHA1 table. Applicable when AUTH_TYPE is\n set to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = INITIAL_SHA1_SEQ_NUMs,  /* INITIAL_SHA1_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Initial SHA1 sequence number used when transmitting the BFD packet.\n The sequence number will get incremented during run time starting\n from this value. The latest sequence number used when transmitting\n the last packet can be found in\n OAM_BFD_TNL_MPLS_ENDPOINT_STATUS.LOCAL_SEQ_NUM. Applicable when\n AUTH_TYPE is set to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = SHA1_SEQ_NUM_INCREMENTs,  /* SHA1_SEQ_NUM_INCREMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to increment the SHA1 sequence number in the next packet\n transmitted. Applicable when the AUTH_TYPE is set to KEYED_SHA1.\n The value of the field needs to be toggled to re-increment the\n SHA1 sequence number.\n",
    },
    {
        .name  = POLL_SEQUENCEs,  /* POLL_SEQUENCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Initiate the poll sequence. Enabling this field will set the poll bit\n in the BFD transmit packet until the Final bit is received from the\n remote endpoint. The value of the field needs to be toggled to\n re-initiate the poll sequence.\n",
    },
    {
        .name  = RX_LOOKUP_LABELs,  /* RX_LOOKUP_LABEL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The label in the received BFD packet identifying the BFD session. The\n received packet is resolved to this endpoint if it's label matches\n with the value configured here.\n",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Port ID on which the BFD packets are sent.",
    },
    {
        .name  = COSs,  /* COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Class of service queueing for transmit BFD packets.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the transmit BFD packets.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address of the transmit BFD packets.",
    },
    {
        .name  = TAG_TYPEs,  /* TAG_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "VLAN tag type.",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID of the transmit BFD packets. Applicable when TAG_TYPE is\n SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = VLAN_PRIs,  /* VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority of the transmit BFD packets. Applicable when TAG_TYPE\n is SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TPID of the transmit BFD packets. Applicable when TAG_TYPE is\n SINGLE_TAGGED or DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_IDs,  /* INNER_VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID of the transmit BFD packets. Applicable when TAG_TYPE\n is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_VLAN_PRIs,  /* INNER_VLAN_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN CFI of the transmit BFD control packets. Applicable when\n TAG_TYPE is DOUBLE_TAGGED.\n",
    },
    {
        .name  = INNER_TPIDs,  /* INNER_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inner TPID of the transmit BFD packets. Applicable when TAG_TYPE is\n DOUBLE_TAGGED.\n",
    },
    {
        .name  = NUM_LABELSs,  /* NUM_LABELS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of MPLS labels in the transmit BFD packets.",
    },
    {
        .name  = LABEL_STACKs,  /* LABEL_STACK */
        .flags = 0,
        .width = 32,
        .depth = 7,
        .desc = "The MPLS label stack of the transmit BFD packets. All labels in the\n transmit packet including the reserved labels must be included, if\n applicable. The order of the labels must be the same as that of the\n transmit packets. The last label must have the Bottom Of Stack (BOS)\n bit set.\n",
    },
    {
        .name  = PW_ACHs,  /* PW_ACH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates if pseudowire (PW) Associated Channel Header (ACH) is\n present in the transmit BFD packets. Applicable when ENCAP_TYPE is\n set to PW.\n",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address of the transmit BFD packets. Applicable when the\n IP_ENCAP_TYPE field is set to IPV4.\n",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address of the transmit BFD packets. Applicable when\n the IP_ENCAP_TYPE field is set to IPV4.\n",
    },
    {
        .name  = TOSs,  /* TOS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv4 type of service of the transmit BFD packets. Applicable when the\n IP_ENCAP_TYPE field is set to IPV4.\n",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address of the transmit BFD packets. Applicable when the\n IP_ENCAP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address of the transmit BFD packets. Applicable when the\n IP_ENCAP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address of the transmit BFD packets. Applicable when\n the IP_ENCAP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address of the transmit BFD packets. Applicable when\n the IP_ENCAP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = TRAFFIC_CLASSs,  /* TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IPv6 traffic class of the transmit BFD packets. Applicable when the\n IP_ENCAP_TYPE field is set to IPV6.\n",
    },
    {
        .name  = UDP_SRC_PORTs,  /* UDP_SRC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source UDP port of the transmit BFD packets.",
    },
    {
        .name  = SOURCE_MEP_IDENTIFIER_LENGTHs,  /* SOURCE_MEP_IDENTIFIER_LENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Length of the SOURCE_MEP_IDENTIFIER. Applicable when the ENCAP_TYPE\n field is set to CC_CV.\n",
    },
    {
        .name  = SOURCE_MEP_IDENTIFIERs,  /* SOURCE_MEP_IDENTIFIER */
        .flags = 0,
        .width = 8,
        .depth = 32,
        .desc = "Source Maintenance Endpoint (MEP) Identifier. Applicable when the\n ENCAP_TYPE field is set to CC_CV.\n",
    },
    {
        .name  = REMOTE_MEP_IDENTIFIER_LENGTHs,  /* REMOTE_MEP_IDENTIFIER_LENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Length of the REMOTE_MEP_IDENTIFIER. Applicable when ENCAP_TYPE is\n set to CC_CV.\n",
    },
    {
        .name  = REMOTE_MEP_IDENTIFIERs,  /* REMOTE_MEP_IDENTIFIER */
        .flags = 0,
        .width = 8,
        .depth = 32,
        .desc = "Remote MEP Identifier. Applicable when ENCAP_TYPE is set to CC_CV.\n",
    },
    {
        .name  = TX_MODEs,  /* TX_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_TX_MODE_T_DATA,
        .desc = "Endpoint transmission mode.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_tnl_mpls_endpoint_t = {
    .name = OAM_BFD_TNL_MPLS_ENDPOINTs, /* OAM_BFD_TNL_MPLS_ENDPOINT */
    .flags = 0,
    .fields = 47,
    .field = bcmltd_oam_bfd_tnl_mpls_endpoint_t_fields,
    .desc = "The OAM_BFD_TNL_MPLS_ENDPOINT table is used to create a BFD over MPLS\n endpoint object.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_TNL_MPLS_ENDPOINT_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_tnl_mpls_endpoint_stats_t_fields[] = {
    {
        .name  = OAM_BFD_TNL_MPLS_ENDPOINT_IDs,  /* OAM_BFD_TNL_MPLS_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_MPLS_ENDPOINT table.",
    },
    {
        .name  = RX_PKT_CNTs,  /* RX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of packets received by the endpoint.",
    },
    {
        .name  = RX_PKT_DISCARD_CNTs,  /* RX_PKT_DISCARD_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of received packets that were discarded by the\n endpoint.\n",
    },
    {
        .name  = RX_PKT_AUTH_FAILURE_DISCARD_CNTs,  /* RX_PKT_AUTH_FAILURE_DISCARD_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of received packets that were discarded by the endpoint\n due to authentication failures.\n",
    },
    {
        .name  = TX_PKT_CNTs,  /* TX_PKT_CNT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Total number of packets transmitted by the endpoint.",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_tnl_mpls_endpoint_stats_t = {
    .name = OAM_BFD_TNL_MPLS_ENDPOINT_STATSs, /* OAM_BFD_TNL_MPLS_ENDPOINT_STATS */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_oam_bfd_tnl_mpls_endpoint_stats_t_fields,
    .desc = "The OAM_BFD_TNL_MPLS_ENDPOINT_STATS table is used to retrieve BFD over MPLS\n tunnel endpoint statistics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/oam/OAM_BFD_TNL_MPLS_ENDPOINT_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_oam_bfd_tnl_mpls_endpoint_status_t_fields[] = {
    {
        .name  = OAM_BFD_TNL_MPLS_ENDPOINT_IDs,  /* OAM_BFD_TNL_MPLS_ENDPOINT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the OAM_BFD_TNL_MPLS_ENDPOINT table.",
    },
    {
        .name  = LOCAL_STATEs,  /* LOCAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_DATA,
        .desc = "Local session state.",
    },
    {
        .name  = REMOTE_STATEs,  /* REMOTE_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_DATA,
        .desc = "Remote session state.",
    },
    {
        .name  = LOCAL_DIAG_CODEs,  /* LOCAL_DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the transmit BFD packets.",
    },
    {
        .name  = REMOTE_DIAG_CODEs,  /* REMOTE_DIAG_CODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_DATA,
        .desc = "Diagnostic code which is set on the BFD packets received from the\n remote endpoint.\n",
    },
    {
        .name  = LOCAL_AUTH_SEQ_NUMs,  /* LOCAL_AUTH_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The last authentication sequence number transmitted by the local\n endpoint. Applicable when OAM_BFD_TNL_MPLS_ENDPOINT.AUTH_TYPE is set\n to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = REMOTE_AUTH_SEQ_NUMs,  /* REMOTE_AUTH_SEQ_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Last authentication sequence number received from the remote\n endpoint. Applicable when OAM_BFD_TNL_MPLS_ENDPOINT.AUTH_TYPE is set\n to KEYED_SHA1 or METICULOUS_KEYED_SHA1.\n",
    },
    {
        .name  = POLL_SEQUENCE_ACTIVEs,  /* POLL_SEQUENCE_ACTIVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if the poll sequence is currently active.",
    },
    {
        .name  = REMOTE_MODEs,  /* REMOTE_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_DATA,
        .desc = "Remote endpoint mode.",
    },
    {
        .name  = LOCAL_DISCRIMINATORs,  /* LOCAL_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Discriminator of the local endpoint. Applicable when\n OAM_BFD_CONTROL.INTERNAL_LOCAL_DISCRIMINATOR_OPER is enabled.\n",
    },
    {
        .name  = REMOTE_DISCRIMINATORs,  /* REMOTE_DISCRIMINATOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Discriminator of the remote endpoint. If\n OAM_BFD_CONTROL.STATIC_REMOTE_DISCRIMINATOR_OPER is enabled, this\n field contains the remote discriminator configured in\n OAM_BFD_TNL_MPLS_ENPOINT.REMOTE_DISCRIMINATOR.\n",
    },
    {
        .name  = REMOTE_DETECT_MULTIPLIERs,  /* REMOTE_DETECT_MULTIPLIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Detection interval multiplier of the remote endpoint.",
    },
    {
        .name  = REMOTE_MIN_TX_INTERVAL_USECSs,  /* REMOTE_MIN_TX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Desired minimum transmit interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = REMOTE_MIN_RX_INTERVAL_USECSs,  /* REMOTE_MIN_RX_INTERVAL_USECS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Required minimum receive interval in microseconds of the remote\n endpoint.\n",
    },
    {
        .name  = MISCONNECTIVITY_DEFECT_MEP_IDENTIFIER_LENGTHs,  /* MISCONNECTIVITY_DEFECT_MEP_IDENTIFIER_LENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Length of the MISCONNECTIVITY_DEFECT_MEP_IDENTIFIER. Applicable when\n OAM_BFD_TNL_MPLS_ENDPOINT.ENCAP_TYPE is set to CC_CV.\n",
    },
    {
        .name  = MISCONNECTIVITY_DEFECT_MEP_IDENTIFIERs,  /* MISCONNECTIVITY_DEFECT_MEP_IDENTIFIER */
        .flags = 0,
        .width = 8,
        .depth = 32,
        .desc = "Misconnectivity defect MEP identifier. A misconnectivity defect is\n raised when the incoming packet?s source MEP ID does not match with\n the configured OAM_BFD_TNL_MPLS_ENDPOINT.REMOTE_MEP_IDENTIFIER. This\n field stores the incorrect MEP ID of the packet that triggered the\n Applicable if BFD_TNL_MPLS_ENDPOINT.ENCAP_TYPE is set to CC_CV.\n",
    },
    {
        .name  = ENDPOINT_STATEs,  /* ENDPOINT_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OAM_BFD_ENDPOINT_ID_STATE_T_DATA,
        .desc = "Reflects the state of the associated OAM_BFD_TNL_MPLS_ENDPOINT\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_oam_bfd_tnl_mpls_endpoint_status_t = {
    .name = OAM_BFD_TNL_MPLS_ENDPOINT_STATUSs, /* OAM_BFD_TNL_MPLS_ENDPOINT_STATUS */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_oam_bfd_tnl_mpls_endpoint_status_t_fields,
    .desc = "The OAM_BFD_TNL_MPLS_ENDPOINT_STATUS table is a read only table used to\n retrieve the run-time status parameters of a BFD over MPLS tunnel endpoint.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_AUTONEG_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_autoneg_profile_t_fields[] = {
    {
        .name  = PC_AUTONEG_PROFILE_IDs,  /* PC_AUTONEG_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Auto-negotiation profile ID.",
    },
    {
        .name  = AN_PARALLEL_DETECTs,  /* AN_PARALLEL_DETECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use parallel detection (no exchange of information).",
    },
    {
        .name  = AUTONEG_MODEs,  /* AUTONEG_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_PHY_AUTONEG_MODE_T_DATA,
        .desc = "Auto-negotiation protocol to be used.",
    },
    {
        .name  = ADVERT_SPEEDs,  /* ADVERT_SPEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Auto-negotiation advertised speed.",
    },
    {
        .name  = MEDIUM_TYPEs,  /* MEDIUM_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_PHY_MEDIUM_T_DATA,
        .desc = "Medium type.",
    },
    {
        .name  = FEC_MODEs,  /* FEC_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_FEC_T_DATA,
        .desc = "FEC mode.",
    },
    {
        .name  = PAUSE_TYPEs,  /* PAUSE_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_PAUSE_T_DATA,
        .desc = "Pause type.",
    },
    {
        .name  = LONG_CHs,  /* LONG_CH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use long channel. So far, this configuration applies\n only to 25G single lane speed, where both base-R FEC and\n RS-FEC are supported. Default is 25G short channel, which\n applies to 25G single lane speed and base-R FEC.\n",
    },
    {
        .name  = NUM_LANESs,  /* NUM_LANES */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "This configuration indicates the number of physical\n lanes that will be used after auto-negotiation is\n completed. It can only be less than or equal to the\n PC_PORTt.NUM_LANES.\n",
    },
    {
        .name  = LINK_TRAINING_OFFs,  /* LINK_TRAINING_OFF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to turn link training off. Default link training is on.",
    },
};
const bcmltd_table_rep_t bcmltd_pc_autoneg_profile_t = {
    .name = PC_AUTONEG_PROFILEs, /* PC_AUTONEG_PROFILE */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_pc_autoneg_profile_t_fields,
    .desc = "The PC_AUTONEG_PROFILE table provides a simple way to share auto-negotiation\n settings across multiple ports of the same type. Furthermore it serves the\n purpose of keeping the PC_PORT table more manageable.\n\n The table has three main sections of which the first one describes\n the supported auto-negotiation methods, the second one describes the\n advertised port operating modes, and the third one describes the\n advertised MAC abilities (PAUSE and EEE).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_FDR_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_fdr_control_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Specify to enable Flight Data Recorder (FDR).\n FDR will clear all previous stats (if any) and start\n collecting the statistics from the start of the next\n Codeword. Start timestamp will show when FDR started.\n",
    },
    {
        .name  = SYMBOL_ERROR_WINDOWs,  /* SYMBOL_ERROR_WINDOW */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Set to indicate the non-overlapping window in which, if\n threshold specified in SYMBOL_ERROR_THRESHOLD is achieved,\n will trigger a notification.\n",
    },
    {
        .name  = SYMBOL_ERROR_THRESHOLDs,  /* SYMBOL_ERROR_THRESHOLD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Indicates a threshold value that triggers a notification to\n the application, if it is achieved in a non-overlapping window\n as specified in SYMBOL_ERROR_WINDOW.\n",
    },
    {
        .name  = SYMBOL_ERROR_START_VALUEs,  /* SYMBOL_ERROR_START_VALUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the number of symbol error start value is\n 9, else it indicates the symbol error start value 0.\n",
    },
    {
        .name  = INTERRUPT_ENABLEs,  /* INTERRUPT_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Specify to enable Flight Data Recorder (FDR) interrupt.\n When enabled, if symbol errors cross the value set in\n SYMBOL_ERROT_THRESHOLD, interrupt triggers. On interrupt\n trigger, FDR statistics are updated.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry whether valid or not.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_fdr_control_t = {
    .name = PC_FDR_CONTROLs, /* PC_FDR_CONTROL */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_pc_fdr_control_t_fields,
    .desc = "The PC_FDR_CONTROL table defines controls for accumulating\n the FEC symbol error information on a port to determine\n the link characteristics.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_FDR_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_fdr_stats_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = FDR_START_TIMEs,  /* FDR_START_TIME */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Indicates the time when the Flight Data Recorder engine\n starts to collect data. The start time indicates either\n the time when FDR is enabled or the time when the\n application reads the statistics.\n",
    },
    {
        .name  = FDR_END_TIMEs,  /* FDR_END_TIME */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Indicates the time when the last statistics are collected\n which are used for the statistics accumulation.\n",
    },
    {
        .name  = UNCORRECTABLE_CODE_WORDSs,  /* UNCORRECTABLE_CODE_WORDS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Indicates the total number of uncorrectable code words.\n",
    },
    {
        .name  = CODE_WORDSs,  /* CODE_WORDS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Total number of code words used for the statistics\n collection.\n",
    },
    {
        .name  = SYMBOL_ERRORSs,  /* SYMBOL_ERRORS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Total number of symbol errors detected.",
    },
    {
        .name  = CODE_WORD_S0_ERRORSs,  /* CODE_WORD_S0_ERRORS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of Code Words (CW) with S + 0 Errors where\n S is specified in SYMBOL_ERROR_START_VALUE field in\n PC_FDR_CONTROL logical table.\n",
    },
    {
        .name  = CODE_WORD_S1_ERRORSs,  /* CODE_WORD_S1_ERRORS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of Code Words (CW) with S + 1 Errors where\n S is specified in SYMBOL_ERROR_START_VALUE field in\n PC_FDR_CONTROL logical table.\n",
    },
    {
        .name  = CODE_WORD_S2_ERRORSs,  /* CODE_WORD_S2_ERRORS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of Code Words (CW) with S + 2 Errors where\n S is specified in SYMBOL_ERROR_START_VALUE field in\n PC_FDR_CONTROL logical table.\n",
    },
    {
        .name  = CODE_WORD_S3_ERRORSs,  /* CODE_WORD_S3_ERRORS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of Code Words (CW) with S + 3 Errors where\n S is specified in SYMBOL_ERROR_START_VALUE field in\n PC_FDR_CONTROL logical table.\n",
    },
    {
        .name  = CODE_WORD_S4_ERRORSs,  /* CODE_WORD_S4_ERRORS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of Code Words (CW) with S + 4 Errors where\n S is specified in SYMBOL_ERROR_START_VALUE field in\n PC_FDR_CONTROL logical table.\n",
    },
    {
        .name  = CODE_WORD_S5_ERRORSs,  /* CODE_WORD_S5_ERRORS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of Code Words (CW) with S + 5 Errors where\n S is specified in SYMBOL_ERROR_START_VALUE field in\n PC_FDR_CONTROL logical table.\n",
    },
    {
        .name  = CODE_WORD_S6_ERRORSs,  /* CODE_WORD_S6_ERRORS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of Code Words (CW) with S + 6 Errors where\n S is specified in SYMBOL_ERROR_START_VALUE field in\n PC_FDR_CONTROL logical table.\n",
    },
    {
        .name  = CODE_WORD_S7_ERRORSs,  /* CODE_WORD_S7_ERRORS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of Code Words (CW) with S + 7 Errors where\n S is specified in SYMBOL_ERROR_START_VALUE field in\n PC_FDR_CONTROL logical table.\n",
    },
    {
        .name  = CODE_WORD_S8_ERRORSs,  /* CODE_WORD_S8_ERRORS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of Code Words (CW) with S + 8 Errors where\n S is specified in SYMBOL_ERROR_START_VALUE field in\n PC_FDR_CONTROL logical table.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry whether valid or not.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_fdr_stats_t = {
    .name = PC_FDR_STATSs, /* PC_FDR_STATS */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_pc_fdr_stats_t_fields,
    .desc = "The FDR table defines the status and statistics\n for the Flight Data Recorder (FDR).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_MAC_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_mac_control_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = OVERSIZE_PKTs,  /* OVERSIZE_PKT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify the threshold value for oversize packet.\n A packet size greater than the threshold value is\n treated as an oversized packet and the MIB for the\n oversize packet is increment. The packet is not\n dropped if this threshold value is less than the\n value of MAX_FRAME_SIZE in PC_PORT,\n",
    },
    {
        .name  = RX_ENABLE_AUTOs,  /* RX_ENABLE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of RX enable.\n When this is set, the RX enable is determined\n internally and is reflected in the RX_ENABLE_OPER\n field.\n",
    },
    {
        .name  = RX_ENABLEs,  /* RX_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable RX on the port.",
    },
    {
        .name  = TX_ENABLE_AUTOs,  /* TX_ENABLE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of TX enable.\n When this is set, the TX enable is determined\n internally and is reflected in the TX_ENABLE_OPER\n field.\n",
    },
    {
        .name  = TX_ENABLEs,  /* TX_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable TX on the port.",
    },
    {
        .name  = LOCAL_FAULT_DISABLEs,  /* LOCAL_FAULT_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to disable the local faults on a port.\n Local faults are enabled by default.\n",
    },
    {
        .name  = REMOTE_FAULT_DISABLEs,  /* REMOTE_FAULT_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to disable the remote faults on a port.\n Remote faults are enabled by default.\n",
    },
    {
        .name  = INTER_FRAME_GAP_AUTOs,  /* INTER_FRAME_GAP_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of Inter-Frame Gap (IFG).\n When this is set, the IFG is determined internally and\n is reflected in the INTER_FRAME_GAP_OPER field.\n",
    },
    {
        .name  = INTER_FRAME_GAPs,  /* INTER_FRAME_GAP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specify the IFG in bits for a port.\n",
    },
    {
        .name  = PAUSE_TXs,  /* PAUSE_TX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow PAUSE frame transmission.",
    },
    {
        .name  = PAUSE_RXs,  /* PAUSE_RX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow PAUSE frame reception.",
    },
    {
        .name  = PAUSE_ADDRs,  /* PAUSE_ADDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address to use for PAUSE frames.",
    },
    {
        .name  = PAUSE_PASSs,  /* PAUSE_PASS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow PAUSE packets into the switch device.",
    },
    {
        .name  = CONTROL_PASSs,  /* CONTROL_PASS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow all control packets (including the PFC frames\n with ethertype 0x8808) except PAUSE frames into the switch\n device.\n",
    },
    {
        .name  = RUNT_THRESHOLD_AUTOs,  /* RUNT_THRESHOLD_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of runt threshold value.\n When this is set, the runt threshold is determined internally\n and is reflected in the RUNT_THRESHOLD_OPER field.\n",
    },
    {
        .name  = RUNT_THRESHOLDs,  /* RUNT_THRESHOLD */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specify the runt threshold in bytes for a port, below\n which the packets are dropped and marked as runt,\n incrementing the runt counter value.\n",
    },
    {
        .name  = MAC_ECC_INTR_ENABLEs,  /* MAC_ECC_INTR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable ECC/Parity interrupts supported by MAC.",
    },
    {
        .name  = RX_ENABLE_OPERs,  /* RX_ENABLE_OPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Operational RX setting on a port. This is a read-only field which\n reflects the actual configured RX setting value.\n Valid only is RX_ENABLE_AUTO is enabled.\n",
    },
    {
        .name  = TX_ENABLE_OPERs,  /* TX_ENABLE_OPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Operational TX setting on a port. This is a read-only field which\n reflects the actual configured TX setting value.\n Valid only is TX_ENABLE_AUTO is enabled.\n",
    },
    {
        .name  = INTER_FRAME_GAP_OPERs,  /* INTER_FRAME_GAP_OPER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Operational Inter-Frame Gap (IFG) value. This is a read-only\n field which reflects the actual configured IFG value.\n Valid only is INTER_FRAME_GAP_AUTO is enabled.\n",
    },
    {
        .name  = RUNT_THRESHOLD_OPERs,  /* RUNT_THRESHOLD_OPER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Operational runt threshold value. This is a read-only\n field which reflects the actual configured runt threshold value.\n Valid only is RUNT_THRESHOLD_AUTO is enabled.\n",
    },
    {
        .name  = PAUSE_RX_OPERs,  /* PAUSE_RX_OPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Operational state of Pause RX. This is a read-only\n field which reflects the actual configured Pause RX setting.\n Valid only is RUNT_THRESHOLD_AUTO is enabled.\n",
    },
    {
        .name  = PAUSE_TX_OPERs,  /* PAUSE_TX_OPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Operational state of Pause TX. This is a read-only\n field which reflects the actual configured Pause TX setting.\n",
    },
    {
        .name  = STALL_TXs,  /* STALL_TX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to stall the transmission of packets on a port.\n When set, the packets are stored in the buffers consuming\n the same. The STALL_TX_STATUS field in PC_PORT_STATUS\n indicates current setting.\n",
    },
    {
        .name  = STALL_TX_OPERs,  /* STALL_TX_OPER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_STALL_TX_STATUS_T_DATA,
        .desc = "Operational state of STALL_TX. This is a read-only\n field which reflects the actual configured state or\n if this feature is not supported.\n",
    },
    {
        .name  = PURGE_DRIBBLE_NIBBLE_ERROR_FRAMESs,  /* PURGE_DRIBBLE_NIBBLE_ERROR_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet received with Dribble Nibble Error\n and trigger the receive packets error counter, else allow this\n packets into the switch.\n",
    },
    {
        .name  = PURGE_MACSEC_FRAMESs,  /* PURGE_MACSEC_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop the MACSEC packets received with\n good CRC and trigger the receive packets error counter, else allow\n the packets into the switch.\n",
    },
    {
        .name  = PURGE_SCH_CRC_ERRORs,  /* PURGE_SCH_CRC_ERROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop the packets received with errors in\n Stub Control Header (SCH) CRC and trigger the packet receive\n error counter, else allow the packet into the switch. This\n is valid only in SCH mode.\n",
    },
    {
        .name  = PURGE_PFC_FRAMESs,  /* PURGE_PFC_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop the PFC packets received and trigger\n the receive packets error counter, else allow the PFC frame\n into the switch.\n",
    },
    {
        .name  = PURGE_RUNT_FRAMESs,  /* PURGE_RUNT_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop RUNT packets received and trigger the\n receive packets error counter,\n",
    },
    {
        .name  = RX_FIFO_FULLs,  /* RX_FIFO_FULL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect RX FIFO buffers full and trigger the\n receive packets error counter,\n",
    },
    {
        .name  = PURGE_UNICAST_FRAMESs,  /* PURGE_UNICAST_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the Unicast packets received and trigger the\n receive packets error counter, else allow the Unicast frame\n into the switch.\n",
    },
    {
        .name  = PURGE_VLAN_TAGGED_FRAMESs,  /* PURGE_VLAN_TAGGED_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop good Vlan tagged packet received and\n trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_BAD_OPCODE_FRAMESs,  /* PURGE_BAD_OPCODE_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop incorrect opcode packet received and\n trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_PAUSE_FRAMESs,  /* PURGE_PAUSE_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop PAUSE control frames received and\n trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_CONTROL_FRAMESs,  /* PURGE_CONTROL_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop Layer 2 Control frames received and\n trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_PROMISCUOUS_FRAMESs,  /* PURGE_PROMISCUOUS_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop promiscuous frames received and\n trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_BROADCAST_FRAMESs,  /* PURGE_BROADCAST_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop broadcast frames received and\n trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_MULTICAST_FRAMESs,  /* PURGE_MULTICAST_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop multicast frames received and\n trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_GOOD_FRAMESs,  /* PURGE_GOOD_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop good (no errors) frames received and\n trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_TRUNCATED_FRAMESs,  /* PURGE_TRUNCATED_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop truncated/out of range frames received\n and trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_LENGTH_CHECK_FAIL_FRAMESs,  /* PURGE_LENGTH_CHECK_FAIL_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop frames with IEEE length check failed\n and trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_CRC_ERROR_FRAMESs,  /* PURGE_CRC_ERROR_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop frames with CRC errors and\n trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_RX_CODE_ERROR_FRAMESs,  /* PURGE_RX_CODE_ERROR_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop frames with RX terminate/code errors\n and trigger the receive packets error counter, else allow the\n frames into the switch.\n",
    },
    {
        .name  = PURGE_UNSUPPORTED_PAUSE_PFC_DAs,  /* PURGE_UNSUPPORTED_PAUSE_PFC_DA */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop frames received with unsupported\n MAC destination address in PAUSE/PFC control frames and\n trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_STACK_VLAN_FRAMESs,  /* PURGE_STACK_VLAN_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop stack vlan tagged packet received and\n trigger the receive packets error counter, else allow the frame\n into the switch.\n",
    },
    {
        .name  = PURGE_WRONG_SAs,  /* PURGE_WRONG_SA */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect and drop frames received with wrong MAC source\n address and trigger the receive packets error counter, else allow\n the frames into the switch.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n 1. PORT_ID to physical port map is missing.\n 2. PORT_ID speed and number of lanes configuration is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_mac_control_t = {
    .name = PC_MAC_CONTROLs, /* PC_MAC_CONTROL */
    .flags = 0,
    .fields = 49,
    .field = bcmltd_pc_mac_control_t_fields,
    .desc = "The PC_MAC_CONTROL table defines MAC control configuation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PFC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_pfc_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = ENABLE_RXs,  /* ENABLE_RX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow PFC frames reception.",
    },
    {
        .name  = ENABLE_TXs,  /* ENABLE_TX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow PFC frames transmission.",
    },
    {
        .name  = ENABLE_STATSs,  /* ENABLE_STATS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to do PFC frames statistics.",
    },
    {
        .name  = REFRESH_TIMERs,  /* REFRESH_TIMER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Threshold for pause timer to cause XOFF to be resent. Set to 0 to\n disable this feature.\n",
    },
    {
        .name  = DEST_ADDRs,  /* DEST_ADDR */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address to use for the PFC frame.",
    },
    {
        .name  = ETH_TYPEs,  /* ETH_TYPE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "EtherType to use for PFC frame.",
    },
    {
        .name  = OPCODEs,  /* OPCODE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Opcode to use for PFC frame.",
    },
    {
        .name  = XOFF_TIMERs,  /* XOFF_TIMER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Time value sent in the Timer Field for classes in XOFF state.",
    },
    {
        .name  = PFC_PASSs,  /* PFC_PASS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow PFC packets into switch device.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n 1. PORT_ID to physical port map is missing.\n 2. PORT_ID speed and number of lanes configuration is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_pfc_t = {
    .name = PC_PFCs, /* PC_PFC */
    .flags = 0,
    .fields = 11,
    .field = bcmltd_pc_pfc_t_fields,
    .desc = "The PC_PFC table defines the Priority-based Flow Control (PFC) configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PHYS_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_phys_port_t_fields[] = {
    {
        .name  = PC_PHYS_PORT_IDs,  /* PC_PHYS_PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Physical device port ID.",
    },
    {
        .name  = PC_PM_IDs,  /* PC_PM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Port macro ID.",
    },
    {
        .name  = PM_PHYS_PORTs,  /* PM_PHYS_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Physical port macro port number (0..MAX_PHYS_PORTS_PER_PM).",
    },
};
const bcmltd_table_rep_t bcmltd_pc_phys_port_t = {
    .name = PC_PHYS_PORTs, /* PC_PHYS_PORT */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_pc_phys_port_t_fields,
    .desc = "The PC_PHYS_PORT table defines the physical device port to port macro ID\n mapping.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PHY_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_phy_control_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = LANE_INDEXs,  /* LANE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Logical lane index of the port.\n",
    },
    {
        .name  = TX_SQUELCH_AUTOs,  /* TX_SQUELCH_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of TX squelch.\n When this is set, the TX squelch value is configured\n internally and is reflected in the PC_PHY_STATUS logical\n table.\n",
    },
    {
        .name  = TX_SQUELCHs,  /* TX_SQUELCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop all traffic going out of the PHY.",
    },
    {
        .name  = RX_SQUELCH_AUTOs,  /* RX_SQUELCH_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of RX squelch.\n When this is set, the RX squelch value is configured\n internally and is reflected in the PC_PHY_STATUS logical\n table.\n",
    },
    {
        .name  = RX_SQUELCHs,  /* RX_SQUELCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop all traffic going into the PHY.",
    },
    {
        .name  = RX_ADAPTATION_RESUME_AUTOs,  /* RX_ADAPTATION_RESUME_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of RX adaptation.\n When this is set, the RX adaptation value is configured\n internally and is reflected in the PC_PHY_STATUS logical\n table.\n",
    },
    {
        .name  = RX_ADAPTION_RESUMEs,  /* RX_ADAPTION_RESUME */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to resume RX adaptation.\n RX adaptation needs to be stopped before modifying any of\n VGA, PF or DFE taps.\n",
    },
    {
        .name  = RX_AFE_VGA_AUTOs,  /* RX_AFE_VGA_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of RX AFE VGA value.\n When this is set, the RX AFE VGA value is configured\n internally and is reflected in the PC_PHY_STATUS logical\n table.\n",
    },
    {
        .name  = RX_AFE_VGAs,  /* RX_AFE_VGA */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "RX AFE VGA set.",
    },
    {
        .name  = RX_AFE_PEAKING_FILTER_AUTOs,  /* RX_AFE_PEAKING_FILTER_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of RX AFE peaking filter value.\n When this is set, the RX AFE peaking filter value is configured\n internally and is reflected in the PC_PHY_STATUS logical\n table.\n",
    },
    {
        .name  = RX_AFE_PEAKING_FILTERs,  /* RX_AFE_PEAKING_FILTER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "RX AFE peaking filter set.",
    },
    {
        .name  = RX_AFE_LOW_FREQ_PEAKING_FILTER_AUTOs,  /* RX_AFE_LOW_FREQ_PEAKING_FILTER_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of RX AFE low frequency\n peaking filter value.\n When this is set, the RX AFE low frequency peaking filter\n value is configured internally and is reflected in the\n PC_PHY_STATUS logical table.\n",
    },
    {
        .name  = RX_AFE_LOW_FREQ_PEAKING_FILTERs,  /* RX_AFE_LOW_FREQ_PEAKING_FILTER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "RX AFE low frequency peaking filter set.",
    },
    {
        .name  = RX_AFE_HIGH_FREQ_PEAKING_FILTER_AUTOs,  /* RX_AFE_HIGH_FREQ_PEAKING_FILTER_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of RX AFE high frequency\n peaking filter value.\n When this is set, the RX AFE high frequency peaking filter\n value is configured internally and is reflected in the\n PC_PHY_STATUS logical table.\n",
    },
    {
        .name  = RX_AFE_HIGH_FREQ_PEAKING_FILTERs,  /* RX_AFE_HIGH_FREQ_PEAKING_FILTER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "RX AFE high frequency peaking filter set.",
    },
    {
        .name  = RX_AFE_DFE_TAP_SIGNs,  /* RX_AFE_DFE_TAP_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 16,
        .desc = "Enable to specify that DFE is negative.",
    },
    {
        .name  = RX_AFE_DFE_TAP_AUTOs,  /* RX_AFE_DFE_TAP_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of DFE value.\n When this is set, the DFE value is configured internally\n and is reflected in the PC_PHY_STATUS logical table.\n",
    },
    {
        .name  = RX_AFE_DFE_TAPs,  /* RX_AFE_DFE_TAP */
        .flags = 0,
        .width = 32,
        .depth = 16,
        .desc = "An array of DFE setting.",
    },
    {
        .name  = PAM4_TX_PATTERN_AUTOs,  /* PAM4_TX_PATTERN_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of PAM4 TX pattern setting.\n When this is set, the PAM4 TX pattern setting is configured\n internally and is reflected in the PC_PHY_STATUS logical table.\n",
    },
    {
        .name  = PAM4_TX_PATTERNs,  /* PAM4_TX_PATTERN */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_PAM4_TX_PATTERN_T_DATA,
        .desc = "Enable PAM4 TX pattern.",
    },
    {
        .name  = PAM4_TX_PRECODER_AUTOs,  /* PAM4_TX_PRECODER_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of PAM4 TX precoder setting.\n When this is set, the PAM4 TX precoder setting is configured\n internally and is reflected in the PC_PHY_STATUS logical table.\n",
    },
    {
        .name  = PAM4_TX_PRECODERs,  /* PAM4_TX_PRECODER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable PAM4 TX precoder.",
    },
    {
        .name  = PHY_ECC_INTR_ENABLE_AUTOs,  /* PHY_ECC_INTR_ENABLE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of SERDES interrupt setting.\n When this is set, the SERDES interrupt setting is configured\n internally and is reflected in the PC_PHY_STATUS logical table.\n",
    },
    {
        .name  = PHY_ECC_INTR_ENABLEs,  /* PHY_ECC_INTR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ECC interrupts if supported.",
    },
    {
        .name  = TX_PI_FREQ_OVERRIDE_SIGNs,  /* TX_PI_FREQ_OVERRIDE_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that TX PI override value is negative.",
    },
    {
        .name  = TX_PI_FREQ_OVERRIDE_AUTOs,  /* TX_PI_FREQ_OVERRIDE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of TX PI frequency setting.\n When this is set, the TX PI frequency setting is configured\n internally and is reflected in the PC_PHY_STATUS logical table.\n",
    },
    {
        .name  = TX_PI_FREQ_OVERRIDEs,  /* TX_PI_FREQ_OVERRIDE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The value of TX PI frequency being overriden",
    },
    {
        .name  = PMD_DEBUG_LANE_EVENT_LOG_LEVELs,  /* PMD_DEBUG_LANE_EVENT_LOG_LEVEL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PMD debug lane event log level for the dsc dump\n The valid values range is 0 to 6.\n",
    },
    {
        .name  = FEC_BYPASS_INDICATION_AUTOs,  /* FEC_BYPASS_INDICATION_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of FEC bypass indication value.\n When this is set, the FEC bypass indication is determined\n internally and is reflected in the PC_PHY_STATUS logical table.\n field.\n",
    },
    {
        .name  = FEC_BYPASS_INDICATIONs,  /* FEC_BYPASS_INDICATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify FEC bypass indication,\n else FEC indication is active.\n This is valid only if FEC is enabled on a logical port\n in PC_PORT.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n 1. PORT_ID to physical port map is missing.\n 2. PORT_ID speed and number of lanes configuration is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_phy_control_t = {
    .name = PC_PHY_CONTROLs, /* PC_PHY_CONTROL */
    .flags = 0,
    .fields = 32,
    .field = bcmltd_pc_phy_control_t_fields,
    .desc = "The PC_PHY_CONTROL table defines PHY control configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PHY_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_phy_status_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = LANE_INDEXs,  /* LANE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Logical lane index of the port.\n",
    },
    {
        .name  = TX_SQUELCHs,  /* TX_SQUELCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate TX squelch status.",
    },
    {
        .name  = RX_SQUELCHs,  /* RX_SQUELCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate RX squelch status.",
    },
    {
        .name  = RX_AFE_VGAs,  /* RX_AFE_VGA */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Current RX AFE VGA setting.",
    },
    {
        .name  = RX_AFE_PEAKING_FILTERs,  /* RX_AFE_PEAKING_FILTER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Currernt RX AFE peaking filter setting.",
    },
    {
        .name  = RX_AFE_LOW_FREQ_PEAKING_FILTERs,  /* RX_AFE_LOW_FREQ_PEAKING_FILTER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Current RX AFE low frequency peaking filter setting.",
    },
    {
        .name  = RX_AFE_HIGH_FREQ_PEAKING_FILTERs,  /* RX_AFE_HIGH_FREQ_PEAKING_FILTER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Current RX AFE high frequency peaking filter setting.",
    },
    {
        .name  = RX_AFE_DFE_TAP_SIGNs,  /* RX_AFE_DFE_TAP_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 16,
        .desc = "Enabled if corresponding DFE value is negative.",
    },
    {
        .name  = RX_AFE_DFE_TAPs,  /* RX_AFE_DFE_TAP */
        .flags = 0,
        .width = 32,
        .depth = 16,
        .desc = "Currnet array of DFE setting.",
    },
    {
        .name  = RX_SIGNAL_DETECTs,  /* RX_SIGNAL_DETECT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Set to indicate RX Signal is detected.",
    },
    {
        .name  = PAM4_TX_PATTERNs,  /* PAM4_TX_PATTERN */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_PAM4_TX_PATTERN_T_DATA,
        .desc = "Get PAM4 TX pattern.",
    },
    {
        .name  = PAM4_TX_PRECODERs,  /* PAM4_TX_PRECODER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Get PAM4 TX precoder.",
    },
    {
        .name  = PHY_ECC_INTR_ENABLEs,  /* PHY_ECC_INTR_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ECC interrupts if supported.",
    },
    {
        .name  = TX_PI_FREQ_OVERRIDE_SIGNs,  /* TX_PI_FREQ_OVERRIDE_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate that TX PI override value is negative.",
    },
    {
        .name  = TX_PI_FREQ_OVERRIDEs,  /* TX_PI_FREQ_OVERRIDE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The value of TX PI frequency being overriden",
    },
    {
        .name  = FEC_BYPASS_INDICATIONs,  /* FEC_BYPASS_INDICATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate FEC bypass indication,\n else FEC indication is active.\n This is valid only if FEC is enabled on a logical port\n in PC_PORT.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_phy_status_t = {
    .name = PC_PHY_STATUSs, /* PC_PHY_STATUS */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_pc_phy_status_t_fields,
    .desc = "The PC_PHY_STATUS table displays PHY configuration status.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PMD_FIRMWARE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_pmd_firmware_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = DFE_AUTOs,  /* DFE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of DFE (Decision Feedback\n Equalizer). When this is set, the DFE value is determined\n internally and is reflected in the PC_PMD_FIRMWARE_STATUS\n logical table.\n",
    },
    {
        .name  = DFEs,  /* DFE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to turn on DFE.",
    },
    {
        .name  = LP_DFE_AUTOs,  /* LP_DFE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of low-power DFE.\n When this is set, the low-power DFE value is determined\n internally and is reflected in the PC_PMD_FIRMWARE_STATUS\n logical table.\n",
    },
    {
        .name  = LP_DFEs,  /* LP_DFE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to turn on low power DFE.",
    },
    {
        .name  = MEDIUM_TYPE_AUTOs,  /* MEDIUM_TYPE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of media type of logical\n port. When this is set, the media type is determined\n internally and is reflected in the PC_PMD_FIRMWARE_STATUS\n logical table.\n",
    },
    {
        .name  = MEDIUM_TYPEs,  /* MEDIUM_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_PHY_MEDIUM_T_DATA,
        .desc = "Set the media type as Backplane/Copper/Fiber for a port.",
    },
    {
        .name  = CL72_RESTART_TIMEOUT_EN_AUTOs,  /* CL72_RESTART_TIMEOUT_EN_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of Clause72 Restart Timeout\n of a logical port. When this is set, the Clause72 Restart Timeout\n is determined internally and is reflected in the\n PC_PMD_FIRMWARE_STATUS logical table.\n",
    },
    {
        .name  = CL72_RESTART_TIMEOUT_ENs,  /* CL72_RESTART_TIMEOUT_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to restart PMD Rx after 600ms if the link has failed to\n complete training.\n",
    },
    {
        .name  = LP_TX_PRECODER_ON_AUTOs,  /* LP_TX_PRECODER_ON_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of link partner TX precoder status.\n When this is set, the link partner TX precoder status is determined\n internally and is reflected in the PC_PMD_FIRMWARE_STATUS\n logical table.\n",
    },
    {
        .name  = LP_TX_PRECODER_ONs,  /* LP_TX_PRECODER_ON */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to get link partner TX precoder enabled status.\n  RX needs to know if the link partner TX has precoder enabled in\n  forced modes.\n  It is handled automatically during link training.\n",
    },
    {
        .name  = UNRELIABLE_LOS_AUTOs,  /* UNRELIABLE_LOS_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of unreliable LOS.\n When this is set, the unreliable LOS is determined\n internally and is reflected in the PC_PMD_FIRMWARE_STATUS\n logical table.\n",
    },
    {
        .name  = UNRELIABLE_LOSs,  /* UNRELIABLE_LOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set loss of signal not reliable.\n LOSS of signal (LOS) cannot be trusted when UNRELIABLE_LOS == TRUE.\n This is meant for optical modules with non-functional or missing\n optical LOS.\n LOS is reliable when UNRELIABLE_LOS == FALSE.\n",
    },
    {
        .name  = SCRAMBLING_ENABLE_AUTOs,  /* SCRAMBLING_ENABLE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of scrambling enable setting.\n When this is set, the scrambling enable is determined\n internally and is reflected in the PC_PMD_FIRMWARE_STATUS\n logical table.\n",
    },
    {
        .name  = SCRAMBLING_ENABLEs,  /* SCRAMBLING_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable scrambling on a port.\n This is supported on lower speeds (1G, 2.5G 10G).\n",
    },
    {
        .name  = NORMAL_REACH_PAM4_AUTOs,  /* NORMAL_REACH_PAM4_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of normal reach PAM4 mode.\n When this is set, the normal reach PAM4 mode is determined\n internally and is reflected in the PC_PMD_FIRMWARE_STATUS\n logical table.\n",
    },
    {
        .name  = NORMAL_REACH_PAM4s,  /* NORMAL_REACH_PAM4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable per-lane PAM4 forced extended reach mode.\n This is a bitmask to indicate on which lanes the\n Normal Reach PAM4 setting is enabled.\n",
    },
    {
        .name  = EXTENDED_REACH_PAM4_AUTOs,  /* EXTENDED_REACH_PAM4_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of extended reach PAM4 mode.\n When this is set, the normal reach PAM4 mode is determined\n internally and is reflected in the PC_PMD_FIRMWARE_STATUS\n logical table.\n",
    },
    {
        .name  = EXTENDED_REACH_PAM4s,  /* EXTENDED_REACH_PAM4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enable per-lane PAM4 forced extended reach mode.\n This is a bitmask to indicate on which lanes the\n Extended Reach PAM4 setting is enabled.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n 1. PORT_ID to physical port map is missing.\n 2. PORT_ID speed and number of lanes configuration is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_pmd_firmware_t = {
    .name = PC_PMD_FIRMWAREs, /* PC_PMD_FIRMWARE */
    .flags = 0,
    .fields = 20,
    .field = bcmltd_pc_pmd_firmware_t_fields,
    .desc = "PC_PMD_FIRMWARE table defines per port PMD firmware configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PMD_FIRMWARE_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_pmd_firmware_status_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = DFEs,  /* DFE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate DFE (Decision Feedback Equalizer) status.",
    },
    {
        .name  = LP_DFEs,  /* LP_DFE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate low power DFE status.",
    },
    {
        .name  = MEDIUM_TYPEs,  /* MEDIUM_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_PHY_MEDIUM_T_DATA,
        .desc = "Media type selected for a port.",
    },
    {
        .name  = CL72_RESTART_TIMEOUT_ENs,  /* CL72_RESTART_TIMEOUT_EN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate restart PMD is set after link training failed",
    },
    {
        .name  = LP_TX_PRECODER_ONs,  /* LP_TX_PRECODER_ON */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate getting link partner TX precoder is set.",
    },
    {
        .name  = UNRELIABLE_LOSs,  /* UNRELIABLE_LOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "/* Enabled to indicate loss of signal (LOS) not reliable is set.\n LOS is reliable when UNRELIABLE_LOS == FALSE.\n",
    },
    {
        .name  = SCRAMBLING_ENABLEs,  /* SCRAMBLING_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate scrambling on a port.",
    },
    {
        .name  = NORMAL_REACH_PAM4s,  /* NORMAL_REACH_PAM4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enabled to indicate  per-lane PAM4 forced normal\n reach mode. This is a bitmask to indicate on which\n lanes the Normal Reach PAM4 setting is enabled.\n",
    },
    {
        .name  = EXTENDED_REACH_PAM4s,  /* EXTENDED_REACH_PAM4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Enabled to indicate  per-lane PAM4 forced extended\n reach mode. This is a bitmask to indicate on which\n lanes the Extended Reach PAM4 setting is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_pmd_firmware_status_t = {
    .name = PC_PMD_FIRMWARE_STATUSs, /* PC_PMD_FIRMWARE_STATUS */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_pc_pmd_firmware_status_t_fields,
    .desc = "PC_PMD_FIRMWARE_STATUS table display per lane PMD firmware configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PM_CORE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_pm_core_t_fields[] = {
    {
        .name  = PC_PM_IDs,  /* PC_PM_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Port macro ID.",
    },
    {
        .name  = CORE_INDEXs,  /* CORE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Core index within port macro (typically 0).",
    },
    {
        .name  = PMD_COM_CLKs,  /* PMD_COM_CLK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Digital common clock that PMD uses for management ports,\n  common user registers and digital logic.\n",
    },
    {
        .name  = TX_LANE_MAP_AUTOs,  /* TX_LANE_MAP_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of TX lane map.\n When this is set, the TX lane map enable is determined\n internally and is reflected in the TX_LANE_MAP_OPER\n field.\n",
    },
    {
        .name  = TX_LANE_MAPs,  /* TX_LANE_MAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Bits[3:0] is lane 0 mapping, bits[7:4] is lane 1 mapping, etc.",
    },
    {
        .name  = TX_LANE_MAP_OPERs,  /* TX_LANE_MAP_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational TX lane map setting of a port macro.\n This is a read-only field which reflects the actual\n configured TX lane map setting.\n Valid only is TX_LANE_MAP_AUTO is enabled.\n",
    },
    {
        .name  = RX_LANE_MAP_AUTOs,  /* RX_LANE_MAP_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of RX lane map.\n When this is set, the RX lane map enable is determined\n internally and is reflected in the RX_LANE_MAP_OPER\n field.\n",
    },
    {
        .name  = RX_LANE_MAPs,  /* RX_LANE_MAP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Bits[3:0] is lane 0 mapping, bits[7:4] is lane 1 mapping, etc.",
    },
    {
        .name  = RX_LANE_MAP_OPERs,  /* RX_LANE_MAP_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational RX lane map setting of a port macro.\n This is a read-only field which reflects the actual\n configured RX lane map setting.\n Valid only is RX_LANE_MAP_AUTO is enabled.\n",
    },
    {
        .name  = TX_POLARITY_FLIP_AUTOs,  /* TX_POLARITY_FLIP_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of TX polarity flip.\n When this is set, the TX polarity flip is determined\n internally and is reflected in the TX_POLARITY_FLIP_OPER\n field.\n",
    },
    {
        .name  = TX_POLARITY_FLIPs,  /* TX_POLARITY_FLIP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Bit 0 flips lane 0, bit 1 flips lane 1, etc.",
    },
    {
        .name  = TX_POLARITY_FLIP_OPERs,  /* TX_POLARITY_FLIP_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational TX polarity flip setting of a port macro.\n This is a read-only field which reflects the actual\n configured TX polarity flip setting.\n Valid only is TX_POLARITY_FLIP_AUTO is enabled.\n",
    },
    {
        .name  = RX_POLARITY_FLIP_AUTOs,  /* RX_POLARITY_FLIP_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic configuration of RX polarity flip.\n When this is set, the RX polarity flip is determined\n internally and is reflected in the RX_POLARITY_FLIP_OPER\n field.\n",
    },
    {
        .name  = RX_POLARITY_FLIPs,  /* RX_POLARITY_FLIP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Bit 0 flips lane 0, bit 1 flips lane 1, etc.",
    },
    {
        .name  = RX_POLARITY_FLIP_OPERs,  /* RX_POLARITY_FLIP_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational RX polarity flip setting of a port macro.\n This is a read-only field which reflects the actual\n configured RX polarity flip setting.\n Valid only is RX_POLARITY_FLIP_AUTO is enabled.\n",
    },
    {
        .name  = PM_MODEs,  /* PM_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicate the PM mode",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_pm_core_t = {
    .name = PC_PM_COREs, /* PC_PM_CORE */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_pc_pm_core_t_fields,
    .desc = "The PC_PM_CORE table is used to configure the board-related properties of a\n port macro core.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PM_PROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_pm_prop_t_fields[] = {
    {
        .name  = PC_PM_IDs,  /* PC_PM_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Port macro ID.",
    },
    {
        .name  = PM_TYPEs,  /* PM_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_PM_TYPE_T_DATA,
        .desc = "Port macro type.",
    },
    {
        .name  = NUM_LANESs,  /* NUM_LANES */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of physical lanes.",
    },
    {
        .name  = NUM_PORTSs,  /* NUM_PORTS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of physical ports.",
    },
    {
        .name  = NUM_AGGRs,  /* NUM_AGGR */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of aggregated cores (for multi-core port macros).",
    },
    {
        .name  = NUM_PLLs,  /* NUM_PLL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of PLLs supported by the port macro.",
    },
    {
        .name  = VCO_RATEs,  /* VCO_RATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 2,
        .desc = "List of active PLL VCO values used by the port macro.",
    },
    {
        .name  = TVCO_SOURCE_INDEXs,  /* TVCO_SOURCE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VCO value of the index of VCO_RATE used as TVCO.",
    },
};
const bcmltd_table_rep_t bcmltd_pc_pm_prop_t = {
    .name = PC_PM_PROPs, /* PC_PM_PROP */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_pc_pm_prop_t_fields,
    .desc = "The PC_PM_PROP read-only table shows the port macro properties.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to administratively enable the port.\n\n A port must be enabled in order to forward packets. If a port is not\n enabled, the driver will attempt to bring down any active link on the\n port, usually by powering down the PHY. If no PHY is associated with\n the port, the MAC will be disabled.\n",
    },
    {
        .name  = SPEEDs,  /* SPEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Port speed (Mbps) to be configured.",
    },
    {
        .name  = NUM_LANESs,  /* NUM_LANES */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of physical lanes.",
    },
    {
        .name  = FEC_MODEs,  /* FEC_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_FEC_T_DATA,
        .desc = "FEC (Forward Error Correction) mode.",
    },
    {
        .name  = ENCAPs,  /* ENCAP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENCAP_T_DATA,
        .desc = "Packet encapsulation type.",
    },
    {
        .name  = LINK_TRAININGs,  /* LINK_TRAINING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable Link training (Clause 72) on a port.",
    },
    {
        .name  = LOOPBACK_MODEs,  /* LOOPBACK_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_LOOPBACK_T_DATA,
        .desc = "Loopback mode.",
    },
    {
        .name  = MAX_FRAME_SIZEs,  /* MAX_FRAME_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum frame size (includes FCS, excludes IEEE 802.3q tags).",
    },
    {
        .name  = LAG_FAILOVERs,  /* LAG_FAILOVER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to support LAG failover.",
    },
    {
        .name  = AUTONEGs,  /* AUTONEG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable auto-negotiation on a port.",
    },
    {
        .name  = NUM_VALID_AN_PROFILESs,  /* NUM_VALID_AN_PROFILES */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid auto-negotiation profiles.",
    },
    {
        .name  = PC_AUTONEG_PROFILE_IDs,  /* PC_AUTONEG_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "Auto-negotiation profile to use when auto_negotiaton is enabled.\n Multiple profiles are supported.\n",
    },
    {
        .name  = RLMs,  /* RLM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable RLM (Reduced Lane Mode).\n RLM provides for application-controlled adaptive lane usage\n as a function of signal quality or bandwidth utilization.\n Applicable when AUTONEG is false.\n",
    },
    {
        .name  = INITIATORs,  /* INITIATOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate that this port decides the speed\n between the RLM link partner (follower) based on the\n number of lanes from the ACTIVE_LANE_MASK. Applicable\n when RLM is true.\n",
    },
    {
        .name  = ACTIVE_LANE_MASKs,  /* ACTIVE_LANE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Active lane mask to be used for a logical port\n when RLM is enabled and INITIATOR is true.\n",
    },
    {
        .name  = SPEED_VCO_FREQs,  /* SPEED_VCO_FREQ */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_SPEED_VCO_T_DATA,
        .desc = "Custom VCO (Voltage-Controlled Oscillator) frequency setting.",
    },
    {
        .name  = SUSPENDs,  /* SUSPEND */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate that the port is in suspended state,\n disable enqueuing the packets to the port and MMU cells\n are drained. Else the port is in normal operational\n state,\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n 1. PORT_ID to physical port map is missing.\n 2. PORT_ID speed and number of lanes configuration is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_port_t = {
    .name = PC_PORTs, /* PC_PORT */
    .flags = 0,
    .fields = 19,
    .field = bcmltd_pc_port_t_fields,
    .desc = "The PC_PORT table defines and configures the operating mode for logical\n ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PORT_ABILITIES.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_port_abilities_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = ABILITY_TYPEs,  /* ABILITY_TYPE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The port ability type.",
    },
    {
        .name  = NUM_ABILITIESs,  /* NUM_ABILITIES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of abilities. This is used to index into the\n other fields in this LT to retrieve the respective\n abilities.\n",
    },
    {
        .name  = SPEEDs,  /* SPEED */
        .flags = 0,
        .width = 32,
        .depth = 128,
        .desc = "Supported speeds.",
    },
    {
        .name  = NUM_LANESs,  /* NUM_LANES */
        .flags = 0,
        .width = 8,
        .depth = 128,
        .desc = "Supported number of lanes.",
    },
    {
        .name  = FEC_MODEs,  /* FEC_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 128,
        .edata = BCMLTD_COMMON_PC_FEC_T_DATA,
        .desc = "Supported FEC types.",
    },
    {
        .name  = AUTONEG_MODEs,  /* AUTONEG_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 128,
        .edata = BCMLTD_COMMON_PC_PHY_AUTONEG_MODE_T_DATA,
        .desc = "Supported auto-negotiation modeis.",
    },
    {
        .name  = MEDIUM_TYPEs,  /* MEDIUM_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 128,
        .edata = BCMLTD_COMMON_PC_PHY_SUPPORTED_MEDIUM_T_DATA,
        .desc = "Supported media types.",
    },
    {
        .name  = PAUSE_TYPEs,  /* PAUSE_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 128,
        .edata = BCMLTD_COMMON_PC_SUPPORTED_PAUSE_T_DATA,
        .desc = "Supported PAUSE types.",
    },
    {
        .name  = CHANNEL_TYPEs,  /* CHANNEL_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 128,
        .edata = BCMLTD_COMMON_PC_PHY_CHANNEL_TYPE_T_DATA,
        .desc = "Supported PHY channel types.",
    },
};
const bcmltd_table_rep_t bcmltd_pc_port_abilities_t = {
    .name = PC_PORT_ABILITIESs, /* PC_PORT_ABILITIES */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_pc_port_abilities_t_fields,
    .desc = "The PC_PORT_ABILITIES read-only table returns a list of port abilities\n  based on ABILITY_TYPE.\n  Port local abilities includes port force speed abilities and\n  auto-negotiation abilities.\n  Force speed (PC_PORT_ABILITIES.AUTONEG_MODE = PC_PHY_AUTONEG_MODE_NONE)\n  abilities are the list of port abilities with same number of lanes as\n  the port and speeds that are equal to or less than maximum speed of the\n  port.\n  Auto-negotiation abilities are the list of port abilities\n  with number of lanes equal to or less than the port and speeds that\n  equal to or less than maximum speed of the port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PORT_DIAG_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_port_diag_stats_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = FEC_CORRECTED_CODEWORDSs,  /* FEC_CORRECTED_CODEWORDS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "FEC corrected codeword counter. Applicable only if the\n FEC_MODE in the PC_PORT table has a value other than PC_FEC_NONE.\n",
    },
    {
        .name  = FEC_UNCORRECTED_CODEWORDSs,  /* FEC_UNCORRECTED_CODEWORDS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "FEC uncorrected codeword counter. Applicable only if the\n FEC_MODE in the PC_PORT table has a value other than PC_FEC_NONE.\n",
    },
    {
        .name  = FEC_SYMBOL_ERRORSs,  /* FEC_SYMBOL_ERRORS */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "FEC symbol error counter. Applicable only if the\n FEC_MODE in the PC_PORT table has a value other than PC_FEC_NONE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_port_diag_stats_t = {
    .name = PC_PORT_DIAG_STATSs, /* PC_PORT_DIAG_STATS */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_pc_port_diag_stats_t_fields,
    .desc = "The PC_PORT_DIAG_STATS table displays physical layer (PHY) diagnostics\n statistics of a port. Not all statistics in the table might be valid\n for a port, depending on the port configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PORT_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_port_info_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = LAST_OPERATIONAL_STATEs,  /* LAST_OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_DATA,
        .desc = "Reason code for the operation failure.\n",
    },
    {
        .name  = NUM_PORTSs,  /* NUM_PORTS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of valid elements in the PORT array.\n",
    },
    {
        .name  = PORTs,  /* PORT */
        .flags = 0,
        .width = 16,
        .depth = 16,
        .desc = "List of logical ports affected in the LAST_OPERATIONAL_STATE\n field. Applicable when LAST_OPERATIONAL_STATE is set to\n VCO_UNVAIL, PRIMARY_VCO_CFG_INVALID, PC_ABILITY_FEC_CONFLICT.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_port_info_t = {
    .name = PC_PORT_INFOs, /* PC_PORT_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_pc_port_info_t_fields,
    .desc = "The PC_PORT_INFO read-only table provides the status of the last\n operation on PC LTs.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PORT_MONITOR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_port_monitor_t_fields[] = {
    {
        .name  = PM_THREAD_DISABLEs,  /* PM_THREAD_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable PM thread.\n\n Allow PM thread to be disabled for debugging purposes.\n Please beware that proper port operation such as RLM,\n 400G AN and three CW bad recovery cannot be guaranteed,\n if the PM thread is disabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_port_monitor_t = {
    .name = PC_PORT_MONITORs, /* PC_PORT_MONITOR */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_pc_port_monitor_t_fields,
    .desc = "The PC_PORT_MONITOR table provides controls for PC threads.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PORT_PHYS_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_port_phys_map_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = PC_PHYS_PORT_IDs,  /* PC_PHYS_PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Physical device port associated with this logical port.",
    },
};
const bcmltd_table_rep_t bcmltd_pc_port_phys_map_t = {
    .name = PC_PORT_PHYS_MAPs, /* PC_PORT_PHYS_MAP */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_pc_port_phys_map_t_fields,
    .desc = "The PC_PORT_PHYS_MAP table defines logical to physical port mapping.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PORT_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_port_status_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = SPEEDs,  /* SPEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Port operating speed (Mbps).",
    },
    {
        .name  = NUM_LANESs,  /* NUM_LANES */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of lanes used by the port.",
    },
    {
        .name  = MAC_DISABLEDs,  /* MAC_DISABLED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the MAC is disabled.",
    },
    {
        .name  = PHY_DISABLEDs,  /* PHY_DISABLED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate that the PHY is disabled (lanes powered down).",
    },
    {
        .name  = FAILOVER_LOOPBACKs,  /* FAILOVER_LOOPBACK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate the port is in link aggregation group (LAG)\n failover loopback state.\n",
    },
    {
        .name  = PMD_RX_LOCKs,  /* PMD_RX_LOCK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate a PMD RX lock status.",
    },
    {
        .name  = LOCAL_FAULTs,  /* LOCAL_FAULT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate a local fault.",
    },
    {
        .name  = REMOTE_FAULTs,  /* REMOTE_FAULT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate a remote fault.",
    },
    {
        .name  = FEC_MODEs,  /* FEC_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_FEC_T_DATA,
        .desc = "Operational FEC MODE.",
    },
    {
        .name  = LOOPBACKs,  /* LOOPBACK */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_LOOPBACK_T_DATA,
        .desc = "Loopback Mode.",
    },
    {
        .name  = AUTONEGs,  /* AUTONEG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate auto-negotiation is on.",
    },
    {
        .name  = AUTONEG_DONEs,  /* AUTONEG_DONE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate auto-negotiation is successful.",
    },
    {
        .name  = LINK_TRAININGs,  /* LINK_TRAINING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate link training is on.",
    },
    {
        .name  = LINK_TRAINING_DONEs,  /* LINK_TRAINING_DONE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate link training is successful.",
    },
    {
        .name  = ENCAPs,  /* ENCAP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENCAP_T_DATA,
        .desc = "Packet encapsulation type.",
    },
    {
        .name  = RLM_STATUSs,  /* RLM_STATUS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_RLM_STATUS_T_DATA,
        .desc = "RLM status.",
    },
    {
        .name  = PAUSE_RXs,  /* PAUSE_RX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate handling of pause frames on receive side.",
    },
    {
        .name  = PAUSE_TXs,  /* PAUSE_TX */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate capability generating of pause frames oni\n transmit side.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_port_status_t = {
    .name = PC_PORT_STATUSs, /* PC_PORT_STATUS */
    .flags = 0,
    .fields = 19,
    .field = bcmltd_pc_port_status_t_fields,
    .desc = "The PC_PORT_STATUS read-only table provides the current operation mode for\n logical ports based on the hardware status registers.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_PORT_TIMESYNC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_port_timesync_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = IEEE_1588s,  /* IEEE_1588 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable IEEE 1588 timestamping.",
    },
    {
        .name  = ONE_STEP_TIMESTAMPs,  /* ONE_STEP_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable one-step time-stamping.\n Two-step time-stamping is enabled if\n this field is not set.\n Applicable when IEEE_1588 is enabled.\n",
    },
    {
        .name  = IS_SOPs,  /* IS_SOP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to enable 1588 SOP (Start-of-Packet) based\n time-stamping. If this is disabled then it is\n 1588 SFD (Start-of-Frame-Delimiter)\n based time-stamping.\n Applicable when IEEE_1588 is enabled.\n",
    },
    {
        .name  = TS_COMP_MODEs,  /* TS_COMP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_TS_COMP_MODE_T_DATA,
        .desc = "Time synchronization compensation mode.\n Applicable when IEEE_1588 is enabled.\n",
    },
    {
        .name  = STAGE_0_MODEs,  /* STAGE_0_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_SYNCE_STAGE0_MODE_T_DATA,
        .desc = "SyncE stage 0 divider mode.",
    },
    {
        .name  = STAGE_1_MODEs,  /* STAGE_1_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_SYNCE_STAGE1_MODE_T_DATA,
        .desc = "SyncE stage 1 divider mode.",
    },
    {
        .name  = FRACTIONAL_DIVISORs,  /* FRACTIONAL_DIVISOR */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SyncE fractional divisor value.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n 1. PORT_ID to physical port map is missing.\n 2. PORT_ID speed and number of lanes configuration is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_port_timesync_t = {
    .name = PC_PORT_TIMESYNCs, /* PC_PORT_TIMESYNC */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_pc_port_timesync_t_fields,
    .desc = "The PC_PORT_TIMESYNC defines time synchronization features.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_SERDES_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_serdes_config_t_fields[] = {
    {
        .name  = FW_LOAD_METHODs,  /* FW_LOAD_METHOD */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_SERDES_FW_LOAD_METHOD_T_DATA,
        .desc = "Device firmware download method to use.\n",
    },
    {
        .name  = FW_LOAD_VERIFYs,  /* FW_LOAD_VERIFY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Device firmware load verify.\n",
    },
    {
        .name  = FW_CRC_VERIFYs,  /* FW_CRC_VERIFY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Device firmware CRC checksum calculation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_serdes_config_t = {
    .name = PC_SERDES_CONFIGs, /* PC_SERDES_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 3,
    .field = bcmltd_pc_serdes_config_t_fields,
    .desc = "PC_SERDES_CONFIG is used to configure the firmware\n download method.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_TX_TAPS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_tx_taps_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = LANE_INDEXs,  /* LANE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Logical lane index of the port.",
    },
    {
        .name  = TX_PRE_AUTOs,  /* TX_PRE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation and configuration of\n TX FIR pre cursor tap value. When this is set, the\n TX FIR pre cursor tap value is calculated internally\n and is reflected in the PC_TX_TAPS_STATUS logical\n table.\n",
    },
    {
        .name  = TX_PREs,  /* TX_PRE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TX FIR pre cursor tap value.",
    },
    {
        .name  = TX_PRE_SIGNs,  /* TX_PRE_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that TX_PRE value is negative.\n This is only applicatble when TX_PRE_AUTO is not\n set.\n",
    },
    {
        .name  = TX_PRE2_AUTOs,  /* TX_PRE2_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation and configuration of\n TX FIR pre2 cursor tap value. When this is set, the\n TX FIR pre2 cursor tap value is calculated internally\n and is reflected in the PC_TX_TAPS_STATUS logical\n table.\n",
    },
    {
        .name  = TX_PRE2s,  /* TX_PRE2 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TX FIR pre2 cursor tap value.",
    },
    {
        .name  = TX_PRE2_SIGNs,  /* TX_PRE2_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that TX_PRE2 value is negative.\n This is only applicatble when TX_PRE2_AUTO is not\n set.\n",
    },
    {
        .name  = TX_MAIN_AUTOs,  /* TX_MAIN_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation and configuration of\n TX FIR main cursor tap value. When this is set, the\n TX FIR main cursor tap value is calculated internally\n and is reflected in the PC_TX_TAPS_STATUS logical\n table.\n",
    },
    {
        .name  = TX_MAINs,  /* TX_MAIN */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TX FIR main cursor tap value.",
    },
    {
        .name  = TX_MAIN_SIGNs,  /* TX_MAIN_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that TX_MAIN value is negative.\n This is only applicatble when TX_MAIN_AUTO is not\n set.\n",
    },
    {
        .name  = TX_POST_AUTOs,  /* TX_POST_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation and configuration of\n TX FIR post cursor tap value. When this is set, the\n TX FIR post cursor tap value is calculated internally\n and is reflected in the PC_TX_TAPS_STATUS logical\n table.\n",
    },
    {
        .name  = TX_POSTs,  /* TX_POST */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TX FIR post cursor tap value.",
    },
    {
        .name  = TX_POST_SIGNs,  /* TX_POST_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that TX_POST value is negative.\n This is only applicatble when TX_POST_AUTO is not\n set.\n",
    },
    {
        .name  = TX_POST2_AUTOs,  /* TX_POST2_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation and configuration of\n TX FIR post2 cursor tap value. When this is set, the\n TX FIR post2 cursor tap value is calculated internally\n and is reflected in the PC_TX_TAPS_STATUS logical\n table.\n",
    },
    {
        .name  = TX_POST2s,  /* TX_POST2 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TX FIR post2 cursor tap value.",
    },
    {
        .name  = TX_POST2_SIGNs,  /* TX_POST2_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that TX_POST2 value is negative.\n This is only applicatble when TX_POST2_AUTO is not\n set.\n",
    },
    {
        .name  = TX_POST3_AUTOs,  /* TX_POST3_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation and configuration of\n TX FIR post3 cursor tap value. When this is set, the\n TX FIR post3 cursor tap value is calculated internally\n and is reflected in the PC_TX_TAPS_STATUS logical\n table.\n",
    },
    {
        .name  = TX_POST3s,  /* TX_POST3 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TX FIR post3 cursor tap value.",
    },
    {
        .name  = TX_POST3_SIGNs,  /* TX_POST3_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that TX_POST3 value is negative.\n This is only applicatble when TX_POST3_AUTO is not\n set.\n",
    },
    {
        .name  = TX_RPARA_AUTOs,  /* TX_RPARA_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation and configuration of\n TX FIR shunt resistance value. When this is set, the\n TX FIR shunt resistance value is calculated internally\n and is reflected in the PC_TX_TAPS_STATUS logical\n table.\n",
    },
    {
        .name  = TX_RPARAs,  /* TX_RPARA */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TX FIR shunt resistance value.",
    },
    {
        .name  = TX_RPARA_SIGNs,  /* TX_RPARA_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that TX_RPARA value is negative.\n This is only applicatble when TX_RPARA_AUTO is not\n set.\n",
    },
    {
        .name  = TX_AMP_AUTOs,  /* TX_AMP_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation and configuration of\n TX amplitude value. When this is set, the\n TX amplitude value is calculated internally\n and is reflected in the PC_TX_TAPS_STATUS logical\n table.\n",
    },
    {
        .name  = TX_AMPs,  /* TX_AMP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TX amplitude control.",
    },
    {
        .name  = TX_AMP_SIGNs,  /* TX_AMP_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that TX_AMP value is negative.\n This is only applicatble when TX_AMP_AUTO is not\n set.\n",
    },
    {
        .name  = TX_DRV_MODE_AUTOs,  /* TX_DRV_MODE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation and configuration of\n TX driver value. When this is set, the\n TX driver value is calculated internally\n and is reflected in the PC_TX_TAPS_STATUS logical\n table.\n",
    },
    {
        .name  = TX_DRV_MODEs,  /* TX_DRV_MODE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TX driver mode.",
    },
    {
        .name  = TX_DRV_MODE_SIGNs,  /* TX_DRV_MODE_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify that TX_DRV value is negative.\n This is only applicatble when TX_DRV_AUTO is not\n set.\n",
    },
    {
        .name  = TXFIR_TAP_MODE_AUTOs,  /* TXFIR_TAP_MODE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation and configuration of\n TSC TXFIR tap mode value. When this is set, the\n TSC TXFIR tap mode value is calculated internally\n and is reflected in the PC_TX_TAPS_STATUS logical\n table.\n",
    },
    {
        .name  = TXFIR_TAP_MODEs,  /* TXFIR_TAP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_TXFIR_TAP_MODE_T_DATA,
        .desc = "TSC txfir tap mode.",
    },
    {
        .name  = TX_SIG_MODE_AUTOs,  /* TX_SIG_MODE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation and configuration of\n TX signalling mode value. When this is set, the\n TX signalling mode value is calculated internally\n and is reflected in the PC_TX_TAPS_STATUS logical\n table.\n",
    },
    {
        .name  = TX_SIG_MODEs,  /* TX_SIG_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_SIG_MODE_T_DATA,
        .desc = "TX signalling mode.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n 1. PORT_ID to physical port map is missing.\n 2. PORT_ID speed and number of lanes configuration is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_pc_tx_taps_t = {
    .name = PC_TX_TAPSs, /* PC_TX_TAPS */
    .flags = 0,
    .fields = 34,
    .field = bcmltd_pc_tx_taps_t_fields,
    .desc = "The PC_TX_TAPS table defines the shareable TX lane configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/pc/PC_TX_TAPS_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_pc_tx_taps_status_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = LANE_INDEXs,  /* LANE_INDEX */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Logical lane index of the port.",
    },
    {
        .name  = TX_PREs,  /* TX_PRE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tx FIR pre cursor tap value.",
    },
    {
        .name  = TX_PRE_SIGNs,  /* TX_PRE_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if TX_PRE value is negative.",
    },
    {
        .name  = TX_PRE2s,  /* TX_PRE2 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tx FIR pre2 cursor tap value.",
    },
    {
        .name  = TX_PRE2_SIGNs,  /* TX_PRE2_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if TX_PRE2 value is negative.",
    },
    {
        .name  = TX_MAINs,  /* TX_MAIN */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tx FIR main cursor tap value.",
    },
    {
        .name  = TX_MAIN_SIGNs,  /* TX_MAIN_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if TX_MAIN value is negative.",
    },
    {
        .name  = TX_POSTs,  /* TX_POST */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tx FIR post cursor tap value.",
    },
    {
        .name  = TX_POST_SIGNs,  /* TX_POST_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if TX_POST value is negative.",
    },
    {
        .name  = TX_POST2s,  /* TX_POST2 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tx FIR post2 cursor tap value.",
    },
    {
        .name  = TX_POST2_SIGNs,  /* TX_POST2_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if TX_POST2 value is negative.",
    },
    {
        .name  = TX_POST3s,  /* TX_POST3 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tx FIR post3 cursor tap value.",
    },
    {
        .name  = TX_POST3_SIGNs,  /* TX_POST3_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if TX_POST3 value is negative.",
    },
    {
        .name  = TX_RPARAs,  /* TX_RPARA */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tx FIR shunt resistance value.",
    },
    {
        .name  = TX_RPARA_SIGNs,  /* TX_RPARA_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if TX_RPARA value is negative.",
    },
    {
        .name  = TX_AMPs,  /* TX_AMP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tx amplitude control.",
    },
    {
        .name  = TX_AMP_SIGNs,  /* TX_AMP_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if TX_AMP value is negative.",
    },
    {
        .name  = TX_DRV_MODEs,  /* TX_DRV_MODE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tx driver mode.",
    },
    {
        .name  = TX_DRV_MODE_SIGNs,  /* TX_DRV_MODE_SIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if TX_DRV_MODE value is negative.",
    },
    {
        .name  = TXFIR_TAP_MODEs,  /* TXFIR_TAP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_TXFIR_TAP_MODE_T_DATA,
        .desc = "TSC txfir tap mode.",
    },
    {
        .name  = TX_SIG_MODEs,  /* TX_SIG_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_PC_SIG_MODE_T_DATA,
        .desc = "Tx signalling mode.",
    },
};
const bcmltd_table_rep_t bcmltd_pc_tx_taps_status_t = {
    .name = PC_TX_TAPS_STATUSs, /* PC_TX_TAPS_STATUS */
    .flags = 0,
    .fields = 22,
    .field = bcmltd_pc_tx_taps_status_t_fields,
    .desc = "The PC_TX_TAPS_STATUS table shows the current status of individual port macro\n lanes.\n\n The contents of this read-only table are based on the hardware\n status registers.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_control_t_fields[] = {
    {
        .name  = DSCP_PRESERVE_OVERRIDEs,  /* DSCP_PRESERVE_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to override KEEP_PAYLOAD_DSCP field in tunnel decapsulation\n logical tables and make port based DSCP map working.\n",
    },
};
const bcmltd_table_rep_t bcmltd_phb_control_t = {
    .name = PHB_CONTROLs, /* PHB_CONTROL */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_phb_control_t_fields,
    .desc = "The PHB_CONTROL logical table specifies device level QoS controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_EGR_IP_INT_PRI_TO_DSCP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_egr_ip_int_pri_to_dscp_t_fields[] = {
    {
        .name  = PHB_EGR_IP_INT_PRI_TO_DSCP_IDs,  /* PHB_EGR_IP_INT_PRI_TO_DSCP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the PHB_EGR_IP_INT_PRI_TO_DSCP table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Color/Drop precedence of the packet.",
    },
    {
        .name  = DSCPs,  /* DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "DSCP value for the outgoing L3 packet.",
    },
    {
        .name  = VALIDs,  /* VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates if packet needs to be remarked.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates if packet needs to be dropped.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_egr_ip_int_pri_to_dscp_t = {
    .name = PHB_EGR_IP_INT_PRI_TO_DSCPs, /* PHB_EGR_IP_INT_PRI_TO_DSCP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_phb_egr_ip_int_pri_to_dscp_t_fields,
    .desc = "The PHB_EGR_IP_INT_PRI_TO_DSCP table is used to derive the DSCP value for the\n  outgoing L3 packet.\n\n  The DSCP value of the outgoing L3 packet is derived from the QoS\n  paramaters of the packet.\n  The index for this table can come from the outgoing L3 interface (L3_EIF)\n  and L3 tunnel encapsulation logical tables (TNL_IPV4_ENCAP, TNL_IPV6_ENCAP).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_EGR_L2_INT_PRI_TO_ITAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_egr_l2_int_pri_to_itag_t_fields[] = {
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_ITAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_ITAG_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_EGR_L2_INT_PRI_TO_ITAG table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Color/drop precedence of the packet.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "802.1p value in the L2 header of the outgoing packet.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value in the L2 header of the outgoing packet.",
    },
    {
        .name  = VALIDs,  /* VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates if packet needs to be remarked.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates if packet needs to be dropped.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_egr_l2_int_pri_to_itag_t = {
    .name = PHB_EGR_L2_INT_PRI_TO_ITAGs, /* PHB_EGR_L2_INT_PRI_TO_ITAG */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_phb_egr_l2_int_pri_to_itag_t_fields,
    .desc = "The PHB_EGR_L2_INT_PRI_TO_ITAG table is used to map the outgoing packet's internal\n  priority and color values to the 802.1p and CFI values.\n\n  The PHB_EGR_L2_INT_PRI_TO_ITAG table is used for the inner VLAN tag when packet is\n  double VLAN tagged.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_EGR_L2_INT_PRI_TO_OTAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_egr_l2_int_pri_to_otag_t_fields[] = {
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_OTAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_OTAG_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_EGR_L2_INT_PRI_TO_OTAG table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Color/drop precedence of the packet.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "802.1p value in the L2 header of the outgoing packet.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value in the L2 header of the outgoing packet.",
    },
    {
        .name  = VALIDs,  /* VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates if packet needs to be remarked.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates if packet needs to be dropped.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_egr_l2_int_pri_to_otag_t = {
    .name = PHB_EGR_L2_INT_PRI_TO_OTAGs, /* PHB_EGR_L2_INT_PRI_TO_OTAG */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_phb_egr_l2_int_pri_to_otag_t_fields,
    .desc = "The PHB_EGR_L2_INT_PRI_TO_OTAG table is used to map the outgoing packet's internal\n  priority and color values to the 802.1p and CFI values.\n\n  If the packet is double VLAN tagged then this table is used for the outer\n  VLAN tag and PHB_EGR_L2_INT_PRI_TO_ITAG is used for the inner VLAN tag.\n  In case of single VLAN tagged packets, this table is used.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_EGR_MPLS_EXP_TO_L2_OTAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_egr_mpls_exp_to_l2_otag_t_fields[] = {
    {
        .name  = PHB_EGR_MPLS_EXP_TO_L2_OTAG_IDs,  /* PHB_EGR_MPLS_EXP_TO_L2_OTAG_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_EGR_MPLS_EXP_TO_L2_OTAG table.",
    },
    {
        .name  = EXPs,  /* EXP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "EXP value in the incoming MPLS packet.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "802.1p value in the L2 header of the outgoing packet.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value in the L2 header of the outgoing packet.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_egr_mpls_exp_to_l2_otag_t = {
    .name = PHB_EGR_MPLS_EXP_TO_L2_OTAGs, /* PHB_EGR_MPLS_EXP_TO_L2_OTAG */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_phb_egr_mpls_exp_to_l2_otag_t_fields,
    .desc = "The PHB_EGR_MPLS_EXP_TO_L2_OTAG table is used to map\n the outgoing packet's EXP value to the 802.1p and CFI values\n used in the outer tag associated with the originating MPLS tunnel.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_egr_mpls_int_pri_to_l2_otag_t_fields[] = {
    {
        .name  = PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG_IDs,  /* PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Color/drop precedence of the packet.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "802.1p value in the L2 header of the outgoing packet.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value in the L2 header of the outgoing packet.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_egr_mpls_int_pri_to_l2_otag_t = {
    .name = PHB_EGR_MPLS_INT_PRI_TO_L2_OTAGs, /* PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_phb_egr_mpls_int_pri_to_l2_otag_t_fields,
    .desc = "The PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG table is used to map\n the outgoing packet's internal priority and color\n values to the 802.1p and CFI values used in the outer tag\n associated with the originating MPLS tunnel.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_egr_mpls_int_pri_to_lsp_exp_t_fields[] = {
    {
        .name  = PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP_IDs,  /* PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal Priority of the packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Color/drop precedence of the packet.",
    },
    {
        .name  = MPLS_EXPs,  /* MPLS_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "MPLS EXP value for the LSP labels.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_egr_mpls_int_pri_to_lsp_exp_t = {
    .name = PHB_EGR_MPLS_INT_PRI_TO_LSP_EXPs, /* PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_phb_egr_mpls_int_pri_to_lsp_exp_t_fields,
    .desc = "The PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP table is used to derive the EXP value\n  for the MPLS LSP labels.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_EGR_MPLS_INT_PRI_TO_TRANSIT_EXP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_egr_mpls_int_pri_to_transit_exp_t_fields[] = {
    {
        .name  = PHB_EGR_MPLS_INT_PRI_TO_TRANSIT_EXP_IDs,  /* PHB_EGR_MPLS_INT_PRI_TO_TRANSIT_EXP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_EGR_MPLS_INT_PRI_TO_TRANSIT_EXP table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Color/drop precedence of the packet.",
    },
    {
        .name  = MPLS_EXPs,  /* MPLS_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "MPLS EXP value for the transit label in the MPLS tunnel.",
    },
    {
        .name  = VALIDs,  /* VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates if packet needs to be remarked.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates if packet needs to be dropped.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_egr_mpls_int_pri_to_transit_exp_t = {
    .name = PHB_EGR_MPLS_INT_PRI_TO_TRANSIT_EXPs, /* PHB_EGR_MPLS_INT_PRI_TO_TRANSIT_EXP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_phb_egr_mpls_int_pri_to_transit_exp_t_fields,
    .desc = "The PHB_EGR_MPLS_INT_PRI_TO_TRANSIT_EXP table is used to derive the EXP\n value for the MPLS transit labels.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_egr_mpls_int_pri_to_vpn_exp_t_fields[] = {
    {
        .name  = PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP_IDs,  /* PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Color/drop precedence of the packet.",
    },
    {
        .name  = MPLS_EXPs,  /* MPLS_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "MPLS EXP value for the VC/VPN label in the MPLS tunnel.",
    },
    {
        .name  = VALIDs,  /* VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates if packet needs to be remarked.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates if packet needs to be dropped.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_egr_mpls_int_pri_to_vpn_exp_t = {
    .name = PHB_EGR_MPLS_INT_PRI_TO_VPN_EXPs, /* PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_phb_egr_mpls_int_pri_to_vpn_exp_t_fields,
    .desc = "The PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP table is used to derive the EXP\n value for the MPLS VC/VPN labels.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_EGR_PORT_INT_PRI_REMAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_egr_port_int_pri_remap_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Outgoing logical port ID.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = NEW_INT_PRIs,  /* NEW_INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "New internal priority for the egress port.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_egr_port_int_pri_remap_t = {
    .name = PHB_EGR_PORT_INT_PRI_REMAPs, /* PHB_EGR_PORT_INT_PRI_REMAP */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_phb_egr_port_int_pri_remap_t_fields,
    .desc = "The PHB_EGR_PORT_INT_PRI_REMAP table is used to map the internl priority\n  of the packet into a new inernal priority for the egress port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_EGR_PORT_INT_PRI_TO_L2_OTAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_egr_port_int_pri_to_l2_otag_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Outgoing logical port ID.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Color/drop precedence of the packet.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "802.1p value in the L2 header of the outgoing packet.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value in the L2 header of the outgoing packet.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_egr_port_int_pri_to_l2_otag_t = {
    .name = PHB_EGR_PORT_INT_PRI_TO_L2_OTAGs, /* PHB_EGR_PORT_INT_PRI_TO_L2_OTAG */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_phb_egr_port_int_pri_to_l2_otag_t_fields,
    .desc = "The PHB_EGR_PORT_INT_PRI_TO_L2_OTAG table is used to derive the 802.1p and CFI values\n  of the packet's outer VLAN tag on a per port basis.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_egr_vlan_int_pri_to_l2_otag_t_fields[] = {
    {
        .name  = PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG_IDs,  /* PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Color/drop precedence of the packet.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "802.1p value in the L2 header of the outgoing packet.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value in the L2 header of the outgoing packet.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_egr_vlan_int_pri_to_l2_otag_t = {
    .name = PHB_EGR_VLAN_INT_PRI_TO_L2_OTAGs, /* PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_phb_egr_vlan_int_pri_to_l2_otag_t_fields,
    .desc = "The PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG table is used to\n  derive the 802.1p and CFI values\n  of the packet's outer VLAN tag on a per VLAN basis.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_ING_IP_DSCP_TO_INT_PRI_REMAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_ing_ip_dscp_to_int_pri_remap_t_fields[] = {
    {
        .name  = PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs,  /* PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_ING_IP_DSCP_TO_INT_PRI_REMAP table.",
    },
    {
        .name  = DSCPs,  /* DSCP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 6,
        .depth = 0,
        .desc = "DSCP value from the incoming packet.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the incoming packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Color or drop precedence of the packet.",
    },
    {
        .name  = NEW_DSCPs,  /* NEW_DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "New DSCP value for the packet.",
    },
    {
        .name  = DSCP_VALIDs,  /* DSCP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate NEW_DSCP value is valid.",
    },
    {
        .name  = BASE_INDEX_AUTOs,  /* BASE_INDEX_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to automatically calculate the value of BASE_INDEX. When\n this field is enabled, the calculated base index is reflected in\n the BASE_INDEX_OPER field.\n",
    },
    {
        .name  = BASE_INDEX_OPERs,  /* BASE_INDEX_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Computed value of BASE_INDEX.\n\n Read-Only field is applicable only when the BASE_INDEX_AUTO\n field is enabled.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Configured value of BASE_INDEX.\n Applicable only when BASE_INDEX_AUTO is disabled.\n\n The BASE_INDEX should not overlap any existing PHB map and must\n be positioned with sufficient space for one complete profile size\n and 8 bytes aligned.\n",
    },
};
const bcmltd_table_rep_t bcmltd_phb_ing_ip_dscp_to_int_pri_remap_t = {
    .name = PHB_ING_IP_DSCP_TO_INT_PRI_REMAPs, /* PHB_ING_IP_DSCP_TO_INT_PRI_REMAP */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_phb_ing_ip_dscp_to_int_pri_remap_t_fields,
    .desc = "The PHB_ING_IP_DSCP_TO_INT_PRI_REMAP table is used to derive the internal QoS parameters\n  from the DSCP values of the incoming L3 packet.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_ING_L2_OTAG_REMAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_ing_l2_otag_remap_t_fields[] = {
    {
        .name  = PHB_ING_L2_OTAG_REMAP_IDs,  /* PHB_ING_L2_OTAG_REMAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_ING_L2_OTAG_REMAP.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "802.1p value in the incoming packet's outer VLAN tag.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "CFI value in the incoming packet's outer VLAN tag.",
    },
    {
        .name  = NEW_PRIs,  /* NEW_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New 802.1p value for the incoming packet's outer VLAN tag.",
    },
    {
        .name  = NEW_CFIs,  /* NEW_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New CFI value for the incoming packet's outer VLAN tag.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_ing_l2_otag_remap_t = {
    .name = PHB_ING_L2_OTAG_REMAPs, /* PHB_ING_L2_OTAG_REMAP */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_phb_ing_l2_otag_remap_t_fields,
    .desc = "THe PHB_ING_L2_OTAG_REMAP table is used to update the incoming packet's\n  802.1p and CFI values in the outer VLAN tag.\n\n  For tunnel terminated packets, the 802.1p and CFI values will be updated\n  in the tunnel payload's outer VLAN tag. For non-tunnel terminated packets,\n  the 802.1p and CFI values will be updated in the packet's outer VLAN tag.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_ING_L2_TAGGED_TO_INT_PRI.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_ing_l2_tagged_to_int_pri_t_fields[] = {
    {
        .name  = PHB_ING_L2_TAGGED_TO_INT_PRI_IDs,  /* PHB_ING_L2_TAGGED_TO_INT_PRI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_ING_L2_TAGGED_TO_INT_PRI table.",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "802.1p value in the incoming packet's VLAN tag.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "CFI value in the incoming packet's VLAN tag.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the incoming packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Color/drop precedence of the incoming packet.",
    },
    {
        .name  = BASE_INDEX_AUTOs,  /* BASE_INDEX_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to automatically calculate the value of BASE_INDEX. When\n this field is enabled, the calculated base index is reflected in\n the BASE_INDEX_OPER field.\n",
    },
    {
        .name  = BASE_INDEX_OPERs,  /* BASE_INDEX_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Computed value of BASE_INDEX.\n\n Read-Only field is applicable only when the BASE_INDEX_AUTO\n field is enabled.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Configured value of BASE_INDEX.\n Applicable only when BASE_INDEX_AUTO is disabled.\n\n The BASE_INDEX should not overlap any existing PHB map and must\n be positioned with sufficient space for one complete profile size\n and 8 bytes aligned.\n",
    },
};
const bcmltd_table_rep_t bcmltd_phb_ing_l2_tagged_to_int_pri_t = {
    .name = PHB_ING_L2_TAGGED_TO_INT_PRIs, /* PHB_ING_L2_TAGGED_TO_INT_PRI */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_phb_ing_l2_tagged_to_int_pri_t_fields,
    .desc = "The PHB_ING_L2_TAGGED_TO_INT_PRI table is used to derive the internal QoS parameters\n  from the incoming packet's 802.1p and CFI values.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_ING_L2_UNTAGGED_TO_INT_PRI.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_ing_l2_untagged_to_int_pri_t_fields[] = {
    {
        .name  = PHB_ING_L2_UNTAGGED_TO_INT_PRI_IDs,  /* PHB_ING_L2_UNTAGGED_TO_INT_PRI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_ING_L2_UNTAGGED_TO_INT_PRI table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the incoming packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Color/drop precedence of the incoming packet.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_ing_l2_untagged_to_int_pri_t = {
    .name = PHB_ING_L2_UNTAGGED_TO_INT_PRIs, /* PHB_ING_L2_UNTAGGED_TO_INT_PRI */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_phb_ing_l2_untagged_to_int_pri_t_fields,
    .desc = "The PHB_ING_L2_UNTAGGED_TO_INT_PRI table is used to derive the internal QoS\n  parameters for the untagged packets.\n\n  The PHB_ING_L2_UNTAGGED_TO_INT_PRI is also used to derive the internal QoS parameters\n  if the QoS derivation is based on the inner VLAN tag but packet has a\n  single VLAN tag.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_ING_MPLS_EXP_TO_INT_PRI.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_ing_mpls_exp_to_int_pri_t_fields[] = {
    {
        .name  = PHB_ING_MPLS_EXP_TO_INT_PRI_IDs,  /* PHB_ING_MPLS_EXP_TO_INT_PRI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_ING_MPLS_EXP_TO_INT_PRI table.",
    },
    {
        .name  = EXPs,  /* EXP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "EXP value in the incoming MPLS packet.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet.",
    },
    {
        .name  = CNGs,  /* CNG */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Color/drop precedence of the packet.",
    },
    {
        .name  = DSCPs,  /* DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "DSCP value of the payload's L3 header of the incoming MPLS packet.\n This value is used if RETAIN_PAYLOAD_DSCP is not\n set in TNL_MPLS_DECAP table.\n",
    },
    {
        .name  = DSCP_VALIDs,  /* DSCP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Set to indicate DSCP value is valid.",
    },
    {
        .name  = BASE_INDEX_AUTOs,  /* BASE_INDEX_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to automatically calculate the value of BASE_INDEX. When\n this field is enabled, the calculated base index is reflected in\n the BASE_INDEX_OPER field.\n",
    },
    {
        .name  = BASE_INDEX_OPERs,  /* BASE_INDEX_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Computed value of BASE_INDEX.\n\n Read-Only field is applicable only when the BASE_INDEX_AUTO\n field is enabled.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Configured value of BASE_INDEX.\n Applicable only when BASE_INDEX_AUTO is disabled.\n\n The BASE_INDEX should not overlap any existing PHB map and must\n be positioned with sufficient space for one complete profile size\n and 8 bytes aligned.\n",
    },
};
const bcmltd_table_rep_t bcmltd_phb_ing_mpls_exp_to_int_pri_t = {
    .name = PHB_ING_MPLS_EXP_TO_INT_PRIs, /* PHB_ING_MPLS_EXP_TO_INT_PRI */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_phb_ing_mpls_exp_to_int_pri_t_fields,
    .desc = "The PHB_ING_MPLS_EXP_TO_INT_PRI table is used to map the incoming MPLS label's EXP\n  value to the internal QoS parameters.\n\n  In order to maintain QoS for for the MPLS packet, incoming MPLS EXP\n  can be mapped to the internal QoS parameters which can be later used to\n  derive the QoS values for the outgoing packet.\n  This table is used to change the DSCP value of the Payload's L3 header\n  of the incoming MPLS packet based on MPLS EXP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/phb/PHB_ING_ROUTED_INT_PRI_REMAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_phb_ing_routed_int_pri_remap_t_fields[] = {
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Index into the PHB_ING_ROUTED_INT_PRI_REMAP table.\n This is the internal priority to be mapped.\n",
    },
    {
        .name  = NEW_INT_PRIs,  /* NEW_INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "New internal priority of the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_phb_ing_routed_int_pri_remap_t = {
    .name = PHB_ING_ROUTED_INT_PRI_REMAPs, /* PHB_ING_ROUTED_INT_PRI_REMAP */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_phb_ing_routed_int_pri_remap_t_fields,
    .desc = "The PHB_ING_ROUTED_INT_PRI_REMAP table is used to map non congestion aware\n  traffic away from congestion aware queues by mapping to a different\n  internal priority.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = MY_MODIDs,  /* MY_MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Module ID.",
    },
    {
        .name  = PORT_TYPEs,  /* PORT_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Port type.",
    },
    {
        .name  = V6L3s,  /* V6L3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv6 unicast packets.",
    },
    {
        .name  = V6IPMCs,  /* V6IPMC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv6 multicast packets.",
    },
    {
        .name  = V4L3s,  /* V4L3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv4 unicast packets.",
    },
    {
        .name  = V4IPMCs,  /* V4IPMC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv4 multicast packets.",
    },
    {
        .name  = OPERATING_MODEs,  /* OPERATING_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operating mode of the port.",
    },
    {
        .name  = URPF_MODEs,  /* URPF_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Unicast RPF mode.",
    },
    {
        .name  = URPF_DEFAULT_ROUTE_CHECKs,  /* URPF_DEFAULT_ROUTE_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable unicast RPF check on default routes.",
    },
    {
        .name  = PORT_PKT_CONTROL_IDs,  /* PORT_PKT_CONTROL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PORT_PKT_CONTROL logical table index.",
    },
    {
        .name  = MPLSs,  /* MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS.",
    },
    {
        .name  = IPMC_USE_L3_IIFs,  /* IPMC_USE_L3_IIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable using L3_IIF as part of IP multicast search key.",
    },
    {
        .name  = IEEE_802_1ASs,  /* IEEE_802_1AS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable times-sync.",
    },
    {
        .name  = USE_IVID_AS_OVIDs,  /* USE_IVID_AS_OVID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable using inner VLAN ID as outer VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = ING_OVIDs,  /* ING_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Ingress outer VLAN ID.",
    },
    {
        .name  = ING_OPRIs,  /* ING_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Ingress outer DOT1P priority.",
    },
    {
        .name  = ING_OCFIs,  /* ING_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Ingress outer CFI.",
    },
    {
        .name  = ING_IVIDs,  /* ING_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Ingress inner VLAN ID.",
    },
    {
        .name  = ING_IPRIs,  /* ING_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Ingress inner DOT1P priority.",
    },
    {
        .name  = ING_ICFIs,  /* ING_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Ingress inner CFI.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter ingress pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = EGR_OVIDs,  /* EGR_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Egress outer VLAN ID.\n If PORT_PHB.TRUST_PHB_EGR_L2_OTAG is disabled,\n use EGR_OVID from PORT logical table.\n",
    },
    {
        .name  = EGR_ASSIGN_OPRIs,  /* EGR_ASSIGN_OPRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to assign the outgoing outer priority\n with EGR_OPRI in the table.\n",
    },
    {
        .name  = EGR_OPRIs,  /* EGR_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Egress outer VLAN priority.",
    },
    {
        .name  = EGR_OCFIs,  /* EGR_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Egress outer VLAN CFI.\n If PORT_PHB.TRUST_PHB_EGR_L2_OTAG is disabled,\n use EGR_OCFI from PORT logical table.\n",
    },
    {
        .name  = EGR_IVIDs,  /* EGR_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Egress inner VLAN ID.\n If PORT_POLICY.PHB_EGR_L2_ITAG_MAP is disabled,\n use EGR_IVID from PORT logical table.\n",
    },
    {
        .name  = EGR_ASSIGN_IPRIs,  /* EGR_ASSIGN_IPRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to assign the outgoing inner priority\n with EGR_IPRI in the table.\n",
    },
    {
        .name  = EGR_IPRIs,  /* EGR_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Egress inner VLAN priority.",
    },
    {
        .name  = EGR_ICFIs,  /* EGR_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Egress inner VLAN CFI.\n If PORT_POLICY.PHB_EGR_L2_ITAG_MAP is disabled,\n use EGR_ICFI from PORT logical table.\n",
    },
    {
        .name  = VLAN_EGR_TAG_ACTION_PROFILE_IDs,  /* VLAN_EGR_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_EGR_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = CTR_EGR_FLEX_POOL_NUMBERs,  /* CTR_EGR_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter egress pool number.",
    },
    {
        .name  = CTR_EGR_FLEX_BASE_INDEXs,  /* CTR_EGR_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_EGR_FLEX_OFFSET_MODEs,  /* CTR_EGR_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = PRESERVE_CPU_TAGs,  /* PRESERVE_CPU_TAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable tag preservation for packets going to the CPU.",
    },
    {
        .name  = CNTAG_DELETE_ON_PRI_MATCHs,  /* CNTAG_DELETE_ON_PRI_MATCH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "A bitmap where the bit position corresponds to\n the packet's 802.1p priority value.\n If a bit is set, packets with\n that 802.1P value will have their CNTAG deleted.\n",
    },
    {
        .name  = VLAN_ASSIGNMENT_BASED_IPV4s,  /* VLAN_ASSIGNMENT_BASED_IPV4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 subnet-based VLAN assignment.",
    },
    {
        .name  = VLAN_ASSIGNMENT_BASED_MACs,  /* VLAN_ASSIGNMENT_BASED_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MAC-based VLAN assignment.",
    },
    {
        .name  = VLAN_ASSIGNMENT_PROTOCOL_IDs,  /* VLAN_ASSIGNMENT_PROTOCOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ASSIGNMENT_PROTOCOL logical table index.",
    },
    {
        .name  = VLAN_PRECEDENCEs,  /* VLAN_PRECEDENCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 subnet-based VLAN assignment to have\n higher priority than mac-based VLAN assignment.\n",
    },
    {
        .name  = INBAND_TELEMETRY_IFAs,  /* INBAND_TELEMETRY_IFA */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable Inband Flow Analyzer (IFA).",
    },
    {
        .name  = INBAND_TELEMETRY_IOAMs,  /* INBAND_TELEMETRY_IOAM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable In-situ Operations, Administration, and\n Maintenance (IOAM).\n",
    },
    {
        .name  = INBAND_TELEMETRY_DATAPLANEs,  /* INBAND_TELEMETRY_DATAPLANE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable In-band Network Telemetry Data-plane Probe (INT-DP).",
    },
    {
        .name  = INPORT_BITMAP_INDEXs,  /* INPORT_BITMAP_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Port bitmap index to generate Input Port Bitmap field of the IFP.",
    },
    {
        .name  = L2_EIF_IDs,  /* L2_EIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L2 outgoing interface ID.",
    },
    {
        .name  = ING_SYSTEM_PORT_TABLE_IDs,  /* ING_SYSTEM_PORT_TABLE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress system port identifier mapped for the\n logical port.\n Index into the ING_SYSTEM_PORT_TABLE table.\n",
    },
    {
        .name  = MTU_CHECKs,  /* MTU_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable egress MTU checks. The packet length is checked against\n the value specified in the MTU field in this table. Packets\n which violate the specified MTU value will be dropped if the port\n is in store and forward mode, or truncated if the port is in\n cut-through mode.\n",
    },
    {
        .name  = MTUs,  /* MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress port's maximum packet length.\n Applicable only if MTU_CHECK is enabled.\n",
    },
    {
        .name  = VFI_EGR_ADAPT_PORT_GRPs,  /* VFI_EGR_ADAPT_PORT_GRP */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "VFI egress adaptation port group ID.",
    },
    {
        .name  = EGR_OPAQUE_TAGs,  /* EGR_OPAQUE_TAG */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Egress L2 opaque tag.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter action.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress enhanced flex counter action.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number. This is a read-only field which specifies\n the packet processing pipe associated with this logical\n port.\n",
    },
    {
        .name  = VFI_EGR_ADAPT_PORT_GRP_LOOKUPs,  /* VFI_EGR_ADAPT_PORT_GRP_LOOKUP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable VFI_EGR_ADAPT_PORT_GRP lookup, where the key\n VXLAN_DECAP is always zero.\n",
    },
    {
        .name  = VFI_EGR_ADAPT_PORT_GRP_LOOKUP_MISS_DROPs,  /* VFI_EGR_ADAPT_PORT_GRP_LOOKUP_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets if VFI_EGR_ADAPT_PORT_GRP missing.\n Applicable if VFI_EGR_ADAPT_PORT_GRP_LOOKUP is enabled.\n",
    },
    {
        .name  = VXLAN_VFI_EGR_ADAPT_PORT_GRP_LOOKUPs,  /* VXLAN_VFI_EGR_ADAPT_PORT_GRP_LOOKUP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dedicated VFI_EGR_ADAPT_PORT_GRP lookup for VXLAN flow,\n where the key VXLAN_DECAP is the VXLAN tunnel termination status.\n This has higher priority against VFI_EGR_ADAPT_PORT_GRP_LOOKUP.\n",
    },
    {
        .name  = VXLAN_VFI_EGR_ADAPT_PORT_GRP_LOOKUP_MISS_DROPs,  /* VXLAN_VFI_EGR_ADAPT_PORT_GRP_LOOKUP_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets if VFI_EGR_ADAPT_PORT_GRP missing.\n Applicable if VXLAN_VFI_EGR_ADAPT_PORT_GRP_LOOKUP is enabled.\n",
    },
    {
        .name  = NTP_TCs,  /* NTP_TC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable NTP transparent clock editing",
    },
    {
        .name  = DEVICE_TS_PTP_MSG_CONTROL_PROFILE_IDs,  /* DEVICE_TS_PTP_MSG_CONTROL_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "DEVICE_TS_PTP_MSG_CONTROL_PROFILE logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_port_t = {
    .name = PORTs, /* PORT */
    .flags = 0,
    .fields = 62,
    .field = bcmltd_port_t_fields,
    .desc = "The PORT table specifies the basic port properties and\n port level functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_BRIDGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_bridge_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = BRIDGEs,  /* BRIDGE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2 forwarding of broadcast, unknown unicast and\n multicast packets.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_bridge_t = {
    .name = PORT_BRIDGEs, /* PORT_BRIDGE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_port_bridge_t_fields,
    .desc = "The PORT_BRIDGE table specifies the port level\n bridging functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_config_t_fields[] = {
    {
        .name  = PORT_SYSTEM_PROFILE_OPERMODE_PIPEUNIQUEs,  /* PORT_SYSTEM_PROFILE_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Port system profile operating mode.\n Enable to specify pipe unique operating mode.\n Disable to specify global operating mode.\n The operating mode must be configured during system\n initialization and cannot be modified during runtime.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_config_t = {
    .name = PORT_CONFIGs, /* PORT_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 1,
    .field = bcmltd_port_config_t_fields,
    .desc = "PORT_CONFIG configures the chip level parameters\n for port functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_control_t_fields[] = {
    {
        .name  = EGR_BLOCK_L2s,  /* EGR_BLOCK_L2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable blocking L2 traffic for the set of egress ports\n specified in BLOCKED_EGR_PORTS.\n",
    },
    {
        .name  = EGR_BLOCK_L3s,  /* EGR_BLOCK_L3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable blocking L3 traffic for the set of egress ports\n specified in BLOCKED_EGR_PORTS.\n",
    },
    {
        .name  = EGR_BLOCK_UCASTs,  /* EGR_BLOCK_UCAST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable blocking unicast traffic for the set of egress ports\n specified in BLOCKED_EGR_PORTS.\n If enabled, EGR_BLOCK_L2 and EGR_BLOCK_L3 affect only unicast\n traffic.\n Otherwise, EGR_BLOCK_L2 and EGR_BLOCK_L3 affect all traffic.\n Applicable only if EGR_BLOCK_L2 or EGR_BLOCK_L3 is enabled.\n",
    },
    {
        .name  = DEST_INDEX_SELs,  /* DEST_INDEX_SEL */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index selection into PORT_SYSTEM_DESTINATION table.\n",
    },
    {
        .name  = DO_NOT_COPY_FROM_CPU_TO_CPUs,  /* DO_NOT_COPY_FROM_CPU_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to not copy packets which originate from the CPU port\n to the CPU port.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_control_t = {
    .name = PORT_CONTROLs, /* PORT_CONTROL */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_port_control_t_fields,
    .desc = "The PORT_CONTROL table specifies the device level\n control functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_COS_Q_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_cos_q_map_t_fields[] = {
    {
        .name  = PORT_COS_Q_MAP_IDs,  /* PORT_COS_Q_MAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PORT_COS_Q_MAP table.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the incoming packet.",
    },
    {
        .name  = UC_COSs,  /* UC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast COS queue value.",
    },
    {
        .name  = UC_ELEPHANT_COSs,  /* UC_ELEPHANT_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast COS queue value for elephant flow.",
    },
    {
        .name  = MC_COSs,  /* MC_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast COS queue value.",
    },
    {
        .name  = RQE_COSs,  /* RQE_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Replication queue engine (RQE) COS queue value.",
    },
    {
        .name  = CPU_COSs,  /* CPU_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "CPU COS queue value.",
    },
};
const bcmltd_table_rep_t bcmltd_port_cos_q_map_t = {
    .name = PORT_COS_Q_MAPs, /* PORT_COS_Q_MAP */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_port_cos_q_map_t_fields,
    .desc = "The PORT_COS_Q_MAP table defines which COS queue to use for a\n packet with a specific internal priority.\n\n The hardware may implement multiple mapping tables of this type, so\n the table key consists of both a map ID and an internal priority.\n The selection of mapping table is typically determined by the packet\n ingress port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_COS_Q_STRENGTH_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_cos_q_strength_profile_t_fields[] = {
    {
        .name  = PORT_COS_Q_STRENGTH_PROFILE_IDs,  /* PORT_COS_Q_STRENGTH_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port COS queue strength profile table index.",
    },
    {
        .name  = UC_COS_STRENGTHs,  /* UC_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast COS queue strength.",
    },
    {
        .name  = MC_COS_STRENGTHs,  /* MC_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast COS queue strength.",
    },
    {
        .name  = RQE_COS_STRENGTHs,  /* RQE_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Replication queue engine (RQE) COS queue strength.",
    },
    {
        .name  = CPU_COS_STRENGTHs,  /* CPU_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "CPU COS queue strength.",
    },
};
const bcmltd_table_rep_t bcmltd_port_cos_q_strength_profile_t = {
    .name = PORT_COS_Q_STRENGTH_PROFILEs, /* PORT_COS_Q_STRENGTH_PROFILE */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_port_cos_q_strength_profile_t_fields,
    .desc = "The PORT_COS_Q_STRENGTH_PROFILE table specifies the strength of the\n port-based COS queue value relative to the COS queue values that may be\n specified by other entities such as FP or TM.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_DVP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_dvp_t_fields[] = {
    {
        .name  = PORT_DVP_IDs,  /* PORT_DVP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 14,
        .depth = 0,
        .desc = "Destination virtual port.",
    },
    {
        .name  = DVP_GRPs,  /* DVP_GRP */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Destination virtual port group.",
    },
    {
        .name  = DVP_NETWORK_GRPs,  /* DVP_NETWORK_GRP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Network group for destination virtual port.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress enhanced flex counter action.",
    },
    {
        .name  = SKIP_VP_PRUNINGs,  /* SKIP_VP_PRUNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip pruning of packet with source virtual port)\n equals to destination virtual port.\n",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip VLAN membership and STG STP state check.",
    },
    {
        .name  = PORT_DVP_MTU_PROFILE_IDs,  /* PORT_DVP_MTU_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the PORT_DVP_MTU_PROFILE logical table.",
    },
    {
        .name  = UNKNOWN_UC_DROPs,  /* UNKNOWN_UC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping unknown unicast packets.",
    },
    {
        .name  = UNKNOWN_MC_DROPs,  /* UNKNOWN_MC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping unknown multicast packets.",
    },
    {
        .name  = BC_DROPs,  /* BC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping broadcast packets.",
    },
};
const bcmltd_table_rep_t bcmltd_port_dvp_t = {
    .name = PORT_DVPs, /* PORT_DVP */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_port_dvp_t_fields,
    .desc = "The PORT_DVP table specifies the basic port properties and\n port level functionality for destination virtual port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_DVP_MTU_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_dvp_mtu_profile_t_fields[] = {
    {
        .name  = PORT_DVP_MTU_PROFILE_IDs,  /* PORT_DVP_MTU_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the PORT_DVP_MTU_PROFILE logical table.",
    },
    {
        .name  = ENABLEs,  /* ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MTU check.",
    },
    {
        .name  = MTUs,  /* MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "MTU for tunnel packets.",
    },
};
const bcmltd_table_rep_t bcmltd_port_dvp_mtu_profile_t = {
    .name = PORT_DVP_MTU_PROFILEs, /* PORT_DVP_MTU_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_port_dvp_mtu_profile_t_fields,
    .desc = "The PORT_DVP_MTU_PROFILE profile table is used to specify\n the MTU based on destination virtual port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ECN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ecn_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = ECN_LATENCY_PROFILE_IDs,  /* ECN_LATENCY_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_LATENCY_PROFILE logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_port_ecn_t = {
    .name = PORT_ECNs, /* PORT_ECN */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_port_ecn_t_fields,
    .desc = "The PORT_ECN table specifies latency ECN profile index.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_EGR_BLOCK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_egr_block_t_fields[] = {
    {
        .name  = PORT_EGR_BLOCK_IDs,  /* PORT_EGR_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "PORT_EGR_BLOCK logical table index.",
    },
    {
        .name  = MASK_PORTSs,  /* MASK_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Mask ports bitmap.",
    },
    {
        .name  = MASK_ACTIONs,  /* MASK_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask action.",
    },
};
const bcmltd_table_rep_t bcmltd_port_egr_block_t = {
    .name = PORT_EGR_BLOCKs, /* PORT_EGR_BLOCK */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_port_egr_block_t_fields,
    .desc = "The PORT_EGR_BLOCK table specifies egress control settings for destination ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_EGR_MIRROR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_egr_mirror_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress port ID.",
    },
    {
        .name  = EGR_PORT_IDs,  /* EGR_PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Egress port ID.",
    },
    {
        .name  = MIRROR_CONTAINER_IDs,  /* MIRROR_CONTAINER_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Mirror container ID.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mirror.",
    },
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MIRROR_INSTANCE table index.",
    },
    {
        .name  = MIRROR_SESSION_IDs,  /* MIRROR_SESSION_ID */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "MIRROR_SESSION table index.",
    },
};
const bcmltd_table_rep_t bcmltd_port_egr_mirror_t = {
    .name = PORT_EGR_MIRRORs, /* PORT_EGR_MIRROR */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_port_egr_mirror_t_fields,
    .desc = "The PORT_EGR_MIRROR logical table is used to enable or disable egress\n mirroring on specified ingress port, egress port and mirror container.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_EGR_OPAQUE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_egr_opaque_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = OPAQUE_CMD0s,  /* OPAQUE_CMD0 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Egress port opaque command 0.",
    },
    {
        .name  = OPAQUE_CMD1s,  /* OPAQUE_CMD1 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Egress port opaque command 1.",
    },
    {
        .name  = OPAQUE_OBJ0s,  /* OPAQUE_OBJ0 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Egress port opaque object 0.",
    },
};
const bcmltd_table_rep_t bcmltd_port_egr_opaque_t = {
    .name = PORT_EGR_OPAQUEs, /* PORT_EGR_OPAQUE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_port_egr_opaque_t_fields,
    .desc = "The PORT_EGR_OPAQUE table is used to configure egress port\n opaque fields. Each opaque field usage is defined by NPL and\n its usage is documented in PORT_EGR_DEVICE_INFO.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_EGR_TS_PTP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_egr_ts_ptp_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = REPLACE_SRC_MACs,  /* REPLACE_SRC_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Replace source MAC address on IEEE 1588 event packets.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.\n Applicable when REPLACE_SRC_MAC is enabled.\n",
    },
    {
        .name  = CF_UPDATE_MODEs,  /* CF_UPDATE_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Correction field update mode.",
    },
    {
        .name  = DROP_INVALID_IEEE1588_PKTs,  /* DROP_INVALID_IEEE1588_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable drop of invalid IEEE_1588 packets.",
    },
    {
        .name  = TS_SYNCs,  /* TS_SYNC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable timestamping for IEEE 1588 SYNC message.",
    },
    {
        .name  = TS_DELAY_REQs,  /* TS_DELAY_REQ */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable timestamping for IEEE 1588 DELAY_REQ message.",
    },
    {
        .name  = TS_PDELAY_REQs,  /* TS_PDELAY_REQ */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable timestamping for IEEE 1588 PDELAY_REQ message.",
    },
    {
        .name  = TS_PDELAY_RESPs,  /* TS_PDELAY_RESP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable timestamping for IEEE 1588 PDELAY_RESP message.",
    },
};
const bcmltd_table_rep_t bcmltd_port_egr_ts_ptp_t = {
    .name = PORT_EGR_TS_PTPs, /* PORT_EGR_TS_PTP */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_port_egr_ts_ptp_t_fields,
    .desc = "The PORT_EGR_TS_PTP table specifies the per egress port\n Precision Time Protocol (PTP) configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_EGR_VISIBILITY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_egr_visibility_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Egress port ID",
    },
    {
        .name  = TIMESTAMP_ORIGINs,  /* TIMESTAMP_ORIGIN */
        .flags = 0,
        .width = 23,
        .depth = 0,
        .desc = "Origin ID for egress timestamp.",
    },
    {
        .name  = SKIP_TIMESTAMPs,  /* SKIP_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard both ingress and egress timestamp for packets exiting this port.",
    },
    {
        .name  = TIMESTAMPs,  /* TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to insert egress timestamp on transmitted packets.",
    },
    {
        .name  = ADJUST_METERSs,  /* ADJUST_METERS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to adjust byte count fields that are used to update\n meters and flex byte counters.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_egr_visibility_t = {
    .name = PORT_EGR_VISIBILITYs, /* PORT_EGR_VISIBILITY */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_port_egr_visibility_t_fields,
    .desc = "The PORT_EGR_VISIBILITY table specifies the per egress port visibility\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_FLOOD_BLOCK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_flood_block_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = ALLs,  /* ALL */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to block all packets for the specified egress ports.",
    },
    {
        .name  = BCs,  /* BC */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to block broadcast packets for the specified egress ports.",
    },
    {
        .name  = UNKNOWN_UCs,  /* UNKNOWN_UC */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to block unknown unicast packets for the specified egress ports.",
    },
    {
        .name  = UNKNOWN_MCs,  /* UNKNOWN_MC */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to block unknown multicast packets for the specified egress ports.",
    },
    {
        .name  = KNOWN_MCs,  /* KNOWN_MC */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to block known multicast packets for the specified egress ports.",
    },
};
const bcmltd_table_rep_t bcmltd_port_flood_block_t = {
    .name = PORT_FLOOD_BLOCKs, /* PORT_FLOOD_BLOCK */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_port_flood_block_t_fields,
    .desc = "The PORT_FLOOD_BLOCK table specifies per ingress port flood control settings.\n This setting blocks per-ingress port flooding of traffic on the\n specified egress ports.\n If any of the specified egress ports in the array is a member of a\n trunk group, then all ports which are part of that\n trunk group should also be specified in the array.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_FP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_fp_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = FP_VLANs,  /* FP_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable VLAN FP.",
    },
    {
        .name  = FP_INGs,  /* FP_ING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable Ingress FP.",
    },
    {
        .name  = FP_EGRs,  /* FP_EGR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable Egress FP.",
    },
    {
        .name  = USE_TABLE_FP_VLAN_PORT_GRPs,  /* USE_TABLE_FP_VLAN_PORT_GRP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use FP_VLAN_PORT_GRP from the logical table,\n otherwise use FP_VLAN_PORT_GRP from the PORT_SYSTEM logical table.\n",
    },
    {
        .name  = FP_VLAN_PORT_GRPs,  /* FP_VLAN_PORT_GRP */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "VLAN FP key port group.",
    },
    {
        .name  = FP_ING_GRP_SEL_CLASS_IDs,  /* FP_ING_GRP_SEL_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress FP group selection class ID.",
    },
    {
        .name  = FP_EGR_PORT_GRPs,  /* FP_EGR_PORT_GRP */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "Egress FP key port group.",
    },
    {
        .name  = FP_EGR_DROPs,  /* FP_EGR_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable egress FP drop if the egress FP stage\n is not bypassed.\n",
    },
    {
        .name  = FP_EGR_CLASS_ID_SELECTs,  /* FP_EGR_CLASS_ID_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select one Class ID from IP tables to be passed to EFP.",
    },
};
const bcmltd_table_rep_t bcmltd_port_fp_t = {
    .name = PORT_FPs, /* PORT_FP */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_port_fp_t_fields,
    .desc = "The PORT_FP table specifies the port level\n field processor functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_GIH_CPU.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_gih_cpu_t_fields[] = {
    {
        .name  = OPAQUE_CMD0s,  /* OPAQUE_CMD0 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Opaque command 0.",
    },
    {
        .name  = OPAQUE_CMD1s,  /* OPAQUE_CMD1 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Opaque command 1.",
    },
    {
        .name  = OPAQUE_CMD2s,  /* OPAQUE_CMD2 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Opaque command 2.",
    },
    {
        .name  = OPAQUE_CMD3s,  /* OPAQUE_CMD3 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Opaque command 3.",
    },
    {
        .name  = OPAQUE_CMD4s,  /* OPAQUE_CMD4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Opaque command 4.",
    },
    {
        .name  = OPAQUE_OBJ0s,  /* OPAQUE_OBJ0 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Opaque object 0.",
    },
    {
        .name  = OPAQUE_OBJ1s,  /* OPAQUE_OBJ1 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Opaque object 1.",
    },
    {
        .name  = ING_SYSTEM_PORT_TABLE_IDs,  /* ING_SYSTEM_PORT_TABLE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress system port identifier mapped for the\n CPU port.\n",
    },
    {
        .name  = PORT_TYPEs,  /* PORT_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress port type in the ingress pipeline.\n The signal decodes are as follows:\n    ING_CMD_BUS_DEVICE_PORT_TYPE\n Overlay types on this field are defined as:\n    FRONT_PANEL_PKT mapped to ING_CMD_BUS_DEVICE_PORT_TYPE[0].\n    HIGIG3_PROCESSING_ENABLE mapped to\n    ING_CMD_BUS_DEVICE_PORT_TYPE[1].\n",
    },
    {
        .name  = PORT_PARSERs,  /* PORT_PARSER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Port parser type.\n The signal decodes are as follows:\n    ING_OBJ_BUS_DEVICE_PORT_PARSE_CTRL_ID\n\n Overlay types on this field are defined as:\n    PARSER_PORT_TYPE mapped to\n    ING_OBJ_BUS_DEVICE_PORT_PARSE_CTRL_ID[2:0].\n\n    PARSER_PORT_TYPE = 1 for LOOPBACK.\n    PARSER_PORT_TYPE = 3 for HIGIG3.\n\n    HIGIG3_PARSING_ENABLE mapped to\n    ING_OBJ_BUS_DEVICE_PORT_PARSE_CTRL_ID[3].\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_gih_cpu_t = {
    .name = PORT_GIH_CPUs, /* PORT_GIH_CPU */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_port_gih_cpu_t_fields,
    .desc = "The PORT_GIH_CPU table specifies CPU port properties used for\n generic internal header (GIH) processing.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ING_BLOCK_LOOPBACK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ing_block_loopback_t_fields[] = {
    {
        .name  = MASK_PORTSs,  /* MASK_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Mask ports bitmap. Enable to loopback the traffic on the\n logical port.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_ing_block_loopback_t = {
    .name = PORT_ING_BLOCK_LOOPBACKs, /* PORT_ING_BLOCK_LOOPBACK */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_port_ing_block_loopback_t_fields,
    .desc = "The PORT_ING_BLOCK_LOOPBACK table is used to enable\n or disable the loopback traffic on logical port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ING_EGR_BLOCK_0.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ing_egr_block_0_t_fields[] = {
    {
        .name  = PORT_ING_EGR_BLOCK_IDs,  /* PORT_ING_EGR_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "PORT_ING_EGR_BLOCK_0 logical table index.",
    },
    {
        .name  = PROFILE_SECTIONs,  /* PROFILE_SECTION */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Profile section.",
    },
    {
        .name  = MASK_EGR_PORTSs,  /* MASK_EGR_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Mask ports bitmap.",
    },
    {
        .name  = MASK_TARGETs,  /* MASK_TARGET */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask target.",
    },
    {
        .name  = MASK_ACTIONs,  /* MASK_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask action.",
    },
};
const bcmltd_table_rep_t bcmltd_port_ing_egr_block_0_t = {
    .name = PORT_ING_EGR_BLOCK_0s, /* PORT_ING_EGR_BLOCK_0 */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_port_ing_egr_block_0_t_fields,
    .desc = "The PORT_ING_EGR_BLOCK_0 table specifies egress member blocking settings\n in the ingress pipeline.\n The egress member ports are determined by applying the action specified in\n MASK_ACTION against the ports specified in MASK_PORTS and\n the L2/L3 egress member ports as specified in MASK_TARGET.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ING_EGR_BLOCK_1.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ing_egr_block_1_t_fields[] = {
    {
        .name  = PORT_ING_EGR_BLOCK_IDs,  /* PORT_ING_EGR_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "PORT_ING_EGR_BLOCK_1 logical table index.",
    },
    {
        .name  = PROFILE_SECTIONs,  /* PROFILE_SECTION */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Profile section.",
    },
    {
        .name  = MASK_EGR_PORTSs,  /* MASK_EGR_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Mask ports bitmap.",
    },
    {
        .name  = MASK_TARGETs,  /* MASK_TARGET */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask target.",
    },
    {
        .name  = MASK_ACTIONs,  /* MASK_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask action.",
    },
};
const bcmltd_table_rep_t bcmltd_port_ing_egr_block_1_t = {
    .name = PORT_ING_EGR_BLOCK_1s, /* PORT_ING_EGR_BLOCK_1 */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_port_ing_egr_block_1_t_fields,
    .desc = "The PORT_ING_EGR_BLOCK_1 table specifies egress member blocking settings\n in the ingress pipeline.\n The egress member ports are determined by applying the action specified in\n MASK_ACTION against the ports specified in MASK_PORTS and\n the L2/L3 egress member ports as specified in MASK_TARGET.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ING_EGR_BLOCK_2.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ing_egr_block_2_t_fields[] = {
    {
        .name  = PORT_ING_EGR_BLOCK_IDs,  /* PORT_ING_EGR_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "PORT_ING_EGR_BLOCK_2 logical table index.",
    },
    {
        .name  = PROFILE_SECTIONs,  /* PROFILE_SECTION */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Profile section.",
    },
    {
        .name  = MASK_EGR_PORTSs,  /* MASK_EGR_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Mask ports bitmap.",
    },
    {
        .name  = MASK_TARGETs,  /* MASK_TARGET */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask target.",
    },
    {
        .name  = MASK_ACTIONs,  /* MASK_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask action.",
    },
};
const bcmltd_table_rep_t bcmltd_port_ing_egr_block_2_t = {
    .name = PORT_ING_EGR_BLOCK_2s, /* PORT_ING_EGR_BLOCK_2 */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_port_ing_egr_block_2_t_fields,
    .desc = "The PORT_ING_EGR_BLOCK_2 table specifies egress member blocking settings\n in the ingress pipeline.\n The egress member ports are determined by applying the action specified in\n MASK_ACTION against the ports specified in MASK_PORTS and\n the L2/L3 egress member ports as specified in MASK_TARGET.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ING_EGR_BLOCK_3.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ing_egr_block_3_t_fields[] = {
    {
        .name  = PORT_ING_EGR_BLOCK_IDs,  /* PORT_ING_EGR_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "PORT_ING_EGR_BLOCK_3 logical table index.",
    },
    {
        .name  = PROFILE_SECTIONs,  /* PROFILE_SECTION */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Profile section.",
    },
    {
        .name  = MASK_EGR_PORTSs,  /* MASK_EGR_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Mask ports bitmap.",
    },
    {
        .name  = MASK_TARGETs,  /* MASK_TARGET */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask target.",
    },
    {
        .name  = MASK_ACTIONs,  /* MASK_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask action.",
    },
};
const bcmltd_table_rep_t bcmltd_port_ing_egr_block_3_t = {
    .name = PORT_ING_EGR_BLOCK_3s, /* PORT_ING_EGR_BLOCK_3 */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_port_ing_egr_block_3_t_fields,
    .desc = "The PORT_ING_EGR_BLOCK_3 table specifies egress member blocking settings\n in the ingress pipeline.\n The egress member ports are determined by applying the action specified in\n MASK_ACTION against the ports specified in MASK_PORTS and\n the L2/L3 egress member ports as specified in MASK_TARGET.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ING_EGR_BLOCK_CPU.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ing_egr_block_cpu_t_fields[] = {
    {
        .name  = MASK_PORTSs,  /* MASK_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Mask ports bitmap.",
    },
};
const bcmltd_table_rep_t bcmltd_port_ing_egr_block_cpu_t = {
    .name = PORT_ING_EGR_BLOCK_CPUs, /* PORT_ING_EGR_BLOCK_CPU */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_port_ing_egr_block_cpu_t_fields,
    .desc = "The PORT_ING_EGR_BLOCK_CPU table specifies control settings for the CPU port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ING_EGR_BLOCK_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ing_egr_block_profile_t_fields[] = {
    {
        .name  = PORT_ING_EGR_BLOCK_PROFILE_IDs,  /* PORT_ING_EGR_BLOCK_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "PORT_ING_EGR_BLOCK_PROFILE logical table index.",
    },
    {
        .name  = SKIP_VLAN_ING_EGR_MEMBERSHIP_CHECKs,  /* SKIP_VLAN_ING_EGR_MEMBERSHIP_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip egress membership check in the ingress pipeline.",
    },
    {
        .name  = SKIP_VLAN_ING_EGR_STG_CHECKs,  /* SKIP_VLAN_ING_EGR_STG_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip egress spanning tree check in the ingress pipeline.",
    },
    {
        .name  = SKIP_ING_EGR_BLOCKs,  /* SKIP_ING_EGR_BLOCK */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable to skip egress member blocking in the ingress pipeline.",
    },
    {
        .name  = SKIP_L3_MEMBER_PRUNINGs,  /* SKIP_L3_MEMBER_PRUNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip pruning to L3 egress member.",
    },
    {
        .name  = SKIP_L2_MEMBER_PRUNINGs,  /* SKIP_L2_MEMBER_PRUNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip pruning to L2 egress member.",
    },
};
const bcmltd_table_rep_t bcmltd_port_ing_egr_block_profile_t = {
    .name = PORT_ING_EGR_BLOCK_PROFILEs, /* PORT_ING_EGR_BLOCK_PROFILE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_port_ing_egr_block_profile_t_fields,
    .desc = "The PORT_ING_EGR_BLOCK_PROFILE table specifies egress member\n blocking control profile settings in the ingress pipeline.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ING_MIRROR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ing_mirror_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress port ID.",
    },
    {
        .name  = MIRROR_CONTAINER_IDs,  /* MIRROR_CONTAINER_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Mirror container ID.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mirror.",
    },
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MIRROR_INSTANCE table index.",
    },
};
const bcmltd_table_rep_t bcmltd_port_ing_mirror_t = {
    .name = PORT_ING_MIRRORs, /* PORT_ING_MIRROR */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_port_ing_mirror_t_fields,
    .desc = "The PORT_ING_MIRROR logical table is used to enable or disable ingress\n mirroring on specified ingress port and mirror container.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ING_OPAQUE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ing_opaque_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = OPAQUE_CMD0s,  /* OPAQUE_CMD0 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Ingress port opaque command 0.",
    },
    {
        .name  = OPAQUE_CMD1s,  /* OPAQUE_CMD1 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Ingress port opaque command 1.",
    },
    {
        .name  = OPAQUE_CMD2s,  /* OPAQUE_CMD2 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Ingress port opaque command 2.",
    },
    {
        .name  = OPAQUE_CMD3s,  /* OPAQUE_CMD3 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Ingress port opaque command 3.",
    },
    {
        .name  = OPAQUE_CMD4s,  /* OPAQUE_CMD4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Ingress port opaque command 4.",
    },
    {
        .name  = OPAQUE_OBJ0s,  /* OPAQUE_OBJ0 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Ingress port opaque object 0.",
    },
    {
        .name  = OPAQUE_OBJ1s,  /* OPAQUE_OBJ1 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Ingress port opaque object 1.",
    },
};
const bcmltd_table_rep_t bcmltd_port_ing_opaque_t = {
    .name = PORT_ING_OPAQUEs, /* PORT_ING_OPAQUE */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_port_ing_opaque_t_fields,
    .desc = "The PORT_ING_OPAQUE table is used to configure ingress port\n opaque fields. Each opaque field usage is defined by NPL and\n its usage is documented in PORT_ING_DEVICE_INFO.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ING_TS_PTP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ing_ts_ptp_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = SIGN_FROM_TIMESTAMPs,  /* SIGN_FROM_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to force sign extension to update the CorrectionField in\n the IEEE1588 packet from the ingress timestamp.\n",
    },
    {
        .name  = CORRECTION_FIELDs,  /* CORRECTION_FIELD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable correction field update on IEEE 1588 event packets.",
    },
    {
        .name  = LINK_DELAYs,  /* LINK_DELAY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Link delay value used for IEEE 1588 one-step packet\n correction field modification.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_ing_ts_ptp_t = {
    .name = PORT_ING_TS_PTPs, /* PORT_ING_TS_PTP */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_port_ing_ts_ptp_t_fields,
    .desc = "The PORT_ING_TS_PTP table specifies the per ingress port\n Precision Time Protocol (PTP) configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_ING_VISIBILITY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_ing_visibility_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress port ID",
    },
    {
        .name  = TIMESTAMP_ORIGINs,  /* TIMESTAMP_ORIGIN */
        .flags = 0,
        .width = 23,
        .depth = 0,
        .desc = "Origin ID for ingress timestamp.",
    },
    {
        .name  = SKIP_TIMESTAMPs,  /* SKIP_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard both ingress and egress timestamp for packets arriving on this port.",
    },
    {
        .name  = TIMESTAMPs,  /* TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to insert ingress timestamp on received packets.",
    },
    {
        .name  = SKIP_TX_TIMESTAMPs,  /* SKIP_TX_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to discard egress timestamp for packets arriving on this port.",
    },
    {
        .name  = TX_TIMESTAMPs,  /* TX_TIMESTAMP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to insert egress timestamp on transmitted packets.",
    },
};
const bcmltd_table_rep_t bcmltd_port_ing_visibility_t = {
    .name = PORT_ING_VISIBILITYs, /* PORT_ING_VISIBILITY */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_port_ing_visibility_t_fields,
    .desc = "The PORT_ING_VISIBILITY table specifies the per ingress port visibility\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_LB.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_lb_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = LB_HASH_PORT_LB_NUMs,  /* LB_HASH_PORT_LB_NUM */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Load Balancing Number for traffic splitting.",
    },
    {
        .name  = OFFSET_TRUNK_RANDOMs,  /* OFFSET_TRUNK_RANDOM */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Circular shift amount to be applied to\n the random value output used in trunk (LAG) resolution.\n",
    },
    {
        .name  = OFFSET_ECMP_RANDOMs,  /* OFFSET_ECMP_RANDOM */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Circular shift amount to be applied to the random value output\n used in Single Level ECMP resolution modes and by Level 1 ECMP resolution\n in Hierarchical Resolution Mode.\n",
    },
    {
        .name  = OFFSET_ECMP_LEVEL1_RANDOMs,  /* OFFSET_ECMP_LEVEL1_RANDOM */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Circular shift amount to be applied to the random value output\n used by Level 1 ECMP resolution in Hierarchical Resolution Mode.\n Not used when configured in Single Level ECMP Resolution Modes.\n",
    },
    {
        .name  = OFFSET_ECMP_LEVEL2_RANDOMs,  /* OFFSET_ECMP_LEVEL2_RANDOM */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Circular shift amount to be applied to the random value output\n used by Level 2 ECMP resolution in Hierarchical Resolution Mode.\n Not used when configured in Single Level ECMP Resolution Modes.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_lb_t = {
    .name = PORT_LBs, /* PORT_LB */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_port_lb_t_fields,
    .desc = "The PORT_LB table specifies the port level load balancing functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_LEARN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_learn_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = MAC_LEARNs,  /* MAC_LEARN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MAC address learning.",
    },
    {
        .name  = MAC_COPY_TO_CPUs,  /* MAC_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copying to CPU for packets with\n unknown source MAC address.\n",
    },
    {
        .name  = MAC_LEARN_AS_PENDINGs,  /* MAC_LEARN_AS_PENDING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable learning new MAC addresses as pending.",
    },
    {
        .name  = MAC_DROPs,  /* MAC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping packets with\n unknown source MAC address.\n",
    },
    {
        .name  = MAC_MOVEs,  /* MAC_MOVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MAC address station move.",
    },
    {
        .name  = MAC_MOVE_COPY_TO_CPUs,  /* MAC_MOVE_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copying to CPU for station move packets.",
    },
    {
        .name  = MAC_MOVE_AS_PENDINGs,  /* MAC_MOVE_AS_PENDING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable learning station move\n MAC addresses as pending.\n",
    },
    {
        .name  = MAC_MOVE_DROPs,  /* MAC_MOVE_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping station move packets.",
    },
    {
        .name  = STATIC_MOVE_DROP_DISABLEs,  /* STATIC_MOVE_DROP_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disable static move drop.",
    },
};
const bcmltd_table_rep_t bcmltd_port_learn_t = {
    .name = PORT_LEARNs, /* PORT_LEARN */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_port_learn_t_fields,
    .desc = "The PORT_LEARN table specifies the port level\n MAC address learning functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_MEMBERSHIP_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_membership_policy_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = ING_VLAN_MEMBERSHIP_CHECKs,  /* ING_VLAN_MEMBERSHIP_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping packets that are not a member of the port's ingress VLAN.",
    },
    {
        .name  = EGR_VLAN_MEMBERSHIP_CHECKs,  /* EGR_VLAN_MEMBERSHIP_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping packets that are not a member of the port's egress VLAN.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable skipping VLAN membership checks.",
    },
};
const bcmltd_table_rep_t bcmltd_port_membership_policy_t = {
    .name = PORT_MEMBERSHIP_POLICYs, /* PORT_MEMBERSHIP_POLICY */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_port_membership_policy_t_fields,
    .desc = "The PORT_MEMBERSHIP_POLICY table specifies\n VLAN membership check attributes for a port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_MIRROR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_mirror_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable both ingress and egress mirror on the ingress port.",
    },
    {
        .name  = CPUs,  /* CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to queue mirror packets to CPU in a dedicated CPU queue\n on the ingress port.\n",
    },
    {
        .name  = EGR_ENCAPs,  /* EGR_ENCAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encapsulate the mirrored packet on the egress port.\n If ENCAP in MIRROR_ING_MEMBER or MIRROR_EGR_MEMBER table is\n disabled, use PORT_MIRROR.MIRROR_ENCAP_ID when EGR_ENCAP is enabled.\n",
    },
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MIRROR_ENCAP table index. Applicable only if EGR_ENCAP is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_mirror_t = {
    .name = PORT_MIRRORs, /* PORT_MIRROR */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_port_mirror_t_fields,
    .desc = "The PORT_MIRROR table specifies mirror actions on the specified port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_MODBASE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_modbase_t_fields[] = {
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Module ID.",
    },
    {
        .name  = MODBASEs,  /* MODBASE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Base index used to calculate the PORT_SYSTEM logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_port_modbase_t = {
    .name = PORT_MODBASEs, /* PORT_MODBASE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_port_modbase_t_fields,
    .desc = "The PORT_MODBASE table specifies the base index used to\n calculate the PORT_SYSTEM table index.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_PHB.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_phb_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = TRUST_PHB_ING_DSCP_V4s,  /* TRUST_PHB_ING_DSCP_V4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust incoming IPv4 DSCP and map to PHB.",
    },
    {
        .name  = TRUST_PHB_ING_DSCP_V6s,  /* TRUST_PHB_ING_DSCP_V6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust incoming IPv6 DSCP and map to PHB.",
    },
    {
        .name  = PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs,  /* PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_IP_DSCP_TO_INT_PRI_REMAP logical table index.\n Applicable only if TRUST_PHB_ING_DSCP_V4 is enabled for IPv4 packets\n and TRUST_PHB_ING_DSCP_V6 is enabled for IPv6 packets.\n",
    },
    {
        .name  = TRUST_PHB_ING_L2_ITAGs,  /* TRUST_PHB_ING_L2_ITAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust incoming inner vlan tag and map the inner VLAN tag's\n 802.1p/CFI bits to PHB.\n",
    },
    {
        .name  = PHB_ING_L2_IDs,  /* PHB_ING_L2_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_L2_TAGGED_TO_INT_PRI logical table index or\n PHB_ING_L2_UNTAGGED_TO_INT_PRI logical table index depending on\n whether the packet is tagged or untagged.\n",
    },
    {
        .name  = PHB_ING_L2_OTAG_REMAP_IDs,  /* PHB_ING_L2_OTAG_REMAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_L2_OTAG_REMAP logical table index.",
    },
    {
        .name  = TRUST_PHB_EGR_L2_OTAGs,  /* TRUST_PHB_EGR_L2_OTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use PRI and CFI from the PHB_EGR_L2_INT_PRI_TO_OTAG logical table\n as EGR_OPRI and EGR_OCFI.\n",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_OTAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_OTAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_L2_INT_PRI_TO_OTAG logical table index.\n Applicable only if TRUST_PHB_EGR_L2_OTAG is enabled.\n",
    },
    {
        .name  = TRUST_PHB_EGR_L2_ITAGs,  /* TRUST_PHB_EGR_L2_ITAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use PRI and CFI from the PHB_EGR_L2_INT_PRI_TO_ITAG logical table\n as EGR_IPRI and EGR_ICFI.\n",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_ITAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_ITAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_L2_INT_PRI_TO_ITAG logical table index.\n Applicable only if TRUST_PHB_EGR_L2_ITAG is enabled.\n",
    },
    {
        .name  = TRUST_PHB_EGR_DSCP_MAPs,  /* TRUST_PHB_EGR_DSCP_MAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use INT_PRI and CNG to index the PHB_EGR_IP_INT_PRI_TO_DSCP\n logical table to get the outgoing IP header's DSCP value.\n",
    },
    {
        .name  = PHB_EGR_IP_INT_PRI_TO_DSCP_IDs,  /* PHB_EGR_IP_INT_PRI_TO_DSCP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_IP_INT_PRI_TO_DSCP logical table index.\n Applicable only if TRUST_PHB_EGR_DSCP_MAP is enabled.\n",
    },
    {
        .name  = TRUST_PHB_EGR_PORT_L2_OTAGs,  /* TRUST_PHB_EGR_PORT_L2_OTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use INT_PRI and CNG to index the PHB_EGR_PORT_INT_PRI_TO_L2_OTAG\n logical table to get the outgoing IP header's 802.1p value and CFI value.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_phb_t = {
    .name = PORT_PHBs, /* PORT_PHB */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_port_phb_t_fields,
    .desc = "The PORT_PHB table specifies port per-hop behavior.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_PKT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_pkt_control_t_fields[] = {
    {
        .name  = PORT_PKT_CONTROL_IDs,  /* PORT_PKT_CONTROL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Packet control ID.",
    },
    {
        .name  = SRP_TO_CPUs,  /* SRP_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of SRP packets to CPU.",
    },
    {
        .name  = SRP_FWD_ACTIONs,  /* SRP_FWD_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "SRP packets forwarding action.",
    },
    {
        .name  = ND_TO_CPUs,  /* ND_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of ND packets to CPU.",
    },
    {
        .name  = ND_DROPs,  /* ND_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping ND packets.",
    },
    {
        .name  = MMRP_TO_CPUs,  /* MMRP_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of MMRP packets to CPU.",
    },
    {
        .name  = MMRP_FWD_ACTIONs,  /* MMRP_FWD_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "MMRP packets forwarding action.",
    },
    {
        .name  = DHCP_TO_CPUs,  /* DHCP_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of DHCP packets to CPU.",
    },
    {
        .name  = DHCP_DROPs,  /* DHCP_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping DHCP packets.",
    },
    {
        .name  = ARP_REQUEST_TO_CPUs,  /* ARP_REQUEST_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of ARP request packets to CPU.",
    },
    {
        .name  = ARP_REQUEST_DROPs,  /* ARP_REQUEST_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping ARP request packets.",
    },
    {
        .name  = ARP_REPLY_TO_CPUs,  /* ARP_REPLY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of ARP reply packets to CPU.",
    },
    {
        .name  = ARP_REPLY_DROPs,  /* ARP_REPLY_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping ARP reply packets.",
    },
    {
        .name  = PFM_RULE_APPLYs,  /* PFM_RULE_APPLY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use Port Filtering Multicast (PFM) rules that are\n applied to IGMP/MLD/reserved multicast packets when\n flooded to VLAN.\n",
    },
    {
        .name  = IGMP_REPORT_LEAVE_FWD_ACTIONs,  /* IGMP_REPORT_LEAVE_FWD_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Forwarding action for IGMP report/leave messages.",
    },
    {
        .name  = IGMP_REPORT_LEAVE_TO_CPUs,  /* IGMP_REPORT_LEAVE_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IGMP report/leave to the CPU.",
    },
    {
        .name  = IGMP_QUERY_FWD_ACTIONs,  /* IGMP_QUERY_FWD_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Forwarding action for IGMP query messages.",
    },
    {
        .name  = IGMP_QUERY_TO_CPUs,  /* IGMP_QUERY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IGMP query to the CPU.",
    },
    {
        .name  = IGMP_UNKNOWN_MSG_FWD_ACTIONs,  /* IGMP_UNKNOWN_MSG_FWD_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Forwarding action for unknown IGMP messages.",
    },
    {
        .name  = IGMP_UNKNOWN_MSG_TO_CPUs,  /* IGMP_UNKNOWN_MSG_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy unknown IGMP messages to the CPU.",
    },
    {
        .name  = IPV4_RESVD_MC_PKT_FWD_ACTIONs,  /* IPV4_RESVD_MC_PKT_FWD_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Forwarding action for IPv4 reserved multicast packets.",
    },
    {
        .name  = IPV4_RESVD_MC_PKT_TO_CPUs,  /* IPV4_RESVD_MC_PKT_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IPv4 reserved multicast packets to the CPU.",
    },
    {
        .name  = IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONs,  /* IPV4_MC_ROUTER_ADV_PKT_FWD_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Forwarding action for multicast router\n advertisement/solicitation/termination packets.\n",
    },
    {
        .name  = IPV4_MC_ROUTER_ADV_PKT_TO_CPUs,  /* IPV4_MC_ROUTER_ADV_PKT_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy multicast router\n advertisement/solicitation/termination packets to the CPU.\n",
    },
    {
        .name  = MLD_REPORT_DONE_FWD_ACTIONs,  /* MLD_REPORT_DONE_FWD_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Forwarding action for MLD report/done messages.",
    },
    {
        .name  = MLD_REPORT_DONE_TO_CPUs,  /* MLD_REPORT_DONE_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MLD report/done to the CPU.",
    },
    {
        .name  = MLD_QUERY_FWD_ACTIONs,  /* MLD_QUERY_FWD_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Forwarding action for MLD query messages.",
    },
    {
        .name  = MLD_QUERY_TO_CPUs,  /* MLD_QUERY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MLD query to the CPU.",
    },
    {
        .name  = IPV6_RESVD_MC_PKT_FWD_ACTIONs,  /* IPV6_RESVD_MC_PKT_FWD_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Forwarding action for IPv6 reserved multicast packets.",
    },
    {
        .name  = IPV6_RESVD_MC_PKT_TO_CPUs,  /* IPV6_RESVD_MC_PKT_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy IPv6 reserved multicast packets to the CPU.",
    },
    {
        .name  = IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONs,  /* IPV6_MC_ROUTER_ADV_PKT_FWD_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Forwarding action for multicast router\n advertisement/solicitation/termination packets.\n",
    },
    {
        .name  = IPV6_MC_ROUTER_ADV_PKT_TO_CPUs,  /* IPV6_MC_ROUTER_ADV_PKT_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy multicast router\n advertisement/solicitation/termination packets to the CPU.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_pkt_control_t = {
    .name = PORT_PKT_CONTROLs, /* PORT_PKT_CONTROL */
    .flags = 0,
    .fields = 32,
    .field = bcmltd_port_pkt_control_t_fields,
    .desc = "The PORT_PKT_CONTROL table specifies the forwarding actions\n for protocol packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_policy_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = TRUST_INCOMING_VIDs,  /* TRUST_INCOMING_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable trusting incoming VLAN tag.",
    },
    {
        .name  = DROP_ON_PRIs,  /* DROP_ON_PRI */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Drop packet with the given priority.\n Array is indexed by 802.1p priority.\n",
    },
    {
        .name  = DROP_UNTAGs,  /* DROP_UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping untagged packets.",
    },
    {
        .name  = DROP_TAGs,  /* DROP_TAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping tagged packets.",
    },
    {
        .name  = PASS_PAUSE_FRAMESs,  /* PASS_PAUSE_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable passing pause frames.",
    },
    {
        .name  = OUTER_TPID_VERIFYs,  /* OUTER_TPID_VERIFY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable matching of packet TPID idx against configured\n VLAN_PROFILE.VLAN_OUTER_TPID_ID and drop on mismatch.\n",
    },
    {
        .name  = PASS_ON_OUTER_TPID_MATCHs,  /* PASS_ON_OUTER_TPID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable matching of packet outer header TPID against\n the VLAN_OUTER_TPID logical table on ingress pipe.\n Array is indexed by VLAN_OUTER_TPID_ID.\n",
    },
    {
        .name  = PASS_ON_EGR_OUTER_TPID_MATCHs,  /* PASS_ON_EGR_OUTER_TPID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable matching of packet outer header TPID against\n the VLAN_OUTER_TPID logical table on egress pipe.\n Array is indexed by VLAN_OUTER_TPID_ID.\n",
    },
    {
        .name  = MAC_IP_BIND_LOOKUP_MISS_DROPs,  /* MAC_IP_BIND_LOOKUP_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable HPAE (Host Posture Assessment and Enforcement) checking.",
    },
    {
        .name  = DROP_BPDUs,  /* DROP_BPDU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping BPDU packets.",
    },
    {
        .name  = ING_CFI_AS_CNGs,  /* ING_CFI_AS_CNG */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "If enabled, ingress CFI carries QoS (drop precedence) information per TPID.\n Array is indexed by VLAN_OUTER_TPID_ID.\n",
    },
    {
        .name  = USE_TABLE_VLAN_OUTER_TPID_IDs,  /* USE_TABLE_VLAN_OUTER_TPID_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use VLAN_OUTER_TPID_ID in logical table VLAN,\n otherwise, use VLAN_OUTER_TPID_ID in the logical table PORT_POLICY.\n",
    },
    {
        .name  = VLAN_OUTER_TPID_IDs,  /* VLAN_OUTER_TPID_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_OUTER_TPID logical table index.",
    },
    {
        .name  = ING_VLAN_OUTER_TPID_IDs,  /* ING_VLAN_OUTER_TPID_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_OUTER_TPID logical table index\n for ingress port based vlan action.\n",
    },
    {
        .name  = EGR_CFI_AS_CNGs,  /* EGR_CFI_AS_CNG */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "If enabled, egress CFI carries QoS (drop precedence) information per TPID.\n Array is indexed by VLAN_OUTER_TPID_ID.\n",
    },
    {
        .name  = PORT_COS_Q_MAP_IDs,  /* PORT_COS_Q_MAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PORT_COS_Q_MAP logical table index.",
    },
    {
        .name  = PASS_ON_PAYLOAD_OUTER_TPID_MATCHs,  /* PASS_ON_PAYLOAD_OUTER_TPID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable matching of tunnel L2 payload outer TPID against\n the VLAN_PAYLOAD_OUTER_TPID logical table on ingress pipe.\n Array is indexed by VLAN_PAYLOAD_OUTER_TPID_ID.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_policy_t = {
    .name = PORT_POLICYs, /* PORT_POLICY */
    .flags = 0,
    .fields = 18,
    .field = bcmltd_port_policy_t_fields,
    .desc = "The PORT_POLICY table specifies policy attributes for a port.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_PROPERTY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_property_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = PORT_TYPEs,  /* PORT_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress port type in the ingress pipeline.\n The signal decodes are as follows:\n    ING_CMD_BUS_DEVICE_PORT_TYPE\n Overlay types on this field are defined as:\n    FRONT_PANEL_PKT mapped to ING_CMD_BUS_DEVICE_PORT_TYPE[0].\n    HIGIG3_PROCESSING_ENABLE mapped to ING_CMD_BUS_DEVICE_PORT_TYPE[1].\n",
    },
    {
        .name  = ING_PORT_PROPERTYs,  /* ING_PORT_PROPERTY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress port properties in the egress pipeline.\n The signal decodes are as follows:\n    EGR_CMD_BUS_RX_PORT_CTRL\n Overlay types on this field are defined as:\n    RX_PORT_TYPE mapped to EGR_CMD_BUS_RX_PORT_CTRL[2:0]\n    RX_PORT_TYPE = 0 for ETHERNET.\n    RX_PORT_TYPE = 1 for HIGIG3.\n",
    },
    {
        .name  = EGR_PORT_PROPERTYs,  /* EGR_PORT_PROPERTY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Egress port properties in the egress pipeline.\n The signal decodes are as follows:\n    EGR_CMD_BUS_TX_PORT_CTRL\n Overlay types on this field are defined as:\n    TX_PORT_TYPE mapped to EGR_CMD_BUS_TX_PORT_CTRL[2:0].\n    TX_PORT_TYPE = 0 for ETHERNET.\n    TX_PORT_TYPE = 2 for LOOPBACK.\n    TX_PORT_TYPE = 3 for HIGIG3.\n    ECN_STATE_ACT mapped to EGR_CMD_BUS_TX_PORT_CTRL[3].\n",
    },
    {
        .name  = PORT_PARSERs,  /* PORT_PARSER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Port parser type.\n The signal decodes are as follows:\n    ING_OBJ_BUS_DEVICE_PORT_PARSE_CTRL_ID\n Overlay types on this field are defined as:\n    PARSER_PORT_TYPE mapped to ING_OBJ_BUS_DEVICE_PORT_PARSE_CTRL_ID[2:0].\n    PARSER_PORT_TYPE = 1 for LOOPBACK.\n    PARSER_PORT_TYPE = 3 for HIGIG3.\n    HIGIG3_PARSING_ENABLE mapped to ING_OBJ_BUS_DEVICE_PORT_PARSE_CTRL_ID[3].\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_property_t = {
    .name = PORT_PROPERTYs, /* PORT_PROPERTY */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_port_property_t_fields,
    .desc = "The PORT_PROPERTY table is used to configure the port controls for\n ingress, egress pipeline traffic processing and parsing.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_PVLAN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_pvlan_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = ING_PVLANs,  /* ING_PVLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ingress private VLAN.",
    },
    {
        .name  = EGR_PVLANs,  /* EGR_PVLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable egress private VLAN.",
    },
    {
        .name  = EGR_REPLACE_PRIs,  /* EGR_REPLACE_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to replace the packet's 802.1p priority value.",
    },
    {
        .name  = EGR_PRIs,  /* EGR_PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "802.1p priority value to set in the packet.\n Applicable only if EGR_REPLACE_PRI is enabled.\n",
    },
    {
        .name  = EGR_UNTAGs,  /* EGR_UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable packets to be sent out untagged.",
    },
    {
        .name  = EGR_VIDs,  /* EGR_VID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN for the outgoing packet.\n Applicable only if EGR_UNTAG is disabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_pvlan_t = {
    .name = PORT_PVLANs, /* PORT_PVLAN */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_port_pvlan_t_fields,
    .desc = "The PORT_PVLAN table specifies private VLAN port properties.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SVP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_svp_t_fields[] = {
    {
        .name  = PORT_SVP_IDs,  /* PORT_SVP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 14,
        .depth = 0,
        .desc = "Source virtual port.",
    },
    {
        .name  = TRUST_PHB_ING_DSCP_V6s,  /* TRUST_PHB_ING_DSCP_V6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust incoming IPv6 DSCP and map to PHB.",
    },
    {
        .name  = TRUST_PHB_ING_DSCP_V4s,  /* TRUST_PHB_ING_DSCP_V4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust incoming IPv4 DSCP and map to PHB.",
    },
    {
        .name  = PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs,  /* PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_IP_DSCP_TO_INT_PRI_REMAP logical table index.\n Applicable only if TRUST_PHB_ING_DSCP_V4 is enabled for IPv4\n packets and TRUST_PHB_ING_DSCP_V6 is enabled for IPv6 packets.\n",
    },
    {
        .name  = PHB_ING_L2_IDs,  /* PHB_ING_L2_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_L2_TAGGED_TO_INT_PRI logical table index or\n PHB_ING_L2_UNTAGGED_TO_INT_PRI logical table index depending on\n whether the packet is tagged or untagged.\n",
    },
    {
        .name  = SVP_NETWORK_GRPs,  /* SVP_NETWORK_GRP */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Network group for source virtual port.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID for the ingress FP.",
    },
    {
        .name  = V6L3s,  /* V6L3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv6 unicast packets.",
    },
    {
        .name  = V6IPMCs,  /* V6IPMC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv6 multicast packets.",
    },
    {
        .name  = L2_FWD_IPMCV6s,  /* L2_FWD_IPMCV6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2-only forwarding of IPMCv6 packets.",
    },
    {
        .name  = V4L3s,  /* V4L3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv4 unicast packets.",
    },
    {
        .name  = V4IPMCs,  /* V4IPMC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv4 multicast packets.",
    },
    {
        .name  = L2_FWD_IPMCV4s,  /* L2_FWD_IPMCV4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2-only forwarding of IPMCv4 packets.",
    },
    {
        .name  = INPORT_BITMAP_INDEXs,  /* INPORT_BITMAP_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Port bitmap index to generate Input Port Bitmap field of the IFP.",
    },
    {
        .name  = PORT_SVP_ING_EFLEX_ACTION_IDs,  /* PORT_SVP_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Select one enhanced ingress flex counter action from\n PORT_SVP_ING_EFLEX_ACTION logical table.\n",
    },
    {
        .name  = ECN_TNL_DECAP_IDs,  /* ECN_TNL_DECAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_TNL_DECAP_IP_PAYLOAD logical table index\n if the terminating tunnel has IP payload, or\n ECN_TNL_DECAP_NON_IP_PAYLOAD logical table index\n if the terminating tunnel has non IP payload.\n",
    },
    {
        .name  = PHB_ING_L2_OTAG_REMAP_IDs,  /* PHB_ING_L2_OTAG_REMAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index in to PHB_ING_L2_OTAG_REMAP logical table.",
    },
    {
        .name  = SKIP_VP_PRUNINGs,  /* SKIP_VP_PRUNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip pruning of packet with source virtual port\n equals to destination virtual port.\n",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip VLAN membership and STG STP state check.",
    },
    {
        .name  = MAC_DROPs,  /* MAC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping packets with\n unknown source MAC address.\n",
    },
    {
        .name  = MAC_COPY_TO_CPUs,  /* MAC_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copying to CPU for packets with\n unknown source MAC address.\n",
    },
    {
        .name  = MAC_LEARNs,  /* MAC_LEARN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MAC address learning.",
    },
    {
        .name  = MAC_MOVE_DROPs,  /* MAC_MOVE_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping station move packets.",
    },
    {
        .name  = MAC_MOVE_COPY_TO_CPUs,  /* MAC_MOVE_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copying to CPU for station move packets.",
    },
    {
        .name  = MAC_MOVEs,  /* MAC_MOVE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MAC address station move.",
    },
};
const bcmltd_table_rep_t bcmltd_port_svp_t = {
    .name = PORT_SVPs, /* PORT_SVP */
    .flags = 0,
    .fields = 25,
    .field = bcmltd_port_svp_t_fields,
    .desc = "The PORT_SVP table specifies the basic port properties and\n port level functionality for source virtual port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SVP_ES_FILTERING.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_svp_es_filtering_t_fields[] = {
    {
        .name  = PORT_SVP_IDs,  /* PORT_SVP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 14,
        .depth = 0,
        .desc = "Source virtual port.",
    },
    {
        .name  = ES_DROPs,  /* ES_DROP */
        .flags = 0,
        .width = 1,
        .depth = 64,
        .desc = "Enable to drop the packets to the specified ethernet\n segment (ES).\n",
    },
    {
        .name  = CTR_EGR_EFLEX_OBJECTs,  /* CTR_EGR_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter object.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_port_svp_es_filtering_t = {
    .name = PORT_SVP_ES_FILTERINGs, /* PORT_SVP_ES_FILTERING */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 4,
    .field = bcmltd_port_svp_es_filtering_t_fields,
    .desc = "The PORT_SVP_ES_FILTERING table is used to enable or disable the\n ethernet segment (ES) filtering based on source virtual port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SVP_ES_FILTERING_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_svp_es_filtering_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = PORT_SVP_ID_MASKs,  /* PORT_SVP_ID_MASK */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Source virtual port mask.",
    },
};
const bcmltd_table_rep_t bcmltd_port_svp_es_filtering_key_mask_t = {
    .name = PORT_SVP_ES_FILTERING_KEY_MASKs, /* PORT_SVP_ES_FILTERING_KEY_MASK */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_port_svp_es_filtering_key_mask_t_fields,
    .desc = "The PORT_SVP_ES_FILTERING_KEY_MASK table specifies the global\n key mask for PORT_SVP_ES_FILTERING.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SVP_ING_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_svp_ing_eflex_action_t_fields[] = {
    {
        .name  = PORT_SVP_ING_EFLEX_ACTION_IDs,  /* PORT_SVP_ING_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PORT_SVP_ING_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_port_svp_ing_eflex_action_t = {
    .name = PORT_SVP_ING_EFLEX_ACTIONs, /* PORT_SVP_ING_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_port_svp_ing_eflex_action_t_fields,
    .desc = "PORT_SVP_ING_EFLEX_ACTION logical table is used to control virtual\n port level enhanced ingress flex counter functions.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SVP_ING_MIRROR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_svp_ing_mirror_t_fields[] = {
    {
        .name  = PORT_SVP_IDs,  /* PORT_SVP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 14,
        .depth = 0,
        .desc = "Source virtual port.",
    },
    {
        .name  = MIRROR_CONTAINER_IDs,  /* MIRROR_CONTAINER_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Mirror container ID.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mirror.",
    },
};
const bcmltd_table_rep_t bcmltd_port_svp_ing_mirror_t = {
    .name = PORT_SVP_ING_MIRRORs, /* PORT_SVP_ING_MIRROR */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_port_svp_ing_mirror_t_fields,
    .desc = "The PORT_SVP_ING_MIRROR logical table is used to enable or disable\n ingress mirroring on specified source virtual port and mirror\n container.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SVP_NETWORK_GRP_PRUNE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_svp_network_grp_prune_t_fields[] = {
    {
        .name  = PORT_SVP_NETWORK_GRPs,  /* PORT_SVP_NETWORK_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Network group for source virtual port.",
    },
    {
        .name  = PRUNINGs,  /* PRUNING */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable to prune packets from the specified source to given\n destination network group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_svp_network_grp_prune_t = {
    .name = PORT_SVP_NETWORK_GRP_PRUNEs, /* PORT_SVP_NETWORK_GRP_PRUNE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_port_svp_network_grp_prune_t_fields,
    .desc = "The PORT_SVP_NETWORK_GRP_PRUNE table specifies the pruning for\n traffic between giving source virtual port network group to\n destination virtual port network group.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_t_fields[] = {
    {
        .name  = PORT_SYSTEM_IDs,  /* PORT_SYSTEM_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the PORT_SYSTEM table.",
    },
    {
        .name  = SYSTEM_PORT_TYPEs,  /* SYSTEM_PORT_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Type of the system port.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Trunk ID.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID for the ingress FP.",
    },
    {
        .name  = VRF_IDs,  /* VRF_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "VRF ID. Applicable if OPERATING_MODE is VRF.",
    },
    {
        .name  = FP_VLAN_PORT_GRPs,  /* FP_VLAN_PORT_GRP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "VLAN FP key port group ID.\n Applicable only if USE_TABLE_FP_VLAN_PORT_GRP\n in the PORT_FP logical table is disabled.\n",
    },
    {
        .name  = VLAN_XLATE_PORT_GRPs,  /* VLAN_XLATE_PORT_GRP */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "Ingress VLAN translation key port group.",
    },
    {
        .name  = OUTER_VLAN_ASSIGNMENT_VLAN_RANGE_IDs,  /* OUTER_VLAN_ASSIGNMENT_VLAN_RANGE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ASSIGNMENT_VLAN_RANGE logical table index for outer VLAN ID.",
    },
    {
        .name  = INNER_VLAN_ASSINGMENT_VLAN_RANGE_IDs,  /* INNER_VLAN_ASSINGMENT_VLAN_RANGE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ASSIGNMENT_VLAN_RANGE logical table index for inner VLAN ID.",
    },
    {
        .name  = OPERATING_MODEs,  /* OPERATING_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operating mode of the port.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable if OPERATING_MODE is L3_IIF.\n",
    },
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID.\n Applicable if OPERATING_MODE is VLAN.\n",
    },
    {
        .name  = L2_FWD_IPMCV6s,  /* L2_FWD_IPMCV6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2-only forwarding of IPMCv6 packets.",
    },
    {
        .name  = L2_FWD_IPMCV4s,  /* L2_FWD_IPMCV4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2-only forwarding of IPMCv4 packets.",
    },
    {
        .name  = MPLSs,  /* MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable skipping STP and VLAN membership check.",
    },
    {
        .name  = BLOCKED_EGR_PORTSs,  /* BLOCKED_EGR_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Bitmap of egress ports which are blocked\n for ingress traffic from this port.\n",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "PORT_SYSTEM_<OBJECT>_PROFILE logical table index.",
    },
    {
        .name  = ECN_CNG_TO_MPLS_EXP_IDs,  /* ECN_CNG_TO_MPLS_EXP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_CNG_TO_MPLS_EXP logical table index.",
    },
    {
        .name  = ECN_CNG_TO_MPLS_EXP_PRIORITYs,  /* ECN_CNG_TO_MPLS_EXP_PRIORITY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies priority for ECN_CNG_TO_MPLS_EXP_ID from\n this table. Priority is relative to the associated\n originating or transit MPLS tunnel.\n",
    },
    {
        .name  = ECN_IP_TO_MPLS_EXP_IDs,  /* ECN_IP_TO_MPLS_EXP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE logical table index\n for non-responsive protocols or ECN_IP_TO_MPLS_EXP_RESPONSIVE\n logical table index for responsive protocols.\n",
    },
    {
        .name  = ECN_IP_TO_MPLS_EXP_PRIORITYs,  /* ECN_IP_TO_MPLS_EXP_PRIORITY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies priority for ECN_IP_TO_MPLS_EXP_ID from this\n table. Priority is relative to the associated\n originating or transit MPLS tunnel.\n",
    },
    {
        .name  = INPORT_BITMAP_INDEXs,  /* INPORT_BITMAP_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Port bitmap index to generate Input Port Bitmap field of the IFP.",
    },
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Virtual Forwarding Instance.",
    },
    {
        .name  = PORT_SVP_IDs,  /* PORT_SVP_ID */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Source Virtual Port.",
    },
    {
        .name  = VFI_ING_ADAPT_FIRST_LOOKUPs,  /* VFI_ING_ADAPT_FIRST_LOOKUP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable VFI ingress adaptation lookup 1.",
    },
    {
        .name  = VFI_ING_ADAPT_SECOND_LOOKUPs,  /* VFI_ING_ADAPT_SECOND_LOOKUP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable VFI ingress adaptation lookup 2.",
    },
    {
        .name  = VFI_ING_ADAPT_FIRST_LOOKUP_PORT_GRP_MODEs,  /* VFI_ING_ADAPT_FIRST_LOOKUP_PORT_GRP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Port group mode for VFI_ING_ADAPT_FIRST_LOOKUP. Applicable\n only if VFI_ING_ADAPT_FIRST_LOOKUP is enabled.\n",
    },
    {
        .name  = VFI_ING_ADAPT_SECOND_LOOKUP_PORT_GRP_MODEs,  /* VFI_ING_ADAPT_SECOND_LOOKUP_PORT_GRP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Port group mode for VFI_ING_ADAPT_SECOND_LOOKUP. Applicable\n only if VFI_ING_ADAPT_SECOND_LOOKUP is enabled.\n",
    },
    {
        .name  = VFI_ING_ADAPT_PORT_GRPs,  /* VFI_ING_ADAPT_PORT_GRP */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "Port group ID used for VFI ingress adaptation lookup. Applicable\n Only if VFI_ING_ADAPT_FIRST/SECOND_LOOKUP_PORT_GRP_MODE is\n PORT_GRP_ID.\n",
    },
    {
        .name  = VFI_ING_ADAPT_LOOKUP_MISS_DROPs,  /* VFI_ING_ADAPT_LOOKUP_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets if both VFI_ING_ADAPT_FIRST_LOOKUP and\n VFI_ING_ADAPT_SECOND_LOOKUP miss.\n",
    },
    {
        .name  = VFI_ING_ADAPT_FIRST_LOOKUP_MISS_DROPs,  /* VFI_ING_ADAPT_FIRST_LOOKUP_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets if VFI_ING_ADAPT_FIRST_LOOKUP misses.",
    },
    {
        .name  = VXLAN_DECAPs,  /* VXLAN_DECAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable VXLAN tunnel decapsulation.",
    },
    {
        .name  = VXLAN_DECAP_KEY_MODEs,  /* VXLAN_DECAP_KEY_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select key mode for VXLAN tunnel decapsulation determination.",
    },
    {
        .name  = VXLAN_DECAP_USE_PKT_OVIDs,  /* VXLAN_DECAP_USE_PKT_OVID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use VLAN ID from packet as the key OVID during VXLAN\n tunnel decapsulation determination, otherwise zero is used as the\n key.\n",
    },
    {
        .name  = VXLAN_VFI_ASSIGN_KEY_MODEs,  /* VXLAN_VFI_ASSIGN_KEY_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select key mode for virtual forwarding instance (VFI) assignment\n during VXLAN tunnel decapsulation.\n",
    },
    {
        .name  = VXLAN_VFI_ASSIGN_USE_PKT_OVIDs,  /* VXLAN_VFI_ASSIGN_USE_PKT_OVID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use VLAN ID from packet as the key OVID for\n VFI assignment during VXLAN tunnel decapsulation.\n",
    },
    {
        .name  = VXLAN_SVP_ASSIGN_USE_PKT_OVIDs,  /* VXLAN_SVP_ASSIGN_USE_PKT_OVID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use VLAN ID from packet as the key OVID for source\n virtual port assignment during VXLAN tunnel decapsulation.\n",
    },
    {
        .name  = ASSIGN_DEFAULT_NETWORK_SVPs,  /* ASSIGN_DEFAULT_NETWORK_SVP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to assign default source virtual port during\n VXLAN tunnel decapsulation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_t = {
    .name = PORT_SYSTEMs, /* PORT_SYSTEM */
    .flags = 0,
    .fields = 39,
    .field = bcmltd_port_system_t_fields,
    .desc = "The PORT_SYSTEM table specifies the system port properties and functionality.\n The PORT_SYSTEM table index is the summation of the logical port ID and\n the value of PORT_MODBASE.MODBASE. Note that the PORT_MODBASE logical table\n is not mapped to all devices, in which case the PORT_SYSTEM table index\n is equal to the logical port ID.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_BRIDGE_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_bridge_profile_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port system profile ID.",
    },
    {
        .name  = BRIDGEs,  /* BRIDGE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2 forwarding of broadcast, unknown unicast and\n multicast packets.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_bridge_profile_t = {
    .name = PORT_SYSTEM_BRIDGE_PROFILEs, /* PORT_SYSTEM_BRIDGE_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_port_system_bridge_profile_t_fields,
    .desc = "The PORT_SYSTEM_BRIDGE_PROFILE table specifies the system port level\n bridging functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_DESTINATION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_destination_t_fields[] = {
    {
        .name  = PORT_SYSTEM_IDs,  /* PORT_SYSTEM_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into PORT_SYSTEM_DESTINATION table.\n System port ID.\n",
    },
    {
        .name  = IS_TRUNK_SYSTEMs,  /* IS_TRUNK_SYSTEM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if the destination is a system trunk.\n Default is disable if the destination is a logical\n port local to the system.\n",
    },
    {
        .name  = TRUNK_SYSTEM_IDs,  /* TRUNK_SYSTEM_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination system trunk ID. Applicable only if\n IS_TRUNK_SYSTEM is enabled.\n Index into the TRUNK_SYSTEM table.\n",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination logical Port ID. Applicable only if\n IS_TRUNK_SYSTEM is disabled.\n",
    },
    {
        .name  = DLB_ID_VALIDs,  /* DLB_ID_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if dynamic load balancing(DLB)is used for\n system trunk resolution. Applicable only if\n IS_TRUNK_SYSTEM is enabled.\n",
    },
    {
        .name  = DLB_IDs,  /* DLB_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Dynamic load balancing(DLB) identifier used for system trunk\n resolution. Applicable only if DLB_ID_VALID is enabled.\n",
    },
    {
        .name  = FLEX_CTR_ACTION_IDs,  /* FLEX_CTR_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Attach the flex counter action to\n destination system port.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_destination_t = {
    .name = PORT_SYSTEM_DESTINATIONs, /* PORT_SYSTEM_DESTINATION */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_port_system_destination_t_fields,
    .desc = "PORT_SYSTEM_DESTINATION table is used to specify the system port\n destination resolution. System port is resolved into logical port\n ID or a system trunk ID.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_FP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_fp_profile_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port system profile ID.",
    },
    {
        .name  = FP_VLANs,  /* FP_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable VLAN FP.",
    },
    {
        .name  = FP_INGs,  /* FP_ING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable Ingress FP.",
    },
    {
        .name  = USE_TABLE_FP_VLAN_PORT_GRPs,  /* USE_TABLE_FP_VLAN_PORT_GRP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use FP_VLAN_PORT_GRP from the logical table,\n otherwise use FP_VLAN_PORT_GRP from the PORT_SYSTEM logical table.\n",
    },
    {
        .name  = FP_VLAN_PORT_GRPs,  /* FP_VLAN_PORT_GRP */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "VLAN FP key port group.",
    },
    {
        .name  = FP_ING_GRP_SEL_CLASS_IDs,  /* FP_ING_GRP_SEL_CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress FP group selection class ID.",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_fp_profile_t = {
    .name = PORT_SYSTEM_FP_PROFILEs, /* PORT_SYSTEM_FP_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_port_system_fp_profile_t_fields,
    .desc = "The PORT_SYSTEM_FP_PROFILE table specifies the system port level\n field processor functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_ING_MIRROR_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_ing_mirror_profile_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port system profile ID.",
    },
    {
        .name  = MIRROR_CONTAINER_IDs,  /* MIRROR_CONTAINER_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Mirror container ID.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mirror.",
    },
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MIRROR_INSTANCE table index.",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_ing_mirror_profile_t = {
    .name = PORT_SYSTEM_ING_MIRROR_PROFILEs, /* PORT_SYSTEM_ING_MIRROR_PROFILE */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_port_system_ing_mirror_profile_t_fields,
    .desc = "The PORT_SYSTEM_ING_MIRROR_PROFILE logical table is used to enable or\n disable ingress mirroring on the system port and mirror container.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_LEARN_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_learn_profile_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port system profile ID.",
    },
    {
        .name  = MAC_LEARNs,  /* MAC_LEARN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MAC address learning.",
    },
    {
        .name  = MAC_COPY_TO_CPUs,  /* MAC_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copying to CPU for packets with unknown source MAC address.",
    },
    {
        .name  = MAC_LEARN_AS_PENDINGs,  /* MAC_LEARN_AS_PENDING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable learning new MAC addresses as pending.",
    },
    {
        .name  = MAC_DROPs,  /* MAC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping packets with unknown source MAC address.",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_learn_profile_t = {
    .name = PORT_SYSTEM_LEARN_PROFILEs, /* PORT_SYSTEM_LEARN_PROFILE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_port_system_learn_profile_t_fields,
    .desc = "The PORT_SYSTEM_LEARN_PROFILE table specifies the system port level\n MAC address learning functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_MEMBERSHIP_POLICY_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_membership_policy_profile_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port system profile ID.",
    },
    {
        .name  = ING_VLAN_MEMBERSHIP_CHECKs,  /* ING_VLAN_MEMBERSHIP_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping packets that are not a member of the port's ingress VLAN.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable skipping VLAN membership checks.",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_membership_policy_profile_t = {
    .name = PORT_SYSTEM_MEMBERSHIP_POLICY_PROFILEs, /* PORT_SYSTEM_MEMBERSHIP_POLICY_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_port_system_membership_policy_profile_t_fields,
    .desc = "The PORT_SYSTEM_MEMBERSHIP_POLICY_PROFILE table specifies\n VLAN membership check attributes for a system port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_PHB_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_phb_profile_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port system profile ID.",
    },
    {
        .name  = TRUST_PHB_ING_DSCP_V4s,  /* TRUST_PHB_ING_DSCP_V4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust incoming IPv4 DSCP and map to PHB.",
    },
    {
        .name  = TRUST_PHB_ING_DSCP_V6s,  /* TRUST_PHB_ING_DSCP_V6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust incoming IPv6 DSCP and map to PHB.",
    },
    {
        .name  = PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs,  /* PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_IP_DSCP_TO_INT_PRI_REMAP logical table index.\n Applicable only if TRUST_PHB_ING_DSCP_V4 is enabled for IPv4 packets\n and TRUST_PHB_ING_DSCP_V6 is enabled for IPv6 packets.\n",
    },
    {
        .name  = TRUST_PHB_ING_L2_ITAGs,  /* TRUST_PHB_ING_L2_ITAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust incoming inner vlan tag and map the inner VLAN tag's\n 802.1p/CFI bits to PHB.\n",
    },
    {
        .name  = PHB_ING_L2_IDs,  /* PHB_ING_L2_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_L2_TAGGED_TO_INT_PRI logical table index or\n PHB_ING_L2_UNTAGGED_TO_INT_PRI logical table index depending on\n whether the packet is tagged or untagged.\n",
    },
    {
        .name  = PHB_ING_L2_OTAG_REMAP_IDs,  /* PHB_ING_L2_OTAG_REMAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_L2_OTAG_REMAP logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_phb_profile_t = {
    .name = PORT_SYSTEM_PHB_PROFILEs, /* PORT_SYSTEM_PHB_PROFILE */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_port_system_phb_profile_t_fields,
    .desc = "The PORT_SYSTEM_PHB_PROFILE table specifies a system port per-hop behavior.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_POLICY_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_policy_profile_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port system profile ID.",
    },
    {
        .name  = TRUST_INCOMING_VIDs,  /* TRUST_INCOMING_VID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable trusting incoming VLAN tag.",
    },
    {
        .name  = DROP_ON_PRIs,  /* DROP_ON_PRI */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Drop packet with the given priority.\n Array is indexed by 802.1p priority.\n",
    },
    {
        .name  = DROP_UNTAGs,  /* DROP_UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping untagged packets.",
    },
    {
        .name  = DROP_TAGs,  /* DROP_TAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping tagged packets.",
    },
    {
        .name  = PASS_PAUSE_FRAMESs,  /* PASS_PAUSE_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable passing pause frames.",
    },
    {
        .name  = OUTER_TPID_VERIFYs,  /* OUTER_TPID_VERIFY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable matching of packet TPID idx against configured VLAN.VLAN_OUTER_TPID_ID\n and drop on mismatch.\n",
    },
    {
        .name  = PASS_ON_OUTER_TPID_MATCHs,  /* PASS_ON_OUTER_TPID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable matching of packet TPID against the VLAN_OUTER_TPID logical table.\n Array is indexed by VLAN_OUTER_TPID_ID.\n",
    },
    {
        .name  = MAC_IP_BIND_LOOKUP_MISS_DROPs,  /* MAC_IP_BIND_LOOKUP_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable HPAE (Host Posture Assessment and Enforcement) checking.",
    },
    {
        .name  = DROP_BPDUs,  /* DROP_BPDU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping BPDU packets.",
    },
    {
        .name  = ING_CFI_AS_CNGs,  /* ING_CFI_AS_CNG */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "If enabled, ingress CFI carries QoS (drop precedence) information per TPID.\n Array is indexed by VLAN_OUTER_TPID_ID.\n",
    },
    {
        .name  = TNL_L2_PAYLOAD_OUTER_TPID_MATCHs,  /* TNL_L2_PAYLOAD_OUTER_TPID_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable matching of tunnel L2 payload outer TPID against\n the TNL_L2_PAYLOAD_OUTER_TPID logical table on ingress pipe.\n Array is indexed by VLAN_PAYLOAD_OUTER_TPID_ID.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_policy_profile_t = {
    .name = PORT_SYSTEM_POLICY_PROFILEs, /* PORT_SYSTEM_POLICY_PROFILE */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_port_system_policy_profile_t_fields,
    .desc = "The PORT_SYSTEM_POLICY_PROFILE table specifies policy attributes for a system port.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_profile_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port system profile ID.",
    },
    {
        .name  = MY_MODIDs,  /* MY_MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Module ID.",
    },
    {
        .name  = PORT_TYPEs,  /* PORT_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Port type.",
    },
    {
        .name  = V6L3s,  /* V6L3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv6 unicast packets.",
    },
    {
        .name  = V6IPMCs,  /* V6IPMC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv6 multicast packets.",
    },
    {
        .name  = V4L3s,  /* V4L3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv4 unicast packets.",
    },
    {
        .name  = V4IPMCs,  /* V4IPMC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv4 multicast packets.",
    },
    {
        .name  = OPERATING_MODEs,  /* OPERATING_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Operating mode of the port.",
    },
    {
        .name  = URPF_MODEs,  /* URPF_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Unicast RPF mode.",
    },
    {
        .name  = URPF_DEFAULT_ROUTE_CHECKs,  /* URPF_DEFAULT_ROUTE_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable unicast RPF check on default routes.",
    },
    {
        .name  = PORT_PKT_CONTROL_IDs,  /* PORT_PKT_CONTROL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PORT_PKT_CONTROL logical table index.",
    },
    {
        .name  = MPLSs,  /* MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS.",
    },
    {
        .name  = IPMC_USE_L3_IIFs,  /* IPMC_USE_L3_IIF */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable using L3_IIF as part of IP multicast search key.",
    },
    {
        .name  = IEEE_802_1ASs,  /* IEEE_802_1AS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable times-sync.",
    },
    {
        .name  = USE_IVID_AS_OVIDs,  /* USE_IVID_AS_OVID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable using inner VLAN ID as outer VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = ING_OVIDs,  /* ING_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Ingress outer VLAN ID.",
    },
    {
        .name  = ING_OPRIs,  /* ING_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Ingress outer DOT1P priority.",
    },
    {
        .name  = ING_OCFIs,  /* ING_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Ingress outer CFI.",
    },
    {
        .name  = ING_IVIDs,  /* ING_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Ingress inner VLAN ID.",
    },
    {
        .name  = ING_IPRIs,  /* ING_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Ingress inner DOT1P priority.",
    },
    {
        .name  = ING_ICFIs,  /* ING_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Ingress inner CFI.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter ingress pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = CTR_EGR_FLEX_POOL_NUMBERs,  /* CTR_EGR_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter egress pool number.",
    },
    {
        .name  = CTR_EGR_FLEX_BASE_INDEXs,  /* CTR_EGR_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_EGR_FLEX_OFFSET_MODEs,  /* CTR_EGR_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = PRESERVE_CPU_TAGs,  /* PRESERVE_CPU_TAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable tag preservation for packets going to the CPU.",
    },
    {
        .name  = CNTAG_DELETE_ON_PRI_MATCHs,  /* CNTAG_DELETE_ON_PRI_MATCH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "A bitmap where the bit position corresponds to\n the packet's 802.1p priority value.\n If a bit is set, packets with\n that 802.1P value will have their CNTAG deleted.\n",
    },
    {
        .name  = VLAN_ASSIGNMENT_BASED_IPV4s,  /* VLAN_ASSIGNMENT_BASED_IPV4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 subnet-based VLAN assignment.",
    },
    {
        .name  = VLAN_ASSIGNMENT_BASED_MACs,  /* VLAN_ASSIGNMENT_BASED_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MAC-based VLAN assignment.",
    },
    {
        .name  = VLAN_ASSIGNMENT_PROTOCOL_IDs,  /* VLAN_ASSIGNMENT_PROTOCOL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ASSIGNMENT_PROTOCOL logical table index.",
    },
    {
        .name  = VLAN_PRECEDENCEs,  /* VLAN_PRECEDENCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IPv4 subnet-based VLAN assignment to have\n higher priority than mac-based VLAN assignment.\n",
    },
    {
        .name  = INBAND_TELEMETRY_IFAs,  /* INBAND_TELEMETRY_IFA */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable Inband Flow Analyzer (IFA).",
    },
    {
        .name  = INBAND_TELEMETRY_IOAMs,  /* INBAND_TELEMETRY_IOAM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable In-situ Operations, Administration, and\n Maintenance (IOAM).\n",
    },
    {
        .name  = INBAND_TELEMETRY_DATAPLANEs,  /* INBAND_TELEMETRY_DATAPLANE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable In-band Network Telemetry Data-plane Probe (INT-DP).",
    },
    {
        .name  = INPORT_BITMAP_INDEXs,  /* INPORT_BITMAP_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Port bitmap index to generate Input Port Bitmap field of the IFP.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter action.",
    },
    {
        .name  = NTP_TCs,  /* NTP_TC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable NTP transparent clock editing",
    },
    {
        .name  = DEVICE_TS_PTP_MSG_CONTROL_PROFILE_IDs,  /* DEVICE_TS_PTP_MSG_CONTROL_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "DEVICE_TS_PTP_MSG_CONTROL_PROFILE logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_profile_t = {
    .name = PORT_SYSTEM_PROFILEs, /* PORT_SYSTEM_PROFILE */
    .flags = 0,
    .fields = 42,
    .field = bcmltd_port_system_profile_t_fields,
    .desc = "The PORT_SYSTEM_PROFILE table specifies the system level basic port properties\n and functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_PVLAN_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_pvlan_profile_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port system profile ID.",
    },
    {
        .name  = ING_PVLANs,  /* ING_PVLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ingress private VLAN.",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_pvlan_profile_t = {
    .name = PORT_SYSTEM_PVLAN_PROFILEs, /* PORT_SYSTEM_PVLAN_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_port_system_pvlan_profile_t_fields,
    .desc = "The PORT_SYSTEM_PVLAN_PROFILE table specifies private VLAN properties\n for a system port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_TM_MIRROR_ON_DROP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_tm_mirror_on_drop_profile_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port system profile ID.",
    },
    {
        .name  = MIRROR_ON_DROPs,  /* MIRROR_ON_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to do TM mirror on drop.",
    },
    {
        .name  = TM_MIRROR_ON_DROP_PROFILE_IDs,  /* TM_MIRROR_ON_DROP_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the TM_MIRROR_ON_DROP_PROFILE table.",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_tm_mirror_on_drop_profile_t = {
    .name = PORT_SYSTEM_TM_MIRROR_ON_DROP_PROFILEs, /* PORT_SYSTEM_TM_MIRROR_ON_DROP_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_port_system_tm_mirror_on_drop_profile_t_fields,
    .desc = "The PORT_SYSTEM_TM_MIRROR_ON_DROP_PROFILE table specifies system port\n level attributes for mirroring of packets dropped by the traffic\n manager(TM).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_SYSTEM_VLAN_XLATE_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_system_vlan_xlate_profile_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = PORT_SYSTEM_PROFILE_IDs,  /* PORT_SYSTEM_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port system profile ID.",
    },
    {
        .name  = ING_XLATEs,  /* ING_XLATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ingress VLAN translation.",
    },
    {
        .name  = ING_XLATE_TBL_SEL_FIRST_LOOKUPs,  /* ING_XLATE_TBL_SEL_FIRST_LOOKUP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table selection for first lookup of ingress VLAN translation.",
    },
    {
        .name  = ING_XLATE_TBL_SEL_SECOND_LOOKUPs,  /* ING_XLATE_TBL_SEL_SECOND_LOOKUP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table selection for second lookup of ingress VLAN translation.",
    },
    {
        .name  = ING_MISS_ACTIONs,  /* ING_MISS_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Action to be taken on ingress VLAN translation lookup miss.",
    },
    {
        .name  = OPRI_MAPPEDs,  /* OPRI_MAPPED */
        .flags = 0,
        .width = 3,
        .depth = 8,
        .desc = "Mapping of packet's outer 802.1p priority value\n to the VLAN translation lookup outer priority value.\n",
    },
    {
        .name  = OCFI_MAPPEDs,  /* OCFI_MAPPED */
        .flags = 0,
        .width = 1,
        .depth = 2,
        .desc = "Mapping of packet's outer VLAN CFI value\n to the VLAN translation lookup outer VLAN CFI value.\n",
    },
    {
        .name  = IPRI_MAPPEDs,  /* IPRI_MAPPED */
        .flags = 0,
        .width = 3,
        .depth = 8,
        .desc = "Mapping of packet's inner 802.1p priority value\n to the VLAN translation lookup inner priority value.\n",
    },
    {
        .name  = ICFI_MAPPEDs,  /* ICFI_MAPPED */
        .flags = 0,
        .width = 1,
        .depth = 2,
        .desc = "Mapping of packet's inner VLAN CFI value\n to the VLAN translation lookup inner VLAN CFI value.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_system_vlan_xlate_profile_t = {
    .name = PORT_SYSTEM_VLAN_XLATE_PROFILEs, /* PORT_SYSTEM_VLAN_XLATE_PROFILE */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_port_system_vlan_xlate_profile_t_fields,
    .desc = "The PORT_SYSTEM_VLAN_XLATE_PROFILE table specifies the system port level\n VLAN translation functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_TM_MIRROR_ON_DROP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_tm_mirror_on_drop_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = MIRROR_ON_DROPs,  /* MIRROR_ON_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable TM mirror on drop.",
    },
    {
        .name  = TM_MIRROR_ON_DROP_PROFILE_IDs,  /* TM_MIRROR_ON_DROP_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the TM_MIRROR_ON_DROP_PROFILE table.",
    },
};
const bcmltd_table_rep_t bcmltd_port_tm_mirror_on_drop_t = {
    .name = PORT_TM_MIRROR_ON_DROPs, /* PORT_TM_MIRROR_ON_DROP */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_port_tm_mirror_on_drop_t_fields,
    .desc = "The PORT_TM_MIRROR_ON_DROP table specifies port level attributes for\n mirroring of packets dropped by the traffic manager(TM).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_trunk_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = TRUNK_SYSTEM_FAILOVERs,  /* TRUNK_SYSTEM_FAILOVER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable failover for the logical port when the\n port is the member of a system trunk group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_trunk_t = {
    .name = PORT_TRUNKs, /* PORT_TRUNK */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_port_trunk_t_fields,
    .desc = "The PORT_TRUNK table specifies the port level\n trunk and system trunk controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/port/PORT_VLAN_XLATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_port_vlan_xlate_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Port ID.",
    },
    {
        .name  = ING_XLATEs,  /* ING_XLATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ingress VLAN translation.",
    },
    {
        .name  = EGR_XLATEs,  /* EGR_XLATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable egress VLAN translation.",
    },
    {
        .name  = ING_XLATE_TBL_SEL_FIRST_LOOKUPs,  /* ING_XLATE_TBL_SEL_FIRST_LOOKUP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table selection for first lookup of ingress VLAN translation.",
    },
    {
        .name  = ING_XLATE_TBL_SEL_SECOND_LOOKUPs,  /* ING_XLATE_TBL_SEL_SECOND_LOOKUP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table selection for second lookup of ingress VLAN translation.",
    },
    {
        .name  = ING_MISS_ACTIONs,  /* ING_MISS_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Action to be taken on ingress VLAN translation lookup miss.",
    },
    {
        .name  = EGR_XLATE_MISS_DROPs,  /* EGR_XLATE_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable packet drop if egress VLAN translation lookup\n results in a miss for a tagged packet.\n",
    },
    {
        .name  = EGR_XLATE_MISS_UT_DROPs,  /* EGR_XLATE_MISS_UT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable packet drop if egress VLAN translation lookup\n results in a miss for an untagged packet.\n",
    },
    {
        .name  = EGR_XLATE_MISS_UNTAGs,  /* EGR_XLATE_MISS_UNTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable forcing packet to be untagged if\n egress VLAN translation lookup results in a miss.\n",
    },
    {
        .name  = PORT_GRPs,  /* PORT_GRP */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "Egress VLAN translation key port group.",
    },
    {
        .name  = OPRI_MAPPEDs,  /* OPRI_MAPPED */
        .flags = 0,
        .width = 3,
        .depth = 8,
        .desc = "Mapping of packet's outer 802.1p priority value\n to the VLAN translation lookup outer priority value.\n",
    },
    {
        .name  = OCFI_MAPPEDs,  /* OCFI_MAPPED */
        .flags = 0,
        .width = 1,
        .depth = 2,
        .desc = "Mapping of packet's outer VLAN CFI value\n to the VLAN translation lookup outer VLAN CFI value.\n",
    },
    {
        .name  = IPRI_MAPPEDs,  /* IPRI_MAPPED */
        .flags = 0,
        .width = 3,
        .depth = 8,
        .desc = "Mapping of packet's inner 802.1p priority value\n to the VLAN translation lookup inner priority value.\n",
    },
    {
        .name  = ICFI_MAPPEDs,  /* ICFI_MAPPED */
        .flags = 0,
        .width = 1,
        .depth = 2,
        .desc = "Mapping of packet's inner VLAN CFI value\n to the VLAN translation lookup inner VLAN CFI value.\n",
    },
};
const bcmltd_table_rep_t bcmltd_port_vlan_xlate_t = {
    .name = PORT_VLAN_XLATEs, /* PORT_VLAN_XLATE */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_port_vlan_xlate_t_fields,
    .desc = "The PORT_VLAN_XLATE table specifies the port level\n VLAN translation functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_BLOCK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_block_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = NUM_SA_PER_SC_ENCRYPTs,  /* NUM_SA_PER_SC_ENCRYPT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Number of security associations per encrypt secure channel.\n Applicable only for MACsec.\n",
    },
    {
        .name  = NUM_SA_PER_SC_DECRYPTs,  /* NUM_SA_PER_SC_DECRYPT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Number of security associations per decrypt secure channel.\n Applicable only for MACsec.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_block_t = {
    .name = SEC_BLOCKs, /* SEC_BLOCK */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_sec_block_t_fields,
    .desc = "The SEC_BLOCK table specifies the block level SEC\n configuration. It is recommended to configure this table prior to\n configuring secure channel (SC) or security association (SA).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SECTAG_C_E_ERRORs,  /* SECTAG_C_E_ERROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to treat a packet with SecTAG.TCI.C=1 and\n SecTAG.TCI.E=0 as an error packet.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = IGNORE_EOP_ERRORSs,  /* IGNORE_EOP_ERRORS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to ignore end of packet (EOP) errors which is also\n marked for copy to CPU. EOP errors include ICV failure and\n MTU check failure. Useful in cases where the traffic manager\n may drop packets destined to CPU marked with EOP error.\n",
    },
    {
        .name  = UNKNOWN_SUB_PORT_DROPs,  /* UNKNOWN_SUB_PORT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets due to unknown SEC sub-port.\n It indicates a miss in the SEC_DECRYPT_SUBPORT_FLOW table.\n",
    },
    {
        .name  = INVALID_SECURED_CONTROL_PORT_DROPs,  /* INVALID_SECURED_CONTROL_PORT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop secured control port packet when\n SEC_DECRYPT_SUBPORT_POLICY.SECURED_CONTROL_PORT == FALSE.\n",
    },
    {
        .name  = INVALID_UNSECURED_CONTROL_PORT_DROPs,  /* INVALID_UNSECURED_CONTROL_PORT_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop unsecured control port packet received when\n SEC_DECRYPT_SUBPORT_POLICY.UNSECURED_DATA_MODE == DROP or\n SEC_DECRYPT_SUBPORT_POLICY.UNSECURED_DATA_MODE ==\n DROP_AND_ACCOUNT.\n",
    },
    {
        .name  = IPV4_CKSUM_MPLS_BOS_DROPs,  /* IPV4_CKSUM_MPLS_BOS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IPv4 checksum failed packet or\n when MPLS BOS is not found within 4 labels.\n",
    },
    {
        .name  = INVALID_SECTAG_DROPs,  /* INVALID_SECTAG_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop invalid SecTAG packets.",
    },
    {
        .name  = UNKNOWN_SC_DROPs,  /* UNKNOWN_SC_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets with unknown secure channel\n indicating a miss in the SEC_DECRYPT_MACSEC_SC table.\n Applicable only when either\n SEC_DECRYPT_SUBPORT_POLICY.TAG_VALIDATE == STRICT or\n C bit in SecTAG is set.\n",
    },
    {
        .name  = UNKNOWN_SA_DROPs,  /* UNKNOWN_SA_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets with unknown security association\n or an expired security association.\n Applicable only when either\n SEC_DECRYPT_SUBPORT_POLICY.TAG_VALIDATE == STRICT or\n C bit in SecTAG is set.\n",
    },
    {
        .name  = REPLAY_PROTECTION_FAILED_DROPs,  /* REPLAY_PROTECTION_FAILED_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop replay protection failed packets.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default SEC_DECRYPT_SUBPORT_POLICY table index when\n a lookup in the SEC_DECRYPT_SUBPORT_FLOW table results in a miss.\n",
    },
    {
        .name  = INVALIDATE_SAs,  /* INVALIDATE_SA */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to invalidate the decrypt security association (SA)\n when the packet number reaches maximum.\n Default behavior of SA is to remain valid with\n SEC_ENCRYPT_MACSEC_SA_POLICY.NEXT_PKT_NUMBER or\n SEC_ENCRYPT_IPSEC_SA_POLICY.NEXT_PKT_NUMBER\n pegged at maximum.\n Applicable only if SEC_DECRYPT_MACSEC_SC_POLICY.REPLAY_PROTECT\n is enabled for the SA.\n",
    },
    {
        .name  = USE_TYPE_LENGTH_LLC_SNAPs,  /* USE_TYPE_LENGTH_LLC_SNAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use type/length field for fixed parser LLC\n and SNAP packets. Default is to use {DSAP, SSAP}.\n",
    },
    {
        .name  = PN_EXPIRE_THDs,  /* PN_EXPIRE_THD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Threshold for triggering soft packet number expiry.\n The SEC_ENCRYPT_MACSEC_SA_POLICY_STATUS or\n SEC_ENCRYPT_IPSEC_SA_POLICY_STATUS table reflects the\n state of the expiry.\n Applicable only when one of the following is true:\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE == CIPHER_GCM_AES_128\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE == CIPHER_GCM_AES_256\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE == CIPHER_GCM_AES_128\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE == CIPHER_GCM_AES_256\n",
    },
    {
        .name  = XPN_EXPIRE_THDs,  /* XPN_EXPIRE_THD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Threshold for triggering soft extended packet number expiry.\n The SEC_ENCRYPT_MACSEC_SA_POLICY_STATUS or\n SEC_ENCRYPT_IPSEC_SA_POLICY_STATUS table reflects the\n state of the expiry.\n Applicable only when one of the following is true:\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_t = {
    .name = SEC_DECRYPTs, /* SEC_DECRYPT */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_sec_decrypt_t_fields,
    .desc = "The SEC_DECRYPT table specifies the\n SEC controls for packets in the decrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_IPSEC_SA_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_ipsec_sa_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_DECRYPT_IPSEC_SA_POLICY_IDs,  /* SEC_DECRYPT_IPSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the decrypt security association.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SA_STATE_CONTROL_T_DATA,
        .desc = "Security association state.",
    },
    {
        .name  = INITIAL_PKT_NUMBERs,  /* INITIAL_PKT_NUMBER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Packet sequence number. The upper 32-bits are\n applicable only when one of the following is true:\n SEC_DECRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_DECRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = XPN_SALTs,  /* XPN_SALT */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "The XPN salt parameter for IPsec.\n Applicable only when one of the following is true:\n SEC_DECRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_DECRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = KEYs,  /* KEY */
        .flags = 0,
        .width = 8,
        .depth = 32,
        .desc = "Decryption key. The upper 16 bytes are\n applicable only when one of the following is true:\n SEC_DECRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_DECRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = NEXT_PKT_NUMBERs,  /* NEXT_PKT_NUMBER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Read-only field indicating the next packet number inserted\n in the SecTag.\n",
    },
    {
        .name  = IN_USEs,  /* IN_USE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Read-only field indicating that the SA is in use.",
    },
    {
        .name  = IN_USE_START_TIMEs,  /* IN_USE_START_TIME */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field indicating the system time when\n the SA started receiving IPsec frames.\n",
    },
    {
        .name  = IN_USE_STOP_TIMEs,  /* IN_USE_STOP_TIME */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field indicating the system time when\n the SA stopped receiving IPsec frames.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_ipsec_sa_policy_t = {
    .name = SEC_DECRYPT_IPSEC_SA_POLICYs, /* SEC_DECRYPT_IPSEC_SA_POLICY */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_sec_decrypt_ipsec_sa_policy_t_fields,
    .desc = "The SEC_DECRYPT_IPSEC_SA_POLICY table provisions an IPsec\n security association in the decrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_IPSEC_SA_POLICY_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_ipsec_sa_policy_status_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_DECRYPT_IPSEC_SA_POLICY_IDs,  /* SEC_DECRYPT_IPSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_IPSEC_SA_POLICY table index.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SA_STATE_T_DATA,
        .desc = "Security association state.",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_ipsec_sa_policy_status_t = {
    .name = SEC_DECRYPT_IPSEC_SA_POLICY_STATUSs, /* SEC_DECRYPT_IPSEC_SA_POLICY_STATUS */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_sec_decrypt_ipsec_sa_policy_status_t_fields,
    .desc = "The SEC_DECRYPT_IPSEC_SA_POLICY_STATUS table provides the\n status of the security association in the decrypt direction.\n Application can subscribe to the table to get status change\n notification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_IPSEC_SC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_ipsec_sc_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index is used to match\n a packet's derived subport.\n",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_ID_MASKs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for SEC_DECRYPT_SUBPORT_POLICY_ID.",
    },
    {
        .name  = SP_IDENTIFIERs,  /* SP_IDENTIFIER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Secure parameter identifier used to match with the\n value in the ESP header.\n",
    },
    {
        .name  = SP_IDENTIFIER_MASKs,  /* SP_IDENTIFIER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for SP_IDENTIFIER.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_IPSEC_SC_POLICY_IDs,  /* SEC_DECRYPT_IPSEC_SC_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_IPSEC_SC_POLICY table index points to the\n secure channel (SC) policy table index. Applicable when a\n match is successful.\n",
    },
    {
        .name  = IPSEC_ANs,  /* IPSEC_AN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The IPsec association number. This value determines the\n active security association using the formula\n IPSec SA = {SEC_DECRYPT_IPSEC_SC_POLICY_ID, IPSEC_AN}\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_ipsec_sc_t = {
    .name = SEC_DECRYPT_IPSEC_SCs, /* SEC_DECRYPT_IPSEC_SC */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 9,
    .field = bcmltd_sec_decrypt_ipsec_sc_t_fields,
    .desc = "The SEC_DECRYPT_IPSEC_SC match table is used to identify a\n secure channel index based on packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_IPSEC_SC_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_ipsec_sc_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Security block table index.",
    },
    {
        .name  = SEC_DECRYPT_IPSEC_SC_POLICY_IDs,  /* SEC_DECRYPT_IPSEC_SC_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the decrypt secure channel.",
    },
    {
        .name  = SA_EXPIRY_DISABLEs,  /* SA_EXPIRY_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to turn off soft and hard SA expiry for the SA.\n",
    },
    {
        .name  = VXLAN_HEADER_UPDATEs,  /* VXLAN_HEADER_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_VXLAN_HEADER_UPDATE_T_DATA,
        .desc = "",
    },
    {
        .name  = DUPLICATE_REJECTs,  /* DUPLICATE_REJECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to reject ESP header enabled duplicate packets\n within 128 packet number sliding window for all\n secure associations belonging to the secure channel.\n Applicable only if REPLAY_PROTECT is enabled and\n REPLAY_PROTECT_WINDOW >= 128.\n",
    },
    {
        .name  = REPLAY_PROTECTs,  /* REPLAY_PROTECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable replay-protect for the secure channel.\n",
    },
    {
        .name  = REPLAY_PROTECT_WINDOWs,  /* REPLAY_PROTECT_WINDOW */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The replay protect window size. A value of 0 implies\n strict replay check.\n Applicable only if REPLAY_PROTECT is enabled;\n",
    },
    {
        .name  = ESP_ICV_MODEs,  /* ESP_ICV_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SEC_HEADER_ICV_MODE_T_DATA,
        .desc = "Mode used to strip off parts of IPsec encapsulation\n after packets have been permitted.\n",
    },
    {
        .name  = CIPHER_SUITEs,  /* CIPHER_SUITE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CIPHER_SUITE_T_DATA,
        .desc = "Decryption standard to use for the channel.",
    },
    {
        .name  = GMAC_MODEs,  /* GMAC_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to specify authentication only mode\n (GMAC mode - RFC4543).\n Disable to specify authentication and decryption in GCM mode.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_ipsec_sc_policy_t = {
    .name = SEC_DECRYPT_IPSEC_SC_POLICYs, /* SEC_DECRYPT_IPSEC_SC_POLICY */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_sec_decrypt_ipsec_sc_policy_t_fields,
    .desc = "The SEC_DECRYPT_IPSEC_SC_POLICY table provisions an IPsec\n security channel in the decrypt direction.\n Each security channel configuration applies to an IPsec\n security association.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_MACSEC_SA_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_macsec_sa_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_DECRYPT_MACSEC_SA_POLICY_IDs,  /* SEC_DECRYPT_MACSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the decrypt security association.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SA_STATE_CONTROL_T_DATA,
        .desc = "Security association state.",
    },
    {
        .name  = INITIAL_PKT_NUMBERs,  /* INITIAL_PKT_NUMBER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Packet sequence number. The upper 32-bits are\n applicable only when one of the following is true:\n SEC_DECRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_DECRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = SHORT_SC_IDENTIFIERs,  /* SHORT_SC_IDENTIFIER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Short secure channel identifier (SSCI) for an XPN cipher.\n SSCI is unique for each secure channel.\n Applicable only when one of the following is true:\n SEC_DECRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_DECRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = XPN_SALTs,  /* XPN_SALT */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "The XPN salt parameter for MACsec.\n Applicable only when one of the following is true:\n SEC_DECRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_DECRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = KEYs,  /* KEY */
        .flags = 0,
        .width = 8,
        .depth = 32,
        .desc = "Decryption key. The upper 16 bytes are\n applicable only when one of the following is true:\n SEC_DECRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_DECRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = NEXT_PKT_NUMBERs,  /* NEXT_PKT_NUMBER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Read-only field indicating the next packet number inserted\n in the SecTag.\n",
    },
    {
        .name  = IN_USEs,  /* IN_USE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Read only field indicating that the SA is in use.",
    },
    {
        .name  = IN_USE_START_TIMEs,  /* IN_USE_START_TIME */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read only field indicating the system time when\n the SA started receiving MACsec frames.\n",
    },
    {
        .name  = IN_USE_STOP_TIMEs,  /* IN_USE_STOP_TIME */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read only field indicating the system time when\n the SA stopped receiving MACsec frames.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_macsec_sa_policy_t = {
    .name = SEC_DECRYPT_MACSEC_SA_POLICYs, /* SEC_DECRYPT_MACSEC_SA_POLICY */
    .flags = 0,
    .fields = 11,
    .field = bcmltd_sec_decrypt_macsec_sa_policy_t_fields,
    .desc = "The SEC_DECRYPT_MACSEC_SA_POLICY table provisions a MACsec\n security association in the decrypt direction.\n The security association is a combination of\n secure channel index and association number.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_MACSEC_SA_POLICY_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_macsec_sa_policy_status_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_DECRYPT_MACSEC_SA_POLICY_IDs,  /* SEC_DECRYPT_MACSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_MACSEC_SA_POLICY table index.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SA_STATE_T_DATA,
        .desc = "Security association state.",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_macsec_sa_policy_status_t = {
    .name = SEC_DECRYPT_MACSEC_SA_POLICY_STATUSs, /* SEC_DECRYPT_MACSEC_SA_POLICY_STATUS */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_sec_decrypt_macsec_sa_policy_status_t_fields,
    .desc = "The SEC_DECRYPT_MACSEC_SA_POLICY_STATUS table\n provides the status of the security association in the decrypt direction.\n Application can subscribe to the table to get status change notification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_MACSEC_SC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_macsec_sc_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index is used to match\n a packet's derived subport.\n",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_ID_MASKs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for SEC_DECRYPT_SUBPORT_POLICY_ID.",
    },
    {
        .name  = SC_IDENTIFIERs,  /* SC_IDENTIFIER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Secure channel identifier present in the SecTAG.",
    },
    {
        .name  = SC_IDENTIFIER_MASKs,  /* SC_IDENTIFIER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for SC_IDENTIFIER.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_MACSEC_SC_POLICY_IDs,  /* SEC_DECRYPT_MACSEC_SC_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_MACSEC_SC_POLICY table index points to the\n secure channel (SC) policy table index. Applicable when a\n match is successful.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_macsec_sc_t = {
    .name = SEC_DECRYPT_MACSEC_SCs, /* SEC_DECRYPT_MACSEC_SC */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 8,
    .field = bcmltd_sec_decrypt_macsec_sc_t_fields,
    .desc = "The SEC_DECRYPT_MACSEC_SC match table is used to identify a\n secure channel index based on packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_MACSEC_SC_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_macsec_sc_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Security block table index.",
    },
    {
        .name  = SEC_DECRYPT_MACSEC_SC_POLICY_IDs,  /* SEC_DECRYPT_MACSEC_SC_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the decrypt secure channel.",
    },
    {
        .name  = MPLS_RESET_BOSs,  /* MPLS_RESET_BOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to reset bottom of stack (BOS) bit in the last MPLS label\n present before SecTAG of a received packet whose SecTAG\n and ICV are both stripped.\n",
    },
    {
        .name  = SA_EXPIRY_DISABLEs,  /* SA_EXPIRY_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to turn off soft and hard SA expiry for the SA.\n",
    },
    {
        .name  = PRE_SECTAG_AUTH_START_ADJUST_FOR_PKTs,  /* PRE_SECTAG_AUTH_START_ADJUST_FOR_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to adjust the value of PRE_SECTAG_AUTH_START\n based on the number of VLAN tags or MPLS labels in the packet.\n Subject to restrictions described in PRE_SECTAG_AUTH_START.\n",
    },
    {
        .name  = PRE_SECTAG_AUTH_END_ADJUST_FOR_PKTs,  /* PRE_SECTAG_AUTH_END_ADJUST_FOR_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to adjust the value of PRE_SECTAG_AUTH_END\n based on the number of VLAN tags or MPLS labels in the packet.\n Subject to restrictions described in PRE_SECTAG_AUTH_END.\n",
    },
    {
        .name  = VXLAN_HEADER_UPDATEs,  /* VXLAN_HEADER_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_VXLAN_HEADER_UPDATE_T_DATA,
        .desc = "",
    },
    {
        .name  = DUPLICATE_REJECTs,  /* DUPLICATE_REJECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to reject SecTAG enabled duplicate packets\n within 128 packet number sliding window for all\n secure associations belonging to the secure channel.\n Applicable only if REPLAY_PROTECT is enabled and\n REPLAY_PROTECT_WINDOW >= 128.\n",
    },
    {
        .name  = REPLAY_PROTECTs,  /* REPLAY_PROTECT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable replay protection for the secure channel.",
    },
    {
        .name  = REPLAY_PROTECT_WINDOWs,  /* REPLAY_PROTECT_WINDOW */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The replay protect window size. A value of 0 implies\n strict replay check.\n Applicable only if REPLAY_PROTECT is enabled;\n",
    },
    {
        .name  = SECTAG_ICV_MODEs,  /* SECTAG_ICV_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SEC_HEADER_ICV_MODE_T_DATA,
        .desc = "Mode used to strip off parts of MACsec encapsulation\n after packets have been permitted.\n",
    },
    {
        .name  = CIPHER_SUITEs,  /* CIPHER_SUITE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CIPHER_SUITE_T_DATA,
        .desc = "Decryption standard to use for the channel.",
    },
    {
        .name  = PRE_SECTAG_AUTHs,  /* PRE_SECTAG_AUTH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to selectively authenticate bytes preceding the\n SecTAG. Default is to encrypt all bytes prior to SecTAG.\n",
    },
    {
        .name  = PRE_SECTAG_AUTH_STARTs,  /* PRE_SECTAG_AUTH_START */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Start byte for selective authentication.\n Applicable only if PRE_SECTAG_AUTH is enabled.\n The value should be less than the SecTAG offset.\n",
    },
    {
        .name  = PRE_SECTAG_AUTH_ENDs,  /* PRE_SECTAG_AUTH_END */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "End byte for selective authentication.\n Applicable only if PRE_SECTAG_AUTH is enabled.\n The following restrictions apply:\n The value should be less than the SecTAG offset and\n should be greater than PRE_SECTAG_AUTH_START.\n PRE_SECTAG_AUTH_START and PRE_SECTAG_AUTH_END\n may be configured to 0 to exclude all bytes before SecTAG from\n authentication.\n Invalid values may result in undefined hardware behavior.\n",
    },
    {
        .name  = CONFIDENTIALITY_OFFSET_BYTESs,  /* CONFIDENTIALITY_OFFSET_BYTES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of bytes from the start of SecTAG after which\n encryption starts.\n The following restriction applies:\n (SECTAG_OFFSET_BYTES + SecTAG length +\n CONFIDENTIALITY_OFFSET_BYTES)<= 192.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_macsec_sc_policy_t = {
    .name = SEC_DECRYPT_MACSEC_SC_POLICYs, /* SEC_DECRYPT_MACSEC_SC_POLICY */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_sec_decrypt_macsec_sc_policy_t_fields,
    .desc = "The SEC_DECRYPT_MACSEC_SC_POLICY table provisions a MACsec\n security channel in the decrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_MGMT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_mgmt_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 8,
        .desc = "Destination MAC addresses used to identify a management\n packet.\n Applicable only if SEC_DECRYPT_PORT.MGMT_DST_MAC is\n enabled for a logical port.\n",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 8,
        .desc = "Ethertype used to identify a management packet.\n Applicable only if SEC_DECRYPT_PORT.MGMT_ETHERTYPE is\n enabled for a logical port.\n",
    },
    {
        .name  = DST_MAC_RANGE_LOWs,  /* DST_MAC_RANGE_LOW */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address which is the lower limit in a range\n of MAC addresses used to identify a management packet.\n Applicable only if SEC_DECRYPT_PORT.MGMT_RANGE is\n enabled for a logical port.\n",
    },
    {
        .name  = DST_MAC_RANGE_HIGHs,  /* DST_MAC_RANGE_HIGH */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address which is the upper limit in a range\n of MAC addresses used to identify a management packet.\n Applicable only if SEC_DECRYPT_PORT.MGMT_RANGE is\n enabled for a logical port.\n",
    },
    {
        .name  = DST_MAC_GROUP_0s,  /* DST_MAC_GROUP_0 */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address in the first pair of destination MAC\n and ethertype used to identify a management packet.\n Used in conjunction with ETHERTYPE_GROUP_0.\n Applicable only if\n SEC_DECRYPT_PORT.MGMT_DST_MAC_AND_ETHERTYPE_0 is\n enabled for a logical port.\n",
    },
    {
        .name  = ETHERTYPE_GROUP_0s,  /* ETHERTYPE_GROUP_0 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype in the first pair of destination MAC\n and ethertype used to identify a management packet.\n Used along with DST_MAC_GROUP_0.\n Applicable only if\n SEC_DECRYPT_PORT.MGMT_DST_MAC_AND_ETHERTYPE_0 is\n enabled for a logical port.\n",
    },
    {
        .name  = DST_MAC_GROUP_1s,  /* DST_MAC_GROUP_1 */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address in the second pair of destination MAC\n and ethertype used to identify a management packet.\n Used along with ETHERTYPE_GROUP_1.\n Applicable only if\n SEC_DECRYPT_PORT.MGMT_DST_MAC_AND_ETHERTYPE_1 is\n enabled for a logical port.\n",
    },
    {
        .name  = ETHERTYPE_GROUP_1s,  /* ETHERTYPE_GROUP_1 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype in the second pair of destination MAC\n and ethertype used to identify a management packet.\n Used along with DST_MAC_GROUP_1.\n Applicable only if\n SEC_DECRYPT_PORT.MGMT_DST_MAC_AND_ETHERTYPE_1 is\n enabled for a logical port.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_mgmt_t = {
    .name = SEC_DECRYPT_MGMTs, /* SEC_DECRYPT_MGMT */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_sec_decrypt_mgmt_t_fields,
    .desc = "The SEC_DECRYPT_MGMT table specifies the\n parameters to identify a management packet.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID",
    },
    {
        .name  = SEC_MACSEC_SECTAG_ETHERTYPE_IDs,  /* SEC_MACSEC_SECTAG_ETHERTYPE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "SEC_MACSEC_SECTAG_ETHERTYPE table index.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SECTAG_VERSIONs,  /* SECTAG_VERSION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "SecTag version. Applicable only for MACsec packets.\n",
    },
    {
        .name  = SECTAG_VERSION_MISMATCHs,  /* SECTAG_VERSION_MISMATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check for SecTAG version mismatch.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SHORT_LENGTH_INVALIDs,  /* SHORT_LENGTH_INVALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check if SecTAG short length (SL)\n is greater than 47.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SHORT_LENGTH_NOT_SETs,  /* SHORT_LENGTH_NOT_SET */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check if SecTAG short length is not set and\n the packet length is less than 48.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SHORT_LENGTH_HIGHs,  /* SHORT_LENGTH_HIGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check if SecTAG short length is greater\n than the received packet length.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SHORT_LENGTH_MISMATCHs,  /* SHORT_LENGTH_MISMATCH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check if SecTAG short length does not match\n the received packet length.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SECTAG_E0_C1s,  /* SECTAG_E0_C1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check if the SecTAG encrypt bit in the\n tag control information field (TCI.E) is 0 and\n clear bit (TCI.C) is 1.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SECTAG_ES1_SC1s,  /* SECTAG_ES1_SC1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check if the SecTAG end station bit (TCI.ES) is 1\n and secure channel indicator bit (TCI.SC)is 1.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SECTAG_SC1_SCB1s,  /* SECTAG_SC1_SCB1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check if SecTAG secure channel indicator bit\n (TCI.SC) is 1 and single copy broadcast bit (TCI.SCB) is 1.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = PN_INVALIDs,  /* PN_INVALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check if SecTAG packet number is 0.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = AN_INVALIDs,  /* AN_INVALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check if SecTAG Association number (AN) value\n is greater than 1.\n Applicable only if SEC_BLOCK.NUM_SA_PER_SC_DECRYPT == TWO.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 1,
        .depth = 5,
        .desc = "Enable to match tag protocol identifier (TPID).",
    },
    {
        .name  = MPLS_ETHERTYPEs,  /* MPLS_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 5,
        .desc = "Enable to match MPLS ethertype.",
    },
    {
        .name  = PBB_TPIDs,  /* PBB_TPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match provider backbone bridge (PBB) TPID.",
    },
    {
        .name  = IPV4_ETHERTYPEs,  /* IPV4_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match IPv4 ethertype.",
    },
    {
        .name  = IPV6_ETHERTYPEs,  /* IPV6_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match IPv6 ethertype.",
    },
    {
        .name  = NIV_ETHERTYPEs,  /* NIV_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match network interface virtualization (NIV)\n or virtual network tag (VNTAG) ethertype.\n",
    },
    {
        .name  = PE_ETHERTYPEs,  /* PE_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match provider edge (PE) ethertype.",
    },
    {
        .name  = UDPs,  /* UDP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match UDP protocol packet.",
    },
    {
        .name  = TCPs,  /* TCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match TCP protocol packet.",
    },
    {
        .name  = PTP_ETHERTYPEs,  /* PTP_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match precision time protocol (PTP) ethertype.",
    },
    {
        .name  = PTP_DEST_PORTs,  /* PTP_DEST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match PTP destination port.",
    },
    {
        .name  = UNTAGGED_PTP_ETHERTYPEs,  /* UNTAGGED_PTP_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match unsecured (untagged) PTP ethertype.",
    },
    {
        .name  = PTP_ETHERTYPE_VLANs,  /* PTP_ETHERTYPE_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match PTP ethertype with one or two VLANs.",
    },
    {
        .name  = UDP_IPV4_PTPs,  /* UDP_IPV4_PTP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match UDP over IPv4 PTP packets at max two VLANs.",
    },
    {
        .name  = UDP_IPV6_PTPs,  /* UDP_IPV6_PTP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match UDP over IPv6 PTP packets at max two VLANs.",
    },
    {
        .name  = SECTAG_AFTER_IPV4s,  /* SECTAG_AFTER_IPV4 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match the two bytes after IPv4 with SecTAG ethertype.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SECTAG_AFTER_IPV6s,  /* SECTAG_AFTER_IPV6 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match the two bytes after IPv6 with SecTAG ethertype.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SECTAG_AFTER_TCPs,  /* SECTAG_AFTER_TCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match the two bytes after TCP header with\n SecTAG ethertype.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SECTAG_AFTER_UDPs,  /* SECTAG_AFTER_UDP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match the two bytes after UDP header with\n SecTAG ethertype.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = IPV4_CHECKSUMs,  /* IPV4_CHECKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check IPv4 checksum for secured data packets\n (packets with SecTAG). Packets will be discarded upon checksum\n failure.\n",
    },
    {
        .name  = VXLAN_UDF_PAYLOADs,  /* VXLAN_UDF_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to extract IPv4 header with UDP and VNI data to be used\n for UDF payload match in the SEC_MACSEC_SUBPORT_FLOW table.\n Applicable only if the secured VXLAN UDP port matches\n the value specified in\n SEC_DECRYPT_PROTOCOL.VXLAN_DEST_PORT_MATCH.\n Default is to use the five bytes following the UDP header as a\n match criteria.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = STP_FOR_BRIDGES_MAC_ADDRs,  /* STP_FOR_BRIDGES_MAC_ADDR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify management packet if the\n destination MAC address is in the range of\n 01-80-C2-00-00-00/44.\n",
    },
    {
        .name  = VTP_MAC_ADDRESSs,  /* VTP_MAC_ADDRESS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify management packet if the\n destination MAC address is 01-00-0C-CC-CC-CC.\n",
    },
    {
        .name  = MGMT_DST_MACs,  /* MGMT_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable to identify management packet if the\n destination MAC address is the same as the value specified in\n SEC_DECRYPT_MGMT.MGMT_DST_MAC.\n",
    },
    {
        .name  = MGMT_ETHERTYPEs,  /* MGMT_ETHERTYPE */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable to identify management packet if the\n ethertype is the same as the value specified in\n SEC_DECRYPT_MGMT.MGMT_ETHERTYPE.\n",
    },
    {
        .name  = MGMT_RANGEs,  /* MGMT_RANGE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify management packet\n based on the destination MAC address range specified in\n SEC_DECRYPT_MGMT.MGMT_DST_MAC_RANGE_LOW and\n SEC_DECRYPT_MGMT.MGMT_DST_MAC_RANGE_HIGH\n",
    },
    {
        .name  = MGMT_DST_MAC_AND_ETHERTYPE_0s,  /* MGMT_DST_MAC_AND_ETHERTYPE_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify management packet\n based on both destination MAC address and ethertype\n specified in SEC_DECRYPT_MGMT.MGMT_DST_MAC_GROUP_0 and\n SEC_DECRYPT_MGMT.MGMT_ETHERTYPE_GROUP_0.\n",
    },
    {
        .name  = MGMT_DST_MAC_AND_ETHERTYPE_1s,  /* MGMT_DST_MAC_AND_ETHERTYPE_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify management packet\n based on both destination MAC address and ethertype\n specified in SEC_DECRYPT_MGMT.MGMT_DST_MAC_GROUP_1 and\n SEC_DECRYPT_MGMT.MGMT_ETHERTYPE_GROUP_1.\n",
    },
    {
        .name  = MGMT_TCIE_1_TCIC_0s,  /* MGMT_TCIE_1_TCIC_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify management packet if\n the TCI.E bit of SecTAG is 1 and TCI.C bit of SecTAG is 0.\n",
    },
    {
        .name  = MGMT_PTPs,  /* MGMT_PTP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify management packet if\n the packet is a precision time protocol (IEEE 1588) packet.\n",
    },
    {
        .name  = IKE_DEST_PORT_WITH_NONESPs,  /* IKE_DEST_PORT_WITH_NONESP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPsec packets with UDP destination port\n SEC_DECRYPT_PROTOCOL.IKE_DEST_PORT_WITH_NONESP_MATCH\n and a 4-byte non-ESP marker.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = IKE_DEST_PORT_WITHOUT_NONESPs,  /* IKE_DEST_PORT_WITHOUT_NONESP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPsec packets with UDP destination port\n SEC_DECRYPT_PROTOCOL.IKE_DEST_PORT_WITHOUT_NONESP_MATCH\n and no ESP marker.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = SECTAG_SHORT_LENGTH_6BITSs,  /* SECTAG_SHORT_LENGTH_6BITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use lower 6 bits of the SL field in SecTAG processing.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = ESPs,  /* ESP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect ESP over IP protocol.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = ESP_UDP_SRC_PORTs,  /* ESP_UDP_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect UDP encapsulated ESP using UDP source port.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = ESP_UDP_DST_PORTs,  /* ESP_UDP_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect UDP encapsulated ESP using UDP destination port.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = ESP_SN_ZEROs,  /* ESP_SN_ZERO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow sequence number (SN) field in ESP to be 0.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = ESP_SPI_ZEROs,  /* ESP_SPI_ZERO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow security parameter index (SPI) field in ESP\n to be 0.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = ESP_SPI_1_255s,  /* ESP_SPI_1_255 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow security parameter index (SPI) field in ESP\n to be in the range of 1 and 255.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = IPV4_FRAGMENTs,  /* IPV4_FRAGMENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 fragment.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = NAT_KEEPALIVE_SRC_PORTs,  /* NAT_KEEPALIVE_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow NAT keep-alive packets using\n SEC_DECRYPT_PROTOCOL.IPSEC_NAT_SRC_PORT_MATCH.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = NAT_KEEPALIVE_DST_PORTs,  /* NAT_KEEPALIVE_DST_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow NAT keep-alive packets using\n SEC_DECRYPT_PROTOCOL.IPSEC_NAT_DST_PORT_MATCH.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = MTUs,  /* MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum transmission unit (MTU) value for decrypt\n management, KaY and subport flow miss packets.\n This value includes SVTAG and doesn't include the CRC bytes.\n",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Default SEC_DECRYPT_SUBPORT_POLICY table index for a\n management packet identified by the enabled rules.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SEC_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_port_t = {
    .name = SEC_DECRYPT_PORTs, /* SEC_DECRYPT_PORT */
    .flags = 0,
    .fields = 58,
    .field = bcmltd_sec_decrypt_port_t_fields,
    .desc = "The SEC_DECRYPT_PORT table specifies the per\n port MACsec and IPsec decryption controls in the decrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_PROTOCOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_protocol_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = MAX_LEN_802_3s,  /* MAX_LEN_802_3 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Data length field value to classify as Ethernet-II packets.\n If the packet data length field is less than the specified\n value, it is treated as an IEEE 802.3 packet.\n",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 8,
        .desc = "VLAN TPID match value.",
    },
    {
        .name  = MPLS_ETHERTYPEs,  /* MPLS_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 4,
        .desc = "MPLS ethertype match value.",
    },
    {
        .name  = PBB_BTAG_TPIDs,  /* PBB_BTAG_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Provider backbone bridge BTAG TPID match value.",
    },
    {
        .name  = PBB_ITAG_TPIDs,  /* PBB_ITAG_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Provider backbone bridge ITAG TPID match value.",
    },
    {
        .name  = IPV4_ETHERTYPEs,  /* IPV4_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "IPv4 ethertype match value.",
    },
    {
        .name  = IPV6_ETHERTYPEs,  /* IPV6_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "IPv6 ethertype match value.",
    },
    {
        .name  = PTP_ETHERTYPEs,  /* PTP_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "PTP ethertype match value.",
    },
    {
        .name  = NIV_ETHERTYPEs,  /* NIV_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "VNTAG ethertype match value.",
    },
    {
        .name  = PE_ETHERTYPEs,  /* PE_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Provider edge ethertype match value.",
    },
    {
        .name  = UDP_PROTOCOL_NUMs,  /* UDP_PROTOCOL_NUM */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "UDP protocol number match match value.",
    },
    {
        .name  = TCP_PROTOCOL_NUMs,  /* TCP_PROTOCOL_NUM */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TCP protocol number match match value.",
    },
    {
        .name  = VXLAN_DEST_PORTs,  /* VXLAN_DEST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Secured VXLAN destination port number used to match the packet.\n For a TCP/UDP over IPv6 packet if a match is successful,\n only the VXLAN Flags and VNI header are extracted to match\n against SEC_DECRYPT_SUBPORT_FLOW.PAYLOAD.\n Applicable only if SEC_DECRYPT_PORT.VXLAN_UDF_PAYLOAD\n is enabled.\n This field is applicable only for MACsec.\n",
    },
    {
        .name  = PTP_GENERAL_DEST_PORTs,  /* PTP_GENERAL_DEST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "PTP destination port number match value for general message.",
    },
    {
        .name  = PTP_EVENT_DEST_PORTs,  /* PTP_EVENT_DEST_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "PTP destination port number match value for event message.",
    },
    {
        .name  = IKE_DEST_PORT_WITH_NONESPs,  /* IKE_DEST_PORT_WITH_NONESP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IPSec IKE UDP destination port match value used when\n a 4-byte non-ESP marker is present.\n Applicable only if SEC_DECRYPT_PORT.IKE_DEST_PORT_WITH_NONESP\n is set. Applicable only for IPsec.\n",
    },
    {
        .name  = IKE_DEST_PORT_WITHOUT_NONESPs,  /* IKE_DEST_PORT_WITHOUT_NONESP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IPSec IKE UDP destination port number used\n without a non-ESP marker.\n Applicable only if SEC_DECRYPT_PORT.IKE_DEST_PORT_WITHOUT_NONESP\n is set. Applicable only for IPsec.\n",
    },
    {
        .name  = IPSEC_NAT_DEST_PORTs,  /* IPSEC_NAT_DEST_PORT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IPSec NAT-keepalive packet UDP destination port number\n used with 1-byte payload value of 0xFF.\n Applicable only for IPsec.\n",
    },
    {
        .name  = ESP_UDP_DEST_PORTs,  /* ESP_UDP_DEST_PORT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The UDP destination port number used to match\n the IPsec UDP encapsulated ESP packet.\n Applicable only for IPsec.\n",
    },
    {
        .name  = IPSEC_NAT_SRC_PORTs,  /* IPSEC_NAT_SRC_PORT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "IPSec NAT-keepalive packet UDP Source port number\n used with IPSEC_NAT_DEST_PORT and\n 1-byte payload value of 0xFF.\n Applicable only for IPsec.\n",
    },
    {
        .name  = ESP_UDP_SRC_PORTs,  /* ESP_UDP_SRC_PORT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The UDP source port number used to match\n the IPsec UDP encapsulated ESP packet along with\n ESP_UDP_DEST_PORT.\n Applicable only for IPsec.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_protocol_t = {
    .name = SEC_DECRYPT_PROTOCOLs, /* SEC_DECRYPT_PROTOCOL */
    .flags = 0,
    .fields = 22,
    .field = bcmltd_sec_decrypt_protocol_t_fields,
    .desc = "The SEC_DECRYPT_PROTOCOL table specifies protocol\n related parameters in the decrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOWs, /* SEC_DECRYPT_SUBPORT_FLOW */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 20,
    .field = bcmltd_sec_decrypt_subport_flow_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW table is used to identify a MACsec\n or an IPsec security entity (SecY).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_ETAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_etag_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = SRC_MAC_MASKs,  /* SRC_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for SRC_MAC.",
    },
    {
        .name  = FIRST_VLAN_IDs,  /* FIRST_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "First VLAN ID.",
    },
    {
        .name  = FIRST_VLAN_ID_MASKs,  /* FIRST_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FIRST_VLAN_ID.",
    },
    {
        .name  = FIRST_PRIs,  /* FIRST_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "First VLAN priority.",
    },
    {
        .name  = FIRST_PRI_MASKs,  /* FIRST_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FIRST_PRI.",
    },
    {
        .name  = FIRST_CFIs,  /* FIRST_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "First VLAN CFI.",
    },
    {
        .name  = FIRST_CFI_MASKs,  /* FIRST_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FIRST_CFI.",
    },
    {
        .name  = SECOND_VLAN_IDs,  /* SECOND_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Second VLAN ID.",
    },
    {
        .name  = SECOND_VLAN_ID_MASKs,  /* SECOND_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for SECOND_VLAN_ID.",
    },
    {
        .name  = SECOND_PRIs,  /* SECOND_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Second VLAN priority.",
    },
    {
        .name  = SECOND_PRI_MASKs,  /* SECOND_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for SECOND_PRI.",
    },
    {
        .name  = SECOND_CFIs,  /* SECOND_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Second VLAN CFI.",
    },
    {
        .name  = SECOND_CFI_MASKs,  /* SECOND_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SECOND_CFI.",
    },
    {
        .name  = ETAG_TCIs,  /* ETAG_TCI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "ETAG TCI header.",
    },
    {
        .name  = ETAG_TCI_MASKs,  /* ETAG_TCI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for ETAG_TCI.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the last defined field.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_etag_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_ETAGs, /* SEC_DECRYPT_SUBPORT_FLOW_ETAG */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 40,
    .field = bcmltd_sec_decrypt_subport_flow_etag_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_ETAG table is used to identify a MACsec\n or an IPsec security entity (SecY) based on extension VLAN tag (ETAG)\n packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_ETHERNET_II.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_ethernet_ii_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = SRC_MAC_MASKs,  /* SRC_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for SRC_MAC.",
    },
    {
        .name  = FIRST_VLAN_IDs,  /* FIRST_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "First VLAN ID.",
    },
    {
        .name  = FIRST_VLAN_ID_MASKs,  /* FIRST_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FIRST_VLAN_ID.",
    },
    {
        .name  = FIRST_PRIs,  /* FIRST_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "First VLAN priority.",
    },
    {
        .name  = FIRST_PRI_MASKs,  /* FIRST_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FIRST_PRI.",
    },
    {
        .name  = FIRST_CFIs,  /* FIRST_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "First VLAN CFI.",
    },
    {
        .name  = FIRST_CFI_MASKs,  /* FIRST_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FIRST_CFI.",
    },
    {
        .name  = SECOND_VLAN_IDs,  /* SECOND_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Second VLAN ID.",
    },
    {
        .name  = SECOND_VLAN_ID_MASKs,  /* SECOND_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for SECOND_VLAN_ID.",
    },
    {
        .name  = SECOND_PRIs,  /* SECOND_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Second VLAN priority.",
    },
    {
        .name  = SECOND_PRI_MASKs,  /* SECOND_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for SECOND_PRI.",
    },
    {
        .name  = SECOND_CFIs,  /* SECOND_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Second VLAN CFI.",
    },
    {
        .name  = SECOND_CFI_MASKs,  /* SECOND_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SECOND_CFI.",
    },
    {
        .name  = THIRD_VLAN_IDs,  /* THIRD_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Third VLAN ID.",
    },
    {
        .name  = THIRD_VLAN_ID_MASKs,  /* THIRD_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for THIRD_VLAN_ID.",
    },
    {
        .name  = THIRD_PRIs,  /* THIRD_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Third VLAN priority.",
    },
    {
        .name  = THIRD_PRI_MASKs,  /* THIRD_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for THIRD_PRI.",
    },
    {
        .name  = THIRD_CFIs,  /* THIRD_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Third VLAN CFI.",
    },
    {
        .name  = THIRD_CFI_MASKs,  /* THIRD_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for THIRD_CFI.",
    },
    {
        .name  = FOURTH_VLAN_IDs,  /* FOURTH_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Fourth VLAN ID.",
    },
    {
        .name  = FOURTH_VLAN_ID_MASKs,  /* FOURTH_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FOURTH_VLAN_ID.",
    },
    {
        .name  = FOURTH_PRIs,  /* FOURTH_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Fourth VLAN priority.",
    },
    {
        .name  = FOURTH_PRI_MASKs,  /* FOURTH_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FOURTH_PRI.",
    },
    {
        .name  = FOURTH_CFIs,  /* FOURTH_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Fourth VLAN CFI.",
    },
    {
        .name  = FOURTH_CFI_MASKs,  /* FOURTH_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FOURTH_CFI.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the fourth VLAN tag.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_ethernet_ii_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_ETHERNET_IIs, /* SEC_DECRYPT_SUBPORT_FLOW_ETHERNET_II */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 50,
    .field = bcmltd_sec_decrypt_subport_flow_ethernet_ii_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW table is used to identify a MACsec or an\n IPsec security entity (SecY) based on Ethernet II packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_ipv4_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = SRC_MAC_MASKs,  /* SRC_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for SRC_MAC.",
    },
    {
        .name  = FIRST_VLAN_IDs,  /* FIRST_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "First VLAN ID.",
    },
    {
        .name  = FIRST_VLAN_ID_MASKs,  /* FIRST_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FIRST_VLAN_ID.",
    },
    {
        .name  = FIRST_PRIs,  /* FIRST_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "First VLAN priority.",
    },
    {
        .name  = FIRST_PRI_MASKs,  /* FIRST_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FIRST_PRI.",
    },
    {
        .name  = FIRST_CFIs,  /* FIRST_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "First VLAN CFI.",
    },
    {
        .name  = FIRST_CFI_MASKs,  /* FIRST_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FIRST_CFI.",
    },
    {
        .name  = SECOND_VLAN_IDs,  /* SECOND_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Second VLAN ID.",
    },
    {
        .name  = SECOND_VLAN_ID_MASKs,  /* SECOND_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for SECOND_VLAN_ID.",
    },
    {
        .name  = SECOND_PRIs,  /* SECOND_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Second VLAN priority.",
    },
    {
        .name  = SECOND_PRI_MASKs,  /* SECOND_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for SECOND_PRI.",
    },
    {
        .name  = SECOND_CFIs,  /* SECOND_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Second VLAN CFI.",
    },
    {
        .name  = SECOND_CFI_MASKs,  /* SECOND_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SECOND_CFI.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = SRC_IPV4_MASKs,  /* SRC_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for SRC_IPV4.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = DST_IPV4_MASKs,  /* DST_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for DST_IPV4.",
    },
    {
        .name  = PROTOCOL_NUMBERs,  /* PROTOCOL_NUMBER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Internet protocol number.",
    },
    {
        .name  = PROTOCOL_NUMBER_MASKs,  /* PROTOCOL_NUMBER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PROTOCOL_NUMBER.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the protocol number.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_ipv4_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_IPV4s, /* SEC_DECRYPT_SUBPORT_FLOW_IPV4 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 44,
    .field = bcmltd_sec_decrypt_subport_flow_ipv4_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_IPV4 table is used to identify a MACsec\n or an IPsec security entity (SecY) based on IPv4 packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_ipv6_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = FIRST_VLAN_IDs,  /* FIRST_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "First VLAN ID.",
    },
    {
        .name  = FIRST_VLAN_ID_MASKs,  /* FIRST_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FIRST_VLAN_ID.",
    },
    {
        .name  = FIRST_PRIs,  /* FIRST_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "First VLAN priority.",
    },
    {
        .name  = FIRST_PRI_MASKs,  /* FIRST_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FIRST_PRI.",
    },
    {
        .name  = FIRST_CFIs,  /* FIRST_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "First VLAN CFI.",
    },
    {
        .name  = FIRST_CFI_MASKs,  /* FIRST_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FIRST_CFI.",
    },
    {
        .name  = SECOND_VLAN_IDs,  /* SECOND_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Second VLAN ID.",
    },
    {
        .name  = SECOND_VLAN_ID_MASKs,  /* SECOND_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for SECOND_VLAN_ID.",
    },
    {
        .name  = SECOND_PRIs,  /* SECOND_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Second VLAN priority.",
    },
    {
        .name  = SECOND_PRI_MASKs,  /* SECOND_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for SECOND_PRI.",
    },
    {
        .name  = SECOND_CFIs,  /* SECOND_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Second VLAN CFI.",
    },
    {
        .name  = SECOND_CFI_MASKs,  /* SECOND_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SECOND_CFI.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_UPPER_MASKs,  /* SRC_IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for SRC_IPV6_UPPER.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_LOWER_MASKs,  /* SRC_IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for SRC_IPV6_LOWER.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_UPPER_MASKs,  /* DST_IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for DST_IPV6_UPPER.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWER_MASKs,  /* DST_IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for DST_IPV6_LOWER.",
    },
    {
        .name  = PROTOCOL_NUMBERs,  /* PROTOCOL_NUMBER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Internet protocol number.",
    },
    {
        .name  = PROTOCOL_NUMBER_MASKs,  /* PROTOCOL_NUMBER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PROTOCOL_NUMBER.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the protocol number.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_ipv6_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_IPV6s, /* SEC_DECRYPT_SUBPORT_FLOW_IPV6 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 46,
    .field = bcmltd_sec_decrypt_subport_flow_ipv6_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_IPV6 table is used to identify a MACsec\n or an IPsec security entity (SecY) based on IPv6 packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_LLC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_llc_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = SRC_MAC_MASKs,  /* SRC_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for SRC_MAC.",
    },
    {
        .name  = FIRST_VLAN_IDs,  /* FIRST_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "First VLAN ID.",
    },
    {
        .name  = FIRST_VLAN_ID_MASKs,  /* FIRST_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FIRST_VLAN_ID.",
    },
    {
        .name  = FIRST_PRIs,  /* FIRST_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "First VLAN priority.",
    },
    {
        .name  = FIRST_PRI_MASKs,  /* FIRST_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FIRST_PRI.",
    },
    {
        .name  = FIRST_CFIs,  /* FIRST_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "First VLAN CFI.",
    },
    {
        .name  = FIRST_CFI_MASKs,  /* FIRST_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FIRST_CFI.",
    },
    {
        .name  = SECOND_VLAN_IDs,  /* SECOND_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Second VLAN ID.",
    },
    {
        .name  = SECOND_VLAN_ID_MASKs,  /* SECOND_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for SECOND_VLAN_ID.",
    },
    {
        .name  = SECOND_PRIs,  /* SECOND_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Second VLAN priority.",
    },
    {
        .name  = SECOND_PRI_MASKs,  /* SECOND_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for SECOND_PRI.",
    },
    {
        .name  = SECOND_CFIs,  /* SECOND_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Second VLAN CFI.",
    },
    {
        .name  = SECOND_CFI_MASKs,  /* SECOND_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SECOND_CFI.",
    },
    {
        .name  = THIRD_VLAN_IDs,  /* THIRD_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Third VLAN ID.",
    },
    {
        .name  = THIRD_VLAN_ID_MASKs,  /* THIRD_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for THIRD_VLAN_ID.",
    },
    {
        .name  = THIRD_PRIs,  /* THIRD_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Third VLAN priority.",
    },
    {
        .name  = THIRD_PRI_MASKs,  /* THIRD_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for THIRD_PRI.",
    },
    {
        .name  = THIRD_CFIs,  /* THIRD_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Third VLAN CFI.",
    },
    {
        .name  = THIRD_CFI_MASKs,  /* THIRD_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for THIRD_CFI.",
    },
    {
        .name  = FOURTH_VLAN_IDs,  /* FOURTH_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Fourth VLAN ID.",
    },
    {
        .name  = FOURTH_VLAN_ID_MASKs,  /* FOURTH_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FOURTH_VLAN_ID.",
    },
    {
        .name  = FOURTH_PRIs,  /* FOURTH_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Fourth VLAN priority.",
    },
    {
        .name  = FOURTH_PRI_MASKs,  /* FOURTH_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FOURTH_PRI.",
    },
    {
        .name  = FOURTH_CFIs,  /* FOURTH_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Fourth VLAN CFI.",
    },
    {
        .name  = FOURTH_CFI_MASKs,  /* FOURTH_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FOURTH_CFI.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the fourth VLAN tag.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_llc_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_LLCs, /* SEC_DECRYPT_SUBPORT_FLOW_LLC */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 50,
    .field = bcmltd_sec_decrypt_subport_flow_llc_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_LLC table is used to identify a MACsec\n or an IPsec security entity (SecY) based on LLC packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_MPLS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_mpls_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_MPLS_0s,  /* NUM_MPLS_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero MPLS labels.",
    },
    {
        .name  = NUM_MPLS_0_MASKs,  /* NUM_MPLS_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_MPLS_0.",
    },
    {
        .name  = NUM_MPLS_1s,  /* NUM_MPLS_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one MPLS label.",
    },
    {
        .name  = NUM_MPLS_1_MASKs,  /* NUM_MPLS_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_MPLS_1.",
    },
    {
        .name  = NUM_MPLS_2s,  /* NUM_MPLS_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two MPLS labels.",
    },
    {
        .name  = NUM_MPLS_2_MASKs,  /* NUM_MPLS_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_MPLS_2.",
    },
    {
        .name  = NUM_MPLS_3s,  /* NUM_MPLS_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three MPLS labels.",
    },
    {
        .name  = NUM_MPLS_3_MASKs,  /* NUM_MPLS_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_MPLS_3.",
    },
    {
        .name  = NUM_MPLS_4s,  /* NUM_MPLS_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four MPLS labels.",
    },
    {
        .name  = NUM_MPLS_4_MASKs,  /* NUM_MPLS_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_MPLS_4.",
    },
    {
        .name  = NUM_MPLS_5s,  /* NUM_MPLS_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more MPLS labels.",
    },
    {
        .name  = NUM_MPLS_5_MASKs,  /* NUM_MPLS_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_MPLS_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = BOS_LABELs,  /* BOS_LABEL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 20,
        .depth = 0,
        .desc = "The bottom of stack (BOS) MPLS label.",
    },
    {
        .name  = BOS_LABEL_MASKs,  /* BOS_LABEL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 20,
        .depth = 0,
        .desc = "MASK for BOS_LABEL.",
    },
    {
        .name  = BOS_LABEL_EXPs,  /* BOS_LABEL_EXP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "The bottom of stack (BOS) MPLS EXP value.",
    },
    {
        .name  = BOS_LABEL_EXP_MASKs,  /* BOS_LABEL_EXP_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for BOS_LABEL_EXP.",
    },
    {
        .name  = BOS_LABEL_SBITs,  /* BOS_LABEL_SBIT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "The bottom of stack (BOS) MPLS S bit.",
    },
    {
        .name  = BOS_LABEL_SBIT_MASKs,  /* BOS_LABEL_SBIT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for BOS_LABEL_SBIT.",
    },
    {
        .name  = BOS_1_LABELs,  /* BOS_1_LABEL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 20,
        .depth = 0,
        .desc = "The first MPLS label before the bottom of stack label.",
    },
    {
        .name  = BOS_1_LABEL_MASKs,  /* BOS_1_LABEL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 20,
        .depth = 0,
        .desc = "MASK for BOS_1_LABEL.",
    },
    {
        .name  = BOS_1_LABEL_EXPs,  /* BOS_1_LABEL_EXP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "The first MPLS EXP value before the bottom of stack label.",
    },
    {
        .name  = BOS_1_LABEL_EXP_MASKs,  /* BOS_1_LABEL_EXP_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for BOS_1_LABEL_EXP.",
    },
    {
        .name  = BOS_1_LABEL_SBITs,  /* BOS_1_LABEL_SBIT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "The first MPLS S bit before the bottom of stack label.",
    },
    {
        .name  = BOS_1_LABEL_SBIT_MASKs,  /* BOS_1_LABEL_SBIT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for BOS_1_LABEL_SBIT.",
    },
    {
        .name  = BOS_2_LABELs,  /* BOS_2_LABEL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 20,
        .depth = 0,
        .desc = "The second MPLS label before the bottom of stack label.",
    },
    {
        .name  = BOS_2_LABEL_MASKs,  /* BOS_2_LABEL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 20,
        .depth = 0,
        .desc = "MASK for BOS_2_LABEL.",
    },
    {
        .name  = BOS_2_LABEL_EXPs,  /* BOS_2_LABEL_EXP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "The second MPLS EXP value before the bottom of stack label.",
    },
    {
        .name  = BOS_2_LABEL_EXP_MASKs,  /* BOS_2_LABEL_EXP_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for BOS_2_LABEL_EXP.",
    },
    {
        .name  = BOS_2_LABEL_SBITs,  /* BOS_2_LABEL_SBIT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "The second MPLS S bit before the bottom of stack label.",
    },
    {
        .name  = BOS_2_LABEL_SBIT_MASKs,  /* BOS_2_LABEL_SBIT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for BOS_2_LABEL_SBIT.",
    },
    {
        .name  = TOS_LABELs,  /* TOS_LABEL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 20,
        .depth = 0,
        .desc = "The top of stack (TOS) MPLS label.",
    },
    {
        .name  = TOS_LABEL_MASKs,  /* TOS_LABEL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 20,
        .depth = 0,
        .desc = "MASK for TOS_LABEL.",
    },
    {
        .name  = TOS_LABEL_EXPs,  /* TOS_LABEL_EXP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "The top of stack (TOS) MPLS EXP value.",
    },
    {
        .name  = TOS_LABEL_EXP_MASKs,  /* TOS_LABEL_EXP_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for TOS_LABEL_EXP.",
    },
    {
        .name  = TOS_LABEL_SBITs,  /* TOS_LABEL_SBIT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "The top of stack (TOS) MPLS S bit.",
    },
    {
        .name  = TOS_LABEL_SBIT_MASKs,  /* TOS_LABEL_SBIT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for TOS_LABEL_SBIT.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the BOS label.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_mpls_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_MPLSs, /* SEC_DECRYPT_SUBPORT_FLOW_MPLS */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 48,
    .field = bcmltd_sec_decrypt_subport_flow_mpls_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_MPLS table is used to identify a MACsec\n or an IPsec security entity (SecY) based on MPLS packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_PBB.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_pbb_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = SRC_MAC_MASKs,  /* SRC_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for SRC_MAC.",
    },
    {
        .name  = PBB_BBTAGs,  /* PBB_BBTAG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Provider backbone bridge BBTAG VLAN after TPID.",
    },
    {
        .name  = PBB_BBTAG_MASKs,  /* PBB_BBTAG_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for PBB_BBTAG.",
    },
    {
        .name  = PBB_ITAGs,  /* PBB_ITAG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Provider backbone bridge ITAG after ethertype.",
    },
    {
        .name  = PBB_ITAG_MASKs,  /* PBB_ITAG_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for PBB_ITAG.",
    },
    {
        .name  = DST_MAC_ADDR_INNERs,  /* DST_MAC_ADDR_INNER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Inner destination MAC address.",
    },
    {
        .name  = DST_MAC_ADDR_INNER_MASKs,  /* DST_MAC_ADDR_INNER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC_ADDR_INNER.",
    },
    {
        .name  = SRC_MAC_ADDR_INNERs,  /* SRC_MAC_ADDR_INNER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Inner source MAC address.",
    },
    {
        .name  = SRC_MAC_ADDR_INNER_MASKs,  /* SRC_MAC_ADDR_INNER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for SRC_MAC_ADDR_INNER.",
    },
    {
        .name  = FIRST_VLAN_ID_INNERs,  /* FIRST_VLAN_ID_INNER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "First inner VLAN ID.",
    },
    {
        .name  = FIRST_VLAN_ID_INNER_MASKs,  /* FIRST_VLAN_ID_INNER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FIRST_VLAN_ID_INNER.",
    },
    {
        .name  = FIRST_PRI_INNERs,  /* FIRST_PRI_INNER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "First inner VLAN priority.",
    },
    {
        .name  = FIRST_PRI_INNER_MASKs,  /* FIRST_PRI_INNER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FIRST_PRI_INNER.",
    },
    {
        .name  = FIRST_CFI_INNERs,  /* FIRST_CFI_INNER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "First inner VLAN CFI.",
    },
    {
        .name  = FIRST_CFI_INNER_MASKs,  /* FIRST_CFI_INNER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FIRST_CFI_INNER.",
    },
    {
        .name  = SECOND_VLAN_ID_INNERs,  /* SECOND_VLAN_ID_INNER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Second inner VLAN ID.",
    },
    {
        .name  = SECOND_VLAN_ID_INNER_MASKs,  /* SECOND_VLAN_ID_INNER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for SECOND_VLAN_ID_INNER.",
    },
    {
        .name  = SECOND_PRI_INNERs,  /* SECOND_PRI_INNER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Second inner VLAN priority.",
    },
    {
        .name  = SECOND_PRI_INNER_MASKs,  /* SECOND_PRI_INNER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for SECOND_PRI_INNER.",
    },
    {
        .name  = SECOND_CFI_INNERs,  /* SECOND_CFI_INNER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Second inner VLAN CFI.",
    },
    {
        .name  = SECOND_CFI_INNER_MASKs,  /* SECOND_CFI_INNER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SECOND_CFI_INNER.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the second inner VLAN tag.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_pbb_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_PBBs, /* SEC_DECRYPT_SUBPORT_FLOW_PBB */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 46,
    .field = bcmltd_sec_decrypt_subport_flow_pbb_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_PBB table is used to identify a MACsec\n or an IPsec security entity (SecY) based on provider backbone bridge\n (PBB) packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_SNAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_snap_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = SRC_MAC_MASKs,  /* SRC_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for SRC_MAC.",
    },
    {
        .name  = FIRST_VLAN_IDs,  /* FIRST_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "First VLAN ID.",
    },
    {
        .name  = FIRST_VLAN_ID_MASKs,  /* FIRST_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FIRST_VLAN_ID.",
    },
    {
        .name  = FIRST_PRIs,  /* FIRST_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "First VLAN priority.",
    },
    {
        .name  = FIRST_PRI_MASKs,  /* FIRST_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FIRST_PRI.",
    },
    {
        .name  = FIRST_CFIs,  /* FIRST_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "First VLAN CFI.",
    },
    {
        .name  = FIRST_CFI_MASKs,  /* FIRST_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FIRST_CFI.",
    },
    {
        .name  = SECOND_VLAN_IDs,  /* SECOND_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Second VLAN ID.",
    },
    {
        .name  = SECOND_VLAN_ID_MASKs,  /* SECOND_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for SECOND_VLAN_ID.",
    },
    {
        .name  = SECOND_PRIs,  /* SECOND_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Second VLAN priority.",
    },
    {
        .name  = SECOND_PRI_MASKs,  /* SECOND_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for SECOND_PRI.",
    },
    {
        .name  = SECOND_CFIs,  /* SECOND_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Second VLAN CFI.",
    },
    {
        .name  = SECOND_CFI_MASKs,  /* SECOND_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SECOND_CFI.",
    },
    {
        .name  = THIRD_VLAN_IDs,  /* THIRD_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Third VLAN ID.",
    },
    {
        .name  = THIRD_VLAN_ID_MASKs,  /* THIRD_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for THIRD_VLAN_ID.",
    },
    {
        .name  = THIRD_PRIs,  /* THIRD_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Third VLAN priority.",
    },
    {
        .name  = THIRD_PRI_MASKs,  /* THIRD_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for THIRD_PRI.",
    },
    {
        .name  = THIRD_CFIs,  /* THIRD_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Third VLAN CFI.",
    },
    {
        .name  = THIRD_CFI_MASKs,  /* THIRD_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for THIRD_CFI.",
    },
    {
        .name  = FOURTH_VLAN_IDs,  /* FOURTH_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Fourth VLAN ID.",
    },
    {
        .name  = FOURTH_VLAN_ID_MASKs,  /* FOURTH_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FOURTH_VLAN_ID.",
    },
    {
        .name  = FOURTH_PRIs,  /* FOURTH_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Fourth VLAN priority.",
    },
    {
        .name  = FOURTH_PRI_MASKs,  /* FOURTH_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FOURTH_PRI.",
    },
    {
        .name  = FOURTH_CFIs,  /* FOURTH_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Fourth VLAN CFI.",
    },
    {
        .name  = FOURTH_CFI_MASKs,  /* FOURTH_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FOURTH_CFI.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the fourth VLAN tag.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_snap_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_SNAPs, /* SEC_DECRYPT_SUBPORT_FLOW_SNAP */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 50,
    .field = bcmltd_sec_decrypt_subport_flow_snap_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_SNAP table is used to identify a MACsec\n or an IPsec security entity (SecY) based on SNAP packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_TCP_OVER_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_tcp_over_ipv4_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = SRC_MAC_MASKs,  /* SRC_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for SRC_MAC.",
    },
    {
        .name  = FIRST_VLAN_IDs,  /* FIRST_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "First VLAN ID.",
    },
    {
        .name  = FIRST_VLAN_ID_MASKs,  /* FIRST_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FIRST_VLAN_ID.",
    },
    {
        .name  = FIRST_PRIs,  /* FIRST_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "First VLAN priority.",
    },
    {
        .name  = FIRST_PRI_MASKs,  /* FIRST_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FIRST_PRI.",
    },
    {
        .name  = FIRST_CFIs,  /* FIRST_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "First VLAN CFI.",
    },
    {
        .name  = FIRST_CFI_MASKs,  /* FIRST_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FIRST_CFI.",
    },
    {
        .name  = SECOND_VLAN_IDs,  /* SECOND_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Second VLAN ID.",
    },
    {
        .name  = SECOND_VLAN_ID_MASKs,  /* SECOND_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for SECOND_VLAN_ID.",
    },
    {
        .name  = SECOND_PRIs,  /* SECOND_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Second VLAN priority.",
    },
    {
        .name  = SECOND_PRI_MASKs,  /* SECOND_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for SECOND_PRI.",
    },
    {
        .name  = SECOND_CFIs,  /* SECOND_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Second VLAN CFI.",
    },
    {
        .name  = SECOND_CFI_MASKs,  /* SECOND_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SECOND_CFI.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = SRC_IPV4_MASKs,  /* SRC_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for SRC_IPV4.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = DST_IPV4_MASKs,  /* DST_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for DST_IPV4.",
    },
    {
        .name  = PROTOCOL_NUMBERs,  /* PROTOCOL_NUMBER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Internet protocol number.",
    },
    {
        .name  = PROTOCOL_NUMBER_MASKs,  /* PROTOCOL_NUMBER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PROTOCOL_NUMBER.",
    },
    {
        .name  = TCP_SRC_PORTs,  /* TCP_SRC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "TCP source port.",
    },
    {
        .name  = TCP_SRC_PORT_MASKs,  /* TCP_SRC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for TCP_SRC_PORT.",
    },
    {
        .name  = TCP_DST_PORTs,  /* TCP_DST_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "TCP destination port.",
    },
    {
        .name  = TCP_DST_PORT_MASKs,  /* TCP_DST_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for TCP_DST_PORT.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the TCP destination port.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_tcp_over_ipv4_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_TCP_OVER_IPV4s, /* SEC_DECRYPT_SUBPORT_FLOW_TCP_OVER_IPV4 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 48,
    .field = bcmltd_sec_decrypt_subport_flow_tcp_over_ipv4_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_TCP_OVER_IPV4 table is used to identify\n a MACsec or an IPsec security entity (SecY) based on TCP over IPv4\n packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_TCP_OVER_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_tcp_over_ipv6_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = FIRST_VLAN_IDs,  /* FIRST_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "First VLAN ID.",
    },
    {
        .name  = FIRST_VLAN_ID_MASKs,  /* FIRST_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FIRST_VLAN_ID.",
    },
    {
        .name  = FIRST_PRIs,  /* FIRST_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "First VLAN priority.",
    },
    {
        .name  = FIRST_PRI_MASKs,  /* FIRST_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FIRST_PRI.",
    },
    {
        .name  = FIRST_CFIs,  /* FIRST_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "First VLAN CFI.",
    },
    {
        .name  = FIRST_CFI_MASKs,  /* FIRST_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FIRST_CFI.",
    },
    {
        .name  = SECOND_VLAN_IDs,  /* SECOND_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Second VLAN ID.",
    },
    {
        .name  = SECOND_VLAN_ID_MASKs,  /* SECOND_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for SECOND_VLAN_ID.",
    },
    {
        .name  = SECOND_PRIs,  /* SECOND_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Second VLAN priority.",
    },
    {
        .name  = SECOND_PRI_MASKs,  /* SECOND_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for SECOND_PRI.",
    },
    {
        .name  = SECOND_CFIs,  /* SECOND_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Second VLAN CFI.",
    },
    {
        .name  = SECOND_CFI_MASKs,  /* SECOND_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SECOND_CFI.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_UPPER_MASKs,  /* SRC_IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for SRC_IPV6_UPPER.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_LOWER_MASKs,  /* SRC_IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for SRC_IPV6_LOWER.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_UPPER_MASKs,  /* DST_IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for DST_IPV6_UPPER.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWER_MASKs,  /* DST_IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for DST_IPV6_LOWER.",
    },
    {
        .name  = PROTOCOL_NUMBERs,  /* PROTOCOL_NUMBER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Internet protocol number.",
    },
    {
        .name  = PROTOCOL_NUMBER_MASKs,  /* PROTOCOL_NUMBER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PROTOCOL_NUMBER.",
    },
    {
        .name  = TCP_SRC_PORTs,  /* TCP_SRC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "TCP source port.",
    },
    {
        .name  = TCP_SRC_PORT_MASKs,  /* TCP_SRC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for TCP_SRC_PORT.",
    },
    {
        .name  = TCP_DST_PORTs,  /* TCP_DST_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "TCP destination port.",
    },
    {
        .name  = TCP_DST_PORT_MASKs,  /* TCP_DST_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for TCP_DST_PORT.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after TCP destination port.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_tcp_over_ipv6_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_TCP_OVER_IPV6s, /* SEC_DECRYPT_SUBPORT_FLOW_TCP_OVER_IPV6 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 50,
    .field = bcmltd_sec_decrypt_subport_flow_tcp_over_ipv6_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_TCP_OVER_IPV6 table is used to identify\n a MACsec or an IPsec security entity (SecY) based on TCP over IPv6\n packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_UDP_OVER_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_udp_over_ipv4_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = SRC_MAC_MASKs,  /* SRC_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for SRC_MAC.",
    },
    {
        .name  = FIRST_VLAN_IDs,  /* FIRST_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "First VLAN ID.",
    },
    {
        .name  = FIRST_VLAN_ID_MASKs,  /* FIRST_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FIRST_VLAN_ID.",
    },
    {
        .name  = FIRST_PRIs,  /* FIRST_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "First VLAN priority.",
    },
    {
        .name  = FIRST_PRI_MASKs,  /* FIRST_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FIRST_PRI.",
    },
    {
        .name  = FIRST_CFIs,  /* FIRST_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "First VLAN CFI.",
    },
    {
        .name  = FIRST_CFI_MASKs,  /* FIRST_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FIRST_CFI.",
    },
    {
        .name  = SECOND_VLAN_IDs,  /* SECOND_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Second VLAN ID.",
    },
    {
        .name  = SECOND_VLAN_ID_MASKs,  /* SECOND_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for SECOND_VLAN_ID.",
    },
    {
        .name  = SECOND_PRIs,  /* SECOND_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Second VLAN priority.",
    },
    {
        .name  = SECOND_PRI_MASKs,  /* SECOND_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for SECOND_PRI.",
    },
    {
        .name  = SECOND_CFIs,  /* SECOND_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Second VLAN CFI.",
    },
    {
        .name  = SECOND_CFI_MASKs,  /* SECOND_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SECOND_CFI.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Source IPv4 address.",
    },
    {
        .name  = SRC_IPV4_MASKs,  /* SRC_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for SRC_IPV4.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Destination IPv4 address.",
    },
    {
        .name  = DST_IPV4_MASKs,  /* DST_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for DST_IPV4.",
    },
    {
        .name  = PROTOCOL_NUMBERs,  /* PROTOCOL_NUMBER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Internet protocol number.",
    },
    {
        .name  = PROTOCOL_NUMBER_MASKs,  /* PROTOCOL_NUMBER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PROTOCOL_NUMBER.",
    },
    {
        .name  = UDP_SRC_PORTs,  /* UDP_SRC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "UDP source port.",
    },
    {
        .name  = UDP_SRC_PORT_MASKs,  /* UDP_SRC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDP_SRC_PORT.",
    },
    {
        .name  = UDP_DST_PORTs,  /* UDP_DST_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "UDP destination port.",
    },
    {
        .name  = UDP_DST_PORT_MASKs,  /* UDP_DST_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDP_DST_PORT.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the UDP destination port.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_udp_over_ipv4_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_UDP_OVER_IPV4s, /* SEC_DECRYPT_SUBPORT_FLOW_UDP_OVER_IPV4 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 48,
    .field = bcmltd_sec_decrypt_subport_flow_udp_over_ipv4_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_UDP_OVER_IPV4 table is used to identify\n a MACsec or an IPsec security entity (SecY) based on UDP over IPv4\n packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_UDP_OVER_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_udp_over_ipv6_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = FIRST_VLAN_IDs,  /* FIRST_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "First VLAN ID.",
    },
    {
        .name  = FIRST_VLAN_ID_MASKs,  /* FIRST_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for FIRST_VLAN_ID.",
    },
    {
        .name  = FIRST_PRIs,  /* FIRST_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "First VLAN priority.",
    },
    {
        .name  = FIRST_PRI_MASKs,  /* FIRST_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for FIRST_PRI.",
    },
    {
        .name  = FIRST_CFIs,  /* FIRST_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "First VLAN CFI.",
    },
    {
        .name  = FIRST_CFI_MASKs,  /* FIRST_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FIRST_CFI.",
    },
    {
        .name  = SECOND_VLAN_IDs,  /* SECOND_VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Second VLAN ID.",
    },
    {
        .name  = SECOND_VLAN_ID_MASKs,  /* SECOND_VLAN_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for SECOND_VLAN_ID.",
    },
    {
        .name  = SECOND_PRIs,  /* SECOND_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Second VLAN priority.",
    },
    {
        .name  = SECOND_PRI_MASKs,  /* SECOND_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "MASK for SECOND_PRI.",
    },
    {
        .name  = SECOND_CFIs,  /* SECOND_CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Second VLAN CFI.",
    },
    {
        .name  = SECOND_CFI_MASKs,  /* SECOND_CFI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SECOND_CFI.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_UPPER_MASKs,  /* SRC_IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for SRC_IPV6_UPPER.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IPv6 address.",
    },
    {
        .name  = SRC_IPV6_LOWER_MASKs,  /* SRC_IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for SRC_IPV6_LOWER.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_UPPER_MASKs,  /* DST_IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for DST_IPV6_UPPER.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IPv6 address.",
    },
    {
        .name  = DST_IPV6_LOWER_MASKs,  /* DST_IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for DST_IPV6_LOWER.",
    },
    {
        .name  = PROTOCOL_NUMBERs,  /* PROTOCOL_NUMBER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Internet protocol number.",
    },
    {
        .name  = PROTOCOL_NUMBER_MASKs,  /* PROTOCOL_NUMBER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PROTOCOL_NUMBER.",
    },
    {
        .name  = UDP_SRC_PORTs,  /* UDP_SRC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "UDP source port.",
    },
    {
        .name  = UDP_SRC_PORT_MASKs,  /* UDP_SRC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDP_SRC_PORT.",
    },
    {
        .name  = UDP_DST_PORTs,  /* UDP_DST_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "UDP destination port.",
    },
    {
        .name  = UDP_DST_PORT_MASKs,  /* UDP_DST_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for UDP_DST_PORT.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the last defined field.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_udp_over_ipv6_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_UDP_OVER_IPV6s, /* SEC_DECRYPT_SUBPORT_FLOW_UDP_OVER_IPV6 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 50,
    .field = bcmltd_sec_decrypt_subport_flow_udp_over_ipv6_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_UDP_OVER_IPV6 table is used to identify\n a MACsec or an IPsec security entity (SecY) based on UDP over IPv6\n packet parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_FLOW_VNTAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_flow_vntag_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = NUM_VLAN_0s,  /* NUM_VLAN_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match zero VLAN tags.",
    },
    {
        .name  = NUM_VLAN_0_MASKs,  /* NUM_VLAN_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_0.",
    },
    {
        .name  = NUM_VLAN_1s,  /* NUM_VLAN_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match one VLAN tag.",
    },
    {
        .name  = NUM_VLAN_1_MASKs,  /* NUM_VLAN_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_1.",
    },
    {
        .name  = NUM_VLAN_2s,  /* NUM_VLAN_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match two VLAN tags.",
    },
    {
        .name  = NUM_VLAN_2_MASKs,  /* NUM_VLAN_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_2.",
    },
    {
        .name  = NUM_VLAN_3s,  /* NUM_VLAN_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match three VLAN tags.",
    },
    {
        .name  = NUM_VLAN_3_MASKs,  /* NUM_VLAN_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_3.",
    },
    {
        .name  = NUM_VLAN_4s,  /* NUM_VLAN_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match four VLAN tags.",
    },
    {
        .name  = NUM_VLAN_4_MASKs,  /* NUM_VLAN_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_4.",
    },
    {
        .name  = NUM_VLAN_5s,  /* NUM_VLAN_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match five or more VLAN tags.",
    },
    {
        .name  = NUM_VLAN_5_MASKs,  /* NUM_VLAN_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NUM_VLAN_5.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "Match on incoming SEC ports.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
    {
        .name  = DST_MAC_MASKs,  /* DST_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for DST_MAC.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address.",
    },
    {
        .name  = SRC_MAC_MASKs,  /* SRC_MAC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MASK for SRC_MAC.",
    },
    {
        .name  = PAYLOADs,  /* PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "Free form payload data after the last defined field.",
    },
    {
        .name  = PAYLOAD_MASKs,  /* PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 512,
        .depth = 0,
        .desc = "MASK for PAYLOAD.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "SEC_DECRYPT_SUBPORT_POLICY table index.",
    },
    {
        .name  = MANAGEMENT_PKTs,  /* MANAGEMENT_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify a management packet for the\n subport number. Default value identifies\n a data packet.\n",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to identify an IPsec packet for the\n SEC subport number. Default value identifies\n a MACsec packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_flow_vntag_t = {
    .name = SEC_DECRYPT_SUBPORT_FLOW_VNTAGs, /* SEC_DECRYPT_SUBPORT_FLOW_VNTAG */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 26,
    .field = bcmltd_sec_decrypt_subport_flow_vntag_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_FLOW_VNTAG table is used to identify\n or an IPsec security entity (SecY) based on VNTAG packet\n parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_DECRYPT_SUBPORT_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_decrypt_subport_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Security block index.",
    },
    {
        .name  = SEC_DECRYPT_SUBPORT_POLICY_IDs,  /* SEC_DECRYPT_SUBPORT_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the subport policy table.",
    },
    {
        .name  = SECURED_CONTROL_PORTs,  /* SECURED_CONTROL_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow secured data packets (packets with SecTAG)\n to be processed by SEC logic.\n",
    },
    {
        .name  = UNSECURED_DATA_MODEs,  /* UNSECURED_DATA_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CONTROLLED_PORT_MODE_T_DATA,
        .desc = "Control port mode for unsecured data packets.",
    },
    {
        .name  = TAG_VALIDATEs,  /* TAG_VALIDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TAGGED_PKT_VALIDATE_MODE_T_DATA,
        .desc = "Validation modes for secured packets.",
    },
    {
        .name  = DROP_IPV4_AND_MPLS_FAILURESs,  /* DROP_IPV4_AND_MPLS_FAILURES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop IPv4 checksum failure or MPLS bottom of\n stack not found packets if they are not copied to CPU.\n Applies to IPv4 secure data packets (with SecTAG) and\n secured/unsecured data packets.\n",
    },
    {
        .name  = POINT_TO_POINTs,  /* POINT_TO_POINT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to configure point to point mode. Used to derive\n the secure channel identifier (SCI) value from the policy table.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = SCIs,  /* SCI */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "The SCI value to be used in point to point mode.\n Applicable when SCI cannot be derived based on SC, ES and\n ESB bits in SecTAG.\n Applicable only for MACsec packets.\n Applicable only if POINT_TO_POINT == TRUE;\n",
    },
    {
        .name  = MTUs,  /* MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The maximum transmission unit (MTU) value used to check\n decrypt packets. A packet will be marked as error if\n its size is greater than MTU.\n",
    },
    {
        .name  = CUSTOM_PROTOCOLs,  /* CUSTOM_PROTOCOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the subport (SecY) is carrying a custom\n protocol. SecTAG location will then be specified by\n SECTAG_OFFSET_BYTES.\n",
    },
    {
        .name  = SECTAG_OFFSET_BYTESs,  /* SECTAG_OFFSET_BYTES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The location of SecTAG in terms of number of bytes before\n SecTAG. If SecTAG is not found, the packet is treated\n as a non-MACsec packet.\n Used by parser when SecTAG location cannot be determined based\n on defined packet formats.\n Applicable only for MACsec packets.\n Applicable if CUSTOM_PROTOCL == TRUE.\n",
    },
    {
        .name  = SEC_MACSEC_SECTAG_ETHERTYPE_IDs,  /* SEC_MACSEC_SECTAG_ETHERTYPE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "SEC_MACSEC_SECTAG_ETHERTYPE table index. The ethertype is used\n to identify the MacSec SecTAG.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = INNER_DST_MACs,  /* INNER_DST_MAC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the inner destination MAC address and\n the inner source MAC address are valid and in the clear.\n Also indicates they are present before SecTAG.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = INNER_DST_MAC_OFFSET_BYTESs,  /* INNER_DST_MAC_OFFSET_BYTES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The location of inner destination MAC address in terms of\n number of bytes before the inner destination MAC address.\n Applicable only if INNER_DST_MAC is valid.\n Value must be less than SECTAG_OFFSET_BYTES if applicable.\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = ADJUST_SECTAGs,  /* ADJUST_SECTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add bytes to SECTAG_OFFSET_BYTES based on the number\n of outer VLAN tags or MPLS labels. A maximum of 4 VLAN tags\n or 4 MPLS labels are supported. The SECTAG_OFFSET_BYTES is\n adjusted based on the following formula:\n New SECTAG_OFFSET_BYTES = SECTAG_OFFSET_BYTES +\n (4 bytes * (Number of VLAN tags or MPLS labels)).\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = ADJUST_INNER_DST_MAC_OFFSETs,  /* ADJUST_INNER_DST_MAC_OFFSET */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add bytes to INNER_DST_MAC_OFFSET_BYTES based on the\n number of outer VLAN tags or MPLS labels. A maximum of 4 VLAN tags\n or 4 MPLS labels are supported. The INNER_DST_MAC_OFFSET_BYTES is\n adjusted based on the following formula:\n New INNER_DST_MAC_OFFSET_BYTES = INNER_DST_MAC_OFFSET_BYTES +\n (4 bytes * (Number of VLAN tags or MPLS labels)).\n Applicable only for MACsec packets.\n",
    },
    {
        .name  = ESP_OFFSET_BYTESs,  /* ESP_OFFSET_BYTES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The location of ESP header in terms of number of bytes before\n the header.\n Applicable only if SECTAG_OFFSET_BYTES is not configured.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = OUTER_IPs,  /* OUTER_IP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to configure the location of outer IP offset using\n OUTER_IP_OFFSET.\n Applicable only if INNER_DST_MAC is not configured.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = OUTER_IP_OFFSET_BYTESs,  /* OUTER_IP_OFFSET_BYTES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The location of outer IP header in terms of\n number of bytes before the IP header.\n Applicable only if OUTER_IP is valid.\n Programmed value should be an even number and should be\n less than 92 for IPv4 and 72 for IPv6 header.\n Applicable only if INNER_DST_MAC_OFFSET_BYTES is not configured.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = ADJUST_ESPs,  /* ADJUST_ESP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add bytes to ESP_OFFSET_BYTES based on the number\n of outer VLAN tags or MPLS labels. A maximum of 4 VLAN tags\n or 4 MPLS labels are supported. The ESP_OFFSET_BYTES is\n adjusted based on the following formula:\n New ESP_OFFSET_BYTES =\n ESP_OFFSET_BYTES +\n (4 bytes * (Number of VLAN tags or MPLS labels)).\n Applicable only if SECTAG_OFFSET_BYTES is not configured.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = ADJUST_OUTER_IP_OFFSETs,  /* ADJUST_OUTER_IP_OFFSET */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add bytes to OUTER_IP_OFFSET_BYTES based on the\n number of outer VLAN tags or MPLS labels. A maximum of 4 VLAN tags\n or 4 MPLS labels are supported. The OUTER_IP_OFFSET_BYTES is\n adjusted based on the following formula:\n New OUTER_IP_OFFSET_BYTES =\n OUTER_IP_OFFSET_BYTES +\n (4 bytes * (Number of VLAN tags or MPLS labels)).\n Applicable only if ADJUST_INNER_DST_MAC_OFFSET is not configured.\n Applicable only for IP packets.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_decrypt_subport_policy_t = {
    .name = SEC_DECRYPT_SUBPORT_POLICYs, /* SEC_DECRYPT_SUBPORT_POLICY */
    .flags = 0,
    .fields = 21,
    .field = bcmltd_sec_decrypt_subport_policy_t_fields,
    .desc = "The SEC_DECRYPT_SUBPORT_POLICY table is used to program the various\n controls for the MACsec and IPsec subport. Each subport may represent a\n MACsec entity (SecY).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_ENCRYPT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_encrypt_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SVTAG_ETHERTYPEs,  /* SVTAG_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Custom L2 header (SVTAG) ethertype.",
    },
    {
        .name  = SVTAG_ETHERTYPE_MASKs,  /* SVTAG_ETHERTYPE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Custom L2 header (SVTAG) ethertype mask.",
    },
    {
        .name  = MANAGEMENT_MTUs,  /* MANAGEMENT_MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Management packet MTU. Packet will be marked as error if\n the size is greater than the configured MTU.\n",
    },
    {
        .name  = PN_EXPIRE_THDs,  /* PN_EXPIRE_THD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Threshold for triggering soft packet number expiry.\n The SEC_ENCRYPT_MACSEC_SA_POLICY_STATUS table reflects the\n state of the expiry.\n Applicable only when one of the following is true:\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE == CIPHER_GCM_AES_128\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE == CIPHER_GCM_AES_256\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE == CIPHER_GCM_AES_128\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE == CIPHER_GCM_AES_256\n",
    },
    {
        .name  = XPN_EXPIRE_THDs,  /* XPN_EXPIRE_THD */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Threshold for triggering soft extended packet number expiry.\n The SEC_ENCRYPT_MACSEC_SA_POLICY_STATUS table reflects the\n state of the expiry.\n Applicable only when one of the following is true:\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n To be used along with SEC_ENCRYPT_THD_MASK table.\n",
    },
    {
        .name  = INCREMENT_PADDINGs,  /* INCREMENT_PADDING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to configure IPsec padding bytes as a\n monotonically incrementing sequence with the first\n byte appended as 1.\n Applicable only for IPsec packets.\n",
    },
    {
        .name  = NH_DUMMYs,  /* NH_DUMMY */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Value populated in the next hop (NH) field of the ESP trailer\n in the encrypt direction. Applicable only if the\n following conditions are true:\n     1. Packet is of type IPsec.\n     2. Inner IP version number is neither IPv4 nor IPv6.\n     3. SVTAG.Dummy bit is not set.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_encrypt_t = {
    .name = SEC_ENCRYPTs, /* SEC_ENCRYPT */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_sec_encrypt_t_fields,
    .desc = "The SEC_ENCRYPT table specifies the\n MACsec and IPsec controls in the encrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_ENCRYPT_IPSEC_SA_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_encrypt_ipsec_sa_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_ENCRYPT_IPSEC_SA_POLICY_IDs,  /* SEC_ENCRYPT_IPSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the encrypt security association.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SA_STATE_CONTROL_T_DATA,
        .desc = "Security association state.",
    },
    {
        .name  = INITIAL_PKT_NUMBERs,  /* INITIAL_PKT_NUMBER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "The packet sequence number. The higher 32-bits are\n applicable only when one of the following is true:\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = SECURITY_PARAMETER_INDEXs,  /* SECURITY_PARAMETER_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The security parameter index (SPI) value that gets\n inserted into the IPsec header.\n",
    },
    {
        .name  = XPN_SALTs,  /* XPN_SALT */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "The XPN salt parameter for IPsec.\n Applicable only when one of the following is true:\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = KEYs,  /* KEY */
        .flags = 0,
        .width = 8,
        .depth = 32,
        .desc = "The key used for encryption. The upper 16 bytes are\n applicable only when one of the following is true:\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = NEXT_PKT_NUMBERs,  /* NEXT_PKT_NUMBER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Read only field indicating the next packet number inserted\n in the SecTag.\n",
    },
    {
        .name  = IN_USE_START_TIMEs,  /* IN_USE_START_TIME */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read only field indicating the system time when\n the SA started receiving IPsec frames.\n",
    },
    {
        .name  = IN_USE_STOP_TIMEs,  /* IN_USE_STOP_TIME */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read only field indicating the system time when\n the SA stopped receiving IPsec frames.\n",
    },
    {
        .name  = IN_USEs,  /* IN_USE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Read only field indicating that the SA is in use.",
    },
};
const bcmltd_table_rep_t bcmltd_sec_encrypt_ipsec_sa_policy_t = {
    .name = SEC_ENCRYPT_IPSEC_SA_POLICYs, /* SEC_ENCRYPT_IPSEC_SA_POLICY */
    .flags = 0,
    .fields = 11,
    .field = bcmltd_sec_encrypt_ipsec_sa_policy_t_fields,
    .desc = "The SEC_ENCRYPT_IPSEC_SA_POLICY table provisions an\n IPsec security association in the encrypt direction.\n The security association is a combination of\n secure channel index and association number.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_ENCRYPT_IPSEC_SA_POLICY_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_encrypt_ipsec_sa_policy_status_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_ENCRYPT_IPSEC_SA_POLICY_IDs,  /* SEC_ENCRYPT_IPSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "SEC_ENCRYPT_IPSEC_SA_POLICY table index.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SA_STATE_T_DATA,
        .desc = "Security association state.",
    },
};
const bcmltd_table_rep_t bcmltd_sec_encrypt_ipsec_sa_policy_status_t = {
    .name = SEC_ENCRYPT_IPSEC_SA_POLICY_STATUSs, /* SEC_ENCRYPT_IPSEC_SA_POLICY_STATUS */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_sec_encrypt_ipsec_sa_policy_status_t_fields,
    .desc = "The SEC_ENCRYPT_IPSEC_SA_POLICY_STATUS table provides the\n status of the security association in the encrypt direction.\n Application can subscribe to the table to get status change\n notification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_ENCRYPT_IPSEC_SC_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_encrypt_ipsec_sc_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Security block table index.",
    },
    {
        .name  = SEC_ENCRYPT_IPSEC_SC_POLICY_IDs,  /* SEC_ENCRYPT_IPSEC_SC_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the encrypt secure channel.",
    },
    {
        .name  = SEC_ENCRYPT_THD_MASK_IDs,  /* SEC_ENCRYPT_THD_MASK_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Soft expiry threshold mask profile select.",
    },
    {
        .name  = DROP_INVALID_SA_PKTSs,  /* DROP_INVALID_SA_PKTS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = VXLAN_PKT_TYPEs,  /* VXLAN_PKT_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_VXLAN_PKT_TYPE_T_DATA,
        .desc = "Indicate the L3 and L4 type for a secured VXLAN packet.\n The position of destination port number and length fields\n are identified based on the packet type.\n",
    },
    {
        .name  = VXLAN_HEADER_UPDATEs,  /* VXLAN_HEADER_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_VXLAN_HEADER_UPDATE_T_DATA,
        .desc = "",
    },
    {
        .name  = MTUs,  /* MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum transmission unit of the channel.",
    },
    {
        .name  = MPLS_MARK_BOSs,  /* MPLS_MARK_BOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to mark bottom of stack for an MPLS packet.",
    },
    {
        .name  = CIPHER_SUITEs,  /* CIPHER_SUITE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CIPHER_SUITE_T_DATA,
        .desc = "Encryption standard to use for the channel.",
    },
    {
        .name  = VXLAN_PKT_ADJUST_FOR_SVTAGs,  /* VXLAN_PKT_ADJUST_FOR_SVTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add the offset extracted from the custom L2 header\n (SVTAG) to the L3 and L4 header positions.\n Applicable only for secured VXLAN packets.\n",
    },
    {
        .name  = ESP_OFFSET_ADJUST_FOR_SVTAGs,  /* ESP_OFFSET_ADJUST_FOR_SVTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add the offset extracted from SVTAG to\n ESP_OFFSET_BYTES.\n",
    },
    {
        .name  = ESP_OFFSET_BYTESs,  /* ESP_OFFSET_BYTES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of bytes from the start of frame after which the ESP\n header is inserted.\n",
    },
    {
        .name  = SECURED_DATA_MODEs,  /* SECURED_DATA_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CONTROLLED_PORT_MODE_T_DATA,
        .desc = "Select the forwarding behavior of the secured data packet for the\n secure channel.\n Applicable only if PROTECT_FRAMES == TRUE.\n",
    },
    {
        .name  = UNSECURED_DATA_MODEs,  /* UNSECURED_DATA_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CONTROLLED_PORT_MODE_T_DATA,
        .desc = "Select the forwarding behavior of the unsecured data packet\n for the secure channel.\n Applicable only if PROTECT_FRAMES == TRUE.\n",
    },
    {
        .name  = PROTECT_FRAMESs,  /* PROTECT_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encrypt or authenticate all egress data packets.\n Default is to bypass the SEC engine and not account the packets.\n",
    },
    {
        .name  = UDPs,  /* UDP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow UDP packets on the secure channel.",
    },
    {
        .name  = TCPs,  /* TCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow TCP packets on the secure channel.",
    },
};
const bcmltd_table_rep_t bcmltd_sec_encrypt_ipsec_sc_policy_t = {
    .name = SEC_ENCRYPT_IPSEC_SC_POLICYs, /* SEC_ENCRYPT_IPSEC_SC_POLICY */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_sec_encrypt_ipsec_sc_policy_t_fields,
    .desc = "The SEC_ENCRYPT_IPSEC_SC_POLICY table provisions an IPsec\n secure channel in the encrypt direction.\n Each IPsec secure channel is associated with one IPsec security\n association.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_ENCRYPT_MACSEC_SA_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_encrypt_macsec_sa_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_ENCRYPT_MACSEC_SA_POLICY_IDs,  /* SEC_ENCRYPT_MACSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the encrypt security association.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SA_STATE_CONTROL_T_DATA,
        .desc = "Security association state.",
    },
    {
        .name  = NEW_ACTIVE_ANs,  /* NEW_ACTIVE_AN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The value of AN field in SecTAG to be overwritten with.\n Applicable only when SEC_BLOCK.NUM_SA_PER_SC_ENCRYPT == ONE.\n Default is to set 0 in SecTAG.AN.\n",
    },
    {
        .name  = INITIAL_PKT_NUMBERs,  /* INITIAL_PKT_NUMBER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Packet sequence number. The upper 32-bits are\n applicable only when one of the following is true:\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = SHORT_SC_IDENTIFIERs,  /* SHORT_SC_IDENTIFIER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Short secure channel identifier (SSCI) for an XPN cipher.\n SSCI is unique for each secure channel.\n Applicable only when one of the following is true:\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = XPN_SALTs,  /* XPN_SALT */
        .flags = 0,
        .width = 8,
        .depth = 12,
        .desc = "The XPN salt parameter for MACsec.\n Applicable only when one of the following is true:\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = KEYs,  /* KEY */
        .flags = 0,
        .width = 8,
        .depth = 32,
        .desc = "Encryption key. The upper 16 bytes are\n Applicable only when one of the following is true:\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n",
    },
    {
        .name  = NEXT_PKT_NUMBERs,  /* NEXT_PKT_NUMBER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Read-only field indicating the next packet number to be\n inserted in the SecTag.\n",
    },
    {
        .name  = IN_USEs,  /* IN_USE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Read only field indicating that the SA is in use.",
    },
    {
        .name  = IN_USE_START_TIMEs,  /* IN_USE_START_TIME */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read only field indicating the system time when\n the SA started transmitting MACsec frames.\n",
    },
    {
        .name  = IN_USE_STOP_TIMEs,  /* IN_USE_STOP_TIME */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read only field indicating the system time when\n the SA stopped transmitting MACsec frames.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_encrypt_macsec_sa_policy_t = {
    .name = SEC_ENCRYPT_MACSEC_SA_POLICYs, /* SEC_ENCRYPT_MACSEC_SA_POLICY */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_sec_encrypt_macsec_sa_policy_t_fields,
    .desc = "The SEC_ENCRYPT_MACSEC_SA_POLICY table provisions a MACsec\n security association in the encrypt direction.\n The security association is a combination of\n secure channel index and association number.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_ENCRYPT_MACSEC_SA_POLICY_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_encrypt_macsec_sa_policy_status_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_ENCRYPT_MACSEC_SA_POLICY_IDs,  /* SEC_ENCRYPT_MACSEC_SA_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the encrypt security association.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SA_STATE_T_DATA,
        .desc = "Security association state.",
    },
};
const bcmltd_table_rep_t bcmltd_sec_encrypt_macsec_sa_policy_status_t = {
    .name = SEC_ENCRYPT_MACSEC_SA_POLICY_STATUSs, /* SEC_ENCRYPT_MACSEC_SA_POLICY_STATUS */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_sec_encrypt_macsec_sa_policy_status_t_fields,
    .desc = "The SEC_ENCRYPT_MACSEC_SA_POLICY_STATUS table\n provides the status of the security association in the encrypt direction.\n Application can subscribe to the table to get status change notification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_ENCRYPT_MACSEC_SC_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_encrypt_macsec_sc_policy_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Security block table index.",
    },
    {
        .name  = SEC_ENCRYPT_MACSEC_SC_POLICY_IDs,  /* SEC_ENCRYPT_MACSEC_SC_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the encrypt secure channel.",
    },
    {
        .name  = ACTIVE_ANs,  /* ACTIVE_AN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The active association number (AN) that is placed\n into the SecTAG. This field can be updated by hardware.\n",
    },
    {
        .name  = SEC_ENCRYPT_THD_MASK_IDs,  /* SEC_ENCRYPT_THD_MASK_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Soft expiry threshold mask profile select.",
    },
    {
        .name  = DROP_INVALID_SA_PKTSs,  /* DROP_INVALID_SA_PKTS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "",
    },
    {
        .name  = VXLAN_PKT_TYPEs,  /* VXLAN_PKT_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_VXLAN_PKT_TYPE_T_DATA,
        .desc = "Indicate the L3 and L4 type for a secured VXLAN packet.\n The position of destination port number and length fields\n are identified based on the packet type.\n",
    },
    {
        .name  = VXLAN_HEADER_UPDATEs,  /* VXLAN_HEADER_UPDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_VXLAN_HEADER_UPDATE_T_DATA,
        .desc = "",
    },
    {
        .name  = AN_CONTROL_MODEs,  /* AN_CONTROL_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_AN_MACSEC_CONTROL_MODE_T_DATA,
        .desc = "AN expiry control mode for the channel.",
    },
    {
        .name  = SEC_MACSEC_SECTAG_ETHERTYPE_IDs,  /* SEC_MACSEC_SECTAG_ETHERTYPE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "SEC_MACSEC_SECTAG_ETHERTYPE table index.",
    },
    {
        .name  = MTUs,  /* MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum transmission unit of the channel.",
    },
    {
        .name  = SC_IDENTIFIERs,  /* SC_IDENTIFIER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The secure channel identifier (SCI) value that gets\n inserted into the sectag. Applicable only if\n SECTAG_TCI_SCI_PRESENT is enabled.\n",
    },
    {
        .name  = CIPHER_SUITEs,  /* CIPHER_SUITE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CIPHER_SUITE_T_DATA,
        .desc = "Encryption standard to use for the channel.",
    },
    {
        .name  = PRE_SECTAG_AUTHs,  /* PRE_SECTAG_AUTH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to selectively authenticate bytes preceding the\n sectag. Default is to encrypt all bytes prior to sectag.\n",
    },
    {
        .name  = PRE_SECTAG_AUTH_STARTs,  /* PRE_SECTAG_AUTH_START */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Start byte for selective authentication.\n Applicable only if PRE_SECTAG_AUTH is enabled.\n The value should be less than the actual sectag offset.\n",
    },
    {
        .name  = PRE_SECTAG_AUTH_ENDs,  /* PRE_SECTAG_AUTH_END */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "End byte for selective authentication.\n Applicable only if PRE_SECTAG_AUTH is enabled.\n The following restrictions apply:\n The value should be less than the actual sectag offset and\n should be greater than PRE_SECTAG_AUTH_START.\n PRE_SECTAG_AUTH_START and PRE_SECTAG_AUTH_END\n may be configured to 0 to exclude all bytes before sectag from\n authentication.\n Invalid values may result in undefined hardware behavior.\n",
    },
    {
        .name  = MPLS_MARK_BOSs,  /* MPLS_MARK_BOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to mark bottom of stack for an MPLS packet.",
    },
    {
        .name  = SECTAG_SHORT_LENGTHs,  /* SECTAG_SHORT_LENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Short length (SL) field of sectag.",
    },
    {
        .name  = SECTAG_TCI_VERSIONs,  /* SECTAG_TCI_VERSION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Tag control information version (TCI.V) field of sectag.",
    },
    {
        .name  = SECTAG_TCI_END_STATIONs,  /* SECTAG_TCI_END_STATION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Tag control information end station (TCI.ES) field of sectag.",
    },
    {
        .name  = SECTAG_TCI_SINGLE_COPY_BROADCASTs,  /* SECTAG_TCI_SINGLE_COPY_BROADCAST */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Tag control information single copy broadcast (TCI.SCB)\n field of sectag.\n",
    },
    {
        .name  = SECTAG_TCI_CHANGED_TEXTs,  /* SECTAG_TCI_CHANGED_TEXT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Tag control information changed text (TCI.C) field of sectag.",
    },
    {
        .name  = SECTAG_TCI_SCI_PRESENTs,  /* SECTAG_TCI_SCI_PRESENT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Tag control information SCI present (TCI.SC) field of sectag.",
    },
    {
        .name  = SECTAG_TCI_ENCRYPTs,  /* SECTAG_TCI_ENCRYPT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Tag control information encrypt (TCI.E) field of sectag.",
    },
    {
        .name  = DERIVE_PKT_TYPE_FROM_SVTAGs,  /* DERIVE_PKT_TYPE_FROM_SVTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to derive packet type from SVTAG.IPV6_PKT.\n Default is to derive it from VXLAN_PKT_TYPE.\n",
    },
    {
        .name  = PROTECT_FRAMESs,  /* PROTECT_FRAMES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to encrypt or authenticate all egress data packets.\n Default is to bypass the SEC engine and not account the packets\n in MIB.\n",
    },
    {
        .name  = VXLAN_PKT_ADJUST_FOR_SVTAGs,  /* VXLAN_PKT_ADJUST_FOR_SVTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add the offset extracted from the custom L2 header\n (SVTAG) to the L3 and L4 header positions.\n Dependent on VXLAN_PKT_TYPE.\n Applicable only for secured VXLAN packets.\n",
    },
    {
        .name  = PRE_SECTAG_AUTH_START_ADJUST_FOR_SVTAGs,  /* PRE_SECTAG_AUTH_START_ADJUST_FOR_SVTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add the offset extracted from SVTAG to\n PRE_SECTAG_AUTH_START.\n",
    },
    {
        .name  = PRE_SECTAG_AUTH_END_ADJUST_FOR_SVTAGs,  /* PRE_SECTAG_AUTH_END_ADJUST_FOR_SVTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add the offset extracted from SVTAG to\n PRE_SECTAG_AUTH_END.\n Restrictions described in PRE_SECTAG_AUTH_START are\n applicable in the hardware after SVTAG offset addition.\n Hardware behavior is undefined if validation fails.\n",
    },
    {
        .name  = SECTAG_OFFSET_ADJUST_FOR_SVTAGs,  /* SECTAG_OFFSET_ADJUST_FOR_SVTAG */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add the offset extracted from SVTAG to\n SECTAG_OFFSET_BYTES.\n",
    },
    {
        .name  = SECTAG_OFFSET_BYTESs,  /* SECTAG_OFFSET_BYTES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of bytes from the start of frame after which sectag\n is inserted.\n (SECTAG_OFFSET_BYTES + sectag length +\n CONFIDENTIALITY_OFFSET_BYTES)<= 192.\n",
    },
    {
        .name  = CONFIDENTIALITY_OFFSET_BYTESs,  /* CONFIDENTIALITY_OFFSET_BYTES */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of bytes from the start of sectag after which\n encryption starts.\n The following restriction applies:\n (SECTAG_OFFSET_BYTES + sectag length +\n CONFIDENTIALITY_OFFSET_BYTES)<= 192.\n",
    },
    {
        .name  = SECURED_DATA_MODEs,  /* SECURED_DATA_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CONTROLLED_PORT_MODE_T_DATA,
        .desc = "Select the forwarding behavior of the secured data packet for the\n secure channel.\n",
    },
    {
        .name  = UNSECURED_DATA_MODEs,  /* UNSECURED_DATA_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_CONTROLLED_PORT_MODE_T_DATA,
        .desc = "Select the forwarding behavior of the unsecured data packet\n for the secure channel.\n",
    },
    {
        .name  = UDPs,  /* UDP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow UDP packets on the secure channel.",
    },
    {
        .name  = TCPs,  /* TCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow TCP packets on the secure channel.",
    },
};
const bcmltd_table_rep_t bcmltd_sec_encrypt_macsec_sc_policy_t = {
    .name = SEC_ENCRYPT_MACSEC_SC_POLICYs, /* SEC_ENCRYPT_MACSEC_SC_POLICY */
    .flags = 0,
    .fields = 35,
    .field = bcmltd_sec_encrypt_macsec_sc_policy_t_fields,
    .desc = "The SEC_ENCRYPT_MACSEC_SC_POLICY table provisions a MACsec\n secure channel in the encrypt direction.\n An encrypt secure channel may represent a SecY entity.\n A SecY is a MAC security entity which is responsible to protect\n the data packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_ENCRYPT_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_encrypt_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID",
    },
    {
        .name  = PORT_BASED_SCs,  /* PORT_BASED_SC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to derive secure channel (SC) index from the\n outgoing MACsec port number. The MACsec subport number\n provided in the SVTAG is ignored.\n In the default case, the SC is derived from the MS_SUBPORT\n field in the SVTAG.\n",
    },
    {
        .name  = REMOVE_CRCs,  /* REMOVE_CRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to remove the CRC in a packet received from the egress\n pipeline before processing it in the security engine.\n",
    },
    {
        .name  = TX_THRESHOLD_CELLSs,  /* TX_THRESHOLD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of 64-byte cells that are buffered per packet\n in the egress output FIFO before transmitting the packet.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SEC_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_encrypt_port_t = {
    .name = SEC_ENCRYPT_PORTs, /* SEC_ENCRYPT_PORT */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_sec_encrypt_port_t_fields,
    .desc = "The SEC_ENCRYPT_PORT table specifies the per\n port MACsec and IPsec controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_ENCRYPT_THD_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_encrypt_thd_mask_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_ENCRYPT_THD_MASK_IDs,  /* SEC_ENCRYPT_THD_MASK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the threshold mask profile table.",
    },
    {
        .name  = XPN_EXPIRE_THD_MASK_LENs,  /* XPN_EXPIRE_THD_MASK_LEN */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Threshold mask length indicating which bits of\n SEC_ENCRYPT.XPN_EXPIRE_THD will be used to\n identify the extended packet number expiry.\n Applicable only when one of the following is true:\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_MACSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_128\n SEC_ENCRYPT_IPSEC_SC_POLICY.CIPHER_SUITE ==\n                    CIPHER_GCM_AES_XPN_256\n The mask is calculated based on the formula\n (2 ^ XPN_EXPIRE_THD_MASK_LEN) - 1.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_encrypt_thd_mask_t = {
    .name = SEC_ENCRYPT_THD_MASKs, /* SEC_ENCRYPT_THD_MASK */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_sec_encrypt_thd_mask_t_fields,
    .desc = "The SEC_ENCRYPT_THD_MASK table specifies the threshold\n mask for the encryption packet number.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_MACSEC_SECTAG_ETHERTYPE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_macsec_sectag_ethertype_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_MACSEC_SECTAG_ETHERTYPE_IDs,  /* SEC_MACSEC_SECTAG_ETHERTYPE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the SecTAG ethertype table.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "SecTAG ethertype.",
    },
};
const bcmltd_table_rep_t bcmltd_sec_macsec_sectag_ethertype_t = {
    .name = SEC_MACSEC_SECTAG_ETHERTYPEs, /* SEC_MACSEC_SECTAG_ETHERTYPE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_sec_macsec_sectag_ethertype_t_fields,
    .desc = "The SEC_MACSEC_SECTAG_ETHERTYPE table specifies\n the SecTAG ethertype.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_PC_PM.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_pc_pm_t_fields[] = {
    {
        .name  = PC_PM_IDs,  /* PC_PM_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Port macro ID",
    },
    {
        .name  = SECs,  /* SEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MACsec/IPsec on the port macro (PM). Note, if the PM is\n paired with another PM for an SEC block, only one\n can be enabled.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SEC_PM_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry. The OPERATIONAL_STATE becomes invalid if\n the SEC is enabled on the port macro pair.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_pc_pm_t = {
    .name = SEC_PC_PMs, /* SEC_PC_PM */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_sec_pc_pm_t_fields,
    .desc = "The SEC_PC_PM table specifies the per port macro\n configuration.\n It is recommended to configure the LT before a PC_PORT configuration\n and not to modify it once the mapping is applied.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_PORT_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_port_info_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID",
    },
    {
        .name  = SECs,  /* SEC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicates whether MACsec or IPsec is enabled on the port.",
    },
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "SEC_BLOCK table index. Applicable only if SEC is enabled.",
    },
    {
        .name  = SEC_PORT_NUMs,  /* SEC_PORT_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Security block port number that the logical port maps to.\n Applicable only if SEC is enabled.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SEC_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_sec_port_info_t = {
    .name = SEC_PORT_INFOs, /* SEC_PORT_INFO */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_sec_port_info_t_fields,
    .desc = "The SEC_PORT_INFO is a read-only table which provides per port\n SEC information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/sec/SEC_SVTAG_CPU_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_sec_svtag_cpu_map_t_fields[] = {
    {
        .name  = SEC_BLOCK_IDs,  /* SEC_BLOCK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the security block.",
    },
    {
        .name  = SEC_BLOCK_ID_MASKs,  /* SEC_BLOCK_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for SEC_BLOCK_ID.",
    },
    {
        .name  = INGRESS_SEC_PORTs,  /* INGRESS_SEC_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "SEC port ID.",
    },
    {
        .name  = INGRESS_SEC_PORT_MASKs,  /* INGRESS_SEC_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 16,
        .desc = "MASK for INGRESS_SEC_PORT.",
    },
    {
        .name  = UNKNOWN_SUB_PORTs,  /* UNKNOWN_SUB_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Packet with unknown sub port.",
    },
    {
        .name  = UNKNOWN_SUB_PORT_MASKs,  /* UNKNOWN_SUB_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for UNKNOWN_SUB_PORT.",
    },
    {
        .name  = INVALID_SECURED_CONTROL_PORTs,  /* INVALID_SECURED_CONTROL_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Secured control port packet with secured\n control port disabled.\n",
    },
    {
        .name  = INVALID_SECURED_CONTROL_PORT_MASKs,  /* INVALID_SECURED_CONTROL_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for INVALID_SECURED_CONTROL_PORT.",
    },
    {
        .name  = INVALID_UNSECURED_CONTROL_PORTs,  /* INVALID_UNSECURED_CONTROL_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Unsecured control port packet with unsecured\n control port disabled.\n",
    },
    {
        .name  = INVALID_UNSECURED_CONTROL_PORT_MASKs,  /* INVALID_UNSECURED_CONTROL_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for INVALID_UNSECURED_CONTROL_PORT.",
    },
    {
        .name  = IPV4_CKSUM_MPLS_BOSs,  /* IPV4_CKSUM_MPLS_BOS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "IPv4 checksum failed secured IPv4 data packets or\n MPLS BOS not found within 4 labels.\n",
    },
    {
        .name  = IPV4_CKSUM_MPLS_BOS_MASKs,  /* IPV4_CKSUM_MPLS_BOS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for IPV4_CKSUM_MPLS_BOS.",
    },
    {
        .name  = INVALID_SECTAGs,  /* INVALID_SECTAG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Packet with invalid SecTAG.",
    },
    {
        .name  = INVALID_SECTAG_MASKs,  /* INVALID_SECTAG_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for INVALID_SECTAG.",
    },
    {
        .name  = UNKNOWN_SCs,  /* UNKNOWN_SC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Packet with secure channel not found.",
    },
    {
        .name  = UNKNOWN_SC_MASKs,  /* UNKNOWN_SC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for UNKNOWN_SC.",
    },
    {
        .name  = UNKNOWN_SAs,  /* UNKNOWN_SA */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Packet with security association not found.",
    },
    {
        .name  = UNKNOWN_SA_MASKs,  /* UNKNOWN_SA_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for UNKNOWN_SA.",
    },
    {
        .name  = REPLAY_PROTECTION_FAILEDs,  /* REPLAY_PROTECTION_FAILED */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Packet with replay protection failed.",
    },
    {
        .name  = REPLAY_PROTECTION_FAILED_MASKs,  /* REPLAY_PROTECTION_FAILED_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for REPLAY_PROTECTION_FAILED.",
    },
    {
        .name  = SVTAG_PKT_TYPEs,  /* SVTAG_PKT_TYPE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_SEC_SVTAG_PKT_T_DATA,
        .desc = "SVTAG packet type.",
    },
    {
        .name  = SVTAG_PKT_TYPE_MASKs,  /* SVTAG_PKT_TYPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for SVTAG_PKT_TYPE.",
    },
    {
        .name  = NAT_KEEPALIVEs,  /* NAT_KEEPALIVE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "NAT keepalive packet.",
    },
    {
        .name  = NAT_KEEPALIVE_MASKs,  /* NAT_KEEPALIVE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NAT_KEEPALIVE.",
    },
    {
        .name  = IPSECs,  /* IPSEC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "IPsec packet.",
    },
    {
        .name  = IPSEC_MASKs,  /* IPSEC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for IPSEC.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
};
const bcmltd_table_rep_t bcmltd_sec_svtag_cpu_map_t = {
    .name = SEC_SVTAG_CPU_MAPs, /* SEC_SVTAG_CPU_MAP */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 27,
    .field = bcmltd_sec_svtag_cpu_map_t_fields,
    .desc = "The SEC_SVTAG_CPU_MAP table specifies the\n controls which marks the packets as copy to CPU\n in the decrypt direction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ser/SER_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ser_config_t_fields[] = {
    {
        .name  = SER_ENABLEs,  /* SER_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable SER checking.",
    },
    {
        .name  = MESSAGE_Q_DEPTHs,  /* MESSAGE_Q_DEPTH */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Depth of SER message queue. Increase the value of\n this field in order to enlarge the SER message queue.\n",
    },
    {
        .name  = SER_LOG_DEPTHs,  /* SER_LOG_DEPTH */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Depth of SER_LOG. Increase the value of\n this field in order to increase the number\n of entries in the SER_LOG table.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ser_config_t = {
    .name = SER_CONFIGs, /* SER_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 3,
    .field = bcmltd_ser_config_t_fields,
    .desc = "The SER_CONFIG table is used to specify device-level SER configuration.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ser/SER_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ser_control_t_fields[] = {
    {
        .name  = TCAM_SCANs,  /* TCAM_SCAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable TCAM software scan.",
    },
    {
        .name  = TCAM_SCAN_INTERVALs,  /* TCAM_SCAN_INTERVAL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Time between TCAM scans in milliseconds.",
    },
    {
        .name  = TCAM_SCAN_CHUNK_SIZEs,  /* TCAM_SCAN_CHUNK_SIZE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of TCAM entries to be retrieved at a time.",
    },
    {
        .name  = TCAM_ENTRIES_READ_PER_INTERVALs,  /* TCAM_ENTRIES_READ_PER_INTERVAL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of TCAM entries to scan per interval.",
    },
    {
        .name  = SRAM_SCANs,  /* SRAM_SCAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable SRAM software scan.",
    },
    {
        .name  = SRAM_SCAN_INTERVALs,  /* SRAM_SCAN_INTERVAL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Time between SCAM scans in milliseconds.",
    },
    {
        .name  = SRAM_SCAN_CHUNK_SIZEs,  /* SRAM_SCAN_CHUNK_SIZE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of SRAM entries to be retrieved at a time.",
    },
    {
        .name  = SRAM_ENTRIES_READ_PER_INTERVALs,  /* SRAM_ENTRIES_READ_PER_INTERVAL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of SRAM entries to scan per interval.",
    },
    {
        .name  = REPORT_SINGLE_BIT_ECCs,  /* REPORT_SINGLE_BIT_ECC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ECC single bit reporting.",
    },
    {
        .name  = SER_LOGGINGs,  /* SER_LOGGING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable SER logging.",
    },
    {
        .name  = ERRONEOUS_ENTRIES_LOGGINGs,  /* ERRONEOUS_ENTRIES_LOGGING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable logging of erroneous entry content\n that triggered SER event.\n",
    },
    {
        .name  = HW_FAULTs,  /* HW_FAULT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable hardware fault checking.",
    },
    {
        .name  = PARITY_ERROR_TO_CPUs,  /* PARITY_ERROR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets which generate parity error\n to the CPU.\n",
    },
    {
        .name  = HIGH_SEVERITY_ERR_SUPPRESSIONs,  /* HIGH_SEVERITY_ERR_SUPPRESSION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable suppression of high severity error reporting.",
    },
    {
        .name  = HIGH_SEVERITY_ERR_THRESHOLDs,  /* HIGH_SEVERITY_ERR_THRESHOLD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the number of SER events that must occur\n in the same physical memory within the time\n specified by HIGH_SEVERITY_ERR_INTERVAL in order for\n the SER event to be classified as a high severity error.\n If such a condition is detected, SER checks are\n disabled on that physical memory.\n Applicable only if HIGH_SEVERITY_ERR_SUPPRESSION is enabled.\n",
    },
    {
        .name  = HIGH_SEVERITY_ERR_INTERVALs,  /* HIGH_SEVERITY_ERR_INTERVAL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Time interval(seconds) used in conjunction with\n HIGH_SEVERITY_ERR_THRESHOLD in order to determine\n whether SER events are classified as\n high severity errors. Applicable only if\n HIGH_SERVERITY_ERR_SUPPRESSION is enabled.\n",
    },
    {
        .name  = MEM_SCAN_RETRY_COUNTs,  /* MEM_SCAN_RETRY_COUNT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies the maximum number of attempts\n to scan the same memory until all SER errors\n in the memory space are individually triggered.\n",
    },
    {
        .name  = MEM_SCAN_TIME_TO_WAITs,  /* MEM_SCAN_TIME_TO_WAIT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specifies time (milliseconds) to wait for\n SER correction. There may be many SER errors in a\n memory, but the memory scan thread cannot trigger\n them at the same time. After the scan thread triggers\n one SER error, the thread will sleep for the specified\n time and wait for SER correction. The thread will then\n scan the memory space again until all SER errors are\n corrected or the retry attempts are equal to\n the value specified in MEM_SCAN_RETRY_COUNT.\n",
    },
    {
        .name  = SQUASH_DUPLICATED_SER_EVENT_INTERVALs,  /* SQUASH_DUPLICATED_SER_EVENT_INTERVAL */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Squash duplicated SER event within the specified time\n (milliseconds).\n",
    },
    {
        .name  = TCAM_SINGLE_BIT_AUTO_CORRECTIONs,  /* TCAM_SINGLE_BIT_AUTO_CORRECTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable 1-bit auto correction for TCAMs.",
    },
};
const bcmltd_table_rep_t bcmltd_ser_control_t = {
    .name = SER_CONTROLs, /* SER_CONTROL */
    .flags = 0,
    .fields = 20,
    .field = bcmltd_ser_control_t_fields,
    .desc = "Global Soft Error Recovery (SER) parameter configuration.\n The SER_CONTROL table is used to configure the SER sub-component.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ser/SER_INJECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ser_injection_t_fields[] = {
    {
        .name  = PT_IDs,  /* PT_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Physical table ID.",
    },
    {
        .name  = PT_INSTANCEs,  /* PT_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Physical table instance.",
    },
    {
        .name  = PT_INDEXs,  /* PT_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Physical table index.",
    },
    {
        .name  = PT_COPYs,  /* PT_COPY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Physical table copy.",
    },
    {
        .name  = XOR_BANKs,  /* XOR_BANK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inject SER ERROR to XOR_BANK or not.\n Applicable only for HASH_XOR physical table types.\n",
    },
    {
        .name  = INJECT_ERR_BIT_NUMs,  /* INJECT_ERR_BIT_NUM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inject single bit or double bit error.",
    },
    {
        .name  = INJECT_VALIDATEs,  /* INJECT_VALIDATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inject and test or only inject SER error.",
    },
    {
        .name  = TIME_TO_WAITs,  /* TIME_TO_WAIT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Time (milliseconds) to wait for SER correction.",
    },
};
const bcmltd_table_rep_t bcmltd_ser_injection_t = {
    .name = SER_INJECTIONs, /* SER_INJECTION */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_ser_injection_t_fields,
    .desc = "The SER_INJECTION table is used to inject\n SER errors to the specified physical table.\n The error injection status can be obtained\n from the SER_INJECTION_STATUS table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ser/SER_INJECTION_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ser_injection_status_t_fields[] = {
    {
        .name  = PT_IDs,  /* PT_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Physical table ID where error is injected.",
    },
    {
        .name  = PT_INSTANCEs,  /* PT_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Physical table instance where error is injected.",
    },
    {
        .name  = PT_INDEXs,  /* PT_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Physical table index where error is injected.",
    },
    {
        .name  = PT_COPYs,  /* PT_COPY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Physical table copy.",
    },
    {
        .name  = XOR_BANKs,  /* XOR_BANK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicate whether SER ERROR was injected to XOR_BANK or not.\n Applicable only for HASH_XOR physical table types.\n",
    },
    {
        .name  = SER_ERR_INJECTEDs,  /* SER_ERR_INJECTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled specifies that the error was injected successfully.",
    },
    {
        .name  = SER_ERR_CORRECTEDs,  /* SER_ERR_CORRECTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled specifies that the error was corrected successfully.",
    },
};
const bcmltd_table_rep_t bcmltd_ser_injection_status_t = {
    .name = SER_INJECTION_STATUSs, /* SER_INJECTION_STATUS */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_ser_injection_status_t_fields,
    .desc = "The SER_INJECTION_STATUS table provides status\n for errors injected via the SER_INJECTION table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ser/SER_LOG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ser_log_t_fields[] = {
    {
        .name  = SER_LOG_IDs,  /* SER_LOG_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "SER log index.",
    },
    {
        .name  = TIMESTAMPs,  /* TIMESTAMP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Timestamp (monotonic time) of SER event.",
    },
    {
        .name  = PT_IDs,  /* PT_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Physical table ID of SER event.",
    },
    {
        .name  = PT_INSTANCEs,  /* PT_INSTANCE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Physical table instance of SER event.",
    },
    {
        .name  = PT_INDEXs,  /* PT_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Physical table index of SER event.",
    },
    {
        .name  = SER_ERR_TYPEs,  /* SER_ERR_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Error type of SER event.",
    },
    {
        .name  = SER_ERR_CORRECTEDs,  /* SER_ERR_CORRECTED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled indicates that SER event was corrected.",
    },
    {
        .name  = SER_RECOVERY_TYPEs,  /* SER_RECOVERY_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Recovery type of SER event.",
    },
    {
        .name  = SER_INSTRUCTION_TYPEs,  /* SER_INSTRUCTION_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Physical table instruction type.",
    },
    {
        .name  = BLK_TYPEs,  /* BLK_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Physical table block type.",
    },
    {
        .name  = HW_FAULTs,  /* HW_FAULT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Physical table error is due to a hardware fault.",
    },
    {
        .name  = HIGH_SEVERITY_ERRs,  /* HIGH_SEVERITY_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate a high severity table error.\n A table error is considered high severity when the error\n can't be corrected.\n",
    },
    {
        .name  = ERR_ENTRY_CONTENTs,  /* ERR_ENTRY_CONTENT */
        .flags = 0,
        .width = 32,
        .depth = 32,
        .desc = "Content of the entry which contains the SER error.\n Applicable when SER_CONTROL.ERRONEOUS_ENTRIES_LOGGING\n is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_ser_log_t = {
    .name = SER_LOGs, /* SER_LOG */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_ser_log_t_fields,
    .desc = "The SER_LOG table provides a log of\n SER events maintained as a circular buffer.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ser/SER_LOG_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ser_log_status_t_fields[] = {
    {
        .name  = SER_LOG_IDs,  /* SER_LOG_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index to the last written entry of SER_LOG.",
    },
};
const bcmltd_table_rep_t bcmltd_ser_log_status_t = {
    .name = SER_LOG_STATUSs, /* SER_LOG_STATUS */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_ser_log_status_t_fields,
    .desc = "The SER_LOG_STATUS table provides SER logging status information.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ser/SER_NOTIFICATION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ser_notification_t_fields[] = {
    {
        .name  = PT_IDs,  /* PT_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Physical table ID associated with the SER event.",
    },
    {
        .name  = HW_FAULTs,  /* HW_FAULT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate a hardware fault.",
    },
    {
        .name  = HIGH_SEVERITY_ERRs,  /* HIGH_SEVERITY_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate a high severity error.",
    },
};
const bcmltd_table_rep_t bcmltd_ser_notification_t = {
    .name = SER_NOTIFICATIONs, /* SER_NOTIFICATION */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_ser_notification_t_fields,
    .desc = "The SER_NOTIFICATION table is updated\n when an SER event occurs in a physical table.\n An application can subscribe for updates on\n the SER_NOTIFICATION table in order to be\n informed of SER events.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ser/SER_PT_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ser_pt_control_t_fields[] = {
    {
        .name  = PT_IDs,  /* PT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Physical table ID.",
    },
    {
        .name  = ECC_PARITY_CHECKs,  /* ECC_PARITY_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ECC or parity check.",
    },
    {
        .name  = SCAN_MODEs,  /* SCAN_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify memory scan mode.",
    },
    {
        .name  = SCAN_MODE_OPERs,  /* SCAN_MODE_OPER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Indicates which scan mode is currently operational.",
    },
    {
        .name  = REPORT_SINGLE_BIT_ECCs,  /* REPORT_SINGLE_BIT_ECC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ECC single bit reporting if supported by the PT.",
    },
    {
        .name  = HIGH_SEVERITY_ERR_SUPPRESSIONs,  /* HIGH_SEVERITY_ERR_SUPPRESSION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable suppression of high severity error reporting.",
    },
};
const bcmltd_table_rep_t bcmltd_ser_pt_control_t = {
    .name = SER_PT_CONTROLs, /* SER_PT_CONTROL */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_ser_pt_control_t_fields,
    .desc = "Global Soft Error Recovery (SER) parameter configuration per physical table (PT).\n The SER_PT_CONTROL table is used to control SER enablement per PT.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ser/SER_PT_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ser_pt_status_t_fields[] = {
    {
        .name  = PT_IDs,  /* PT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Physical table ID.",
    },
    {
        .name  = HW_FAULTs,  /* HW_FAULT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if there is a hardware fault which cannot be\n corrected for this physical table. Once enabled,\n SER protection for this physical table will be disabled\n regardless of the setting of /ref ECC_PARITY_CHECK.\n",
    },
    {
        .name  = HIGH_SEVERITY_ERRs,  /* HIGH_SEVERITY_ERR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if there is high severity error in this PT.",
    },
    {
        .name  = PT_INDEX_NUMs,  /* PT_INDEX_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of physical table index.",
    },
    {
        .name  = PT_INST_NUMs,  /* PT_INST_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of physical table instance.",
    },
    {
        .name  = PT_COPY_NUMs,  /* PT_COPY_NUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of physical table copy.",
    },
    {
        .name  = SER_RECOVERY_TYPE_FOR_DOUBLE_BITs,  /* SER_RECOVERY_TYPE_FOR_DOUBLE_BIT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Type of SER recovery supported by this PT for double bits.",
    },
    {
        .name  = SER_RECOVERY_TYPE_FOR_SINGLE_BITs,  /* SER_RECOVERY_TYPE_FOR_SINGLE_BIT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Type of SER recovery supported by this PT for single bits.",
    },
    {
        .name  = SER_CHECK_TYPEs,  /* SER_CHECK_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Type of SER checks supported by this PT.",
    },
};
const bcmltd_table_rep_t bcmltd_ser_pt_status_t = {
    .name = SER_PT_STATUSs, /* SER_PT_STATUS */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_ser_pt_status_t_fields,
    .desc = "Global Soft Error Recovery (SER) status per PT.\n The SER_PT_STATUS table is used to indicate SER status per physical table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/ser/SER_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_ser_stats_t_fields[] = {
    {
        .name  = BLK_TYPEs,  /* BLK_TYPE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the device block type for which to\n provide statistics. Aggregated statistics for\n all block types are provided if\n BLK_TYPE=SER_BLK_ALL.\n",
    },
    {
        .name  = RECOVERY_TYPEs,  /* RECOVERY_TYPE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the SER recovery type for which to\n provide statistics. Aggregated statistics for\n all recovery types are provided if\n RECOVERY_TYPE=SER_RECOVERY_ALL.\n",
    },
    {
        .name  = ECC_SBE_REG_CNTs,  /* ECC_SBE_REG_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of ECC single bit errors in physical registers.",
    },
    {
        .name  = ECC_SBE_MEM_CNTs,  /* ECC_SBE_MEM_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of ECC single bit errors in physical memories.",
    },
    {
        .name  = ECC_SBE_CTR_CNTs,  /* ECC_SBE_CTR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of ECC single bit errors in physical counter memories.",
    },
    {
        .name  = ECC_DBE_REG_CNTs,  /* ECC_DBE_REG_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of ECC double bit errors in physical registers.",
    },
    {
        .name  = ECC_DBE_MEM_CNTs,  /* ECC_DBE_MEM_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of ECC double bit errors in physical memories.",
    },
    {
        .name  = ECC_DBE_CTR_CNTs,  /* ECC_DBE_CTR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of ECC double bit errors in physical counter memories.",
    },
    {
        .name  = PARITY_ERR_REG_CNTs,  /* PARITY_ERR_REG_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of parity errors in physical registers.",
    },
    {
        .name  = PARITY_ERR_MEM_CNTs,  /* PARITY_ERR_MEM_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of parity errors in physical memories,\n not including TCAM memories.\n",
    },
    {
        .name  = PARITY_ERR_CTR_CNTs,  /* PARITY_ERR_CTR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of parity errors in physical counter memories.",
    },
    {
        .name  = PARITY_ERR_TCAM_CNTs,  /* PARITY_ERR_TCAM_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of parity errors in physical TCAM memories.",
    },
    {
        .name  = ECC_PARITY_ERR_INT_BUS_CNTs,  /* ECC_PARITY_ERR_INT_BUS_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of internal bus parity or ECC errors.",
    },
    {
        .name  = ECC_PARITY_ERR_INT_MEM_CNTs,  /* ECC_PARITY_ERR_INT_MEM_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of internal memory ECC or parity errors.",
    },
    {
        .name  = HW_FAULT_CNTs,  /* HW_FAULT_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of table hardware faults.",
    },
    {
        .name  = HIGH_SEVERITY_ERR_CNTs,  /* HIGH_SEVERITY_ERR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of high severity errors.",
    },
    {
        .name  = TOTAL_ERR_CNTs,  /* TOTAL_ERR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of all SER errors",
    },
};
const bcmltd_table_rep_t bcmltd_ser_stats_t = {
    .name = SER_STATSs, /* SER_STATS */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_ser_stats_t_fields,
    .desc = "The SER_STATS table provides SER statistics\n information on a per device block basis.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/table/TABLE_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_table_control_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table ID.",
    },
    {
        .name  = MAX_ENTRIESs,  /* MAX_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The maximum number of LT entries which may be inserted\n into the logical table specified by TABLE_ID.\n\n This value must be <= TABLE_INFO.ENTRY_LIMIT.\n\n If TABLE_INFO.ENTRY_LIMIT changes during runtime due to\n control modifications of the hash or TCAM settings,\n this value must be updated by the application to ensure\n this constraint.\n\n If an INSERT operation to the LT specified by TABLE_ID\n would increase the in-use count to greater than this value,\n the INSERT is rejected.\n\n This field value is ignored on any LT which does not\n support INSERT.\n",
    },
    {
        .name  = TABLE_OP_PT_INFOs,  /* TABLE_OP_PT_INFO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to record physical table address information for\n operations in this LT.\n",
    },
};
const bcmltd_table_rep_t bcmltd_table_control_t = {
    .name = TABLE_CONTROLs, /* TABLE_CONTROL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_table_control_t_fields,
    .desc = "The TABLE_CONTROL table permits modification of runtime\n properties of any logical table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/table/TABLE_EM_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_table_em_control_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical Table ID",
    },
    {
        .name  = MOVE_DEPTHs,  /* MOVE_DEPTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Move depth for hash reordering when collision happens.",
    },
};
const bcmltd_table_rep_t bcmltd_table_em_control_t = {
    .name = TABLE_EM_CONTROLs, /* TABLE_EM_CONTROL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_table_em_control_t_fields,
    .desc = "The TABLE_EM_CONTROL table specifies enhanced memory controls for\n logical tables.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/table/TABLE_EM_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_table_em_info_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table ID",
    },
    {
        .name  = LOOKUP_CNTs,  /* LOOKUP_CNT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Maximum number of lookups supported by the logical table.",
    },
    {
        .name  = GROUP_CNTs,  /* GROUP_CNT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of groups to which this logical table is mapped.",
    },
    {
        .name  = DEVICE_EM_GROUP_IDs,  /* DEVICE_EM_GROUP_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 64,
        .desc = "List of groups to which this logical table is mapped.",
    },
};
const bcmltd_table_rep_t bcmltd_table_em_info_t = {
    .name = TABLE_EM_INFOs, /* TABLE_EM_INFO */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_table_em_info_t_fields,
    .desc = "The TABLE_EM_INFO table provides read-only enhanced memory banks group\n information for logical tables which use enhanced memory banks.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/table/TABLE_FIELD_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_table_field_info_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table ID.",
    },
    {
        .name  = FIELD_IDs,  /* FIELD_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table field ID.",
    },
    {
        .name  = SYMBOLs,  /* SYMBOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate this field is specified via symbols,\n not numeric values.\n",
    },
    {
        .name  = MIN_LIMITs,  /* MIN_LIMIT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "The least permitted value for this field in this LT,\n as restricted by device resource and table configuration.\n Applicable if SYMBOL is disabled.\n",
    },
    {
        .name  = MAX_LIMITs,  /* MAX_LIMIT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "The greatest permitted value for this field in this LT,\n as restricted by device resource and table configuration.\n Applicable if SYMBOL is disabled.\n",
    },
    {
        .name  = DEFAULTs,  /* DEFAULT */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "The default numeric value for this field in this LT.\n Applicable if SYMBOL is disabled.\n",
    },
    {
        .name  = SYMBOL_DEFAULTs,  /* SYMBOL_DEFAULT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The default symbolic value for this field in this LT.\n Applicable if SYMBOL is enabled.\n",
    },
    {
        .name  = KEYs,  /* KEY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if this is a key field.",
    },
    {
        .name  = INDEX_ALLOC_KEY_FIELDs,  /* INDEX_ALLOC_KEY_FIELD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if this key field may be optionally allocated during\n INSERT into an index with allocation logical table.\n Allocated fields are returned in the output field list\n of an INSERT operation.\n Disabled if this key field is required in the input field\n list for INSERT.\n Applicable only if TABLE_INFO.TYPE == INDEX_ALLOCATE.\n",
    },
    {
        .name  = READ_ONLYs,  /* READ_ONLY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if this field is read-only and may not be modified\n by the application.\n",
    },
    {
        .name  = ARRAY_DEPTHs,  /* ARRAY_DEPTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of array elements for this field.\n If the field is scalar, this value is 0.\n",
    },
    {
        .name  = ELEMENTSs,  /* ELEMENTS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of elements for this field.\n For a scalar, this will be (FIELD_WIDTH + 63 / 64).\n For an array, this is equal to ARRAY_DEPTH.\n The valid field index values for this field range\n [ELEMENTS - 1, 0].\n",
    },
    {
        .name  = FIELD_WIDTHs,  /* FIELD_WIDTH */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Bit width of this field.",
    },
    {
        .name  = SELECTORs,  /* SELECTOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if this is a selector field for an overlay group.",
    },
    {
        .name  = NUM_GROUPs,  /* NUM_GROUP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "If NUM_GROUP is non-zero, this field is a member of an overlay\n group.  The value specified in NUM_GROUP is the number of\n entries in the TABLE_FIELD_SELECT table.\n (TABLE_ID, FIELD_ID, i), i = [0, NUM_GROUP-1].\n If NUM_GROUP is zero, this field is not part of an overlay group,\n and the TABLE_FIELD_SELECT table will have no entries\n for this field.\n",
    },
};
const bcmltd_table_rep_t bcmltd_table_field_info_t = {
    .name = TABLE_FIELD_INFOs, /* TABLE_FIELD_INFO */
    .flags = 0,
    .fields = 15,
    .field = bcmltd_table_field_info_t_fields,
    .desc = "The TABLE_FIELD_INFO table provides read-only access to immutable\n properties of a logical table's fields.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/table/TABLE_FIELD_SELECT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_table_field_select_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Table ID.",
    },
    {
        .name  = FIELD_IDs,  /* FIELD_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Field ID.",
    },
    {
        .name  = GROUPs,  /* GROUP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Disambiguator for fields in multiple selectors.",
    },
    {
        .name  = SELECTOR_FIELD_IDs,  /* SELECTOR_FIELD_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Selector Field ID or NO_FIELD if field not\n associated with a selector.\n",
    },
    {
        .name  = SCALARs,  /* SCALAR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if the selector is a scalar.",
    },
    {
        .name  = SCALAR_VALUEs,  /* SCALAR_VALUE */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Scalar value of the selector for this FIELD_ID\n and group.\n",
    },
    {
        .name  = ENUM_VALUEs,  /* ENUM_VALUE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Enum value of the selector for this FIELD_ID\n and group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_table_field_select_t = {
    .name = TABLE_FIELD_SELECTs, /* TABLE_FIELD_SELECT */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_table_field_select_t_fields,
    .desc = "This table describes the relationship of fields\n which are conditionally included in a logical table entry\n depending upon the value of a selector field.\n A selector field is indicated by TABLE_FIELD_INFO.SELECTOR.\n A field has entries in this table only if\n TABLE_FIELD_INFO.NUM_GROUP is non-zero.\n\n This table provides the association of fields and\n field selectors used for field overlays and PDDs.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/table/TABLE_HASH_STORE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_table_hash_store_info_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table ID",
    },
    {
        .name  = HASH_STOREs,  /* HASH_STORE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Hash store value for the last successful/unsuccessful insert\n attempt for the logical table specified by TABLE_ID.\n",
    },
};
const bcmltd_table_rep_t bcmltd_table_hash_store_info_t = {
    .name = TABLE_HASH_STORE_INFOs, /* TABLE_HASH_STORE_INFO */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_table_hash_store_info_t_fields,
    .desc = "The TABLE_HASH_STORE_INFO table provides read-only hash store value\n information for logical tables which support the hash store function.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/table/TABLE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_table_info_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table ID.",
    },
    {
        .name  = TYPEs,  /* TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TABLE_TYPE_T_DATA,
        .desc = "Table type.",
    },
    {
        .name  = MAPs,  /* MAP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TABLE_MAP_T_DATA,
        .desc = "Map type.",
    },
    {
        .name  = MODELEDs,  /* MODELED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if the logical table is Modeled.\n Disabled if the logical table is Interactive.\n",
    },
    {
        .name  = READ_ONLYs,  /* READ_ONLY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if this table does not permit direct changes to values.",
    },
    {
        .name  = NUM_KEYSs,  /* NUM_KEYS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of key fields in this logical table.",
    },
    {
        .name  = NUM_FIELDSs,  /* NUM_FIELDS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of fields in this logical table.",
    },
    {
        .name  = ENTRY_INUSE_CNTs,  /* ENTRY_INUSE_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The current number of entries inserted in this logical table.",
    },
    {
        .name  = ENTRY_MAXIMUMs,  /* ENTRY_MAXIMUM */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The maximum number of entries which may be installed for this\n logical table in this device variant.\n",
    },
    {
        .name  = ENTRY_LIMITs,  /* ENTRY_LIMIT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The greatest number of entries for this logical table in this\n device as currently configured.  Reconfiguration of the device\n via other logical tables may change this bound.\n\n Note that the number of permitted entries for a logical table may\n be further restricted by the TABLE_INDEX_CONTROL.MAX_ENTRIES value.\n",
    },
    {
        .name  = NUM_RESOURCE_INFOs,  /* NUM_RESOURCE_INFO */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of companion resource info tables.\n These read-only tables provide additional context about\n the state of various device resources utilized by this\n logical table.\n",
    },
    {
        .name  = INSERT_OPCODEs,  /* INSERT_OPCODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if INSERT opcode is supported on this logical table.",
    },
    {
        .name  = DELETE_OPCODEs,  /* DELETE_OPCODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if DELETE opcode is supported on this logical table.",
    },
    {
        .name  = LOOKUP_OPCODEs,  /* LOOKUP_OPCODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if LOOKUP opcode is supported on this logical table.",
    },
    {
        .name  = UPDATE_OPCODEs,  /* UPDATE_OPCODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if UPDATE opcode is supported on this logical table.",
    },
    {
        .name  = TRAVERSE_OPCODEs,  /* TRAVERSE_OPCODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if TRAVERSE opcode is supported on this logical table.",
    },
};
const bcmltd_table_rep_t bcmltd_table_info_t = {
    .name = TABLE_INFOs, /* TABLE_INFO */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_table_info_t_fields,
    .desc = "The TABLE_INFO table provides read-only access to\n properties of any logical table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/table/TABLE_OP_DOP_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_table_op_dop_info_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table ID.",
    },
    {
        .name  = PT_ID_CNTs,  /* PT_ID_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of valid entries in the PT_ID and PT_INSTANCE array.",
    },
    {
        .name  = PT_INSTANCEs,  /* PT_INSTANCE */
        .flags = 0,
        .width = 32,
        .depth = 16,
        .desc = "Array of physical table instances.",
    },
    {
        .name  = PT_IDs,  /* PT_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 16,
        .desc = "Array of physical table names.",
    },
    {
        .name  = PT_INDEX_CNTs,  /* PT_INDEX_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of valid entries in the PT_INDEX array.",
    },
    {
        .name  = PT_INDEXs,  /* PT_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 16,
        .desc = "Array of physical table indexes, updated during last LT\n  operation.\n",
    },
    {
        .name  = PT_LOOKUPs,  /* PT_LOOKUP */
        .flags = 0,
        .width = 1,
        .depth = 16,
        .desc = "Enabled to specify that the lookup was performed.\n Since this field information gets updated for lookup/update operation on target LT,\n it is required that the visibility packet needs to be transmitted prior to every\n lookup/update operation on the target LT.\n",
    },
    {
        .name  = PT_HITs,  /* PT_HIT */
        .flags = 0,
        .width = 1,
        .depth = 16,
        .desc = "Enabled to specify that the lookup resulted in a hit. Applicable\n only when the corresponding array element in the PT_LOOKUP field\n is enabled.\n Since this field information gets updated for lookup/update operation on target LT,\n it is required that the visibility packet needs to be transmitted prior to every\n lookup/update operation on the target LT.\n",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "PT Lookup and PT hit information are updated for this\n  ingress port.\n",
    },
};
const bcmltd_table_rep_t bcmltd_table_op_dop_info_t = {
    .name = TABLE_OP_DOP_INFOs, /* TABLE_OP_DOP_INFO */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_table_op_dop_info_t_fields,
    .desc = "The TABLE_OP_DOP_INFO table specifies the physical table address\n information along with physical table(PT) lookup hit or miss, associated\n with the latest logical table operation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/table/TABLE_OP_PT_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_table_op_pt_info_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table ID.",
    },
    {
        .name  = PT_ID_CNTs,  /* PT_ID_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of valid entries in the PT_ID and PT_INSTANCE array.",
    },
    {
        .name  = PT_INSTANCEs,  /* PT_INSTANCE */
        .flags = 0,
        .width = 32,
        .depth = 16,
        .desc = "Physical table instance.",
    },
    {
        .name  = PT_IDs,  /* PT_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 16,
        .desc = "Array of physical table names.",
    },
    {
        .name  = PT_INDEX_CNTs,  /* PT_INDEX_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of valid entries in the PT_INDEX array.",
    },
    {
        .name  = PT_INDEXs,  /* PT_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 16,
        .desc = "Array of physical table indexes, updated during last LT operation",
    },
    {
        .name  = PT_ID_DATA_CNTs,  /* PT_ID_DATA_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of valid entries in the PT_ID_DATA array.",
    },
    {
        .name  = PT_ID_DATAs,  /* PT_ID_DATA */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 16,
        .desc = "Array of physical table names of the data view.\n Valid only if AGGREGATE_VIEW is disabled.\n",
    },
    {
        .name  = PT_INDEX_DATA_CNTs,  /* PT_INDEX_DATA_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Count of valid entries in the PT_INDEX_DATA array.",
    },
    {
        .name  = PT_INDEX_DATAs,  /* PT_INDEX_DATA */
        .flags = 0,
        .width = 32,
        .depth = 16,
        .desc = "Array of physical table index of the data view.\n Valid only if AGGREGATE_VIEW is disabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_table_op_pt_info_t = {
    .name = TABLE_OP_PT_INFOs, /* TABLE_OP_PT_INFO */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_table_op_pt_info_t_fields,
    .desc = "The TABLE_OP_PT_INFO table specifies the physical table address information\n associated with the latest logical table operation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/table/TABLE_RESOURCE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_table_resource_info_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table ID.",
    },
    {
        .name  = RESOURCE_INFOs,  /* RESOURCE_INFO */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Disambiguator for resource information table IDs.",
    },
    {
        .name  = RESOURCE_INFO_TABLE_IDs,  /* RESOURCE_INFO_TABLE_ID */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Resource information table ID.",
    },
};
const bcmltd_table_rep_t bcmltd_table_resource_info_t = {
    .name = TABLE_RESOURCE_INFOs, /* TABLE_RESOURCE_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_table_resource_info_t_fields,
    .desc = "The TABLE_RESOURCE_INFO table provides the companion resource information\n for a logical table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/table/TABLE_STATS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_table_stats_t_fields[] = {
    {
        .name  = TABLE_IDs,  /* TABLE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Logical table ID.",
    },
    {
        .name  = TABLE_ERROR_CNTs,  /* TABLE_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of error entry operations targeting this\n logical table.\n",
    },
    {
        .name  = FIELD_SIZE_ERROR_CNTs,  /* FIELD_SIZE_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of field width errors.  Such errors occur when\n the field value is outside the valid range.\n",
    },
    {
        .name  = FIELD_LIST_ERROR_CNTs,  /* FIELD_LIST_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of field list errors.  Such errors occur when\n a required field is missing.\n",
    },
    {
        .name  = VALIDATE_ERROR_CNTs,  /* VALIDATE_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of errors generated by custom field validations.",
    },
    {
        .name  = TRANSFORM_ERROR_CNTs,  /* TRANSFORM_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of errors generated by custom field transformations.",
    },
    {
        .name  = TABLE_HANDLER_ERROR_CNTs,  /* TABLE_HANDLER_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of errors generated by a custom table handler.",
    },
    {
        .name  = TABLE_INSERT_CNTs,  /* TABLE_INSERT_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The total number of INSERT operations requested.",
    },
    {
        .name  = TABLE_INSERT_ERROR_CNTs,  /* TABLE_INSERT_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of INSERT operations resulting in an error",
    },
    {
        .name  = TABLE_LOOKUP_CNTs,  /* TABLE_LOOKUP_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The total number of LOOKUP operations requested.",
    },
    {
        .name  = TABLE_LOOKUP_ERROR_CNTs,  /* TABLE_LOOKUP_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of LOOKUP operations resulting in an error",
    },
    {
        .name  = TABLE_DELETE_CNTs,  /* TABLE_DELETE_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The total number of DELETE operations requested.",
    },
    {
        .name  = TABLE_DELETE_ERROR_CNTs,  /* TABLE_DELETE_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of DELETE operations resulting in an error",
    },
    {
        .name  = TABLE_UPDATE_CNTs,  /* TABLE_UPDATE_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The total number of UPDATE operations requested.",
    },
    {
        .name  = TABLE_UPDATE_ERROR_CNTs,  /* TABLE_UPDATE_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of UPDATE operations resulting in an error",
    },
    {
        .name  = TABLE_TRAVERSE_CNTs,  /* TABLE_TRAVERSE_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The total number of TRAVERSE operations requested.",
    },
    {
        .name  = TABLE_TRAVERSE_ERROR_CNTs,  /* TABLE_TRAVERSE_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of TRAVERSE operations resulting in an error",
    },
    {
        .name  = PHYSICAL_TABLE_OP_CNTs,  /* PHYSICAL_TABLE_OP_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of physical table operations requested",
    },
    {
        .name  = PHYSICAL_TABLE_OP_ERROR_CNTs,  /* PHYSICAL_TABLE_OP_ERROR_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "The number of physical table operations resulting in an error",
    },
};
const bcmltd_table_rep_t bcmltd_table_stats_t = {
    .name = TABLE_STATSs, /* TABLE_STATS */
    .flags = 0,
    .fields = 19,
    .field = bcmltd_table_stats_t_fields,
    .desc = "The TABLE_STATS table enables retrieval of runtime\n operating statistics of any Logical Table.\n The values may be assigned via UPDATE for reset or test purposes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_BST_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_bst_control_t_fields[] = {
    {
        .name  = CLASSs,  /* CLASS */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_BST_EVENT_CLASS_T_DATA,
        .desc = "Resource class for an event.",
    },
    {
        .name  = TRACKING_MODEs,  /* TRACKING_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_BST_TRACK_MODE_TYPE_T_DATA,
        .desc = "Select the tracking mode for the resource class.",
    },
    {
        .name  = CLEAR_ON_READs,  /* CLEAR_ON_READ */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable clear on read of BST and drop counters for\n the resource class. Applicable only if\n TRACKING_MODE == HIGH_WATERMARK_TRACK.\n",
    },
    {
        .name  = SNAPSHOTs,  /* SNAPSHOT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the snapshot trigger of BST counters.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_bst_control_t = {
    .name = TM_BST_CONTROLs, /* TM_BST_CONTROL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_bst_control_t_fields,
    .desc = "BST control table. Used to provision global per-CLASS BST\n run-time controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_BST_DEVICE_THD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_bst_device_thd_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Device thresholds in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_bst_device_thd_t = {
    .name = TM_BST_DEVICE_THDs, /* TM_BST_DEVICE_THD */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tm_bst_device_thd_t_fields,
    .desc = "The TM_BST_DEVICE_THD table is used to configure the\n threshold parameters for at the device level.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_BST_EVENT_SOURCE_EGR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_bst_event_source_egr_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = UC_Qs,  /* UC_Q */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if unicast queue threshold is hit.",
    },
    {
        .name  = UC_Q_PORTs,  /* UC_Q_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Port number of the queue for the event triggered.\n Applicable only if UC_Q is set.\n",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID for the event triggered.\n Applicable only if UC_Q is set.\n",
    },
    {
        .name  = MC_Qs,  /* MC_Q */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if multicast queue threshold is hit.",
    },
    {
        .name  = MC_Q_PORTs,  /* MC_Q_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Port number of the queue for the event triggered.\n Applicable only if MC_Q is set.\n",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue ID for the event triggered.\n Applicable only if MC_Q is set.\n",
    },
    {
        .name  = SERVICE_POOL_UCs,  /* SERVICE_POOL_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if egress unicast service-pool threshold is hit.",
    },
    {
        .name  = SERVICE_POOL_UC_INDEXs,  /* SERVICE_POOL_UC_INDEX */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Index of the unicast egress service pool for the\n event triggered.\n Applicable only if SERVICE_POOL_UC is set.\n",
    },
    {
        .name  = SERVICE_POOL_MCs,  /* SERVICE_POOL_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if Egress multicast service-pool threshold is hit.",
    },
    {
        .name  = SERVICE_POOL_MC_INDEXs,  /* SERVICE_POOL_MC_INDEX */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Index of the multicast egress service pool\n for the event triggered.\n Applicable only if SERVICE_POOL_MC is set.\n",
    },
    {
        .name  = PORT_SERVICE_POOL_UCs,  /* PORT_SERVICE_POOL_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if egress unicast port service-pool threshold is hit.",
    },
    {
        .name  = PORT_SERVICE_POOL_UC_PORTs,  /* PORT_SERVICE_POOL_UC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Port number of the unicast port service pool\n for the event triggered.\n Applicable only if PORT_SERVICE_POOL_UC is set.\n",
    },
    {
        .name  = PORT_SERVICE_POOL_UC_INDEXs,  /* PORT_SERVICE_POOL_UC_INDEX */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Index of the unicast port service pool for the\n event triggered.\n Applicable only if PORT_SERVICE_POOL_UC is set.\n",
    },
    {
        .name  = PORT_SERVICE_POOL_MCs,  /* PORT_SERVICE_POOL_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if egress multicast port service-pool threshold\n is hit.\n",
    },
    {
        .name  = PORT_SERVICE_POOL_MC_PORTs,  /* PORT_SERVICE_POOL_MC_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Port number of the multicast port service pool\n for the event triggered.\n Applicable only if PORT_SERVICE_POOL_MC is set.\n",
    },
    {
        .name  = PORT_SERVICE_POOL_MC_INDEXs,  /* PORT_SERVICE_POOL_MC_INDEX */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Index of the multicast port service pool for the\n event triggered.\n Applicable only if PORT_SERVICE_POOL_MC is set.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_bst_event_source_egr_t = {
    .name = TM_BST_EVENT_SOURCE_EGRs, /* TM_BST_EVENT_SOURCE_EGR */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_tm_bst_event_source_egr_t_fields,
    .desc = "The TM_BST_EVENT_SOURCE_EGR table is used to retrieve fine grained\n event information for the egress (EGR) class.\n User is expected to retrieve information from TM_BST_EVENT_SOURCE_EGR\n table following an event notification from TM_BST_EVENT_STATE table.\n These values are undefined unless in TRIGGERED state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_BST_EVENT_SOURCE_ING.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_bst_event_source_ing_t_fields[] = {
    {
        .name  = TM_PIPEs,  /* TM_PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TM pipe number.",
    },
    {
        .name  = SERVICE_POOLs,  /* SERVICE_POOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if ingress service pool threshold is hit.",
    },
    {
        .name  = SERVICE_POOL_INDEXs,  /* SERVICE_POOL_INDEX */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Index of the service pool for the event triggered.\n Applicable only if SERVICE_POOL is set.\n",
    },
    {
        .name  = HEADROOM_POOLs,  /* HEADROOM_POOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if ingress headroom pool threshold is hit.",
    },
    {
        .name  = HEADROOM_POOL_INDEXs,  /* HEADROOM_POOL_INDEX */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Index of the headroom pool for the event triggered.\n Applicable only if HEADROOM_POOL is set.\n",
    },
    {
        .name  = PRI_GRPs,  /* PRI_GRP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if ingress priority group threshold is hit.",
    },
    {
        .name  = PRI_GRP_PORTs,  /* PRI_GRP_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source port of the priority group for the\n event triggered.\n Applicable only if PRI_GRP is set.\n",
    },
    {
        .name  = PRI_GRP_INDEXs,  /* PRI_GRP_INDEX */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Index of the priority group for the event triggered.\n Applicable only if PRI_GRP is set.\n",
    },
    {
        .name  = PRI_GRP_HEADROOMs,  /* PRI_GRP_HEADROOM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if ingress priority group headroom threshold is hit.",
    },
    {
        .name  = PRI_GRP_HEADROOM_PORTs,  /* PRI_GRP_HEADROOM_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source port of the priority group headroom\n for the event triggered.\n Applicable only if PRI_GRP_HEADROOM is set.\n",
    },
    {
        .name  = PRI_GRP_HEADROOM_INDEXs,  /* PRI_GRP_HEADROOM_INDEX */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Index of the priority group headroom for the\n event triggered.\n Applicable only if PRI_GRP_HEADROOM is set.\n",
    },
    {
        .name  = PORT_SERVICE_POOLs,  /* PORT_SERVICE_POOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if ingress port service-pool threshold is hit.",
    },
    {
        .name  = PORT_SERVICE_POOL_PORTs,  /* PORT_SERVICE_POOL_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Source port of the port service-pool for the\n event triggered.\n Applicable only if PORT_SERVICE_POOL is set.\n",
    },
    {
        .name  = PORT_SERVICE_POOL_INDEXs,  /* PORT_SERVICE_POOL_INDEX */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Index of the port service pool for the event triggered.\n Applicable only if PORT_SERVICE_POOL is set.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_bst_event_source_ing_t = {
    .name = TM_BST_EVENT_SOURCE_INGs, /* TM_BST_EVENT_SOURCE_ING */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_tm_bst_event_source_ing_t_fields,
    .desc = "The TM_BST_EVENT_SOURCE_ING table is used to retrieve fine grained\n event information for ingress (ING) class.\n User is expected to retrieve information from TM_BST_EVENT_SOURCE_ING\n table following an event notification from TM_BST_EVENT_STATE table.\n These values are undefined unless in TRIGGERED state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_BST_EVENT_SOURCE_REPL_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_bst_event_source_repl_q_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = PRI_Qs,  /* PRI_Q */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if replication priority queue threshold is hit.",
    },
    {
        .name  = REPL_Q_NUMs,  /* REPL_Q_NUM */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Index of replication queue for the event triggered.\n Applicable only if PRI_Q is set.\n",
    },
    {
        .name  = SERVICE_POOLs,  /* SERVICE_POOL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled if replication service pool threshold is hit.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_bst_event_source_repl_q_t = {
    .name = TM_BST_EVENT_SOURCE_REPL_Qs, /* TM_BST_EVENT_SOURCE_REPL_Q */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_bst_event_source_repl_q_t_fields,
    .desc = "The TM_BST_EVENT_SOURCE_REPL_Q is used to retrieve fine grained\n event information for the replication queue (REPL_Q) class.\n User is expected to retrieve information from TM_BST_EVENT_SOURCE_REPL_Q\n table following an event notification from TM_BST_EVENT_STATE table.\n These values are undefined unless in TRIGGERED state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_BST_EVENT_STATE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_bst_event_state_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = CLASSs,  /* CLASS */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_BST_EVENT_CLASS_T_DATA,
        .desc = "Resource class for an event.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_BST_EVENT_STATE_T_DATA,
        .desc = "BST event state.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_bst_event_state_t = {
    .name = TM_BST_EVENT_STATEs, /* TM_BST_EVENT_STATE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_bst_event_state_t_fields,
    .desc = "The TM_BST_EVENT_STATE displays the event state information for\n the supported BST buffers.\n Application can poll or subscribe to the table to determine if\n an event has occurred and state has changed. Entries in this table\n follow entries in TM_BST_EVENT_STATE_CONTROL and constitute the operational\n status of the requested state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_BST_EVENT_STATE_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_bst_event_state_control_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = CLASSs,  /* CLASS */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_BST_EVENT_CLASS_T_DATA,
        .desc = "Resource class for an event.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_BST_EVENT_STATE_T_DATA,
        .desc = "BST event state.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_bst_event_state_control_t = {
    .name = TM_BST_EVENT_STATE_CONTROLs, /* TM_BST_EVENT_STATE_CONTROL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_bst_event_state_control_t_fields,
    .desc = "The TM_BST_EVENT_STATE_CONTROL is used to request transition\n to an operational state for the resource class. The resultant\n status of the request can be obtained by reading the entries in\n TM_BST_EVENT_STATE table.\n Application can use this table in order to transition through\n the event state machine.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_BST_REPL_Q_PRI_QUEUE_THD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_bst_repl_q_pri_queue_thd_t_fields[] = {
    {
        .name  = REPL_Q_NUMs,  /* REPL_Q_NUM */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Replication queue number.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Threshold in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_bst_repl_q_pri_queue_thd_t = {
    .name = TM_BST_REPL_Q_PRI_QUEUE_THDs, /* TM_BST_REPL_Q_PRI_QUEUE_THD */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_bst_repl_q_pri_queue_thd_t_fields,
    .desc = "The TM_BST_REPL_Q_PRI_QUEUE_THD table is used to configure the\n threshold parameters for a replication queue.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_BST_REPL_Q_SERVICE_POOL_THD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_bst_repl_q_service_pool_thd_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Threshold in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_bst_repl_q_service_pool_thd_t = {
    .name = TM_BST_REPL_Q_SERVICE_POOL_THDs, /* TM_BST_REPL_Q_SERVICE_POOL_THD */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tm_bst_repl_q_service_pool_thd_t_fields,
    .desc = "The TM_BST_REPL_Q_SERVICE_POOL_THD table is used to configure the\n threshold parameters for replication engine service pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_BST_SERVICE_POOL_THD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_bst_service_pool_thd_t_fields[] = {
    {
        .name  = TM_BST_SERVICE_POOL_THD_IDs,  /* TM_BST_SERVICE_POOL_THD_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Index into the BST service pool threshold table.",
    },
    {
        .name  = ING_SERVICE_POOL_CELLSs,  /* ING_SERVICE_POOL_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Ingress service pool shared threshold in cells.",
    },
    {
        .name  = ING_HEADROOM_POOL_CELLSs,  /* ING_HEADROOM_POOL_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Ingress headroom pool shared threshold in cells.",
    },
    {
        .name  = EGR_SERVICE_POOL_UC_CELLSs,  /* EGR_SERVICE_POOL_UC_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Egress unicast service pool threshold in cells.",
    },
    {
        .name  = EGR_SERVICE_POOL_MC_CELLSs,  /* EGR_SERVICE_POOL_MC_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Egress multicast service pool threshold\n in cells.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_bst_service_pool_thd_t = {
    .name = TM_BST_SERVICE_POOL_THDs, /* TM_BST_SERVICE_POOL_THD */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tm_bst_service_pool_thd_t_fields,
    .desc = "The TM_BST_SERVICE_POOL_THD table is used to configure the\n threshold parameters for a service pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_COS_Q_CPU_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_cos_q_cpu_map_t_fields[] = {
    {
        .name  = PKT_TRACEs,  /* PKT_TRACE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to packet trace function.",
    },
    {
        .name  = PKT_TRACE_MASKs,  /* PKT_TRACE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for PKT_TRACE.",
    },
    {
        .name  = IP_MC_L3_IIF_MISMATCHs,  /* IP_MC_L3_IIF_MISMATCH */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to IP multicast interface mismatch.",
    },
    {
        .name  = IP_MC_L3_IIF_MISMATCH_MASKs,  /* IP_MC_L3_IIF_MISMATCH_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for IP_MC_L3_IIF_MISMATCH.",
    },
    {
        .name  = BFD_ERRORs,  /* BFD_ERROR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to BFD error.",
    },
    {
        .name  = BFD_ERROR_MASKs,  /* BFD_ERROR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for BFD_ERROR.",
    },
    {
        .name  = BFD_SLOWPATHs,  /* BFD_SLOWPATH */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to BFD slow path.",
    },
    {
        .name  = BFD_SLOWPATH_MASKs,  /* BFD_SLOWPATH_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for BFD_SLOWPATH.",
    },
    {
        .name  = L2_MY_STATION_HITs,  /* L2_MY_STATION_HIT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to MY_STATION hit.",
    },
    {
        .name  = L2_MY_STATION_HIT_MASKs,  /* L2_MY_STATION_HIT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L2_MY_STATION_HIT.",
    },
    {
        .name  = MAC_IP_BIND_LOOKUP_MISS_DROPs,  /* MAC_IP_BIND_LOOKUP_MISS_DROP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to HPAE (Host Posture Assessment\n and Enforcement) check failure.\n",
    },
    {
        .name  = MAC_IP_BIND_LOOKUP_MISS_DROP_MASKs,  /* MAC_IP_BIND_LOOKUP_MISS_DROP_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MAC_IP_BIND_LOOKUP_MISS_DROP.",
    },
    {
        .name  = L2_PROTOs,  /* L2_PROTO */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select L2 protocol packet copied to CPU.",
    },
    {
        .name  = L2_PROTO_MASKs,  /* L2_PROTO_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L2_PROTO.",
    },
    {
        .name  = TIME_SYNCs,  /* TIME_SYNC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select network time sync packet copied to CPU.",
    },
    {
        .name  = TIME_SYNC_MASKs,  /* TIME_SYNC_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for TIME_SYNC.",
    },
    {
        .name  = AMT_CONTROLs,  /* AMT_CONTROL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select AMT (Automatic IP multicast without explicit tunnels)\n control packet copied to CPU.\n",
    },
    {
        .name  = AMT_CONTROL_MASKs,  /* AMT_CONTROL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for AMT_CONTROL.",
    },
    {
        .name  = VLAN_XLATE_MISSs,  /* VLAN_XLATE_MISS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to VLAN translation miss.",
    },
    {
        .name  = VLAN_XLATE_MISS_MASKs,  /* VLAN_XLATE_MISS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for VLAN_XLATE_MISS.",
    },
    {
        .name  = IEEE1588_UNKNOWN_VERSIONs,  /* IEEE1588_UNKNOWN_VERSION */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to IEEE 1588 unknown version.",
    },
    {
        .name  = IEEE1588_UNKNOWN_VERSION_MASKs,  /* IEEE1588_UNKNOWN_VERSION_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for IEEE1588_UNKNOWN_VERSION.",
    },
    {
        .name  = SRP_PROTOCOLs,  /* SRP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select SRP (Stream Registration Protocol) packet copied to CPU .",
    },
    {
        .name  = SRP_PROTOCOL_MASKs,  /* SRP_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SRP_PROTOCOL.",
    },
    {
        .name  = MMRP_PROTOCOLs,  /* MMRP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select MMRP (Multiple Mac Registration Protocol) packet copied to CPU.",
    },
    {
        .name  = MMRP_PROTOCOL_MASKs,  /* MMRP_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MMRP_PROTOCOL.",
    },
    {
        .name  = MPLS_ILLEGAL_RESERVED_LABELs,  /* MPLS_ILLEGAL_RESERVED_LABEL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to illegal reserved\n MPLS label. Such packets have GAL (Generic Associated Channel Label)\n that is not at the bottom of the stack.\n",
    },
    {
        .name  = MPLS_ILLEGAL_RESERVED_LABEL_MASKs,  /* MPLS_ILLEGAL_RESERVED_LABEL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MPLS_ILLEGAL_RESERVED_LABEL.",
    },
    {
        .name  = MPLS_ALERT_LABEL_EXPOSEDs,  /* MPLS_ALERT_LABEL_EXPOSED */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to GAL (Generic Associated channel\n Label) or RAL (Router Alert Label) being exposed.\n",
    },
    {
        .name  = MPLS_ALERT_LABEL_EXPOSED_MASKs,  /* MPLS_ALERT_LABEL_EXPOSED_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MPLS_ALERT_LABEL_EXPOSED.",
    },
    {
        .name  = MPLS_TTL_CHECK_FAILs,  /* MPLS_TTL_CHECK_FAIL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to\n MPLS Header TTL value being 0 or 1.\n",
    },
    {
        .name  = MPLS_TTL_CHECK_FAIL_MASKs,  /* MPLS_TTL_CHECK_FAIL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MPLS_TTL_CHECK_FAIL.",
    },
    {
        .name  = MPLS_INVALID_PAYLOADs,  /* MPLS_INVALID_PAYLOAD */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to MPLS payload being invalid.\n Packet has an IPv4 payload and TNL_MPLS_DECAP.IPV4_PAYLOAD is\n not enabled, or packet has an IPv6 payload and TNL_MPLS_DECAP.IPV6_PAYLOAD is\n not enabled.\n",
    },
    {
        .name  = MPLS_INVALID_PAYLOAD_MASKs,  /* MPLS_INVALID_PAYLOAD_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MPLS_INVALID_PAYLOAD.",
    },
    {
        .name  = MPLS_INVALID_ACTIONs,  /* MPLS_INVALID_ACTION */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to MPLS invalid action.\n Label is  BOS (Bottom Of Stack) and TNL_MPLS_DECAP.BOS_ACTIONS is\n set to in valid, or label is NON_BOS (Not Bottom Of Stack) and\n TNL_MPLS_DECAP.NON_BOS_ACTIONS is set to invalid.\n",
    },
    {
        .name  = MPLS_INVALID_ACTION_MASKs,  /* MPLS_INVALID_ACTION_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MPLS_INVALID_ACTION.",
    },
    {
        .name  = MPLS_LABEL_MISSs,  /* MPLS_LABEL_MISS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to MPLS label lookup miss.\n Applicable only for MPLS tunnel termination.\n",
    },
    {
        .name  = MPLS_LABEL_MISS_MASKs,  /* MPLS_LABEL_MISS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MPLS_LABEL_MISS.",
    },
    {
        .name  = MPLS_UNKNOWN_ACH_TYPEs,  /* MPLS_UNKNOWN_ACH_TYPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to MPLS unknown ACH (Associated\n Channel Header) packet.\n",
    },
    {
        .name  = MPLS_UNKNOWN_ACH_TYPE_MASKs,  /* MPLS_UNKNOWN_ACH_TYPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MPLS_UNKNOWN_ACH_TYPE.",
    },
    {
        .name  = L3_MTU_CHECK_FAILs,  /* L3_MTU_CHECK_FAIL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L3 MTU check failure.",
    },
    {
        .name  = L3_MTU_CHECK_FAIL_MASKs,  /* L3_MTU_CHECK_FAIL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L3_MTU_CHECK_FAIL.",
    },
    {
        .name  = SFLOW_FLEX_SAMPLEs,  /* SFLOW_FLEX_SAMPLE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select SFLOW flex sampled packet copied to CPU.",
    },
    {
        .name  = SFLOW_FLEX_SAMPLE_MASKs,  /* SFLOW_FLEX_SAMPLE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SFLOW_FLEX_SAMPLE.",
    },
    {
        .name  = SFLOW_ING_SAMPLEs,  /* SFLOW_ING_SAMPLE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select SFLOW ingress sampled packet copied to CPU.",
    },
    {
        .name  = SFLOW_ING_SAMPLE_MASKs,  /* SFLOW_ING_SAMPLE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SFLOW_ING_SAMPLE.",
    },
    {
        .name  = SFLOW_EGR_SAMPLEs,  /* SFLOW_EGR_SAMPLE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select SFLOW egress sampled packet copied to CPU.",
    },
    {
        .name  = SFLOW_EGR_SAMPLE_MASKs,  /* SFLOW_EGR_SAMPLE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SFLOW_EGR_SAMPLE.",
    },
    {
        .name  = ICMP_REDIRECTs,  /* ICMP_REDIRECT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select ICMP redirect packet copied to CPU.",
    },
    {
        .name  = ICMP_REDIRECT_MASKs,  /* ICMP_REDIRECT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for ICMP_REDIRECT.",
    },
    {
        .name  = FP_INGs,  /* FP_ING */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to ingress FP action.",
    },
    {
        .name  = FP_ING_MASKs,  /* FP_ING_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for FP_ING.",
    },
    {
        .name  = URPF_FAILs,  /* URPF_FAIL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to URPF check failure.",
    },
    {
        .name  = URPF_FAIL_MASKs,  /* URPF_FAIL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for URPF_FAIL.",
    },
    {
        .name  = NHOPs,  /* NHOP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU from next hop table.",
    },
    {
        .name  = NHOP_MASKs,  /* NHOP_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for NHOP.",
    },
    {
        .name  = ECN_TNL_DECAPs,  /* ECN_TNL_DECAP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU from tunnel decap ECN.",
    },
    {
        .name  = ECN_TNL_DECAP_MASKs,  /* ECN_TNL_DECAP_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for ECN_TNL_DECAP.",
    },
    {
        .name  = CBSM_PREVENTEDs,  /* CBSM_PREVENTED */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to CBSM\n (Class Based Station Movement) prevention.\n",
    },
    {
        .name  = CBSM_PREVENTED_MASKs,  /* CBSM_PREVENTED_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for CBSM_PREVENTED.",
    },
    {
        .name  = DLB_MONITORs,  /* DLB_MONITOR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU by DLB monitor.\n",
    },
    {
        .name  = DLB_MONITOR_MASKs,  /* DLB_MONITOR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for DLB_MONITOR.",
    },
    {
        .name  = ETRAP_MONITORs,  /* ETRAP_MONITOR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU by Etrap (elephant trap)\n monitor.\n",
    },
    {
        .name  = ETRAP_MONITOR_MASKs,  /* ETRAP_MONITOR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for ETRAP_MONITOR.",
    },
    {
        .name  = INBAND_TELEMETRY_HOP_LIMITs,  /* INBAND_TELEMETRY_HOP_LIMIT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select inband network telemetry packet copied\n to CPU on exceeding hop limit.\n",
    },
    {
        .name  = INBAND_TELEMETRY_HOP_LIMIT_MASKs,  /* INBAND_TELEMETRY_HOP_LIMIT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for INBAND_TELEMETRY_HOP_LIMIT.",
    },
    {
        .name  = INBAND_TELEMETRY_TURN_AROUNDs,  /* INBAND_TELEMETRY_TURN_AROUND */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select inband network telemetry packet copied\n to CPU when egress port is set to turnaround.\n",
    },
    {
        .name  = INBAND_TELEMETRY_TURN_AROUND_MASKs,  /* INBAND_TELEMETRY_TURN_AROUND_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for INBAND_TELEMETRY_TURN_AROUND.",
    },
    {
        .name  = VFPs,  /* VFP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to VFP action.",
    },
    {
        .name  = VFP_MASKs,  /* VFP_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for VFP.",
    },
    {
        .name  = MC_ID_ERRORs,  /* MC_ID_ERROR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to multicast index error.",
    },
    {
        .name  = MC_ID_ERROR_MASKs,  /* MC_ID_ERROR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MC_ID_ERROR.",
    },
    {
        .name  = TNL_ERRs,  /* TNL_ERR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to tunnel error.",
    },
    {
        .name  = TNL_ERR_MASKs,  /* TNL_ERR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for TNL_ERR.",
    },
    {
        .name  = MARTIAN_ADDRs,  /* MARTIAN_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to Martian address.",
    },
    {
        .name  = MARTIAN_ADDR_MASKs,  /* MARTIAN_ADDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MARTIAN_ADDR.",
    },
    {
        .name  = L3_HDR_ERRs,  /* L3_HDR_ERR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L3 header error.",
    },
    {
        .name  = L3_HDR_ERR_MASKs,  /* L3_HDR_ERR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L3_HDR_ERR.",
    },
    {
        .name  = IP_MC_MISSs,  /* IP_MC_MISS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to IPMC miss.",
    },
    {
        .name  = IP_MC_MISS_MASKs,  /* IP_MC_MISS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for IP_MC_MISS.",
    },
    {
        .name  = L2_MC_MISSs,  /* L2_MC_MISS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L2MC miss.",
    },
    {
        .name  = L2_MC_MISS_MASKs,  /* L2_MC_MISS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L2_MC_MISS.",
    },
    {
        .name  = L3_SRC_MOVEs,  /* L3_SRC_MOVE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L3 station movement.",
    },
    {
        .name  = L3_SRC_MOVE_MASKs,  /* L3_SRC_MOVE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L3_SRC_MOVE.",
    },
    {
        .name  = L3_DST_MISSs,  /* L3_DST_MISS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L3 destination IP\n miss or broadcast destination IP.\n",
    },
    {
        .name  = L3_DST_MISS_MASKs,  /* L3_DST_MISS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L3_DST_MISS.",
    },
    {
        .name  = L3_SRC_MISSs,  /* L3_SRC_MISS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L3 source IP miss.",
    },
    {
        .name  = L3_SRC_MISS_MASKs,  /* L3_SRC_MISS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L3_SRC_MISS.",
    },
    {
        .name  = IP_OPTIONS_PKTs,  /* IP_OPTIONS_PKT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to an IP packet with options.",
    },
    {
        .name  = IP_OPTIONS_PKT_MASKs,  /* IP_OPTIONS_PKT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for IP_OPTIONS_PKT.",
    },
    {
        .name  = TTL_1s,  /* TTL_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select IPMC or L3UC packet with TTL equal to 1 copied to CPU.",
    },
    {
        .name  = TTL_1_MASKs,  /* TTL_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for TTL_1.",
    },
    {
        .name  = PBT_NONUC_PKTs,  /* PBT_NONUC_PKT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to PBT\n (Provider Backbone Transport) packet being non unicast.\n",
    },
    {
        .name  = PBT_NONUC_PKT_MASKs,  /* PBT_NONUC_PKT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for PBT_NONUC_PKT.",
    },
    {
        .name  = L2s,  /* L2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU from L2 table.",
    },
    {
        .name  = L2_MASKs,  /* L2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L2.",
    },
    {
        .name  = L2_MOVEs,  /* L2_MOVE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L2 station movement.",
    },
    {
        .name  = L2_MOVE_MASKs,  /* L2_MOVE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L2_MOVE.",
    },
    {
        .name  = L2_DST_LOOKUP_FAILUREs,  /* L2_DST_LOOKUP_FAILURE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L2 destination lookup failure.",
    },
    {
        .name  = L2_DST_LOOKUP_FAILURE_MASKs,  /* L2_DST_LOOKUP_FAILURE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L2_DST_LOOKUP_FAILURE.",
    },
    {
        .name  = L2_SRC_LOOKUP_FAILUREs,  /* L2_SRC_LOOKUP_FAILURE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to L2 source lookup failure.",
    },
    {
        .name  = L2_SRC_LOOKUP_FAILURE_MASKs,  /* L2_SRC_LOOKUP_FAILURE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for L2_SRC_LOOKUP_FAILURE.",
    },
    {
        .name  = PARITY_ERRORs,  /* PARITY_ERROR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select packet copied to CPU due to parity error\n in ingress pipeline tables.\n",
    },
    {
        .name  = PARITY_ERROR_MASKs,  /* PARITY_ERROR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for PARITY_ERROR.",
    },
    {
        .name  = DOS_ATTACKs,  /* DOS_ATTACK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select DOS attack packet copied to CPU.",
    },
    {
        .name  = DOS_ATTACK_MASKs,  /* DOS_ATTACK_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for DOS_ATTACK.",
    },
    {
        .name  = PVLAN_MISMATCHs,  /* PVLAN_MISMATCH */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select Private VLAN mismatch packet copied to CPU.",
    },
    {
        .name  = PVLAN_MISMATCH_MASKs,  /* PVLAN_MISMATCH_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for PVLAN_MISMATCH.",
    },
    {
        .name  = UNKNOWN_VLANs,  /* UNKNOWN_VLAN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select Unknown VLAN packet copied to CPU.",
    },
    {
        .name  = UNKNOWN_VLAN_MASKs,  /* UNKNOWN_VLAN_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for UNKNOWN_VLAN.",
    },
    {
        .name  = ARP_PROTOCOLs,  /* ARP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select ARP packet copied to CPU.",
    },
    {
        .name  = ARP_PROTOCOL_MASKs,  /* ARP_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for ARP_PROTOCOL.",
    },
    {
        .name  = IGMP_PROTOCOLs,  /* IGMP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select IGMP packet copied to CPU.",
    },
    {
        .name  = IGMP_PROTOCOL_MASKs,  /* IGMP_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for IGMP_PROTOCOL.",
    },
    {
        .name  = DHCP_PROTOCOLs,  /* DHCP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select DHCP packet copied to CPU.",
    },
    {
        .name  = DHCP_PROTOCOL_MASKs,  /* DHCP_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for DHCP_PROTOCOL.",
    },
    {
        .name  = IPMC_RSVD_PROTOCOLs,  /* IPMC_RSVD_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select IPMC reserved packet copied to CPU.",
    },
    {
        .name  = IPMC_RSVD_PROTOCOL_MASKs,  /* IPMC_RSVD_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for IPMC_RSVD_PROTOCOL.",
    },
    {
        .name  = BPDU_PROTOCOLs,  /* BPDU_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select BPDU packet copied to CPU.",
    },
    {
        .name  = BPDU_PROTOCOL_MASKs,  /* BPDU_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for BPDU_PROTOCOL.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to mirror the packets to CPU.",
    },
    {
        .name  = MIRROR_MASKs,  /* MIRROR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for MIRROR.",
    },
    {
        .name  = SWITCHED_PKT_TYPEs,  /* SWITCHED_PKT_TYPE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the type of packet being switched to CPU.",
    },
    {
        .name  = SWITCHED_PKT_TYPE_MASKs,  /* SWITCHED_PKT_TYPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for SWITCHED_PKT_TYPE.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority of the packet to CPU.",
    },
    {
        .name  = INT_PRI_MASKs,  /* INT_PRI_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "MASK for INT_PRI.",
    },
    {
        .name  = KEY0s,  /* KEY0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Flex key 0",
    },
    {
        .name  = KEY0_MASKs,  /* KEY0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for KEY0.",
    },
    {
        .name  = KEY1s,  /* KEY1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Flex key 1.",
    },
    {
        .name  = KEY1_MASKs,  /* KEY1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for KEY1.",
    },
    {
        .name  = KEY2s,  /* KEY2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Flex key 2.",
    },
    {
        .name  = KEY2_MASKs,  /* KEY2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for KEY2.",
    },
    {
        .name  = SWITCHs,  /* SWITCH */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to switch the packets to CPU.",
    },
    {
        .name  = SWITCH_MASKs,  /* SWITCH_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for SWITCH.",
    },
    {
        .name  = CPU_REASONs,  /* CPU_REASON */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Copy to CPU trace event reasons bitmap.",
    },
    {
        .name  = CPU_REASON_MASKs,  /* CPU_REASON_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for CPU_REASON.",
    },
    {
        .name  = HIGHEST_DROP_CODEs,  /* HIGHEST_DROP_CODE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Highest priority drop code.",
    },
    {
        .name  = HIGHEST_DROP_CODE_MASKs,  /* HIGHEST_DROP_CODE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for HIGHEST_DROP_CODE.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies the priority of the entry.",
    },
    {
        .name  = TRUNCATE_CPU_COPYs,  /* TRUNCATE_CPU_COPY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to truncate CPU copy, disable to not truncate CPU copy.",
    },
    {
        .name  = COSs,  /* COS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "COS value.",
    },
    {
        .name  = STRENGTHs,  /* STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Strength of COS map resolution. Used to associate a strength\n to the COS derived from this table.\n",
    },
    {
        .name  = CPU_Q_HI_PRIs,  /* CPU_Q_HI_PRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to select high priority queue.\n Disable to select low priority queue.\n",
    },
    {
        .name  = RQE_COSs,  /* RQE_COS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "RQE COS value.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_cos_q_cpu_map_t = {
    .name = TM_COS_Q_CPU_MAPs, /* TM_COS_Q_CPU_MAP */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 144,
    .field = bcmltd_tm_cos_q_cpu_map_t_fields,
    .desc = "The TM_COS_Q_CPU_MAP table is used to map CPU reason code to\n COS value for packets that are copied to the CPU.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_COS_Q_CPU_STRENGTH_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_cos_q_cpu_strength_profile_t_fields[] = {
    {
        .name  = TM_COS_Q_CPU_STRENGTH_PROFILE_IDs,  /* TM_COS_Q_CPU_STRENGTH_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index to CPU COS queue strength profile table.",
    },
    {
        .name  = CPU_COS_STRENGTHs,  /* CPU_COS_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "CPU COS queue strength.",
    },
    {
        .name  = REPL_Q_NUM_STRENGTHs,  /* REPL_Q_NUM_STRENGTH */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Replication queue (RQE) COS queue strength.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_cos_q_cpu_strength_profile_t = {
    .name = TM_COS_Q_CPU_STRENGTH_PROFILEs, /* TM_COS_Q_CPU_STRENGTH_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_cos_q_cpu_strength_profile_t_fields,
    .desc = "The TM_COS_Q_CPU_STRENGTH_PROFILE table specifies the strength of the TM COS\n COS queue values relative to the COS queue values that may be specified by\n other entities such as PORT or FP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_CUT_THROUGH_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_cut_through_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = CUT_THROUGHs,  /* CUT_THROUGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables cut-through mode.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of\n the entry. The OPERATIONAL_STATE of the entry becomes invalid if the\n mapping between PORT_ID to internal physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_cut_through_port_t = {
    .name = TM_CUT_THROUGH_PORTs, /* TM_CUT_THROUGH_PORT */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_cut_through_port_t_fields,
    .desc = "The TM_CUT_THROUGH_PORT table allows user to enable or disable\n cut-through mode for a given front-panel port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_CUT_THROUGH_PORT_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_cut_through_port_info_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = SRC_PORT_MAX_SPEEDs,  /* SRC_PORT_MAX_SPEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Cut-through source port max-speed (mbps).",
    },
    {
        .name  = CUT_THROUGH_CLASSs,  /* CUT_THROUGH_CLASS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Cut-through class for the port.",
    },
    {
        .name  = MAX_CREDIT_CELLSs,  /* MAX_CREDIT_CELLS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies the maximum credits in cells.",
    },
    {
        .name  = EGR_XMIT_START_COUNT_BYTESs,  /* EGR_XMIT_START_COUNT_BYTES */
        .flags = 0,
        .width = 16,
        .depth = 8,
        .desc = "Specifies the transmit start count in bytes.",
    },
    {
        .name  = FIFO_THD_CELLSs,  /* FIFO_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Cut-through fifo threshold in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of\n the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_cut_through_port_info_t = {
    .name = TM_CUT_THROUGH_PORT_INFOs, /* TM_CUT_THROUGH_PORT_INFO */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_tm_cut_through_port_info_t_fields,
    .desc = "The TM_CUT_THROUGH_PORT_INFO table is a read-only table which specifies\n cut-through properties of front-panel port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_DEVICE_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_device_info_t_fields[] = {
    {
        .name  = MAX_PKT_SIZEs,  /* MAX_PKT_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum packet size in bytes.",
    },
    {
        .name  = PKT_HDR_SIZEs,  /* PKT_HDR_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Packet header size in bytes.",
    },
    {
        .name  = JUMBO_PKT_SIZEs,  /* JUMBO_PKT_SIZE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Jumbo packet size in bytes.",
    },
    {
        .name  = DEFAULT_MTUs,  /* DEFAULT_MTU */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Default MTU size in bytes.",
    },
    {
        .name  = CELL_SIZEs,  /* CELL_SIZE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Size of single buffer cell in bytes.",
    },
    {
        .name  = NUM_CELLSs,  /* NUM_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of Cells (TM buffer memory size).",
    },
    {
        .name  = NUM_PORT_PRI_GRPs,  /* NUM_PORT_PRI_GRP */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of supported port-pg instances.",
    },
    {
        .name  = NUM_SERVICE_POOLs,  /* NUM_SERVICE_POOL */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of supported service pools.",
    },
    {
        .name  = NUM_Qs,  /* NUM_Q */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Maximum number of unicast and multicast queues supported for\n non-cpu ports.\n",
    },
    {
        .name  = NUM_CPU_Qs,  /* NUM_CPU_Q */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Maximum number of queues supported for the CPU port.\n The CPU port supports only multicast queues.\n",
    },
    {
        .name  = NUM_PIPEs,  /* NUM_PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of pipes.",
    },
    {
        .name  = NUM_MC_REPL_RESOURCE_FREEs,  /* NUM_MC_REPL_RESOURCE_FREE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of multicast free resource available",
    },
    {
        .name  = NUM_NHOP_SPARSE_MODEs,  /* NUM_NHOP_SPARSE_MODE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of next hop entries per multicast resource in sparse mode.",
    },
    {
        .name  = NUM_NHOP_DENSE_MODEs,  /* NUM_NHOP_DENSE_MODE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of next hop entries per multicast resource in dense mode.",
    },
    {
        .name  = MAX_NUM_MC_REPLs,  /* MAX_NUM_MC_REPL */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum number of replication for a given TM_MC_GROUP_ID.",
    },
    {
        .name  = NUM_BUFFER_POOLs,  /* NUM_BUFFER_POOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of Buffer pools.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_device_info_t = {
    .name = TM_DEVICE_INFOs, /* TM_DEVICE_INFO */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_tm_device_info_t_fields,
    .desc = "The TM_DEVICE_INFO is a read-only table which specifies device specific TM\n information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EBST_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ebst_control_t_fields[] = {
    {
        .name  = SCAN_ROUNDs,  /* SCAN_ROUND */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Value in clock cycles defining the frequency of an EBST\n scan round. The minimum value must be greater than the\n worst case scan round duration.\n The worst case scan round duration is defined as\n (clock cycles required to scan all configured EBST nodes +\n  clock cycles required to read all configured EBST nodes)\n",
    },
    {
        .name  = SCAN_THDs,  /* SCAN_THD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Scan threshold. The scan process will start if the number of\n available entries in the EBST FIFO is greater than SCAN_THD.\n",
    },
    {
        .name  = SCAN_MODEs,  /* SCAN_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_EBST_SCAN_MODE_T_DATA,
        .desc = "EBST scan mode.",
    },
    {
        .name  = EBSTs,  /* EBST */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_EBST_ENABLE_MODE_T_DATA,
        .desc = "EBST enable mode.\n Application is restricted from setting the mode to EBST_FIFO_FULL.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ebst_control_t = {
    .name = TM_EBST_CONTROLs, /* TM_EBST_CONTROL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_ebst_control_t_fields,
    .desc = "The TM_EBST_CONTROL table is used to configure\n global parameters for event BST (EBST).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EBST_DATA.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ebst_data_t_fields[] = {
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool.",
    },
    {
        .name  = TM_EBST_DATA_IDs,  /* TM_EBST_DATA_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the EBST data table.",
    },
    {
        .name  = TIMESTAMPs,  /* TIMESTAMP */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Timestamp of the instance when the buffer occupancy\n level was recorded.\n",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Buffer occupancy level in cells.",
    },
    {
        .name  = GREEN_DROPs,  /* GREEN_DROP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_EBST_GREEN_DROP_STATE_T_DATA,
        .desc = "Green drop state.",
    },
    {
        .name  = YELLOW_DROPs,  /* YELLOW_DROP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_EBST_YELLOW_DROP_STATE_T_DATA,
        .desc = "Yellow drop state.",
    },
    {
        .name  = RED_DROPs,  /* RED_DROP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_EBST_RED_DROP_STATE_T_DATA,
        .desc = "Red drop state.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ebst_data_t = {
    .name = TM_EBST_DATAs, /* TM_EBST_DATA */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_tm_ebst_data_t_fields,
    .desc = "The TM_EBST_DATA table displays the EBST timestamp\n and the buffer utilization level at the given timestamp.\n An application is expected to map a block of consecutive indices\n with an EBST entity before enabling the EBST operation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EBST_MC_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ebst_mc_q_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue ID",
    },
    {
        .name  = MONITORs,  /* MONITOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to monitor the queue during an EBST scan.",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Base index in the TM_EBST_DATA table for the block\n associated with the queue.\n",
    },
    {
        .name  = NUM_ENTRIESs,  /* NUM_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries starting from BASE_INDEX\n associated with the queue in the TM_EBST_DATA table.\n",
    },
    {
        .name  = TM_EBST_DATA_IDs,  /* TM_EBST_DATA_ID */
        .flags = 0,
        .width = 32,
        .depth = 2,
        .desc = "Read only field indicating the last updated entry\n in the TM_EBST_DATA table associated with the queue.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_MC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ebst_mc_q_t = {
    .name = TM_EBST_MC_Qs, /* TM_EBST_MC_Q */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_tm_ebst_mc_q_t_fields,
    .desc = "The TM_EBST_MC_Q table is used to configure the\n multicast queue level parameters for event BST (EBST).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EBST_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ebst_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID",
    },
    {
        .name  = MONITORs,  /* MONITOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to monitor all the service pools of the port\n during an EBST scan.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ebst_port_t = {
    .name = TM_EBST_PORTs, /* TM_EBST_PORT */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_ebst_port_t_fields,
    .desc = "The TM_EBST_PORT table is used to configure the\n port level parameters of all the associated\n service pools for event BST (EBST).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EBST_PORT_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ebst_port_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = UC_BASE_INDEXs,  /* UC_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Base index in the TM_EBST_DATA table for the block\n associated with the unicast port service pool.\n",
    },
    {
        .name  = UC_NUM_ENTRIESs,  /* UC_NUM_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries starting from BASE_INDEX\n associated with the unicast port service pool\n in the TM_EBST_DATA table.\n",
    },
    {
        .name  = UC_TM_EBST_DATA_IDs,  /* UC_TM_EBST_DATA_ID */
        .flags = 0,
        .width = 32,
        .depth = 2,
        .desc = "Read only field indicating the last updated entry\n in the TM_EBST_DATA table associated with the\n unicast port service pool.\n",
    },
    {
        .name  = MC_BASE_INDEXs,  /* MC_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Base index in the TM_EBST_DATA table for the block\n associated with the multicast port service pool.\n",
    },
    {
        .name  = MC_NUM_ENTRIESs,  /* MC_NUM_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries starting from BASE_INDEX\n associated with the multicast port service pool\n in the TM_EBST_DATA table.\n",
    },
    {
        .name  = MC_TM_EBST_DATA_IDs,  /* MC_TM_EBST_DATA_ID */
        .flags = 0,
        .width = 32,
        .depth = 2,
        .desc = "Read only field indicating the last updated entry\n in the TM_EBST_DATA table associated with the\n multicast port service pool.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ebst_port_service_pool_t = {
    .name = TM_EBST_PORT_SERVICE_POOLs, /* TM_EBST_PORT_SERVICE_POOL */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_tm_ebst_port_service_pool_t_fields,
    .desc = "The TM_EBST_PORT_SERVICE_POOL table is used to configure the\n service pools for event BST (EBST).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EBST_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ebst_profile_t_fields[] = {
    {
        .name  = TM_EBST_PROFILE_IDs,  /* TM_EBST_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Profile ID.",
    },
    {
        .name  = START_THDs,  /* START_THD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Start threshold level in cells.",
    },
    {
        .name  = STOP_THDs,  /* STOP_THD */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Stop threshold level in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ebst_profile_t = {
    .name = TM_EBST_PROFILEs, /* TM_EBST_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_ebst_profile_t_fields,
    .desc = "The TM_EBST_PROFILE table is used to configure the\n start and stop thresholds of an event BST (EBST) profile.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EBST_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ebst_service_pool_t_fields[] = {
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID",
    },
    {
        .name  = MONITORs,  /* MONITOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to monitor the service pools\n during an EBST scan.\n",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Base index in the TM_EBST_DATA table for the block\n associated with the service pool.\n",
    },
    {
        .name  = NUM_ENTRIESs,  /* NUM_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries starting from BASE_INDEX\n associated with the service pool in the TM_EBST_DATA table.\n",
    },
    {
        .name  = TM_EBST_DATA_IDs,  /* TM_EBST_DATA_ID */
        .flags = 0,
        .width = 32,
        .depth = 2,
        .desc = "Read-only field indicating the last updated entry\n in the TM_EBST_DATA table associated with the service pool.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_EBST_MONITOR_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry. The operational state is valid\n when any port/queue's EBST monitor is enabled and\n the service pool's monitor is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ebst_service_pool_t = {
    .name = TM_EBST_SERVICE_POOLs, /* TM_EBST_SERVICE_POOL */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_ebst_service_pool_t_fields,
    .desc = "The TM_EBST_SERVICE_POOL table is used to configure the\n port level parameters of all the associated\n service pools for event BST (EBST).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EBST_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ebst_status_t_fields[] = {
    {
        .name  = EBSTs,  /* EBST */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_EBST_ENABLE_MODE_T_DATA,
        .desc = "EBST state information.",
    },
    {
        .name  = FIFO_FULLs,  /* FIFO_FULL */
        .flags = 0,
        .width = 1,
        .depth = 2,
        .desc = "Read-only field which determines the hardware FIFO state.\n The field is enabled when hardware FIFO full interrupt is generated.\n The application should consider increasing\n TM_EBST_CONTROL.SCAN_ROUND time.\n This detail on how to recover from this state is explained in user\n guide.\n Interrupt can be cleared by resetting TM_EBST_CONTROL.EBST.\n Applicable only if TM_EBST_STATUS.EBST == EBST_FIFO_FULL.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ebst_status_t = {
    .name = TM_EBST_STATUSs, /* TM_EBST_STATUS */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tm_ebst_status_t_fields,
    .desc = "The TM_EBST_STATUS table is used to provide\n the status of the EBST operation.\n Application can poll or subscribe to the table\n to determine the EBST state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EBST_UC_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ebst_uc_q_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID",
    },
    {
        .name  = MONITORs,  /* MONITOR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to monitor the queue during an EBST scan.",
    },
    {
        .name  = BASE_INDEXs,  /* BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Base index in the TM_EBST_DATA table for the block\n associated with the queue.\n",
    },
    {
        .name  = NUM_ENTRIESs,  /* NUM_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of entries starting from BASE_INDEX\n associated with the queue in the TM_EBST_DATA table.\n",
    },
    {
        .name  = TM_EBST_DATA_IDs,  /* TM_EBST_DATA_ID */
        .flags = 0,
        .width = 32,
        .depth = 2,
        .desc = "Read only field indicating the last updated entry\n in the TM_EBST_DATA table associated with the queue.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_UC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ebst_uc_q_t = {
    .name = TM_EBST_UC_Qs, /* TM_EBST_UC_Q */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_tm_ebst_uc_q_t_fields,
    .desc = "The TM_EBST_UC_Q table is used to configure the\n unicast queue level parameters for the event BST (EBST).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EGR_BST_THD_MC_PORT_SERVICE_POOL_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_egr_bst_thd_mc_port_service_pool_profile_t_fields[] = {
    {
        .name  = TM_EGR_BST_THD_MC_PORT_SERVICE_POOL_PROFILE_IDs,  /* TM_EGR_BST_THD_MC_PORT_SERVICE_POOL_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the egress multicast port service pool\n threshold profile table.\n",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Egress port service pool threshold in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_egr_bst_thd_mc_port_service_pool_profile_t = {
    .name = TM_EGR_BST_THD_MC_PORT_SERVICE_POOL_PROFILEs, /* TM_EGR_BST_THD_MC_PORT_SERVICE_POOL_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tm_egr_bst_thd_mc_port_service_pool_profile_t_fields,
    .desc = "TM_EGR_BST_THD_MC_PORT_SERVICE_POOL_PROFILE is a profile table\n used to configure BST threshold values per multicast port service pool.\n This profile is used by TM_EGR_THD_MC_PORT_SERVICE_POOL.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EGR_BST_THD_Q_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_egr_bst_thd_q_profile_t_fields[] = {
    {
        .name  = TM_EGR_BST_THD_Q_PROFILE_IDs,  /* TM_EGR_BST_THD_Q_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the egress queue threshold profile table.",
    },
    {
        .name  = UC_Q_CELLSs,  /* UC_Q_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "UC Queue Threshold in cells.",
    },
    {
        .name  = MC_Q_CELLSs,  /* MC_Q_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "MC Queue Threshold in cells.",
    },
    {
        .name  = CPU_Q_CELLSs,  /* CPU_Q_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "CPU Queue Threshold in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_egr_bst_thd_q_profile_t = {
    .name = TM_EGR_BST_THD_Q_PROFILEs, /* TM_EGR_BST_THD_Q_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_egr_bst_thd_q_profile_t_fields,
    .desc = "TM_EGR_BST_THD_Q_PROFILE is a profile table used to configure\n BST threshold values per egress queue. These profiles are\n referenced by Traffic Manager Queue threshold tables.\n This profile is used by TM_THD_UC_Q and TM_THD_MC_Q.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EGR_BST_THD_UC_PORT_SERVICE_POOL_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_egr_bst_thd_uc_port_service_pool_profile_t_fields[] = {
    {
        .name  = TM_EGR_BST_THD_UC_PORT_SERVICE_POOL_PROFILE_IDs,  /* TM_EGR_BST_THD_UC_PORT_SERVICE_POOL_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the egress unicast port service pool\n threshold profile table.\n",
    },
    {
        .name  = CELLSs,  /* CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Egress port service pool threshold in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_egr_bst_thd_uc_port_service_pool_profile_t = {
    .name = TM_EGR_BST_THD_UC_PORT_SERVICE_POOL_PROFILEs, /* TM_EGR_BST_THD_UC_PORT_SERVICE_POOL_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tm_egr_bst_thd_uc_port_service_pool_profile_t_fields,
    .desc = "TM_EGR_BST_THD_UC_PORT_SERVICE_POOL_PROFILE is a profile table\n used to configure BST threshold values per unicast port service pool.\n This profile is used by TM_EGR_THD_UC_PORT_SERVICE_POOL.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EGR_OBJECT_UPDATE_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_egr_object_update_profile_t_fields[] = {
    {
        .name  = TM_EGR_OBJECT_UPDATE_PROFILE_IDs,  /* TM_EGR_OBJECT_UPDATE_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TM_EGR_OBJECT_UPDATE_PROFILE logical table index.",
    },
    {
        .name  = EGR_OBJ_INDEX_SEL_0s,  /* EGR_OBJ_INDEX_SEL_0 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Egress object 0 override control.",
    },
    {
        .name  = EGR_OBJ_INDEX_SEL_1s,  /* EGR_OBJ_INDEX_SEL_1 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Egress object 1 override control.",
    },
    {
        .name  = EGR_OBJ_INDEX_SEL_2s,  /* EGR_OBJ_INDEX_SEL_2 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Egress object 2 override control.",
    },
    {
        .name  = EGR_OBJ_INDEX_SEL_3s,  /* EGR_OBJ_INDEX_SEL_3 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Egress object 3 override control.",
    },
    {
        .name  = EGR_OBJ_INDEX_SEL_4s,  /* EGR_OBJ_INDEX_SEL_4 */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Egress object 4 override control.",
    },
    {
        .name  = TRUST_EGR_OBJ_TABLE_SEL_0s,  /* TRUST_EGR_OBJ_TABLE_SEL_0 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Trust EGR_OBJ_TABLE_SEL_0.",
    },
    {
        .name  = EGR_OBJ_TABLE_SEL_0s,  /* EGR_OBJ_TABLE_SEL_0 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Egress object tables selection.",
    },
    {
        .name  = TRUST_EGR_OBJ_TABLE_SEL_1s,  /* TRUST_EGR_OBJ_TABLE_SEL_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Trust EGR_OBJ_TABLE_SEL_1.",
    },
    {
        .name  = EGR_OBJ_TABLE_SEL_1s,  /* EGR_OBJ_TABLE_SEL_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Egress object tables selection.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_egr_object_update_profile_t = {
    .name = TM_EGR_OBJECT_UPDATE_PROFILEs, /* TM_EGR_OBJECT_UPDATE_PROFILE */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_tm_egr_object_update_profile_t_fields,
    .desc = "The TM_EGR_OBJECT_UPDATE_PROFILE table is used to\n update egress objects and select tables.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EGR_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_egr_service_pool_t_fields[] = {
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = OOBFC_MERGE_UC_Q_POOL_STATEs,  /* OOBFC_MERGE_UC_Q_POOL_STATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to merge pool congestion state with unicast queue\n congestion state for out of band flow control (OOBFC).\n When disabled, only the unicast queue congestion state is reported.\n",
    },
    {
        .name  = OOBFC_MERGE_MC_Q_POOL_STATEs,  /* OOBFC_MERGE_MC_Q_POOL_STATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to merge pool congestion state with multicast queue\n congestion state for out of band flow control (OOBFC).\n When disabled, only the multicast queue congestion state is reported.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_egr_service_pool_t = {
    .name = TM_EGR_SERVICE_POOLs, /* TM_EGR_SERVICE_POOL */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_egr_service_pool_t_fields,
    .desc = "The TM_EGR_SERVICE_POOL specifies per egress service pool\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EGR_SERVICE_POOL_DYNAMIC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_egr_service_pool_dynamic_t_fields[] = {
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = ADAPTIVE_DYNAMICs,  /* ADAPTIVE_DYNAMIC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Dynamic value for computing high priority queue service pool\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_egr_service_pool_dynamic_t = {
    .name = TM_EGR_SERVICE_POOL_DYNAMICs, /* TM_EGR_SERVICE_POOL_DYNAMIC */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_egr_service_pool_dynamic_t_fields,
    .desc = "The TM_EGR_SERVICE_POOL_DYNAMIC table is used to specify the dynamic\n value used in computing the high priority queue service pool margin.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EGR_THD_MC_PORT_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_egr_thd_mc_port_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Egress service pool ID.",
    },
    {
        .name  = SHARED_LIMITSs,  /* SHARED_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use shared buffer limit.",
    },
    {
        .name  = SHARED_LIMIT_CELLSs,  /* SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit in cells.\n Packets gets discarded once the share count crosses SHARED_LIMIT_CELLS.\n",
    },
    {
        .name  = SHARED_RESUME_LIMIT_CELLSs,  /* SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Transmission resume limit in cells.",
    },
    {
        .name  = SHARED_RESUME_LIMIT_CELLS_OPERs,  /* SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational transmission resume limit in\n cells. It can be different than the configured SHARED_RESUME_LIMIT_CELLS\n if the configured value is not in 8-cell granularity.\n",
    },
    {
        .name  = COLOR_SPECIFIC_LIMITSs,  /* COLOR_SPECIFIC_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use color based discards shared buffer limits.",
    },
    {
        .name  = YELLOW_SHARED_LIMIT_CELLSs,  /* YELLOW_SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit for yellow packets in cells.",
    },
    {
        .name  = YELLOW_SHARED_LIMIT_CELLS_OPERs,  /* YELLOW_SHARED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for yellow packets. It can be different than the configured\n YELLOW_SHARED_LIMIT_CELLS if the configured value is not in 8-cell\n granularity.\n",
    },
    {
        .name  = YELLOW_SHARED_RESUME_LIMIT_CELLSs,  /* YELLOW_SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Transmission resume limits in cells for yellow packets.",
    },
    {
        .name  = YELLOW_SHARED_RESUME_LIMIT_CELLS_OPERs,  /* YELLOW_SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational absolute resume limit for\n yellow packets in cells. It can be different than the configured\n YELLOW_SHARED_RESUME_LIMIT_CELLS if the configured value is not in\n 8-cell granularity.\n",
    },
    {
        .name  = RED_SHARED_LIMIT_CELLSs,  /* RED_SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit for red packets in cells.",
    },
    {
        .name  = RED_SHARED_LIMIT_CELLS_OPERs,  /* RED_SHARED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for red packets. It can be different than the configured\n RED_SHARED_LIMIT_CELLS if the configured value is not in 8-cell\n granularity.\n",
    },
    {
        .name  = RED_SHARED_RESUME_LIMIT_CELLSs,  /* RED_SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Transmission resume limit in cells for red packets.",
    },
    {
        .name  = RED_SHARED_RESUME_LIMIT_CELLS_OPERs,  /* RED_SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational absolute resume limit for\n red packets in cells. It can be different than the configured\n RED_SHARED_RESUME_LIMIT_CELLS if the configured value is not in\n 8-cell granularity.\n",
    },
    {
        .name  = TM_EGR_BST_THD_MC_PORT_SERVICE_POOL_PROFILE_IDs,  /* TM_EGR_BST_THD_MC_PORT_SERVICE_POOL_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_EGR_BST_THD_MC_PORT_SERVICE_POOL_PROFILE table index. Provides the profile ID\n to be used for egress port service pool BST thresholds.\n",
    },
    {
        .name  = TM_EBST_PROFILE_IDs,  /* TM_EBST_PROFILE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "TM_EBST_PROFILE table index. It provides the index to the\n EBST thresholds profile table.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if the\n mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_egr_thd_mc_port_service_pool_t = {
    .name = TM_EGR_THD_MC_PORT_SERVICE_POOLs, /* TM_EGR_THD_MC_PORT_SERVICE_POOL */
    .flags = 0,
    .fields = 18,
    .field = bcmltd_tm_egr_thd_mc_port_service_pool_t_fields,
    .desc = "The TM_EGR_THD_MC_PORT_SERVICE_POOL table specifies buffer thresholds for\n multicast traffic on a per {port, service pool} basis.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EGR_THD_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_egr_thd_service_pool_t_fields[] = {
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = SHARED_LIMIT_CELLSs,  /* SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit in cells.\n For all service pools in the same buffer pool, the sum of the\n SHARED_LIMIT_CELLS should always equal the total shared buffer cells.\n When adjusting SHARED_LIMIT_CELLS for a service pool, it is highly\n recommended to also adjust the SHARED_LIMIT_CELLS across other service\n pools in order to avoid changing the total shared buffer cells.\n The SHARED_LIMIT_CELLS must be programmed to be the same as the\n SHARED_LIMIT_CELLS in the TM_ING_THD_SERVICE_POOL table.\n",
    },
    {
        .name  = SHARED_LIMIT_CELLS_OPERs,  /* SHARED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational shared buffer limit cells. This read-only field reflects\n any modification to the configured SHARED_LIMIT_CELLS as a function\n of all reserved resources (minimum guarantee and headroom pool limit)\n associated to the specified service pool. Increasing/decreasing a\n reserved resource by certain amount results in decreasing/increasing\n of the corresponding service pool shared limit by the same amount.\n",
    },
    {
        .name  = SHARED_RESUME_LIMIT_CELLSs,  /* SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static transmit resume limit in cells.",
    },
    {
        .name  = SHARED_RESUME_LIMIT_CELLS_OPERs,  /* SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational resume offset limit in\n cells. It can be different than the configured SHARED_RESUME_LIMIT_CELLS\n if the configured value is larger than SHARED_LIMIT_CELLS or it is\n not in 8-cell granularity.\n",
    },
    {
        .name  = COLOR_SPECIFIC_LIMITSs,  /* COLOR_SPECIFIC_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets based on color specific shared buffer limits.\n All color specific shared buffer limits and resume limits should\n still be properly configured if COLOR_SPECIFIC_LIMITS is disabled.\n",
    },
    {
        .name  = YELLOW_SHARED_LIMIT_CELLSs,  /* YELLOW_SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit for yellow packets in cells. Yellow packets are\n dropped when exceeds YELLOW_SHARED_LIMIT_CELLS if\n USE_COLOR_SPECIFIC_LIMITS is enabled.\n",
    },
    {
        .name  = YELLOW_SHARED_LIMIT_CELLS_OPERs,  /* YELLOW_SHARED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for yellow packets. It can be different than the configured\n YELLOW_SHARED_LIMIT_CELLS if the configured value is larger than\n SHARED_LIMIT_CELLS or it is not in 8-cell granularity.\n",
    },
    {
        .name  = YELLOW_SHARED_RESUME_LIMIT_CELLSs,  /* YELLOW_SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Transmission resume limit (in cells) for yellow packets.",
    },
    {
        .name  = YELLOW_SHARED_RESUME_LIMIT_CELLS_OPERs,  /* YELLOW_SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational resume offset limit for\n yellow packets in cells. It can be different than the configured\n YELLOW_SHARED_RESUME_LIMIT_CELLS if the configured value is larger\n than YELLOW_SHARED_LIMIT_CELLS or it is not in 8-cell granularity.\n",
    },
    {
        .name  = RED_SHARED_LIMIT_CELLSs,  /* RED_SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit for red packets in cells. Red packets are\n dropped when exceeds RED_SHARED_LIMIT_CELLS if\n USE_COLOR_SPECIFIC_LIMITS is enabled.\n",
    },
    {
        .name  = RED_SHARED_LIMIT_CELLS_OPERs,  /* RED_SHARED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for red packets. It can be different than the configured\n RED_SHARED_LIMIT_CELLS if the configured value is larger than\n SHARED_LIMIT_CELLS or it is not in 8-cell granularity.\n",
    },
    {
        .name  = RED_SHARED_RESUME_LIMIT_CELLSs,  /* RED_SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Transmission resume limit (in cells) for red packets.",
    },
    {
        .name  = RED_SHARED_RESUME_LIMIT_CELLS_OPERs,  /* RED_SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational resume offset limit for red\n packets in cells. It can be different than the configured\n RED_SHARED_RESUME_LIMIT_CELLS if the configured value is larger than\n RED_SHARED_LIMIT_CELLS or it is not in 8-cell granularity.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_EGR_THD_SERVICE_POOL_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE becomes invalid due to one of the following reasons:\n The SHARED_LIMIT_CELLS cannot be allocated without decreasing the\n other service pool's shared limit.\n Any of the resume limits is larger than its corresponding drop limit.\n Any of the color limit is larger than SHARED_LIMIT_CELLS.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_egr_thd_service_pool_t = {
    .name = TM_EGR_THD_SERVICE_POOLs, /* TM_EGR_THD_SERVICE_POOL */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_tm_egr_thd_service_pool_t_fields,
    .desc = "The TM_EGR_THD_SERVICE_POOL table specifies buffer thresholds per egress\n service pool.\n\n For some devices, there are multiple buffer pools. Each buffer pool contains\n a complete set of egress service pools. By default, the buffer thresholds\n of a specific egress service pool across different buffer pools are the same.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_EGR_THD_UC_PORT_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_egr_thd_uc_port_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Egress service pool ID.",
    },
    {
        .name  = SHARED_LIMITSs,  /* SHARED_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use shared buffer limit.",
    },
    {
        .name  = SHARED_LIMIT_CELLSs,  /* SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit in cells.\n Packets gets discarded once the shared count crosses SHARED_LIMIT_CELLS.\n",
    },
    {
        .name  = SHARED_RESUME_LIMIT_CELLSs,  /* SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Transmission resume limit in cells.",
    },
    {
        .name  = SHARED_RESUME_LIMIT_CELLS_OPERs,  /* SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational transmission resume limit in\n cells. It can be different than the configured SHARED_RESUME_LIMIT_CELLS\n if the configured value is not in 8-cell granularity.\n",
    },
    {
        .name  = COLOR_SPECIFIC_LIMITSs,  /* COLOR_SPECIFIC_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use color based discards shared buffer limits.",
    },
    {
        .name  = YELLOW_SHARED_LIMIT_CELLSs,  /* YELLOW_SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit for yellow packets in cells.",
    },
    {
        .name  = YELLOW_SHARED_LIMIT_CELLS_OPERs,  /* YELLOW_SHARED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for yellow packets. It can be different than the configured\n YELLOW_SHARED_LIMIT_CELLS if the configured value is not in 8-cell\n granularity.\n",
    },
    {
        .name  = YELLOW_SHARED_RESUME_LIMIT_CELLSs,  /* YELLOW_SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Transmission resume limits in cells for yellow packets.",
    },
    {
        .name  = YELLOW_SHARED_RESUME_LIMIT_CELLS_OPERs,  /* YELLOW_SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational absolute resume limit for\n yellow packets in cells. It can be different than the configured\n YELLOW_SHARED_RESUME_LIMIT_CELLS if the configured value is not in\n 8-cell granularity.\n",
    },
    {
        .name  = RED_SHARED_LIMIT_CELLSs,  /* RED_SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit for red packets in cells.",
    },
    {
        .name  = RED_SHARED_LIMIT_CELLS_OPERs,  /* RED_SHARED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for red packets. It can be different than the configured\n RED_SHARED_LIMIT_CELLS if the configured value is not in 8-cell\n granularity.\n",
    },
    {
        .name  = RED_SHARED_RESUME_LIMIT_CELLSs,  /* RED_SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Transmission resume limit in cells for red packets.",
    },
    {
        .name  = RED_SHARED_RESUME_LIMIT_CELLS_OPERs,  /* RED_SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational absolute resume limit for red\n packets in cells. It can be different than the configured\n RED_SHARED_RESUME_LIMIT_CELLS if the configured value is not in\n 8-cell granularity.\n",
    },
    {
        .name  = TM_EGR_BST_THD_UC_PORT_SERVICE_POOL_PROFILE_IDs,  /* TM_EGR_BST_THD_UC_PORT_SERVICE_POOL_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_EGR_BST_THD_UC_PORT_SERVICE_POOL_PROFILE table index. Provides the profile ID\n to be used for egress port service pool BST thresholds.\n",
    },
    {
        .name  = TM_EBST_PROFILE_IDs,  /* TM_EBST_PROFILE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "TM_EBST_PROFILE table index. It provides the index to the\n EBST thresholds profile table.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if the\n mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_egr_thd_uc_port_service_pool_t = {
    .name = TM_EGR_THD_UC_PORT_SERVICE_POOLs, /* TM_EGR_THD_UC_PORT_SERVICE_POOL */
    .flags = 0,
    .fields = 18,
    .field = bcmltd_tm_egr_thd_uc_port_service_pool_t_fields,
    .desc = "The TM_EGR_THD_UC_PORT_SERVICE_POOL table specifies buffer thresholds for\n unicast traffic on a per {port, service pool} basis.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_ING_BST_THD_PORT_SERVICE_POOL_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ing_bst_thd_port_service_pool_profile_t_fields[] = {
    {
        .name  = TM_ING_BST_THD_PORT_SERVICE_POOL_PROFILE_IDs,  /* TM_ING_BST_THD_PORT_SERVICE_POOL_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the BST ingress port service pool\n threshold profile table.\n",
    },
    {
        .name  = SHARED_CELLSs,  /* SHARED_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Port service pool shared threshold in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ing_bst_thd_port_service_pool_profile_t = {
    .name = TM_ING_BST_THD_PORT_SERVICE_POOL_PROFILEs, /* TM_ING_BST_THD_PORT_SERVICE_POOL_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tm_ing_bst_thd_port_service_pool_profile_t_fields,
    .desc = "TM_ING_BST_THD_PORT_SERVICE_POOL_PROFILE is a profile table used\n to configure threshold values for ingress port service pool.\n This profile is used by TM_ING_THD_PORT_SERVICE_POOL.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_ING_BST_THD_PRI_GRP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ing_bst_thd_pri_grp_profile_t_fields[] = {
    {
        .name  = TM_ING_BST_THD_PRI_GRP_PROFILE_IDs,  /* TM_ING_BST_THD_PRI_GRP_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the BST priority group threshold profile table.",
    },
    {
        .name  = SHARED_CELLSs,  /* SHARED_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared threshold in cells.",
    },
    {
        .name  = HEADROOM_CELLSs,  /* HEADROOM_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Headroom threshold in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ing_bst_thd_pri_grp_profile_t = {
    .name = TM_ING_BST_THD_PRI_GRP_PROFILEs, /* TM_ING_BST_THD_PRI_GRP_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_ing_bst_thd_pri_grp_profile_t_fields,
    .desc = "The TM_ING_BST_THD_PRI_GRP_PROFILE is a profile table used to\n configure thresholds values for per priority group ingress\n tracking counters.\n This profile is used by TM_ING_THD_PORT_PRI_GRP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_ING_NONUC_ING_PRI_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ing_nonuc_ing_pri_map_t_fields[] = {
    {
        .name  = TM_ING_NONUC_ING_PRI_MAP_IDs,  /* TM_ING_NONUC_ING_PRI_MAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the TM_ING_NONUC_ING_PRI_MAP table.",
    },
    {
        .name  = ING_PRIs,  /* ING_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Input priority.",
    },
    {
        .name  = TM_PRI_GRP_IDs,  /* TM_PRI_GRP_ID */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Priority group ID.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ing_nonuc_ing_pri_map_t = {
    .name = TM_ING_NONUC_ING_PRI_MAPs, /* TM_ING_NONUC_ING_PRI_MAP */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_ing_nonuc_ing_pri_map_t_fields,
    .desc = "The TM_ING_NONUC_ING_PRI_MAP table specifies the map between input priority\n and priority group for non-unicast traffic.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_ING_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ing_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = ING_PRI_MAP_IDs,  /* ING_PRI_MAP_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the  TM_ING_UC_ING_PRI_MAP and TM_ING_NONUC_ING_PRI_MAP\n logical tables.\n",
    },
    {
        .name  = PRI_GRP_MAP_IDs,  /* PRI_GRP_MAP_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Index into the TM_PRI_GRP_POOL_MAP logical table.",
    },
    {
        .name  = PAUSEs,  /* PAUSE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use pause flow control.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE becomes invalid if the mapping between PORT_ID\n and the physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ing_port_t = {
    .name = TM_ING_PORTs, /* TM_ING_PORT */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tm_ing_port_t_fields,
    .desc = "The TM_ING_PORT table specifies the ingress port related traffic manager\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_ING_PORT_PRI_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ing_port_pri_grp_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_PRI_GRP_IDs,  /* TM_PRI_GRP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Priority group.",
    },
    {
        .name  = ING_MIN_MODEs,  /* ING_MIN_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Ingress minimum mode that indicates which minimum threshold\n is used for ingress.\n",
    },
    {
        .name  = LOSSLESSs,  /* LOSSLESS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set priority group as lossless.",
    },
    {
        .name  = PFCs,  /* PFC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable PFC on the priority group.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE becomes invalid if the mapping between PORT_ID\n and the physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ing_port_pri_grp_t = {
    .name = TM_ING_PORT_PRI_GRPs, /* TM_ING_PORT_PRI_GRP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_ing_port_pri_grp_t_fields,
    .desc = "The TM_ING_PORT_PRI_GRP table specifies traffic manager configurations per\n port, per priority group. This table must not be updated while traffic is\n flowing.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_ING_THD_HEADROOM_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ing_thd_headroom_pool_t_fields[] = {
    {
        .name  = TM_HEADROOM_POOL_IDs,  /* TM_HEADROOM_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Headroom pool ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = LIMIT_CELLSs,  /* LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Headroom buffer usage limit in cells for all ports\n belonging to TM_THD_HEADROOM_POOL_ID.\n",
    },
    {
        .name  = LIMIT_CELLS_OPERs,  /* LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "This read-only field reflects the operational headroom buffer usage\n limit in cells. It can be different than the configured LIMIT_CELLS\n if the configured value cannot be allocated.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_ING_THD_HEADROOM_POOL_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE becomes invalid if LIMIT_CELLS exceeds the\n total available buffer size of the specified BUFFER_POOL.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ing_thd_headroom_pool_t = {
    .name = TM_ING_THD_HEADROOM_POOLs, /* TM_ING_THD_HEADROOM_POOL */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tm_ing_thd_headroom_pool_t_fields,
    .desc = "The TM_ING_THD_HEADROOM_POOL table specifies the buffer threshold\n configuration in cells per ingress headroom pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_ING_THD_PORT_PRI_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ing_thd_port_pri_grp_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_PRI_GRP_IDs,  /* TM_PRI_GRP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Priority group.",
    },
    {
        .name  = MIN_GUARANTEE_CELLSs,  /* MIN_GUARANTEE_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum guaranteed cells.",
    },
    {
        .name  = MIN_GUARANTEE_CELLS_OPERs,  /* MIN_GUARANTEE_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "This read-only field reflects the operational minimum guaranteed\n cells. It can be different than the configured MIN_GUARANTEE_CELLS if\n the configured value cannot be allocated.\n",
    },
    {
        .name  = DYNAMIC_SHARED_LIMITSs,  /* DYNAMIC_SHARED_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use dynamic thresholds for shared buffer limits.",
    },
    {
        .name  = SHARED_LIMIT_CELLS_STATICs,  /* SHARED_LIMIT_CELLS_STATIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static shared buffer limit in cells.",
    },
    {
        .name  = SHARED_LIMIT_DYNAMICs,  /* SHARED_LIMIT_DYNAMIC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Dynamic shared buffer limit (alpha) represented as a fraction.\n Applicable only if DYNAMIC_SHARED_LIMITS is enabled.\n",
    },
    {
        .name  = RESUME_OFFSET_CELLSs,  /* RESUME_OFFSET_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to shared buffer limit used to calculate transmit resume limit.\n Transmit resume limit = shared buffer limit - RESUME_OFFSET_CELLS.\n Transmit will resume when transmit resume limit is reached.\n",
    },
    {
        .name  = RESUME_FLOOR_CELLSs,  /* RESUME_FLOOR_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static lower bound for transmit resume limit, which will become the\n operating transmit resume limit if the configured transmit resume\n limit is lower than RESUME_FLOOR_CELLS.\n",
    },
    {
        .name  = GLOBAL_HEADROOMs,  /* GLOBAL_HEADROOM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use global headroom.",
    },
    {
        .name  = HEADROOM_LIMIT_AUTOs,  /* HEADROOM_LIMIT_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable/Disable automatic setting of Headroom limit based on port\n speed.\n",
    },
    {
        .name  = HEADROOM_LIMIT_CELLSs,  /* HEADROOM_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Headroom limit.",
    },
    {
        .name  = HEADROOM_LIMIT_CELLS_OPERs,  /* HEADROOM_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "This read-only field reflects the operational headroom limit. It can\n be different than the configured HEADROOM_LIMIT_CELLS when flexport\n operation is performed on the port.\n",
    },
    {
        .name  = TM_ING_BST_THD_PRI_GRP_PROFILE_IDs,  /* TM_ING_BST_THD_PRI_GRP_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_ING_BST_THD_PRI_GRP_PROFILE table index. Provides the profile ID\n to be used for shared and headroom BST threshold selection.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_ING_THD_PORT_PRI_GRP_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE becomes invalid due to one of the following\n reasons:\n The mapping between PORT_ID and the physical port is missing.\n The MIN_GUARANTEE_CELLS exceeds the total available buffer size.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ing_thd_port_pri_grp_t = {
    .name = TM_ING_THD_PORT_PRI_GRPs, /* TM_ING_THD_PORT_PRI_GRP */
    .flags = 0,
    .fields = 15,
    .field = bcmltd_tm_ing_thd_port_pri_grp_t_fields,
    .desc = "The TM_ING_THD_PORT_PRI_GRP table specifies buffer thresholds per port\n priority group.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_ING_THD_PORT_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ing_thd_port_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_ING_SERVICE_POOL_IDs,  /* TM_ING_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = MIN_GUARANTEE_CELLSs,  /* MIN_GUARANTEE_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum guaranteed data buffer cells.",
    },
    {
        .name  = MIN_GUARANTEE_CELLS_OPERs,  /* MIN_GUARANTEE_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "This read-only field reflects the operational minimum guaranteed\n cells. It can be different than the configured MIN_GUARANTEE_CELLS if\n the configured value cannot be allocated.\n",
    },
    {
        .name  = SHARED_LIMIT_CELLSs,  /* SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit in cells.",
    },
    {
        .name  = RESUME_LIMIT_CELLSs,  /* RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to calculate transmit resume (in cells)\n The value of RESUME_LIMIT_CELLS should be set equal to or less than\n SHARED_LIMIT_CELLS for the same entry in this table.\n",
    },
    {
        .name  = RESUME_LIMIT_CELLS_OPERs,  /* RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational resume limit cells. This read-only field reflects any\n modification to the configured RESUME_LIMIT_CELLS as a function of\n SHARED_LIMIT_CELLS.\n",
    },
    {
        .name  = TM_ING_BST_THD_PORT_SERVICE_POOL_PROFILE_IDs,  /* TM_ING_BST_THD_PORT_SERVICE_POOL_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_ING_BST_THD_PORT_SERVICE_POOL_PROFILE table index. Provides the profile ID\n to be used for shared and minimum guaranteed BST threshold profile\n selection.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_ING_THD_PORT_SERVICE_POOL_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE becomes invalid due to one of the following\n reasons:\n The mapping between PORT_ID and the physical port is missing.\n The MIN_GUARANTEE_CELLS exceeds the total available buffer size.\n The RESUME_LIMIT_CELLS is larger than SHARED_LIMIT_CELLS.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ing_thd_port_service_pool_t = {
    .name = TM_ING_THD_PORT_SERVICE_POOLs, /* TM_ING_THD_PORT_SERVICE_POOL */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_tm_ing_thd_port_service_pool_t_fields,
    .desc = "The TM_ING_THD_PORT_SERVICE_POOL table specifies buffer thresholds on a\n per {port, service pool} basis.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_ING_THD_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ing_thd_service_pool_t_fields[] = {
    {
        .name  = TM_ING_SERVICE_POOL_IDs,  /* TM_ING_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Ingess service pool ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = SHARED_LIMIT_CELLSs,  /* SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit in cells.\n For all service pools in the same buffer pool, the sum of the\n SHARED_LIMIT_CELLS should always equal the total shared buffer cells.\n When adjusting SHARED_LIMIT_CELLS for a service pool, it is highly\n recommended to also adjust the SHARED_LIMIT_CELLS across other service\n pools in order to avoid changing the total shared buffer cells.\n",
    },
    {
        .name  = SHARED_LIMIT_CELLS_OPERs,  /* SHARED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational shared buffer limit cells. This read-only field reflects\n any modification to the configured SHARED_LIMIT_CELLS as a function\n of all reserved resources (minimum guarantee and headroom pool limit)\n associated to the specified service pool. Increasing/decreasing a\n reserved resource by certain amount results in decreasing/increasing\n of the corresponding service pool shared limit by the same amount.\n",
    },
    {
        .name  = SHARED_RESUME_LIMIT_CELLSs,  /* SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Transmission resume limit for the service pool in cells. This limit\n is used for green, yellow and red limit states.\n",
    },
    {
        .name  = SHARED_RESUME_OFFSET_CELLSs,  /* SHARED_RESUME_OFFSET_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to SHARED_LIMIT_CELLS used to calculate transmit resume limit.\n Transmit resume limit = SHARED_LIMIT_CELLS - RESUME_OFFSET_CELLS.\n Transmit will resume when transmit resume limit is reached.\n",
    },
    {
        .name  = COLOR_SPECIFIC_LIMITSs,  /* COLOR_SPECIFIC_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use color based discards.",
    },
    {
        .name  = YELLOW_OFFSET_CELLSs,  /* YELLOW_OFFSET_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Service pool acceptance preference offset for yellow packets (in\n cells).\n Yellow limit = SHARED_LIMIT_CELLS - YELLOW_OFFSET_CELLS.\n",
    },
    {
        .name  = RED_OFFSET_CELLSs,  /* RED_OFFSET_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Service pool acceptance preference offset for red packets (in cells).\n Red limit = SHARED_LIMIT_CELLS - RED_OFFSET_CELLS.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_ING_THD_SERVICE_POOL_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE becomes invalid if the SHARED_LIMIT_CELLS\n cannot be allocated without decreasing the other service pool's\n shared limit.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ing_thd_service_pool_t = {
    .name = TM_ING_THD_SERVICE_POOLs, /* TM_ING_THD_SERVICE_POOL */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_tm_ing_thd_service_pool_t_fields,
    .desc = "The TM_ING_THD_SERVICE_POOL table specifies buffer threshold per ingress\n service pool.\n\n For some devices, there are multiple buffer pools. Each buffer pool contains\n a complete set of ingress service pools. By default, the buffer thresholds\n of a specific ingress service pool across different buffer pools are the same.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_ING_UC_ING_PRI_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ing_uc_ing_pri_map_t_fields[] = {
    {
        .name  = TM_ING_UC_ING_PRI_MAP_IDs,  /* TM_ING_UC_ING_PRI_MAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the TM_ING_UC_ING_PRI_MAP table.",
    },
    {
        .name  = ING_PRIs,  /* ING_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Input priority.",
    },
    {
        .name  = TM_PRI_GRP_IDs,  /* TM_PRI_GRP_ID */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Priority group ID.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ing_uc_ing_pri_map_t = {
    .name = TM_ING_UC_ING_PRI_MAPs, /* TM_ING_UC_ING_PRI_MAP */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_ing_uc_ing_pri_map_t_fields,
    .desc = "The TM_ING_UC_ING_PRI_MAP table specifies the map between input priority and\n priority group for unicast traffic.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_MC_AGG_LIST_MEMBER_REMAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_mc_agg_list_member_remap_t_fields[] = {
    {
        .name  = TM_MC_AGG_LIST_MEMBER_REMAP_IDs,  /* TM_MC_AGG_LIST_MEMBER_REMAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "TM_MC_AGG_LIST_MEMBER_REMAP_ID logical table index.",
    },
    {
        .name  = TM_EGR_OBJECT_UPDATE_PROFILE_IDs,  /* TM_EGR_OBJECT_UPDATE_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_EGR_OBJECT_UPDATE_PROFILE logical table index.",
    },
    {
        .name  = REMAP_OBJECT_INDEX_0s,  /* REMAP_OBJECT_INDEX_0 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Remap object index 0.",
    },
    {
        .name  = REMAP_OBJECT_INDEX_1s,  /* REMAP_OBJECT_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Remap object index 1.",
    },
    {
        .name  = REMAP_OBJECT_INDEX_2s,  /* REMAP_OBJECT_INDEX_2 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Remap object index 2.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_mc_agg_list_member_remap_t = {
    .name = TM_MC_AGG_LIST_MEMBER_REMAPs, /* TM_MC_AGG_LIST_MEMBER_REMAP */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tm_mc_agg_list_member_remap_t_fields,
    .desc = "The TM_MC_AGG_LIST_MEMBER_REMAP table is used to\n map new objects for a specific AGG_LIST_MEMBER in TM_MC_PORT_AGG_LIST.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_MC_AGG_LIST_MEMBER_REMAP_RANGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_mc_agg_list_member_remap_range_t_fields[] = {
    {
        .name  = MAX_AGG_LIST_MEMBERs,  /* MAX_AGG_LIST_MEMBER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Max next hop value.",
    },
    {
        .name  = MIN_AGG_LIST_MEMBERs,  /* MIN_AGG_LIST_MEMBER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Min next hop value.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_mc_agg_list_member_remap_range_t = {
    .name = TM_MC_AGG_LIST_MEMBER_REMAP_RANGEs, /* TM_MC_AGG_LIST_MEMBER_REMAP_RANGE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tm_mc_agg_list_member_remap_range_t_fields,
    .desc = "The TM_MC_AGG_LIST_MEMBER_REMAP_RANGE table is used to\n specify the AGG_LIST_MEMBER range for remapping.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_MC_GROUP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_mc_group_t_fields[] = {
    {
        .name  = TM_MC_GROUP_IDs,  /* TM_MC_GROUP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the L3 multicast table.",
    },
    {
        .name  = TM_MC_PORT_AGG_LIST_IDs,  /* TM_MC_PORT_AGG_LIST_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "TM_MC_PORT_AGG_LIST table index. Used as a base index\n from which the next NUM_PORT_LIST_ENTRIES number of indices\n are associated with this entry.\n",
    },
    {
        .name  = NUM_PORT_LIST_ENTRIESs,  /* NUM_PORT_LIST_ENTRIES */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Number of consecutive port list entries.",
    },
    {
        .name  = L3_PORTs,  /* L3_PORT */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to configure all the ports that are part of\n this replication group. Applicable to L3 replication.\n",
    },
    {
        .name  = L2_PORTs,  /* L2_PORT */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to configure all the ports that are part of\n this replication group. Applicable to L2 replication.\n",
    },
    {
        .name  = L2_MCs,  /* L2_MC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2 multicast replication.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_mc_group_t = {
    .name = TM_MC_GROUPs, /* TM_MC_GROUP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_mc_group_t_fields,
    .desc = "The TM_MC_GROUP table maps multiple sets of multicast next hop\n indices to an L3 multicast index.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_MC_PORT_AGG_LIST.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_mc_port_agg_list_t_fields[] = {
    {
        .name  = TM_MC_PORT_AGG_LIST_IDs,  /* TM_MC_PORT_AGG_LIST_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the L3 multicast port aggregate list table.",
    },
    {
        .name  = TM_MC_PORT_AGG_IDs,  /* TM_MC_PORT_AGG_ID */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "The port aggregate index to which this entry is mapped.",
    },
    {
        .name  = NUM_AGG_LIST_MEMBERs,  /* NUM_AGG_LIST_MEMBER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The number of indices specified in AGG_LIST_MEMBER array.",
    },
    {
        .name  = AGG_LIST_MEMBERs,  /* AGG_LIST_MEMBER */
        .flags = 0,
        .width = 16,
        .depth = 4096,
        .desc = "An array of indices that will be used to derive next hop\n information.\n",
    },
    {
        .name  = NUM_REPL_RESOURCE_IN_USEs,  /* NUM_REPL_RESOURCE_IN_USE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The number of replication resource used.",
    },
    {
        .name  = SHARED_REPL_RESOURCEs,  /* SHARED_REPL_RESOURCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to notify that replication resource is shared across\n different TM_MC_PORT_AGG_LIST_ID.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_mc_port_agg_list_t = {
    .name = TM_MC_PORT_AGG_LISTs, /* TM_MC_PORT_AGG_LIST */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_mc_port_agg_list_t_fields,
    .desc = "The TM_MC_PORT_AGG_LIST table maps a set of multicast next hop\n indices to a port aggregate index.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_MC_PORT_AGG_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_mc_port_agg_map_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_MC_PORT_AGG_IDs,  /* TM_MC_PORT_AGG_ID */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "The aggregate ID that the port maps to.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_mc_port_agg_map_t = {
    .name = TM_MC_PORT_AGG_MAPs, /* TM_MC_PORT_AGG_MAP */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tm_mc_port_agg_map_t_fields,
    .desc = "The TM_MC_PORT_AGG_MAP is used to map a port to an aggregate ID.\n Each port which is part of an aggregate ID receives an identical\n copy of the packet destined to that aggregate ID.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_MIRROR_ON_DROP_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_mirror_on_drop_control_t_fields[] = {
    {
        .name  = MIRROR_ON_DROPs,  /* MIRROR_ON_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable TM mirror on drop.",
    },
    {
        .name  = RESERVED_LIMIT_CELLSs,  /* RESERVED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Mirror on drop pool limit in cells.",
    },
    {
        .name  = RESERVED_LIMIT_CELLS_OPERs,  /* RESERVED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field that reflects the operational value of\n RESERVED_LIMIT_CELLS.\n",
    },
    {
        .name  = HIGH_WATERMARK_CLEAR_ON_READs,  /* HIGH_WATERMARK_CLEAR_ON_READ */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the clear on read of high watermark cell usage count.",
    },
    {
        .name  = ENQUEUE_TIME_OUTs,  /* ENQUEUE_TIME_OUT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Hardware cycles for repeated timer to cause mirror on drop\n packets to be enqueued. Set to 0 to disable the timer.\n Applies when less than X mirror on drop packets waiting to be\n enqueued to single destination queue (X is a device specified\n value which represents the maximum packet number can be enqueued\n within one cycle).\n If no less than X mirror on drop packets waiting to be\n enqueued, X mirror on drop packets will be enqueued, no\n matter there is regular packets waiting to be enqueued or not.\n If less than X mirror on drop packets waiting to be\n enqueued, all the mirror on drop packets will be enqueued if\n there is no regular packet waiting, or this timer expires.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_MIRROR_DROP_CONTROL_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_mirror_on_drop_control_t = {
    .name = TM_MIRROR_ON_DROP_CONTROLs, /* TM_MIRROR_ON_DROP_CONTROL */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_mirror_on_drop_control_t_fields,
    .desc = "The TM_MIRROR_ON_DROP_CONTROL logical table specifies the global enable\n and buffer space reservation controls for enqueuing and mirroring packets\n dropped by the traffic manager(TM).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_MIRROR_ON_DROP_DESTINATION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_mirror_on_drop_destination_t_fields[] = {
    {
        .name  = TM_MIRROR_ON_DROP_DESTINATION_IDs,  /* TM_MIRROR_ON_DROP_DESTINATION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Mirror on drop destination identifier.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination logical Port ID.",
    },
    {
        .name  = UC_Qs,  /* UC_Q */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if destination queue is unicast.",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID within PORT_ID for the destination queue.\n Applicable only if UC_Q is set.\n",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue ID within PORT_ID for the destination queue.\n Applicable only if UC_Q is not set.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_MIRROR_DROP_DESTINATION_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state\n of this table entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_mirror_on_drop_destination_t = {
    .name = TM_MIRROR_ON_DROP_DESTINATIONs, /* TM_MIRROR_ON_DROP_DESTINATION */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_mirror_on_drop_destination_t_fields,
    .desc = "The TM_MIRROR_ON_DROP_DESTINATION table specifies the destination port\n and queue number for mirror copy of mirror on drop traffic.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_MIRROR_ON_DROP_ENCAP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_mirror_on_drop_encap_profile_t_fields[] = {
    {
        .name  = TM_MIRROR_ON_DROP_ENCAP_PROFILE_IDs,  /* TM_MIRROR_ON_DROP_ENCAP_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror on drop encap profile table.",
    },
    {
        .name  = MIRROR_INSTANCE_IDs,  /* MIRROR_INSTANCE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MIRROR_ING_MEMBER table.",
    },
    {
        .name  = MIRROR_MEMBER_IDs,  /* MIRROR_MEMBER_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the MIRROR_ING_MEMBER table.",
    },
    {
        .name  = MIRROR_ENCAP_IDs,  /* MIRROR_ENCAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into mirror on drop encapsulation table.\n Note that only MIRROR_ENCAP_MIRROR_ON_DROP(_IPv6)\n encapsulation instances are supported.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_mirror_on_drop_encap_profile_t = {
    .name = TM_MIRROR_ON_DROP_ENCAP_PROFILEs, /* TM_MIRROR_ON_DROP_ENCAP_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_mirror_on_drop_encap_profile_t_fields,
    .desc = "The TM_MIRROR_ON_DROP_ENCAP_PROFILE table specifies mirror on drop\n encapsulation configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_MIRROR_ON_DROP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_mirror_on_drop_profile_t_fields[] = {
    {
        .name  = TM_MIRROR_ON_DROP_PROFILE_IDs,  /* TM_MIRROR_ON_DROP_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the mirror on drop profile table.",
    },
    {
        .name  = MIRROR_ON_DROPs,  /* MIRROR_ON_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable mirroring.",
    },
    {
        .name  = TM_MIRROR_ON_DROP_DESTINATION_IDs,  /* TM_MIRROR_ON_DROP_DESTINATION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the TM_MIRROR_ON_DROP_DESTINATION table.",
    },
    {
        .name  = PERCENTAGE_75_100s,  /* PERCENTAGE_75_100 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Sampling probability when CELL_USAGE is greater than 75% of\n MIRROR_ON_DROP_CELL_LIMIT.\n",
    },
    {
        .name  = PERCENTAGE_50_75s,  /* PERCENTAGE_50_75 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Sampling probability when CELL_USAGE is between 50% and 75% of\n MIRROR_ON_DROP_CELL_LIMIT.\n",
    },
    {
        .name  = PERCENTAGE_25_50s,  /* PERCENTAGE_25_50 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Sampling probability when CELL_USAGE is between 25% and 50% of\n MIRROR_ON_DROP_CELL_LIMIT.\n",
    },
    {
        .name  = PERCENTAGE_0_25s,  /* PERCENTAGE_0_25 */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Sampling probability when CELL_USAGE is less than 25% of\n MIRROR_ON_DROP_CELL_LIMIT.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_mirror_on_drop_profile_t = {
    .name = TM_MIRROR_ON_DROP_PROFILEs, /* TM_MIRROR_ON_DROP_PROFILE */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_tm_mirror_on_drop_profile_t_fields,
    .desc = "The TM_MIRROR_ON_DROP_PROFILE table specifies mirror on drop\n sampling probability and destination configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_OBM_PC_PM_MAX_USAGE_MODE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_obm_pc_pm_max_usage_mode_t_fields[] = {
    {
        .name  = PC_PM_IDs,  /* PC_PM_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Port Macro ID.",
    },
    {
        .name  = MAX_USAGE_MODEs,  /* MAX_USAGE_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_OBM_MAX_USG_MODE_T_DATA,
        .desc = "Maximum usage mode to be accounted in maximum usage counters.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_obm_pc_pm_max_usage_mode_t = {
    .name = TM_OBM_PC_PM_MAX_USAGE_MODEs, /* TM_OBM_PC_PM_MAX_USAGE_MODE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tm_obm_pc_pm_max_usage_mode_t_fields,
    .desc = "The TM_OBM_PC_PM_MAX_USAGE_MODE table specifies oversubscription buffer\n management (OBM) max usage mode to be accounted for\n CTR_TM_OBM_PORT_USAGE.MAX_USAGE_BYTE.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_OBM_PC_PM_PKT_PARSE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_obm_pc_pm_pkt_parse_t_fields[] = {
    {
        .name  = PC_PM_IDs,  /* PC_PM_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Port macro ID.",
    },
    {
        .name  = INNER_TPIDs,  /* INNER_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Inner TPID value.",
    },
    {
        .name  = OUTER_TPIDs,  /* OUTER_TPID */
        .flags = 0,
        .width = 16,
        .depth = 4,
        .desc = "Outer TPID value.",
    },
    {
        .name  = ETAG_PARSEs,  /* ETAG_PARSE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to parse ETAG header in OBM.",
    },
    {
        .name  = ETAG_ETHERTYPEs,  /* ETAG_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype to identify ETAG packets.\n Applicable only when ETAG_PARSE is enabled.\n",
    },
    {
        .name  = VNTAG_PARSEs,  /* VNTAG_PARSE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to parse VNTAG header.",
    },
    {
        .name  = VNTAG_ETHERTYPEs,  /* VNTAG_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype to identify VNTAG packets.\n Applicable only when VNTAG_PARSE is enabled.\n",
    },
    {
        .name  = HIGIG3_ETHERTYPEs,  /* HIGIG3_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype to identify higig3 packets.",
    },
    {
        .name  = HIGIG3_ETHERTYPE_MASKs,  /* HIGIG3_ETHERTYPE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype mask that will be logically ANDed with the\n HIGIG3_ETHERTYPE field to identify higig3 packets.\n Applicable only when HIGIG3_ETHERTYPE is non-zero.\n",
    },
    {
        .name  = USER_DEFINED_PROTOCOL_MATCHs,  /* USER_DEFINED_PROTOCOL_MATCH */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable matching based on user defined protocol.",
    },
    {
        .name  = USER_DEFINED_PROTOCOL_ETHERTYPEs,  /* USER_DEFINED_PROTOCOL_ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 4,
        .desc = "Ethertype to identify user defined protocol packets",
    },
    {
        .name  = USER_DEFINED_PROTOCOL_ETHERTYPE_MASKs,  /* USER_DEFINED_PROTOCOL_ETHERTYPE_MASK */
        .flags = 0,
        .width = 16,
        .depth = 4,
        .desc = "Ethertype mask is logically ANDed with USER_DEFINED_PROTOCOL_ETHERTYPE\n to identify user defined protocol packets.\n Applicable only if USER_DEFINED_PROTOCOL_ETHERTYPE is non-zero\n",
    },
    {
        .name  = USER_DEFINED_PROTOCOL_DST_MACs,  /* USER_DEFINED_PROTOCOL_DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 4,
        .desc = "Destination MAC address to identify the user definedprotocol packets",
    },
    {
        .name  = USER_DEFINED_PROTOCOL_DST_MAC_MASKs,  /* USER_DEFINED_PROTOCOL_DST_MAC_MASK */
        .flags = 0,
        .width = 48,
        .depth = 4,
        .desc = "Destination MAC address mask is logically ANDed with\n USER_DEFINED_PROTOCOL_DST_MAC to identify the user defined protocol packets\n Applicable only if USER_DEFINED_PROTOCOL_DST_MAC field is non-zero.\n",
    },
    {
        .name  = USER_DEFINED_PROTOCOL_TRAFFIC_CLASSs,  /* USER_DEFINED_PROTOCOL_TRAFFIC_CLASS */
        .flags = 0,
        .width = 8,
        .depth = 4,
        .desc = "OBM traffic class that should be assigned to packets matching the user\n defined MAC address or user defined Ethertype in the corresponding index\n position.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_obm_pc_pm_pkt_parse_t = {
    .name = TM_OBM_PC_PM_PKT_PARSEs, /* TM_OBM_PC_PM_PKT_PARSE */
    .flags = 0,
    .fields = 15,
    .field = bcmltd_tm_obm_pc_pm_pkt_parse_t_fields,
    .desc = "The TM_OBM_PC_PM_PKT_PARSE table configures\n per port macro OBM controls to parse different packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_OBM_PORT_FLOW_CTRL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_obm_port_flow_ctrl_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = FLOW_CTRLs,  /* FLOW_CTRL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use flow control based on packet type.",
    },
    {
        .name  = FLOW_CTRL_TYPEs,  /* FLOW_CTRL_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_FLOW_CTRL_T_DATA,
        .desc = "Flow control message type.",
    },
    {
        .name  = LOSSLESS0_FLOW_CTRLs,  /* LOSSLESS0_FLOW_CTRL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use flow control for Lossless 0 packets.",
    },
    {
        .name  = LOSSLESS1_FLOW_CTRLs,  /* LOSSLESS1_FLOW_CTRL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use flow control for Lossless 1 packets.",
    },
    {
        .name  = COS_BMAP_LOSSLESS0s,  /* COS_BMAP_LOSSLESS0 */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable COS indices in COS bitmap for Lossless 0\n packets to send flow control request to port macro.\n",
    },
    {
        .name  = COS_BMAP_LOSSLESS1s,  /* COS_BMAP_LOSSLESS1 */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "Enable COS indices in COS bitmap for Lossless 1\n packets to send flow control request to port macro.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE of the entry becomes invalid if the mapping\n between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_obm_port_flow_ctrl_t = {
    .name = TM_OBM_PORT_FLOW_CTRLs, /* TM_OBM_PORT_FLOW_CTRL */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_tm_obm_port_flow_ctrl_t_fields,
    .desc = "The TM_OBM_PORT_FLOW_CTRL table specifies the per-port oversubscription\n buffer management (OBM) flow control configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_OBM_PORT_PKT_PARSE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_obm_port_pkt_parse_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = HEADER_TYPEs,  /* HEADER_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OBM_HEADER_TYPE_T_DATA,
        .desc = "Defines the port header type to be set by the OBM to derive\n the OB priority value.\n",
    },
    {
        .name  = DSCP_MAPs,  /* DSCP_MAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to map DSCP priority value from the packet to the OBM traffic class.\n The OBM traffic class value for each DSCP value should be programmed in the\n TM_OBM_PORT_PKT_PRI_TC_MAP table for PKT_PRI_TYPE of PKT_PRI_TYPE_DSCP.\n",
    },
    {
        .name  = MPLS_MAPs,  /* MPLS_MAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to map MPLS EXP priority value from the packet to the OBM traffic class.\n The OBM traffic class value for each MPLS EXP value should be programmed in the\n TM_OBM_PORT_PKT_PRI_TC_MAP table for PKT_PRI_TYPE of PKT_PRI_TYPE_MPLS.\n",
    },
    {
        .name  = ETAG_MAPs,  /* ETAG_MAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to map ETAG priority value from the packet to the OBM traffic class.\n The OBM traffic class value for each ETAG value should be programmed in the\n TM_OBM_PORT_PKT_PRI_TC_MAP table for PKT_PRI_TYPE of PKT_PRI_TYPE_ETAG.\n Applicable only if TM_OBM_PC_PM_PKT_PARSE.ETAG_PARSE is enabled.\n",
    },
    {
        .name  = INNER_TPIDs,  /* INNER_TPID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to parse inner TPID.\n The OBM traffic class value will be derived from the priority value in the\n inner TPID of the packet.\n Applicable only if TM_OBM_PC_PM_PKT_PARSE.INNER_TPID is non-zero.\n",
    },
    {
        .name  = OUTER_TPIDs,  /* OUTER_TPID */
        .flags = 0,
        .width = 1,
        .depth = 4,
        .desc = "Enable to parse outer TPID.\n The OBM traffic class value will be derived from the priority value in the\n outer TPID of the packet.\n Applicable only if corresponding element in TM_OBM_PC_PM_PKT_PARSE.OUTER_TPID\n array is non-zero.\n",
    },
    {
        .name  = DEFAULT_PKT_PRIs,  /* DEFAULT_PKT_PRI */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Default priority value.\n This is used to determine OBM traffic class for untagged packets.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_obm_port_pkt_parse_t = {
    .name = TM_OBM_PORT_PKT_PARSEs, /* TM_OBM_PORT_PKT_PARSE */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_tm_obm_port_pkt_parse_t_fields,
    .desc = "The TM_OBM_PORT_PKT_PARSE table specifies per port controls for\n parsing different packets in the oversubscription buffer.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_OBM_PORT_PKT_PRI_TC_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_obm_port_pkt_pri_tc_map_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = PKT_PRI_TYPEs,  /* PKT_PRI_TYPE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Packet priority type.",
    },
    {
        .name  = PKT_PRIs,  /* PKT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 6,
        .depth = 0,
        .desc = "Priority value.",
    },
    {
        .name  = TRAFFIC_CLASSs,  /* TRAFFIC_CLASS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_OBM_TC_T_DATA,
        .desc = "OBM traffic class to be mapped.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_obm_port_pkt_pri_tc_map_t = {
    .name = TM_OBM_PORT_PKT_PRI_TC_MAPs, /* TM_OBM_PORT_PKT_PRI_TC_MAP */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tm_obm_port_pkt_pri_tc_map_t_fields,
    .desc = "The TM_OBM_PORT_PKT_PRI_TC_MAP table creates the map between\n packet priority and OBM traffic class. Priority fields can be selected\n from different headers such as VLAN or DSCP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_OOBFC_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_oobfc_control_t_fields[] = {
    {
        .name  = GCS_REPORTs,  /* GCS_REPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to report global congestion status (GCS)\n congestion state.\n",
    },
    {
        .name  = SERVICE_POOL_IDs,  /* SERVICE_POOL_ID */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID to be reported in GCS field.\n Applicable if GCS_REPORT is enabled.\n",
    },
    {
        .name  = SERVICE_POOL_REPORTs,  /* SERVICE_POOL_REPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable reporting of ingress, egress and replication\n queue engine (RQE) service pool congestion status.\n",
    },
    {
        .name  = POOL_CHANNEL_BASEs,  /* POOL_CHANNEL_BASE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Service pool channel base for ingress, egress\n and RQE service pool congestion reporting.\n Applicable if SERVICE_POOL_REPORT is enabled.\n",
    },
    {
        .name  = INGRESS_REPORTs,  /* INGRESS_REPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable reporting of ingress priority group (PG) and pool\n congestion states.\n",
    },
    {
        .name  = INGRESS_CHANNEL_BASEs,  /* INGRESS_CHANNEL_BASE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Channel base for ingress PG and pool\n congestion reporting.\n Applicable if INGRESS_REPORT is enabled.\n",
    },
    {
        .name  = EGRESS_REPORTs,  /* EGRESS_REPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable reporting of egress queue and pool\n congestion states.\n",
    },
    {
        .name  = EGRESS_CHANNEL_BASEs,  /* EGRESS_CHANNEL_BASE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Channel base for egress queue\n congestion reporting.\n Applicable if EGRESS_REPORT is enabled.\n",
    },
    {
        .name  = EGRESS_STATUS_SIZEs,  /* EGRESS_STATUS_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_OOBFC_EGRESS_SIZE_T_DATA,
        .desc = "Egress congestion status representation size.\n Valid values are 8 bit and 16 bit.\n",
    },
    {
        .name  = INTER_PACKET_GAPs,  /* INTER_PACKET_GAP */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Idle period in number of clock cycles between\n TX OOBFC messages.\n The duration of a single clock cycle for the underlying\n device can be obtained from TM_OOBFC_INFO.CLOCK_CYCLE_DURATION.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_oobfc_control_t = {
    .name = TM_OOBFC_CONTROLs, /* TM_OOBFC_CONTROL */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_tm_oobfc_control_t_fields,
    .desc = "The TM_OOBFC_CONTROL table is used to configure various out of band\n flow control (OOBFC) properties that are applicable to all ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_OOBFC_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_oobfc_info_t_fields[] = {
    {
        .name  = CLOCK_CYCLE_DURATIONs,  /* CLOCK_CYCLE_DURATION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The duration of one clock cycle in nanoseconds.\n This value represents the minimum time gap between\n two OOBFC transmit messages.\n The clock cycle duration can be used in the calculation\n of the inter-packet gap (TM_OOBFC_CONTROL.INTER_PACKET_GAP).\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_oobfc_info_t = {
    .name = TM_OOBFC_INFOs, /* TM_OOBFC_INFO */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_tm_oobfc_info_t_fields,
    .desc = "The TM_OOBFC_INFO table is used to retrieve device specific\n out of band flow control (OOBFC) information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_OOBFC_MC_Q_MAP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_oobfc_mc_q_map_profile_t_fields[] = {
    {
        .name  = TM_OOBFC_Q_MAP_PROFILE_IDs,  /* TM_OOBFC_Q_MAP_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the OOBFC queue map profile table.",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue index.",
    },
    {
        .name  = CONGESTION_NOTIFYs,  /* CONGESTION_NOTIFY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to send congestion status for the queue.",
    },
    {
        .name  = OOB_BIT_OFFSETs,  /* OOB_BIT_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The bit position in the 8/16 bit queue representation for\n the port in the OOBFC message. The user must configure\n the MC_Q_ID uniquely to a 8/16 bit position in the\n OOBFC message.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_OOBFC_MC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE of the entry becomes invalid if TM_MC_Q_ID\n exceeds TM_SCHDEULER_CONFIG.NUM_MC_Q.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_oobfc_mc_q_map_profile_t = {
    .name = TM_OOBFC_MC_Q_MAP_PROFILEs, /* TM_OOBFC_MC_Q_MAP_PROFILE */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tm_oobfc_mc_q_map_profile_t_fields,
    .desc = "The TM_OOBFC_MC_Q_MAP_PROFILE is a profile table used to map\n multicast queues to a bit position in the out of band\n flow control (OOBFC) message.\n The table TM_OOBFC_PORT should be used to map a port to a profile.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_OOBFC_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_oobfc_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = OOB_PORTs,  /* OOB_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Out of band (OOB) port number. This is used to calculate the\n channel offset to represent the port congestion state in the\n OOBFC message. Please refer to user guide for more details.\n",
    },
    {
        .name  = INGRESSs,  /* INGRESS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to configure OOBFC for ingress resources.",
    },
    {
        .name  = EGRESSs,  /* EGRESS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to configure OOBFC for egress resources.",
    },
    {
        .name  = CNG_REPORTs,  /* CNG_REPORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to configure OOBFC reporting for\n the port.\n Port Congestion is reported based on the following mapping.\n  INGRESS=0, CNG_REPORT=0 - ingress port is skipped.\n  INGRESS=0, CNG_REPORT=1 - ingress port is skipped.\n  INGRESS=1, CNG_REPORT=0 - ingress port is reported as 0.\n  INGRESS=1, CNG_REPORT=1 - ingress port is reported as is.\n  EGRESS=0,  CNG_REPORT=0 - egress port is skipped.\n  EGRESS=0,  CNG_REPORT=1 - egress port is skipped.\n  EGRESS=1,  CNG_REPORT=0 - egress port is reported as 0.\n  EGRESS=1,  CNG_REPORT=1 - egress port is reported as is.\n",
    },
    {
        .name  = TM_OOBFC_Q_MAP_PROFILE_IDs,  /* TM_OOBFC_Q_MAP_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_OOBFC_Q_MAP_PROFILE table index.\n Used to select a queue mapping profile for\n the port.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_oobfc_port_t = {
    .name = TM_OOBFC_PORTs, /* TM_OOBFC_PORT */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_tm_oobfc_port_t_fields,
    .desc = "The TM_OOBFC_PORT table is used to configure\n out of band flow control (OOBFC) port properties.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_OOBFC_UC_Q_MAP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_oobfc_uc_q_map_profile_t_fields[] = {
    {
        .name  = TM_OOBFC_Q_MAP_PROFILE_IDs,  /* TM_OOBFC_Q_MAP_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "OOBFC queue map profile table index.",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue index.",
    },
    {
        .name  = CONGESTION_NOTIFYs,  /* CONGESTION_NOTIFY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to send congestion status for the queue.",
    },
    {
        .name  = OOB_BIT_OFFSETs,  /* OOB_BIT_OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "The bit position in the 8/16 bit queue representation for\n the port in the OOBFC message. The user must configure\n the UC_Q_ID uniquely to a 8/16 bit position in the\n OOBFC message.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_OOBFC_UC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE of the entry becomes invalid if TM_UC_Q_ID\n exceeds TM_DEVICE_INFO.NUM_Q - TM_SCHDEULER_CONFIG.NUM_MC_Q.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_oobfc_uc_q_map_profile_t = {
    .name = TM_OOBFC_UC_Q_MAP_PROFILEs, /* TM_OOBFC_UC_Q_MAP_PROFILE */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tm_oobfc_uc_q_map_profile_t_fields,
    .desc = "The TM_OOBFC_UC_Q_MAP_PROFILE is a profile table used to map\n unicast queues to a bit position in the out of band\n flow control (OOBFC) message.\n The table TM_OOBFC_PORT is used to map a port to the profile.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PFC_DEADLOCK_RECOVERY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_pfc_deadlock_recovery_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = PFC_PRIs,  /* PFC_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "PFC priority.",
    },
    {
        .name  = DEADLOCK_RECOVERYs,  /* DEADLOCK_RECOVERY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to perform deadlock detection and recovery.",
    },
    {
        .name  = DETECTION_TIMERs,  /* DETECTION_TIMER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Deadlock detection countdown timer. The unit is specified\n by the DETECTION_TIMER_GRANULARITY field.\n",
    },
    {
        .name  = DETECTION_TIMER_GRANULARITYs,  /* DETECTION_TIMER_GRANULARITY */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The time unit (tick) value for the detection countdown timer.",
    },
    {
        .name  = RECOVERY_TIMERs,  /* RECOVERY_TIMER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Deadlock recovery countdown timer in units of 100 milliseconds.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n the mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_pfc_deadlock_recovery_t = {
    .name = TM_PFC_DEADLOCK_RECOVERYs, /* TM_PFC_DEADLOCK_RECOVERY */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_tm_pfc_deadlock_recovery_t_fields,
    .desc = "The TM_PFC_DEADLOCK_RECOVERY table specifies the per-port PFC deadlock\n recovery configuration for front panel and management ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PFC_DEADLOCK_RECOVERY_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_pfc_deadlock_recovery_control_t_fields[] = {
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Action to take while recovering from deadlock state.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_pfc_deadlock_recovery_control_t = {
    .name = TM_PFC_DEADLOCK_RECOVERY_CONTROLs, /* TM_PFC_DEADLOCK_RECOVERY_CONTROL */
    .flags = 0,
    .fields = 1,
    .field = bcmltd_tm_pfc_deadlock_recovery_control_t_fields,
    .desc = "The TM_PFC_DEADLOCK_RECOVERY_CONTROL table specifies the global configuration\n for all ports to transmit or discard the packets while recovering from\n deadlock states.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PFC_DEADLOCK_RECOVERY_STATUS.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_pfc_deadlock_recovery_status_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = PFC_PRIs,  /* PFC_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "PFC priority.",
    },
    {
        .name  = RECOVERYs,  /* RECOVERY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enabled to indicate in recovery.",
    },
    {
        .name  = RECOVERY_CNTs,  /* RECOVERY_CNT */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Accumulated deadlock recovery time across all\n recovery events (in units of 100 milliseconds).\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if\n the mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_pfc_deadlock_recovery_status_t = {
    .name = TM_PFC_DEADLOCK_RECOVERY_STATUSs, /* TM_PFC_DEADLOCK_RECOVERY_STATUS */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tm_pfc_deadlock_recovery_status_t_fields,
    .desc = "The TM_PFC_DEADLOCK_RECOVERY_STATUS table provides the per-port PFC deadlock\n recovery status. An application can subscribe for updates to this logical table\n and take action accordingly.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PFC_EGR.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_pfc_egr_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = BLOCK_PFC_QUEUE_UPDATESs,  /* BLOCK_PFC_QUEUE_UPDATES */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to block egress queue updates for all the\n port's PFC priorities.\n",
    },
    {
        .name  = TM_PFC_PRI_PROFILE_IDs,  /* TM_PFC_PRI_PROFILE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "TM_PFC_PRI_PROFILE table index. Specifies the PFC priority\n to TM queue and egress buffer group configuration profile for this port.\n This field should be kept the same as\n TM_SCHEDULER_PORT_PROFILE.TM_SCHEDULER_PROFILE_ID for the same\n port.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_ENTRY_STATE_T_DATA,
        .desc = "Read-only field, which reflects the operational state of the entry.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_pfc_egr_t = {
    .name = TM_PFC_EGRs, /* TM_PFC_EGR */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_pfc_egr_t_fields,
    .desc = "The TM_PFC_EGR table specifies per-port receive priority flow\n control (PFC) configuration. PFC stops scheduling transmitted packets\n when PFC transmit off (XOFF) messages are received.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PFC_PRI_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_pfc_pri_profile_t_fields[] = {
    {
        .name  = TM_PFC_PRI_PROFILE_IDs,  /* TM_PFC_PRI_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index of the PFC priority profile table.",
    },
    {
        .name  = PFC_PRIs,  /* PFC_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "PFC priority.",
    },
    {
        .name  = PFCs,  /* PFC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to activate PFC for the specified priority.",
    },
    {
        .name  = COS_LISTs,  /* COS_LIST */
        .flags = 0,
        .width = 1,
        .depth = 12,
        .desc = "An array indexed by COS number to indicate the COS list\n controlled by this PFC priority.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_pfc_pri_profile_t = {
    .name = TM_PFC_PRI_PROFILEs, /* TM_PFC_PRI_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_pfc_pri_profile_t_fields,
    .desc = "The TM_PFC_PRI_PROFILE table specifies per-PFC priority flow control enable\n and their cos map configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PFC_PRI_TO_PRI_GRP_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_pfc_pri_to_pri_grp_map_t_fields[] = {
    {
        .name  = TM_PFC_PRI_TO_PRI_GRP_MAP_IDs,  /* TM_PFC_PRI_TO_PRI_GRP_MAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Index into the TM_PFC_PRI_TO_PRI_GRP_MAP table.",
    },
    {
        .name  = PFC_PRIs,  /* PFC_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "PFC priority.",
    },
    {
        .name  = TM_PRI_GRP_IDs,  /* TM_PRI_GRP_ID */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Priority group ID for PFC priority.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_pfc_pri_to_pri_grp_map_t = {
    .name = TM_PFC_PRI_TO_PRI_GRP_MAPs, /* TM_PFC_PRI_TO_PRI_GRP_MAP */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_pfc_pri_to_pri_grp_map_t_fields,
    .desc = "The TM_PFC_PRI_TO_PRI_GRP_MAP table specifies the priority group mapped to a\n PFC priority.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PIPE_MAP_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_pipe_map_info_t_fields[] = {
    {
        .name  = TM_PIPEs,  /* TM_PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TM pipe number.",
    },
    {
        .name  = PORT_CNTs,  /* PORT_CNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Number of ports for the specified pipe.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 32,
        .desc = "Logical port IDs.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_pipe_map_info_t = {
    .name = TM_PIPE_MAP_INFOs, /* TM_PIPE_MAP_INFO */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_pipe_map_info_t_fields,
    .desc = "The TM_PIPE_MAP_INFO is a read-only table which specifies the list of\n port IDs for the given pipe.\n The PORT_ID retrieved can further be used to index the\n TM_PORT_MAP_INFO table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PKT_FWD_TYPE_TABLE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_pkt_fwd_type_table_t_fields[] = {
    {
        .name  = L3UC_ROUTEDs,  /* L3UC_ROUTED */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "L3 unicast flow.",
    },
    {
        .name  = MULTICASTs,  /* MULTICAST */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Multicast flow.",
    },
    {
        .name  = SWITCHs,  /* SWITCH */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "L2 switch flow.",
    },
    {
        .name  = L3_MCs,  /* L3_MC */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "L3 multicast flow.",
    },
    {
        .name  = L3_MC_L3ONLYs,  /* L3_MC_L3ONLY */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Only L3 copies for L3 multicast flow.",
    },
    {
        .name  = MIRRORs,  /* MIRROR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Mirror flow.",
    },
    {
        .name  = INGRESS_MIRRORs,  /* INGRESS_MIRROR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Ingress mirror flow.",
    },
    {
        .name  = PKT_TO_CPUs,  /* PKT_TO_CPU */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Send to CPU flow, including mirror, copy, switch.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Copy to CPU flow.",
    },
    {
        .name  = MIRROR_ON_DROPs,  /* MIRROR_ON_DROP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Mirror on drop flow.",
    },
    {
        .name  = FWD_TYPEs,  /* FWD_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Type of forwarding flow.",
    },
    {
        .name  = REMAP_CTRLs,  /* REMAP_CTRL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Control used to determine zone remapping.",
    },
    {
        .name  = REMAPs,  /* REMAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to lookup TM_MC_AGG_LIST_MEMBER_REMAP logical table.",
    },
    {
        .name  = TM_EGR_OBJECT_UPDATE_PROFILE_IDs,  /* TM_EGR_OBJECT_UPDATE_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_EGR_OBJECT_UPDATE_PROFILE logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_pkt_fwd_type_table_t = {
    .name = TM_PKT_FWD_TYPE_TABLEs, /* TM_PKT_FWD_TYPE_TABLE */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_tm_pkt_fwd_type_table_t_fields,
    .desc = "The TM_PKT_FWD_TYPE_TABLE table is used to\n specify forwarding behavior for a specific packet flow.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PM_FLEX_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_pm_flex_config_t_fields[] = {
    {
        .name  = MAX_SUB_PORTs,  /* MAX_SUB_PORT */
        .flags = 0,
        .width = 8,
        .depth = 64,
        .desc = "Maximum number of ports within port macro.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_pm_flex_config_t = {
    .name = TM_PM_FLEX_CONFIGs, /* TM_PM_FLEX_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 1,
    .field = bcmltd_tm_pm_flex_config_t_fields,
    .desc = "",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PORT_MAP_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_port_map_info_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port number.",
    },
    {
        .name  = PC_PHYS_PORT_IDs,  /* PC_PHYS_PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Physical port number.",
    },
    {
        .name  = TM_PIPEs,  /* TM_PIPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM pipe number.",
    },
    {
        .name  = TM_LOCAL_PORTs,  /* TM_LOCAL_PORT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM pipe-local port number.",
    },
    {
        .name  = TM_SPARSE_GLOBAL_PORTs,  /* TM_SPARSE_GLOBAL_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TM sparse global port number.\n The discrete global port number to index ports within TM.\n",
    },
    {
        .name  = TM_COMPACT_GLOBAL_PORTs,  /* TM_COMPACT_GLOBAL_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TM compact global port number.\n The continuous global port number based on TM pipe-local port number and pipe offsets.\n",
    },
    {
        .name  = BASE_UC_Qs,  /* BASE_UC_Q */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Unicast queue number base.",
    },
    {
        .name  = NUM_UC_Qs,  /* NUM_UC_Q */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of Unicast Queues.",
    },
    {
        .name  = BASE_MC_Qs,  /* BASE_MC_Q */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Multicast queue number base.",
    },
    {
        .name  = NUM_MC_Qs,  /* NUM_MC_Q */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of Multicast Queues.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_port_map_info_t = {
    .name = TM_PORT_MAP_INFOs, /* TM_PORT_MAP_INFO */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_tm_port_map_info_t_fields,
    .desc = "The TM_PORT_MAP_INFO table provides port numbers and UC/MC queue numbers\n associated with a logical port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PORT_MC_Q_TO_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_port_mc_q_to_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue ID.",
    },
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = USE_QGROUP_MINs,  /* USE_QGROUP_MIN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use queue group minimum threshold.\n Disable to use queue minimum threshold.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_MC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid due to one\n of the following reasons:\n The mapping between PORT_ID to physical port is missing.\n The TM_MC_Q_ID exceeds TM_SCHEDULER_CONFIG.NUM_MC_Q for non-cpu port\n or TM_DEVICE_CONFIG.NUM_CPU_Q for cpu port.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_port_mc_q_to_service_pool_t = {
    .name = TM_PORT_MC_Q_TO_SERVICE_POOLs, /* TM_PORT_MC_Q_TO_SERVICE_POOL */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tm_port_mc_q_to_service_pool_t_fields,
    .desc = "The TM_PORT_MC_Q_TO_SERVICE_POOL table specifies egress service pool ID per\n multicast queue and the associated minimum guarantees. This table must not be\n updated while traffic is flowing.\n\n It is highly recommended that packets are mapped to the same ingress and\n egress shared data buffer cells service pools.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PORT_UC_Q_TO_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_port_uc_q_to_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID.",
    },
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = USE_QGROUP_MINs,  /* USE_QGROUP_MIN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use queue group minimum threshold.\n Disable to use queue minimum threshold.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_UC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if the\n mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_port_uc_q_to_service_pool_t = {
    .name = TM_PORT_UC_Q_TO_SERVICE_POOLs, /* TM_PORT_UC_Q_TO_SERVICE_POOL */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tm_port_uc_q_to_service_pool_t_fields,
    .desc = "The TM_PORT_UC_Q_TO_SERVICE_POOL table specifies egress service pool ID per\n unicast queue and the associated minimum guarantees. This table must not be\n updated while traffic is flowing.\n\n It is highly recommended that packets are mapped to the same ingress and\n egress shared data buffer cells service pools.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_PRI_GRP_POOL_MAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_pri_grp_pool_map_t_fields[] = {
    {
        .name  = TM_PRI_GRP_POOL_MAP_IDs,  /* TM_PRI_GRP_POOL_MAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the TM_PRI_GRP_POOL_MAP table.",
    },
    {
        .name  = TM_PRI_GRP_IDs,  /* TM_PRI_GRP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Priority group",
    },
    {
        .name  = TM_ING_SERVICE_POOL_IDs,  /* TM_ING_SERVICE_POOL_ID */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = TM_HEADROOM_POOL_IDs,  /* TM_HEADROOM_POOL_ID */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "TM_ING_THD_HEADROOM_POOL table index.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_pri_grp_pool_map_t = {
    .name = TM_PRI_GRP_POOL_MAPs, /* TM_PRI_GRP_POOL_MAP */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_pri_grp_pool_map_t_fields,
    .desc = "The TM_PRI_GRP_POOL_MAP specifies the map between priority group and headroom\n pool, service pool. This table must not be updated while traffic is flowing.\n\n It is highly recommended that packets are mapped to the same ingress and\n egress shared data buffer cells service pools.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_Q_ASSIGNMENT_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_q_assignment_profile_t_fields[] = {
    {
        .name  = TM_Q_ASSIGNMENT_PROFILE_IDs,  /* TM_Q_ASSIGNMENT_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index to queue assignment profile table.",
    },
    {
        .name  = BASE_PORT_COS_Q_MAP_IDs,  /* BASE_PORT_COS_Q_MAP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "PORT_COS_Q_MAP profile base index.",
    },
    {
        .name  = BASE_FP_ING_COS_Q_MAP_IDs,  /* BASE_FP_ING_COS_Q_MAP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP_ING_COS_Q_MAP profile base index.",
    },
    {
        .name  = BASE_FP_DESTINATION_COS_Q_MAP_IDs,  /* BASE_FP_DESTINATION_COS_Q_MAP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "FP_DESTINATION_COS_Q_MAP profile base index.",
    },
    {
        .name  = PORT_COS_Q_STRENGTH_PROFILE_IDs,  /* PORT_COS_Q_STRENGTH_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PORT_COS_Q_STRENGTH_PROFILE table index.",
    },
    {
        .name  = FP_ING_COS_Q_STRENGTH_PROFILE_IDs,  /* FP_ING_COS_Q_STRENGTH_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "FP_ING_COS_Q_STRENGTH_PROFILE table index.",
    },
    {
        .name  = TM_COS_Q_CPU_STRENGTH_PROFILE_IDs,  /* TM_COS_Q_CPU_STRENGTH_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_COS_Q_CPU_STRENGTH_PROFILE table index.",
    },
    {
        .name  = FP_DESTINATION_COS_Q_STRENGTH_PROFILE_IDs,  /* FP_DESTINATION_COS_Q_STRENGTH_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "FP_DESTINATION_COS_Q_STRENGTH_PROFILE table index.",
    },
    {
        .name  = MC_COS_MIRRORs,  /* MC_COS_MIRROR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use multicast COS from mirroring.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_q_assignment_profile_t = {
    .name = TM_Q_ASSIGNMENT_PROFILEs, /* TM_Q_ASSIGNMENT_PROFILE */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_tm_q_assignment_profile_t_fields,
    .desc = "The TM_Q_ASSIGNMENT_PROFILE table specifies device-level TM queue assignment\n properties.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SCHEDULER_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_scheduler_config_t_fields[] = {
    {
        .name  = NUM_MC_Qs,  /* NUM_MC_Q */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SCHED_PORT_NUM_MC_Q_T_DATA,
        .desc = "Maximum number of multicast queues for a port.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_scheduler_config_t = {
    .name = TM_SCHEDULER_CONFIGs, /* TM_SCHEDULER_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 1,
    .field = bcmltd_tm_scheduler_config_t_fields,
    .desc = "The TM_SCHEDULER_CONFIG table specifies the device-level scheduler\n configuration.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SCHEDULER_CPU_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_scheduler_cpu_port_t_fields[] = {
    {
        .name  = WRRs,  /* WRR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables WRR mode.",
    },
    {
        .name  = WDRR_CREDITSs,  /* WDRR_CREDITS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SCHED_CPU_CREDIT_WDRR_T_DATA,
        .desc = "Credits for the excess bandwidth WDRR scheduling mode.\n Applicable only if WRR is disabled.\n",
    },
    {
        .name  = WRR_CREDITSs,  /* WRR_CREDITS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SCHED_CPU_CREDIT_WRR_T_DATA,
        .desc = "Credits for the excess bandwidth WRR scheduling mode.\n Applicable only if WRR is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_scheduler_cpu_port_t = {
    .name = TM_SCHEDULER_CPU_PORTs, /* TM_SCHEDULER_CPU_PORT */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_scheduler_cpu_port_t_fields,
    .desc = "The TM_SCHEDULER_CPU_PORT table specifies the scheduling mode and weights for\n CPU ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SCHEDULER_NODE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_scheduler_node_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_SCHEDULER_NODE_IDs,  /* TM_SCHEDULER_NODE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into scheduler node table.",
    },
    {
        .name  = SCHED_NODEs,  /* SCHED_NODE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Scheduler node type in the hierarchy.",
    },
    {
        .name  = SCHED_MODEs,  /* SCHED_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Traffic scheduling mode.",
    },
    {
        .name  = WEIGHTs,  /* WEIGHT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Weight of the nodes used by schedulers.\n Weight for strict-priority scheduling mode should be zero.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SCHED_NODE_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE of the entry becomes invalid if the mapping\n between PORT_ID to the physical port is missing or\n TM_SCHEDULER_PROFILE mapped to the TM_SCHEDULER_PORT_PROFILE is invalid.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_scheduler_node_t = {
    .name = TM_SCHEDULER_NODEs, /* TM_SCHEDULER_NODE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_scheduler_node_t_fields,
    .desc = "The TM_SCHEDULER_NODE table specifies the scheduling mode for\n scheduling nodes at different levels.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SCHEDULER_PORT_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_scheduler_port_profile_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_SCHEDULER_PROFILE_IDs,  /* TM_SCHEDULER_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_SCHEDULER_PROFILE table index.",
    },
    {
        .name  = WRRs,  /* WRR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables WRR scheduling mode.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SCHED_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE of the entry becomes invalid if the mapping\n between PORT_ID to the physical port is missing or\n TM_SCHEDULER_PROFILE mapped is invalid.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_scheduler_port_profile_t = {
    .name = TM_SCHEDULER_PORT_PROFILEs, /* TM_SCHEDULER_PORT_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_scheduler_port_profile_t_fields,
    .desc = "The TM_SCHEDULER_PORT_PROFILE table defines the mapping of the scheduler\n hierarchy associated with non-CPU ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SCHEDULER_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_scheduler_profile_t_fields[] = {
    {
        .name  = TM_SCHEDULER_PROFILE_IDs,  /* TM_SCHEDULER_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the scheduler hierarchy profile table.",
    },
    {
        .name  = TM_SCHEDULER_NODE_IDs,  /* TM_SCHEDULER_NODE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TM_SCHEDULER_NODE table index.",
    },
    {
        .name  = NUM_UC_Qs,  /* NUM_UC_Q */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of unicast queue associated with TM_SCHEDULER_NODE_ID.",
    },
    {
        .name  = NUM_MC_Qs,  /* NUM_MC_Q */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of multicast queue associated with TM_SCHEDULER_NODE_ID.",
    },
    {
        .name  = FLOW_CTRL_UCs,  /* FLOW_CTRL_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set flow control only for unicast packets.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SCHED_PROFILE_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry is invalid if\n the profile is incomplete or the number of unicast and multicast\n queues configured violates TM_SCHEDULER_CONFIG.NUM_MC_QUEUE\n and TM_DEVICE_INFO.NUM_Q.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_scheduler_profile_t = {
    .name = TM_SCHEDULER_PROFILEs, /* TM_SCHEDULER_PROFILE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_scheduler_profile_t_fields,
    .desc = "The TM_SCHEDULER_PROFILE table specifies the profiles for the scheduling\n hierarchy.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SCHEDULER_PROFILE_Q_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_scheduler_profile_q_info_t_fields[] = {
    {
        .name  = TM_SCHEDULER_PROFILE_IDs,  /* TM_SCHEDULER_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TM_SCHEDULER_PROFILE table index.",
    },
    {
        .name  = TM_SCHEDULER_NODE_IDs,  /* TM_SCHEDULER_NODE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TM_SCHEDULER_NODE table index.",
    },
    {
        .name  = NUM_TM_UC_Qs,  /* NUM_TM_UC_Q */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid elements in TM_UC_Q_ID.",
    },
    {
        .name  = NUM_TM_MC_Qs,  /* NUM_TM_MC_Q */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of valid elements in TM_MC_Q_ID.",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = 0,
        .width = 8,
        .depth = 2,
        .desc = "Unicast queue IDs.",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue ID.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_scheduler_profile_q_info_t = {
    .name = TM_SCHEDULER_PROFILE_Q_INFOs, /* TM_SCHEDULER_PROFILE_Q_INFO */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_scheduler_profile_q_info_t_fields,
    .desc = "The TM_SCHEDULER_PROFILE_Q_INFO table provides unicast and multicast\n queue ID information.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SCHEDULER_SHAPER_CPU_NODE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_scheduler_shaper_cpu_node_t_fields[] = {
    {
        .name  = SCHED_NODEs,  /* SCHED_NODE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Scheduler node type in the hierarchy.",
    },
    {
        .name  = TM_SCHEDULER_SHAPER_CPU_NODE_IDs,  /* TM_SCHEDULER_SHAPER_CPU_NODE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the TM_SCHEDULER_SHAPER_CPU_NODE table.",
    },
    {
        .name  = SCHED_MODEs,  /* SCHED_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Traffic scheduling mode.",
    },
    {
        .name  = WEIGHTs,  /* WEIGHT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Weight of the nodes used by the schedulers. Weight for strict-priority\n scheduling mode should be zero.\n",
    },
    {
        .name  = PARENT_TM_SCHEDULER_SHAPER_CPU_NODE_IDs,  /* PARENT_TM_SCHEDULER_SHAPER_CPU_NODE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Parent node for TM_SCHEDULER_SHAPER_CPU_NODE_ID.\n Valid only if SCHED_NODE is L1_SCHED_NODE_MC.\n",
    },
    {
        .name  = SHAPING_MODEs,  /* SHAPING_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SHAPING_MODE_T_DATA,
        .desc = "Traffic shaping mode.",
    },
    {
        .name  = BURST_SIZE_AUTOs,  /* BURST_SIZE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation of burst size. When this field is\n enabled the minimum and maximum burst sizes are calculated\n internally and are reflected in the MAX_BURST_SIZE_KBITS_OPER and\n MIN_BURST_SIZE_KBITS_OPER fields.\n",
    },
    {
        .name  = MAX_BANDWIDTH_KBPSs,  /* MAX_BANDWIDTH_KBPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum bandwidth in kilobits per second.",
    },
    {
        .name  = MAX_BANDWIDTH_KBPS_OPERs,  /* MAX_BANDWIDTH_KBPS_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational maximum bandwidth. This is a read-only field which\n reflects the actual configured MAX_BANDWIDTH_KBPS value as\n a function of REFRESH_RATE and GRANULARITY.\n",
    },
    {
        .name  = MIN_BANDWIDTH_KBPSs,  /* MIN_BANDWIDTH_KBPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum bandwidth in kilobits per second.",
    },
    {
        .name  = MIN_BANDWIDTH_KBPS_OPERs,  /* MIN_BANDWIDTH_KBPS_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational minimum bandwidth. This is a read-only field which\n reflects the actual configured MIN_BANDWIDTH_KBPS value as a\n function of REFRESH_RATE and GRANULARITY.\n",
    },
    {
        .name  = MAX_BURST_SIZE_KBITSs,  /* MAX_BURST_SIZE_KBITS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum burst size in kilobits.\n Valid only if BURST_SIZE_AUTO is disabled.\n",
    },
    {
        .name  = MAX_BURST_SIZE_KBITS_OPERs,  /* MAX_BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational maximum burst size. This is a read-only field which\n reflects the actual configured MAX_BURST_SIZE value as a function\n of the MAX_BANDWIDTH_KBPS and SHAPING_MODE fields.\n Valid only if BURST_SIZE_AUTO is enabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_KBITSs,  /* MIN_BURST_SIZE_KBITS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Minimum burst size in kilobits.\n Valid only if BURST_SIZE_AUTO is disabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_KBITS_OPERs,  /* MIN_BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational minimum burst size. This is a read-only field which\n reflects the actual configured MIN_BURST_SIZE value as a function\n of MIN_BANDWIDTH_KBPS and SHAPING_MODE fields.\n Valid only if BURST_SIZE_AUTO is enabled.\n",
    },
    {
        .name  = ETHERNET_AVs,  /* ETHERNET_AV */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ethernet audio video settings. When this field is enabled,\n prioritizes the selection of ETHERNET_AV enabled\n TM_SCHEDULER_SHAPER_CPU_NODE for port bandwidth.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_scheduler_shaper_cpu_node_t = {
    .name = TM_SCHEDULER_SHAPER_CPU_NODEs, /* TM_SCHEDULER_SHAPER_CPU_NODE */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_tm_scheduler_shaper_cpu_node_t_fields,
    .desc = "The TM_SCHEDULER_SHAPER_CPU_NODE table specifies scheduler and shapers\n configurations for scheduling nodes associated with the CPU port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SCHEDULER_SHAPER_NODE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_scheduler_shaper_node_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = SCHED_NODEs,  /* SCHED_NODE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Scheduler node type in the hierarchy.",
    },
    {
        .name  = COSs,  /* COS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "COS values.",
    },
    {
        .name  = SCHED_MODEs,  /* SCHED_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Traffic scheduling mode.",
    },
    {
        .name  = WEIGHTs,  /* WEIGHT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Weight of the nodes used by schedulers.\n Weight for strict-priority scheduling mode should be zero.\n",
    },
    {
        .name  = SHAPING_MODEs,  /* SHAPING_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SHAPING_MODE_T_DATA,
        .desc = "Traffic shaping mode.",
    },
    {
        .name  = BURST_SIZE_AUTOs,  /* BURST_SIZE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation of burst size. When this field is enabled\n the minimum and maximum burst sizes are calculated internally and\n are reflected in the MAX_BURST_SIZE_KBITS_OPER and\n MIN_BURST_SIZE_KBITS_OPER fields.\n",
    },
    {
        .name  = MAX_BANDWIDTH_KBPSs,  /* MAX_BANDWIDTH_KBPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum bandwidth in kilobits per second.",
    },
    {
        .name  = MAX_BANDWIDTH_KBPS_OPERs,  /* MAX_BANDWIDTH_KBPS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational maximum bandwidth. This is a read-only field which\n reflects the actual configures MAX_BANDWIDTH_KBPS value as function\n of REFRESH_RATE and GRANULARITY.\n",
    },
    {
        .name  = MIN_BANDWIDTH_KBPSs,  /* MIN_BANDWIDTH_KBPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum bandwidth in kilobits per second.",
    },
    {
        .name  = MIN_BANDWIDTH_KBPS_OPERs,  /* MIN_BANDWIDTH_KBPS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational minimum bandwidth. This is a read-only field which\n reflects the actual configured MIN_BANDWIDTH_KBPS value as function\n of REFRESH_RATE and GRANULARITY.\n",
    },
    {
        .name  = MAX_BURST_SIZE_KBITSs,  /* MAX_BURST_SIZE_KBITS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum burst size in kilobits. Valid only if BURST_SIZE_AUTO\n is disabled.\n",
    },
    {
        .name  = MAX_BURST_SIZE_KBITS_OPERs,  /* MAX_BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational maximum burst size. This is a read-only field which\n reflects the actual configured MAX_BURST_SIZE value as a function\n of the MAX_BANDWIDTH_KBPS and SHAPING_MODE fields.\n",
    },
    {
        .name  = MIN_BURST_SIZE_KBITSs,  /* MIN_BURST_SIZE_KBITS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Minimum burst size in kilobits. Valid only if BURST_SIZE_AUTO\n is disabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_KBITS_OPERs,  /* MIN_BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Operational minimum burst size. This is a read-only field which\n reflects the actual configured MIN_BURST_SIZE value as a function\n of the MIN_BANDWIDTH_KBPS and SHAPING_MODE fields.\n",
    },
    {
        .name  = ETHERNET_AVs,  /* ETHERNET_AV */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables ethernet audio video settings. When this field is enabled,\n prioritizes the selection of ETHERNET_AV enabled COS for\n port bandwidth.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of\n the entry. The OPERATIONAL_STATE of the entry becomes invalid if\n the mapping between PORT_ID to the physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_scheduler_shaper_node_t = {
    .name = TM_SCHEDULER_SHAPER_NODEs, /* TM_SCHEDULER_SHAPER_NODE */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_tm_scheduler_shaper_node_t_fields,
    .desc = "The TM_SCHEDULER_SHAPER_NODE table specifies the scheduling mode and shaper\n values for scheduling nodes at different levels for non-CPU ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SCHEDULER_SP_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_scheduler_sp_profile_t_fields[] = {
    {
        .name  = TM_SCHEDULER_PROFILE_IDs,  /* TM_SCHEDULER_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TM_SCHEDULER_PROFILE table index.",
    },
    {
        .name  = STRICT_PRIORITYs,  /* STRICT_PRIORITY */
        .flags = 0,
        .width = 1,
        .depth = 12,
        .desc = "Enable to set the scheduling mode to strict priority for\n the TM_SCHEDULING_NODE_ID.\n",
    },
    {
        .name  = STRICT_PRIORITY_OPERs,  /* STRICT_PRIORITY_OPER */
        .flags = 0,
        .width = 1,
        .depth = 12,
        .desc = "Read only field which reflects the modification to the\n configured STRICT_PRIORITY value. If STRICT_PRIORITY is enabled\n for a specific scheduler node, all scheduler nodes with higher\n IDs will also be set as STRICT_PRIORITY.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_scheduler_sp_profile_t = {
    .name = TM_SCHEDULER_SP_PROFILEs, /* TM_SCHEDULER_SP_PROFILE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_scheduler_sp_profile_t_fields,
    .desc = "The TM_SCHEDULER_SP_PROFILE table specifies whether the scheduling node\n selected by the port in the scheduling hierarchy is configured for\n strict priority.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SERVICE_POOL_OVERRIDE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_service_pool_override_t_fields[] = {
    {
        .name  = MC_OVERRIDEs,  /* MC_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to override multicast service pool.",
    },
    {
        .name  = MC_SERVICE_POOLs,  /* MC_SERVICE_POOL */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Multicast override service pool ID. Applicable only if\n MC_OVERRIDE == 1.\n",
    },
    {
        .name  = CPU_OVERRIDEs,  /* CPU_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to override CPU service pool.",
    },
    {
        .name  = CPU_SERVICE_POOLs,  /* CPU_SERVICE_POOL */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "CPU override service pool ID. Applicable only if\n CPU_OVERRIDE == 1.\n",
    },
    {
        .name  = MIRROR_OVERRIDEs,  /* MIRROR_OVERRIDE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to override mirror service pool.",
    },
    {
        .name  = MIRROR_SERVICE_POOLs,  /* MIRROR_SERVICE_POOL */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Mirror override service pool ID. Applicable only if\n MIRROR_OVERRIDE == 1.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_service_pool_override_t = {
    .name = TM_SERVICE_POOL_OVERRIDEs, /* TM_SERVICE_POOL_OVERRIDE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_service_pool_override_t_fields,
    .desc = "The TM_SERVICE_POOL_OVERRIDE table configures service pool override for\n different flows. This table must not be updated while traffic is flowing.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SHAPER_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_shaper_config_t_fields[] = {
    {
        .name  = REFRESH_TIMEs,  /* REFRESH_TIME */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SHAPER_REFRESH_TIME_T_DATA,
        .desc = "Shaper bucket refresh time cycle in micro seconds.",
    },
    {
        .name  = ITU_MODEs,  /* ITU_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable ITU mode for burst size calculations.",
    },
    {
        .name  = SHAPERs,  /* SHAPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable egress shapers.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_shaper_config_t = {
    .name = TM_SHAPER_CONFIGs, /* TM_SHAPER_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 3,
    .field = bcmltd_tm_shaper_config_t_fields,
    .desc = "The TM_SHAPER_CONFIG table specifies device-level shaper configuration\n properties.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SHAPER_NODE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_shaper_node_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = SCHED_NODEs,  /* SCHED_NODE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Scheduler node type in the hierarchy.",
    },
    {
        .name  = TM_SCHEDULER_NODE_IDs,  /* TM_SCHEDULER_NODE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TM_SCHEDULER_NODE logical table index.",
    },
    {
        .name  = SHAPING_MODEs,  /* SHAPING_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SHAPING_MODE_T_DATA,
        .desc = "Traffic shaping mode.",
    },
    {
        .name  = BURST_SIZE_AUTOs,  /* BURST_SIZE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation of burst size. When this field is enabled\n the minimum and maximum burst sizes are calculated internally and\n are reflected in the MAX_BURST_SIZE_KBITS_OPER and\n MIN_BURST_SIZE_KBITS_OPER fields.\n",
    },
    {
        .name  = MAX_BANDWIDTH_KBPSs,  /* MAX_BANDWIDTH_KBPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum bandwidth in kilobits per second.",
    },
    {
        .name  = MAX_BANDWIDTH_KBPS_OPERs,  /* MAX_BANDWIDTH_KBPS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational maximum bandwidth. This is a read-only field which\n reflects the actual configured MAX_BANDWIDTH_KBPS value as function\n of REFRESH_RATE and GRANULARITY.\n",
    },
    {
        .name  = MIN_BANDWIDTH_KBPSs,  /* MIN_BANDWIDTH_KBPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum bandwidth in kilobits per second.",
    },
    {
        .name  = MIN_BANDWIDTH_KBPS_OPERs,  /* MIN_BANDWIDTH_KBPS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational minimum bandwidth. This is a read-only field which\n reflects the actual configured MIN_BANDWIDTH_KBPS value as a\n function of REFRESH_RATE and GRANULARITY.\n",
    },
    {
        .name  = MAX_BURST_SIZE_KBITSs,  /* MAX_BURST_SIZE_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum burst size in kilobits. Valid only if BURST_SIZE_AUTO\n is disabled.\n",
    },
    {
        .name  = MAX_BURST_SIZE_KBITS_OPERs,  /* MAX_BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational maximum burst size. This is a read-only field which\n reflects the actual configured MAX_BURST_SIZE value as a function\n of the MAX_BANDWIDTH_KBPS and SHAPING_MODE fields.\n Valid only if BURST_SIZE_AUTO is enabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_KBITSs,  /* MIN_BURST_SIZE_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum burst size in kilobits. Valid only if BURST_SIZE_AUTO\n is disabled.\n",
    },
    {
        .name  = MIN_BURST_SIZE_KBITS_OPERs,  /* MIN_BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational minimum burst size. This is a read-only field which\n reflects the actual configured MIN_BURST_SIZE value as a function\n of the MIN_BANDWIDTH_KBPS and SHAPING_MODE fields.\n Valid only if BURST_SIZE_AUTO is enabled.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SCHED_NODE_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of\n the entry. The OPERATIONAL_STATE of the entry becomes invalid if the mapping\n between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_shaper_node_t = {
    .name = TM_SHAPER_NODEs, /* TM_SHAPER_NODE */
    .flags = 0,
    .fields = 14,
    .field = bcmltd_tm_shaper_node_t_fields,
    .desc = "The TM_SHAPER_NODE table specifies shaper values for scheduling nodes\n associated with non-CPU ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_SHAPER_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_shaper_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = SHAPING_MODEs,  /* SHAPING_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SHAPING_MODE_T_DATA,
        .desc = "Traffic shaping mode.",
    },
    {
        .name  = HULL_MODEs,  /* HULL_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable high bandwidth ultra low latency mode. The port won't be\n shaped when HULL_MODE is enabled.\n",
    },
    {
        .name  = BURST_SIZE_AUTOs,  /* BURST_SIZE_AUTO */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables automatic calculation of burst size. When this field is\n enabled, the burst size is calculated internally and is reflected\n in the BURST_SIZE_KBITS_OPER field.\n",
    },
    {
        .name  = BANDWIDTH_KBPSs,  /* BANDWIDTH_KBPS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum bandwidth in kilobits per second.",
    },
    {
        .name  = BANDWIDTH_KBPS_OPERs,  /* BANDWIDTH_KBPS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operation maximum bandwidth. This is a read-only field which\n reflects the actual configured BANDWIDTH_KBPS values as a function\n of REFRESH_RATE and GRANULARITY.\n",
    },
    {
        .name  = BURST_SIZE_KBITSs,  /* BURST_SIZE_KBITS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Maximum burst size in kilobits. Valid only if BURST_SIZE_AUTO\n is disabled.\n",
    },
    {
        .name  = BURST_SIZE_KBITS_OPERs,  /* BURST_SIZE_KBITS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational maximum burst size. This is a read-only field which\n reflects the actual configured BURST_SIZE_KBITS value as a function\n of the BANDWIDTH_KBPS and SHAPING_MODE.\n Valid only is BURST_SIZE_AUTO is enabled.\n",
    },
    {
        .name  = ETHERNET_AVs,  /* ETHERNET_AV */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable Ethernet Audio Video control settings. When this field is\n enabled, prioritizes the selection of ETHERNET_AV enabled\n TM_SCHEDULER_SHAPER_NODE and TM_SCHEDULER_SHAPER_CPU_NODE for\n port bandwidth.\n",
    },
    {
        .name  = INTER_FRAME_GAP_BYTEs,  /* INTER_FRAME_GAP_BYTE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Preamble and inter-frame gap (IFG) bytes for non-HiGig2.",
    },
    {
        .name  = INTER_FRAME_GAP_ENCAPs,  /* INTER_FRAME_GAP_ENCAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add inter-frame gap (IFG) bytes to the shaping counters.\n On disabling inter-frame gap bytes are subtracted.\n",
    },
    {
        .name  = INTER_FRAME_GAP_HIGIG2_BYTEs,  /* INTER_FRAME_GAP_HIGIG2_BYTE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Preamble and inter-frame gap (IFG) bytes to be added in\n shaping counters for HiGig2.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of\n the entry. The OPERATIONAL_STATE of the entry becomes invalid if the\n mapping between PORT_ID to internal physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_shaper_port_t = {
    .name = TM_SHAPER_PORTs, /* TM_SHAPER_PORT */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_tm_shaper_port_t_fields,
    .desc = "The TM_SHAPER_PORT table specifies maximum shapers values for all ports,\n inclusive of all CPU and non-CPU ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_THD_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_thd_config_t_fields[] = {
    {
        .name  = THRESHOLD_MODEs,  /* THRESHOLD_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "TM threshold mode.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_thd_config_t = {
    .name = TM_THD_CONFIGs, /* TM_THD_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 1,
    .field = bcmltd_tm_thd_config_t_fields,
    .desc = "The TM_THD_CONFIG logical table specifies TM thresholds mode.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_THD_DYNAMIC_MARGIN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_thd_dynamic_margin_t_fields[] = {
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = MARGINs,  /* MARGIN */
        .flags = 0,
        .width = 32,
        .depth = 10,
        .desc = "Margin.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_thd_dynamic_margin_t = {
    .name = TM_THD_DYNAMIC_MARGINs, /* TM_THD_DYNAMIC_MARGIN */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tm_thd_dynamic_margin_t_fields,
    .desc = "The TM_THD_DYNAMIC_MARGIN table is used to specify the margin levels\n to be used to indicate which limit low priority alpha to use.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_THD_MC_EGR_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_thd_mc_egr_service_pool_t_fields[] = {
    {
        .name  = TM_EGR_SERVICE_POOL_IDs,  /* TM_EGR_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Service pool ID.",
    },
    {
        .name  = BUFFER_POOLs,  /* BUFFER_POOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Buffer pool index.",
    },
    {
        .name  = SHARED_LIMIT_CELLSs,  /* SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit in cells.\n For all service pools in the same buffer pool, the sum of the\n SHARED_LIMIT_CELLS should always equal the total shared buffer cells.\n When adjusting SHARED_LIMIT_CELLS for a service pool, it is highly\n recommended to also adjust the SHARED_LIMIT_CELLS across other service\n pools in order to avoid changing the total shared buffer cells.\n",
    },
    {
        .name  = SHARED_LIMIT_CELLS_OPERs,  /* SHARED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational shared buffer limit cells. This read-only field reflects\n any modification to the configured SHARED_LIMIT_CELLS as a function\n of all reserved resources (minimum guarantee and headroom pool limit)\n associated to the specified service pool. Increasing/decreasing a\n reserved resource by certain amount results in decreasing/increasing\n of the corresponding service pool shared limit by the same amount.\n",
    },
    {
        .name  = SHARED_RESUME_LIMIT_CELLSs,  /* SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static transmit resume limit in cells.",
    },
    {
        .name  = SHARED_RESUME_LIMIT_CELLS_OPERs,  /* SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational resume offset limit in\n cells. It can be different than the configured SHARED_RESUME_LIMIT_CELLS\n if the configured value is larger than SHARED_LIMIT_CELLS or it is\n not in 8-cell granularity.\n",
    },
    {
        .name  = COLOR_SPECIFIC_LIMITSs,  /* COLOR_SPECIFIC_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets based on color specific shared buffer limits.\n All color specific shared buffer limits and resume limits should\n still be properly configured if COLOR_SPECIFIC_LIMITS is disabled.\n",
    },
    {
        .name  = YELLOW_SHARED_LIMIT_CELLSs,  /* YELLOW_SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit for yellow packets in cells. Yellow packets are\n dropped when exceeds YELLOW_SHARED_LIMIT_CELLS if\n USE_COLOR_SPECIFIC_LIMITS is enabled.\n",
    },
    {
        .name  = YELLOW_SHARED_LIMIT_CELLS_OPERs,  /* YELLOW_SHARED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for yellow packets. It can be different than the configured\n YELLOW_SHARED_LIMIT_CELLS if the configured value is larger than\n SHARED_LIMIT_CELLS or it is not in 8-cell granularity.\n",
    },
    {
        .name  = YELLOW_SHARED_RESUME_LIMIT_CELLSs,  /* YELLOW_SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Transmission resume limit (in cells) for yellow packets.",
    },
    {
        .name  = YELLOW_SHARED_RESUME_LIMIT_CELLS_OPERs,  /* YELLOW_SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational resume offset limit for\n yellow packets in cells. It can be different than the configured\n YELLOW_SHARED_RESUME_LIMIT_CELLS if the configured value is larger\n than YELLOW_SHARED_LIMIT_CELLS or it is not in 8-cell granularity.\n",
    },
    {
        .name  = RED_SHARED_LIMIT_CELLSs,  /* RED_SHARED_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer limit for red packets in cells. Red packets are\n dropped when exceeds RED_SHARED_LIMIT_CELLS if\n USE_COLOR_SPECIFIC_LIMITS is enabled.\n",
    },
    {
        .name  = RED_SHARED_LIMIT_CELLS_OPERs,  /* RED_SHARED_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for red packets. It can be different than the configured\n RED_SHARED_LIMIT_CELLS if the configured value is larger than\n SHARED_LIMIT_CELLS or it is not in 8-cell granularity.\n",
    },
    {
        .name  = RED_SHARED_RESUME_LIMIT_CELLSs,  /* RED_SHARED_RESUME_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Transmission resume limit (in cells) for red packets.",
    },
    {
        .name  = RED_SHARED_RESUME_LIMIT_CELLS_OPERs,  /* RED_SHARED_RESUME_LIMIT_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational resume offset limit for red\n packets in cells. It can be different than the configured\n RED_SHARED_RESUME_LIMIT_CELLS if the configured value is larger than\n RED_SHARED_LIMIT_CELLS or it is not in 8-cell granularity.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_EGR_THD_SERVICE_POOL_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE becomes invalid due to one of the following reasons:\n The SHARED_LIMIT_CELLS cannot be allocated without decreasing the\n other service pool's shared limit.\n Any of the resume limits is larger than its corresponding drop limit.\n Any of the color limit is larger than SHARED_LIMIT_CELLS.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_thd_mc_egr_service_pool_t = {
    .name = TM_THD_MC_EGR_SERVICE_POOLs, /* TM_THD_MC_EGR_SERVICE_POOL */
    .flags = 0,
    .fields = 16,
    .field = bcmltd_tm_thd_mc_egr_service_pool_t_fields,
    .desc = "The TM_THD_MC_EGR_SERVICE_POOL table specifies buffer threshold per egress\n service pool for MC-CQE (Multicast Cell Queue Entry) resources that are used\n only by multicast traffic.\n\n For some devices, there are multiple buffer pools. Each buffer pool contains\n a complete set of egress service pools. By default, the buffer thresholds\n of a specific egress service pool across different buffer pools are the same.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_THD_MC_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_thd_mc_q_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_MC_Q_IDs,  /* TM_MC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Multicast queue ID.",
    },
    {
        .name  = MIN_GUARANTEE_CELLSs,  /* MIN_GUARANTEE_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum guranteed cells.",
    },
    {
        .name  = MIN_GUARANTEE_CELLS_OPERs,  /* MIN_GUARANTEE_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational minimum guaranteed cells.\n It can be different than the configured MIN_GUARANTEE_CELLS if the\n configured value cannot be allocated.\n",
    },
    {
        .name  = SHARED_LIMITSs,  /* SHARED_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use shared buffer limit.",
    },
    {
        .name  = DYNAMIC_SHARED_LIMITSs,  /* DYNAMIC_SHARED_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use dynamic threshold for shared buffer limit.",
    },
    {
        .name  = SHARED_LIMIT_CELLS_STATICs,  /* SHARED_LIMIT_CELLS_STATIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static shared buffer limit in cells.\n Applicable only if SHARED_LIMITS is enabled and DYNAMIC_SHARED_LIMITS\n is disabled.\n",
    },
    {
        .name  = SHARED_LIMIT_DYNAMICs,  /* SHARED_LIMIT_DYNAMIC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Dynamic shared buffer limit (alpha) represented as a fraction.\n Applicable only if SHARED_LIMITS and DYNAMIC_SHARED_LIMITS are enabled.\n",
    },
    {
        .name  = RESUME_OFFSET_CELLSs,  /* RESUME_OFFSET_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to shared buffer limit used to calculate transmit resume limit.\n Transmit resume limit = shared buffer limit - RESUME_OFFSET_CELLS.\n Transmit will resume when transmit resume limit is reached.\n Applicable only if SHARED_LIMITS is enabled.\n The field is in 8-cell granularity.\n",
    },
    {
        .name  = RESUME_OFFSET_CELLS_OPERs,  /* RESUME_OFFSET_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational resume offset limit in\n cells. It can be different than the configured RESUME_OFFSET_CELLS if\n the configured value is not in 8-cell granularity.\n",
    },
    {
        .name  = RESUME_FLOOR_CELLSs,  /* RESUME_FLOOR_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static lower bound for transmit resume limit, which will become the\n operating transmit resume limit if the configured transmit resume\n limit is lower than RESUME_FLOOR_CELLS.\n",
    },
    {
        .name  = COLOR_SPECIFIC_LIMITSs,  /* COLOR_SPECIFIC_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use color based discards shared buffer limits.",
    },
    {
        .name  = COLOR_SPECIFIC_DYNAMIC_LIMITSs,  /* COLOR_SPECIFIC_DYNAMIC_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use dynamic color based discards shared buffer limits.",
    },
    {
        .name  = YELLOW_LIMIT_CELLS_STATICs,  /* YELLOW_LIMIT_CELLS_STATIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer static limit for yellow packets (in 8-cell granularity).\n Applicable only if SHARED_LIMITS and COLOR_SPECIFIC_LIMITS are\n enabled, and COLOR_SPECIFIC_DYNAMIC_LIMITS is disabled.\n",
    },
    {
        .name  = YELLOW_LIMIT_CELLS_STATIC_OPERs,  /* YELLOW_LIMIT_CELLS_STATIC_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for yellow packets. It can be different than the configured\n YELLOW_LIMIT_CELLS_STATIC if the configured value is not in 8-cell\n granularity.\n",
    },
    {
        .name  = YELLOW_LIMIT_DYNAMICs,  /* YELLOW_LIMIT_DYNAMIC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer dynamic limit for yellow packets represented as a\n percentage.\n Applicable only if SHARED_LIMITS, COLOR_SPECIFIC_LIMITS, and\n COLOR_SPECIFIC_DYNAMIC_LIMITS are enabled.\n",
    },
    {
        .name  = RED_LIMIT_CELLS_STATICs,  /* RED_LIMIT_CELLS_STATIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer static limit for red packets (in 8-cell granularity).\n Applicable only if SHARED_LIMITS and COLOR_SPECIFIC_LIMITS are\n enabled, and COLOR_SPECIFIC_DYNAMIC_LIMITS is disabled.\n",
    },
    {
        .name  = RED_LIMIT_CELLS_STATIC_OPERs,  /* RED_LIMIT_CELLS_STATIC_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for red packets. It can be different than the configured\n RED_LIMIT_CELLS_STATIC if the configured value is not in 8-cell\n granularity.\n",
    },
    {
        .name  = RED_LIMIT_DYNAMICs,  /* RED_LIMIT_DYNAMIC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer dynamic limit for red packets represented as a\n percentage.\n Applicable only if SHARED_LIMITS, COLOR_SPECIFIC_LIMITS, and\n COLOR_SPECIFIC_DYNAMIC_LIMITS are enabled.\n",
    },
    {
        .name  = RESUME_OFFSET_YELLOW_CELLSs,  /* RESUME_OFFSET_YELLOW_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to shared buffer limit used to calculate transmit resume limit\n for yellow packets.\n Transmit resume limit = shared buffer limit - RESUME_OFFSET_CELLS.\n Transmit will resume when transmit resume limit is reached.\n",
    },
    {
        .name  = RESUME_FLOOR_YELLOW_CELLSs,  /* RESUME_FLOOR_YELLOW_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static lower bound of transmit resume limit for yellow packets,\n which will become the operating transmit resume limit if the\n configured transmit resume limit is lower than RESUME_FLOOR_CELLS.\n",
    },
    {
        .name  = RESUME_OFFSET_RED_CELLSs,  /* RESUME_OFFSET_RED_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to shared buffer limit used to calculate transmit resume limit\n for red packets.\n Transmit resume limit = shared buffer limit - RESUME_OFFSET_CELLS.\n Transmit will resume when transmit resume limit is reached.\n",
    },
    {
        .name  = RESUME_FLOOR_RED_CELLSs,  /* RESUME_FLOOR_RED_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static lower bound of transmit resume limit for red packets,\n which will become the operating transmit resume limit if the\n configured transmit resume limit is lower than RESUME_FLOOR_CELLS.\n",
    },
    {
        .name  = TM_EGR_BST_THD_Q_PROFILE_IDs,  /* TM_EGR_BST_THD_Q_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_EGR_BST_THD_Q_PROFILE table index. Provides the profile ID to\n be used for per queue BST threshold selection.\n",
    },
    {
        .name  = TM_EBST_PROFILE_IDs,  /* TM_EBST_PROFILE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "TM_EBST_PROFILE table index. It provides the index to the\n EBST thresholds profile table.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_THD_MC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE becomes invalid due to one of the following\n reasons:\n The mapping between PORT_ID and the physical port is missing.\n The MIN_GUARANTEE_CELLS exceeds the total available buffer size.\n TM_MC_Q_ID exceeds TM_SCHEDULER_CONFIG.NUM_MC_Q for non-cpu ports\n or TM_DEVICE_CONFIG.NUM_CPU_Q for cpu ports.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_thd_mc_q_t = {
    .name = TM_THD_MC_Qs, /* TM_THD_MC_Q */
    .flags = 0,
    .fields = 26,
    .field = bcmltd_tm_thd_mc_q_t_fields,
    .desc = "The TM_THD_MC_Q table specifies the buffer threshold configurations for\n multicast queues.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_THD_PORT_INT_PRI_TO_PRI_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_thd_port_int_pri_to_pri_grp_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 4,
        .depth = 0,
        .desc = "Input packet priority.",
    },
    {
        .name  = TM_THD_PORT_PRI_GRP_IDs,  /* TM_THD_PORT_PRI_GRP_ID */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Index into TM_THD_PORT_PRI_GRP table.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if the\n mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_thd_port_int_pri_to_pri_grp_t = {
    .name = TM_THD_PORT_INT_PRI_TO_PRI_GRPs, /* TM_THD_PORT_INT_PRI_TO_PRI_GRP */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_thd_port_int_pri_to_pri_grp_t_fields,
    .desc = "The TM_THD_PORT_INT_PRI_TO_PRI_GRP table specifies the mapping of internal\n priority to priority group for each port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_THD_PORT_PRI_GRP_TO_HEADROOM_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_thd_port_pri_grp_to_headroom_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_THD_PORT_PRI_GRP_IDs,  /* TM_THD_PORT_PRI_GRP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Index into TM_THD_PORT_PRI_GRP table.",
    },
    {
        .name  = TM_THD_HEADROOM_POOL_IDs,  /* TM_THD_HEADROOM_POOL_ID */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Index into TM_THD_HEADROOM_POOL table.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if the\n mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_thd_port_pri_grp_to_headroom_pool_t = {
    .name = TM_THD_PORT_PRI_GRP_TO_HEADROOM_POOLs, /* TM_THD_PORT_PRI_GRP_TO_HEADROOM_POOL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_thd_port_pri_grp_to_headroom_pool_t_fields,
    .desc = "The TM_THD_PORT_PRI_GRP_TO_HEADROOM_POOL table specifies the mapping of\n port priority group to headroom pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_THD_PORT_PRI_GRP_TO_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_thd_port_pri_grp_to_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_THD_PORT_PRI_GRP_IDs,  /* TM_THD_PORT_PRI_GRP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Index into TM_THD_PORT_PRI_GRP table.",
    },
    {
        .name  = TM_THD_SERVICE_POOL_IDs,  /* TM_THD_SERVICE_POOL_ID */
        .flags = 0,
        .width = 2,
        .depth = 0,
        .desc = "Index into TM_THD_SERVICE_POOL table.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_ENTRY_STATE_T_DATA,
        .desc = "Operational state of the entry.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_thd_port_pri_grp_to_service_pool_t = {
    .name = TM_THD_PORT_PRI_GRP_TO_SERVICE_POOLs, /* TM_THD_PORT_PRI_GRP_TO_SERVICE_POOL */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tm_thd_port_pri_grp_to_service_pool_t_fields,
    .desc = "The TM_THD_PORT_PRI_GRP_TO_SERVICE_POOL table specifies the mapping of\n port priority group to service pool.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_THD_Q_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_thd_q_grp_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = UC_Q_GRP_MIN_GUARANTEE_CELLSs,  /* UC_Q_GRP_MIN_GUARANTEE_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum guaranteed data buffer cells for the group of unicast queues\n of a port that are configured to use queue group minimum guarantee.\n",
    },
    {
        .name  = UC_Q_GRP_MIN_GUARANTEE_CELLS_OPERs,  /* UC_Q_GRP_MIN_GUARANTEE_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational minimum guaranteed cells.\n It can be different than the configured UC_Q_GRP_MIN_GUARANTEE_CELLS\n if the configured value cannot be allocated.\n",
    },
    {
        .name  = MC_Q_GRP_MIN_GUARANTEE_CELLSs,  /* MC_Q_GRP_MIN_GUARANTEE_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum guaranteed data buffer cells for the group of multicast queues\n of a port that are configured to use queue group minimum guarantee.\n",
    },
    {
        .name  = MC_Q_GRP_MIN_GUARANTEE_CELLS_OPERs,  /* MC_Q_GRP_MIN_GUARANTEE_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational minimum guaranteed cells.\n It can be different than the configured MC_Q_GRP_MIN_GUARANTEE_CELLS\n if the configured value cannot be allocated.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_THD_Q_GRP_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE becomes invalid due to one of the following\n reasons:\n The mapping between PORT_ID and the physical port is missing.\n The UC/MC_Q_GRP_MIN_GUARANTEE_CELLS exceeds the total available\n buffer size.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_thd_q_grp_t = {
    .name = TM_THD_Q_GRPs, /* TM_THD_Q_GRP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_thd_q_grp_t_fields,
    .desc = "The TM_THD_Q_GRP table specifies unicast queue group minimum guarantee and\n multicast queue group minimum guarantee. Each egress port has unicast queues\n and multicast queues. All the unicast queues for a particular port belong to\n a unicast queue group, and all the multicast queues belong to a multicast\n queue group.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_THD_UC_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_thd_uc_q_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID.",
    },
    {
        .name  = MIN_GUARANTEE_CELLSs,  /* MIN_GUARANTEE_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum guranteed cells.",
    },
    {
        .name  = MIN_GUARANTEE_CELLS_OPERs,  /* MIN_GUARANTEE_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational minimum guaranteed cells.\n It can be different than the configured MIN_GUARANTEE_CELLS if the\n configured value cannot be allocated.\n",
    },
    {
        .name  = SHARED_LIMITSs,  /* SHARED_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use shared buffer limit.",
    },
    {
        .name  = DYNAMIC_SHARED_LIMITSs,  /* DYNAMIC_SHARED_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use dynamic threshold for shared buffer limit.",
    },
    {
        .name  = SHARED_LIMIT_CELLS_STATICs,  /* SHARED_LIMIT_CELLS_STATIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static shared buffer limit in cells.\n Applicable only if SHARED_LIMITS is enabled and DYNAMIC_SHARED_LIMITS\n is disabled.\n",
    },
    {
        .name  = SHARED_LIMIT_DYNAMICs,  /* SHARED_LIMIT_DYNAMIC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Dynamic shared buffer limit (alpha) represented as a fraction.\n Applicable only if SHARED_LIMITS and DYNAMIC_SHARED_LIMITS are enabled.\n",
    },
    {
        .name  = DYNAMIC_GROUPs,  /* DYNAMIC_GROUP */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Unicast queue's dynamic group.\n",
    },
    {
        .name  = RESUME_OFFSET_CELLSs,  /* RESUME_OFFSET_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to shared buffer limit used to calculate transmit resume limit.\n Transmit resume limit = shared buffer limit - RESUME_OFFSET_CELLS.\n Transmit will resume when transmit resume limit is reached.\n Applicable only if SHARED_LIMITS is enabled.\n The field is in 8-cell granularity.\n",
    },
    {
        .name  = RESUME_OFFSET_CELLS_OPERs,  /* RESUME_OFFSET_CELLS_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational resume offset limit in\n cells. It can be different than the configured RESUME_OFFSET_CELLS if\n the configured value is not in 8-cell granularity.\n",
    },
    {
        .name  = RESUME_FLOOR_CELLSs,  /* RESUME_FLOOR_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static lower bound for transmit resume limit, which will become the\n operating transmit resume limit if the configured transmit resume\n limit is lower than RESUME_FLOOR_CELLS.\n",
    },
    {
        .name  = COLOR_SPECIFIC_LIMITSs,  /* COLOR_SPECIFIC_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use color based discards shared buffer limits.",
    },
    {
        .name  = COLOR_SPECIFIC_DYNAMIC_LIMITSs,  /* COLOR_SPECIFIC_DYNAMIC_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use dynamic color based discards shared buffer limits.",
    },
    {
        .name  = YELLOW_LIMIT_CELLS_STATICs,  /* YELLOW_LIMIT_CELLS_STATIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer static limit for yellow packets (in 8-cell granularity).\n Applicable only if SHARED_LIMITS and COLOR_SPECIFIC_LIMITS are\n enabled, and COLOR_SPECIFIC_DYNAMIC_LIMITS is disabled.\n",
    },
    {
        .name  = YELLOW_LIMIT_CELLS_STATIC_OPERs,  /* YELLOW_LIMIT_CELLS_STATIC_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for yellow packets. It can be different than the configured\n YELLOW_LIMIT_CELLS_STATIC if the configured value is not in 8-cell\n granularity.\n",
    },
    {
        .name  = YELLOW_LIMIT_DYNAMICs,  /* YELLOW_LIMIT_DYNAMIC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer dynamic limit for yellow packets represented as a\n percentage.\n Applicable only if SHARED_LIMITS, COLOR_SPECIFIC_LIMITS, and\n COLOR_SPECIFIC_DYNAMIC_LIMITS are enabled.\n",
    },
    {
        .name  = RED_LIMIT_CELLS_STATICs,  /* RED_LIMIT_CELLS_STATIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer static limit for red packets (in 8-cell granularity).\n Applicable only if SHARED_LIMITS and COLOR_SPECIFIC_LIMITS are\n enabled, and COLOR_SPECIFIC_DYNAMIC_LIMITS is disabled.\n",
    },
    {
        .name  = RED_LIMIT_CELLS_STATIC_OPERs,  /* RED_LIMIT_CELLS_STATIC_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Read-only field reflects the operational shared buffer static limit\n for red packets. It can be different than the configured\n RED_LIMIT_CELLS_STATIC if the configured value is not in 8-cell\n granularity.\n",
    },
    {
        .name  = RED_LIMIT_DYNAMICs,  /* RED_LIMIT_DYNAMIC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer dynamic limit for red packets represented as a\n percentage.\n Applicable only if SHARED_LIMITS, COLOR_SPECIFIC_LIMITS, and\n COLOR_SPECIFIC_DYNAMIC_LIMITS are enabled.\n",
    },
    {
        .name  = RESUME_OFFSET_YELLOW_CELLSs,  /* RESUME_OFFSET_YELLOW_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to shared buffer limit used to calculate transmit resume limit\n for yellow packets.\n Transmit resume limit = shared buffer limit - RESUME_OFFSET_CELLS.\n Transmit will resume when transmit resume limit is reached.\n",
    },
    {
        .name  = RESUME_FLOOR_YELLOW_CELLSs,  /* RESUME_FLOOR_YELLOW_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static lower bound of transmit resume limit for yellow packets,\n which will become the operating transmit resume limit if the\n configured transmit resume limit is lower than RESUME_FLOOR_CELLS.\n",
    },
    {
        .name  = RESUME_OFFSET_RED_CELLSs,  /* RESUME_OFFSET_RED_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to shared buffer limit used to calculate transmit resume limit\n for red packets.\n Transmit resume limit = shared buffer limit - RESUME_OFFSET_CELLS.\n Transmit will resume when transmit resume limit is reached.\n",
    },
    {
        .name  = RESUME_FLOOR_RED_CELLSs,  /* RESUME_FLOOR_RED_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static lower bound of transmit resume limit for red packets,\n which will become the operating transmit resume limit if the\n configured transmit resume limit is lower than RESUME_FLOOR_CELLS.\n",
    },
    {
        .name  = TM_EGR_BST_THD_Q_PROFILE_IDs,  /* TM_EGR_BST_THD_Q_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_EGR_BST_THD_Q_PROFILE table index. Provides the profile ID to\n be used for per queue BST threshold selection.\n",
    },
    {
        .name  = TM_EBST_PROFILE_IDs,  /* TM_EBST_PROFILE_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "TM_EBST_PROFILE table index. It provides the index to the\n EBST thresholds profile table.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_THD_UC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE becomes invalid due to one of the following\n reasons:\n The mapping between PORT_ID and the physical port is missing.\n The MIN_GUARANTEE_CELLS exceeds the total available buffer size.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_thd_uc_q_t = {
    .name = TM_THD_UC_Qs, /* TM_THD_UC_Q */
    .flags = 0,
    .fields = 27,
    .field = bcmltd_tm_thd_uc_q_t_fields,
    .desc = "The TM_THD_UC_Q table specifies the buffer threshold configurations for\n unicast queues of the port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_THD_UC_Q_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_thd_uc_q_grp_t_fields[] = {
    {
        .name  = TM_THD_UC_Q_GRP_IDs,  /* TM_THD_UC_Q_GRP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue group ID.",
    },
    {
        .name  = MIN_GUARANTEE_CELLSs,  /* MIN_GUARANTEE_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Minimum guaranteed cells.",
    },
    {
        .name  = USE_DYNAMIC_SHARED_LIMITSs,  /* USE_DYNAMIC_SHARED_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables dynamic threshold calculation for the queues.\n",
    },
    {
        .name  = SHARED_LIMIT_CELLS_STATICs,  /* SHARED_LIMIT_CELLS_STATIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static shared buffer limit in cells. Valid only if\n USE_DYNAMIC_SHARED_LIMITS is disabled.\n",
    },
    {
        .name  = SHARED_LIMIT_DYNAMICs,  /* SHARED_LIMIT_DYNAMIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Dynamic shared buffer limit. Valid only if\n USE_DYNAMIC_SHARED_LIMITS is disabled.\n",
    },
    {
        .name  = RESET_OFFSET_CELLSs,  /* RESET_OFFSET_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to calculate tansmission resume in cells.",
    },
    {
        .name  = RESET_FLOOR_CELLSs,  /* RESET_FLOOR_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static lower bound for transmit in cells.",
    },
    {
        .name  = USE_COLOR_SPECIFIC_DYNAMIC_LIMITSs,  /* USE_COLOR_SPECIFIC_DYNAMIC_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables color specific queue discard shared buffer limits.\n",
    },
    {
        .name  = YELLOW_LIMIT_CELLS_STATICs,  /* YELLOW_LIMIT_CELLS_STATIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer static limits for yellow packets. Valid only if\n USE_DYNAMIC_SHARED_LIMITS is disabled.\n",
    },
    {
        .name  = YELLOW_LIMIT_DYNAMICs,  /* YELLOW_LIMIT_DYNAMIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer dynamic limit for yellow packets. Valid only if\n USE_DYNAMIC_SHARED_LIMITS is enabled.\n",
    },
    {
        .name  = RED_LIMIT_CELLS_STATICs,  /* RED_LIMIT_CELLS_STATIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer static limit for red packets. Valid only if\n USE_DYNAMIC_SHARED_LIMITS is disabled.\n",
    },
    {
        .name  = RED_LIMIT_DYNAMICs,  /* RED_LIMIT_DYNAMIC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Shared buffer dynamic limit for red packets. Valid only if\n USE_DYNAMIC_SHARED_LIMITS is enabled.\n",
    },
    {
        .name  = RESET_OFFSET_YELLOW_CELLSs,  /* RESET_OFFSET_YELLOW_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to calculate transmit resume for yellow packets in cells.",
    },
    {
        .name  = RESET_FLOOR_YELLOW_CELLSs,  /* RESET_FLOOR_YELLOW_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static lower bound for transmit resume for yellow packets in cells.\n",
    },
    {
        .name  = RESET_OFFSET_RED_CELLSs,  /* RESET_OFFSET_RED_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset to calculate transmit resume for red packets in cells.",
    },
    {
        .name  = RESET_FLOOR_RED_CELLSs,  /* RESET_FLOOR_RED_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Static lower bound for transmit resume for red packets in cells.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if the\n mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_thd_uc_q_grp_t = {
    .name = TM_THD_UC_Q_GRPs, /* TM_THD_UC_Q_GRP */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_tm_thd_uc_q_grp_t_fields,
    .desc = "The TM_THD_UC_Q_GRP table specifies the buffer thresholds configurations\n for unicast queue groups.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_THD_UC_Q_TO_UC_Q_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_thd_uc_q_to_uc_q_grp_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = UC_Qs,  /* UC_Q */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID.",
    },
    {
        .name  = TM_THD_UC_Q_GRP_IDs,  /* TM_THD_UC_Q_GRP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into TM_THD_UC_Q_GRP table.",
    },
    {
        .name  = USE_UC_Q_GRP_SHARED_LIMITSs,  /* USE_UC_Q_GRP_SHARED_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables usage of unicast queue group min limits.\n",
    },
    {
        .name  = USE_UC_Q_GRP_MIN_LIMITSs,  /* USE_UC_Q_GRP_MIN_LIMITS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables unicast queue group based shared limits.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the\n entry. The OPERATIONAL_STATE of the entry becomes invalid if the\n mapping between PORT_ID to physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_thd_uc_q_to_uc_q_grp_t = {
    .name = TM_THD_UC_Q_TO_UC_Q_GRPs, /* TM_THD_UC_Q_TO_UC_Q_GRP */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tm_thd_uc_q_to_uc_q_grp_t_fields,
    .desc = "The TM_THD_UC_Q_TO_UC_Q_GRP table specifies the mapping of unicast queue to\n unicast queue group ID.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_TS_TOD.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_ts_tod_t_fields[] = {
    {
        .name  = TOD_SECs,  /* TOD_SEC */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Second portion of ToD.",
    },
    {
        .name  = TOD_NSECs,  /* TOD_NSEC */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Nanosecond portion of ToD.",
    },
    {
        .name  = ADJUSTs,  /* ADJUST */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Adjustment time in nanoseconds.\n Applicable when HW_UPDATE is disabled.\n",
    },
    {
        .name  = HW_UPDATEs,  /* HW_UPDATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable TOD update by hardware.",
    },
    {
        .name  = TOD_SEC_OPERs,  /* TOD_SEC_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational value of second portion of ToD. This is a read-only\n field which reflects the current second value when\n HW_UPDATE is enabled.\n Applicable when HW_UPDATE is enabled.\n",
    },
    {
        .name  = TOD_NSEC_OPERs,  /* TOD_NSEC_OPER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Operational value of nanosecond portion of ToD. This is a read-only\n field which reflects the current nanosecond value when\n HW_UPDATE is enabled.\n Applicable when HW_UPDATE is enabled.\n",
    },
    {
        .name  = ADJUST_OPERs,  /* ADJUST_OPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Operational value of adjustment time in nanoseconds. This is a\n read-only field which reflects the current adjustment time value\n when HW_UPDATE is enabled.\n Applicable when HW_UPDATE is enabled.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TOD_HW_UPDATE_STATE_T_DATA,
        .desc = "Operational state. This is a read-only field which reflects the\n operational state of TOD update. Applicable when HW_UPDATE is\n enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_ts_tod_t = {
    .name = TM_TS_TODs, /* TM_TS_TOD */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_tm_ts_tod_t_fields,
    .desc = "The TM_TS_TOD table specifies Time of Day (ToD) configuration\n for timestamp conversion to UTC format for traffic manager(TM).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_WRED_CNG_NOTIFICATION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_wred_cng_notification_profile_t_fields[] = {
    {
        .name  = TM_WRED_CNG_NOTIFICATION_PROFILE_IDs,  /* TM_WRED_CNG_NOTIFICATION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the WRED congestion notification profile table.",
    },
    {
        .name  = Q_AVGs,  /* Q_AVG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use average queue state for congestion resolution.",
    },
    {
        .name  = Q_MINs,  /* Q_MIN */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use queue minimum state for congestion resolution.",
    },
    {
        .name  = SERVICE_POOLs,  /* SERVICE_POOL */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_SERVICE_POOL_CNG_STATE_T_DATA,
        .desc = "Service pool state for congestion resolution.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to mark/drop the packet.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_wred_cng_notification_profile_t = {
    .name = TM_WRED_CNG_NOTIFICATION_PROFILEs, /* TM_WRED_CNG_NOTIFICATION_PROFILE */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tm_wred_cng_notification_profile_t_fields,
    .desc = "The TM_WRED_CNG_NOTIFICATION_PROFILE table is used to specify whether\n to mark/drop the packet based on various TM states considered for WRED\n congestion resoultion.\n The table is indexed per-unicast queue as specified in\n TM_WRED_UC_Q.MARK_TM_WRED_CNG_NOTIFICATION_PROFILE_ID or\n TM_WRED_UC_Q.DROP_TM_WRED_CNG_NOTIFICATION_PROFILE_ID.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_WRED_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_wred_control_t_fields[] = {
    {
        .name  = NO_REFRESHs,  /* NO_REFRESH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to stop WRED refresh operations. This field takes\n effect only after the previous refresh cycle is completed.\n",
    },
    {
        .name  = JITTERs,  /* JITTER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the range of jitter value to be added to the WRED\n refresh cycle.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_wred_control_t = {
    .name = TM_WRED_CONTROLs, /* TM_WRED_CONTROL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tm_wred_control_t_fields,
    .desc = "The TM_WRED_CONTROL table specifies the global WRED configuration parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_WRED_DROP_CURVE_SET_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_wred_drop_curve_set_profile_t_fields[] = {
    {
        .name  = TM_WRED_DROP_CURVE_SET_PROFILE_IDs,  /* TM_WRED_DROP_CURVE_SET_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index to WRED drop curve set profile table.",
    },
    {
        .name  = RESPONSIVE_GREEN_DROP_MIN_THD_CELLSs,  /* RESPONSIVE_GREEN_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Responsive drop green minimum threshold.",
    },
    {
        .name  = RESPONSIVE_GREEN_DROP_MAX_THD_CELLSs,  /* RESPONSIVE_GREEN_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Responsive drop green maximum threshold.",
    },
    {
        .name  = RESPONSIVE_GREEN_DROP_PERCENTAGEs,  /* RESPONSIVE_GREEN_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Responsive drop green drop percentage.",
    },
    {
        .name  = RESPONSIVE_YELLOW_DROP_MIN_THD_CELLSs,  /* RESPONSIVE_YELLOW_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Responsive drop yellow minimum threshold.",
    },
    {
        .name  = RESPONSIVE_YELLOW_DROP_MAX_THD_CELLSs,  /* RESPONSIVE_YELLOW_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Responsive drop yellow maximum threshold.",
    },
    {
        .name  = RESPONSIVE_YELLOW_DROP_PERCENTAGEs,  /* RESPONSIVE_YELLOW_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Responsive drop yellow drop percentage.",
    },
    {
        .name  = RESPONSIVE_RED_DROP_MIN_THD_CELLSs,  /* RESPONSIVE_RED_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Responsive drop red minimum threshold.",
    },
    {
        .name  = RESPONSIVE_RED_DROP_MAX_THD_CELLSs,  /* RESPONSIVE_RED_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Responsive drop red maximum threshold.",
    },
    {
        .name  = RESPONSIVE_RED_DROP_PERCENTAGEs,  /* RESPONSIVE_RED_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Responsive drop red drop percentage.",
    },
    {
        .name  = NON_RESPONSIVE_GREEN_DROP_MIN_THD_CELLSs,  /* NON_RESPONSIVE_GREEN_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Non-Responsive drop green minimum threshold.",
    },
    {
        .name  = NON_RESPONSIVE_GREEN_DROP_MAX_THD_CELLSs,  /* NON_RESPONSIVE_GREEN_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Non-Responsive drop green maximum threshold.",
    },
    {
        .name  = NON_RESPONSIVE_GREEN_DROP_PERCENTAGEs,  /* NON_RESPONSIVE_GREEN_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Non-Responsive drop green drop percentage.",
    },
    {
        .name  = NON_RESPONSIVE_YELLOW_DROP_MIN_THD_CELLSs,  /* NON_RESPONSIVE_YELLOW_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Non-Responsive drop yellow minimum threshold.",
    },
    {
        .name  = NON_RESPONSIVE_YELLOW_DROP_MAX_THD_CELLSs,  /* NON_RESPONSIVE_YELLOW_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Non-Responsive drop yellow maximum threshold.",
    },
    {
        .name  = NON_RESPONSIVE_YELLOW_DROP_PERCENTAGEs,  /* NON_RESPONSIVE_YELLOW_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Non-Responsive drop yellow drop percentage.",
    },
    {
        .name  = NON_RESPONSIVE_RED_DROP_MIN_THD_CELLSs,  /* NON_RESPONSIVE_RED_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Non-Responsive drop red minimum threshold.",
    },
    {
        .name  = NON_RESPONSIVE_RED_DROP_MAX_THD_CELLSs,  /* NON_RESPONSIVE_RED_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Non-Responsive drop red maximum threshold.",
    },
    {
        .name  = NON_RESPONSIVE_RED_DROP_PERCENTAGEs,  /* NON_RESPONSIVE_RED_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Non-Responsive drop red drop percentage.",
    },
    {
        .name  = ECN_GREEN_DROP_MIN_THD_CELLSs,  /* ECN_GREEN_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN marking green minimum threshold.",
    },
    {
        .name  = ECN_GREEN_DROP_MAX_THD_CELLSs,  /* ECN_GREEN_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN marking green maximum threshold.",
    },
    {
        .name  = ECN_GREEN_DROP_PERCENTAGEs,  /* ECN_GREEN_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "ECN Marking green drop percentage.",
    },
    {
        .name  = ECN_YELLOW_DROP_MIN_THD_CELLSs,  /* ECN_YELLOW_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN marking yellow minimum threshold.",
    },
    {
        .name  = ECN_YELLOW_DROP_MAX_THD_CELLSs,  /* ECN_YELLOW_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN marking yellow maximum threshold.",
    },
    {
        .name  = ECN_YELLOW_DROP_PERCENTAGEs,  /* ECN_YELLOW_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "ECN marking yellow drop percentage.",
    },
    {
        .name  = ECN_RED_DROP_MIN_THD_CELLSs,  /* ECN_RED_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN marking red minimum threshold.",
    },
    {
        .name  = ECN_RED_DROP_MAX_THD_CELLSs,  /* ECN_RED_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "ECN marking red maximum threshold.",
    },
    {
        .name  = ECN_RED_DROP_PERCENTAGEs,  /* ECN_RED_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "ECN marking red drop percentage.",
    },
    {
        .name  = INSTANT_ECN_GREEN_DROP_MIN_THD_CELLSs,  /* INSTANT_ECN_GREEN_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Instantaneous ECN marking green minimum threshold.",
    },
    {
        .name  = INSTANT_ECN_GREEN_DROP_MAX_THD_CELLSs,  /* INSTANT_ECN_GREEN_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Instantaneous ECN marking green maximum threshold.",
    },
    {
        .name  = INSTANT_ECN_GREEN_DROP_PERCENTAGEs,  /* INSTANT_ECN_GREEN_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Instantaneous ECN Marking green drop percentage.",
    },
    {
        .name  = INSTANT_ECN_YELLOW_DROP_MIN_THD_CELLSs,  /* INSTANT_ECN_YELLOW_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Instantaneous ECN marking yellow minimum threshold.",
    },
    {
        .name  = INSTANT_ECN_YELLOW_DROP_MAX_THD_CELLSs,  /* INSTANT_ECN_YELLOW_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Instantaneous ECN marking yellow maximum threshold.",
    },
    {
        .name  = INSTANT_ECN_YELLOW_DROP_PERCENTAGEs,  /* INSTANT_ECN_YELLOW_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Instantaneous ECN marking yellow drop percentage.",
    },
    {
        .name  = INSTANT_ECN_RED_DROP_MIN_THD_CELLSs,  /* INSTANT_ECN_RED_DROP_MIN_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Instantaneous ECN marking red minimum threshold.",
    },
    {
        .name  = INSTANT_ECN_RED_DROP_MAX_THD_CELLSs,  /* INSTANT_ECN_RED_DROP_MAX_THD_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Instantaneous ECN marking red maximum threshold.",
    },
    {
        .name  = INSTANT_ECN_RED_DROP_PERCENTAGEs,  /* INSTANT_ECN_RED_DROP_PERCENTAGE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Instantaneous ECN marking red drop percentage.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_wred_drop_curve_set_profile_t = {
    .name = TM_WRED_DROP_CURVE_SET_PROFILEs, /* TM_WRED_DROP_CURVE_SET_PROFILE */
    .flags = 0,
    .fields = 37,
    .field = bcmltd_tm_wred_drop_curve_set_profile_t_fields,
    .desc = "The TM_WRED_DROP_CURVE_SET_PROFILE table specifies the WRED drop curve\n parameters.\n The profile table contains minimum and maximum thresholds for\n responsive packets such as  TCP, non responsive traffic such as UDP and\n ECN marking for each color (RED, YELLOW and GREEN).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_WRED_PIPE_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_wred_pipe_service_pool_t_fields[] = {
    {
        .name  = TM_PIPEs,  /* TM_PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TM pipe number.",
    },
    {
        .name  = TM_WRED_PIPE_SERVICE_POOL_IDs,  /* TM_WRED_PIPE_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the WRED per-pipe service pool table.",
    },
    {
        .name  = CURRENT_Q_SIZEs,  /* CURRENT_Q_SIZE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to replace the average queue size with the current queue cell\n count when the average queue size becomes greater than the current\n queue cell count.\n",
    },
    {
        .name  = WEIGHTs,  /* WEIGHT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Time scale parameter for computing average queue size",
    },
    {
        .name  = WREDs,  /* WRED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the service pool is capable of WRED.",
    },
    {
        .name  = TM_WRED_TIME_PROFILE_IDs,  /* TM_WRED_TIME_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_WRED_TIME_PROFILE table index. Used to obtain the time for\n average buffer size updates.\n",
    },
    {
        .name  = TM_WRED_DROP_CURVE_SET_PROFILE_IDs,  /* TM_WRED_DROP_CURVE_SET_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_WRED_DROP_CURVE_SET_PROFILE table index. Specifies the WRED\n curve profile associated with the pipe service pool.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_wred_pipe_service_pool_t = {
    .name = TM_WRED_PIPE_SERVICE_POOLs, /* TM_WRED_PIPE_SERVICE_POOL */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_tm_wred_pipe_service_pool_t_fields,
    .desc = "The TM_WRED_PIPE_SERVICE_POOL table specifies WRED configuration on a\n per pipe and per service pool basis.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_WRED_PORT_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_wred_port_service_pool_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_WRED_PORT_SERVICE_POOL_IDs,  /* TM_WRED_PORT_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into WRED per-port service pool table.",
    },
    {
        .name  = CURRENT_Q_SIZEs,  /* CURRENT_Q_SIZE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to replace the average queue size with the current queue cell\n count when the average queue size becomes greater than the current\n queue cell count.\n",
    },
    {
        .name  = WEIGHTs,  /* WEIGHT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Time scale parameter for computing average queue size",
    },
    {
        .name  = WREDs,  /* WRED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the service pool is capable of WRED.",
    },
    {
        .name  = TM_WRED_TIME_PROFILE_IDs,  /* TM_WRED_TIME_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_WRED_TIME_PROFILE table index. Used to obtain the time for\n average buffer size updates.\n",
    },
    {
        .name  = TM_WRED_DROP_CURVE_SET_PROFILE_IDs,  /* TM_WRED_DROP_CURVE_SET_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_WRED_DROP_CURVE_SET_PROFILE table index. Specifies the WRED\n curve profile associated with the port service pool.\n",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE of the entry becomes invalid if the mapping\n between PORT_ID and the physical port is missing.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_wred_port_service_pool_t = {
    .name = TM_WRED_PORT_SERVICE_POOLs, /* TM_WRED_PORT_SERVICE_POOL */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_tm_wred_port_service_pool_t_fields,
    .desc = "The TM_WRED_PORT_SERVICE_POOL table specifies WRED configuration on a per\n port and per service pool basis.\n WRED and ECN configurations are supported only for front-panel\n and management ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_WRED_SERVICE_POOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_wred_service_pool_t_fields[] = {
    {
        .name  = TM_WRED_SERVICE_POOL_IDs,  /* TM_WRED_SERVICE_POOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the WRED service pool table.",
    },
    {
        .name  = CURRENT_Q_SIZEs,  /* CURRENT_Q_SIZE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to replace the average queue size with the current queue cell\n count when the average queue size becomes greater than the current\n queue cell count.\n",
    },
    {
        .name  = WEIGHTs,  /* WEIGHT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Time scale parameter for computing average queue size",
    },
    {
        .name  = WREDs,  /* WRED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the service pool is capable of WRED.",
    },
    {
        .name  = TM_WRED_TIME_PROFILE_IDs,  /* TM_WRED_TIME_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_WRED_TIME_PROFILE table index. Used to obtain the time for\n average buffer size updates.\n",
    },
    {
        .name  = TM_WRED_DROP_CURVE_SET_PROFILE_IDs,  /* TM_WRED_DROP_CURVE_SET_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_WRED_DROP_CURVE_SET_PROFILE table index. Specifies the WRED\n curve profile associated with the service pool.\n",
    },
    {
        .name  = HIGH_CNG_LIMIT_CELLSs,  /* HIGH_CNG_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "High congestion limit in cells.",
    },
    {
        .name  = LOW_CNG_LIMIT_CELLSs,  /* LOW_CNG_LIMIT_CELLS */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Low congestion limit in cells.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_wred_service_pool_t = {
    .name = TM_WRED_SERVICE_POOLs, /* TM_WRED_SERVICE_POOL */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_tm_wred_service_pool_t_fields,
    .desc = "The TM_WRED_SERVICE_POOL table specifies the WRED configuration for global\n service pools.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_WRED_TIME_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_wred_time_profile_t_fields[] = {
    {
        .name  = TM_WRED_TIME_PROFILE_IDs,  /* TM_WRED_TIME_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the WRED time profile table.",
    },
    {
        .name  = TIME_DOMAINs,  /* TIME_DOMAIN */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Time domain values.",
    },
};
const bcmltd_table_rep_t bcmltd_tm_wred_time_profile_t = {
    .name = TM_WRED_TIME_PROFILEs, /* TM_WRED_TIME_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tm_wred_time_profile_t_fields,
    .desc = "The TM_WRED_TIME_PROFILE table determines the time domain for average\n buffer size calculations from one of the four profiles.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tm/TM_WRED_UC_Q.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include <bcmltd/chip/bcmltd_common_enumpool.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tm_wred_uc_q_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port ID.",
    },
    {
        .name  = TM_UC_Q_IDs,  /* TM_UC_Q_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Unicast queue ID.",
    },
    {
        .name  = WEIGHTs,  /* WEIGHT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Time scale parameter for computing average queue size.",
    },
    {
        .name  = CURRENT_Q_SIZEs,  /* CURRENT_Q_SIZE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to replace the average queue size with the current queue cell\n count when the average queue size becomes greater than the queue\n cell count.\n",
    },
    {
        .name  = WREDs,  /* WRED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate the queue is capable of WRED.",
    },
    {
        .name  = ECNs,  /* ECN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the queue is capable of ECN marking.\n Applicable only if WRED is enabled.\n",
    },
    {
        .name  = ECN_MODEs,  /* ECN_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_WRED_ECN_MODE_T_DATA,
        .desc = "ECN marking mode. Applicable only if ECN is enabled.",
    },
    {
        .name  = TM_WRED_TIME_PROFILE_IDs,  /* TM_WRED_TIME_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_WRED_TIME_PROFILE table index. Used to obtain the time for\n average buffer size updates.\n",
    },
    {
        .name  = MARK_TM_WRED_CNG_NOTIFICATION_PROFILE_IDs,  /* MARK_TM_WRED_CNG_NOTIFICATION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_WRED_CNG_NOTIFICATION_PROFILE table index. The profile entry\n indexed by this field is used for marking the packets.\n",
    },
    {
        .name  = DROP_TM_WRED_CNG_NOTIFICATION_PROFILE_IDs,  /* DROP_TM_WRED_CNG_NOTIFICATION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_WRED_CNG_NOTIFICATION_PROFILE table index. The profile entry\n indexed by this field is used for dropping the packets.\n",
    },
    {
        .name  = TM_WRED_DROP_CURVE_SET_PROFILE_IDs,  /* TM_WRED_DROP_CURVE_SET_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TM_WRED_DROP_CURVE_SET_PROFILE table index.",
    },
    {
        .name  = OPERATIONAL_STATEs,  /* OPERATIONAL_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .edata = BCMLTD_COMMON_TM_PORT_UC_Q_ENTRY_STATE_T_DATA,
        .desc = "Read-only field which reflects the operational state of the entry.\n The OPERATIONAL_STATE of the entry becomes invalid if the mapping\n between PORT_ID and the physical port is missing or TM_UC_Q_ID exceeds\n TM_DEVICE_INFO.NUM_Q - TM_SCHEDULER_CONFIG.NUM_MC_Q.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tm_wred_uc_q_t = {
    .name = TM_WRED_UC_Qs, /* TM_WRED_UC_Q */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_tm_wred_uc_q_t_fields,
    .desc = "The TM_WRED_UC_Q table specifies WRED configuration parameters for\n unicast queues. WRED and ECN configurations are supported only for\n front-panel and management ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_control_t_fields[] = {
    {
        .name  = TNL_ERR_TO_CPUs,  /* TNL_ERR_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packets with tunnel error to the CPU.",
    },
    {
        .name  = MPLS_GAL_LABEL_EXPOSED_TO_CPUs,  /* MPLS_GAL_LABEL_EXPOSED_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MPLS packets with a generic associated channel\n (GAL) label exposed resulting in packet drop to the CPU.\n",
    },
    {
        .name  = MPLS_ILLEGAL_RESERVED_LABEL_TO_CPUs,  /* MPLS_ILLEGAL_RESERVED_LABEL_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MPLS packet exposing an illegal\n reserved label to the CPU.\n",
    },
    {
        .name  = MPLS_INVALID_ACTION_TO_CPUs,  /* MPLS_INVALID_ACTION_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MPLS packets with bottom of stack (BOS)\n actions conflicting\n TNL_MPLS_DECAP.NON_BOS_ACTIONS or\n TNL_MPLS_DECAP.BOS_ACTIONS configuration to the CPU.\n",
    },
    {
        .name  = MPLS_INVALID_PAYLOAD_TO_CPUs,  /* MPLS_INVALID_PAYLOAD_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MPLS packets with IPv4 payload but\n TNL_MPLS_DECAP.IPV4_PAYLOAD not configured or\n MPLS packets with IPv6 payload but TNL_MPLS_DECAP.IPV6_PAYLOAD\n not configured to the CPU.\n",
    },
    {
        .name  = MPLS_LABEL_MISS_TO_CPUs,  /* MPLS_LABEL_MISS_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MPLS packets with TNL_MPLS_DECAP table\n miss to the CPU.\n",
    },
    {
        .name  = MPLS_RAL_LABEL_EXPOSED_TO_CPUs,  /* MPLS_RAL_LABEL_EXPOSED_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MPLS packets with a router alert label (RAL)\n exposed resulting in packet drop to the CPU.\n",
    },
    {
        .name  = MPLS_TTL_CHECK_FAILs,  /* MPLS_TTL_CHECK_FAIL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MPLS packets with time-to-live (TTL)\n value 0 or 1 to the CPU.\n",
    },
    {
        .name  = MPLS_PW_ACH_TO_CPUs,  /* MPLS_PW_ACH_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MPLS packets with pseudowire (PW) generic associated\n channel header (ACH) to the CPU.\n",
    },
    {
        .name  = MPLS_UNKNOWN_ACH_TYPE_TO_CPUs,  /* MPLS_UNKNOWN_ACH_TYPE_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MPLS packets with an unknown generic associated\n channel header type to the CPU.\n",
    },
    {
        .name  = MPLS_UNKNOWN_ACH_VERSION_TO_CPUs,  /* MPLS_UNKNOWN_ACH_VERSION_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy MPLS packets with an unknown generic associated\n channel header version to the CPU.\n",
    },
    {
        .name  = MPLS_ECMP_LB_HASH_FLOW_BASEDs,  /* MPLS_ECMP_LB_HASH_FLOW_BASED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use the flow based hash output selection mechanism in\n ECMP load balancing hash of single level or underlay ECMP group\n for MPLS packets.\n",
    },
    {
        .name  = MPLS_OVERLAY_ECMP_LB_HASH_FLOW_BASEDs,  /* MPLS_OVERLAY_ECMP_LB_HASH_FLOW_BASED */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use the flow based hash output selection mechanism in\n ECMP load balancing hash of overlay ECMP group for MPLS packets.\n",
    },
    {
        .name  = PROT_NHOP_OFFSETs,  /* PROT_NHOP_OFFSET */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies the offset of the protection next hop\n from the primary next hop.\n",
    },
    {
        .name  = PW_DECAP_SEQUENCE_NUMBER_RANGEs,  /* PW_DECAP_SEQUENCE_NUMBER_RANGE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Terminating pseudowire sequence number range. This field\n specifies the allowed receive sequence number window.\n\n If the packet sequence number is greater than the expected\n sequence number and the packet sequence number minus the\n expected sequence number is less than the specified range value,\n the packet passes the sequence number check. Otherwise, it fails\n the check.\n\n If the packet sequence number is less than the expected\n sequence number and the expected sequence number minus the\n packet sequence number is greater than or equal to the specified\n range value, the packet passes the sequence number check.\n Otherwise, it fails the check.\n",
    },
    {
        .name  = LABEL_FWD_CTRLs,  /* LABEL_FWD_CTRL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MPLS label forward control.",
    },
    {
        .name  = LABEL_FWD_CTRL_MASKs,  /* LABEL_FWD_CTRL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MPLS label forward control mask.",
    },
    {
        .name  = ELI_LABELs,  /* ELI_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Specifies ELI label value.",
    },
    {
        .name  = GAL_LABELs,  /* GAL_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Specifies GAL label value.",
    },
    {
        .name  = CW_LOWER_CLEARs,  /* CW_LOWER_CLEAR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to clear the lower control word.",
    },
    {
        .name  = CW_UPPER_CLEARs,  /* CW_UPPER_CLEAR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to clear the upper control word.",
    },
    {
        .name  = LABEL_REORDERs,  /* LABEL_REORDER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable the MPLS label reorder from label 0-4 to label 5-7.",
    },
    {
        .name  = LOOPBACK_PORTSs,  /* LOOPBACK_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Loopback port bitmap.",
    },
    {
        .name  = LOOPBACK_PORTS_MASK_TARGETs,  /* LOOPBACK_PORTS_MASK_TARGET */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Loopback port mask target.",
    },
    {
        .name  = LOOPBACK_PORTS_MASK_ACTIONs,  /* LOOPBACK_PORTS_MASK_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Loopback port mask action.",
    },
    {
        .name  = SHARE_FRAGMENT_IDs,  /* SHARE_FRAGMENT_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to share TNL_ENCAP_FRAGMENT.FRAGMENT_ID with the table\n index TNL_ENCAP_FRAGMENT_ID 0 for all IPv4 tunnels.\n",
    },
    {
        .name  = FRAGMENT_ID_MASKs,  /* FRAGMENT_ID_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask value inverted and applied to the fragment ID before adding it\n into the IPv4 tunneled packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_control_t = {
    .name = TNL_CONTROLs, /* TNL_CONTROL */
    .flags = 0,
    .fields = 27,
    .field = bcmltd_tnl_control_t_fields,
    .desc = "The TNL_CONTROL table provides device level tunnel controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_DECAP_PORT_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_decap_port_profile_t_fields[] = {
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_DECAP_PORT_PROFILE table.",
    },
    {
        .name  = DECAP_PORTSs,  /* DECAP_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to set the specified port as a tunnel end point.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_decap_port_profile_t = {
    .name = TNL_DECAP_PORT_PROFILEs, /* TNL_DECAP_PORT_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tnl_decap_port_profile_t_fields,
    .desc = "The TNL_DECAP_PORT_PROFILE table is used to specify the ports that can be\n tunnel endpoints.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_DEFAULT_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_default_policy_t_fields[] = {
    {
        .name  = POLICY_CMD_SELECTs,  /* POLICY_CMD_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 12,
        .desc = "Policy command result selection.",
    },
    {
        .name  = POLICY_OBJ_SELECTs,  /* POLICY_OBJ_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 6,
        .desc = "Policy object result selection.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_default_policy_t = {
    .name = TNL_DEFAULT_POLICYs, /* TNL_DEFAULT_POLICY */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tnl_default_policy_t_fields,
    .desc = "The TNL_DEFAULT_POLICY table is used to specify\n the default policy selection for the NON-MPLS flow.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_ENCAP_FRAGMENT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_encap_fragment_t_fields[] = {
    {
        .name  = TNL_ENCAP_FRAGMENT_IDs,  /* TNL_ENCAP_FRAGMENT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_ENCAP_FRAGMENT table. It\n comes from L3_EIF.TNL_IPV4_ENCAP_INDEX when\n TNL_CONTROL.SHARE_FRAGMENT_ID is disabled.\n",
    },
    {
        .name  = FRAGMENT_IDs,  /* FRAGMENT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Real-time fragment ID value for the next outgoing IPv4\n tunneled packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_encap_fragment_t = {
    .name = TNL_ENCAP_FRAGMENTs, /* TNL_ENCAP_FRAGMENT */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tnl_encap_fragment_t_fields,
    .desc = "The logical table TNL_ENCAP_FRAGMENT specifies the fragment ID\n for the next outgoing IPv4 tunneled packet. The fragment ID is\n auto-increased by hardware.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_ENCAP_SEQUENCE_NUMBER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_encap_sequence_number_t_fields[] = {
    {
        .name  = TNL_ENCAP_SEQUENCE_NUMBER_IDs,  /* TNL_ENCAP_SEQUENCE_NUMBER_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel sequence number ID.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = SEQUENCE_NUMBERs,  /* SEQUENCE_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Real-time sequence number value for the next outgoing\n tunneled packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_encap_sequence_number_t = {
    .name = TNL_ENCAP_SEQUENCE_NUMBERs, /* TNL_ENCAP_SEQUENCE_NUMBER */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tnl_encap_sequence_number_t_fields,
    .desc = "The TNL_ENCAP_SEQUENCE_NUMBER table specifies the sequence number\n value for the next outgoing tunneled packet. The sequence number\n can also be auto-updated by hardware when\n TNL_ENCAP_SEQUENCE_PROFILE.SEQUENCE_UPDATE is enabled.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_ENCAP_SEQUENCE_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_encap_sequence_profile_t_fields[] = {
    {
        .name  = TNL_ENCAP_SEQUENCE_PROFILE_IDs,  /* TNL_ENCAP_SEQUENCE_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Tunnel sequence profile ID.",
    },
    {
        .name  = SEQUENCEs,  /* SEQUENCE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to apply sequence number processing.",
    },
    {
        .name  = SEQUENCE_UPDATEs,  /* SEQUENCE_UPDATE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to write back updated counter value to the\n TNL_ENCAP_SEQUENCE_NUMBER table.\n",
    },
    {
        .name  = INCREMENTs,  /* INCREMENT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Sequence number increment value.",
    },
    {
        .name  = RESERVED_VALUEs,  /* RESERVED_VALUE */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Sequence number reserved value.\n This value is skipped during counter increment.\n",
    },
    {
        .name  = MASKs,  /* MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Sequence number value mask. A bit value of 1\n indicates the corresponding bit of the sequence number\n is to be masked.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_encap_sequence_profile_t = {
    .name = TNL_ENCAP_SEQUENCE_PROFILEs, /* TNL_ENCAP_SEQUENCE_PROFILE */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tnl_encap_sequence_profile_t_fields,
    .desc = "The TNL_ENCAP_SEQUENCE_PROFILE table specifies controls to generate\n sequence numbers for outgoing tunneled packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_IPV4_DECAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_ipv4_decap_t_fields[] = {
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Source IP address of the tunnel.",
    },
    {
        .name  = SRC_IPV4_MASKs,  /* SRC_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Source IP address mask of the tunnel.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Destination IP address of the tunnel.",
    },
    {
        .name  = DST_IPV4_MASKs,  /* DST_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Destination IP address mask of the tunnel.",
    },
    {
        .name  = IP_PROTOCOLs,  /* IP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP protocol used in data portion of the tunnel.",
    },
    {
        .name  = IP_PROTOCOL_MASKs,  /* IP_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP protocol mask used in data portion of the tunnel.",
    },
    {
        .name  = SRC_L4_PORTs,  /* SRC_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 source port.",
    },
    {
        .name  = SRC_L4_PORT_MASKs,  /* SRC_L4_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 source port mask.",
    },
    {
        .name  = DST_L4_PORTs,  /* DST_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 destination port.",
    },
    {
        .name  = DST_L4_PORT_MASKs,  /* DST_L4_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 destination port mask.",
    },
    {
        .name  = IPV6_GRE_PAYLOADs,  /* IPV6_GRE_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 GRE payload.",
    },
    {
        .name  = IPV4_GRE_PAYLOADs,  /* IPV4_GRE_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 GRE payload.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = TYPEs,  /* TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies L3 tunnel type.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies whether the tunnel is an auto or configured one.",
    },
    {
        .name  = UDP_TYPEs,  /* UDP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies UDP tunnel type. Applicable if tunneled protocol is UDP.",
    },
    {
        .name  = TNL_HDR_DSCP_FOR_PHBs,  /* TNL_HDR_DSCP_FOR_PHB */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's DSCP value for PHB.",
    },
    {
        .name  = USE_TNL_HDR_TTLs,  /* USE_TNL_HDR_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = IGNORE_UDP_CHECKSUMs,  /* IGNORE_UDP_CHECKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to ignore the UDP checksum for tunneled UDP packets.",
    },
    {
        .name  = CTRL_PKTS_TO_CPUs,  /* CTRL_PKTS_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy control packets to the CPU.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = DECAP_PORTSs,  /* DECAP_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to set the specified port as a tunnel end point.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_ipv4_decap_t = {
    .name = TNL_IPV4_DECAPs, /* TNL_IPV4_DECAP */
    .flags = BCMLTD_TABLE_F_TYPE_MAPPED,
    .fields = 29,
    .field = bcmltd_tnl_ipv4_decap_t_fields,
    .desc = "The TNL_IPV4_DECAP table is used to specify IPv4 tunnel termination\n parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_IPV4_DECAP_EM.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_ipv4_decap_em_t_fields[] = {
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Source IP address of the tunnel.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Destination IP address of the tunnel.",
    },
    {
        .name  = IP_PROTOCOLs,  /* IP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP protocol used in data portion of the tunnel.",
    },
    {
        .name  = IPV6_GRE_PAYLOADs,  /* IPV6_GRE_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 GRE payload.",
    },
    {
        .name  = IPV4_GRE_PAYLOADs,  /* IPV4_GRE_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 GRE payload.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = TYPEs,  /* TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies L3 tunnel type.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies whether the tunnel is an auto or configured one.",
    },
    {
        .name  = TNL_HDR_DSCP_FOR_PHBs,  /* TNL_HDR_DSCP_FOR_PHB */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's DSCP value for PHB.",
    },
    {
        .name  = USE_TNL_HDR_TTLs,  /* USE_TNL_HDR_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_ipv4_decap_em_t = {
    .name = TNL_IPV4_DECAP_EMs, /* TNL_IPV4_DECAP_EM */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 16,
    .field = bcmltd_tnl_ipv4_decap_em_t_fields,
    .desc = "The TNL_IPV4_DECAP_EM table is used to specify IPv4 tunnel\n termination parameters for exact match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_IPV4_DECAP_EM_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_ipv4_decap_em_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = SRC_IPV4_MASKs,  /* SRC_IPV4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IP address mask of the tunnel.",
    },
    {
        .name  = DST_IPV4_MASKs,  /* DST_IPV4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IP address mask of the tunnel.",
    },
    {
        .name  = IP_PROTOCOL_MASKs,  /* IP_PROTOCOL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IP protocol mask used in data portion of the tunnel.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_ipv4_decap_em_key_mask_t = {
    .name = TNL_IPV4_DECAP_EM_KEY_MASKs, /* TNL_IPV4_DECAP_EM_KEY_MASK */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tnl_ipv4_decap_em_key_mask_t_fields,
    .desc = "The TNL_IPV4_DECAP_EM_KEY_MASK table is used to control and specify\n the global key mask of TNL_IPV4_DECAP_EM for IPv4 tunnel termination.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_IPV4_ENCAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_ipv4_encap_t_fields[] = {
    {
        .name  = TNL_IPV4_ENCAP_IDs,  /* TNL_IPV4_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_IPV4_ENCAP table.",
    },
    {
        .name  = ENCAP_INDEXs,  /* ENCAP_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Read-only field which reflects the hardware\n index allocated to this tunnel entry. This field\n is used in L3_EIF.TNL_IPV4_ENCAP_INDEX.\n",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address of the packet.",
    },
    {
        .name  = SRC_IPV4s,  /* SRC_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Source IP address of the packet.",
    },
    {
        .name  = DST_IPV4s,  /* DST_IPV4 */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Destination IP address of the packet.",
    },
    {
        .name  = TNL_TYPEs,  /* TNL_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Tunnel type for IPv4 tunnel.",
    },
    {
        .name  = TNL_TTLs,  /* TNL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TTL value for tunnel IP header.",
    },
    {
        .name  = IPV4_IN_IPV4_DF_MODEs,  /* IPV4_IN_IPV4_DF_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the construction for DF (Don't Fragment)\n field for an IPv4 packet.\n",
    },
    {
        .name  = IPV6_IN_IPV4_DF_MODEs,  /* IPV6_IN_IPV4_DF_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the construction for DF (Don't Fragment)\n field for an IPv6 packet.\n",
    },
    {
        .name  = PHB_EGR_DSCP_ACTIONs,  /* PHB_EGR_DSCP_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies which DSCP to choose to put in the outer tunnel header.",
    },
    {
        .name  = PHB_EGR_IP_INT_PRI_TO_DSCP_IDs,  /* PHB_EGR_IP_INT_PRI_TO_DSCP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "PHB_EGR_IP_INT_PRI_TO_DSCP logical table index. Applicable\n only when PHB_EGR_DSCP_ACTION == MAP.\n",
    },
    {
        .name  = DSCPs,  /* DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "DSCP value to set in the tunnel. Applicable\n only when PHB_EGR_DSCP_ACTION == FIXED.\n",
    },
    {
        .name  = SRC_L4_PORTs,  /* SRC_L4_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 source port.",
    },
    {
        .name  = DST_L4_PORTs,  /* DST_L4_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 destination port.",
    },
    {
        .name  = ECN_TNL_ENCAP_IDs,  /* ECN_TNL_ENCAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_TNL_ENCAP_IP_PAYLOAD logical table index. Applicable\n when the payload is IP.\n ECN_TNL_ENCAP_NON_IP_PAYLOAD logical table index. Applicable\n when the payload is non-IP.\n",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_ipv4_encap_t = {
    .name = TNL_IPV4_ENCAPs, /* TNL_IPV4_ENCAP */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_tnl_ipv4_encap_t_fields,
    .desc = "The TNL_IPV4_ENCAP table is used to specify IPV4 tunnel parameters\n during encapsulation of packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_IPV6_DECAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_ipv6_decap_t_fields[] = {
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IP address of the tunnel.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IP address of the tunnel.",
    },
    {
        .name  = SRC_IPV6_MASK_UPPERs,  /* SRC_IPV6_MASK_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IP address mask of the tunnel.",
    },
    {
        .name  = SRC_IPV6_MASK_LOWERs,  /* SRC_IPV6_MASK_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IP address mask of the tunnel.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IP address of the tunnel.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IP address of the tunnel.",
    },
    {
        .name  = DST_IPV6_MASK_UPPERs,  /* DST_IPV6_MASK_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IP address mask of the tunnel.",
    },
    {
        .name  = DST_IPV6_MASK_LOWERs,  /* DST_IPV6_MASK_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IP address mask of the tunnel.",
    },
    {
        .name  = IP_PROTOCOLs,  /* IP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP protocol used in data portion of the tunnel.",
    },
    {
        .name  = IP_PROTOCOL_MASKs,  /* IP_PROTOCOL_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP protocol mask used in data portion of the tunnel.",
    },
    {
        .name  = SRC_L4_PORTs,  /* SRC_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 source port.",
    },
    {
        .name  = SRC_L4_PORT_MASKs,  /* SRC_L4_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 source port mask.",
    },
    {
        .name  = DST_L4_PORTs,  /* DST_L4_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 destination port.",
    },
    {
        .name  = DST_L4_PORT_MASKs,  /* DST_L4_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 destination port mask.",
    },
    {
        .name  = IPV6_GRE_PAYLOADs,  /* IPV6_GRE_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 GRE payload.",
    },
    {
        .name  = IPV4_GRE_PAYLOADs,  /* IPV4_GRE_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 GRE payload.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = TYPEs,  /* TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies L3 tunnel type.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies whether the tunnel is an auto or configured one.",
    },
    {
        .name  = UDP_TYPEs,  /* UDP_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies UDP tunnel type. Applicable if tunneled protocol is UDP.",
    },
    {
        .name  = TNL_HDR_DSCP_FOR_PHBs,  /* TNL_HDR_DSCP_FOR_PHB */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's DSCP value for PHB.",
    },
    {
        .name  = USE_TNL_HDR_HOP_LIMITs,  /* USE_TNL_HDR_HOP_LIMIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's hop limit value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = IGNORE_UDP_CHECKSUMs,  /* IGNORE_UDP_CHECKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to ignore the UDP checksum for tunneled UDP packets.",
    },
    {
        .name  = CTRL_PKTS_TO_CPUs,  /* CTRL_PKTS_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy control packets to the CPU.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = DECAP_PORTSs,  /* DECAP_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Enable to set the specified port as a tunnel end point.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_ipv6_decap_t = {
    .name = TNL_IPV6_DECAPs, /* TNL_IPV6_DECAP */
    .flags = BCMLTD_TABLE_F_TYPE_MAPPED,
    .fields = 33,
    .field = bcmltd_tnl_ipv6_decap_t_fields,
    .desc = "The TNL_IPV6_DECAP table is used to specify IPv6 tunnel termination\n parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_IPV6_DECAP_EM.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_ipv6_decap_em_t_fields[] = {
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IP address of the tunnel.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Source IP address of the tunnel.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IP address of the tunnel.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Destination IP address of the tunnel.",
    },
    {
        .name  = IP_PROTOCOLs,  /* IP_PROTOCOL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "IP protocol used in data portion of the tunnel.",
    },
    {
        .name  = IPV6_GRE_PAYLOADs,  /* IPV6_GRE_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 GRE payload.",
    },
    {
        .name  = IPV4_GRE_PAYLOADs,  /* IPV4_GRE_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 GRE payload.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = TYPEs,  /* TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies L3 tunnel type.",
    },
    {
        .name  = MODEs,  /* MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies whether the tunnel is an auto or configured one.",
    },
    {
        .name  = TNL_HDR_DSCP_FOR_PHBs,  /* TNL_HDR_DSCP_FOR_PHB */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's DSCP value for PHB.",
    },
    {
        .name  = USE_TNL_HDR_HOP_LIMITs,  /* USE_TNL_HDR_HOP_LIMIT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's hop limit value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_ipv6_decap_em_t = {
    .name = TNL_IPV6_DECAP_EMs, /* TNL_IPV6_DECAP_EM */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 18,
    .field = bcmltd_tnl_ipv6_decap_em_t_fields,
    .desc = "The TNL_IPV6_DECAP table is used to specify IPv6 tunnel\n termination parameters for exact match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_IPV6_DECAP_EM_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_ipv6_decap_em_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = SRC_IPV6_MASK_UPPERs,  /* SRC_IPV6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IP address mask of the tunnel.",
    },
    {
        .name  = SRC_IPV6_MASK_LOWERs,  /* SRC_IPV6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IP address mask of the tunnel.",
    },
    {
        .name  = DST_IPV6_MASK_UPPERs,  /* DST_IPV6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IP address mask of the tunnel.",
    },
    {
        .name  = DST_IPV6_MASK_LOWERs,  /* DST_IPV6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IP address mask of the tunnel.",
    },
    {
        .name  = IP_PROTOCOL_MASKs,  /* IP_PROTOCOL_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IP protocol mask used in data portion of the tunnel.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_ipv6_decap_em_key_mask_t = {
    .name = TNL_IPV6_DECAP_EM_KEY_MASKs, /* TNL_IPV6_DECAP_EM_KEY_MASK */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tnl_ipv6_decap_em_key_mask_t_fields,
    .desc = "The TNL_IPV6_DECAP_EM_KEY_MASK table is used to control and specify\n the global key mask of TNL_IPV6_DECAP_EM for IPv6 tunnel termination.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_IPV6_ENCAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_ipv6_encap_t_fields[] = {
    {
        .name  = TNL_IPV6_ENCAP_IDs,  /* TNL_IPV6_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_IPV6_ENCAP table.",
    },
    {
        .name  = ENCAP_INDEXs,  /* ENCAP_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Read-only field which reflects the hardware\n index allocated to this tunnel entry. This field\n is used in L3_EIF.TNL_IPV6_ENCAP_INDEX.\n",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address of the packet.",
    },
    {
        .name  = SRC_MACs,  /* SRC_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Source MAC address of the packet.",
    },
    {
        .name  = SRC_IPV6_UPPERs,  /* SRC_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IP address of the packet.",
    },
    {
        .name  = SRC_IPV6_LOWERs,  /* SRC_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Source IP address of the packet.",
    },
    {
        .name  = DST_IPV6_UPPERs,  /* DST_IPV6_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IP address of the packet.",
    },
    {
        .name  = DST_IPV6_LOWERs,  /* DST_IPV6_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Destination IP address of the packet.",
    },
    {
        .name  = TNL_TYPEs,  /* TNL_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Tunnel type for IPv6 tunnel.",
    },
    {
        .name  = HOP_LIMITs,  /* HOP_LIMIT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hop limit value for tunnel IPv6 header.",
    },
    {
        .name  = FLOW_LABEL_SELECTs,  /* FLOW_LABEL_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify how to select the flow label in IPv6 tunnel header.",
    },
    {
        .name  = FLOW_LABELs,  /* FLOW_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Flow label for IPv6 tunnel header. Applicable only\n when FLOW_LABEL_SELECT == FLOW_LABEL.\n",
    },
    {
        .name  = PHB_EGR_DSCP_ACTIONs,  /* PHB_EGR_DSCP_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies which DSCP to choose to put in the outer tunnel header.",
    },
    {
        .name  = PHB_EGR_IP_INT_PRI_TO_DSCP_IDs,  /* PHB_EGR_IP_INT_PRI_TO_DSCP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "PHB_EGR_IP_INT_PRI_TO_DSCP logical table index. Applicable only\n when PHB_EGR_DSCP_ACTION == MAP.\n",
    },
    {
        .name  = DSCPs,  /* DSCP */
        .flags = 0,
        .width = 6,
        .depth = 0,
        .desc = "DSCP value to set in the tunnel. Applicable only\n when PHB_EGR_DSCP_ACTION == FIXED.\n",
    },
    {
        .name  = SRC_L4_PORTs,  /* SRC_L4_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 source port.",
    },
    {
        .name  = DST_L4_PORTs,  /* DST_L4_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 destination port.",
    },
    {
        .name  = ECN_TNL_ENCAP_IDs,  /* ECN_TNL_ENCAP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_TNL_ENCAP_IP_PAYLOAD logical table index. Applicable\n when the payload is IP.\n ECN_TNL_ENCAP_NON_IP_PAYLOAD logical table index. Applicable\n when the payload is non-IP.\n",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_ipv6_encap_t = {
    .name = TNL_IPV6_ENCAPs, /* TNL_IPV6_ENCAP */
    .flags = 0,
    .fields = 19,
    .field = bcmltd_tnl_ipv6_encap_t_fields,
    .desc = "The TNL_IPV6_ENCAP table is used to specify IPV6 tunnel parameters\n during encapsulation of packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_ADAPT_VFI.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_adapt_vfi_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance.",
    },
    {
        .name  = VNIDs,  /* VNID */
        .flags = 0,
        .width = 24,
        .depth = 0,
        .desc = "VXLAN network identifier.",
    },
    {
        .name  = VLAN_TAG_PRESENT_ACTIONs,  /* VLAN_TAG_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 tag action if the tag is present.",
    },
    {
        .name  = VLAN_TAG_NOT_PRESENT_ACTIONs,  /* VLAN_TAG_NOT_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 tag action if the tag is not present.",
    },
    {
        .name  = L2_OPAQUE_TAG_PRESENT_ACTIONs,  /* L2_OPAQUE_TAG_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 opaque tag action if the tag is present.",
    },
    {
        .name  = L2_OPAQUE_TAG_NOT_PRESENT_ACTIONs,  /* L2_OPAQUE_TAG_NOT_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 opaque tag action if the tag is not present.",
    },
    {
        .name  = IS_PHB_MAP_IDs,  /* IS_PHB_MAP_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate a PHB map table index is used.",
    },
    {
        .name  = REMARK_CFIs,  /* REMARK_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable remarking CFI.",
    },
    {
        .name  = OCFIs,  /* OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI. Applicable only if IS_PHB_MAP_ID is disabled.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority. Applicable only if IS_PHB_MAP_ID\n is disabled.\n",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_OTAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_OTAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_EGR_L2_INT_PRI_TO_OTAG logical table.\n Applicable only if IS_PHB_MAP_ID is enabled.\n",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = VLAN_OUTER_TPID_IDs,  /* VLAN_OUTER_TPID_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the VLAN_OUTER_TPID logical table.",
    },
    {
        .name  = CTR_EGR_EFLEX_OBJECTs,  /* CTR_EGR_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter object.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_adapt_vfi_t = {
    .name = TNL_L2_VXLAN_ADAPT_VFIs, /* TNL_L2_VXLAN_ADAPT_VFI */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 15,
    .field = bcmltd_tnl_l2_vxlan_adapt_vfi_t_fields,
    .desc = "The TNL_L2_VXLAN_ADAPT_VFI table derives VNID and payload tag actions based\n on virtual forwarding instance (VFI) during egress adaptation lookup.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_ADAPT_VFI_DVP_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_adapt_vfi_dvp_grp_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance.",
    },
    {
        .name  = DVP_GRPs,  /* DVP_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Destination virtual port group.",
    },
    {
        .name  = VNIDs,  /* VNID */
        .flags = 0,
        .width = 24,
        .depth = 0,
        .desc = "VXLAN network identifier.",
    },
    {
        .name  = VLAN_TAG_PRESENT_ACTIONs,  /* VLAN_TAG_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 tag action if the tag is present.",
    },
    {
        .name  = VLAN_TAG_NOT_PRESENT_ACTIONs,  /* VLAN_TAG_NOT_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 tag action if the tag is not present.",
    },
    {
        .name  = L2_OPAQUE_TAG_PRESENT_ACTIONs,  /* L2_OPAQUE_TAG_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 opaque tag action if the tag is present.",
    },
    {
        .name  = L2_OPAQUE_TAG_NOT_PRESENT_ACTIONs,  /* L2_OPAQUE_TAG_NOT_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 opaque tag action if the tag is not present.",
    },
    {
        .name  = IS_PHB_MAP_IDs,  /* IS_PHB_MAP_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate a PHB map table index is used.",
    },
    {
        .name  = REMARK_CFIs,  /* REMARK_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable remarking CFI.",
    },
    {
        .name  = OCFIs,  /* OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI. Applicable only if IS_PHB_MAP_ID is disabled.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority. Applicable only if IS_PHB_MAP_ID\n is disabled.\n",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_OTAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_OTAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the PHB_EGR_L2_INT_PRI_TO_OTAG logical table.\n Applicable only if IS_PHB_MAP_ID is enabled.\n",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = VLAN_OUTER_TPID_IDs,  /* VLAN_OUTER_TPID_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into the VLAN_OUTER_TPID logical table.",
    },
    {
        .name  = CTR_EGR_EFLEX_OBJECTs,  /* CTR_EGR_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter object.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_adapt_vfi_dvp_grp_t = {
    .name = TNL_L2_VXLAN_ADAPT_VFI_DVP_GRPs, /* TNL_L2_VXLAN_ADAPT_VFI_DVP_GRP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 16,
    .field = bcmltd_tnl_l2_vxlan_adapt_vfi_dvp_grp_t_fields,
    .desc = "The TNL_L2_VXLAN_ADAPT_VFI_DVP_GRP table derives VNID and payload tag\n actions based on virtual forwarding instance (VFI) and destination\n virtual port group during egress adaptation lookup.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_ADAPT_VFI_DVP_GRP_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_adapt_vfi_dvp_grp_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = VFI_ID_MASKs,  /* VFI_ID_MASK */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance mask.",
    },
    {
        .name  = DVP_GRP_MASKs,  /* DVP_GRP_MASK */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Destination virtual port group mask .",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_adapt_vfi_dvp_grp_key_mask_t = {
    .name = TNL_L2_VXLAN_ADAPT_VFI_DVP_GRP_KEY_MASKs, /* TNL_L2_VXLAN_ADAPT_VFI_DVP_GRP_KEY_MASK */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tnl_l2_vxlan_adapt_vfi_dvp_grp_key_mask_t_fields,
    .desc = "The TNL_L2_VXLAN_ADAPT_VFI_DVP_GRP_KEY_MASK table specifies the global\n key mask for TNL_L2_VXLAN_ADAPT_VFI_DVP_GRP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_ADAPT_VFI_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_adapt_vfi_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = VFI_ID_MASKs,  /* VFI_ID_MASK */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance mask.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_adapt_vfi_key_mask_t = {
    .name = TNL_L2_VXLAN_ADAPT_VFI_KEY_MASKs, /* TNL_L2_VXLAN_ADAPT_VFI_KEY_MASK */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tnl_l2_vxlan_adapt_vfi_key_mask_t_fields,
    .desc = "The TNL_L2_VXLAN_ADAPT_VFI_KEY_MASK table specifies the global key mask for\n TNL_L2_VXLAN_ADAPT_VFI.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_control_t_fields[] = {
    {
        .name  = DECAP_DST_L4_PORTs,  /* DECAP_DST_L4_PORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Value to match against the layer 4 destination port in the\n UDP header to identify VXLAN packets during VXLAN tunnel\n decapsulation.\n",
    },
    {
        .name  = DECAP_FLAGSs,  /* DECAP_FLAGS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to match against the FLAGS field in the VXLAN header\n during VXLAN tunnel decapsulation.\n",
    },
    {
        .name  = DECAP_FLAGS_MASKs,  /* DECAP_FLAGS_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask value to be applied to the FLAGS field in the VXLAN header\n before matching with DECAP_FLAGS.\n",
    },
    {
        .name  = DECAP_FLAGS_MISMATCH_DROPs,  /* DECAP_FLAGS_MISMATCH_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop VXLAN packets.\n Applicable if the FLAGS field in the VXLAN header is not\n matched with DECAP_FLAGS.\n",
    },
    {
        .name  = DECAP_IPV4_PAYLOADs,  /* DECAP_IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to parse IPv4 payload during VXLAN decapsulation.",
    },
    {
        .name  = DECAP_IPV6_PAYLOADs,  /* DECAP_IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to parse IPv6 payload during VXLAN decapsulation.",
    },
    {
        .name  = DECAP_ARP_PAYLOADs,  /* DECAP_ARP_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to parse ARP payload during VXLAN decapsulation.",
    },
    {
        .name  = DECAP_RARP_PAYLOADs,  /* DECAP_RARP_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to parse RARP payload during VXLAN decapsulation.",
    },
    {
        .name  = RESERVED_1s,  /* RESERVED_1 */
        .flags = 0,
        .width = 24,
        .depth = 0,
        .desc = "Value to fill into the RESERVED_1 field in the VXLAN header\n during VXLAN tunnel encapsulation.\n",
    },
    {
        .name  = RESERVED_2s,  /* RESERVED_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to fill into the RESERVED_2 field in the VXLAN header\n during VXLAN tunnel encapsulation.\n",
    },
    {
        .name  = FLAGSs,  /* FLAGS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Value to fill into the FLAGS field in the VXLAN header\n during VXLAN tunnel encapsulation.\n",
    },
    {
        .name  = SRC_L4_PORT_SELECTs,  /* SRC_L4_PORT_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify how to select the layer 4 source port in the UDP header\n during VXLAN tunnel encapsulation.\n",
    },
    {
        .name  = DEFAULT_NETWORK_SVPs,  /* DEFAULT_NETWORK_SVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Specify default network source virtual port during VXLAN\n decapsulation. Applicable if there is no match in\n TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4 or\n TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6\n and PORT_SYSTEM.ASSIGN_DEFAULT_NETWORK_SVP is enabled.\n",
    },
    {
        .name  = VXLAN_VFI_ASSIGN_FAIL_COPY_TO_CPUs,  /* VXLAN_VFI_ASSIGN_FAIL_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy VXLAN packets with VFI assignment failure to CPU.\n Applicable if there is no match in\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID or\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4 or\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6 during\n tunnel decapsulation.\n",
    },
    {
        .name  = VXLAN_SVP_ASSIGN_FAIL_COPY_TO_CPUs,  /* VXLAN_SVP_ASSIGN_FAIL_COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy VXLAN packets with source virtual port assignment\n failure to CPU. Applicable if there is no match in\n TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4 or\n TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_control_t = {
    .name = TNL_L2_VXLAN_CONTROLs, /* TNL_L2_VXLAN_CONTROL */
    .flags = 0,
    .fields = 15,
    .field = bcmltd_tnl_l2_vxlan_control_t_fields,
    .desc = "The TNL_L2_VXLAN_CONTROL table provides device level VXLAN tunnel\n controls.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_DST_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv4_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for OVID.",
    },
    {
        .name  = OUTER_DST_IPV4s,  /* OUTER_DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = OUTER_DST_IPV4_MASKs,  /* OUTER_DST_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for OUTER_DST_IPV4.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = USE_TNL_HDR_TTLs,  /* USE_TNL_HDR_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = IGNORE_UDP_CHKSUMs,  /* IGNORE_UDP_CHKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to ignore UDP checksum check. By default, VXLAN packet\n with nonzero checksum will be dropped.\n",
    },
    {
        .name  = TNL_HDR_FOR_PHBs,  /* TNL_HDR_FOR_PHB */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select how to generate PHB based on tunnel header.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv4_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_DST_IPV4s, /* TNL_L2_VXLAN_DECAP_OVID_DST_IPV4 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 16,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv4_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_DST_IPV4 table is used to specify decapsulation\n attributes for VXLAN tunnel (with IPv4 underlay).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EM.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv4_em_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = OUTER_DST_IPV4s,  /* OUTER_DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = USE_TNL_HDR_TTLs,  /* USE_TNL_HDR_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = IGNORE_UDP_CHKSUMs,  /* IGNORE_UDP_CHKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to ignore UDP checksum check. By default, VXLAN packet\n with nonzero checksum will be dropped.\n",
    },
    {
        .name  = TNL_HDR_FOR_PHBs,  /* TNL_HDR_FOR_PHB */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select how to generate PHB based on tunnel header.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv4_em_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EMs, /* TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EM */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 14,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv4_em_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EM table is used to specify\n decapsulation attributes for VXLAN tunnel (with IPv4 underlay) through\n exact match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EM_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv4_em_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID mask.",
    },
    {
        .name  = OUTER_DST_IPV4_MASKs,  /* OUTER_DST_IPV4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Outer destination IP address mask.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv4_em_key_mask_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EM_KEY_MASKs, /* TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EM_KEY_MASK */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv4_em_key_mask_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EM_KEY_MASK table is used to control\n and specify the global key mask of TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EM.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_DST_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv6_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for OVID.",
    },
    {
        .name  = OUTER_DST_IPV6_UPPERs,  /* OUTER_DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = OUTER_DST_IPV6_UPPER_MASKs,  /* OUTER_DST_IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for OUTER_DST_IPV6_UPPER.",
    },
    {
        .name  = OUTER_DST_IPV6_LOWERs,  /* OUTER_DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = OUTER_DST_IPV6_LOWER_MASKs,  /* OUTER_DST_IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for OUTER_DST_IPV6_LOWER.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = USE_TNL_HDR_TTLs,  /* USE_TNL_HDR_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = IGNORE_UDP_CHKSUMs,  /* IGNORE_UDP_CHKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to ignore UDP checksum check. By default, VXLAN packet\n with nonzero checksum will be dropped.\n",
    },
    {
        .name  = TNL_HDR_FOR_PHBs,  /* TNL_HDR_FOR_PHB */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select how to generate PHB based on tunnel header.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv6_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_DST_IPV6s, /* TNL_L2_VXLAN_DECAP_OVID_DST_IPV6 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 18,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv6_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_DST_IPV6 table is used to specify decapsulation\n attributes for VXLAN tunnel (with IPv6 underlay).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EM.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv6_em_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = OUTER_DST_IPV6_UPPERs,  /* OUTER_DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = OUTER_DST_IPV6_LOWERs,  /* OUTER_DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = USE_TNL_HDR_TTLs,  /* USE_TNL_HDR_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = IGNORE_UDP_CHKSUMs,  /* IGNORE_UDP_CHKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to ignore UDP checksum check. By default, VXLAN packet\n with nonzero checksum will be dropped.\n",
    },
    {
        .name  = TNL_HDR_FOR_PHBs,  /* TNL_HDR_FOR_PHB */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select how to generate PHB based on tunnel header.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv6_em_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EMs, /* TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EM */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 15,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv6_em_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EM table is used to specify\n decapsulation attributes for VXLAN tunnel (with IPv6 underlay) through\n exact match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EM_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv6_em_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID mask.",
    },
    {
        .name  = OUTER_DST_IPV6_MASK_UPPERs,  /* OUTER_DST_IPV6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address mask of the tunnel.",
    },
    {
        .name  = OUTER_DST_IPV6_MASK_LOWERs,  /* OUTER_DST_IPV6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address mask of the tunnel.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv6_em_key_mask_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EM_KEY_MASKs, /* TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EM_KEY_MASK */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_dst_ipv6_em_key_mask_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EM_KEY_MASK table is used to control\n and specify the global key mask of TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EM.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv4_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for OVID.",
    },
    {
        .name  = OUTER_DST_IPV4s,  /* OUTER_DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = OUTER_DST_IPV4_MASKs,  /* OUTER_DST_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for OUTER_DST_IPV4.",
    },
    {
        .name  = OUTER_SRC_IPV4s,  /* OUTER_SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Outer source IP address of the tunnel.",
    },
    {
        .name  = OUTER_SRC_IPV4_MASKs,  /* OUTER_SRC_IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for OUTER_SRC_IPV4.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = USE_TNL_HDR_TTLs,  /* USE_TNL_HDR_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = IGNORE_UDP_CHKSUMs,  /* IGNORE_UDP_CHKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to ignore UDP checksum check. By default, VXLAN packet\n with nonzero checksum will be dropped.\n",
    },
    {
        .name  = TNL_HDR_FOR_PHBs,  /* TNL_HDR_FOR_PHB */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select how to generate PHB based on tunnel header.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv4_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_IPV4s, /* TNL_L2_VXLAN_DECAP_OVID_IPV4 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 18,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_ipv4_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_IPV4 table is used to specify decapsulation\n attributes for VXLAN tunnel (with IPv4 underlay).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_IPV4_EM.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv4_em_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = OUTER_DST_IPV4s,  /* OUTER_DST_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = OUTER_SRC_IPV4s,  /* OUTER_SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Outer source IP address of the tunnel.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = USE_TNL_HDR_TTLs,  /* USE_TNL_HDR_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = IGNORE_UDP_CHKSUMs,  /* IGNORE_UDP_CHKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to ignore UDP checksum check. By default, VXLAN packet\n with nonzero checksum will be dropped.\n",
    },
    {
        .name  = TNL_HDR_FOR_PHBs,  /* TNL_HDR_FOR_PHB */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select how to generate PHB based on tunnel header.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv4_em_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_IPV4_EMs, /* TNL_L2_VXLAN_DECAP_OVID_IPV4_EM */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 15,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_ipv4_em_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_IPV4_EM table is used to specify decapsulation\n attributes for VXLAN tunnel (with IPv4 underlay) through exact match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_IPV4_EM_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv4_em_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID mask.",
    },
    {
        .name  = OUTER_DST_IPV4_MASKs,  /* OUTER_DST_IPV4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Outer destination IP address mask.",
    },
    {
        .name  = OUTER_SRC_IPV4_MASKs,  /* OUTER_SRC_IPV4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Outer source IP address mask.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv4_em_key_mask_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_IPV4_EM_KEY_MASKs, /* TNL_L2_VXLAN_DECAP_OVID_IPV4_EM_KEY_MASK */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_ipv4_em_key_mask_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_IPV4_EM_KEY_MASK table is used to control\n and specify the global key mask of TNL_L2_VXLAN_DECAP_OVID_IPV4_EM.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv6_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "MASK for OVID.",
    },
    {
        .name  = OUTER_DST_IPV6_UPPERs,  /* OUTER_DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = OUTER_DST_IPV6_UPPER_MASKs,  /* OUTER_DST_IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for OUTER_DST_IPV6_UPPER.",
    },
    {
        .name  = OUTER_DST_IPV6_LOWERs,  /* OUTER_DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = OUTER_DST_IPV6_LOWER_MASKs,  /* OUTER_DST_IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for OUTER_DST_IPV6_LOWER.",
    },
    {
        .name  = OUTER_SRC_IPV6_UPPERs,  /* OUTER_SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IP address of the tunnel.",
    },
    {
        .name  = OUTER_SRC_IPV6_UPPER_MASKs,  /* OUTER_SRC_IPV6_UPPER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for OUTER_SRC_IPV6_UPPER.",
    },
    {
        .name  = OUTER_SRC_IPV6_LOWERs,  /* OUTER_SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IP address of the tunnel.",
    },
    {
        .name  = OUTER_SRC_IPV6_LOWER_MASKs,  /* OUTER_SRC_IPV6_LOWER_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "MASK for OUTER_SRC_IPV6_LOWER.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = USE_TNL_HDR_TTLs,  /* USE_TNL_HDR_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = IGNORE_UDP_CHKSUMs,  /* IGNORE_UDP_CHKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to ignore UDP checksum check. By default, VXLAN packet\n with nonzero checksum will be dropped.\n",
    },
    {
        .name  = TNL_HDR_FOR_PHBs,  /* TNL_HDR_FOR_PHB */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select how to generate PHB based on tunnel header.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv6_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_IPV6s, /* TNL_L2_VXLAN_DECAP_OVID_IPV6 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 22,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_ipv6_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_IPV6 table is used to specify decapsulation\n attributes for VXLAN tunnel (with IPv6 underlay).\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_IPV6_EM.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv6_em_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = OUTER_DST_IPV6_UPPERs,  /* OUTER_DST_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = OUTER_DST_IPV6_LOWERs,  /* OUTER_DST_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address of the tunnel.",
    },
    {
        .name  = OUTER_SRC_IPV6_UPPERs,  /* OUTER_SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IP address of the tunnel.",
    },
    {
        .name  = OUTER_SRC_IPV6_LOWERs,  /* OUTER_SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IP address of the tunnel.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = USE_TNL_HDR_TTLs,  /* USE_TNL_HDR_TTL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL value.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the inner header's DSCP value.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Tunnel class ID based on a tunnel termination hit.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = TNL_DECAP_PORT_PROFILE_IDs,  /* TNL_DECAP_PORT_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_DECAP_PORT_PROFILE logical table index.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = IGNORE_UDP_CHKSUMs,  /* IGNORE_UDP_CHKSUM */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to ignore UDP checksum check. By default, VXLAN packet\n with nonzero checksum will be dropped.\n",
    },
    {
        .name  = TNL_HDR_FOR_PHBs,  /* TNL_HDR_FOR_PHB */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Select how to generate PHB based on tunnel header.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv6_em_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_IPV6_EMs, /* TNL_L2_VXLAN_DECAP_OVID_IPV6_EM */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 17,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_ipv6_em_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_IPV6_EM table is used to specify decapsulation\n attributes for VXLAN tunnel (with IPv6 underlay) through exact match.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_OVID_IPV6_EM_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv6_em_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID mask.",
    },
    {
        .name  = OUTER_DST_IPV6_MASK_UPPERs,  /* OUTER_DST_IPV6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address mask of the tunnel.",
    },
    {
        .name  = OUTER_DST_IPV6_MASK_LOWERs,  /* OUTER_DST_IPV6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Outer destination IP address mask of the tunnel.",
    },
    {
        .name  = OUTER_SRC_IPV6_MASK_UPPERs,  /* OUTER_SRC_IPV6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IP address mask of the tunnel.",
    },
    {
        .name  = OUTER_SRC_IPV6_MASK_LOWERs,  /* OUTER_SRC_IPV6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IP address mask of the tunnel.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_ovid_ipv6_em_key_mask_t = {
    .name = TNL_L2_VXLAN_DECAP_OVID_IPV6_EM_KEY_MASKs, /* TNL_L2_VXLAN_DECAP_OVID_IPV6_EM_KEY_MASK */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_tnl_l2_vxlan_decap_ovid_ipv6_em_key_mask_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_OVID_IPV6_EM_KEY_MASK table is used to control\n and specify the global key mask of TNL_L2_VXLAN_DECAP_OVID_IPV6_EM.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv4_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = OUTER_SRC_IPV4s,  /* OUTER_SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Outer source IP address of the tunnel.",
    },
    {
        .name  = PORT_SVP_IDs,  /* PORT_SVP_ID */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Source virtual port.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv4_t = {
    .name = TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4s, /* TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4 */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 5,
    .field = bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv4_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4 table assigns\n source virtual port (SVP) based on outer source IP address during\n VXLAN tunnel (with IPv4 underlay) decapsulation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv4_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID mask.",
    },
    {
        .name  = OUTER_SRC_IPV4_MASKs,  /* OUTER_SRC_IPV4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Outer source IP address mask.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv4_key_mask_t = {
    .name = TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4_KEY_MASKs, /* TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4_KEY_MASK */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv4_key_mask_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4_KEY_MASK table\n is used to control and specify the global key mask of\n TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv6_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = OUTER_SRC_IPV6_UPPERs,  /* OUTER_SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IP address of the tunnel.",
    },
    {
        .name  = OUTER_SRC_IPV6_LOWERs,  /* OUTER_SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IP address of the tunnel.",
    },
    {
        .name  = PORT_SVP_IDs,  /* PORT_SVP_ID */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Source virtual port.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv6_t = {
    .name = TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6s, /* TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6 */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 6,
    .field = bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv6_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6 table assigns\n source virtual port (SVP) based on outer source IP address during\n VXLAN tunnel (with IPv6 underlay) decapsulation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv6_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID mask.",
    },
    {
        .name  = OUTER_SRC_IPV6_MASK_UPPERs,  /* OUTER_SRC_IPV6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IP address mask.",
    },
    {
        .name  = OUTER_SRC_IPV6_MASK_LOWERs,  /* OUTER_SRC_IPV6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IP address mask.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv6_key_mask_t = {
    .name = TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6_KEY_MASKs, /* TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6_KEY_MASK */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tnl_l2_vxlan_decap_svp_assignment_ovid_src_ipv6_key_mask_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6_KEY_MASK table\n is used to control and specify the global key mask of\n TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = VNIDs,  /* VNID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 24,
        .depth = 0,
        .desc = "VXLAN network identifier.",
    },
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_t = {
    .name = TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNIDs, /* TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 5,
    .field = bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID table assigns virtual\n forwarding instance (VFI) based on VNID during VXLAN tunnel\n decapsulation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID mask.",
    },
    {
        .name  = VNID_MASKs,  /* VNID_MASK */
        .flags = 0,
        .width = 24,
        .depth = 0,
        .desc = "VXLAN network identifier mask.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_key_mask_t = {
    .name = TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_KEY_MASKs, /* TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_KEY_MASK */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_key_mask_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_KEY_MASK table\n is used to control and specify the global key mask of\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv4_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = VNIDs,  /* VNID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 24,
        .depth = 0,
        .desc = "VXLAN network identifier.",
    },
    {
        .name  = OUTER_SRC_IPV4s,  /* OUTER_SRC_IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "Outer source IPV4 address.",
    },
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv4_t = {
    .name = TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4s, /* TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4 */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 6,
    .field = bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv4_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4 table assigns\n virtual forwarding instance (VFI) based on VNID and outer source IP\n address during VXLAN tunnel (with IPv4 underlay) decapsulation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv4_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID mask .",
    },
    {
        .name  = VNID_MASKs,  /* VNID_MASK */
        .flags = 0,
        .width = 24,
        .depth = 0,
        .desc = "VXLAN network identifier mask.",
    },
    {
        .name  = OUTER_SRC_IPV4_MASKs,  /* OUTER_SRC_IPV4_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Outer source IP address mask.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv4_key_mask_t = {
    .name = TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4_KEY_MASKs, /* TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4_KEY_MASK */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv4_key_mask_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4_KEY_MASK table\n is used to control and specify the global key mask of\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv6_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = VNIDs,  /* VNID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 24,
        .depth = 0,
        .desc = "VXLAN network identifier.",
    },
    {
        .name  = OUTER_SRC_IPV6_UPPERs,  /* OUTER_SRC_IPV6_UPPER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IPV6 address.",
    },
    {
        .name  = OUTER_SRC_IPV6_LOWERs,  /* OUTER_SRC_IPV6_LOWER */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IPV6 address.",
    },
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv6_t = {
    .name = TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6s, /* TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6 */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 7,
    .field = bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv6_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6 table assigns\n virtual forwarding instance (VFI) based on VNID and outer source IP\n address during VXLAN tunnel (with IPv6 underlay) decapsulation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv6_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = OVID_MASKs,  /* OVID_MASK */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID mask .",
    },
    {
        .name  = VNID_MASKs,  /* VNID_MASK */
        .flags = 0,
        .width = 24,
        .depth = 0,
        .desc = "VXLAN network identifier mask.",
    },
    {
        .name  = OUTER_SRC_IPV6_MASK_UPPERs,  /* OUTER_SRC_IPV6_MASK_UPPER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IPV6 address",
    },
    {
        .name  = OUTER_SRC_IPV6_MASK_LOWERs,  /* OUTER_SRC_IPV6_MASK_LOWER */
        .flags = 0,
        .width = 64,
        .depth = 0,
        .desc = "Outer source IPV6 address",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv6_key_mask_t = {
    .name = TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6_KEY_MASKs, /* TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6_KEY_MASK */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tnl_l2_vxlan_decap_vfi_assignment_ovid_vnid_src_ipv6_key_mask_t_fields,
    .desc = "The TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6_KEY_MASK table\n is used to control and specify the global key mask of\n TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_CONTROL_PKT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_control_pkt_t_fields[] = {
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_0s,  /* TNL_MPLS_CONTROL_PKT_ID_0 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "TNL_MPLS_CONTROL_PKT logical table index 0.",
    },
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_0_MASKs,  /* TNL_MPLS_CONTROL_PKT_ID_0_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for TNL_MPLS_CONTROL_PKT_ID_0.",
    },
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_1s,  /* TNL_MPLS_CONTROL_PKT_ID_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "TNL_MPLS_CONTROL_PKT logical table index 1.",
    },
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_1_MASKs,  /* TNL_MPLS_CONTROL_PKT_ID_1_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for TNL_MPLS_CONTROL_PKT_ID_1.",
    },
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_2s,  /* TNL_MPLS_CONTROL_PKT_ID_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "TNL_MPLS_CONTROL_PKT logical table index 2.",
    },
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_2_MASKs,  /* TNL_MPLS_CONTROL_PKT_ID_2_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for TNL_MPLS_CONTROL_PKT_ID_2.",
    },
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_3s,  /* TNL_MPLS_CONTROL_PKT_ID_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "TNL_MPLS_CONTROL_PKT logical table index 3.",
    },
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_3_MASKs,  /* TNL_MPLS_CONTROL_PKT_ID_3_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for TNL_MPLS_CONTROL_PKT_ID_3.",
    },
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_4s,  /* TNL_MPLS_CONTROL_PKT_ID_4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "TNL_MPLS_CONTROL_PKT logical table index 4.",
    },
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_4_MASKs,  /* TNL_MPLS_CONTROL_PKT_ID_4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for TNL_MPLS_CONTROL_PKT_ID_4.",
    },
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_5s,  /* TNL_MPLS_CONTROL_PKT_ID_5 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "TNL_MPLS_CONTROL_PKT logical table index 5.",
    },
    {
        .name  = TNL_MPLS_CONTROL_PKT_ID_5_MASKs,  /* TNL_MPLS_CONTROL_PKT_ID_5_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for TNL_MPLS_CONTROL_PKT_ID_5.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = SEQ_NUM_CHECKs,  /* SEQ_NUM_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable sequence number check.",
    },
    {
        .name  = CW_PRESENTs,  /* CW_PRESENT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicate control word is present.",
    },
    {
        .name  = CONTROL_PKTs,  /* CONTROL_PKT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indictate control packet.",
    },
    {
        .name  = CONTROL_PKT_TYPEs,  /* CONTROL_PKT_TYPE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Indicate control packet type.\n Applicable only when CONTROL_PKT is enabled.\n",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy to CPU.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_control_pkt_t = {
    .name = TNL_MPLS_CONTROL_PKTs, /* TNL_MPLS_CONTROL_PKT */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 19,
    .field = bcmltd_tnl_mpls_control_pkt_t_fields,
    .desc = "The TNL_MPLS_CONTROL_PKT table is used to specify\n MPLS control packet processing attributes.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_CTR_ING_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_ctr_ing_eflex_action_t_fields[] = {
    {
        .name  = TNL_MPLS_CTR_ING_EFLEX_ACTION_IDs,  /* TNL_MPLS_CTR_ING_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_CTR_ING_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_ctr_ing_eflex_action_t = {
    .name = TNL_MPLS_CTR_ING_EFLEX_ACTIONs, /* TNL_MPLS_CTR_ING_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tnl_mpls_ctr_ing_eflex_action_t_fields,
    .desc = "The TNL_MPLS_CTR_ING_EFLEX_ACTION table is used to configure the\n MPLS tunnel ingress flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_DECAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_decap_t_fields[] = {
    {
        .name  = MPLS_LABELs,  /* MPLS_LABEL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 20,
        .depth = 0,
        .desc = "Outer MPLS label of the tunnel.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Incoming module ID of the tunnel.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Incoming logical port ID of the tunnel.",
    },
    {
        .name  = BOS_ACTIONSs,  /* BOS_ACTIONS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "MPLS bottom of stack label actions.",
    },
    {
        .name  = NON_BOS_ACTIONSs,  /* NON_BOS_ACTIONS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "MPLS non-bottom of stack label actions.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable when BOS_ACTIONS == L3_IIF.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3_UC_NHOP logical table index. Used for L3 VPN.\n Applicable when BOS_ACTIONS == (SWAP_NHI or L3_NHI) or\n NON_BOS_ACTIONS == (SWAP_NHI or PHP_NHI).\n",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "ECMP logical table index.\n Applicable when BOS_ACTIONS == (L3_ECMP or SWAP_ECMP) or\n NON_BOS_ACTIONS == (SWAP_ECMP or PHP_ECMP).\n",
    },
    {
        .name  = USE_TTL_FROM_DECAP_HDRs,  /* USE_TTL_FROM_DECAP_HDR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL field.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the DSCP field in the tunnel payload.",
    },
    {
        .name  = TNL_EXP_TO_INNER_EXPs,  /* TNL_EXP_TO_INNER_EXP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to push the EXP value from the tunnel label to the inner label.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets if using protection path.",
    },
    {
        .name  = EXP_MAP_ACTIONs,  /* EXP_MAP_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies how to generate the internal priority and CNG values.",
    },
    {
        .name  = PHB_ING_MPLS_EXP_TO_INT_PRI_IDs,  /* PHB_ING_MPLS_EXP_TO_INT_PRI_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_MPLS_EXP_TO_INT_PRI logical table index. Applicable only if\n EXP_MAP_ACTION == MAP_PRI_CNG or FIXED_PRI_MAP_CNG.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority value. Applicable only if\n EXP_MAP_ACTION == FIXED_PRI_MAP_CNG.\n",
    },
    {
        .name  = ECN_MPLS_EXP_TO_IP_ECN_IDs,  /* ECN_MPLS_EXP_TO_IP_ECN_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_MPLS_EXP_TO_IP_ECN logical table index.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enhanced flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = TNL_MPLS_CTR_ING_EFLEX_ACTION_IDs,  /* TNL_MPLS_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_CTR_ING_EFLEX_ACTION logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_decap_t = {
    .name = TNL_MPLS_DECAPs, /* TNL_MPLS_DECAP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 25,
    .field = bcmltd_tnl_mpls_decap_t_fields,
    .desc = "The TNL_MPLS_DECAP table is used to specify MPLS tunnel\n termination parameters for tunnels which terminate on a logical port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_DECAP_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_decap_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASK_ENABLEs,  /* GLOBAL_KEY_MASK_ENABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = MPLS_LABEL_MASKs,  /* MPLS_LABEL_MASK */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Outer MPLS label mask of the tunnel.",
    },
    {
        .name  = MODPORT_TRUNK_MASKs,  /* MODPORT_TRUNK_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Incoming logical port and trunk ID mask of the tunnel.",
    },
    {
        .name  = TRUNK_BIT_MASKs,  /* TRUNK_BIT_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set the trunk bit mask.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_decap_key_mask_t = {
    .name = TNL_MPLS_DECAP_KEY_MASKs, /* TNL_MPLS_DECAP_KEY_MASK */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_tnl_mpls_decap_key_mask_t_fields,
    .desc = "The TNL_MPLS_DECAP_KEY_MASK table is used to control and specify\n the global key mask of hash tables for MPLS tunnel termination.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_DECAP_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_decap_trunk_t_fields[] = {
    {
        .name  = MPLS_LABELs,  /* MPLS_LABEL */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 20,
        .depth = 0,
        .desc = "Outer MPLS label of the tunnel.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Incoming trunk ID of the tunnel.",
    },
    {
        .name  = BOS_ACTIONSs,  /* BOS_ACTIONS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "MPLS bottom of stack label actions.",
    },
    {
        .name  = NON_BOS_ACTIONSs,  /* NON_BOS_ACTIONS */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "MPLS non-bottom of stack label actions.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable when BOS_ACTIONS == L3_IIF.\n",
    },
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "L3_UC_NHOP logical table index. Used for L3 VPN.\n Applicable when BOS_ACTIONS == (SWAP_NHI or L3_NHI) or\n NON_BOS_ACTIONS == (SWAP_NHI or PHP_NHI).\n",
    },
    {
        .name  = ECMP_IDs,  /* ECMP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "ECMP logical table index.\n Applicable when BOS_ACTIONS == (L3_ECMP or SWAP_ECMP) or\n NON_BOS_ACTIONS == (SWAP_ECMP or PHP_ECMP).\n",
    },
    {
        .name  = USE_TTL_FROM_DECAP_HDRs,  /* USE_TTL_FROM_DECAP_HDR */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use outer header's TTL field.",
    },
    {
        .name  = KEEP_PAYLOAD_DSCPs,  /* KEEP_PAYLOAD_DSCP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to preserve the DSCP field in the tunnel payload.",
    },
    {
        .name  = TNL_EXP_TO_INNER_EXPs,  /* TNL_EXP_TO_INNER_EXP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to push the EXP value from the tunnel label to the inner label.",
    },
    {
        .name  = IPV6_PAYLOADs,  /* IPV6_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv6 payload.",
    },
    {
        .name  = IPV4_PAYLOADs,  /* IPV4_PAYLOAD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to allow IPv4 payload.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop packets if using protection path.",
    },
    {
        .name  = EXP_MAP_ACTIONs,  /* EXP_MAP_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies how to generate the internal priority and CNG values.",
    },
    {
        .name  = PHB_ING_MPLS_EXP_TO_INT_PRI_IDs,  /* PHB_ING_MPLS_EXP_TO_INT_PRI_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_MPLS_EXP_TO_INT_PRI logical table index. Applicable only if\n EXP_MAP_ACTION == MAP_PRI_CNG or FIXED_PRI_MAP_CNG.\n",
    },
    {
        .name  = INT_PRIs,  /* INT_PRI */
        .flags = 0,
        .width = 4,
        .depth = 0,
        .desc = "Internal priority value. Applicable only if\n EXP_MAP_ACTION == FIXED_PRI_MAP_CNG.\n",
    },
    {
        .name  = ECN_MPLS_EXP_TO_IP_ECN_IDs,  /* ECN_MPLS_EXP_TO_IP_ECN_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_MPLS_EXP_TO_IP_ECN logical table index.",
    },
    {
        .name  = BFDs,  /* BFD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to detect BFD packets.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
    {
        .name  = TNL_MPLS_CTR_ING_EFLEX_ACTION_IDs,  /* TNL_MPLS_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_CTR_ING_EFLEX_ACTION logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_decap_trunk_t = {
    .name = TNL_MPLS_DECAP_TRUNKs, /* TNL_MPLS_DECAP_TRUNK */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 24,
    .field = bcmltd_tnl_mpls_decap_trunk_t_fields,
    .desc = "The TNL_MPLS_DECAP_TRUNK table is used to specify\n MPLS tunnel termination parameters for tunnels which\n terminate on a trunk.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_DST_MAC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_dst_mac_t_fields[] = {
    {
        .name  = TNL_MPLS_DST_MAC_IDs,  /* TNL_MPLS_DST_MAC_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_DST_MAC table.",
    },
    {
        .name  = DST_MACs,  /* DST_MAC */
        .flags = 0,
        .width = 48,
        .depth = 0,
        .desc = "Destination MAC address.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_dst_mac_t = {
    .name = TNL_MPLS_DST_MACs, /* TNL_MPLS_DST_MAC */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tnl_mpls_dst_mac_t_fields,
    .desc = "The TNL_MPLS_DST_MAC table is used to set the destination MAC used during\n MPLS packet modification.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_ENCAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_encap_t_fields[] = {
    {
        .name  = TNL_MPLS_ENCAP_IDs,  /* TNL_MPLS_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_ENCAP table.",
    },
    {
        .name  = ENCAP_INDEXs,  /* ENCAP_INDEX */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Read-only field which reflects the hardware\n index allocated to this tunnel entry. This field\n is used in L3_EIF.TNL_MPLS_ENCAP_INDEX.\n",
    },
    {
        .name  = NUM_LABELSs,  /* NUM_LABELS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of labels to push for the MPLS tunnel.\n When NUM_LABELS == 0, no tunnel labels will be pushed but the\n interface will be considered as a tunnel interface ie. packets\n will have MPLS EtherType.\n A VPN label might be pushed depending on the configuration\n of TNL_MPLS_ENCAP_NHOP and TNL_MPLS_VPN_ENCAP tables.\n",
    },
    {
        .name  = MAX_LABELSs,  /* MAX_LABELS */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Maximum number of labels that can be pushed for the MPLS tunnel.",
    },
    {
        .name  = LABELs,  /* LABEL */
        .flags = 0,
        .width = 20,
        .depth = 8,
        .desc = "MPLS Labels that can be added in outgoing label stack.",
    },
    {
        .name  = LABEL_TTLs,  /* LABEL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "MPLS label TTL value.",
    },
    {
        .name  = MPLS_TNL_EXP_MODEs,  /* MPLS_TNL_EXP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 8,
        .desc = "Specifies how EXP values of the MPLS label stack will be determined.",
    },
    {
        .name  = PHB_EGR_MPLS_IDs,  /* PHB_EGR_MPLS_ID */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "If MPLS_TNL_EXP_MODE == MAP:\n EXP value for this label is derived from the\n PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP logical table index specified\n by PHB_EGR_MPLS_ID.\n If this is the outermost label, the 802.1p priority and CFI\n values for the outer VLAN tag are derived from the\n PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n\n If MPLS_TNL_EXP_MODE == USE_INNER_LABEL:\n EXP value for this label is derived from the inner MPLS label.\n If there is no inner MPLS label, the LABEL_EXP value specified\n in this logical table is used as the EXP value.\n If this is the outermost label, the 802.1p priority and CFI\n values for the outer VLAN tag are derived from the\n PHB_EGR_MPLS_EXP_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n",
    },
    {
        .name  = LABEL_EXPs,  /* LABEL_EXP */
        .flags = 0,
        .width = 3,
        .depth = 8,
        .desc = "EXP values to be set in the MPLS label stack.\n Applicable only if MPLS_TNL_EXP_MODE == FIXED.\n",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 8,
        .desc = "DOT1P value for the outer L2 header.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 8,
        .desc = "CFI value for the outer L2 header.",
    },
    {
        .name  = ECN_CNG_TO_MPLS_EXP_IDs,  /* ECN_CNG_TO_MPLS_EXP_ID */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "ECN_CNG_TO_MPLS_EXP logical table index.",
    },
    {
        .name  = ECN_CNG_TO_MPLS_EXP_PRIORITYs,  /* ECN_CNG_TO_MPLS_EXP_PRIORITY */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "Specifies priority for ECN_CNG_TO_MPLS_EXP_ID from this table.\n Priority relative to PORT_SYSTEM.ECN_CNG_TO_MPLS_EXP_PRIORITY.\n",
    },
    {
        .name  = ECN_IP_TO_MPLS_EXP_IDs,  /* ECN_IP_TO_MPLS_EXP_ID */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE logical table index for\n non-responsive protocols or ECN_IP_TO_MPLS_EXP_RESPONSIVE\n logical table index for responsive protocols.\n",
    },
    {
        .name  = ECN_IP_TO_MPLS_EXP_PRIORITYs,  /* ECN_IP_TO_MPLS_EXP_PRIORITY */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "Specifies priority for ECN_IP_TO_MPLS_EXP_ID from this table.\n Priority relative to PORT_SYSTEM.ECN_IP_TO_MPLS_EXP_PRIORITY.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_encap_t = {
    .name = TNL_MPLS_ENCAPs, /* TNL_MPLS_ENCAP */
    .flags = 0,
    .fields = 15,
    .field = bcmltd_tnl_mpls_encap_t_fields,
    .desc = "The TNL_MPLS_ENCAP table is used to specify MPLS tunnel parameters\n during encapsulation of packets.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_ENCAP_NHOP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_encap_nhop_t_fields[] = {
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_ENCAP_NHOP table.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Destination module ID to reach the next hop.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination logical port to reach the next hop.",
    },
    {
        .name  = IS_TRUNKs,  /* IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the next hop is a trunk (LAG) port.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Trunk group identifier. Applicable only if IS_TRUNK is enabled.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packet to CPU.",
    },
    {
        .name  = L3_EIF_VALIDs,  /* L3_EIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate L3_EIF_ID is valid.\n L3_EIF_ID is applicable only if L3_EIF_VALID is enabled.\n",
    },
    {
        .name  = L3_EIF_IDs,  /* L3_EIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_EIF logical table index.",
    },
    {
        .name  = TNL_MPLS_DST_MAC_IDs,  /* TNL_MPLS_DST_MAC_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_DST_MAC table to get the MAC address to be\n used for destination MAC address replacement.\n",
    },
    {
        .name  = TNL_MPLS_VPN_ENCAP_IDs,  /* TNL_MPLS_VPN_ENCAP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_VPN_ENCAP logical table.",
    },
    {
        .name  = CTR_EGR_FLEX_POOL_NUMBERs,  /* CTR_EGR_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter pool number.",
    },
    {
        .name  = CTR_EGR_FLEX_BASE_INDEXs,  /* CTR_EGR_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_EGR_FLEX_OFFSET_MODEs,  /* CTR_EGR_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID for egress FP.",
    },
    {
        .name  = VPN_LABELs,  /* VPN_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to add MPLS VPN label.",
    },
    {
        .name  = LABELs,  /* LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "VPN label in the outgoing MPLS label stack.",
    },
    {
        .name  = LABEL_TTLs,  /* LABEL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VPN label TTL value.",
    },
    {
        .name  = EXP_MODEs,  /* EXP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies how EXP value of the MPLS label stack will be determined.",
    },
    {
        .name  = LABEL_EXPs,  /* LABEL_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "EXP values to be set in the MPLS label stack.\n Applicable only if EXP_MODE == FIXED.\n",
    },
    {
        .name  = PHB_EGR_MPLS_IDs,  /* PHB_EGR_MPLS_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "If EXP_MODE == MAP:\n EXP value for this label is derived from the\n PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP  logical table index\n specified by PHB_EGR_MPLS_ID.\n If this is the outermost label, the 802.1p priority and CFI\n values for the outer VLAN tag are derived from the\n PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n\n If EXP_MODE == USE_INNER_LABEL:\n EXP value for this label is derived from the inner MPLS label.\n If there is no inner MPLS label, the LABEL_EXP value specified\n in this logical table is used as the EXP value.\n If this is the outermost label, the 802.1p priority and CFI\n values for the outer VLAN tag are derived from the\n PHB_EGR_MPLS_EXP_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n\n If EXP_MODE == USE_SWAP_LABEL:\n EXP value for this label is derived from the last decapped or\n swapped MPLS label.  If this is the outermost label, the 802.1p\n priority and CFI values for the outer VLAN tag are derived from\n the PHB_EGR_MPLS_EXP_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "DOT1P value for the outer L2 header.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value for the outer L2 header.",
    },
    {
        .name  = ECN_CNG_TO_MPLS_EXP_IDs,  /* ECN_CNG_TO_MPLS_EXP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_CNG_TO_MPLS_EXP logical table index.",
    },
    {
        .name  = ECN_CNG_TO_MPLS_EXP_PRIORITYs,  /* ECN_CNG_TO_MPLS_EXP_PRIORITY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies priority for ECN_CNG_TO_MPLS_EXP_ID from this table.\n Priority relative to PORT_SYSTEM.ECN_CNG_TO_MPLS_EXP_PRIORITY.\n",
    },
    {
        .name  = ECN_IP_TO_MPLS_EXP_IDs,  /* ECN_IP_TO_MPLS_EXP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE logical table index for\n non-responsive protocols or ECN_IP_TO_MPLS_EXP_RESPONSIVE\n logical table index for responsive protocols.\n",
    },
    {
        .name  = ECN_IP_TO_MPLS_EXP_PRIORITYs,  /* ECN_IP_TO_MPLS_EXP_PRIORITY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies priority for ECN_IP_TO_MPLS_EXP_ID from this table.\n Priority relative to PORT_SYSTEM.ECN_IP_TO_MPLS_EXP_PRIORITY.\n",
    },
    {
        .name  = CTR_EGR_EFLEX_OBJECTs,  /* CTR_EGR_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress enhanced flex counter object.",
    },
    {
        .name  = TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION_IDs,  /* TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION logical table index.\n TNL_MPLS_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION logical table index\n when NHOP_ID is used as an overlay next hop.\n",
    },
    {
        .name  = DO_NOT_CUT_THROUGHs,  /* DO_NOT_CUT_THROUGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate the packet is not eligible for cut-through.\n",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Destination VP derived from this next hop.",
    },
    {
        .name  = ING_UNDERLAY_NHOP_VALIDs,  /* ING_UNDERLAY_NHOP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate ING_UNDERLAY_NHOP_ID is valid.\n Applicable only when NHOP_ID is used as an overlay next hop.\n",
    },
    {
        .name  = ING_UNDERLAY_NHOP_IDs,  /* ING_UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Underlay next hop ID, derived\n from this overlay next hop in the ingress pipeline.\n Applicable only if ING_UNDERLAY_NHOP_VALID is enabled.\n",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_VALIDs,  /* EGR_UNDERLAY_NHOP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate EGR_UNDERLAY_NHOP_ID is valid.\n Applicable only when NHOP_ID is used as an underlay next hop.\n",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_IDs,  /* EGR_UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Underlay next hop ID which overrides\n the underlay next hop in the egress pipeline.\n Applicable only if EGR_UNDERLAY_NHOP_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_encap_nhop_t = {
    .name = TNL_MPLS_ENCAP_NHOPs, /* TNL_MPLS_ENCAP_NHOP */
    .flags = BCMLTD_TABLE_F_TYPE_INDEX_ALLOC,
    .fields = 35,
    .field = bcmltd_tnl_mpls_encap_nhop_t_fields,
    .desc = "The TNL_MPLS_ENCAP_NHOP table is used to specify MPLS tunnel next-hop\n parameters for packets entering into the MPLS tunnel.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_EXP_QOS_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_exp_qos_selection_t_fields[] = {
    {
        .name  = TNL_MPLS_EXP_QOS_SELECTION_ID_1s,  /* TNL_MPLS_EXP_QOS_SELECTION_ID_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_EXP_QOS_SELECTION logical table index 1.",
    },
    {
        .name  = TNL_MPLS_EXP_QOS_SELECTION_ID_2s,  /* TNL_MPLS_EXP_QOS_SELECTION_ID_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_EXP_QOS_SELECTION logical table index 2.",
    },
    {
        .name  = TNL_MPLS_EXP_QOS_SELECTION_ID_3s,  /* TNL_MPLS_EXP_QOS_SELECTION_ID_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_EXP_QOS_SELECTION logical table index 3.",
    },
    {
        .name  = EFFECTIVE_EXP_QOSs,  /* EFFECTIVE_EXP_QOS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable effective QoS for MPLS EXP.",
    },
    {
        .name  = EXP_QOS_SELECTs,  /* EXP_QOS_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "MPLS EXP QOS map selection.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_exp_qos_selection_t = {
    .name = TNL_MPLS_EXP_QOS_SELECTIONs, /* TNL_MPLS_EXP_QOS_SELECTION */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tnl_mpls_exp_qos_selection_t_fields,
    .desc = "The TNL_MPLS_EXP_QOS_SELECTION table is used to select QoS profile for MPLS EXP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_EXP_REMARK_SELECTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_exp_remark_selection_t_fields[] = {
    {
        .name  = TNL_MPLS_EXP_REMARK_SELECTION_ID_1s,  /* TNL_MPLS_EXP_REMARK_SELECTION_ID_1 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_EXP_REMARK_SELECTION logical table index 1.",
    },
    {
        .name  = TNL_MPLS_EXP_REMARK_SELECTION_ID_2s,  /* TNL_MPLS_EXP_REMARK_SELECTION_ID_2 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_EXP_REMARK_SELECTION logical table index 2.",
    },
    {
        .name  = TNL_MPLS_EXP_REMARK_SELECTION_ID_3s,  /* TNL_MPLS_EXP_REMARK_SELECTION_ID_3 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_EXP_REMARK_SELECTION logical table index 3.",
    },
    {
        .name  = EFFECTIVE_EXP_REMARKs,  /* EFFECTIVE_EXP_REMARK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable effective remark for MPLS EXP.",
    },
    {
        .name  = EXP_REMARK_SELECTs,  /* EXP_REMARK_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "MPLS EXP remark selection.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_exp_remark_selection_t = {
    .name = TNL_MPLS_EXP_REMARK_SELECTIONs, /* TNL_MPLS_EXP_REMARK_SELECTION */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_tnl_mpls_exp_remark_selection_t_fields,
    .desc = "The TNL_MPLS_EXP_REMARK_SELECTION table is used to select MPLS_EXP_REMARK.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_GLOBAL_LABEL_RANGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_global_label_range_t_fields[] = {
    {
        .name  = TNL_MPLS_GLOBAL_LABEL_RANGE_IDs,  /* TNL_MPLS_GLOBAL_LABEL_RANGE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MPLS_GLOBAL_LABEL_RANGE logical table index.",
    },
    {
        .name  = MIN_LABELs,  /* MIN_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Minimal value for the global MPLS label.",
    },
    {
        .name  = MAX_LABELs,  /* MAX_LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "Maximal value for the global MPLS label.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_global_label_range_t = {
    .name = TNL_MPLS_GLOBAL_LABEL_RANGEs, /* TNL_MPLS_GLOBAL_LABEL_RANGE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tnl_mpls_global_label_range_t_fields,
    .desc = "The TNL_MPLS_GLOBAL_LABEL_RANGE table specifies the global MPLS label range.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_IP_PROTOCOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_ip_protocol_t_fields[] = {
    {
        .name  = TNL_MPLS_IP_PROTOCOL_IDs,  /* TNL_MPLS_IP_PROTOCOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_IP_PROTOCOL logical table index.",
    },
    {
        .name  = CONTROLs,  /* CONTROL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "IP protocol control information.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_ip_protocol_t = {
    .name = TNL_MPLS_IP_PROTOCOLs, /* TNL_MPLS_IP_PROTOCOL */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tnl_mpls_ip_protocol_t_fields,
    .desc = "The TNL_MPLS_IP_PROTOCOL table is used to specify the\n control attributes for a specific IP protocol.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_LABEL_DECAP_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_label_decap_policy_t_fields[] = {
    {
        .name  = TNL_MPLS_LABEL_DECAP_POLICY_IDs,  /* TNL_MPLS_LABEL_DECAP_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_LABEL_DECAP_POLICY logical table index.",
    },
    {
        .name  = LABEL_FWD_CTRL_1s,  /* LABEL_FWD_CTRL_1 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Label forward control from MPLS label lookup 1.",
    },
    {
        .name  = LABEL_FWD_CTRL_2s,  /* LABEL_FWD_CTRL_2 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Label forward control from MPLS label lookup 2.",
    },
    {
        .name  = LABEL_FWD_CTRL_3s,  /* LABEL_FWD_CTRL_3 */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Label forward control from MPLS label lookup 3.",
    },
    {
        .name  = LABEL_FWD_CTRL_1_MASKs,  /* LABEL_FWD_CTRL_1_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask for label forward control from MPLS label lookup 1.",
    },
    {
        .name  = LABEL_FWD_CTRL_2_MASKs,  /* LABEL_FWD_CTRL_2_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask for label forward control from MPLS label lookup 2.",
    },
    {
        .name  = LABEL_FWD_CTRL_3_MASKs,  /* LABEL_FWD_CTRL_3_MASK */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Mask for label forward control from MPLS label lookup 3.",
    },
    {
        .name  = EFFECTIVE_EXP_REMARKs,  /* EFFECTIVE_EXP_REMARK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable effective remark for the MPLS EXP.",
    },
    {
        .name  = EFFECTIVE_EXP_QOSs,  /* EFFECTIVE_EXP_QOS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable effective QOS map for the MPLS EXP.",
    },
    {
        .name  = DECAP_LOOKUP_LABELs,  /* DECAP_LOOKUP_LABEL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Indicate to pop all labels before the specified lookup label.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the MPLS packet.",
    },
    {
        .name  = POLICY_CMD_SELECTs,  /* POLICY_CMD_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 12,
        .desc = "Policy command result selection.\n POLICY_CMD_SELECT[0] must be used to select LABEL_FWD_CTRL.\n POLICY_CMD_SELECT[1] must be used to select ECN_MPLS_EXP_TO_IP_ECN_ID.\n POLICY_CMD_SELECT[2] must be used to select MPLS_EXP_REMARK and MPLS_EXP_PHB.\n",
    },
    {
        .name  = POLICY_OBJ_SELECTs,  /* POLICY_OBJ_SELECT */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 6,
        .desc = "Policy object result selection.",
    },
    {
        .name  = POP_LOOKUP_LABEL_1s,  /* POP_LOOKUP_LABEL_1 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to pop the lookup label 1.",
    },
    {
        .name  = POP_LOOKUP_LABEL_2s,  /* POP_LOOKUP_LABEL_2 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to pop the lookup label 2.",
    },
    {
        .name  = POP_LOOKUP_LABEL_3s,  /* POP_LOOKUP_LABEL_3 */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to pop the lookup label 3.",
    },
    {
        .name  = TRUST_FWD_POLICYs,  /* TRUST_FWD_POLICY */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust MPLS forwarding policy result.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_label_decap_policy_t = {
    .name = TNL_MPLS_LABEL_DECAP_POLICYs, /* TNL_MPLS_LABEL_DECAP_POLICY */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_tnl_mpls_label_decap_policy_t_fields,
    .desc = "The TNL_MPLS_LABEL_DECAP_POLICY table is used to specify\n the per-label policy selection for MPLS process.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_nhop_ctr_egr_eflex_action_t_fields[] = {
    {
        .name  = TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION_IDs,  /* TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_nhop_ctr_egr_eflex_action_t = {
    .name = TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTIONs, /* TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tnl_mpls_nhop_ctr_egr_eflex_action_t_fields,
    .desc = "The TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION table is used to configure the\n MPLS tunnel next hop egress flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_OVERLAY_MPLS_NHOP_CTR_EGR_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_overlay_nhop_ctr_egr_eflex_action_t_fields[] = {
    {
        .name  = TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION_IDs,  /* TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_overlay_nhop_ctr_egr_eflex_action_t = {
    .name = TNL_MPLS_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTIONs, /* TNL_MPLS_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tnl_mpls_overlay_nhop_ctr_egr_eflex_action_t_fields,
    .desc = "The TNL_MPLS_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION table is used to configure the\n MPLS tunnel overlay next hop egress flex counter action.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_PROTECTION_ENABLE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_protection_enable_t_fields[] = {
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "TNL_MPLS_PROTECTION_ENABLE logical table index.",
    },
    {
        .name  = PROTECTIONs,  /* PROTECTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to switch to protection path.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_protection_enable_t = {
    .name = TNL_MPLS_PROTECTION_ENABLEs, /* TNL_MPLS_PROTECTION_ENABLE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_tnl_mpls_protection_enable_t_fields,
    .desc = "The TNL_MPLS_PROTECTION_ENABLE table is used to\n enable protection switching for an MPLS next hop.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_SPECIAL_LABEL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_special_label_t_fields[] = {
    {
        .name  = TNL_MPLS_SPECIAL_LABEL_IDs,  /* TNL_MPLS_SPECIAL_LABEL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_SPECIAL_LABEL logical table index.",
    },
    {
        .name  = MPLS_HEADERs,  /* MPLS_HEADER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "MPLS header.",
    },
    {
        .name  = MPLS_HEADER_MASKs,  /* MPLS_HEADER_MASK */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "MPLS header mask.",
    },
    {
        .name  = IGNORE_NEXT_LABEL_ACTIONs,  /* IGNORE_NEXT_LABEL_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip next MPLS label action.",
    },
    {
        .name  = SKIP_NEXT_LABEL_HASHs,  /* SKIP_NEXT_LABEL_HASH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip the next MPLS label for hash.",
    },
    {
        .name  = SKIP_LABEL_HASHs,  /* SKIP_LABEL_HASH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip the current MPLS label for hash.",
    },
    {
        .name  = SKIP_NEXT_LABEL_LOOKUPs,  /* SKIP_NEXT_LABEL_LOOKUP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip the next MPLS label for lookup.",
    },
    {
        .name  = SKIP_LABEL_LOOKUPs,  /* SKIP_LABEL_LOOKUP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip the current MPLS label for lookup.",
    },
    {
        .name  = RESERVED_LABELs,  /* RESERVED_LABEL */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicate reserved label.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_special_label_t = {
    .name = TNL_MPLS_SPECIAL_LABELs, /* TNL_MPLS_SPECIAL_LABEL */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_tnl_mpls_special_label_t_fields,
    .desc = "The TNL_MPLS_SPECIAL_LABEL table is used to specify actions for special labels.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_TRANSIT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_transit_t_fields[] = {
    {
        .name  = TNL_MPLS_TRANSIT_IDs,  /* TNL_MPLS_TRANSIT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_TRANSIT table.",
    },
    {
        .name  = LABELs,  /* LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "MPLS label for the swap operation at this LSR.",
    },
    {
        .name  = LABEL_TTLs,  /* LABEL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MPLS label TTL value.",
    },
    {
        .name  = EXP_MODEs,  /* EXP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "EXP selection mode.",
    },
    {
        .name  = LABEL_EXPs,  /* LABEL_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "MPLS label EXP value if EXP_MODE == FIXED.",
    },
    {
        .name  = PHB_EGR_MPLS_IDs,  /* PHB_EGR_MPLS_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "If EXP_MODE == MAP:\n EXP value for this label is derived from the\n PHB_EGR_MPLS_INT_PRI_TO_TRANSIT_EXP logical table index\n specified by PHB_EGR_MPLS_ID.\n If this is the outermost label, the 802.1p priority and CFI\n values for the outer VLAN tag are derived from the\n PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n\n If EXP_MODE == USE_INNER_LABEL:\n EXP value for this label is derived from the inner MPLS label.\n If there is no inner MPLS label, the LABEL_EXP value specified\n in this logical table is used as the EXP value.\n If this is the outermost label, the 802.1p priority and CFI\n values for the outer VLAN tag are derived from the\n PHB_EGR_MPLS_EXP_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n\n If EXP_MODE == USE_SWAP_LABEL:\n EXP value for this label is derived from the last decapped or\n swapped MPLS label.  If this is the outermost label, the 802.1p\n priority and CFI values for the outer VLAN tag are derived from\n the PHB_EGR_MPLS_EXP_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "DOT1P value for the outer L2 header.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value for the outer L2 header.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_transit_t = {
    .name = TNL_MPLS_TRANSITs, /* TNL_MPLS_TRANSIT */
    .flags = BCMLTD_TABLE_F_TYPE_INDEX_ALLOC,
    .fields = 8,
    .field = bcmltd_tnl_mpls_transit_t_fields,
    .desc = "The TNL_MPLS_TRANSIT table is used to specify label parameters for the\n transit labels in the MPLS tunnel.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_TRANSIT_NHOP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_transit_nhop_t_fields[] = {
    {
        .name  = NHOP_IDs,  /* NHOP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_TRANSIT_NHOP.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Destination module ID to reach the next hop.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Destination logical port to reach the next hop.",
    },
    {
        .name  = IS_TRUNKs,  /* IS_TRUNK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate that the next hop is a trunk (LAG) port.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Trunk group identifier. Applicable only if IS_TRUNK is enabled.",
    },
    {
        .name  = DROPs,  /* DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to drop the packet.",
    },
    {
        .name  = COPY_TO_CPUs,  /* COPY_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to copy packet to CPU.",
    },
    {
        .name  = L3_EIF_VALIDs,  /* L3_EIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate L3_EIF_ID is valid.\n L3_EIF_ID is applicable only if L3_EIF_VALID is enabled.\n",
    },
    {
        .name  = L3_EIF_IDs,  /* L3_EIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_EIF logical table index.",
    },
    {
        .name  = TNL_MPLS_DST_MAC_IDs,  /* TNL_MPLS_DST_MAC_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_DST_MAC_ID table to get the MAC address\n to be used for destination MAC address replacement.\n",
    },
    {
        .name  = TNL_MPLS_TRANSIT_IDs,  /* TNL_MPLS_TRANSIT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "TNL_MPLS_TRANSIT logical table index.",
    },
    {
        .name  = CTR_EGR_FLEX_POOL_NUMBERs,  /* CTR_EGR_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter pool number.",
    },
    {
        .name  = CTR_EGR_FLEX_BASE_INDEXs,  /* CTR_EGR_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_EGR_FLEX_OFFSET_MODEs,  /* CTR_EGR_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Class ID for egress FP.",
    },
    {
        .name  = LABELs,  /* LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "MPLS label for the swap operation at this LSR.",
    },
    {
        .name  = LABEL_TTLs,  /* LABEL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MPLS label TTL value.",
    },
    {
        .name  = LABEL_ACTIONs,  /* LABEL_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify the action associated with this label.",
    },
    {
        .name  = EXP_MODEs,  /* EXP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "EXP selection mode.",
    },
    {
        .name  = LABEL_EXPs,  /* LABEL_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "MPLS label EXP value if EXP_MODE == FIXED.",
    },
    {
        .name  = PHB_EGR_MPLS_IDs,  /* PHB_EGR_MPLS_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "If EXP_MODE == MAP:\n EXP value for this label is derived from the\n PHB_EGR_MPLS_INT_PRI_TO_TRANSIT_EXP logical table index\n specified by PHB_EGR_MPLS_ID.\n If this is the outermost label, the 802.1p priority and CFI\n values for the outer VLAN tag are derived from the\n PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n\n If EXP_MODE == USE_INNER_LABEL:\n EXP value for this label is derived from the inner MPLS label.\n If there is no inner MPLS label, the LABEL_EXP value specified\n in this logical table is used as the EXP value.\n If this is the outermost label, the 802.1p priority and CFI\n values for the outer VLAN tag are derived from the\n PHB_EGR_MPLS_EXP_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n\n If EXP_MODE == USE_SWAP_LABEL:\n EXP value for this label is derived from the last decapped or\n swapped MPLS label.  If this is the outermost label, the 802.1p\n priority and CFI values for the outer VLAN tag are derived from\n the PHB_EGR_MPLS_EXP_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "DOT1P value for the outer L2 header.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value for the outer L2 header.",
    },
    {
        .name  = ECN_CNG_TO_MPLS_EXP_IDs,  /* ECN_CNG_TO_MPLS_EXP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_CNG_TO_MPLS_EXP logical table index.",
    },
    {
        .name  = ECN_CNG_TO_MPLS_EXP_PRIORITYs,  /* ECN_CNG_TO_MPLS_EXP_PRIORITY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies priority for ECN_CNG_TO_MPLS_EXP_ID from this table.\n Priority relative to PORT_SYSTEM.ECN_CNG_TO_MPLS_EXP_PRIORITY.\n",
    },
    {
        .name  = ECN_IP_TO_MPLS_EXP_IDs,  /* ECN_IP_TO_MPLS_EXP_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE logical table index for\n non-responsive protocols or ECN_IP_TO_MPLS_EXP_RESPONSIVE\n logical table index for responsive protocols.\n",
    },
    {
        .name  = ECN_IP_TO_MPLS_EXP_PRIORITYs,  /* ECN_IP_TO_MPLS_EXP_PRIORITY */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Specifies priority for ECN_IP_TO_MPLS_EXP_ID from this table.\n Priority relative to PORT_SYSTEM.ECN_IP_TO_MPLS_EXP_PRIORITY.\n",
    },
    {
        .name  = CTR_EGR_EFLEX_OBJECTs,  /* CTR_EGR_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress enhanced flex counter object.",
    },
    {
        .name  = TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION_IDs,  /* TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "TNL_MPLS_NHOP_CTR_EGR_EFLEX_ACTION logical table index.\n TNL_MPLS_OVERLAY_NHOP_CTR_EGR_EFLEX_ACTION logical table index\n when NHOP_ID is used as an overlay next hop.\n",
    },
    {
        .name  = DO_NOT_CUT_THROUGHs,  /* DO_NOT_CUT_THROUGH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate the packet is not eligible for cut-through.\n",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Destination VP derived from this next hop.",
    },
    {
        .name  = ING_UNDERLAY_NHOP_VALIDs,  /* ING_UNDERLAY_NHOP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate ING_UNDERLAY_NHOP_ID is valid.\n Applicable only when NHOP_ID is used as an overlay next hop.\n",
    },
    {
        .name  = ING_UNDERLAY_NHOP_IDs,  /* ING_UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Underlay next hop ID which is derived\n from this overlay next hop in the ingress pipeline.\n Applicable only if ING_UNDERLAY_NHOP_VALID is enabled.\n",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_VALIDs,  /* EGR_UNDERLAY_NHOP_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate EGR_UNDERLAY_NHOP_ID is valid.\n Applicable only when NHOP_ID is used as an underlay next hop.\n",
    },
    {
        .name  = EGR_UNDERLAY_NHOP_IDs,  /* EGR_UNDERLAY_NHOP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Underlay next hop ID which overrides\n the underlay next hop in the egress pipeline.\n Applicable only if EGR_UNDERLAY_NHOP_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_transit_nhop_t = {
    .name = TNL_MPLS_TRANSIT_NHOPs, /* TNL_MPLS_TRANSIT_NHOP */
    .flags = BCMLTD_TABLE_F_TYPE_INDEX_ALLOC,
    .fields = 35,
    .field = bcmltd_tnl_mpls_transit_nhop_t_fields,
    .desc = "The TNL_MPLS_TRANSIT_NHOP table is used to specify next-hop parameters\n for transit MPLS tunnels.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_MPLS_VPN_ENCAP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_mpls_vpn_encap_t_fields[] = {
    {
        .name  = TNL_MPLS_VPN_ENCAP_IDs,  /* TNL_MPLS_VPN_ENCAP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the TNL_MPLS_VPN_ENCAP table.",
    },
    {
        .name  = LABELs,  /* LABEL */
        .flags = 0,
        .width = 20,
        .depth = 0,
        .desc = "VPN label in the outgoing MPLS label stack.",
    },
    {
        .name  = LABEL_TTLs,  /* LABEL_TTL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "MPLS label TTL value.",
    },
    {
        .name  = EXP_MODEs,  /* EXP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies how EXP value of the MPLS label stack will be determined.",
    },
    {
        .name  = LABEL_EXPs,  /* LABEL_EXP */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "EXP values to be set in the MPLS label stack.\n Applicable only if EXP_MODE == FIXED.\n",
    },
    {
        .name  = PHB_EGR_MPLS_IDs,  /* PHB_EGR_MPLS_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "If EXP_MODE == MAP:\n EXP value for this label is derived from the\n PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP  logical table index\n specified by PHB_EGR_MPLS_ID.\n If this is the outermost label, the 802.1p priority and CFI\n values for the outer VLAN tag are derived from the\n PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n\n If EXP_MODE == USE_INNER_LABEL:\n EXP value for this label is derived from the inner MPLS label.\n If there is no inner MPLS label, the LABEL_EXP value specified\n in this logical table is used as the EXP value.\n If this is the outermost label, the 802.1p priority and CFI\n values for the outer VLAN tag are derived from the\n PHB_EGR_MPLS_EXP_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n\n If EXP_MODE == USE_SWAP_LABEL:\n EXP value for this label is derived from the last decapped or\n swapped MPLS label.  If this is the outermost label, the 802.1p\n priority and CFI values for the outer VLAN tag are derived from\n the PHB_EGR_MPLS_EXP_TO_L2_OTAG logical table index\n specified by PHB_EGR_MPLS_ID.\n",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "DOT1P value for the outer L2 header.",
    },
    {
        .name  = CFIs,  /* CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "CFI value for the outer L2 header.",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_mpls_vpn_encap_t = {
    .name = TNL_MPLS_VPN_ENCAPs, /* TNL_MPLS_VPN_ENCAP */
    .flags = BCMLTD_TABLE_F_TYPE_INDEX_ALLOC,
    .fields = 8,
    .field = bcmltd_tnl_mpls_vpn_encap_t_fields,
    .desc = "The TNL_MPLS_VPN_ENCAP table is used to specify MPLS VPN tunnel encapsulation\n parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/tnl/TNL_PW_DECAP_SEQUENCE_NUMBER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_tnl_pw_decap_sequence_number_t_fields[] = {
    {
        .name  = TNL_PW_DECAP_SEQUENCE_NUMBER_IDs,  /* TNL_PW_DECAP_SEQUENCE_NUMBER_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Identifier of PW terminating sequence number.",
    },
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number.",
    },
    {
        .name  = SEQUENCE_NUMBERs,  /* SEQUENCE_NUMBER */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Real-time expected sequence number for the next PW packet.\n The difference value between the expected sequence number\n and the packet sequence number is compared against\n TNL_CONTROL.PW_DECAP_SEQUENCE_NUMBER_RANGE.\n",
    },
};
const bcmltd_table_rep_t bcmltd_tnl_pw_decap_sequence_number_t = {
    .name = TNL_PW_DECAP_SEQUENCE_NUMBERs, /* TNL_PW_DECAP_SEQUENCE_NUMBER */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_tnl_pw_decap_sequence_number_t_fields,
    .desc = "The TNL_PW_DECAP_SEQUENCE_NUMBER table specifies the expected sequence\n number used to perform validation on the terminated pseudowire (PW).\n If a packet fails the sequence number check, it is dropped. If a packet\n passes the sequence number check, the hardware automatically adds 1 to\n the sequence number extracted from the current packet's MPLS control word\n and writes back the SEQUENCE_NUMBER for checking against the next\n incoming PW packet.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_t_fields[] = {
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "TRUNK group identifier.",
    },
    {
        .name  = LB_MODEs,  /* LB_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Load balancing mode.",
    },
    {
        .name  = UC_RTAGs,  /* UC_RTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash rule tag for unicast packets.",
    },
    {
        .name  = UC_MAX_MEMBERSs,  /* UC_MAX_MEMBERS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum possible members of this trunk under all\n circumstances. Preallocating trunk resources can\n improve performance when processing a trunk change\n but may waste some resources.\n",
    },
    {
        .name  = UC_MEMBER_CNTs,  /* UC_MEMBER_CNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Actual count of members for unicast packets.",
    },
    {
        .name  = UC_MEMBER_MODIDs,  /* UC_MEMBER_MODID */
        .flags = 0,
        .width = 8,
        .depth = 256,
        .desc = "Module ID array of members for unicast packets.",
    },
    {
        .name  = UC_MEMBER_MODPORTs,  /* UC_MEMBER_MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 256,
        .desc = "Port ID array of members for unicast packets.",
    },
    {
        .name  = MON_AGM_POOLs,  /* MON_AGM_POOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation Group Monitor Pool for unicast packets.",
    },
    {
        .name  = MON_AGM_IDs,  /* MON_AGM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation Group Monitor Identifier for unicast packets.",
    },
    {
        .name  = NONUC_MEMBER_CNTs,  /* NONUC_MEMBER_CNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Member count for non-unicast packets.",
    },
    {
        .name  = NONUC_MEMBER_MODIDs,  /* NONUC_MEMBER_MODID */
        .flags = 0,
        .width = 8,
        .depth = 256,
        .desc = "Module ID array of members for non-unicast packets.",
    },
    {
        .name  = NONUC_MEMBER_MODPORTs,  /* NONUC_MEMBER_MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 256,
        .desc = "Port ID array of members for non-unicast packets.",
    },
    {
        .name  = UC_MEMBER_PORT_SYSTEMs,  /* UC_MEMBER_PORT_SYSTEM */
        .flags = 0,
        .width = 16,
        .depth = 256,
        .desc = "System port ID array of members for unicast packets.",
    },
    {
        .name  = NONUC_MEMBER_PORT_SYSTEMs,  /* NONUC_MEMBER_PORT_SYSTEM */
        .flags = 0,
        .width = 16,
        .depth = 256,
        .desc = "System port ID array of members for non-unicast packets.",
    },
    {
        .name  = MEMBER_L2_EIFs,  /* MEMBER_L2_EIF */
        .flags = 0,
        .width = 32,
        .depth = 256,
        .desc = "L2 outgoing interface ID array for trunk group.",
    },
    {
        .name  = UC_EGR_BLOCKs,  /* UC_EGR_BLOCK */
        .flags = 0,
        .width = 1,
        .depth = 256,
        .desc = "Enable to prevent the unicast members from receiving\n unicast traffic.\n",
    },
    {
        .name  = NONUC_EGR_BLOCKs,  /* NONUC_EGR_BLOCK */
        .flags = 0,
        .width = 1,
        .depth = 256,
        .desc = "Enable to prevent the non-unicast members from receiving\n non-unicast traffic.\n",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_t = {
    .name = TRUNKs, /* TRUNK */
    .flags = 0,
    .fields = 17,
    .field = bcmltd_trunk_t_fields,
    .desc = "The TRUNK table is used to specify a link aggregation group's\n physical port resolution criteria.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_config_t_fields[] = {
    {
        .name  = FAST_MODEs,  /* FAST_MODE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if fast trunk resolution is required.",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_config_t = {
    .name = TRUNK_CONFIGs, /* TRUNK_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 1,
    .field = bcmltd_trunk_config_t_fields,
    .desc = "Device configuration of trunk component.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_control_t_fields[] = {
    {
        .name  = UC_HASH_USE_SRC_PORTs,  /* UC_HASH_USE_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Use source port for hash computation of unicast packets.",
    },
    {
        .name  = NONUC_HASH_USE_DSTs,  /* NONUC_HASH_USE_DST */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Use L2/L3 dst MAC/IP for hash computation of non-unicast packets.",
    },
    {
        .name  = NONUC_HASH_USE_SRC_PORTs,  /* NONUC_HASH_USE_SRC_PORT */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Use source port for hash computation of non-unicast packets.",
    },
    {
        .name  = NONUC_HASH_USE_SRCs,  /* NONUC_HASH_USE_SRC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Use L2/L3 src MAC/IP for hash computation of non-unicast packets.",
    },
    {
        .name  = NONUC_HASH_USE_LB_HASHs,  /* NONUC_HASH_USE_LB_HASH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Use LB_HASH for hash computation of non-unicast packets.",
    },
    {
        .name  = LB_HASH_USE_FLOW_UCs,  /* LB_HASH_USE_FLOW_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Use flow based LB_HASH for unicast packets on trunk.",
    },
    {
        .name  = LB_HASH_USE_FLOW_NONUCs,  /* LB_HASH_USE_FLOW_NONUC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Use flow based LB_HASH for non-unicast packets on trunk.",
    },
    {
        .name  = LB_HASH_USE_FLOW_FAILOVERs,  /* LB_HASH_USE_FLOW_FAILOVER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Use flow based LB_HASH for trunk failover.",
    },
    {
        .name  = RANDOM_SEEDs,  /* RANDOM_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the seed for the random number generator which is\n used by the trunk group for load balancing of traffic across\n the trunk group member ports.\n Applicable only if TRUNK.LB_MODE == RANDOM.\n",
    },
    {
        .name  = SYSTEM_RANDOM_SEEDs,  /* SYSTEM_RANDOM_SEED */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the seed for the random number generator which is\n used by the system trunk group  for load balancing of\n traffic across the system trunk group member ports.\n Applicable only if TRUNK_SYSTEM.LB_MODE == RANDOM.\n",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_control_t = {
    .name = TRUNK_CONTROLs, /* TRUNK_CONTROL */
    .flags = 0,
    .fields = 10,
    .field = bcmltd_trunk_control_t_fields,
    .desc = "TRUNK_CONTROL logical table is used to configure chip-wide TRUNK\n parameters.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK_CTR_ING_EFLEX_ACTION.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_ctr_ing_eflex_action_t_fields[] = {
    {
        .name  = TRUNK_CTR_ING_EFLEX_ACTION_IDs,  /* TRUNK_CTR_ING_EFLEX_ACTION_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the TRUNK_CTR_ING_EFLEX_ACTION table.",
    },
    {
        .name  = ACTIONs,  /* ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specify an action.",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_ctr_ing_eflex_action_t = {
    .name = TRUNK_CTR_ING_EFLEX_ACTIONs, /* TRUNK_CTR_ING_EFLEX_ACTION */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_trunk_ctr_ing_eflex_action_t_fields,
    .desc = "TRUNK_CTR_ING_EFLEX_ACTION logical table is used to control device level\n TRUNK enhanced flex counter functions.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK_FAILOVER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_failover_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Logical port identifier which enables failover.",
    },
    {
        .name  = RTAGs,  /* RTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash rule tag for failover ports selection.",
    },
    {
        .name  = FAILOVER_CNTs,  /* FAILOVER_CNT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Count of failover ports.",
    },
    {
        .name  = FAILOVER_MODIDs,  /* FAILOVER_MODID */
        .flags = 0,
        .width = 8,
        .depth = 8,
        .desc = "Module ID array of failover ports.",
    },
    {
        .name  = FAILOVER_MODPORTs,  /* FAILOVER_MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 8,
        .desc = "Port array of failover ports.",
    },
    {
        .name  = FAILOVER_PORT_SYSTEMs,  /* FAILOVER_PORT_SYSTEM */
        .flags = 0,
        .width = 16,
        .depth = 8,
        .desc = "System port ID array of failover ports.",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_failover_t = {
    .name = TRUNK_FAILOVERs, /* TRUNK_FAILOVER */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_trunk_failover_t_fields,
    .desc = "The TRUNK_FAILOVER table is used to specify a set of failover ports for\n the specified port.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK_FAST.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_fast_t_fields[] = {
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Trunk group identifier.",
    },
    {
        .name  = LB_MODEs,  /* LB_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Load balancing mode for fast trunk group.",
    },
    {
        .name  = UC_RTAGs,  /* UC_RTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Hash rule tag for unicast packets.",
    },
    {
        .name  = UC_MEMBER_CNTs,  /* UC_MEMBER_CNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Actual count of members for unicast packets.",
    },
    {
        .name  = UC_MEMBER_MODIDs,  /* UC_MEMBER_MODID */
        .flags = 0,
        .width = 8,
        .depth = 64,
        .desc = "Module ID array of members for unicast packets.",
    },
    {
        .name  = UC_MEMBER_MODPORTs,  /* UC_MEMBER_MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "Port ID array of members for unicast packets.",
    },
    {
        .name  = MON_AGM_POOLs,  /* MON_AGM_POOL */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation Group Monitor Pool for unicast packets.",
    },
    {
        .name  = MON_AGM_IDs,  /* MON_AGM_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Aggregation Group Monitor Identifier for unicast packets.",
    },
    {
        .name  = NONUC_MEMBER_CNTs,  /* NONUC_MEMBER_CNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Member count for non-unicast packets.",
    },
    {
        .name  = NONUC_MEMBER_MODIDs,  /* NONUC_MEMBER_MODID */
        .flags = 0,
        .width = 8,
        .depth = 64,
        .desc = "Module ID array of members for non-unicast packets.",
    },
    {
        .name  = NONUC_MEMBER_MODPORTs,  /* NONUC_MEMBER_MODPORT */
        .flags = 0,
        .width = 16,
        .depth = 64,
        .desc = "Port ID array of members for non-unicast packets.",
    },
    {
        .name  = TRUNK_CTR_ING_EFLEX_ACTION_IDs,  /* TRUNK_CTR_ING_EFLEX_ACTION_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Select one enhanced flex counter action from\n TRUNK_CTR_ING_EFLEX_ACTION logical table.\n",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Enhanced flex counter object.",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_fast_t = {
    .name = TRUNK_FASTs, /* TRUNK_FAST */
    .flags = 0,
    .fields = 13,
    .field = bcmltd_trunk_fast_t_fields,
    .desc = "The TRUNK_FAST table is used to specify a low latency link aggregation\n group's physical port resolution criteria.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK_HASH_OUTPUT_SELECTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_hash_output_selection_profile_t_fields[] = {
    {
        .name  = TRUNK_HASH_OUTPUT_SELECTION_PROFILE_IDs,  /* TRUNK_HASH_OUTPUT_SELECTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into TRUNK_HASH_OUTPUT_SELECTION_PROFILE table.",
    },
    {
        .name  = HASH_FLOW_ID_SRC_UCs,  /* HASH_FLOW_ID_SRC_UC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The Flex Digest output sub-field selected as the source for generating\n LB_HASH_TRUNK_UC_OUTPUT_SELECTION.LB_HASH_TRUNK_UC_OUTPUT_SELECTION_ID,\n key field value, which is used in combination with the\n LB_HASH_INSTANCE key field to index into the\n LB_HASH_TRUNK_UC_OUTPUT_SELECTION logical table.\n",
    },
    {
        .name  = HASH_INSTANCE_UCs,  /* HASH_INSTANCE_UC */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hash table selection for unicast trunk.",
    },
    {
        .name  = HASH_FLOW_ID_SRC_NONUCs,  /* HASH_FLOW_ID_SRC_NONUC */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The Flex Digest output sub-field selected as the source for generating\n LB_HASH_TRUNK_NONUC_OUTPUT_SELECTION.LB_HASH_TRUNK_NONUC_OUTPUT_SELECTION_ID,\n key field value, which is used in combination with the\n LB_HASH_INSTANCE key field to index into the\n LB_HASH_TRUNK_NONUC_OUTPUT_SELECTION logical table.\n",
    },
    {
        .name  = HASH_USE_HIGIG3_ENTROPY_NONUCs,  /* HASH_USE_HIGIG3_ENTROPY_NONUC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable if the entropy value from the HIGIG3 header is\n used for hash computation during the non-unicast trunk\n resolution.\n",
    },
    {
        .name  = HASH_INSTANCE_NONUCs,  /* HASH_INSTANCE_NONUC */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hash table selection for non-unicast trunk.",
    },
    {
        .name  = HASH_FLOW_ID_SRC_FAILOVERs,  /* HASH_FLOW_ID_SRC_FAILOVER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The Flex Digest output sub-field selected as the source for generating\n LB_HASH_TRUNK_FAILOVER_OUTPUT_SELECTION.\n LB_HASH_TRUNK_FAILOVER_OUTPUT_SELECTION_ID,\n key field value, which is used in combination with the\n LB_HASH_INSTANCE key field to index into the\n LB_HASH_TRUNK_FAILOVER_OUTPUT_SELECTION logical table.\n",
    },
    {
        .name  = HASH_INSTANCE_FAILOVERs,  /* HASH_INSTANCE_FAILOVER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hash table selection for failover trunk.",
    },
    {
        .name  = HASH_FLOW_ID_SRC_SYSTEMs,  /* HASH_FLOW_ID_SRC_SYSTEM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The Flex Digest output sub-field selected as the source for generating\n LB_HASH_TRUNK_SYSTEM_OUTPUT_SELECTION.\n LB_HASH_TRUNK_SYSTEM_OUTPUT_SELECTION_ID,\n key field value, which is used in combination with the\n LB_HASH_INSTANCE key field to index into the\n LB_HASH_TRUNK_SYSTEM_OUTPUT_SELECTION logical table.\n",
    },
    {
        .name  = HASH_INSTANCE_SYSTEMs,  /* HASH_INSTANCE_SYSTEM */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hash table selection for system trunk.",
    },
    {
        .name  = HASH_FLOW_ID_SRC_SYSTEM_FAILOVERs,  /* HASH_FLOW_ID_SRC_SYSTEM_FAILOVER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "The Flex Digest output sub-field selected as the source for generating\n LB_HASH_TRUNK_SYSTEM_FAILOVER_OUTPUT_SELECTION.\n LB_HASH_TRUNK_SYSTEM_FAILOVER_OUTPUT_SELECTION_ID,\n key field value, which is used in combination with the\n LB_HASH_INSTANCE key field to index into the\n LB_HASH_TRUNK_SYSTEM_FAILOVER_OUTPUT_SELECTION logical table.\n",
    },
    {
        .name  = HASH_INSTANCE_SYSTEM_FAILOVERs,  /* HASH_INSTANCE_SYSTEM_FAILOVER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Hash table selection for failover system trunk.",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_hash_output_selection_profile_t = {
    .name = TRUNK_HASH_OUTPUT_SELECTION_PROFILEs, /* TRUNK_HASH_OUTPUT_SELECTION_PROFILE */
    .flags = 0,
    .fields = 12,
    .field = bcmltd_trunk_hash_output_selection_profile_t_fields,
    .desc = "The TRUNK_HASH_OUTPUT_SELECTION_PROFILE table to used to create\n hash output selection profile used for the trunk resolution.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK_SYSTEM.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_system_t_fields[] = {
    {
        .name  = TRUNK_SYSTEM_IDs,  /* TRUNK_SYSTEM_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into TRUNK_SYSTEM table.\n System link aggregation group identifier.\n",
    },
    {
        .name  = LB_MODEs,  /* LB_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Load balancing mode.",
    },
    {
        .name  = MAX_MEMBERSs,  /* MAX_MEMBERS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Maximum possible members of this\n system trunk group.\n",
    },
    {
        .name  = MEMBER_CNTs,  /* MEMBER_CNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Actual count of member logical ports.",
    },
    {
        .name  = MEMBER_PORT_IDs,  /* MEMBER_PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 128,
        .desc = "Logical port ID array of member ports.",
    },
    {
        .name  = RESOLUTION_DISABLEs,  /* RESOLUTION_DISABLE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Disables the system trunk group resolution.\n System trunk resolution is enabled by default.\n If system trunk resolution is disabled, copy of\n packet is sent to each member of the system trunk\n group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_system_t = {
    .name = TRUNK_SYSTEMs, /* TRUNK_SYSTEM */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_trunk_system_t_fields,
    .desc = "The TRUNK_SYSTEM table is used to specify the\n system link aggregation group local port\n resolution criteria.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK_SYSTEM_FAILOVER.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_system_failover_t_fields[] = {
    {
        .name  = TRUNK_SYSTEM_IDs,  /* TRUNK_SYSTEM_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into TRUNK_SYSTEM_FAILOVER table.\n System link aggregation group identifier.\n",
    },
    {
        .name  = FAILOVER_CNTs,  /* FAILOVER_CNT */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of failover ports.",
    },
    {
        .name  = FAILOVER_PORT_IDs,  /* FAILOVER_PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 8,
        .desc = "Logical port ID array of failover ports.",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_system_failover_t = {
    .name = TRUNK_SYSTEM_FAILOVERs, /* TRUNK_SYSTEM_FAILOVER */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_trunk_system_failover_t_fields,
    .desc = "The TRUNK_SYSTEM_FAILOVER table is used\n to specify the set of failover ports for the\n system trunk group.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK_SYSTEM_FAILOVER_PORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_system_failover_port_t_fields[] = {
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into TRUNK_SYSTEM_FAILOVER_PORT table.\n Logical port identifier.\n",
    },
    {
        .name  = FAILOVER_PORT_IDs,  /* FAILOVER_PORT_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies the backup port used for the switching of traffic\n during the failover of the member logical port.\n",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_system_failover_port_t = {
    .name = TRUNK_SYSTEM_FAILOVER_PORTs, /* TRUNK_SYSTEM_FAILOVER_PORT */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_trunk_system_failover_port_t_fields,
    .desc = "The TRUNK_SYSTEM_FAILOVER_PORT table is used to specify the alternate\n port used for the switching of traffic during the failover of\n the selected backup port for the system trunk group\n as specified in TRUNK_SYSTEM_FAILOVER table and if it is\n same as the resolved member port of the system trunk group.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK_VP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_vp_t_fields[] = {
    {
        .name  = TRUNK_VP_IDs,  /* TRUNK_VP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP Group Member index_0.",
    },
    {
        .name  = NHOP_INDEX_1s,  /* NHOP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 128,
        .desc = "Next hop table index. Inner Next hop table index in case of a Tunnel flow.",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 16,
        .depth = 128,
        .desc = "Destination VP.",
    },
    {
        .name  = NHOP_2_OR_ECMP_GROUP_INDEX_1s,  /* NHOP_2_OR_ECMP_GROUP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 128,
        .desc = "Next_hop_2 table index or ECMP Group index_2.",
    },
    {
        .name  = ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,  /* ECMP_AND_PROT_SWT_SFC_PROFILE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 128,
        .desc = "Encoding for ecmp_and_prot_swt_sfc_profile_index:\n               [1:0]: BITP/BOTP Profile Table index for ECMP and Protection Switching SF;\n               [2:2]: If set, nhop_2_or_ecmp_group_index_1 is ECMP Group 1 Table index else Next hop 2 table index;\n               [3:3]: If set, nhop_2_or_ecmp_group_index_1 carries the ecmp member 0 index to read the ecmp member table;\n",
    },
    {
        .name  = LB_MODEs,  /* LB_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the load balancing mode for VP trunk\n aggregation group.\n",
    },
    {
        .name  = MAX_MEMBERSs,  /* MAX_MEMBERS */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies the maximum number of members participating\n in the VP trunk group. Used to preallocate\n the resources for the VP trunk group.\n",
    },
    {
        .name  = MEMBER_CNTs,  /* MEMBER_CNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies the member count of VP trunk group members\n participating in the VP trunk group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_vp_t = {
    .name = TRUNK_VPs, /* TRUNK_VP */
    .flags = 0,
    .fields = 8,
    .field = bcmltd_trunk_vp_t_fields,
    .desc = "This table is looked up by ECMP Group Member index_0 which is\n     generated by ECMP Group_0 SF. This table provides the nexthop table index. It also\n     provides a DVP and an underlay next_hop_index or ecmp_group_index_1 in case of an L3\n     unicast packet switching into Layer 2 tunnel. In case of hierarchical ECMP mode for a\n     non_tunnel flow, it can provide ecmp_group_index_1 to resolve next level of ECMP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/trunk/TRUNK_VP_WEIGHTED.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_trunk_vp_weighted_t_fields[] = {
    {
        .name  = TRUNK_VP_IDs,  /* TRUNK_VP_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "ECMP Group Member index_0.",
    },
    {
        .name  = NHOP_INDEX_1s,  /* NHOP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 16384,
        .desc = "Next hop table index. Inner Next hop table index in case of a Tunnel flow.",
    },
    {
        .name  = DVPs,  /* DVP */
        .flags = 0,
        .width = 16,
        .depth = 16384,
        .desc = "Destination VP.",
    },
    {
        .name  = NHOP_2_OR_ECMP_GROUP_INDEX_1s,  /* NHOP_2_OR_ECMP_GROUP_INDEX_1 */
        .flags = 0,
        .width = 16,
        .depth = 16384,
        .desc = "Next_hop_2 table index or ECMP Group index_2.",
    },
    {
        .name  = ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,  /* ECMP_AND_PROT_SWT_SFC_PROFILE_INDEX */
        .flags = 0,
        .width = 8,
        .depth = 16384,
        .desc = "Encoding for ecmp_and_prot_swt_sfc_profile_index:\n               [1:0]: BITP/BOTP Profile Table index for ECMP and Protection Switching SF;\n               [2:2]: If set, nhop_2_or_ecmp_group_index_1 is ECMP Group 1 Table index else Next hop 2 table index;\n               [3:3]: If set, nhop_2_or_ecmp_group_index_1 carries the ecmp member 0 index to read the ecmp member table;\n",
    },
    {
        .name  = MEMBER_CNTs,  /* MEMBER_CNT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Specifies the member count of VP trunk group members\n participating in the VP trunk group.\n",
    },
    {
        .name  = WEIGHTED_SIZEs,  /* WEIGHTED_SIZE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Maximum number of members participating in the weighted\n VP trunk group.\n",
    },
};
const bcmltd_table_rep_t bcmltd_trunk_vp_weighted_t = {
    .name = TRUNK_VP_WEIGHTEDs, /* TRUNK_VP_WEIGHTED */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_trunk_vp_weighted_t_fields,
    .desc = "This table is looked up by ECMP Group Member index_0 which is\n     generated by ECMP Group_0 SF. This table provides the nexthop table index. It also\n     provides a DVP and an underlay next_hop_index or ecmp_group_index_1 in case of an L3\n     unicast packet switching into Layer 2 tunnel. In case of hierarchical ECMP mode for a\n     non_tunnel flow, it can provide ecmp_group_index_1 to resolve next level of ECMP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/udf/UDF.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_udf_t_fields[] = {
    {
        .name  = PIPEs,  /* PIPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Pipe number",
    },
    {
        .name  = PIPE_MASKs,  /* PIPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "MASK for PIPE.",
    },
    {
        .name  = ETAGs,  /* ETAG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to qualify if the port extender tag is present in\n the packet.\n",
    },
    {
        .name  = ETAG_MASKs,  /* ETAG_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for ETAG.",
    },
    {
        .name  = CNTAGs,  /* CNTAG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to qualify if the packet is CN-tagged.",
    },
    {
        .name  = CNTAG_MASKs,  /* CNTAG_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for CNTAG.",
    },
    {
        .name  = VNTAGs,  /* VNTAG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to qualify if the packet is VN-tagged.",
    },
    {
        .name  = VNTAG_MASKs,  /* VNTAG_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for VNTAG.",
    },
    {
        .name  = HIGIGs,  /* HIGIG */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to qualify if the packet has HIGIG header.",
    },
    {
        .name  = HIGIG_MASKs,  /* HIGIG_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for HIGIG.",
    },
    {
        .name  = PORT_IDs,  /* PORT_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ingress port on which this packet is received.",
    },
    {
        .name  = PORT_ID_MASKs,  /* PORT_ID_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for PORT_ID.",
    },
    {
        .name  = INBAND_TELEMETRYs,  /* INBAND_TELEMETRY */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to qualify if inband network telemetry is detected\n in outer L3/L4 header of the packet.\n",
    },
    {
        .name  = INBAND_TELEMETRY_MASKs,  /* INBAND_TELEMETRY_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for INBAND_TELEMETRY.",
    },
    {
        .name  = LOOPBACK_HDRs,  /* LOOPBACK_HDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Qualify for Loopback header in the packet.",
    },
    {
        .name  = LOOPBACK_HDR_MASKs,  /* LOOPBACK_HDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for LOOPBACK_HDR.",
    },
    {
        .name  = OPAQUE_TAG_TYPEs,  /* OPAQUE_TAG_TYPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "Opaque tag type of the packet.",
    },
    {
        .name  = OPAQUE_TAG_TYPE_MASKs,  /* OPAQUE_TAG_TYPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 2,
        .depth = 0,
        .desc = "MASK for OPAQUE_TAG_TYPE.",
    },
    {
        .name  = L4DST_PORTs,  /* L4DST_PORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Layer 4 TCP or UDP destination port number.",
    },
    {
        .name  = L4DST_PORT_MASKs,  /* L4DST_PORT_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for L4DST_PORT.",
    },
    {
        .name  = LOOPBACK_TYPEs,  /* LOOPBACK_TYPE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Loopback type of the packet.",
    },
    {
        .name  = LOOPBACK_TYPE_MASKs,  /* LOOPBACK_TYPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for LOOPBACK_TYPE.",
    },
    {
        .name  = L2_TYPEs,  /* L2_TYPE */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Protocol in the L2 header of the packet.",
    },
    {
        .name  = L2_TYPE_MASKs,  /* L2_TYPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for L2_TYPE.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype contained in the L2 header.",
    },
    {
        .name  = ETHERTYPE_MASKs,  /* ETHERTYPE_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "MASK for ETHERTYPE.",
    },
    {
        .name  = VLAN_TAGs,  /* VLAN_TAG */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Qualify for VLAN tag type present in the packet.",
    },
    {
        .name  = VLAN_TAG_MASKs,  /* VLAN_TAG_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for VLAN_TAG.",
    },
    {
        .name  = L3_FIELDSs,  /* L3_FIELDS */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 24,
        .depth = 0,
        .desc = "Protocol fields in L3 header stacks in the tunneled packet.\n (1) For IP-in-IP tunnel packet,\n     - bit [23:16] represent IP protocol in the outer IP stack.\n (2) For GRE tunnel packet,\n     - bit [23:16] represent IP protocol in the outer IP stack.\n     - bit [15:0] represent Ethertype in GRE header stack.\n (3) For MPLS tunnel packet,\n     - bit [19:4] represent 2 bytes after MPLS BOS.\n     - bit [3:0] represent number of labels in MPLS BOS.\n",
    },
    {
        .name  = L3_FIELDS_MASKs,  /* L3_FIELDS_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 24,
        .depth = 0,
        .desc = "MASK for L3_FIELDS.",
    },
    {
        .name  = OUTER_L3_HDRs,  /* OUTER_L3_HDR */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Protocol in the outer L3 header stack of the packet.",
    },
    {
        .name  = OUTER_L3_HDR_MASKs,  /* OUTER_L3_HDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for OUTER_L3_HDR.",
    },
    {
        .name  = INNER_L3_HDRs,  /* INNER_L3_HDR */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Protocol in the inner L3 header stack of the packet",
    },
    {
        .name  = INNER_L3_HDR_MASKs,  /* INNER_L3_HDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for INNER_L3_HDR.",
    },
    {
        .name  = OUTER_FCOE_HDRs,  /* OUTER_FCOE_HDR */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the outer fiber channel over ethernet\n (FCOE)configuration.\n",
    },
    {
        .name  = OUTER_FCOE_HDR_MASKs,  /* OUTER_FCOE_HDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for OUTER_FCOE_HDR.",
    },
    {
        .name  = INNER_FCOE_HDRs,  /* INNER_FCOE_HDR */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specifies the inner FCOE configuration.",
    },
    {
        .name  = INNER_FCOE_HDR_MASKs,  /* INNER_FCOE_HDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for INNER_FCOE_HDR.",
    },
    {
        .name  = OUTER_IFA_HDRs,  /* OUTER_IFA_HDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to qualify if the outer Inband Flow Analyzer (IFA) base\n header is present in the packet.\n",
    },
    {
        .name  = OUTER_IFA_HDR_MASKs,  /* OUTER_IFA_HDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for OUTER_IFA_HDR.",
    },
    {
        .name  = INNER_IFA_HDRs,  /* INNER_IFA_HDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Enable to qualify if the inner IFA base header is present\n in the packet.\n",
    },
    {
        .name  = INNER_IFA_HDR_MASKs,  /* INNER_IFA_HDR_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "MASK for INNER_IFA_HDR.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Priority associated with the entry.",
    },
    {
        .name  = UDF6_DATA_MASKs,  /* UDF6_DATA_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask to be used with UDF chunk 6 for UDF hashing. Applicable\n when UDF based hashing is enabled for bin2 by\n LB_HASH_BINS_ASSIGNMENT.HASH0_BIN2_UDF_EN or\n LB_HASH_BINS_ASSIGNMENT.HASH1_BIN2_UDF_EN.\n",
    },
    {
        .name  = UDF7_DATA_MASKs,  /* UDF7_DATA_MASK */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Mask to be used with UDF chunk 7 for UDF hashing. Applicable\n when UDF based hashing is enabled for bin3 by\n LB_HASH_BINS_ASSIGNMENT.HASH0_BIN3_UDF_EN or\n LB_HASH_BINS_ASSIGNMENT.HASH1_BIN3_UDF_EN.\n",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "UDF class ID that is used as a qualifier in the ingress FP.",
    },
    {
        .name  = FLEX_HASHs,  /* FLEX_HASH */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable lookup in LB_HASH_FLEX_FIELDS_SELECTION LT",
    },
    {
        .name  = SKIP_OUTER_IFA_METADATAs,  /* SKIP_OUTER_IFA_METADATA */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Skip outer IFA metadata, if packet has IFA header at the base\n offset specified by the LAYER field. The offset in the packet\n specified by OFFSET field starts after skipping IFA metadata header\n and added metadata specified by protocol field CURRENT LENGTH in\n the IFA metadata header.\n Adjustment can be applied to the base offset INNER_L3_HDR for\n the following packet:\n (1) Non-tunneled IP packets\n (2) Tunnel Packet with IFA in Tunnel only.\n Adjustment can be applied to the base offset L4_HDR for the\n following packet:\n (1) Non-tunneled IP packets.\n (2) Tunnel Packet with IFA in Tunnel only.\n (3) Tunnel Packet with IFA in payload only.\n (4) Tunnel Packet with IFA in Tunnel and payload both.\n",
    },
    {
        .name  = LAYERs,  /* LAYER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 16,
        .desc = "Base header for various protocol stack in the packet.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 8,
        .depth = 16,
        .desc = "Relative offset from the base header specified by the LAYER\n field to extract fields from the packet.\n",
    },
};
const bcmltd_table_rep_t bcmltd_udf_t = {
    .name = UDFs, /* UDF */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 50,
    .field = bcmltd_udf_t_fields,
    .desc = "The UDF table is used to UDF rules and select destination chunks\n for packet field extraction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/udf/UDF_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_udf_config_t_fields[] = {
    {
        .name  = UDF_OPERMODE_PIPEUNIQUEs,  /* UDF_OPERMODE_PIPEUNIQUE */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Following field indicates the operating modes of UDF. These modes\n are\n 1. global Mode\n 2. Pipe local mode\n By default, the configuration is 'Global Mode' with value set\n to FALSE. User can set value to TRUE for using UDF in pipe unique\n opearing mode during system init-configuration. This field is\n immutable during runtime.\n",
    },
};
const bcmltd_table_rep_t bcmltd_udf_config_t = {
    .name = UDF_CONFIGs, /* UDF_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 1,
    .field = bcmltd_udf_config_t_fields,
    .desc = "This LT is used to set operating mode of UDF.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/udf/UDF_FIELD_MUX_SELECT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_udf_field_mux_select_t_fields[] = {
    {
        .name  = UDF_FIELD_MUX_SELECT_IDs,  /* UDF_FIELD_MUX_SELECT_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Field mux profile identifier.",
    },
    {
        .name  = FORWARDING_CONTAINER_4_BYTEs,  /* FORWARDING_CONTAINER_4_BYTE */
        .flags = 0,
        .width = 1,
        .depth = 128,
        .desc = "Enable mux select for 4 byte forwarding container in field bus.",
    },
    {
        .name  = FORWARDING_CONTAINER_2_BYTEs,  /* FORWARDING_CONTAINER_2_BYTE */
        .flags = 0,
        .width = 1,
        .depth = 128,
        .desc = "Enable mux select for 2 byte forwarding container in field bus.",
    },
    {
        .name  = FORWARDING_CONTAINER_1_BYTEs,  /* FORWARDING_CONTAINER_1_BYTE */
        .flags = 0,
        .width = 1,
        .depth = 128,
        .desc = "Enable mux select for 1 byte forwarding container in field bus.",
    },
    {
        .name  = ALTERNATE_CONTAINER_2_BYTEs,  /* ALTERNATE_CONTAINER_2_BYTE */
        .flags = 0,
        .width = 1,
        .depth = 128,
        .desc = "Enable mux select for 2 byte alternate container in field bus.",
    },
};
const bcmltd_table_rep_t bcmltd_udf_field_mux_select_t = {
    .name = UDF_FIELD_MUX_SELECTs, /* UDF_FIELD_MUX_SELECT */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_udf_field_mux_select_t_fields,
    .desc = "The UDF_FIELD_MUX_SELECT table specifies tunnel termination profiles.\n By default, UDF containers are populated from the tunnel payload for all\n tunnel termination flows. In order to assign a particular container\n from a tunnel header, an user application needs to explicitly select this\n container for forwarding by enabling the appropriate mux select field.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/udf/UDF_POLICY.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_udf_policy_t_fields[] = {
    {
        .name  = UDF_POLICY_IDs,  /* UDF_POLICY_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Index into the UDF_POLICY table.",
    },
    {
        .name  = PACKET_HEADERs,  /* PACKET_HEADER */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "UDF anchor type used for extraction.",
    },
    {
        .name  = OFFSETs,  /* OFFSET */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Offset in the incoming packet from the\n given header type PACKET_HEADER.\n",
    },
    {
        .name  = CONTAINER_4_BYTEs,  /* CONTAINER_4_BYTE */
        .flags = 0,
        .width = 1,
        .depth = 128,
        .desc = "4 byte destination container used for UDF extraction.\n Number of available containers is auto generated by\n tooling.\n",
    },
    {
        .name  = CONTAINER_2_BYTEs,  /* CONTAINER_2_BYTE */
        .flags = 0,
        .width = 1,
        .depth = 128,
        .desc = "2 byte destination container used for UDF extraction.\n Number of available containers is auto generated by\n tooling.\n",
    },
    {
        .name  = CONTAINER_1_BYTEs,  /* CONTAINER_1_BYTE */
        .flags = 0,
        .width = 1,
        .depth = 128,
        .desc = "1 byte destination container used for UDF extraction.\n Number of available containers is auto generated by\n tooling.\n",
    },
};
const bcmltd_table_rep_t bcmltd_udf_policy_t = {
    .name = UDF_POLICYs, /* UDF_POLICY */
    .flags = 0,
    .fields = 6,
    .field = bcmltd_udf_policy_t_fields,
    .desc = "The UDF_POLICY table is used to program UDF rules and\n select destination containers for packet field extraction.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/udf/UDF_POLICY_INFO.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_udf_policy_info_t_fields[] = {
    {
        .name  = UDF_POLICY_INFO_IDs,  /* UDF_POLICY_INFO_ID */
        .flags = BCMLTD_FIELD_F_KEY | BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Index into the UDF_POLICY_INFO table.",
    },
    {
        .name  = MAX_CONTAINERs,  /* MAX_CONTAINER */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Maximum number of containers supported for\n the specified header type.\n",
    },
    {
        .name  = NUM_CONTAINER_4_BYTEs,  /* NUM_CONTAINER_4_BYTE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of 4 byte destination containers available for\n UDF extraction.\n",
    },
    {
        .name  = NUM_CONTAINER_2_BYTEs,  /* NUM_CONTAINER_2_BYTE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of 2 byte destination containers available for\n UDF extraction.\n",
    },
    {
        .name  = NUM_CONTAINER_1_BYTEs,  /* NUM_CONTAINER_1_BYTE */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Number of 1 byte destination containers available for\n UDF extraction.\n",
    },
};
const bcmltd_table_rep_t bcmltd_udf_policy_info_t = {
    .name = UDF_POLICY_INFOs, /* UDF_POLICY_INFO */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_udf_policy_info_t_fields,
    .desc = "The UDF_POLICY_INFO table is used to get the maximum container\n count that can be supported for the specified header type.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vfi/VFI.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vfi_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance (VFI) ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = MPLSs,  /* MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS.",
    },
    {
        .name  = VFI_PROFILE_IDs,  /* VFI_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VFI_PROFILE logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress FP key class ID.",
    },
    {
        .name  = VFI_STG_IDs,  /* VFI_STG_ID */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "VFI_STG logical table index.",
    },
    {
        .name  = VFI_ING_MEMBER_PORTS_PROFILE_IDs,  /* VFI_ING_MEMBER_PORTS_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "VFI_ING_MEMBER_PORTS_PROFILE_ID table index.",
    },
    {
        .name  = VFI_EGR_MEMBER_PORTS_PROFILE_IDs,  /* VFI_EGR_MEMBER_PORTS_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Index to VFI_EGR_MEMBER_PORTS_PROFILE table and\n VFI_EGR_UNTAGGED_MEMBER_PORTS_PROFILE table.\n",
    },
    {
        .name  = VFI_ING_EGR_MEMBER_PORTS_PROFILE_IDs,  /* VFI_ING_EGR_MEMBER_PORTS_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "VFI_ING_EGR_MEMBER_PORTS_PROFILE logical table index.",
    },
    {
        .name  = FORWARDING_BEHAVIORs,  /* FORWARDING_BEHAVIOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Forwarding behavior.",
    },
    {
        .name  = FIDs,  /* FID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Forwarding database ID.",
    },
    {
        .name  = IGMP_MLD_SNOOPINGs,  /* IGMP_MLD_SNOOPING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IGMP/MLD snooping.",
    },
    {
        .name  = REMARK_DOT1Ps,  /* REMARK_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable remarking PCP.",
    },
    {
        .name  = REMARK_CFIs,  /* REMARK_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable remarking CFI.",
    },
    {
        .name  = PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG_IDs,  /* PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG logical table index.\n Applicable only if REMARK_DOT1P or REMARK_CFI is enabled.\n",
    },
    {
        .name  = VLAN_OUTER_TPID_IDs,  /* VLAN_OUTER_TPID_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_OUTER_TPID logical table index.",
    },
    {
        .name  = NO_LEARNINGs,  /* NO_LEARNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to skip MAC source address learning.",
    },
    {
        .name  = EGR_VFI_MEMBERSHIP_CHECKs,  /* EGR_VFI_MEMBERSHIP_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable VFI membership check on the outgoing ports.",
    },
    {
        .name  = EGR_OVID_VALIDs,  /* EGR_OVID_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate EGR_OVID is valid.",
    },
    {
        .name  = EGR_OVIDs,  /* EGR_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Egress outer VLAN ID from VFI.",
    },
    {
        .name  = EGR_ADAPT_PORT_GRP_MODEs,  /* EGR_ADAPT_PORT_GRP_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Port group mode for egress adaptation.",
    },
    {
        .name  = VP_REPLICATIONs,  /* VP_REPLICATION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enables virtual port replication to this VFI using\n replication indices specified by the L3_UNKNOWN_UC_GRP_ID,\n L3_UNKNOWN_MC_GRP_ID or L3_BC_GRP_ID fields.\n",
    },
    {
        .name  = L3_UNKOWN_UC_GRP_IDs,  /* L3_UNKOWN_UC_GRP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The L3 multicast group used to represent an\n unknown unicast flood into the associated VFI.\n Applicable if VP_REPLICATION is enabled.\n",
    },
    {
        .name  = L3_UNKOWN_MC_GRP_IDs,  /* L3_UNKOWN_MC_GRP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The L3 multicast group used to represent an\n unknown multicast flood into the associated VFI.\n Applicable if VP_REPLICATION is enabled.\n",
    },
    {
        .name  = L3_BC_GRP_IDs,  /* L3_BC_GRP_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "The L3 multicast group used to represent a\n broadcast flood into the associated VFI.\n Applicable if VP_REPLICATION is enabled.\n",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter action.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress enhanced flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_vfi_t = {
    .name = VFIs, /* VFI */
    .flags = 0,
    .fields = 27,
    .field = bcmltd_vfi_t_fields,
    .desc = "The VFI table specifies the VFI properties and functionalities.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vfi/VFI_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vfi_control_t_fields[] = {
    {
        .name  = UNKNOWN_VLAN_TO_CPUs,  /* UNKNOWN_VLAN_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of packets with unknown VLAN ID to CPU.",
    },
    {
        .name  = PRIVATE_VLAN_MISMATCH_TO_CPUs,  /* PRIVATE_VLAN_MISMATCH_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of packets to CPU when ING_VLAN in the PORT_PVLAN\n logical table is true and the forwarding VLAN ID of\n the packets is not equal to PORT.ING_OVID.\n",
    },
    {
        .name  = ING_ADAPT_LOOKUP_MISS_TO_CPUs,  /* ING_ADAPT_LOOKUP_MISS_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of packets to CPU when ingress VFI adaption lookup\n with OVID and port group ID is miss.\n",
    },
    {
        .name  = DROP_INVALID_VLAN_BPDUs,  /* DROP_INVALID_VLAN_BPDU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable drop of BPDU packets with invalid VLAN ID.",
    },
    {
        .name  = SHARED_VFIs,  /* SHARED_VFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use VFI.FID instead of VFI as\n the key for L2 learning and lookup.\n",
    },
    {
        .name  = MATCH_NON_ZERO_OUI_SNAPs,  /* MATCH_NON_ZERO_OUI_SNAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match SNAP packets with non-zero OUI as SNAP header.",
    },
    {
        .name  = GLOBAL_SHARED_VFIs,  /* GLOBAL_SHARED_VFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use GLOBAL_FID for L2 learning and lookup.",
    },
    {
        .name  = GLOBAL_FIDs,  /* GLOBAL_FID */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Global forwarding database ID. Applicable only if GLOBAL_SHARED_VFI\n is enabled.\n",
    },
    {
        .name  = EGR_STG_CHECKs,  /* EGR_STG_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check egress port's spanning tree state.",
    },
};
const bcmltd_table_rep_t bcmltd_vfi_control_t = {
    .name = VFI_CONTROLs, /* VFI_CONTROL */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_vfi_control_t_fields,
    .desc = "The VFI_CONTROL table is used to specify device level VFI functions.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vfi/VFI_EGR_ADAPT_PORT_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vfi_egr_adapt_port_grp_t_fields[] = {
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance.",
    },
    {
        .name  = PORT_GRPs,  /* PORT_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Port group ID.",
    },
    {
        .name  = VXLAN_DECAPs,  /* VXLAN_DECAP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "VXLAN tunnel decapsulation status.",
    },
    {
        .name  = VLAN_TAG_PRESENT_ACTIONs,  /* VLAN_TAG_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 tag action if the tag is present.",
    },
    {
        .name  = VLAN_TAG_NOT_PRESENT_ACTIONs,  /* VLAN_TAG_NOT_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 tag action if the tag is not present.",
    },
    {
        .name  = L2_OPAQUE_TAG_PRESENT_ACTIONs,  /* L2_OPAQUE_TAG_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 opaque tag action if the tag is present.",
    },
    {
        .name  = L2_OPAQUE_TAG_NOT_PRESENT_ACTIONs,  /* L2_OPAQUE_TAG_NOT_PRESENT_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 opaque tag action if the tag is not present.",
    },
    {
        .name  = IS_PHB_MAP_IDs,  /* IS_PHB_MAP_ID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to indicate a PHB map table index is used.",
    },
    {
        .name  = REMARK_CFIs,  /* REMARK_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable remarking CFI.",
    },
    {
        .name  = OCFIs,  /* OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI. Applicable only if IS_PHB_MAP_ID is disabled.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority. Applicable only if IS_PHB_MAP_ID\n is disabled.\n",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_OTAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_OTAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Index into logical table PHB_EGR_L2_INT_PRI_TO_OTAG.\n Applicable only if IS_PHB_MAP_ID is enabled.\n",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = VLAN_OUTER_TPID_IDs,  /* VLAN_OUTER_TPID_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_OUTER_TPID logical table index.",
    },
    {
        .name  = PORT_DVP_IDs,  /* PORT_DVP_ID */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Destination virtual port.",
    },
    {
        .name  = DVP_GRPs,  /* DVP_GRP */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Destination virtual port group ID.",
    },
    {
        .name  = CTR_EGR_EFLEX_OBJECTs,  /* CTR_EGR_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress flex counter object.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "Egress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_vfi_egr_adapt_port_grp_t = {
    .name = VFI_EGR_ADAPT_PORT_GRPs, /* VFI_EGR_ADAPT_PORT_GRP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 18,
    .field = bcmltd_vfi_egr_adapt_port_grp_t_fields,
    .desc = "The VFI_EGR_ADAPT_PORT_GRP table specifies the VFI egress adaptation\n parameters. In the adaptation L2 tag action are derived based on VFI and\n egress port group ID and VXLAN tunnel decapsulation status.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vfi/VFI_EGR_ADAPT_PORT_GRP_KEY_MASK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vfi_egr_adapt_port_grp_key_mask_t_fields[] = {
    {
        .name  = GLOBAL_KEY_MASKs,  /* GLOBAL_KEY_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to set global key mask.",
    },
    {
        .name  = VFI_ID_MASKs,  /* VFI_ID_MASK */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance mask.",
    },
    {
        .name  = PORT_GRP_MASKs,  /* PORT_GRP_MASK */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "Port group ID mask.",
    },
    {
        .name  = VXLAN_DECAP_MASKs,  /* VXLAN_DECAP_MASK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "VXLAN tunnel decapsulation status mask.",
    },
};
const bcmltd_table_rep_t bcmltd_vfi_egr_adapt_port_grp_key_mask_t = {
    .name = VFI_EGR_ADAPT_PORT_GRP_KEY_MASKs, /* VFI_EGR_ADAPT_PORT_GRP_KEY_MASK */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_vfi_egr_adapt_port_grp_key_mask_t_fields,
    .desc = "The VFI_EGR_ADAPT_PORT_GRP_KEY_MASK table specifies\n the global key mask for VFI_EGR_ADAPT_PORT_GRP.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vfi/VFI_EGR_MEMBER_PORTS_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vfi_egr_member_ports_profile_t_fields[] = {
    {
        .name  = VFI_EGR_MEMBER_PORTS_PROFILE_IDs,  /* VFI_EGR_MEMBER_PORTS_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VFI_EGR_MEMBER_PORTS_PROFILE logical table index.",
    },
    {
        .name  = MEMBER_PORTSs,  /* MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Egress member ports.",
    },
};
const bcmltd_table_rep_t bcmltd_vfi_egr_member_ports_profile_t = {
    .name = VFI_EGR_MEMBER_PORTS_PROFILEs, /* VFI_EGR_MEMBER_PORTS_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vfi_egr_member_ports_profile_t_fields,
    .desc = "The VFI_EGR_MEMBER_PORTS_PROFILE table specifies VFI egress member ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vfi/VFI_EGR_UNTAGGED_MEMBER_PORTS_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vfi_egr_untagged_member_ports_profile_t_fields[] = {
    {
        .name  = VFI_EGR_MEMBER_PORTS_PROFILE_IDs,  /* VFI_EGR_MEMBER_PORTS_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VFI_EGR_UNTAGGED_MEMBER_PORTS_PROFILE logical table index.",
    },
    {
        .name  = MEMBER_PORTSs,  /* MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Untagged member ports.",
    },
};
const bcmltd_table_rep_t bcmltd_vfi_egr_untagged_member_ports_profile_t = {
    .name = VFI_EGR_UNTAGGED_MEMBER_PORTS_PROFILEs, /* VFI_EGR_UNTAGGED_MEMBER_PORTS_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vfi_egr_untagged_member_ports_profile_t_fields,
    .desc = "The VFI_EGR_UNTAGGED_MEMBER_PORTS_PROFILE table specifies VFI egress untagged\n member ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vfi/VFI_ING_ADAPT_OVID_PORT_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vfi_ing_adapt_ovid_port_grp_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = PORT_GRPs,  /* PORT_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Port group ID.",
    },
    {
        .name  = VFI_IDs,  /* VFI_ID */
        .flags = 0,
        .width = 13,
        .depth = 0,
        .desc = "Virtual forwarding instance.",
    },
    {
        .name  = PORT_SVP_IDs,  /* PORT_SVP_ID */
        .flags = 0,
        .width = 14,
        .depth = 0,
        .desc = "Source virtual port.",
    },
    {
        .name  = CTR_ING_EFLEX_OBJECTs,  /* CTR_ING_EFLEX_OBJECT */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter object.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_vfi_ing_adapt_ovid_port_grp_t = {
    .name = VFI_ING_ADAPT_OVID_PORT_GRPs, /* VFI_ING_ADAPT_OVID_PORT_GRP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 6,
    .field = bcmltd_vfi_ing_adapt_ovid_port_grp_t_fields,
    .desc = "The VFI_ING_ADAPT_OVID_PORT_GRP table specifies the VFI ingress adaptation\n parameters. In the adaptation VFI and SVP are assigned based on outer VID and\n port group ID.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vfi/VFI_ING_EGR_MEMBER_PORTS_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vfi_ing_egr_member_ports_profile_t_fields[] = {
    {
        .name  = VFI_ING_EGR_MEMBER_PORTS_PROFILE_IDs,  /* VFI_ING_EGR_MEMBER_PORTS_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VFI_ING_EGR_MEMBER_PORTS_PROFILE logical table index.",
    },
    {
        .name  = EGR_MEMBER_PORTSs,  /* EGR_MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Egress member ports.",
    },
};
const bcmltd_table_rep_t bcmltd_vfi_ing_egr_member_ports_profile_t = {
    .name = VFI_ING_EGR_MEMBER_PORTS_PROFILEs, /* VFI_ING_EGR_MEMBER_PORTS_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vfi_ing_egr_member_ports_profile_t_fields,
    .desc = "The VFI_ING_EGR_MEMBER_PORTS_PROFILE table specifies egress member ports\n in the ingress pipeline.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vfi/VFI_ING_MEMBER_PORTS_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vfi_ing_member_ports_profile_t_fields[] = {
    {
        .name  = VFI_ING_MEMBER_PORTS_PROFILE_IDs,  /* VFI_ING_MEMBER_PORTS_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VFI_ING_MEMBER_PORTS_PROFILE logical table index.",
    },
    {
        .name  = MEMBER_PORTSs,  /* MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Ingress member ports.",
    },
};
const bcmltd_table_rep_t bcmltd_vfi_ing_member_ports_profile_t = {
    .name = VFI_ING_MEMBER_PORTS_PROFILEs, /* VFI_ING_MEMBER_PORTS_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vfi_ing_member_ports_profile_t_fields,
    .desc = "The VFI_ING_MEMBER_PORTS_PROFILE table specifies VFI ingress member ports.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vfi/VFI_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vfi_profile_t_fields[] = {
    {
        .name  = VFI_PROFILE_IDs,  /* VFI_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "VFI profile ID.",
    },
    {
        .name  = PORT_PKT_CONTROL_IDs,  /* PORT_PKT_CONTROL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PORT_PKT_CONTROL_ID logical table index.",
    },
    {
        .name  = VLAN_OUTER_TPID_IDs,  /* VLAN_OUTER_TPID_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_OUTER_TPID logical table index.",
    },
    {
        .name  = PHB_ING_L2_OTAG_MAPs,  /* PHB_ING_L2_OTAG_MAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust outer vlan tag and map 802.1p/CFI bits\n of the outer vlan tag to PHB.\n",
    },
    {
        .name  = PHB_ING_L2_TAGGED_TO_INT_PRI_IDs,  /* PHB_ING_L2_TAGGED_TO_INT_PRI_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_L2_TAGGED_TO_INT_PRI logical table index.\n Applicable only if PHB_ING_L2_OTAG_MAP is enabled.\n",
    },
    {
        .name  = L3_IPV6_PFMs,  /* L3_IPV6_PFM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "IPv6 multicast packet flooding mode.",
    },
    {
        .name  = L3_IPV4_PFMs,  /* L3_IPV4_PFM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 multicast packet flooding mode.",
    },
    {
        .name  = L2_PFMs,  /* L2_PFM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 multicast packet flooding mode.",
    },
    {
        .name  = L2_NON_UCAST_TOCPUs,  /* L2_NON_UCAST_TOCPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of L2 non-unicast packets to CPU.",
    },
    {
        .name  = L2_NON_UCAST_DROPs,  /* L2_NON_UCAST_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping L2 non-unicast packets.",
    },
    {
        .name  = L2_MISS_TOCPUs,  /* L2_MISS_TOCPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of L2 miss lookup packets to CPU.",
    },
    {
        .name  = L2_MISS_DROPs,  /* L2_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping L2 miss lookup packets.",
    },
    {
        .name  = IPV6_MC_L2_FWDs,  /* IPV6_MC_L2_FWD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2-only forwarding for IPv6 multicast packets.",
    },
    {
        .name  = IPV4_MC_L2_FWDs,  /* IPV4_MC_L2_FWD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2-only forwarding for IPv4 multicast packets.",
    },
    {
        .name  = BLOCK_MASK_As,  /* BLOCK_MASK_A */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Inverse of mask A ANDed with the port bitmap.",
    },
    {
        .name  = BLOCK_MASK_Bs,  /* BLOCK_MASK_B */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Inverse of mask B ANDed with the port bitmap.",
    },
    {
        .name  = UNKNOWN_UC_MASK_MODEs,  /* UNKNOWN_UC_MASK_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask mode for unknown unicast packets between mask A and mask B.",
    },
    {
        .name  = UNKNOWN_MC_MASK_MODEs,  /* UNKNOWN_MC_MASK_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask mode for unknown multicast packets between mask A and mask B.",
    },
    {
        .name  = MC_MASK_MODEs,  /* MC_MASK_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask mode for known multicast packets between mask A and mask B.",
    },
    {
        .name  = BC_MASK_MODEs,  /* BC_MASK_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask mode for broadcast packets between mask A and mask B.",
    },
    {
        .name  = VFI_ING_MEMBERSHIP_CHECKs,  /* VFI_ING_MEMBERSHIP_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable VFI membership check on the ingoing ports.",
    },
};
const bcmltd_table_rep_t bcmltd_vfi_profile_t = {
    .name = VFI_PROFILEs, /* VFI_PROFILE */
    .flags = 0,
    .fields = 21,
    .field = bcmltd_vfi_profile_t_fields,
    .desc = "The VFI_PROFILE table specifies the VFI functionality profile.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vfi/VFI_STG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vfi_stg_t_fields[] = {
    {
        .name  = VFI_STG_IDs,  /* VFI_STG_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Spanning tree group ID.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 272,
        .desc = "Spanning tree group forwarding state per-port.",
    },
};
const bcmltd_table_rep_t bcmltd_vfi_stg_t = {
    .name = VFI_STGs, /* VFI_STG */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vfi_stg_t_fields,
    .desc = "The VFI_STG table specifies the spanning tree group state configuration.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_t_fields[] = {
    {
        .name  = VLAN_IDs,  /* VLAN_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "VLAN ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.",
    },
    {
        .name  = MPLSs,  /* MPLS */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MPLS.",
    },
    {
        .name  = VLAN_PROFILE_IDs,  /* VLAN_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_PROFILE logical table index.",
    },
    {
        .name  = CLASS_IDs,  /* CLASS_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress FP key class ID.",
    },
    {
        .name  = VLAN_STG_IDs,  /* VLAN_STG_ID */
        .flags = 0,
        .width = 9,
        .depth = 0,
        .desc = "VLAN_STG logical table index.",
    },
    {
        .name  = ING_MEMBER_PORTSs,  /* ING_MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Ingress member ports.",
    },
    {
        .name  = ING_EGR_MEMBER_PORTSs,  /* ING_EGR_MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Egress member ports in the ingress pipeline.",
    },
    {
        .name  = EGR_MEMBER_PORTSs,  /* EGR_MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Egress members ports.",
    },
    {
        .name  = VLAN_ING_EGR_MEMBER_PORTS_PROFILE_IDs,  /* VLAN_ING_EGR_MEMBER_PORTS_PROFILE_ID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "VLAN_ING_EGR_MEMBER_PORTS_PROFILE logical table index.",
    },
    {
        .name  = FORWARDING_BEHAVIORs,  /* FORWARDING_BEHAVIOR */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Forwarding behavior.",
    },
    {
        .name  = FIDs,  /* FID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Filtering database ID.",
    },
    {
        .name  = IGMP_MLD_SNOOPINGs,  /* IGMP_MLD_SNOOPING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable IGMP/MLD snooping.",
    },
    {
        .name  = UNTAGGED_MEMBER_PORTSs,  /* UNTAGGED_MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Untagged membership ports.",
    },
    {
        .name  = REMARK_DOT1Ps,  /* REMARK_DOT1P */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable remarking PCP.",
    },
    {
        .name  = REMARK_CFIs,  /* REMARK_CFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable remarking CFI.",
    },
    {
        .name  = PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG_IDs,  /* PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_VLAN_INT_PRI_TO_L2_OTAG logical table index.\n Applicable only if REMARK_DOT1P or REMARK_CFI is enabled.\n",
    },
    {
        .name  = VLAN_OUTER_TPID_IDs,  /* VLAN_OUTER_TPID_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_OUTER_TPID logical table index.",
    },
    {
        .name  = DOT1P_MAPPING_IDs,  /* DOT1P_MAPPING_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PCP remark ID.",
    },
    {
        .name  = SRC_PVLAN_PORT_TYPEs,  /* SRC_PVLAN_PORT_TYPE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Private VLAN source port type.",
    },
    {
        .name  = CTR_ING_FLEX_POOL_NUMBERs,  /* CTR_ING_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter ingress pool number.",
    },
    {
        .name  = CTR_ING_FLEX_BASE_INDEXs,  /* CTR_ING_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_ING_FLEX_OFFSET_MODEs,  /* CTR_ING_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = CTR_EGR_FLEX_POOL_NUMBERs,  /* CTR_EGR_FLEX_POOL_NUMBER */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter egress pool number.",
    },
    {
        .name  = CTR_EGR_FLEX_BASE_INDEXs,  /* CTR_EGR_FLEX_BASE_INDEX */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter base index.",
    },
    {
        .name  = CTR_EGR_FLEX_OFFSET_MODEs,  /* CTR_EGR_FLEX_OFFSET_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Specify flexible counter offset mode.",
    },
    {
        .name  = CTR_ING_EFLEX_ACTIONs,  /* CTR_ING_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress enhanced flex counter action.",
    },
    {
        .name  = CTR_EGR_EFLEX_ACTIONs,  /* CTR_EGR_EFLEX_ACTION */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress enhanced flex counter action.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_t = {
    .name = VLANs, /* VLAN */
    .flags = 0,
    .fields = 28,
    .field = bcmltd_vlan_t_fields,
    .desc = "The VLAN table specifies the VLAN properties and functionalites.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ASSIGNMENT_INNER_VLAN_RANGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_assignment_inner_vlan_range_t_fields[] = {
    {
        .name  = VLAN_ASSIGNMENT_INNER_VLAN_RANGE_IDs,  /* VLAN_ASSIGNMENT_INNER_VLAN_RANGE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ASSIGNMENT_INNER_VLAN_RANGE logical table index.",
    },
    {
        .name  = VLAN_ID_MINs,  /* VLAN_ID_MIN */
        .flags = 0,
        .width = 12,
        .depth = 8,
        .desc = "VLAN ID range min array.",
    },
    {
        .name  = VLAN_ID_MAXs,  /* VLAN_ID_MAX */
        .flags = 0,
        .width = 12,
        .depth = 8,
        .desc = "VLAN ID range max array.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_assignment_inner_vlan_range_t = {
    .name = VLAN_ASSIGNMENT_INNER_VLAN_RANGEs, /* VLAN_ASSIGNMENT_INNER_VLAN_RANGE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_vlan_assignment_inner_vlan_range_t_fields,
    .desc = "The VLAN_ASSIGNMENT_INNER_VLAN_RANGE table specifies the inner VLAN range based\n VLAN assignment functionality.\n The primary purpose of the table is to compress an inner VLAN range to one inner VLAN ID.\n If the packet's inner VLAN falls in the range [VLAN_ID_MIN, VLAN_ID_MAX],\n the inner VLAN will be replaced with VLAN_ID_MIN.\n If the inner VLAN falls outside of any specified range, it will remain unchanged.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ASSIGNMENT_IPV4.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_assignment_ipv4_t_fields[] = {
    {
        .name  = IPV4s,  /* IPV4 */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "IP address.",
    },
    {
        .name  = IPV4_MASKs,  /* IPV4_MASK */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 32,
        .depth = 0,
        .desc = "MASK for IPV4.",
    },
    {
        .name  = ENTRY_PRIORITYs,  /* ENTRY_PRIORITY */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "Entry priority.",
    },
    {
        .name  = OCFIs,  /* OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = ICFIs,  /* ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = IPRIs,  /* IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_assignment_ipv4_t = {
    .name = VLAN_ASSIGNMENT_IPV4s, /* VLAN_ASSIGNMENT_IPV4 */
    .flags = BCMLTD_TABLE_F_TYPE_TCAM,
    .fields = 10,
    .field = bcmltd_vlan_assignment_ipv4_t_fields,
    .desc = "The VLAN_ASSIGNMENT_IPV4 table specifies the IPV4 address based\n VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ASSIGNMENT_MAC.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_assignment_mac_t_fields[] = {
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MAC address.",
    },
    {
        .name  = OCFIs,  /* OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer priority.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = ICFIs,  /* ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = IPRIs,  /* IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ASSIGNs,  /* VLAN_ASSIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation is valid.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_assignment_mac_t = {
    .name = VLAN_ASSIGNMENT_MACs, /* VLAN_ASSIGNMENT_MAC */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 9,
    .field = bcmltd_vlan_assignment_mac_t_fields,
    .desc = "The VLAN_ASSIGNMENT_MAC table specifies the MAC address based\n VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ASSIGNMENT_MAC_MODPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_assignment_mac_modport_t_fields[] = {
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MAC address.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Module ID.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "System port.",
    },
    {
        .name  = OCFIs,  /* OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer priority.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = ICFIs,  /* ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = IPRIs,  /* IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ASSIGNs,  /* VLAN_ASSIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation is valid.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_assignment_mac_modport_t = {
    .name = VLAN_ASSIGNMENT_MAC_MODPORTs, /* VLAN_ASSIGNMENT_MAC_MODPORT */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 11,
    .field = bcmltd_vlan_assignment_mac_modport_t_fields,
    .desc = "The VLAN_ASSIGNMENT_MAC_MODPORT table specifies the MAC address\n and MODPORT based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ASSIGNMENT_MAC_PORT_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_assignment_mac_port_grp_t_fields[] = {
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MAC address.",
    },
    {
        .name  = PORT_GRPs,  /* PORT_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Port group.",
    },
    {
        .name  = OCFIs,  /* OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer priority.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = ICFIs,  /* ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = IPRIs,  /* IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ASSIGNs,  /* VLAN_ASSIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation is valid.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_assignment_mac_port_grp_t = {
    .name = VLAN_ASSIGNMENT_MAC_PORT_GRPs, /* VLAN_ASSIGNMENT_MAC_PORT_GRP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 10,
    .field = bcmltd_vlan_assignment_mac_port_grp_t_fields,
    .desc = "The VLAN_ASSIGNMENT_MAC_PORT_GRP table specifies the MAC address\n and port group based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ASSIGNMENT_MAC_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_assignment_mac_trunk_t_fields[] = {
    {
        .name  = MAC_ADDRs,  /* MAC_ADDR */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 48,
        .depth = 0,
        .desc = "MAC address.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Trunk ID.",
    },
    {
        .name  = OCFIs,  /* OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer priority.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = ICFIs,  /* ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = IPRIs,  /* IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ASSIGNs,  /* VLAN_ASSIGN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation is valid.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_assignment_mac_trunk_t = {
    .name = VLAN_ASSIGNMENT_MAC_TRUNKs, /* VLAN_ASSIGNMENT_MAC_TRUNK */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 10,
    .field = bcmltd_vlan_assignment_mac_trunk_t_fields,
    .desc = "The VLAN_ASSIGNMENT_MAC_TRUNK table specifies the MAC address\n and TRUNK group based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ASSIGNMENT_OUTER_VLAN_RANGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_assignment_outer_vlan_range_t_fields[] = {
    {
        .name  = VLAN_ASSIGNMENT_OUTER_VLAN_RANGE_IDs,  /* VLAN_ASSIGNMENT_OUTER_VLAN_RANGE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ASSIGNMENT_OUTER_VLAN_RANGE logical table index.",
    },
    {
        .name  = VLAN_ID_MINs,  /* VLAN_ID_MIN */
        .flags = 0,
        .width = 12,
        .depth = 8,
        .desc = "VLAN ID range min array.",
    },
    {
        .name  = VLAN_ID_MAXs,  /* VLAN_ID_MAX */
        .flags = 0,
        .width = 12,
        .depth = 8,
        .desc = "VLAN ID range max array.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_assignment_outer_vlan_range_t = {
    .name = VLAN_ASSIGNMENT_OUTER_VLAN_RANGEs, /* VLAN_ASSIGNMENT_OUTER_VLAN_RANGE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_vlan_assignment_outer_vlan_range_t_fields,
    .desc = "The VLAN_ASSIGNMENT_OUTER_VLAN_RANGE table specifies the outer VLAN range based\n VLAN assignment functionality.\n The primary purpose of the table is to compress an outer VLAN range to one outer VLAN ID.\n If the packet's outer VLAN falls in the range [VLAN_ID_MIN, VLAN_ID_MAX],\n the outer VLAN will be replaced with VLAN_ID_MIN.\n If the outer VLAN falls outside of any specified range, it will remain unchanged.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ASSIGNMENT_PROTOCOL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_assignment_protocol_t_fields[] = {
    {
        .name  = VLAN_ASSIGNMENT_PROTOCOL_IDs,  /* VLAN_ASSIGNMENT_PROTOCOL_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the protocol based VLAN assignment table.",
    },
    {
        .name  = VLAN_PROTOCOL_MATCH_IDs,  /* VLAN_PROTOCOL_MATCH_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_PROTOCOL_MATCH logical table index.",
    },
    {
        .name  = OCFIs,  /* OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = ICFIs,  /* ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = IPRIs,  /* IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_assignment_protocol_t = {
    .name = VLAN_ASSIGNMENT_PROTOCOLs, /* VLAN_ASSIGNMENT_PROTOCOL */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_vlan_assignment_protocol_t_fields,
    .desc = "The VLAN_ASSIGNMENT_PROTOCOL table specifies the protocol\n based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ASSIGNMENT_VLAN_RANGE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_assignment_vlan_range_t_fields[] = {
    {
        .name  = VLAN_ASSIGNMENT_VLAN_RANGE_IDs,  /* VLAN_ASSIGNMENT_VLAN_RANGE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the VLAN range assignment table.\n",
    },
    {
        .name  = VLAN_ID_MINs,  /* VLAN_ID_MIN */
        .flags = 0,
        .width = 12,
        .depth = 8,
        .desc = "VLAN ID range min array.",
    },
    {
        .name  = VLAN_ID_MAXs,  /* VLAN_ID_MAX */
        .flags = 0,
        .width = 12,
        .depth = 8,
        .desc = "VLAN ID range max array.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_assignment_vlan_range_t = {
    .name = VLAN_ASSIGNMENT_VLAN_RANGEs, /* VLAN_ASSIGNMENT_VLAN_RANGE */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_vlan_assignment_vlan_range_t_fields,
    .desc = "The VLAN_ASSIGNMENT_VLAN_RANGE table specifies the VLAN range based\n VLAN assignment functionality.\n The primary purpose of the table is to compress a VLAN range to one VLAN ID.\n If the packet's VLAN falls in the range [VLAN_ID_MIN, VLAN_ID_MAX],\n the VLAN will be replaced with VLAN_ID_MIN.\n If the VLAN falls outside of any specified range, it will remain unchanged.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_CONTROL.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_control_t_fields[] = {
    {
        .name  = UNKNOWN_VLAN_TO_CPUs,  /* UNKNOWN_VLAN_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of packets with unknown VLAN ID to CPU.",
    },
    {
        .name  = PRIVATE_VLAN_MISMATCH_TO_CPUs,  /* PRIVATE_VLAN_MISMATCH_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of packets to CPU when ING_VLAN in the PORT_PVLAN\n logical table is true and the forwarding VLAN ID of\n the packets is not equal to PORT.ING_OVID.\n",
    },
    {
        .name  = DROP_INVALID_VLAN_BPDUs,  /* DROP_INVALID_VLAN_BPDU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable drop of BPDU packets with invalid VLAN ID.",
    },
    {
        .name  = VLAN_XLATE_LOOKUP_MISS_TO_CPUs,  /* VLAN_XLATE_LOOKUP_MISS_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of packets to CPU when packets are dropped\n due to PORT_VLAN_XLATE.ING_MISS_ACTION and\n VLAN translation lookup miss.\n",
    },
    {
        .name  = SHARED_VLANs,  /* SHARED_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use VLAN.FID instead of VLAN ID as\n the key for L2 learning and lookup.\n",
    },
    {
        .name  = MATCH_NON_ZERO_OUI_SNAPs,  /* MATCH_NON_ZERO_OUI_SNAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to match SNAP packets with non-zero OUI as SNAP header.",
    },
    {
        .name  = GLOBAL_SHARED_VLANs,  /* GLOBAL_SHARED_VLAN */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use GLOBAL_FID for L2 learning and lookup.",
    },
    {
        .name  = GLOBAL_FIDs,  /* GLOBAL_FID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "Global filtering database ID.",
    },
    {
        .name  = EGR_STG_CHECKs,  /* EGR_STG_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to check egress port's spanning tree state.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_control_t = {
    .name = VLAN_CONTROLs, /* VLAN_CONTROL */
    .flags = 0,
    .fields = 9,
    .field = bcmltd_vlan_control_t_fields,
    .desc = "The VLAN_CONTROL table is used to specify device level VLAN functions.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_EGR_MEMBER_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_egr_member_profile_t_fields[] = {
    {
        .name  = VLAN_EGR_MEMBER_PROFILE_IDs,  /* VLAN_EGR_MEMBER_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_EGR_MEMBER_PROFILE logical table index.",
    },
    {
        .name  = MEMBER_PORTSs,  /* MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Egress membership ports.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_egr_member_profile_t = {
    .name = VLAN_EGR_MEMBER_PROFILEs, /* VLAN_EGR_MEMBER_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vlan_egr_member_profile_t_fields,
    .desc = "The VLAN_EGR_MEMBER_PROFILE table is used to specify\n egress member ports for the egress membership check.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_EGR_STG_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_egr_stg_profile_t_fields[] = {
    {
        .name  = VLAN_EGR_STG_PROFILE_IDs,  /* VLAN_EGR_STG_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "VLAN_EGR_STG_PROFILE logical table index.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 272,
        .desc = "Spanning tree port state.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_egr_stg_profile_t = {
    .name = VLAN_EGR_STG_PROFILEs, /* VLAN_EGR_STG_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vlan_egr_stg_profile_t_fields,
    .desc = "The VLAN_EGR_STG_PROFILE table is used to specify the egress spanning tree\n group (STG) state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_EGR_TAG_ACTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_egr_tag_action_profile_t_fields[] = {
    {
        .name  = VLAN_EGR_TAG_ACTION_PROFILE_IDs,  /* VLAN_EGR_TAG_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Egress VLAN tag action profile ID.",
    },
    {
        .name  = UT_OTAGs,  /* UT_OTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN action for the untagged packets.",
    },
    {
        .name  = UT_OPRIs,  /* UT_OPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN priority action for the untagged packets.",
    },
    {
        .name  = UT_OCFIs,  /* UT_OCFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN CFI action for the untagged packets.",
    },
    {
        .name  = UT_ITAGs,  /* UT_ITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN action for the untagged packets.",
    },
    {
        .name  = UT_IPRIs,  /* UT_IPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN priority action for the untagged packets.",
    },
    {
        .name  = UT_ICFIs,  /* UT_ICFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN CFI action for the untagged packets.",
    },
    {
        .name  = SOT_POTAGs,  /* SOT_POTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN action for the single outer priority tagged packets.",
    },
    {
        .name  = SOT_OTAGs,  /* SOT_OTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN action for the single outer tagged packets.",
    },
    {
        .name  = SOT_OPRIs,  /* SOT_OPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN priority action for the single outer tagged packets.",
    },
    {
        .name  = SOT_OCFIs,  /* SOT_OCFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN CFI action for the single outer tagged packets.",
    },
    {
        .name  = SOT_ITAGs,  /* SOT_ITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN action for the single outer tagged packets.",
    },
    {
        .name  = SOT_IPRIs,  /* SOT_IPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN priority action for the single outer tagged packets.",
    },
    {
        .name  = SOT_ICFIs,  /* SOT_ICFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN CFI action for the single outer tagged packets.",
    },
    {
        .name  = SIT_PITAGs,  /* SIT_PITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN action for the single inner priority tagged packets.",
    },
    {
        .name  = SIT_OTAGs,  /* SIT_OTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN action for the single inner tagged packets.",
    },
    {
        .name  = SIT_OPRIs,  /* SIT_OPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN priority action for the single inner tagged packets.",
    },
    {
        .name  = SIT_OCFIs,  /* SIT_OCFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN CFI action for the single inner tagged packets.",
    },
    {
        .name  = SIT_ITAGs,  /* SIT_ITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN action for the single inner tagged packets.",
    },
    {
        .name  = SIT_IPRIs,  /* SIT_IPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN priority action for the single inner tagged packets.",
    },
    {
        .name  = SIT_ICFIs,  /* SIT_ICFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN CFI action for the single inner tagged packets.",
    },
    {
        .name  = DT_POTAGs,  /* DT_POTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN action for the double priority tagged packets.",
    },
    {
        .name  = DT_PITAGs,  /* DT_PITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN action for the double priority tagged packets.",
    },
    {
        .name  = DT_OTAGs,  /* DT_OTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN action for the double tagged packets.",
    },
    {
        .name  = DT_OPRIs,  /* DT_OPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN priority action for the double tagged packets.",
    },
    {
        .name  = DT_OCFIs,  /* DT_OCFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN CFI action for the double tagged packets.",
    },
    {
        .name  = DT_ITAGs,  /* DT_ITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN action for the double tagged packets.",
    },
    {
        .name  = DT_IPRIs,  /* DT_IPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN priority action for the double tagged packets.",
    },
    {
        .name  = DT_ICFIs,  /* DT_ICFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN CFI action for the double tagged packets.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_egr_tag_action_profile_t = {
    .name = VLAN_EGR_TAG_ACTION_PROFILEs, /* VLAN_EGR_TAG_ACTION_PROFILE */
    .flags = 0,
    .fields = 29,
    .field = bcmltd_vlan_egr_tag_action_profile_t_fields,
    .desc = "The VLAN_EGR_TAG_ACTION_PROFILE table specifies the actions for\n the VLAN ID, VLAN priority and VLAN CFI in the egress pipeline.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_EGR_UNTAG_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_egr_untag_profile_t_fields[] = {
    {
        .name  = VLAN_EGR_UNTAG_PROFILE_IDs,  /* VLAN_EGR_UNTAG_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_EGR_UNTAG_PROFILE logical table index.",
    },
    {
        .name  = MEMBER_PORTSs,  /* MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Untagged membership ports.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_egr_untag_profile_t = {
    .name = VLAN_EGR_UNTAG_PROFILEs, /* VLAN_EGR_UNTAG_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vlan_egr_untag_profile_t_fields,
    .desc = "The VLAN_EGR_UNTAG_PROFILE table is used to remove the tag\n from the outgoing packet.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_EGR_XLATE_MODPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_egr_xlate_modport_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Old outer VLAN ID.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Old inner VLAN ID.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Destination Module ID.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Destination PORT ID.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = PHB_EGR_L2_OTAG_MAPs,  /* PHB_EGR_L2_OTAG_MAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use PRI and CFI from the PHB_EGR_L2_INT_PRI_TO_OTAG\n logical table as NEW_OPRI and NEW_OCFI.\n",
    },
    {
        .name  = ASSIGN_OPRIs,  /* ASSIGN_OPRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to assign the outgoing outer priority\n with NEW_OPRI in the table.\n",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.\n If PHB_EGR_L2_OTAG_MAP is disabled, use NEW_OCFI from the logical table.\n",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_OTAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_OTAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_L2_INT_PRI_TO_OTAG logical table index.\n Applicable only if PHB_EGR_L2_OTAG_MAP is enabled.\n",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = PHB_EGR_L2_ITAG_MAPs,  /* PHB_EGR_L2_ITAG_MAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use PRI and CFI from the PHB_EGR_L2_INT_PRI_TO_ITAG\n logical table as NEW_IPRI and NEW_ICFI.\n",
    },
    {
        .name  = ASSIGN_IPRIs,  /* ASSIGN_IPRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to assign the outgoing inner priority\n with NEW_IPRI in the table.\n",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner CFI.\n If PHB_EGR_L2_ITAG_MAP is disabled, use NEW_ICFI from the logical table.\n",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_ITAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_ITAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_L2_INT_PRI_TO_ITAG logical table index.\n Applicable only if PHB_EGR_L2_ITAG_MAP is enabled.\n",
    },
    {
        .name  = VLAN_EGR_TAG_ACTION_PROFILE_IDs,  /* VLAN_EGR_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_EGR_TAG_ACTION_PROFILE logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_egr_xlate_modport_t = {
    .name = VLAN_EGR_XLATE_MODPORTs, /* VLAN_EGR_XLATE_MODPORT */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 17,
    .field = bcmltd_vlan_egr_xlate_modport_t_fields,
    .desc = "The VLAN_EGR_XLATE_MODPORT table specifies the outer VLAN, inner VLAN\n and MODPORT based VLAN assignment functionality in the egress pipeline.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_EGR_XLATE_PORT_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_egr_xlate_port_grp_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Old outer VLAN ID.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Old inner VLAN ID.",
    },
    {
        .name  = PORT_GRPs,  /* PORT_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Destination port group.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = PHB_EGR_L2_OTAG_MAPs,  /* PHB_EGR_L2_OTAG_MAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use PRI and CFI from the PHB_EGR_L2_INT_PRI_TO_OTAG\n logical table as NEW_OPRI and NEW_OCFI.\n",
    },
    {
        .name  = ASSIGN_OPRIs,  /* ASSIGN_OPRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to assign the outgoing outer priority\n with NEW_OPRI in the table.\n",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.\n If PHB_EGR_L2_OTAG_MAP is disabled, use NEW_OCFI from the logical table.\n",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_OTAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_OTAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_L2_INT_PRI_TO_OTAG logical table index.\n Applicable only if PHB_EGR_L2_OTAG_MAP is enabled.\n",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = PHB_EGR_L2_ITAG_MAPs,  /* PHB_EGR_L2_ITAG_MAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use PRI and CFI from the PHB_EGR_L2_INT_PRI_TO_ITAG\n logical table as NEW_IPRI and NEW_ICFI.\n",
    },
    {
        .name  = ASSIGN_IPRIs,  /* ASSIGN_IPRI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to assign the outgoing inner priority\n with NEW_IPRI in the table.\n",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner CFI.\n If PHB_EGR_L2_ITAG_MAP is disabled, use NEW_ICFI from the logical table.\n",
    },
    {
        .name  = PHB_EGR_L2_INT_PRI_TO_ITAG_IDs,  /* PHB_EGR_L2_INT_PRI_TO_ITAG_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_EGR_L2_INT_PRI_TO_ITAG logical table index.\n Applicable only if PHB_EGR_L2_ITAG_MAP is enabled.\n",
    },
    {
        .name  = VLAN_EGR_TAG_ACTION_PROFILE_IDs,  /* VLAN_EGR_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_EGR_TAG_ACTION_PROFILE logical table index.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_egr_xlate_port_grp_t = {
    .name = VLAN_EGR_XLATE_PORT_GRPs, /* VLAN_EGR_XLATE_PORT_GRP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 16,
    .field = bcmltd_vlan_egr_xlate_port_grp_t_fields,
    .desc = "The VLAN_EGR_XLATE_GRP table specifies the outer VLAN, inner VLAN\n and port group based VLAN assignment functionality in the egress pipeline.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_EGR_MEMBER_PORTS_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_egr_member_ports_profile_t_fields[] = {
    {
        .name  = VLAN_ING_EGR_MEMBER_PORTS_PROFILE_IDs,  /* VLAN_ING_EGR_MEMBER_PORTS_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "VLAN_ING_EGR_MEMBER_PORTS_PROFILE logical table index.",
    },
    {
        .name  = EGR_MEMBER_PORTSs,  /* EGR_MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Egress member ports.",
    },
    {
        .name  = MASK_TARGETs,  /* MASK_TARGET */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask target.",
    },
    {
        .name  = MASK_ACTIONs,  /* MASK_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask action.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_egr_member_ports_profile_t = {
    .name = VLAN_ING_EGR_MEMBER_PORTS_PROFILEs, /* VLAN_ING_EGR_MEMBER_PORTS_PROFILE */
    .flags = 0,
    .fields = 4,
    .field = bcmltd_vlan_ing_egr_member_ports_profile_t_fields,
    .desc = "The VLAN_ING_EGR_MEMBER_PORTS_PROFILE table specifies egress member ports\n in the ingress pipeline.\n The egress member ports are determined by applying the action specified in\n MASK_ACTION against the ports specified in EGR_MEMBER_PORTS and the L2/L3\n destination ports as specified in MASK_TARGET.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_EGR_STG_MEMBER_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_egr_stg_member_profile_t_fields[] = {
    {
        .name  = VLAN_ING_EGR_STG_MEMBER_PROFILE_IDs,  /* VLAN_ING_EGR_STG_MEMBER_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "VLAN_ING_EGR_STG_MEMBER_PORTS_PROFILE logical table index.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 272,
        .desc = "Spanning tree group forwarding state per mask member.",
    },
    {
        .name  = COMPARED_STATEs,  /* COMPARED_STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Status used to compare against each members state\n to generate mask bitmap.\n",
    },
    {
        .name  = MASK_TARGETs,  /* MASK_TARGET */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask target.",
    },
    {
        .name  = MASK_ACTIONs,  /* MASK_ACTION */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask action.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_egr_stg_member_profile_t = {
    .name = VLAN_ING_EGR_STG_MEMBER_PROFILEs, /* VLAN_ING_EGR_STG_MEMBER_PROFILE */
    .flags = 0,
    .fields = 5,
    .field = bcmltd_vlan_ing_egr_stg_member_profile_t_fields,
    .desc = "The VLAN_ING_EGR_STG_MEMBER_PROFILE table specifies egress member ports\n per spanning tree group in the ingress pipeline.\n STATE and COMPARED_STATE are used to generate a member state\n mask. This member state mask and MASK_TRAGET is used to determine the\n egress member ports with MASK_ACTION applied on them.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_MEMBER_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_member_profile_t_fields[] = {
    {
        .name  = VLAN_ING_MEMBER_PROFILE_IDs,  /* VLAN_ING_MEMBER_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_MEMBER_PROFILE logical table index.",
    },
    {
        .name  = MEMBER_PORTSs,  /* MEMBER_PORTS */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Ingress member ports.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_member_profile_t = {
    .name = VLAN_ING_MEMBER_PROFILEs, /* VLAN_ING_MEMBER_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vlan_ing_member_profile_t_fields,
    .desc = "The VLAN_ING_MEMBERSHIP_PROFILE table is used to specify member ports\n for the ingress membership check.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_STG_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_stg_profile_t_fields[] = {
    {
        .name  = VLAN_ING_STG_PROFILE_IDs,  /* VLAN_ING_STG_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "VLAN_ING_STG_PROFILE logical table index.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 272,
        .desc = "Spanning tree group forwarding state per-port.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_stg_profile_t = {
    .name = VLAN_ING_STG_PROFILEs, /* VLAN_ING_STG_PROFILE */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vlan_ing_stg_profile_t_fields,
    .desc = "The VLAN_ING_STG_PROFILE table is used to specify the ingress spanning tree\n group (STG) state.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_TAG_ACTION_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_tag_action_profile_t_fields[] = {
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Ingress VLAN tag action profile ID.",
    },
    {
        .name  = UT_OTAGs,  /* UT_OTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN tag action for the untagged packets.",
    },
    {
        .name  = UT_OPRIs,  /* UT_OPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer PCP action for the untagged packets.",
    },
    {
        .name  = UT_OCFIs,  /* UT_OCFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer CFI action for the untagged packets.",
    },
    {
        .name  = UT_ITAGs,  /* UT_ITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN tag action for the untagged packets.",
    },
    {
        .name  = UT_IPRIs,  /* UT_IPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner PCP action for the untagged packets.",
    },
    {
        .name  = UT_ICFIs,  /* UT_ICFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner CFI action for the untagged packets.",
    },
    {
        .name  = SOT_POTAGs,  /* SOT_POTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN tag action for the single outer-tagged and\n pri-tagged packets.\n",
    },
    {
        .name  = SOT_OTAGs,  /* SOT_OTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN tag action for the single outer-tagged packets.",
    },
    {
        .name  = SOT_OPRIs,  /* SOT_OPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer PCP action for the single outer-tagged packets.",
    },
    {
        .name  = SOT_OCFIs,  /* SOT_OCFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer CFI action for the single outer-tagged packets.",
    },
    {
        .name  = SOT_ITAGs,  /* SOT_ITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN tag action for the single outer-tagged packets.",
    },
    {
        .name  = SOT_IPRIs,  /* SOT_IPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner PCP action for the single outer-tagged packets.",
    },
    {
        .name  = SOT_ICFIs,  /* SOT_ICFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner CFI action for the single outer-tagged packets.",
    },
    {
        .name  = SIT_PITAGs,  /* SIT_PITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN tag action for the single inner-tagged\n and pri-tagged packets.\n",
    },
    {
        .name  = SIT_OTAGs,  /* SIT_OTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN tag action for the single inner-tagged packets.",
    },
    {
        .name  = SIT_OPRIs,  /* SIT_OPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer PCP action for the single inner-tagged packets.",
    },
    {
        .name  = SIT_OCFIs,  /* SIT_OCFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer CFI action for the single inner-tagged packets.",
    },
    {
        .name  = SIT_ITAGs,  /* SIT_ITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN tag action for the single inner-tagged packets.",
    },
    {
        .name  = SIT_IPRIs,  /* SIT_IPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner PCP action for the single inner-tagged packets.",
    },
    {
        .name  = SIT_ICFIs,  /* SIT_ICFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner CFI action for the single inner-tagged packets.",
    },
    {
        .name  = DT_POTAGs,  /* DT_POTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN tag action for the double tagged\n and pri-tagged packets.\n",
    },
    {
        .name  = DT_PITAGs,  /* DT_PITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN tag action for the double tagged\n and pri-tagged packets.\n",
    },
    {
        .name  = DT_OTAGs,  /* DT_OTAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer VLAN tag action for the double tagged packets.",
    },
    {
        .name  = DT_OPRIs,  /* DT_OPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer PCP action for the double tagged packets.",
    },
    {
        .name  = DT_OCFIs,  /* DT_OCFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Outer CFI action for the double tagged packets.",
    },
    {
        .name  = DT_ITAGs,  /* DT_ITAG */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner VLAN tag action for the double tagged packets.",
    },
    {
        .name  = DT_IPRIs,  /* DT_IPRI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner PCP action for the double tagged packets.",
    },
    {
        .name  = DT_ICFIs,  /* DT_ICFI */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Inner CFI action for the double tagged packets.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_tag_action_profile_t = {
    .name = VLAN_ING_TAG_ACTION_PROFILEs, /* VLAN_ING_TAG_ACTION_PROFILE */
    .flags = 0,
    .fields = 29,
    .field = bcmltd_vlan_ing_tag_action_profile_t_fields,
    .desc = "The VLAN_ING_TAG_ACTION_PROFILE table specifies the actions for\n the VLAN ID, VLAN priority and VLAN CFI.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_CFI_PRI.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_cfi_pri_t_fields[] = {
    {
        .name  = CFIs,  /* CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "VLAN CFI.\n CFI and PRI can be <OCFI,OPRI>/<ICFI,IPRI>.\n",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority.\n CFI and PRI can be <OCFI,OPRI>/<ICFI,IPRI>.\n",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_cfi_pri_t = {
    .name = VLAN_ING_XLATE_CFI_PRIs, /* VLAN_ING_XLATE_CFI_PRI */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 13,
    .field = bcmltd_vlan_ing_xlate_cfi_pri_t_fields,
    .desc = "The VLAN_ING_XLATE_CFI_PRI table specifies the VLAN priority\n and VLAN CFI based VLAN assignment functionality.\n The priority and CFI can be the outer VLAN priority and outer VLAN CFI,\n or the inner VLAN priority and inner VLAN CFI.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_CFI_PRI_MODPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_cfi_pri_modport_t_fields[] = {
    {
        .name  = CFIs,  /* CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "VLAN CFI.\n CFI and PRI can be <OCFI,OPRI>/<ICFI,IPRI>.\n",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority.\n CFI and PRI can be <OCFI,OPRI>/<ICFI,IPRI>.\n",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Module ID.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "System port.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_cfi_pri_modport_t = {
    .name = VLAN_ING_XLATE_CFI_PRI_MODPORTs, /* VLAN_ING_XLATE_CFI_PRI_MODPORT */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 15,
    .field = bcmltd_vlan_ing_xlate_cfi_pri_modport_t_fields,
    .desc = "The VLAN_ING_XLATE_CFI_PRI_MODPORT table specifies the VLAN priority,\n VLAN CFI and MODPORT based VLAN assignment functionality.\n The priority and CFI can be the outer VLAN priority and outer VLAN CFI,\n or the inner VLAN priority and inner VLAN CFI.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_CFI_PRI_PORT_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_cfi_pri_port_grp_t_fields[] = {
    {
        .name  = CFIs,  /* CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "VLAN CFI.\n CFI and PRI can be <OCFI,OPRI>/<ICFI,IPRI>.\n",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority.\n CFI and PRI can be <OCFI,OPRI>/<ICFI,IPRI>.\n",
    },
    {
        .name  = PORT_GRPs,  /* PORT_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Port group.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_cfi_pri_port_grp_t = {
    .name = VLAN_ING_XLATE_CFI_PRI_PORT_GRPs, /* VLAN_ING_XLATE_CFI_PRI_PORT_GRP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 14,
    .field = bcmltd_vlan_ing_xlate_cfi_pri_port_grp_t_fields,
    .desc = "The VLAN_ING_XLATE_CFI_PRI_PORT_GRP table specifies the VLAN priority,\n VLAN CFI and port group based VLAN assignment functionality.\n The priority and CFI can be the outer VLAN priority and outer VLAN CFI,\n or the inner VLAN priority and inner VLAN CFI.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_CFI_PRI_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_cfi_pri_trunk_t_fields[] = {
    {
        .name  = CFIs,  /* CFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "VLAN CFI.\n CFI and PRI can be <OCFI,OPRI>/<ICFI,IPRI>.\n",
    },
    {
        .name  = PRIs,  /* PRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "VLAN priority.\n CFI and PRI can be <OCFI,OPRI>/<ICFI,IPRI>.\n",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Trunk ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_cfi_pri_trunk_t = {
    .name = VLAN_ING_XLATE_CFI_PRI_TRUNKs, /* VLAN_ING_XLATE_CFI_PRI_TRUNK */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 14,
    .field = bcmltd_vlan_ing_xlate_cfi_pri_trunk_t_fields,
    .desc = "The VLAN_ING_XLATE_CFI_PRI_TRUNK table specifies the VLAN priority,\n VLAN CFI and TRUNK group based VLAN assignment functionality.\n The priority and CFI can be the outer VLAN priority and outer VLAN CFI,\n or the inner VLAN priority and inner VLAN CFI.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_ITAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_itag_t_fields[] = {
    {
        .name  = ICFIs,  /* ICFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = IPRIs,  /* IPRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_itag_t = {
    .name = VLAN_ING_XLATE_ITAGs, /* VLAN_ING_XLATE_ITAG */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 14,
    .field = bcmltd_vlan_ing_xlate_itag_t_fields,
    .desc = "The VLAN_ING_XLATE_ITAG table specifies the inner VLAN, inner VLAN priority\n and inner VLAN CFI based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_ITAG_MODPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_itag_modport_t_fields[] = {
    {
        .name  = ICFIs,  /* ICFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = IPRIs,  /* IPRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Module ID.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "System port.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_itag_modport_t = {
    .name = VLAN_ING_XLATE_ITAG_MODPORTs, /* VLAN_ING_XLATE_ITAG_MODPORT */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 16,
    .field = bcmltd_vlan_ing_xlate_itag_modport_t_fields,
    .desc = "The VLAN_ING_XLATE_ITAG_MODPORT table specifies the inner VLAN,\n inner VLAN priority, inner VLAN CFI and MODPORT based\n VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_ITAG_PORT_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_itag_port_grp_t_fields[] = {
    {
        .name  = ICFIs,  /* ICFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = IPRIs,  /* IPRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = PORT_GRPs,  /* PORT_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Port group.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_itag_port_grp_t = {
    .name = VLAN_ING_XLATE_ITAG_PORT_GRPs, /* VLAN_ING_XLATE_ITAG_PORT_GRP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 15,
    .field = bcmltd_vlan_ing_xlate_itag_port_grp_t_fields,
    .desc = "The VLAN_ING_XLATE_ITAG_PORT_GRP table specifies the inner VLAN,\n inner VLAN priority, inner VLAN CFI and port group based\n VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_ITAG_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_itag_trunk_t_fields[] = {
    {
        .name  = ICFIs,  /* ICFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Inner VLAN CFI.",
    },
    {
        .name  = IPRIs,  /* IPRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Inner VLAN priority.",
    },
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Trunk ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_itag_trunk_t = {
    .name = VLAN_ING_XLATE_ITAG_TRUNKs, /* VLAN_ING_XLATE_ITAG_TRUNK */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 15,
    .field = bcmltd_vlan_ing_xlate_itag_trunk_t_fields,
    .desc = "The VLAN_ING_XLATE_ITAG_TRUNK table specifies the inner VLAN,\n inner VLAN priority, inner VLAN CFI and TRUNK group based\n VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_IVID.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ivid_t_fields[] = {
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ivid_t = {
    .name = VLAN_ING_XLATE_IVIDs, /* VLAN_ING_XLATE_IVID */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 12,
    .field = bcmltd_vlan_ing_xlate_ivid_t_fields,
    .desc = "The VLAN_ING_XLATE_IVID table specifies the inner VLAN based\n VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_IVID_MODPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ivid_modport_t_fields[] = {
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Module ID.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "System port.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ivid_modport_t = {
    .name = VLAN_ING_XLATE_IVID_MODPORTs, /* VLAN_ING_XLATE_IVID_MODPORT */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 14,
    .field = bcmltd_vlan_ing_xlate_ivid_modport_t_fields,
    .desc = "The VLAN_ING_XLATE_IVID_MODPORT table specifies the inner VLAN and\n MODPORT based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_IVID_OVID.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ivid_ovid_t_fields[] = {
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ivid_ovid_t = {
    .name = VLAN_ING_XLATE_IVID_OVIDs, /* VLAN_ING_XLATE_IVID_OVID */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 13,
    .field = bcmltd_vlan_ing_xlate_ivid_ovid_t_fields,
    .desc = "The VLAN_ING_XLATE_IVID_OVID table specifies the inner VLAN and outer VLAN\n based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_IVID_OVID_MODPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ivid_ovid_modport_t_fields[] = {
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Module ID.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "System port.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ivid_ovid_modport_t = {
    .name = VLAN_ING_XLATE_IVID_OVID_MODPORTs, /* VLAN_ING_XLATE_IVID_OVID_MODPORT */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 15,
    .field = bcmltd_vlan_ing_xlate_ivid_ovid_modport_t_fields,
    .desc = "The VLAN_ING_XLATE_IVID_OVID_MODPORT table specifies the inner VLAN,\n outer VLAN and MODPORT based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_IVID_OVID_PORT_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ivid_ovid_port_grp_t_fields[] = {
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = PORT_GRPs,  /* PORT_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Port group.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ivid_ovid_port_grp_t = {
    .name = VLAN_ING_XLATE_IVID_OVID_PORT_GRPs, /* VLAN_ING_XLATE_IVID_OVID_PORT_GRP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 14,
    .field = bcmltd_vlan_ing_xlate_ivid_ovid_port_grp_t_fields,
    .desc = "The VLAN_ING_XLATE_IVID_OVID_PORT_GRP table specifies the inner VLAN,\n outer VLAN and port group based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_IVID_OVID_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ivid_ovid_trunk_t_fields[] = {
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Trunk ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ivid_ovid_trunk_t = {
    .name = VLAN_ING_XLATE_IVID_OVID_TRUNKs, /* VLAN_ING_XLATE_IVID_OVID_TRUNK */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 14,
    .field = bcmltd_vlan_ing_xlate_ivid_ovid_trunk_t_fields,
    .desc = "The VLAN_ING_XLATE_IVID_OVID_TRUNK table specifies the inner VLAN,\n outer VLAN and TRUNK group based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_IVID_PORT_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ivid_port_grp_t_fields[] = {
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = PORT_GRPs,  /* PORT_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Port group.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ivid_port_grp_t = {
    .name = VLAN_ING_XLATE_IVID_PORT_GRPs, /* VLAN_ING_XLATE_IVID_PORT_GRP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 13,
    .field = bcmltd_vlan_ing_xlate_ivid_port_grp_t_fields,
    .desc = "The VLAN_ING_XLATE_IVID_PORT_GRP table specifies the inner VLAN and\n port group based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_IVID_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ivid_trunk_t_fields[] = {
    {
        .name  = IVIDs,  /* IVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Inner VLAN ID.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Trunk ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ivid_trunk_t = {
    .name = VLAN_ING_XLATE_IVID_TRUNKs, /* VLAN_ING_XLATE_IVID_TRUNK */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 13,
    .field = bcmltd_vlan_ing_xlate_ivid_trunk_t_fields,
    .desc = "The VLAN_ING_XLATE_IVID_TRUNK table specifies the inner VLAN and\n TRUNK group based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_OTAG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_otag_t_fields[] = {
    {
        .name  = OCFIs,  /* OCFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_otag_t = {
    .name = VLAN_ING_XLATE_OTAGs, /* VLAN_ING_XLATE_OTAG */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 14,
    .field = bcmltd_vlan_ing_xlate_otag_t_fields,
    .desc = "The VLAN_ING_XLATE_OTAG table specifies the outer VLAN,\n outer VLAN priority and outer VLAN CFI based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_OTAG_MODPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_otag_modport_t_fields[] = {
    {
        .name  = OCFIs,  /* OCFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Module ID.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "System port.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_otag_modport_t = {
    .name = VLAN_ING_XLATE_OTAG_MODPORTs, /* VLAN_ING_XLATE_OTAG_MODPORT */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 16,
    .field = bcmltd_vlan_ing_xlate_otag_modport_t_fields,
    .desc = "The VLAN_ING_XLATE_OTAG_MODPORT table specifies the outer VLAN,\n outer VLAN priority, outer VLAN CFI and MODPORT based\n VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_OTAG_PORT_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_otag_port_grp_t_fields[] = {
    {
        .name  = OCFIs,  /* OCFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = PORT_GRPs,  /* PORT_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Port group.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_otag_port_grp_t = {
    .name = VLAN_ING_XLATE_OTAG_PORT_GRPs, /* VLAN_ING_XLATE_OTAG_PORT_GRP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 15,
    .field = bcmltd_vlan_ing_xlate_otag_port_grp_t_fields,
    .desc = "The VLAN_ING_XLATE_OTAG_PORT_GRP table specifies the outer VLAN,\n outer VLAN priority, outer VLAN CFI and port group based\n VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_OTAG_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_otag_trunk_t_fields[] = {
    {
        .name  = OCFIs,  /* OCFI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 1,
        .depth = 0,
        .desc = "Outer VLAN CFI.",
    },
    {
        .name  = OPRIs,  /* OPRI */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 3,
        .depth = 0,
        .desc = "Outer VLAN priority.",
    },
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Trunk ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_otag_trunk_t = {
    .name = VLAN_ING_XLATE_OTAG_TRUNKs, /* VLAN_ING_XLATE_OTAG_TRUNK */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 15,
    .field = bcmltd_vlan_ing_xlate_otag_trunk_t_fields,
    .desc = "The VLAN_ING_XLATE_OTAG_TRUNK table specifies the outer VLAN,\n outer VLAN priority, outer VLAN CFI and TRUNK group based\n VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_OVID.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ovid_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ovid_t = {
    .name = VLAN_ING_XLATE_OVIDs, /* VLAN_ING_XLATE_OVID */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 12,
    .field = bcmltd_vlan_ing_xlate_ovid_t_fields,
    .desc = "The VLAN_ING_XLATE_OVID table specifies the outer VLAN based\n VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_OVID_MODPORT.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ovid_modport_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = MODIDs,  /* MODID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Module ID.",
    },
    {
        .name  = MODPORTs,  /* MODPORT */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "System port.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ovid_modport_t = {
    .name = VLAN_ING_XLATE_OVID_MODPORTs, /* VLAN_ING_XLATE_OVID_MODPORT */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 14,
    .field = bcmltd_vlan_ing_xlate_ovid_modport_t_fields,
    .desc = "The VLAN_ING_XLATE_OVID_MODPORT table specifies the outer VLAN and MODPORT\n based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_OVID_PORT_GRP.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ovid_port_grp_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = PORT_GRPs,  /* PORT_GRP */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Port group.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ovid_port_grp_t = {
    .name = VLAN_ING_XLATE_OVID_PORT_GRPs, /* VLAN_ING_XLATE_OVID_PORT_GRP */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 13,
    .field = bcmltd_vlan_ing_xlate_ovid_port_grp_t_fields,
    .desc = "The VLAN_ING_XLATE_OVID_PORT_GRP table specifies the outer VLAN\n and port group based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_ING_XLATE_OVID_TRUNK.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_ing_xlate_ovid_trunk_t_fields[] = {
    {
        .name  = OVIDs,  /* OVID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 12,
        .depth = 0,
        .desc = "Outer VLAN ID.",
    },
    {
        .name  = TRUNK_IDs,  /* TRUNK_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 16,
        .depth = 0,
        .desc = "Trunk ID.",
    },
    {
        .name  = VLAN_ING_TAG_ACTION_PROFILE_IDs,  /* VLAN_ING_TAG_ACTION_PROFILE_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_ING_TAG_ACTION_PROFILE logical table index.",
    },
    {
        .name  = VLAN_ACTIONs,  /* VLAN_ACTION */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Indicator that the VLAN translation action is valid.",
    },
    {
        .name  = NEW_OVIDs,  /* NEW_OVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New outer VLAN ID.",
    },
    {
        .name  = NEW_OPRIs,  /* NEW_OPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New outer VLAN priority.",
    },
    {
        .name  = NEW_OCFIs,  /* NEW_OCFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New outer VLAN CFI.",
    },
    {
        .name  = NEW_IVIDs,  /* NEW_IVID */
        .flags = 0,
        .width = 12,
        .depth = 0,
        .desc = "New inner VLAN ID.",
    },
    {
        .name  = NEW_IPRIs,  /* NEW_IPRI */
        .flags = 0,
        .width = 3,
        .depth = 0,
        .desc = "New inner VLAN priority.",
    },
    {
        .name  = NEW_ICFIs,  /* NEW_ICFI */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "New inner VLAN CFI.",
    },
    {
        .name  = SKIP_VLAN_CHECKs,  /* SKIP_VLAN_CHECK */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, spanning tree and VLAN memberships checks\n are not performed.\n",
    },
    {
        .name  = L3_IIF_VALIDs,  /* L3_IIF_VALID */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, use L3_IIF_ID.",
    },
    {
        .name  = L3_IIF_IDs,  /* L3_IIF_ID */
        .flags = 0,
        .width = 32,
        .depth = 0,
        .desc = "L3_IIF logical table index.\n Applicable only if L3_IIF_VALID is enabled.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_ing_xlate_ovid_trunk_t = {
    .name = VLAN_ING_XLATE_OVID_TRUNKs, /* VLAN_ING_XLATE_OVID_TRUNK */
    .flags = BCMLTD_TABLE_F_TYPE_HASH,
    .fields = 13,
    .field = bcmltd_vlan_ing_xlate_ovid_trunk_t_fields,
    .desc = "The VLAN_ING_XLATE_OVID_TRUNK table specifies the outer VLAN\n and TRUNK group based VLAN assignment functionality.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_INNER_TPID.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_inner_tpid_t_fields[] = {
    {
        .name  = ING_TPIDs,  /* ING_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress inner TPID for parsing.",
    },
    {
        .name  = EGR_TPIDs,  /* EGR_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress inner TPID for remarking.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_inner_tpid_t = {
    .name = VLAN_INNER_TPIDs, /* VLAN_INNER_TPID */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vlan_inner_tpid_t_fields,
    .desc = "The VLAN_INNER_TPID table specifies the inner TPID for the device.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_OUTER_TPID.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_outer_tpid_t_fields[] = {
    {
        .name  = VLAN_OUTER_TPID_IDs,  /* VLAN_OUTER_TPID_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Outer TPID ID.",
    },
    {
        .name  = ING_TPIDs,  /* ING_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ingress outer TPID for parsing.",
    },
    {
        .name  = EGR_TPIDs,  /* EGR_TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Egress outer TPID for remarking.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_outer_tpid_t = {
    .name = VLAN_OUTER_TPIDs, /* VLAN_OUTER_TPID */
    .flags = 0,
    .fields = 3,
    .field = bcmltd_vlan_outer_tpid_t_fields,
    .desc = "The VLAN_OUTER_TPID table specifies the outer TPIDs for the device.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_PAYLOAD_OUTER_TPID.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_payload_outer_tpid_t_fields[] = {
    {
        .name  = VLAN_PAYLOAD_OUTER_TPID_IDs,  /* VLAN_PAYLOAD_OUTER_TPID_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "Index into the VLAN_PAYLOAD_OUTER_TPID logical table.",
    },
    {
        .name  = TPIDs,  /* TPID */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Outer TPID for parsing.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_payload_outer_tpid_t = {
    .name = VLAN_PAYLOAD_OUTER_TPIDs, /* VLAN_PAYLOAD_OUTER_TPID */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vlan_payload_outer_tpid_t_fields,
    .desc = "The VLAN_PAYLOAD_OUTER_TPID table specifies the outer TPIDs for\n payload during tunnel decapsulation.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_PROFILE.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_profile_t_fields[] = {
    {
        .name  = VLAN_PROFILE_IDs,  /* VLAN_PROFILE_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "VLAN profile ID.",
    },
    {
        .name  = PORT_PKT_CONTROL_IDs,  /* PORT_PKT_CONTROL_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PORT_PKT_CONTROL_ID logical table index.",
    },
    {
        .name  = VLAN_OUTER_TPID_IDs,  /* VLAN_OUTER_TPID_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "VLAN_OUTER_TPID logical table index.",
    },
    {
        .name  = PHB_ING_L2_OTAG_MAPs,  /* PHB_ING_L2_OTAG_MAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to trust outer vlan tag and map 802.1p/CFI bits\n of the outer vlan tag to PHB.\n",
    },
    {
        .name  = PHB_ING_L2_TAGGED_TO_INT_PRI_IDs,  /* PHB_ING_L2_TAGGED_TO_INT_PRI_ID */
        .flags = 0,
        .width = 8,
        .depth = 0,
        .desc = "PHB_ING_L2_TAGGED_TO_INT_PRI logical table index.\n Applicable only if PHB_ING_L2_OTAG_MAP is enabled.\n",
    },
    {
        .name  = NO_LEARNINGs,  /* NO_LEARNING */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable MAC source address learning.",
    },
    {
        .name  = L3_IPV6_PFMs,  /* L3_IPV6_PFM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "IPv6 multicast packet flooding mode.",
    },
    {
        .name  = L3_IPV4_PFMs,  /* L3_IPV4_PFM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "IPv4 multicast packet flooding mode.",
    },
    {
        .name  = L2_PFMs,  /* L2_PFM */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "L2 multicast packet flooding mode.",
    },
    {
        .name  = L2_NON_UCAST_TOCPUs,  /* L2_NON_UCAST_TOCPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of L2 non-unicast packets to CPU.",
    },
    {
        .name  = L2_NON_UCAST_DROPs,  /* L2_NON_UCAST_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping L2 non-unicast packets.",
    },
    {
        .name  = L2_MISS_TOCPUs,  /* L2_MISS_TOCPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable copy of L2 miss lookup packets to CPU.",
    },
    {
        .name  = L2_MISS_DROPs,  /* L2_MISS_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable dropping L2 miss lookup packets.",
    },
    {
        .name  = IPV6_MC_L2_FWDs,  /* IPV6_MC_L2_FWD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2-only forwarding for IPv6 multicast packets.",
    },
    {
        .name  = IPV4_MC_L2_FWDs,  /* IPV4_MC_L2_FWD */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L2-only forwarding for IPv4 multicast packets.",
    },
    {
        .name  = BLOCK_MASK_As,  /* BLOCK_MASK_A */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Inverse of mask A ANDed with the port bitmap.",
    },
    {
        .name  = BLOCK_MASK_Bs,  /* BLOCK_MASK_B */
        .flags = 0,
        .width = 1,
        .depth = 272,
        .desc = "Inverse of mask B ANDed with the port bitmap.",
    },
    {
        .name  = UNKNOWN_UC_MASK_MODEs,  /* UNKNOWN_UC_MASK_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask mode for unknown unicast packets between mask A and mask B.",
    },
    {
        .name  = UNKNOWN_MC_MASK_MODEs,  /* UNKNOWN_MC_MASK_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask mode for unknown multicast packets between mask A and mask B.",
    },
    {
        .name  = MC_MASK_MODEs,  /* MC_MASK_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask mode for known multicast packets between mask A and mask B.",
    },
    {
        .name  = BC_MASK_MODEs,  /* BC_MASK_MODE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 0,
        .desc = "Mask mode for broadcast packets between mask A and mask B.",
    },
    {
        .name  = ICMP_REDIRECT_PKT_TO_CPUs,  /* ICMP_REDIRECT_PKT_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to perform ICMP redirect checks. If enabled, L3 routed\n packets are copied to the CPU if the route necessitates an\n ICMP redirect.\n",
    },
    {
        .name  = IPV6_UCs,  /* IPV6_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv6 unicast packets.",
    },
    {
        .name  = IPV4_UCs,  /* IPV4_UC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable L3 forwarding for IPv4 unicast packets.",
    },
    {
        .name  = IPV4_UNKNOWN_MC_TO_CPUs,  /* IPV4_UNKNOWN_MC_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable sending of unknown IPv4 multicast packets to CPU.",
    },
    {
        .name  = IPV6_UNKNOWN_MC_TO_CPUs,  /* IPV6_UNKNOWN_MC_TO_CPU */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable sending of unknown IPv6 multicast packets to CPU.",
    },
    {
        .name  = IPV6_ROUTING_HDR_TYPE_0_DROPs,  /* IPV6_ROUTING_HDR_TYPE_0_DROP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable drop of IPv6 packets with type 0 routing header.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_profile_t = {
    .name = VLAN_PROFILEs, /* VLAN_PROFILE */
    .flags = 0,
    .fields = 27,
    .field = bcmltd_vlan_profile_t_fields,
    .desc = "The VLAN_PROFILE table specifies the VLAN functionality profile.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_PROTOCOL_MATCH.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_protocol_match_t_fields[] = {
    {
        .name  = VLAN_PROTOCOL_MATCH_IDs,  /* VLAN_PROTOCOL_MATCH_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 8,
        .depth = 0,
        .desc = "VLAN protocol match ID.",
    },
    {
        .name  = ETHERTYPEs,  /* ETHERTYPE */
        .flags = 0,
        .width = 16,
        .depth = 0,
        .desc = "Ethertype of the packet.",
    },
    {
        .name  = LLCs,  /* LLC */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, the entry applies for LLC packets.",
    },
    {
        .name  = SNAPs,  /* SNAP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, the entry applies for SNAP packets.",
    },
    {
        .name  = ETHERNET_IIs,  /* ETHERNET_II */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "If enabled, the entry applies for ETHER II packets.",
    },
    {
        .name  = MATCH_ETHERTYPE_LOWERs,  /* MATCH_ETHERTYPE_LOWER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable matching the lower byte of ETHERTYPE in the table\n with the lower byte of the packet's Ethertype to indicate ETHERTYPE match.\n If neither MATCH_ETHER_TYPE_LOWER or MATCH_ETHER_TYPE_UPPER is set,\n ETHERTYPE match is set when one of the upper byte or lower byte matches.\n",
    },
    {
        .name  = MATCH_ETHERTYPE_UPPERs,  /* MATCH_ETHERTYPE_UPPER */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable matching the upper byte of ETHERTYPE in the table\n with the upper byte of the packet's Ethertype to indicate ETHERTYPE match.\n If neither MATCH_ETHER_TYPE_LOWER or MATCH_ETHER_TYPE_UPPER is set,\n ETHERTYPE match is set when one of the upper byte or lower byte matches.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_protocol_match_t = {
    .name = VLAN_PROTOCOL_MATCHs, /* VLAN_PROTOCOL_MATCH */
    .flags = 0,
    .fields = 7,
    .field = bcmltd_vlan_protocol_match_t_fields,
    .desc = "The VLAN_PROTOCOL_MATCH table specifies protocol based VLAN assignment\n parameters and is used in conjunction with the VLAN_ASSIGNMENT_PROTOCOL table.\n",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_STG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_stg_t_fields[] = {
    {
        .name  = VLAN_STG_IDs,  /* VLAN_STG_ID */
        .flags = BCMLTD_FIELD_F_KEY,
        .width = 9,
        .depth = 0,
        .desc = "Spanning tree group ID.",
    },
    {
        .name  = STATEs,  /* STATE */
        .flags = BCMLTD_FIELD_F_ENUM,
        .width = 32,
        .depth = 272,
        .desc = "Spanning tree group forwarding state per-port.",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_stg_t = {
    .name = VLAN_STGs, /* VLAN_STG */
    .flags = 0,
    .fields = 2,
    .field = bcmltd_vlan_stg_t_fields,
    .desc = "The VLAN_STG table specifies the spanning tree group state configuration.",
};
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from INTERNAL/fltg/xgs/vlan/VLAN_XLATE_CONFIG.tbl.ltl
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Broadcom Ltd.$
 */
#include <bcmltd/bcmltd_internal.h>
#include "bcmltd_strpool.h"
static const bcmltd_field_rep_t bcmltd_vlan_xlate_config_t_fields[] = {
    {
        .name  = EGR_XLATE_PORT_GRPs,  /* EGR_XLATE_PORT_GRP */
        .flags = 0,
        .width = 1,
        .depth = 0,
        .desc = "Enable to use port group for egress VLAN translation.\n Disable to use system port for egress VLAN translation.\n",
    },
};
const bcmltd_table_rep_t bcmltd_vlan_xlate_config_t = {
    .name = VLAN_XLATE_CONFIGs, /* VLAN_XLATE_CONFIG */
    .flags = BCMLTD_TABLE_F_CONFIG,
    .fields = 1,
    .field = bcmltd_vlan_xlate_config_t_fields,
    .desc = "The VLAN_XLATE_CONFIG specifies the device-level\n VLAN translation configuration.\n",
};
