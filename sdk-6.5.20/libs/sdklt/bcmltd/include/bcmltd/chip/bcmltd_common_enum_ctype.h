/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from Logical Table definition files.
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
#ifndef BCMLTD_COMMON_ENUM_CTYPE_H
#define BCMLTD_COMMON_ENUM_CTYPE_H
#ifndef DOXYGEN_IGNORE_AUTOGEN

/*! enum type for AN_MACSEC_CONTROL_MODE_T
 * Enums defining the association number (AN) control mode.
 */
typedef enum bcmltd_common_an_macsec_control_mode_t_e {
    /*!
     * Invalidate SA when, next packet number is 2^32-1
     *  (non-XPN Cipher suite) or 2^64-1 (XPN Cipher suite).
     */
    BCMLTD_COMMON_AN_MACSEC_CONTROL_MODE_T_T_NORMAL = 0,
    /*!
     * Rollover next packet number from 2^32-1 (non-XPN Cipher suite)
     *  or 2^64-1 (XPN Cipher suite) to 1.
     */
    BCMLTD_COMMON_AN_MACSEC_CONTROL_MODE_T_T_ROLLOVER = 1,
    /*!
     * Switchover the active AN of the secure channel
     *  to the next valid AN.
     */
    BCMLTD_COMMON_AN_MACSEC_CONTROL_MODE_T_T_AUTO_SWITCHOVER = 2,
} bcmltd_common_an_macsec_control_mode_t_t;

/*! enum type for BST_EVENT_CLASS_T
 * Enums defining the various BST resource classes for an event.
 */
typedef enum bcmltd_common_bst_event_class_t_e {
    /*! Ingress events.  */
    BCMLTD_COMMON_BST_EVENT_CLASS_T_T_ING = 0,
    /*! Egress events.  */
    BCMLTD_COMMON_BST_EVENT_CLASS_T_T_EGR = 1,
    /*! Replication queue events.  */
    BCMLTD_COMMON_BST_EVENT_CLASS_T_T_REPL_Q = 2,
    /*! Device events.  */
    BCMLTD_COMMON_BST_EVENT_CLASS_T_T_DEVICE = 3,
} bcmltd_common_bst_event_class_t_t;

/*! enum type for BST_EVENT_STATE_T
 * BST event states.
 */
typedef enum bcmltd_common_bst_event_state_t_e {
    /*! Event notification turned off.  */
    BCMLTD_COMMON_BST_EVENT_STATE_T_T_OFF = 0,
    /*! Counter tracking with event notification enabled. */
    BCMLTD_COMMON_BST_EVENT_STATE_T_T_ARMED = 1,
    /*! Counter tracking without event notification. */
    BCMLTD_COMMON_BST_EVENT_STATE_T_T_ARMED_PASSIVE = 2,
    /*! Event notification triggered. */
    BCMLTD_COMMON_BST_EVENT_STATE_T_T_TRIGGERED = 3,
} bcmltd_common_bst_event_state_t_t;

/*! enum type for BST_TRACK_MODE_TYPE_T
 * Enums defining the BST Tracking Modes.
 */
typedef enum bcmltd_common_bst_track_mode_type_t_e {
    /*! Tracks the current value of the counter. */
    BCMLTD_COMMON_BST_TRACK_MODE_TYPE_T_T_INSTANTANEOUS_TRACK = 0,
    /*! Tracks the highest value attained by the counter. */
    BCMLTD_COMMON_BST_TRACK_MODE_TYPE_T_T_HIGH_WATERMARK_TRACK = 1,
} bcmltd_common_bst_track_mode_type_t_t;

/*! enum type for CIPHER_SUITE_T
 * Enums defining the encryption standards for MACsec and IPsec.
 */
typedef enum bcmltd_common_cipher_suite_t_e {
    /*! GCM-AES-128  */
    BCMLTD_COMMON_CIPHER_SUITE_T_T_GCM_AES_128 = 0,
    /*! GCM-AES-256  */
    BCMLTD_COMMON_CIPHER_SUITE_T_T_GCM_AES_256 = 1,
    /*! GCM-AES-XPN_128  */
    BCMLTD_COMMON_CIPHER_SUITE_T_T_GCM_AES_XPN_128 = 2,
    /*! GCM-AES-XPN_256  */
    BCMLTD_COMMON_CIPHER_SUITE_T_T_GCM_AES_XPN_256 = 3,
} bcmltd_common_cipher_suite_t_t;

/*! enum type for COLLECTOR_TAG_TYPE_T
 * VLAN tag type.
 */
typedef enum bcmltd_common_collector_tag_type_t_e {
    /*! No VLAN tag.  */
    BCMLTD_COMMON_COLLECTOR_TAG_TYPE_T_T_UNTAGGED = 0,
    /*! Single VLAN tag.  */
    BCMLTD_COMMON_COLLECTOR_TAG_TYPE_T_T_SINGLE_TAGGED = 1,
    /*! Double VLAN tag.  */
    BCMLTD_COMMON_COLLECTOR_TAG_TYPE_T_T_DOUBLE_TAGGED = 2,
} bcmltd_common_collector_tag_type_t_t;

/*! enum type for CONTROLLED_PORT_MODE_T
 * Enums defining the packet mode for processing by SEC logic.
 *  Applicable for secured and unsecured data packets.
 */
typedef enum bcmltd_common_controlled_port_mode_t_e {
    /*!
     * Drop data packet without performing SEC functions.
     *  Accounting is disabled.
     */
    BCMLTD_COMMON_CONTROLLED_PORT_MODE_T_T_DROP = 0,
    /*!
     * Drop data packet after performing SEC functions.
     *  Packet is accounted for in MIB as dropped.
     */
    BCMLTD_COMMON_CONTROLLED_PORT_MODE_T_T_DROP_AND_ACCOUNT = 1,
    /*!
     * Allow and forward data packet to SEC logic.
     *  Packets are accounted for in MIB.
     */
    BCMLTD_COMMON_CONTROLLED_PORT_MODE_T_T_ALLOW = 2,
} bcmltd_common_controlled_port_mode_t_t;

/*! enum type for CTR_EFLEX_ACTION_ZONE_T
 * Defines enhanced flex counter action vector zone.
 */
typedef enum bcmltd_common_ctr_eflex_action_zone_t_e {
    /*! Fixed action zone.  */
    BCMLTD_COMMON_CTR_EFLEX_ACTION_ZONE_T_T_FIXED = 0,
    /*! Flex action zone.  */
    BCMLTD_COMMON_CTR_EFLEX_ACTION_ZONE_T_T_FLEX = 1,
} bcmltd_common_ctr_eflex_action_zone_t_t;

/*! enum type for CTR_EFLEX_DROP_COUNT_MODE_T
 * Enhanced flex counter count on drop modes.
 */
typedef enum bcmltd_common_ctr_eflex_drop_count_mode_t_e {
    /*! Count only if not being dropped.  */
    BCMLTD_COMMON_CTR_EFLEX_DROP_COUNT_MODE_T_T_NO_DROP_COUNT = 0,
    /*! Count only if being dropped.  */
    BCMLTD_COMMON_CTR_EFLEX_DROP_COUNT_MODE_T_T_DROP_COUNT = 1,
    /*! Ignore drop status and always count.  */
    BCMLTD_COMMON_CTR_EFLEX_DROP_COUNT_MODE_T_T_ALWAYS_COUNT = 2,
} bcmltd_common_ctr_eflex_drop_count_mode_t_t;

/*! enum type for CTR_EFLEX_EVICT_COMPARE_T
 * Enhanced flex counter conditional eviction operations.
 */
typedef enum bcmltd_common_ctr_eflex_evict_compare_t_e {
    /*! No conditional eviction.  */
    BCMLTD_COMMON_CTR_EFLEX_EVICT_COMPARE_T_T_NOOP = 0,
    /*! Evict if counter A > counter B.  */
    BCMLTD_COMMON_CTR_EFLEX_EVICT_COMPARE_T_T_GREATER = 1,
    /*! Evict if counter A < counter B.  */
    BCMLTD_COMMON_CTR_EFLEX_EVICT_COMPARE_T_T_LESS = 2,
    /*! Evict if counter A == counter B.  */
    BCMLTD_COMMON_CTR_EFLEX_EVICT_COMPARE_T_T_EQUALS = 3,
} bcmltd_common_ctr_eflex_evict_compare_t_t;

/*! enum type for CTR_EFLEX_MODE_T
 * Enhanced flex counter modes.
 */
typedef enum bcmltd_common_ctr_eflex_mode_t_e {
    /*! Counters A and B, each 64-bit wide.  */
    BCMLTD_COMMON_CTR_EFLEX_MODE_T_T_NORMAL = 0,
    /*! Counter A only, 128-bit wide.  */
    BCMLTD_COMMON_CTR_EFLEX_MODE_T_T_WIDE = 1,
    /*! Counters A, B and C, each 32-bit wide.  */
    BCMLTD_COMMON_CTR_EFLEX_MODE_T_T_SLIM = 2,
} bcmltd_common_ctr_eflex_mode_t_t;

/*! enum type for CTR_EFLEX_SRC_T
 * Enhanced flex counter source options.
 */
typedef enum bcmltd_common_ctr_eflex_src_t_e {
    /*! Use counter value computed by CTR_ING/EGR_EFLEX_OPERAND_PROFILE LT.  */
    BCMLTD_COMMON_CTR_EFLEX_SRC_T_T_NOOP = 0,
    /*! Use packet length.  */
    BCMLTD_COMMON_CTR_EFLEX_SRC_T_T_USE_PKTLEN = 1,
    /*!
     * Use stored value of paired counter.
     *  If both counters select this option, each counter will use
     *  current counter value instead of the updated value.
     *
     *  For example, Assume update mode is INC.
     *  new value A = old value A + old value B
     *  new value B = old value B + old value A
     */
    BCMLTD_COMMON_CTR_EFLEX_SRC_T_T_USE_PAIRED_COUNTER = 2,
} bcmltd_common_ctr_eflex_src_t_t;

/*! enum type for CTR_EFLEX_START_TRIGGER_T
 * Enhanced flex counter start trigger types.
 */
typedef enum bcmltd_common_ctr_eflex_start_trigger_t_e {
    /*! Use time as type.  */
    BCMLTD_COMMON_CTR_EFLEX_START_TRIGGER_T_T_TIME = 0,
    /*! Use condition as type.  */
    BCMLTD_COMMON_CTR_EFLEX_START_TRIGGER_T_T_CONDITION = 1,
} bcmltd_common_ctr_eflex_start_trigger_t_t;

/*! enum type for CTR_EFLEX_STATE_T
 * Enhanced flex counter operational state.
 */
typedef enum bcmltd_common_ctr_eflex_state_t_e {
    /*! Entry is invalid  */
    BCMLTD_COMMON_CTR_EFLEX_STATE_T_T_INACTIVE = 0,
    /*! Entry is valid  */
    BCMLTD_COMMON_CTR_EFLEX_STATE_T_T_ACTIVE = 1,
} bcmltd_common_ctr_eflex_state_t_t;

/*! enum type for CTR_EVENT_SYNC_STATE_CONTROL_T
 * Counter sync event state control.
 */
typedef enum bcmltd_common_ctr_event_sync_state_control_t_e {
    /*! Counter sync off.  */
    BCMLTD_COMMON_CTR_EVENT_SYNC_STATE_CONTROL_T_T_OFF = 0,
    /*! Counter sync start. */
    BCMLTD_COMMON_CTR_EVENT_SYNC_STATE_CONTROL_T_T_START = 1,
} bcmltd_common_ctr_event_sync_state_control_t_t;

/*! enum type for CTR_EVENT_SYNC_STATE_T
 * Counter sync event states.
 */
typedef enum bcmltd_common_ctr_event_sync_state_t_e {
    /*! Counter sync is off.  */
    BCMLTD_COMMON_CTR_EVENT_SYNC_STATE_T_T_OFF = 0,
    /*! Counter sync started. */
    BCMLTD_COMMON_CTR_EVENT_SYNC_STATE_T_T_START = 1,
    /*! Counter sync completed. */
    BCMLTD_COMMON_CTR_EVENT_SYNC_STATE_T_T_COMPLETE = 2,
} bcmltd_common_ctr_event_sync_state_t_t;

/*! enum type for CTR_FLEX_OPERATIONAL_STATE_T
 * Flex counter operational state definitions.
 */
typedef enum bcmltd_common_ctr_flex_operational_state_t_e {
    /*! Operational state OK  */
    BCMLTD_COMMON_CTR_FLEX_OPERATIONAL_STATE_T_T_OPERATIONAL_STATE_OK = 0,
    /*! PKT_ATTR_TEMPLATE unavailable  */
    BCMLTD_COMMON_CTR_FLEX_OPERATIONAL_STATE_T_T_PKT_ATTR_TEMPLATE_NOT_PRESENT = 1,
    /*! ATTR_TEMPLATE unavailable  */
    BCMLTD_COMMON_CTR_FLEX_OPERATIONAL_STATE_T_T_ATTR_TEMPLATE_NOT_PRESENT = 2,
    /*! CTR_FLEX_INSTANCEs exceeds allocated counters  */
    BCMLTD_COMMON_CTR_FLEX_OPERATIONAL_STATE_T_T_ATTR_TEMPLATE_INSTANCES_EXCEEDED = 3,
    /*! PKT_ATTR_TEMPLATE attributes exceeds width limit  */
    BCMLTD_COMMON_CTR_FLEX_OPERATIONAL_STATE_T_T_PKT_ATTR_TEMPLATE_WIDTH_EXCEEDED = 4,
    /*! Waiting for counter resources  */
    BCMLTD_COMMON_CTR_FLEX_OPERATIONAL_STATE_T_T_AWAITING_COUNTER_RESOURCE = 5,
} bcmltd_common_ctr_flex_operational_state_t_t;

/*! enum type for CTR_FLEX_STATS_STATE_T
 * Flex stats operational state definitions.
 */
typedef enum bcmltd_common_ctr_flex_stats_state_t_e {
    /*! Entry ID is invalid  */
    BCMLTD_COMMON_CTR_FLEX_STATS_STATE_T_T_INACTIVE = 0,
    /*! Entry ID is valid  */
    BCMLTD_COMMON_CTR_FLEX_STATS_STATE_T_T_ACTIVE = 1,
} bcmltd_common_ctr_flex_stats_state_t_t;

/*! enum type for CTR_PORT_ENTRY_STATE_T
 * Enumerations defining entry operational status.
 */
typedef enum bcmltd_common_ctr_port_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical port to physical map unavailable or invalid logical port.  */
    BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*! Counter collection is disabled.  */
    BCMLTD_COMMON_CTR_PORT_ENTRY_STATE_T_T_COUNTER_COLLECT_DISABLED = 2,
} bcmltd_common_ctr_port_entry_state_t_t;

/*! enum type for CTR_PORT_MC_Q_ENTRY_STATE_T
 * Enumerations defining entry operational status.
 */
typedef enum bcmltd_common_ctr_port_mc_q_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_CTR_PORT_MC_Q_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_CTR_PORT_MC_Q_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*! Invalid multicast queue number.  */
    BCMLTD_COMMON_CTR_PORT_MC_Q_ENTRY_STATE_T_T_MC_Q_INVALID = 2,
} bcmltd_common_ctr_port_mc_q_entry_state_t_t;

/*! enum type for CTR_PORT_Q_ENTRY_STATE_T
 * Enumerations defining entry operational status.
 */
typedef enum bcmltd_common_ctr_port_q_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_CTR_PORT_Q_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical port to TM port map unavailable or invalid logical port.  */
    BCMLTD_COMMON_CTR_PORT_Q_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*! Invalid queue number.  */
    BCMLTD_COMMON_CTR_PORT_Q_ENTRY_STATE_T_T_QUEUE_INVALID = 2,
    /*! Counter collection is disabled.  */
    BCMLTD_COMMON_CTR_PORT_Q_ENTRY_STATE_T_T_COUNTER_COLLECT_DISABLED = 3,
} bcmltd_common_ctr_port_q_entry_state_t_t;

/*! enum type for CTR_PORT_UC_Q_ENTRY_STATE_T
 * Enumerations defining entry operational status.
 */
typedef enum bcmltd_common_ctr_port_uc_q_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_CTR_PORT_UC_Q_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_CTR_PORT_UC_Q_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*! Invalid unicast queue number.  */
    BCMLTD_COMMON_CTR_PORT_UC_Q_ENTRY_STATE_T_T_UC_Q_INVALID = 2,
} bcmltd_common_ctr_port_uc_q_entry_state_t_t;

/*! enum type for CTR_TM_QUEUE_TYPE_T
 * Enumerations defining queue match type.
 */
typedef enum bcmltd_common_ctr_tm_queue_type_t_e {
    /*! Unicast queue.  */
    BCMLTD_COMMON_CTR_TM_QUEUE_TYPE_T_T_UC_Q = 0,
    /*! Multicast queue.  */
    BCMLTD_COMMON_CTR_TM_QUEUE_TYPE_T_T_MC_Q = 1,
} bcmltd_common_ctr_tm_queue_type_t_t;

/*! enum type for CTR_TYPE_T
 * Counter types.
 */
typedef enum bcmltd_common_ctr_type_t_e {
    /*! Port counters.  */
    BCMLTD_COMMON_CTR_TYPE_T_T_PORT = 0,
    /*! Traffic management counters. */
    BCMLTD_COMMON_CTR_TYPE_T_T_TM = 1,
    /*! Egress pipeline counters. */
    BCMLTD_COMMON_CTR_TYPE_T_T_EGR_PIPE = 2,
    /*! Ingress pipeline counters. */
    BCMLTD_COMMON_CTR_TYPE_T_T_ING_PIPE = 3,
    /*! Eviction counters. */
    BCMLTD_COMMON_CTR_TYPE_T_T_EVICT = 4,
    /*! Security module counters. */
    BCMLTD_COMMON_CTR_TYPE_T_T_SEC = 5,
    /*! All counters. */
    BCMLTD_COMMON_CTR_TYPE_T_T_ALL = 6,
} bcmltd_common_ctr_type_t_t;

/*! enum type for DEVICE_FIFO_CHANNELS_MODE_T */
typedef enum bcmltd_common_device_fifo_channels_mode_t_e {
    /*! Disable usage of FIFO_CHANNELs.  */
    BCMLTD_COMMON_DEVICE_FIFO_CHANNELS_MODE_T_T_DISABLE = 0,
    /*! Use only one FIFO_CHANNEL.  */
    BCMLTD_COMMON_DEVICE_FIFO_CHANNELS_MODE_T_T_SINGLE = 1,
    /*! Use two FIFO_CHANNELs.  */
    BCMLTD_COMMON_DEVICE_FIFO_CHANNELS_MODE_T_T_DOUBLE = 2,
} bcmltd_common_device_fifo_channels_mode_t_t;

/*! enum type for EVICTION_THRESHOLD_T
 * DMA Eviction Threshold.
 */
typedef enum bcmltd_common_eviction_threshold_t_e {
    BCMLTD_COMMON_EVICTION_THRESHOLD_T_T_PERCENT_25 = 25,
    BCMLTD_COMMON_EVICTION_THRESHOLD_T_T_PERCENT_50 = 50,
    BCMLTD_COMMON_EVICTION_THRESHOLD_T_T_PERCENT_75 = 75,
} bcmltd_common_eviction_threshold_t_t;

/*! enum type for EXPORT_PACKET_LEN_INDICATOR_T
 * Export packet length indicator.
 */
typedef enum bcmltd_common_export_packet_len_indicator_t_e {
    /*! Maximum length. */
    BCMLTD_COMMON_EXPORT_PACKET_LEN_INDICATOR_T_T_MAX_PKT_LENGTH = 0,
    /*! Number of record records to be sent in one packet. */
    BCMLTD_COMMON_EXPORT_PACKET_LEN_INDICATOR_T_T_NUM_RECORDS = 1,
} bcmltd_common_export_packet_len_indicator_t_t;

/*! enum type for FLEX_STATE_INSTANCE_T
 * Enhanced flex state instances.
 */
typedef enum bcmltd_common_flex_state_instance_t_e {
    /*! Ingress post lookup instance.  */
    BCMLTD_COMMON_FLEX_STATE_INSTANCE_T_T_ING_POST_LKUP_INST = 0,
    /*! Ingress post fowarding instance.  */
    BCMLTD_COMMON_FLEX_STATE_INSTANCE_T_T_ING_POST_FWD_INST = 1,
} bcmltd_common_flex_state_instance_t_t;

/*! enum type for FLOWTRACKER_ACTION_TYPE_T
 * List of flowtracker actions.
 */
typedef enum bcmltd_common_flowtracker_action_type_t_e {
    /*! None.  */
    BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_T_NONE = 0,
    /*!
     * An opaque value is assigned to the flow. This value
     *  can be matched later in the Ingress FP and an action
     *  can be applied.
     */
    BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_T_EM_FT_OPAQUE_OBJ0 = 1,
    /*!
     * Perform an IFA/IOAM or GBP action on the flow.
     *  This action is applicable only when
     *  MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is ENABLE_HARDWARE_ONLY.
     */
    BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_T_EM_FT_IOAM_GBP_ACTION = 2,
    /*!
     * Send a copy of the packet to the CPU.
     *  This action is applicable only when
     *  MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is ENABLE_HARDWARE_ONLY.
     */
    BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_T_EM_FT_COPY_TO_CPU = 3,
    /*!
     * Drop the packet.
     *  This action is applicable only when
     *  MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is ENABLE_HARDWARE_ONLY.
     */
    BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_T_EM_FT_DROP_ACTION = 4,
    /*!
     * Assign a destination for the packet.
     *  This action is applicable only when
     *  MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is ENABLE_HARDWARE_ONLY.
     */
    BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_T_DESTINATION = 5,
    /*!
     * Assign a destination type for the packet.
     *  This action is applicable only when
     *  MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is ENABLE_HARDWARE_ONLY.
     */
    BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_T_DESTINATION_TYPE = 6,
    /*!
     * Assign a flex state action for the packet.
     *  This action is applicable only when
     *  MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is ENABLE_HARDWARE_ONLY.
     */
    BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_T_EM_FT_FLEX_STATE_ACTION = 7,
    /*!
     * Assign packet flow eligibility for the packet.
     *  This action is applicable only when
     *  MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is ENABLE_HARDWARE_ONLY.
     */
    BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_T_PKT_FLOW_ELIGIBILITY = 8,
    /*!
     * Assign a flex counter action for the packet.
     *  This action is applicable only when
     *  MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is ENABLE_HARDWARE_ONLY.
     */
    BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_T_FLEX_CTR_ACTION = 9,
    /*!
     * Assign a Mirror index to lookup MIRROR_SESSION_0 table
     *  for the packet. This action is applicable only when
     *  MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is ENABLE_HARDWARE_ONLY.
     */
    BCMLTD_COMMON_FLOWTRACKER_ACTION_TYPE_T_T_L2_IIF_SVP_MIRROR_INDEX_0 = 10,
} bcmltd_common_flowtracker_action_type_t_t;

/*! enum type for FLOWTRACKER_EXPORT_ELEMENT_TYPE_T
 * Flowtracker export element types.
 */
typedef enum bcmltd_common_flowtracker_export_element_type_t_e {
    /*! None.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_NONE = 0,
    /*! SRC IPv4 of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_SRC_IPV4 = 1,
    /*! DST IPV4 of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_DST_IPV4 = 2,
    /*! SRC IPV6 of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_SRC_IPV6 = 3,
    /*! DST IPV6 of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_DST_IPV6 = 4,
    /*! L4 SRC PORT of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_SRC_L4_PORT = 5,
    /*! L4 DST PORT of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_DST_L4_PORT = 6,
    /*! IP PROTOCOL of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_IP_PROTOCOL = 7,
    /*! Count of packets of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_PKT_COUNT = 8,
    /*! Count of bytes of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_BYTE_COUNT = 9,
    /*! Inner Src IPV4 of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_INNER_SRC_IPV4 = 10,
    /*! Inner DST IPV4 of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_INNER_DST_IPV4 = 11,
    /*! Inner SRC IPV6 of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_INNER_SRC_IPV6 = 12,
    /*! Inner DST IPV6 of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_INNER_DST_IPV6 = 13,
    /*! Inner L4 SRC PORT of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_INNER_SRC_L4_PORT = 14,
    /*! Inner L4 DST PORT of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_INNER_DST_L4_PORT = 15,
    /*! Inner IP PROTOCOL of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_INNER_IP_PROTOCOL = 16,
    /*!
     * Custom element tracked as part of the flow
     *  needs to be exported.
     */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_CUSTOM = 17,
    /*! Flow start timestamp of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_FLOW_START_TIMESTAMP = 18,
    /*! Observation timestamp of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_OBSERVATION_TIMESTAMP = 19,
    /*! Flowtracker group ID of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_FLOWTRACKER_GROUP = 20,
    /*! Vxlan network ID of the flow needs to be exported.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_ELEMENT_TYPE_T_T_VNID = 21,
} bcmltd_common_flowtracker_export_element_type_t_t;

/*! enum type for FLOWTRACKER_EXPORT_TRIGGER_TYPE_T
 * Types of export triggers to be set in export triggers
 *  bitmap in MON_FLOWTRACKER_GROUP table.
 */
typedef enum bcmltd_common_flowtracker_export_trigger_type_t_e {
    /*! None.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_TRIGGER_TYPE_T_T_NONE = 0,
    /*! Flow information is exported on expiry of a periodic timer.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_TRIGGER_TYPE_T_T_TIMER = 1,
    /*! Flow information is exported when a new flow is learnt.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_TRIGGER_TYPE_T_T_NEW_FLOW_LEARN = 2,
    /*! Flow information is exported when a flow ages out.  */
    BCMLTD_COMMON_FLOWTRACKER_EXPORT_TRIGGER_TYPE_T_T_FLOW_AGE_OUT = 3,
} bcmltd_common_flowtracker_export_trigger_type_t_t;

/*! enum type for FLOWTRACKER_HARDWARE_LEARN_T
 * List of hardware learn configurations.
 */
typedef enum bcmltd_common_flowtracker_hardware_learn_t_e {
    /*!
     * Disable hardware learning. Embedded application would perform
     *  the learning, exporting and aging of the flows.
     */
    BCMLTD_COMMON_FLOWTRACKER_HARDWARE_LEARN_T_T_DISABLE = 0,
    /*!
     * Enable hardware learning. Embedded application would perform the
     *  exporting and aging of the flows.
     */
    BCMLTD_COMMON_FLOWTRACKER_HARDWARE_LEARN_T_T_ENABLE = 1,
    /*!
     * Enable hardware learning without embedded application.
     *  The user application is expected to age out the flows.
     */
    BCMLTD_COMMON_FLOWTRACKER_HARDWARE_LEARN_T_T_ENABLE_HARDWARE_ONLY = 2,
} bcmltd_common_flowtracker_hardware_learn_t_t;

/*! enum type for FLOWTRACKER_HW_LEARN_EXACT_MATCH_IDX_MODE_T
 * List of exact match table index modes.
 */
typedef enum bcmltd_common_flowtracker_hw_learn_exact_match_idx_mode_t_e {
    /*! Single wide mode.  */
    BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_EXACT_MATCH_IDX_MODE_T_T_SINGLE = 1,
    /*! Double wide mode.  */
    BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_EXACT_MATCH_IDX_MODE_T_T_DOUBLE = 2,
    /*! Quad wide mode.  */
    BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_EXACT_MATCH_IDX_MODE_T_T_QUAD = 3,
} bcmltd_common_flowtracker_hw_learn_exact_match_idx_mode_t_t;

/*! enum type for FLOWTRACKER_HW_LEARN_FLOW_ACTION_STATE_T
 * Enum defines the status of the action performed using
 *  MON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_CONTROL table.
 */
typedef enum bcmltd_common_flowtracker_hw_learn_flow_action_state_t_e {
    /*! Action succeeded.  */
    BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_STATE_T_T_SUCCESS = 0,
    /*! Action failed.  */
    BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_STATE_T_T_FAILURE = 1,
    /*!
     * Not supported since
     *  MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN is not set to
     *  ENABLE_HARDWARE_ONLY
     */
    BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_STATE_T_T_NOT_SUPPORTED = 2,
    /*!
     * Action types specified in the LT do not match with the
     *  action types specified in the MON_FLOWTRACKER_GROUP table.
     */
    BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_STATE_T_T_ACTION_MISMATCH = 3,
    /*! Group specified in the control table is not present.  */
    BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_FLOW_ACTION_STATE_T_T_GROUP_NOT_PRESENT = 4,
} bcmltd_common_flowtracker_hw_learn_flow_action_state_t_t;

/*! enum type for FLOWTRACKER_HW_LEARN_FLOW_CMD_T
 * List of actions that can be performed on flows learnt by HW.
 */
typedef enum bcmltd_common_flowtracker_hw_learn_flow_cmd_t_e {
    BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_FLOW_CMD_T_T_NOP = 0,
    /*! Delete the exact match table entry.  */
    BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_FLOW_CMD_T_T_DELETE = 1,
    /*! Modify the exact match table actions.  */
    BCMLTD_COMMON_FLOWTRACKER_HW_LEARN_FLOW_CMD_T_T_MODIFY = 2,
} bcmltd_common_flowtracker_hw_learn_flow_cmd_t_t;

/*! enum type for FLOWTRACKER_TRACKING_PARAM_TYPE_T
 * Types of supported flow tracking parameters in flowtracker embedded
 *  application.
 */
typedef enum bcmltd_common_flowtracker_tracking_param_type_t_e {
    /*! Source IPv4 address in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_SRC_IPV4 = 0,
    /*! Destination IPv4 address in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_DST_IPV4 = 1,
    /*! Source IPv6 address in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_SRC_IPV6 = 2,
    /*! Destination IPv6 address in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_DST_IPV6 = 3,
    /*! L4 source port in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_L4_SRC_PORT = 4,
    /*! L4 destination port in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_L4_DST_PORT = 5,
    /*! IP protocol in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_IP_PROTOCOL = 6,
    /*! Inner source IPv4 address in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_INNER_SRC_IPV4 = 7,
    /*!
     * Inner destination IPv4 address in the packet
     *  used for tracking flow.
     */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_INNER_DST_IPV4 = 8,
    /*! Inner source IPv6 address in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_INNER_SRC_IPV6 = 9,
    /*! Inner destination IPv6 address in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_INNER_DST_IPV6 = 10,
    /*! Inner L4 source port in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_INNER_L4_SRC_PORT = 11,
    /*! Inner L4 destination port in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_INNER_L4_DST_PORT = 12,
    /*! Inner IP protocol in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_INNER_IP_PROTOCOL = 13,
    /*! Custom user defined field in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_CUSTOM = 14,
    /*! The ingress port of the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_IN_PORT = 15,
    /*! VxLAN network ID in the packet used for tracking flow.  */
    BCMLTD_COMMON_FLOWTRACKER_TRACKING_PARAM_TYPE_T_T_VNID = 16,
} bcmltd_common_flowtracker_tracking_param_type_t_t;

/*! enum type for FP_COMPRESSION_TYPE_T
 * FP compression types.
 */
typedef enum bcmltd_common_fp_compression_type_t_e {
    BCMLTD_COMMON_FP_COMPRESSION_TYPE_T_T_DST_IPV4 = 0,
    BCMLTD_COMMON_FP_COMPRESSION_TYPE_T_T_SRC_IPV4 = 1,
    BCMLTD_COMMON_FP_COMPRESSION_TYPE_T_T_DST_IPV6 = 2,
    BCMLTD_COMMON_FP_COMPRESSION_TYPE_T_T_SRC_IPV6 = 3,
} bcmltd_common_fp_compression_type_t_t;

/*! enum type for FP_ING_OPERMODE_T
 * Enum defines configuration mode for ingress FP stage.
 */
typedef enum bcmltd_common_fp_ing_opermode_t_e {
    /*! Operational mode global.  */
    BCMLTD_COMMON_FP_ING_OPERMODE_T_T_GLOBAL = 0,
    /*! Operational mode pipe unique.  */
    BCMLTD_COMMON_FP_ING_OPERMODE_T_T_PIPE_UNIQUE = 1,
    /*! Operational mode global pipe aware.  */
    BCMLTD_COMMON_FP_ING_OPERMODE_T_T_GLOBAL_PIPE_AWARE = 2,
} bcmltd_common_fp_ing_opermode_t_t;

/*! enum type for LB_HASH_GTP_L4_PORT_MATCH_T
 * GTP port matching enumeration type.
 */
typedef enum bcmltd_common_lb_hash_gtp_l4_port_match_t_e {
    /*! Skipped, no matching.  */
    BCMLTD_COMMON_LB_HASH_GTP_L4_PORT_MATCH_T_T_NO_L4_PORT_MATCH = 0,
    /*! Match L4 destination port only.  */
    BCMLTD_COMMON_LB_HASH_GTP_L4_PORT_MATCH_T_T_DST_L4_PORT = 1,
    /*! Match L4 source port only.  */
    BCMLTD_COMMON_LB_HASH_GTP_L4_PORT_MATCH_T_T_SRC_L4_PORT = 2,
    /*! Match L4 source or destination port.  */
    BCMLTD_COMMON_LB_HASH_GTP_L4_PORT_MATCH_T_T_SRC_OR_DST_L4_PORT = 3,
    /*! Match both L4 source and destination port.  */
    BCMLTD_COMMON_LB_HASH_GTP_L4_PORT_MATCH_T_T_SRC_AND_DST_L4_PORT = 4,
} bcmltd_common_lb_hash_gtp_l4_port_match_t_t;

/*! enum type for LDH_MONITOR_STATE_T
 * Defines the state of the latency monitor.
 */
typedef enum bcmltd_common_ldh_monitor_state_t_e {
    /*! Inactive state.  */
    BCMLTD_COMMON_LDH_MONITOR_STATE_T_T_MONITOR_INACTIVE = 0,
    /*! Active state.  */
    BCMLTD_COMMON_LDH_MONITOR_STATE_T_T_MONITOR_ACTIVE = 1,
} bcmltd_common_ldh_monitor_state_t_t;

/*! enum type for LM_LINKSCAN_MODE_T
 * \brief Globally available Linkscan modes.
 */
typedef enum bcmltd_common_lm_linkscan_mode_t_e {
    /*! No linkscan  */
    BCMLTD_COMMON_LM_LINKSCAN_MODE_T_T_NO_SCAN = 0,
    /*! Software linkscan.  */
    BCMLTD_COMMON_LM_LINKSCAN_MODE_T_T_SOFTWARE = 1,
    /*! Hardware linkscan.  */
    BCMLTD_COMMON_LM_LINKSCAN_MODE_T_T_HARDWARE = 2,
    /*! Application overrides the link status.  */
    BCMLTD_COMMON_LM_LINKSCAN_MODE_T_T_OVERRIDE = 3,
} bcmltd_common_lm_linkscan_mode_t_t;

/*! enum type for METER_FP_MODE_T */
typedef enum bcmltd_common_meter_fp_mode_t_e {
    /*! Default metering.  */
    BCMLTD_COMMON_METER_FP_MODE_T_T_DEFAULT = 0,
    /*! Flow metering.  */
    BCMLTD_COMMON_METER_FP_MODE_T_T_FLOW = 1,
    /*! Single rate three color marking.  */
    BCMLTD_COMMON_METER_FP_MODE_T_T_SRTCM = 2,
    /*! Modified single rate three color marking.  */
    BCMLTD_COMMON_METER_FP_MODE_T_T_MODSRTCM = 3,
    /*! Two-rate three color marking.  */
    BCMLTD_COMMON_METER_FP_MODE_T_T_TRTCM = 4,
    /*! Modified two-rate three color marking.  */
    BCMLTD_COMMON_METER_FP_MODE_T_T_MODTRTCM = 5,
} bcmltd_common_meter_fp_mode_t_t;

/*! enum type for MON_COLLECTOR_TYPE_T
 * Enum defines the types of collectors
 */
typedef enum bcmltd_common_mon_collector_type_t_e {
    /*! IPV4 Collector  */
    BCMLTD_COMMON_MON_COLLECTOR_TYPE_T_T_IPV4 = 0,
    /*! IPV6 Collector  */
    BCMLTD_COMMON_MON_COLLECTOR_TYPE_T_T_IPV6 = 1,
} bcmltd_common_mon_collector_type_t_t;

/*! enum type for MON_FLOWTRACKER_CONTROL_STATE_T
 * Enum defines operational state of MON_FLOWTRACKER_CONTROL entry.
 */
typedef enum bcmltd_common_mon_flowtracker_control_state_t_e {
    /*! Success.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_CONTROL_STATE_T_T_SUCCESS = 0,
    /*! Flowtracker embedded application is not initialized.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_CONTROL_STATE_T_T_APP_NOT_INITIALIZED = 1,
    /*! ETRAP feature not supported.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_CONTROL_STATE_T_T_ETRAP_FEATURE_NOT_SUPPORTED = 2,
    /*! Invalid maximum export length.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_CONTROL_STATE_T_T_INVALID_MAX_EXPORT_LENGTH = 3,
    /*! Invalid scan interval.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_CONTROL_STATE_T_T_INVALID_SCAN_INTERVAL_USECS = 4,
    /*!
     * Profile info specified by CTR_ING_FLEX_ACTION_PROFILE_ID
     *  does not exist.
     */
    BCMLTD_COMMON_MON_FLOWTRACKER_CONTROL_STATE_T_T_CTR_ING_FLEX_ACTION_PROFILE_ID_NOT_EXISTS = 5,
    /*! Insufficient flex counter pools.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_CONTROL_STATE_T_T_CTR_ING_FLEX_POOLS_NOT_SUFFICIENT = 6,
    /*!
     * Flowtracker embedded application is already running.
     *  Cannot change MON_FLOWTRACKER_CONTROL.HARDWARE_LEARN to
     *  ENABLE_HARDWARE_ONLY. MON_FLOWTRACKER_CONTROL.FLOWTRACKER field
     *  needs to be toggled.
     */
    BCMLTD_COMMON_MON_FLOWTRACKER_CONTROL_STATE_T_T_APP_RUNNING = 7,
} bcmltd_common_mon_flowtracker_control_state_t_t;

/*! enum type for MON_FLOWTRACKER_EXPORT_TEMPLATE_STATE_T
 * Enum defines operational state of
 *  MON_FLOWTRACKER_EXPORT_TEMPLATE entry
 */
typedef enum bcmltd_common_mon_flowtracker_export_template_state_t_e {
    /*! Success.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_EXPORT_TEMPLATE_STATE_T_T_SUCCESS = 0,
    /*! Collector specified by MON_COLLECTOR_ID_IPV4/IPV6_ID does not exist.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_EXPORT_TEMPLATE_STATE_T_T_COLLECTOR_NOT_EXISTS = 1,
    /*!
     * Flowtracker group ID specified by MON_FLOWTRACKER_GROUP_ID
     *  does not exist.
     */
    BCMLTD_COMMON_MON_FLOWTRACKER_EXPORT_TEMPLATE_STATE_T_T_FLOWTRACKER_GROUP_NOT_EXISTS = 2,
    /*!
     * Flowtracker embedded application is not initialized
     *  in MON_FLOWTRACKER_CONTROL.FLOWTRACKER field.
     */
    BCMLTD_COMMON_MON_FLOWTRACKER_EXPORT_TEMPLATE_STATE_T_T_APP_NOT_INITIALIZED = 3,
    /*! Flowtracker embedded application is not responding.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_EXPORT_TEMPLATE_STATE_T_T_APP_NOT_RESPONDING = 4,
} bcmltd_common_mon_flowtracker_export_template_state_t_t;

/*! enum type for MON_FLOWTRACKER_GROUP_COLLECTOR_MAP_STATE_T
 * Enum defines operational state of
 *  MON_FLOWTRACKER_GROUP_COLLECTOR_MAP entry
 */
typedef enum bcmltd_common_mon_flowtracker_group_collector_map_state_t_e {
    /*! Success.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_COLLECTOR_MAP_STATE_T_T_SUCCESS = 0,
    /*! Collector specified by MON_COLLECTOR_ID_IPV4/IPV6_ID does not exist.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_COLLECTOR_MAP_STATE_T_T_COLLECTOR_NOT_EXISTS = 1,
    /*! Export profile specified by MON_EXPORT_PROFILE_ID does not exist.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_COLLECTOR_MAP_STATE_T_T_EXPORT_PROFILE_NOT_EXISTS = 2,
    /*!
     * Export template specified by MON_FLOWTRACKER_EXPORT_TEMPLATE_ID
     *  does not exist.
     */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_COLLECTOR_MAP_STATE_T_T_EXPORT_TEMPLATE_NOT_EXISTS = 3,
    /*!
     * Flowtracker group ID specified by MON_FLOWTRACKER_GROUP_ID
     *  does not exist.
     */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_COLLECTOR_MAP_STATE_T_T_FLOWTRACKER_GROUP_NOT_EXISTS = 4,
    /*!
     * Flowtracker embedded application is not initialized
     *  in MON_FLOWTRACKER_CONTROL.FLOWTRACKER field.
     */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_COLLECTOR_MAP_STATE_T_T_APP_NOT_INITIALIZED = 5,
    /*! Flowtracker embedded application is not responding.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_COLLECTOR_MAP_STATE_T_T_APP_NOT_RESPONDING = 6,
} bcmltd_common_mon_flowtracker_group_collector_map_state_t_t;

/*! enum type for MON_FLOWTRACKER_GROUP_STATE_T
 * Enum defines operational state of MON_FLOWTRACKER_GROUP entry.
 */
typedef enum bcmltd_common_mon_flowtracker_group_state_t_e {
    /*! Success.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_STATE_T_T_SUCCESS = 0,
    /*! EM group specified by DT_EM_GRP_TEMPLATE_ID does not exist.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_STATE_T_T_EM_GRP_TEMPLATE_ID_NOT_EXISTS = 1,
    /*!
     * UDF POLICY ID specified by one of tracking parameters
     *  TRACKING_PARAMETERS_UDF_POLICY_ID does not exist.
     */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_STATE_T_T_UDF_POLICY_ID_NOT_EXISTS = 2,
    /*!
     * Flowtracker embedded application is not initialized
     *  in MON_FLOWTRACKER_CONTROL.FLOWTRACKER field.
     */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_STATE_T_T_APP_NOT_INITIALIZED = 3,
    /*! Flowtracker embedded application is not responding.  */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_STATE_T_T_APP_NOT_RESPONDING = 4,
    /*!
     * Elephant profile ID specified by MON_FLOWTRACKER_ELEPHANT_PROFILE_ID
     *  does not exist.
     */
    BCMLTD_COMMON_MON_FLOWTRACKER_GROUP_STATE_T_T_ELEPHANT_PROFILE_ID_NOT_EXISTS = 5,
} bcmltd_common_mon_flowtracker_group_state_t_t;

/*! enum type for MON_INBAND_TELEMETRY_CONTROL_COLLECTOR_TYPE_T
 * Enum defines the types of collectors used by the
 *  MON_INBAND_TELEMETRY_CONTROL LT.
 */
typedef enum bcmltd_common_mon_inband_telemetry_control_collector_type_t_e {
    /*! IPV4 Collector.  */
    BCMLTD_COMMON_MON_INBAND_TELEMETRY_CONTROL_COLLECTOR_TYPE_T_T_IPV4 = 0,
    /*! IPV6 Collector.  */
    BCMLTD_COMMON_MON_INBAND_TELEMETRY_CONTROL_COLLECTOR_TYPE_T_T_IPV6 = 1,
} bcmltd_common_mon_inband_telemetry_control_collector_type_t_t;

/*! enum type for MON_INBAND_TELEMETRY_CONTROL_STATE_T
 * Enum defines the operational state of the
 *  MON_INBAND_TELEMETRY_CONTROL entry
 */
typedef enum bcmltd_common_mon_inband_telemetry_control_state_t_e {
    /*! Success.  */
    BCMLTD_COMMON_MON_INBAND_TELEMETRY_CONTROL_STATE_T_T_SUCCESS = 0,
    /*!
     * Inband Telemetry (INT) embedded application is not initialized in the
     *  MON_INBAND_TELEMETRY_CONTROL.INBAND_TELEMETRY field.
     */
    BCMLTD_COMMON_MON_INBAND_TELEMETRY_CONTROL_STATE_T_T_APP_NOT_INITIALIZED = 1,
    /*! Collector specified by MON_COLLECTOR_ID_IPV4/IPV6_ID does not exist.  */
    BCMLTD_COMMON_MON_INBAND_TELEMETRY_CONTROL_STATE_T_T_COLLECTOR_NOT_EXISTS = 2,
    /*! Export profile specified by MON_EXPORT_PROFILE_ID does not exist.  */
    BCMLTD_COMMON_MON_INBAND_TELEMETRY_CONTROL_STATE_T_T_EXPORT_PROFILE_NOT_EXISTS = 3,
    /*!
     * The MON_EXPORT_PROFILE.WIRE_FORMAT field specified by
     *  MON_EXPORT_PROFILE_ID is not supported.
     */
    BCMLTD_COMMON_MON_INBAND_TELEMETRY_CONTROL_STATE_T_T_EXPORT_PROFILE_WIRE_FORMAT_NOT_SUPPORTED = 4,
    /*!
     * The MON_EXPORT_PROFILE.MAX_PKT_LENGTH specified by MON_EXPORT_PROFILE_ID
     *  is invalid. This implies that the MAX_PKT_LENGTH value is either larger
     *  than the MON_INBAND_TELEMETRY_CONTROL.MAX_EXPORT_PKT_LENGTH_OPER field LT
     *  or that the MAX_PKT_LENGTH value is too small. This state
     *  is only applicable when the MON_EXPORT_PROFILE.PACKET_LEN_INDICATOR is
     *  set to MAX_PKT_LENGTH.
     */
    BCMLTD_COMMON_MON_INBAND_TELEMETRY_CONTROL_STATE_T_T_EXPORT_PROFILE_INVALID_MAX_PKT_LENGTH = 5,
} bcmltd_common_mon_inband_telemetry_control_state_t_t;

/*! enum type for MON_INBAND_TELEMETRY_IPFIX_EXPORT_STATE_T
 * Enum defines the operational state of the MON_INBAND_TELEMETRY_IPFIX_EXPORT
 *  entry.
 */
typedef enum bcmltd_common_mon_inband_telemetry_ipfix_export_state_t_e {
    /*! Success.  */
    BCMLTD_COMMON_MON_INBAND_TELEMETRY_IPFIX_EXPORT_STATE_T_T_SUCCESS = 0,
    /*!
     * Inband Telemetry (INT) embedded application is not initialized in the
     *  MON_INBAND_TELEMETRY_CONTROL.INBAND_TELEMETRY field.
     */
    BCMLTD_COMMON_MON_INBAND_TELEMETRY_IPFIX_EXPORT_STATE_T_T_APP_NOT_INITIALIZED = 1,
} bcmltd_common_mon_inband_telemetry_ipfix_export_state_t_t;

/*! enum type for OAM_BFD_AUTH_STATE_T
 * Enum defines the operational state of an OAM_BFD_AUTH entry.
 */
typedef enum bcmltd_common_oam_bfd_auth_state_t_e {
    /*! Success.  */
    BCMLTD_COMMON_OAM_BFD_AUTH_STATE_T_T_SUCCESS = 0,
    /*!
     * Number of authentication IDs exceed
     *  OAM_BFD_CONTROL.MAX_AUTH_SIMPLE_PASSWORD_KEYS_OPER or
     *  OAM_BFD_CONTROL.MAX_AUTH_SHA1_KEYS_OPER depending on the type of
     *  authentication.
     */
    BCMLTD_COMMON_OAM_BFD_AUTH_STATE_T_T_NUM_AUTH_IDS_EXCEED_MAX = 1,
} bcmltd_common_oam_bfd_auth_state_t_t;

/*! enum type for OAM_BFD_AUTH_TYPE_T
 * Enum defines the authentication types used by BFD endpoints.
 */
typedef enum bcmltd_common_oam_bfd_auth_type_t_e {
    /*! No authentication.  */
    BCMLTD_COMMON_OAM_BFD_AUTH_TYPE_T_T_NONE = 0,
    /*!
     * Simple password authentication. In this method of authentication, one or
     *  more passwords (with corresponding key IDs) are configured in each system
     *  and one of these password/ID pairs is carried in each BFD control packet.
     *  The receiving system accepts the packet if the password and key ID
     *  matches one of the password/ID pairs configured in that system.
     */
    BCMLTD_COMMON_OAM_BFD_AUTH_TYPE_T_T_SIMPLE_PASSWORD = 1,
    /*!
     * Keyed SHA1 authentication. In this method of authentication, the SHA1
     *  hash of the outgoing BFD packet (without the key) along with a sequence
     *  number is included in the packet. The sequence number needs to be
     *  occasionally incremented to prevent replay attacks.
     */
    BCMLTD_COMMON_OAM_BFD_AUTH_TYPE_T_T_KEYED_SHA1 = 2,
    /*!
     * Meticulous keyed SHA1. This is very similar to the keyed SHA1
     *  authentication, the only difference is that the sequence number is
     *  incremented every packet.
     */
    BCMLTD_COMMON_OAM_BFD_AUTH_TYPE_T_T_METICULOUS_KEYED_SHA1 = 3,
} bcmltd_common_oam_bfd_auth_type_t_t;

/*! enum type for OAM_BFD_CONTROL_STATE_T
 * Enum defines the operational state of the OAM_BFD_CONTROL entry.
 */
typedef enum bcmltd_common_oam_bfd_control_state_t_e {
    /*! Success.  */
    BCMLTD_COMMON_OAM_BFD_CONTROL_STATE_T_T_SUCCESS = 0,
    /*!
     * Bidirectional Forwarding Detection (BFD) embedded application is
     *  not initialized.
     */
    BCMLTD_COMMON_OAM_BFD_CONTROL_STATE_T_T_APP_NOT_INITIALIZED = 1,
} bcmltd_common_oam_bfd_control_state_t_t;

/*! enum type for OAM_BFD_DIAG_CODE_T
 * Enum defines the different diagnostic codes.
 */
typedef enum bcmltd_common_oam_bfd_diag_code_t_e {
    /*! No diagnostic.  */
    BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_T_NO_DIAGNOSTIC = 0,
    /*! Control detection time expired.  */
    BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_T_CONTROL_DETECTION_TIME_EXPIRED = 1,
    /*! Echo function failed.  */
    BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_T_ECHO_FUNCTION_FAILED = 2,
    /*! Neighbor signaled session down.  */
    BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_T_NEIGHBOR_SIGNALED_SESSION_DOWN = 3,
    /*! Forwarding plane reset.  */
    BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_T_FORWARDING_PLANE_RESET = 4,
    /*! Path down.  */
    BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_T_PATH_DOWN = 5,
    /*! Concatenated path down.  */
    BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_T_CONCATENATED_PATH_DOWN = 6,
    /*! Administratively down.  */
    BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_T_ADMINISTRATIVELY_DOWN = 7,
    /*! Reverse concatenated path down.  */
    BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_T_REVERSE_CONCATENATED_PATH_DOWN = 8,
    /*! Misconnectivity defect.  */
    BCMLTD_COMMON_OAM_BFD_DIAG_CODE_T_T_MISCONNECTIVITY_DEFECT = 9,
} bcmltd_common_oam_bfd_diag_code_t_t;

/*! enum type for OAM_BFD_ENDPOINT_EVENT_T
 * Enum defines the events that are raised by BFD endpoints.
 */
typedef enum bcmltd_common_oam_bfd_endpoint_event_t_e {
    /*! The endpoint state has changed to ADMIN_DOWN.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_LOCAL_STATE_ADMIN_DOWN = 0,
    /*! The endpoint state has changed to DOWN.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_LOCAL_STATE_DOWN = 1,
    /*! The endpoint state has changed to INIT.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_LOCAL_STATE_INIT = 2,
    /*! The endpoint state has changed to UP.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_LOCAL_STATE_UP = 3,
    /*!
     * The remote endpoint state or mode has changed. The REMOTE_STATE and
     *  REMOTE_MODE fields in the associated OAM_BFD IP or TNL endpoint status
     *  tables reflect the current state and mode of the remote endpoint.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_REMOTE_STATE_MODE_CHANGE = 4,
    /*!
     * The remote endpoint discriminator has changed. The REMOTE_DISCRIMINATOR
     *  field in the associated OAM_BFD IP or TNL endpoint status tables reflect
     *  the current remote discriminator.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_REMOTE_DISCRIMINATOR_CHANGE = 5,
    /*!
     * One or more parameters of the remote endpoint has changed. The associated
     *  OAM_BFD IP or TNL endpoint status tables reflect the current parameters
     *  of the remote endpoint.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_REMOTE_PARAMETER_CHANGE = 6,
    /*! Received a BFD packet from the remote endpoint with the poll bit set.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_REMOTE_POLL_BIT_SET = 7,
    /*! Received a BFD packet from the remote endpoint with the final bit set.\n */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_REMOTE_FINAL_BIT_SET = 8,
    /*! Misconnectivity defect detected.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_MISCONNECTIVITY_DEFECT = 9,
    /*! Misconnectivity defect cleared.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_MISCONNECTIVITY_DEFECT_CLEAR = 10,
    /*! Unexpected Maintenance Entity Group (MEG) defect detected.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_UNEXPECTED_MEG_DEFECT = 11,
    /*! Unexpected MEG defect cleared.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_EVENT_T_T_UNEXPECTED_MEG_DEFECT_CLEAR = 12,
} bcmltd_common_oam_bfd_endpoint_event_t_t;

/*! enum type for OAM_BFD_ENDPOINT_ID_STATE_T
 * Enum defines the state of an OAM_BFD endpoint ID.
 */
typedef enum bcmltd_common_oam_bfd_endpoint_id_state_t_e {
    /*! The associated endpoint ID is created and is active.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_ID_STATE_T_T_ENDPOINT_ID_ACTIVE = 0,
    /*!
     * The associated endpoint ID is created, however it is not yet active.
     *  Check the OPERATIONAL_STATE field in the OAM_BFD endpoint table to know
     *  the reason.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_ID_STATE_T_T_ENDPOINT_ID_INACTIVE = 1,
    /*!
     * The associated endpoint ID is not created in the OAM_BFD endpoint
     *  table.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_ID_STATE_T_T_ENDPOINT_ID_NOT_FOUND = 2,
} bcmltd_common_oam_bfd_endpoint_id_state_t_t;

/*! enum type for OAM_BFD_ENDPOINT_MODE_T
 * Enum defines the different modes of a BFD endpoint.
 */
typedef enum bcmltd_common_oam_bfd_endpoint_mode_t_e {
    /*!
     * In asynchronous mode, the endpoint periodically sends BFD control packets
     *  to the remote endpoint, and also expects packets from the remote
     *  endpoint. If the packets are not received within specified time duration
     *  the session is declared as down.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_T_ASYNCHRONOUS = 0,
    /*!
     * In demand mode, it is assumed that there is an independent way of
     *  verifying the connectivity to the remote device. Once the BFD session is
     *  established, packets are only exchanged based on user input.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_MODE_T_T_DEMAND = 1,
} bcmltd_common_oam_bfd_endpoint_mode_t_t;

/*! enum type for OAM_BFD_ENDPOINT_SESSION_INIT_ROLE_T
 * Enum defines the different roles an endpoint can play during session
 *  initialization.
 */
typedef enum bcmltd_common_oam_bfd_endpoint_session_init_role_t_e {
    /*!
     * Endpoints with ACTIVE role will send packets during session
     *  initialization regardless of whether it has received any BFD packets for
     *  that session.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_SESSION_INIT_ROLE_T_T_ACTIVE = 0,
    /*!
     * Endpoints with PASSIVE role will not send packets unless it has received
     *  BFD packets from the remote endpoint.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_SESSION_INIT_ROLE_T_T_PASSIVE = 1,
} bcmltd_common_oam_bfd_endpoint_session_init_role_t_t;

/*! enum type for OAM_BFD_ENDPOINT_STATE_T
 * Enum defines the operational state of an OAM_BFD endpoint entry.
 */
typedef enum bcmltd_common_oam_bfd_endpoint_state_t_e {
    /*! Success.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_STATE_T_T_SUCCESS = 0,
    /*!
     * Number of endpoints exceed is greater than
     *  OAM_BFD_CONTROL.MAX_ENDPOINTS_OPER.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_STATE_T_T_NUM_ENDPOINTS_EXCEED_MAX = 1,
    /*!
     * The endpoint's BFD packet's size is greater than
     *  OAM_BFD_CONTROL.MAX_PKT_SIZE_OPER.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_STATE_T_T_PKT_SIZE_EXCEED_MAX = 2,
    /*!
     * The authentication ID specified by OAM_BFD_AUTH_SIMPLE_PASSWORD_ID or
     *  OAM_BFD_AUTH_SHA1_ID does not exist.
     */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_STATE_T_T_AUTH_NOT_EXISTS = 3,
} bcmltd_common_oam_bfd_endpoint_state_t_t;

/*! enum type for OAM_BFD_ENDPOINT_TX_MODE_T
 * Enum defines mode of transmission used by BFD endpoints.
 */
typedef enum bcmltd_common_oam_bfd_endpoint_tx_mode_t_e {
    /*! Stream of Bytes Module Header.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_TX_MODE_T_T_SOBMH = 0,
    /*! Raw Ethernet flow.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_TX_MODE_T_T_RAW_ETHERNET = 1,
    /*! CPU masquerade flow.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_TX_MODE_T_T_CPU_MASQUERADE = 2,
} bcmltd_common_oam_bfd_endpoint_tx_mode_t_t;

/*! enum type for OAM_BFD_ENDPOINT_TYPE_T
 * Enum defines the type of BFD endpoints.
 */
typedef enum bcmltd_common_oam_bfd_endpoint_type_t_e {
    /*! BFD over IPv4 endpoint.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_TYPE_T_T_IPV4 = 0,
    /*! BFD over IPv6 endpoint.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_TYPE_T_T_IPV6 = 1,
    /*! BFD over IPv4 tunnel endpoint.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_TYPE_T_T_TNL_IPV4 = 2,
    /*! BFD over IPv6 tunnel endpoint.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_TYPE_T_T_TNL_IPV6 = 3,
    /*! BFD over MPLS endpoint.  */
    BCMLTD_COMMON_OAM_BFD_ENDPOINT_TYPE_T_T_TNL_MPLS = 4,
} bcmltd_common_oam_bfd_endpoint_type_t_t;

/*! enum type for OAM_BFD_IP_ENDPOINT_TYPE_T
 * Enum defines the different types of BFD over IP endpoints.
 */
typedef enum bcmltd_common_oam_bfd_ip_endpoint_type_t_e {
    /*! BFD over single-hop  */
    BCMLTD_COMMON_OAM_BFD_IP_ENDPOINT_TYPE_T_T_SINGLE_HOP = 0,
    /*! BFD over multiple hops.  */
    BCMLTD_COMMON_OAM_BFD_IP_ENDPOINT_TYPE_T_T_MULTI_HOP = 1,
    /*! BFD over trunk port members.  */
    BCMLTD_COMMON_OAM_BFD_IP_ENDPOINT_TYPE_T_T_MICRO = 2,
} bcmltd_common_oam_bfd_ip_endpoint_type_t_t;

/*! enum type for OAM_BFD_SESSION_STATE_T
 * Enum defines the states of a BFD session.
 */
typedef enum bcmltd_common_oam_bfd_session_state_t_e {
    /*! Endpoint has been administratively set to down.  */
    BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_T_ADMIN_DOWN = 0,
    /*! Session is down.  */
    BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_T_DOWN = 1,
    /*! Session is initializing.  */
    BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_T_INIT = 2,
    /*! Session is up.  */
    BCMLTD_COMMON_OAM_BFD_SESSION_STATE_T_T_UP = 3,
} bcmltd_common_oam_bfd_session_state_t_t;

/*! enum type for OAM_BFD_TNL_IP_INNER_IP_TYPE_T
 * Enum defines the inner IP type for IP tunnels.
 */
typedef enum bcmltd_common_oam_bfd_tnl_ip_inner_ip_type_t_e {
    /*! IPv4.  */
    BCMLTD_COMMON_OAM_BFD_TNL_IP_INNER_IP_TYPE_T_T_IPV4 = 0,
    /*! IPv6.  */
    BCMLTD_COMMON_OAM_BFD_TNL_IP_INNER_IP_TYPE_T_T_IPV6 = 1,
} bcmltd_common_oam_bfd_tnl_ip_inner_ip_type_t_t;

/*! enum type for OAM_BFD_TNL_MPLS_ENDPOINT_ENCAP_TYPE_T
 * Enum defines the various kinds of MPLS encapsulations supported by BFD over
 *  MPLS endpoints.
 */
typedef enum bcmltd_common_oam_bfd_tnl_mpls_endpoint_encap_type_t_e {
    /*! BFD over MPLS LSP.  */
    BCMLTD_COMMON_OAM_BFD_TNL_MPLS_ENDPOINT_ENCAP_TYPE_T_T_MPLS_LSP = 0,
    /*! BFD over MPLS LSP with Penultimate Hop Popping (PHP).  */
    BCMLTD_COMMON_OAM_BFD_TNL_MPLS_ENDPOINT_ENCAP_TYPE_T_T_MPLS_LSP_PHP = 1,
    /*! BFD over MPLS pseudowire.  */
    BCMLTD_COMMON_OAM_BFD_TNL_MPLS_ENDPOINT_ENCAP_TYPE_T_T_PW = 2,
    /*! BFD over MPLS-TP with Continuity Check (CC).  */
    BCMLTD_COMMON_OAM_BFD_TNL_MPLS_ENDPOINT_ENCAP_TYPE_T_T_MPLS_TP_CC = 3,
    /*!
     * BFD over MPLS-TP with Continuity Check (CC) and Connectivity
     *  Verification (CV).
     */
    BCMLTD_COMMON_OAM_BFD_TNL_MPLS_ENDPOINT_ENCAP_TYPE_T_T_MPLS_TP_CC_CV = 4,
} bcmltd_common_oam_bfd_tnl_mpls_endpoint_encap_type_t_t;

/*! enum type for OAM_BFD_TNL_MPLS_ENDPOINT_IP_ENCAP_TYPE_T
 * Enum defines the IP encapsulation types used by BFD over MPLS
 *  endpoints.
 */
typedef enum bcmltd_common_oam_bfd_tnl_mpls_endpoint_ip_encap_type_t_e {
    /*! No IP encapsulation (raw BFD).  */
    BCMLTD_COMMON_OAM_BFD_TNL_MPLS_ENDPOINT_IP_ENCAP_TYPE_T_T_NONE = 0,
    /*! IPv4 header.  */
    BCMLTD_COMMON_OAM_BFD_TNL_MPLS_ENDPOINT_IP_ENCAP_TYPE_T_T_IPV4 = 1,
    /*! IPv6 header.  */
    BCMLTD_COMMON_OAM_BFD_TNL_MPLS_ENDPOINT_IP_ENCAP_TYPE_T_T_IPV6 = 2,
} bcmltd_common_oam_bfd_tnl_mpls_endpoint_ip_encap_type_t_t;

/*! enum type for OBM_HEADER_TYPE_T
 * OBM header types.
 */
typedef enum bcmltd_common_obm_header_type_t_e {
    /*! Ethernet header type.  */
    BCMLTD_COMMON_OBM_HEADER_TYPE_T_T_OBM_HEADER_TYPE_ETHERNET = 0,
    /*! Generic stacking header type.  */
    BCMLTD_COMMON_OBM_HEADER_TYPE_T_T_OBM_HEADER_TYPE_GENERIC_STACKING_HEADER = 1,
} bcmltd_common_obm_header_type_t_t;

/*! enum type for OOBFC_EGRESS_SIZE_T
 * Enum defining the size of OOBFC egress reporting.
 */
typedef enum bcmltd_common_oobfc_egress_size_t_e {
    /*!
     * Egress congestion states are packed into 8 bit
     *  messages in the OOBFC frame.
     */
    BCMLTD_COMMON_OOBFC_EGRESS_SIZE_T_T_EGRESS_SIZE_8 = 0,
    /*!
     * Egress congestion states are packed into 16 bit
     *  messages in the OOBFC frame.
     */
    BCMLTD_COMMON_OOBFC_EGRESS_SIZE_T_T_EGRESS_SIZE_16 = 1,
} bcmltd_common_oobfc_egress_size_t_t;

/*! enum type for PC_ENCAP_T
 * \brief Globally available packet encapsulations.
 */
typedef enum bcmltd_common_pc_encap_t_e {
    /*! Standard Ethernet encapsulation.  */
    BCMLTD_COMMON_PC_ENCAP_T_T_PC_ENCAP_IEEE = 0,
    /*! Broadcom HiGig2 encapsulation.  */
    BCMLTD_COMMON_PC_ENCAP_T_T_PC_ENCAP_HIGIG = 1,
    /*! Broadcom HiGig3 encapsulation.  */
    BCMLTD_COMMON_PC_ENCAP_T_T_PC_ENCAP_HIGIG3 = 2,
} bcmltd_common_pc_encap_t_t;

/*! enum type for PC_ENTRY_STATE_T
 * \brief Port entry state enumerations.
 */
typedef enum bcmltd_common_pc_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical port not configured.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_PORT_UNKNOWN = 1,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_PORT_MAP_UNKNOWN = 2,
    /*! Logical port speed configuration missing.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_PORT_SPEED_UNKNOWN = 3,
    /*! Number of lanes configuration missing for the logical port.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_PORT_NUM_LANES_UNKNOWN = 4,
    /*! Profile incomplete.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_PROFILE_INCOMPELETE = 5,
    /*! Port configuration incomplete.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_PORT_CFG_INCOMPELETE = 6,
    /*! Physical Port invalid.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_PHYSICAL_PORT_INVALID = 7,
    /*! Physical Port invalid.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_RLM_AUTONEG_CFG_CONFLICT = 8,
    /*! RLM not supported on the logical port.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_RLM_NO_SUPPORT = 9,
    /*!
     * RLM not supported on the logical port
     *  with the current speed setting.
     */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_RLM_CFG_PORT_SPEED_INVALID = 10,
    /*!
     * RLM configuration invalid, due to
     *  incorrect active lane mask selection
     *  on the logical port.
     */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_RLM_CFG_ACTIVE_LANE_MASK_INVALID = 11,
    /*!
     * Physical port conflict.
     *  Indicates that the same physical port is mapped to
     *  multiple logical ports. This could be due to incorrect
     *  number of lanes configuration for a llgical port or
     *  could be due to incorrect logical to physcial map
     *  configuration.
     */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_PHYSICAL_PORT_CONFLICT = 12,
    /*!
     * PM VCO violation, this indicates that the logical port
     *  comfiguration resulted in VCO setting which cannot
     *  be honored due to current PM VCO selection based on the
     *  already configured logical ports withing the PM>
     */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_PORT_CFG_PM_VCO_VIOLATION = 13,
    /*! Internal Port Macro, invalid configuration.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_INTERNAL_PM = 14,
    /*! Internal Port Macro, invalid configuration.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_PM_INACTIVE = 15,
    /*!
     * Indicates that Link Training (CLAUSE 72) is enabled on the
     *  logical port.
     */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_LINK_TRAINING_ACTIVE = 16,
    /*! Indicates that the configuration is not valid.  */
    BCMLTD_COMMON_PC_ENTRY_STATE_T_T_CONFIG_INVALID = 17,
} bcmltd_common_pc_entry_state_t_t;

/*! enum type for PC_FEC_T
 * \brief Port Control FEC types.
 *
 *  PHY Forward Error Correction (FEC) types.
 */
typedef enum bcmltd_common_pc_fec_t_e {
    /*! No FEC.  */
    BCMLTD_COMMON_PC_FEC_T_T_PC_FEC_NONE = 0,
    /*! BASE-R FEC (IEEE 802.3 clause 74).  */
    BCMLTD_COMMON_PC_FEC_T_T_PC_FEC_BASE_R = 1,
    /*! RS-528 FEC  */
    BCMLTD_COMMON_PC_FEC_T_T_PC_FEC_RS528 = 2,
    /*! RS-544 FEC, using 1xN RS FEC architecture.  */
    BCMLTD_COMMON_PC_FEC_T_T_PC_FEC_RS544 = 3,
    /*! RS-272 FEC, using 1xN RS FEC architecture.  */
    BCMLTD_COMMON_PC_FEC_T_T_PC_FEC_RS272 = 4,
    /*! RS 544 FEC, using 2xN RS FEC architecture.  */
    BCMLTD_COMMON_PC_FEC_T_T_PC_FEC_RS544_2XN = 5,
    /*! RS 272 FEC, using 2xN RS FEC architecture.  */
    BCMLTD_COMMON_PC_FEC_T_T_PC_FEC_RS272_2XN = 6,
} bcmltd_common_pc_fec_t_t;

/*! enum type for PC_LOOPBACK_T
 * \brief Port Control loopback types.
 *
 *  PHY_PCS loopback is inside PCS close to PMD boundary.
 *
 *  PHY_PMD loopback is inside PMD close to AFE.
 *
 *  Local loopback is used to loop the system TX packets back
 *  to the system RX.
 *
 *  REMOTE_PCS loopback is inside PCS close to MAC.
 *
 *  REMOTE_PMD loopback is inside PMD close to PCS.
 *
 *  Remote looback is used to loop the system RX packets to the
 *  system TX.
 */
typedef enum bcmltd_common_pc_loopback_t_e {
    /*! No loopback.  */
    BCMLTD_COMMON_PC_LOOPBACK_T_T_PC_LPBK_NONE = 0,
    /*! MAC loopback.  */
    BCMLTD_COMMON_PC_LOOPBACK_T_T_PC_LPBK_MAC = 1,
    /*! PCS loopback.  */
    BCMLTD_COMMON_PC_LOOPBACK_T_T_PC_LPBK_PCS = 2,
    /*! PMD loopback.  */
    BCMLTD_COMMON_PC_LOOPBACK_T_T_PC_LPBK_PMD = 3,
    /*! PCS remote loopback.  */
    BCMLTD_COMMON_PC_LOOPBACK_T_T_PC_LPBK_REMOTE_PCS = 4,
    /*! PMD remote loopback.  */
    BCMLTD_COMMON_PC_LOOPBACK_T_T_PC_LPBK_REMOTE_PMD = 5,
} bcmltd_common_pc_loopback_t_t;

/*! enum type for PC_MAC_STATUS_T
 * \brief Globally available port state.
 */
typedef enum bcmltd_common_pc_mac_status_t_e {
    /*! Both RX and TX are disabled,  */
    BCMLTD_COMMON_PC_MAC_STATUS_T_T_TX_RX_OFF = 0,
    /*! Both RX and TX are enabled.  */
    BCMLTD_COMMON_PC_MAC_STATUS_T_T_TX_RX_ON = 1,
    /*! Only RX is enabled and TX is disabled.  */
    BCMLTD_COMMON_PC_MAC_STATUS_T_T_RX_ON = 2,
    /*! Only TX is enabled and RX is disabled.  */
    BCMLTD_COMMON_PC_MAC_STATUS_T_T_TX_ON = 3,
} bcmltd_common_pc_mac_status_t_t;

/*! enum type for PC_OPERATIONAL_STATE_T
 * Enumerations defining the status of operations on a port.
 */
typedef enum bcmltd_common_pc_operational_state_t_e {
    /*! Successful operation.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_OPER_SUCCESS = 0,
    /*! Invalid port.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_PORT_INVALID = 1,
    /*! Invalid speed configuration.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_SPEED_INVALID = 2,
    /*!
     * Number of VCO?s required to support the operation is
     *  more than what the hardware supports.
     */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_VCO_UNAVAIL = 3,
    /*! Port deletion failed.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_PORT_ACTIVE = 4,
    /*!
     * PAM4 encoding not supported with the current
     *  primary VCO setting.
     */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_PRIMARY_VCO_CFG_INVALID = 5,
    /*! The lane number is not valid for this port.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_LANE_MASK_INVALID = 6,
    /*! Unsupported loopback type.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_LOOPBACK_TYPE_INVALID = 7,
    /*! Port ability configuration not supported.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_ABILITY_PORT_CFG_INVALID = 8,
    /*! Pause setting conflicts in the port abilities.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_ABILITY_PAUSE_CONFLICT = 9,
    /*!
     * The current port media type conflicts the media
     *  setting in the abilities.
     */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_ABILITY_MEDIA_TYPE_CONFLICT = 10,
    /*! FEC configuration conflicts in the abilities configuration.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_ABILITY_FEC_CONFLICT = 11,
    /*! Channel configuration conflicts in the ability configuration.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_ABILITY_CHANNEL_CONFLICT = 12,
    /*! Invalid advertisement configuration.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_ABILITY_ADVERT_CFG_INVALID = 13,
    /*! Conflict in auto-negotiation configuration in abilities.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_ABILITY_AN_CONFLICT_CFG = 14,
    /*! Invalid auto-negotiation mode configuration.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_AN_MODE_INVALID = 15,
    /*! MAC operation error.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_MAC_OPER_ERROR = 16,
    /*! PHY operation error.  */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_PHY_OPER_ERROR = 17,
    /*!
     * Logical port is in suspended state, only operation allowed is
     *  to disable the suspended state.
     */
    BCMLTD_COMMON_PC_OPERATIONAL_STATE_T_T_PC_PORT_SUSPENDED = 18,
} bcmltd_common_pc_operational_state_t_t;

/*! enum type for PC_PAM4_TX_PATTERN_T
 * \brief PAM4 TX pattern types.
 *
 *  PAM4 TX pattarn types.
 */
typedef enum bcmltd_common_pc_pam4_tx_pattern_t_e {
    /*! PAM4 TX pattern NONE.  */
    BCMLTD_COMMON_PC_PAM4_TX_PATTERN_T_T_PC_PAM4_TX_PATTERN_NONE = 0,
    /*!
     * PAM4 TX JP03B pattern.
     *  JP03B - p0330 means:
     *  8'b_0011_1100 or 8'h3C w/o  Gray coding.
     *  8'b_0010_1000 or 8'h28 with Gray coding.
     */
    BCMLTD_COMMON_PC_PAM4_TX_PATTERN_T_T_PC_PAM4_TX_PATTERN_JP03B = 1,
    /*! PAM4 TX linearity pattern.  */
    BCMLTD_COMMON_PC_PAM4_TX_PATTERN_T_T_PC_PAM4_TX_PATTERN_LINEAR = 2,
} bcmltd_common_pc_pam4_tx_pattern_t_t;

/*! enum type for PC_PAUSE_T
 * \brief Port pause types.
 */
typedef enum bcmltd_common_pc_pause_t_e {
    /*! No PAUSE.  */
    BCMLTD_COMMON_PC_PAUSE_T_T_PC_PAUSE_NONE = 0,
    /*! TX pause.  */
    BCMLTD_COMMON_PC_PAUSE_T_T_PC_PAUSE_TX = 1,
    /*! RX pause.  */
    BCMLTD_COMMON_PC_PAUSE_T_T_PC_PAUSE_RX = 2,
    /*! Symmetric pause, both RX and TX.  */
    BCMLTD_COMMON_PC_PAUSE_T_T_PC_PAUSE_SYMM = 3,
} bcmltd_common_pc_pause_t_t;

/*! enum type for PC_PHY_AUTONEG_MODE_T
 * \brief PHY autoneg mode.
 */
typedef enum bcmltd_common_pc_phy_autoneg_mode_t_e {
    /*! NONE autoneg mode.  */
    BCMLTD_COMMON_PC_PHY_AUTONEG_MODE_T_T_PC_PHY_AUTONEG_MODE_NONE = 0,
    /*! CLAUSE 37.  */
    BCMLTD_COMMON_PC_PHY_AUTONEG_MODE_T_T_PC_PHY_AUTONEG_MODE_CL37 = 1,
    /*! CLAUSE 37 BAM.  */
    BCMLTD_COMMON_PC_PHY_AUTONEG_MODE_T_T_PC_PHY_AUTONEG_MODE_CL37_BAM = 2,
    /*! CLAUSE 73.  */
    BCMLTD_COMMON_PC_PHY_AUTONEG_MODE_T_T_PC_PHY_AUTONEG_MODE_CL73 = 3,
    /*! CLAUSE 73 BAM.  */
    BCMLTD_COMMON_PC_PHY_AUTONEG_MODE_T_T_PC_PHY_AUTONEG_MODE_CL73_BAM = 4,
    /*! MSA (Multi-Source agreement) mode.  */
    BCMLTD_COMMON_PC_PHY_AUTONEG_MODE_T_T_PC_PHY_AUTONEG_MODE_MSA = 5,
    /*! SGMII mode.  */
    BCMLTD_COMMON_PC_PHY_AUTONEG_MODE_T_T_PC_PHY_AUTONEG_MODE_SGMII = 6,
} bcmltd_common_pc_phy_autoneg_mode_t_t;

/*! enum type for PC_PHY_CHANNEL_TYPE_T
 * \brief PHY channel types.
 */
typedef enum bcmltd_common_pc_phy_channel_type_t_e {
    /*! Short channel.  */
    BCMLTD_COMMON_PC_PHY_CHANNEL_TYPE_T_T_PC_PHY_CHANNEL_SHORT = 0,
    /*! Long channel.  */
    BCMLTD_COMMON_PC_PHY_CHANNEL_TYPE_T_T_PC_PHY_CHANNEL_LONG = 1,
    /*! All channel type.  */
    BCMLTD_COMMON_PC_PHY_CHANNEL_TYPE_T_T_PC_PHY_CHANNEL_ALL = 2,
} bcmltd_common_pc_phy_channel_type_t_t;

/*! enum type for PC_PHY_MEDIUM_T
 * \brief PHY medium types.
 */
typedef enum bcmltd_common_pc_phy_medium_t_e {
    /*! Medium type backplane(KR).  */
    BCMLTD_COMMON_PC_PHY_MEDIUM_T_T_PC_PHY_MEDIUM_BACKPLANE = 0,
    /*! Medium type copper(CR).  */
    BCMLTD_COMMON_PC_PHY_MEDIUM_T_T_PC_PHY_MEDIUM_COPPER = 1,
    /*! Medium type Optical.  */
    BCMLTD_COMMON_PC_PHY_MEDIUM_T_T_PC_PHY_MEDIUM_OPTICAL = 2,
} bcmltd_common_pc_phy_medium_t_t;

/*! enum type for PC_PHY_SUPPORTED_MEDIUM_T
 * \brief PHY medium types.
 */
typedef enum bcmltd_common_pc_phy_supported_medium_t_e {
    /*! Medium type backplane(KR).  */
    BCMLTD_COMMON_PC_PHY_SUPPORTED_MEDIUM_T_T_PC_PHY_MEDIUM_BACKPLANE = 0,
    /*! Medium type copper(CR).  */
    BCMLTD_COMMON_PC_PHY_SUPPORTED_MEDIUM_T_T_PC_PHY_MEDIUM_COPPER = 1,
    /*! Medium type Optical.  */
    BCMLTD_COMMON_PC_PHY_SUPPORTED_MEDIUM_T_T_PC_PHY_MEDIUM_OPTICAL = 2,
    /*! All Medium type.  */
    BCMLTD_COMMON_PC_PHY_SUPPORTED_MEDIUM_T_T_PC_PHY_MEDIUM_ALL = 3,
} bcmltd_common_pc_phy_supported_medium_t_t;

/*! enum type for PC_PM_TYPE_T
 * \brief Globally available port macro types.
 *
 *  Each port macro type offers different configuration options.
 */
typedef enum bcmltd_common_pc_pm_type_t_e {
    /*! Ensure that zero is not interpreted as a valid type.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_NONE = 0,
    /*! CPU port block.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_CPU = 1,
    /*! Loopback port block.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_LOOPBACK = 2,
    /*! PM4x10.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_PM4X10 = 3,
    /*! PM4x25.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_PM4X25 = 4,
    /*! PM8x50.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_PM8X50 = 5,
    /*! PM8x50 2nd generation.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_PM8X50_GEN2 = 6,
    /*! PM8x50 3rd generation.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_PM8X50_GEN3 = 7,
    /*! PM8x100.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_PM8X100 = 8,
    /*! PM8x100 2nd generation.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_PM8X100_GEN2 = 9,
    /*! PMQTC.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_PMQTC = 10,
    /*! PMSGMII4Px2.  */
    BCMLTD_COMMON_PC_PM_TYPE_T_T_PC_PM_TYPE_PMSGMII4PX2 = 11,
} bcmltd_common_pc_pm_type_t_t;

/*! enum type for PC_PORT_TIMESYNC_MODE_T
 * Port time synchronization modes.
 */
typedef enum bcmltd_common_pc_port_timesync_mode_t_e {
    /*! No time synchronization support.  */
    BCMLTD_COMMON_PC_PORT_TIMESYNC_MODE_T_T_PC_PORT_TIMESYNC_MODE_NONE = 0,
    /*! IEEE 1588 based time synchronization.  */
    BCMLTD_COMMON_PC_PORT_TIMESYNC_MODE_T_T_PC_PORT_TIMESYNC_MODE_1588 = 1,
    /*! SyncE (Synchronous Ethernet) based time synchronization.  */
    BCMLTD_COMMON_PC_PORT_TIMESYNC_MODE_T_T_PC_PORT_TIMESYNC_MODE_SYNCE = 2,
} bcmltd_common_pc_port_timesync_mode_t_t;

/*! enum type for PC_RLM_STATUS_T
 * \brief RLM (Reduced Lane Mode) status enumerations.
 */
typedef enum bcmltd_common_pc_rlm_status_t_e {
    /*! RLM is not enabled.  */
    BCMLTD_COMMON_PC_RLM_STATUS_T_T_PC_RLM_DISABLE = 0,
    /*! RLM operation in progress.  */
    BCMLTD_COMMON_PC_RLM_STATUS_T_T_PC_RLM_BUSY = 1,
    /*! RLM operation in progress.  */
    BCMLTD_COMMON_PC_RLM_STATUS_T_T_PC_RLM_DONE = 2,
    /*! RLM operation failed.  */
    BCMLTD_COMMON_PC_RLM_STATUS_T_T_PC_RLM_FAILED = 3,
} bcmltd_common_pc_rlm_status_t_t;

/*! enum type for PC_SERDES_FW_LOAD_METHOD_T
 * Enumerations defining the firmware download method.
 */
typedef enum bcmltd_common_pc_serdes_fw_load_method_t_e {
    /*! Fast/parallel load method.  */
    BCMLTD_COMMON_PC_SERDES_FW_LOAD_METHOD_T_T_PC_SERDES_FW_FAST_LOAD = 0,
    /*! Slow load method using MDIO.  */
    BCMLTD_COMMON_PC_SERDES_FW_LOAD_METHOD_T_T_PC_SERDES_FW_SLOW_LOAD = 1,
} bcmltd_common_pc_serdes_fw_load_method_t_t;

/*! enum type for PC_SIG_MODE_T
 * \brief Port Control singalling modes.
 *
 *  PHY signalling modes for Tx.
 */
typedef enum bcmltd_common_pc_sig_mode_t_e {
    /*! NRZ mode.  */
    BCMLTD_COMMON_PC_SIG_MODE_T_T_PC_SIG_MODE_NRZ = 0,
    /*! PAM4 mode  */
    BCMLTD_COMMON_PC_SIG_MODE_T_T_PC_SIG_MODE_PAM4 = 1,
} bcmltd_common_pc_sig_mode_t_t;

/*! enum type for PC_SPEED_VCO_T
 * \brief Port VCO frequency setting.
 *
 *  Specify VCO (Voltage-Controlled Oscillator) frequency
 *  for configured port speed.
 */
typedef enum bcmltd_common_pc_speed_vco_t_e {
    /*! No specific VCO.  */
    BCMLTD_COMMON_PC_SPEED_VCO_T_T_PC_SPEED_VCO_NONE = 0,
    /*! Speed 1G running at 6.25G VCO.  */
    BCMLTD_COMMON_PC_SPEED_VCO_T_T_PC_SPEED_1G_AT_6P25G_VCO = 1,
    /*! Speed 1G running at 12.5G VCO.  */
    BCMLTD_COMMON_PC_SPEED_VCO_T_T_PC_SPEED_1G_AT_12P5G_VCO = 2,
    /*! Speed 1G running at 25.781G VCO.  */
    BCMLTD_COMMON_PC_SPEED_VCO_T_T_PC_SPEED_1G_AT_25P781G_VCO = 3,
    /*! Speed 2.5G running at 12.5G VCO.  */
    BCMLTD_COMMON_PC_SPEED_VCO_T_T_PC_SPEED_2P5G_AT_12P5G_VCO = 4,
    /*! Speed 5G running at 12.5G VCO.  */
    BCMLTD_COMMON_PC_SPEED_VCO_T_T_PC_SPEED_5G_AT_12P5G_VCO = 5,
} bcmltd_common_pc_speed_vco_t_t;

/*! enum type for PC_STALL_TX_STATUS_T
 * \brief Globally available port transmission status (STALL_TX).
 */
typedef enum bcmltd_common_pc_stall_tx_status_t_e {
    /*! Transmission of packets enabled.  */
    BCMLTD_COMMON_PC_STALL_TX_STATUS_T_T_PC_STALL_TX_DISABLE = 0,
    /*! Transmission of packets disabled.  */
    BCMLTD_COMMON_PC_STALL_TX_STATUS_T_T_PC_STALL_TX_ENABLE = 1,
    /*! Transmission control Feature not supported.  */
    BCMLTD_COMMON_PC_STALL_TX_STATUS_T_T_PC_STALL_TX_NO_SUPPORT = 2,
} bcmltd_common_pc_stall_tx_status_t_t;

/*! enum type for PC_SUPPORTED_PAUSE_T
 * \brief Port supported pause types.
 */
typedef enum bcmltd_common_pc_supported_pause_t_e {
    /*! No PAUSE.  */
    BCMLTD_COMMON_PC_SUPPORTED_PAUSE_T_T_PC_PAUSE_NONE = 0,
    /*! TX pause.  */
    BCMLTD_COMMON_PC_SUPPORTED_PAUSE_T_T_PC_PAUSE_TX = 1,
    /*! RX pause.  */
    BCMLTD_COMMON_PC_SUPPORTED_PAUSE_T_T_PC_PAUSE_RX = 2,
    /*! Symmetric pause, both RX and TX.  */
    BCMLTD_COMMON_PC_SUPPORTED_PAUSE_T_T_PC_PAUSE_SYMM = 3,
    /*! Combination of all pause types.  */
    BCMLTD_COMMON_PC_SUPPORTED_PAUSE_T_T_PC_PAUSE_ALL = 4,
} bcmltd_common_pc_supported_pause_t_t;

/*! enum type for PC_SYNCE_STAGE0_MODE_T
 * Port SyncE stage0 divider modes.
 */
typedef enum bcmltd_common_pc_synce_stage0_mode_t_e {
    /*!
     * SyncE stage divider: No divider.
     *  Can be applied to both stage 0 and stage 1.
     */
    BCMLTD_COMMON_PC_SYNCE_STAGE0_MODE_T_T_PC_SYNCE_STAGE_0_MODE_DIV_NONE = 0,
    /*!
     * SyncE stage 0 divider: gap divider,
     *  4 clocks out for every 5 clocks in.
     */
    BCMLTD_COMMON_PC_SYNCE_STAGE0_MODE_T_T_PC_SYNCE_STAGE_0_MODE_DIV_GAP_CLK_4_OVER_5 = 1,
    /*! SyncE stage 0 divider: SDM fractional divider.  */
    BCMLTD_COMMON_PC_SYNCE_STAGE0_MODE_T_T_PC_SYNCE_STAGE_0_MODE_SDM_FRAC_DIV = 2,
} bcmltd_common_pc_synce_stage0_mode_t_t;

/*! enum type for PC_SYNCE_STAGE1_MODE_T
 * Port SyncE stage1 divider modes.
 */
typedef enum bcmltd_common_pc_synce_stage1_mode_t_e {
    /*! SyncE stage divider: No divider.\n */
    BCMLTD_COMMON_PC_SYNCE_STAGE1_MODE_T_T_PC_SYNCE_STAGE_1_MODE_DIV_NONE = 0,
    /*! SyncE stage 1 divider: 7.  */
    BCMLTD_COMMON_PC_SYNCE_STAGE1_MODE_T_T_PC_SYNCE_STAGE_1_MODE_DIV_7 = 1,
    /*! SyncE stage 1 divider: 11.  */
    BCMLTD_COMMON_PC_SYNCE_STAGE1_MODE_T_T_PC_SYNCE_STAGE_1_MODE_DIV_11 = 2,
} bcmltd_common_pc_synce_stage1_mode_t_t;

/*! enum type for PC_SYNCE_STAGE_MODE_T
 * Port SyncE stage divider modes.
 */
typedef enum bcmltd_common_pc_synce_stage_mode_t_e {
    /*!
     * SyncE stage divider: No divider.
     *  Can be applied to both stage 0 and stage 1.
     */
    BCMLTD_COMMON_PC_SYNCE_STAGE_MODE_T_T_PC_SYNCE_MODE_DIV_NONE = 0,
    /*!
     * SyncE stage 0 divider: gap divider,
     *  4 clocks out for every 5 clocks in.
     */
    BCMLTD_COMMON_PC_SYNCE_STAGE_MODE_T_T_PC_SYNCE_STAGE_0_MODE_DIV_GAP_CLK_4_OVER_5 = 1,
    /*! SyncE stage 0 divider: SDM fractional divider.  */
    BCMLTD_COMMON_PC_SYNCE_STAGE_MODE_T_T_PC_SYNCE_STAGE_0_MODE_SDM_FRAC_DIV = 2,
    /*! SyncE stage 1 divider: 7.  */
    BCMLTD_COMMON_PC_SYNCE_STAGE_MODE_T_T_PC_SYNCE_STAGE_1_MODE_DIV_7 = 3,
    /*! SyncE stage 1 divider: 11.  */
    BCMLTD_COMMON_PC_SYNCE_STAGE_MODE_T_T_PC_SYNCE_STAGE_1_MODE_DIV_11 = 4,
} bcmltd_common_pc_synce_stage_mode_t_t;

/*! enum type for PC_TS_COMP_MODE_T
 * \brief Timesync compensation mode.
 */
typedef enum bcmltd_common_pc_ts_comp_mode_t_e {
    /*! None Timesync compensation.  */
    BCMLTD_COMMON_PC_TS_COMP_MODE_T_T_PC_TIMESYNC_COMP_NONE = 0,
    /*! Timesync compensation earlist lane mode.  */
    BCMLTD_COMMON_PC_TS_COMP_MODE_T_T_PC_TIMESYNC_COMP_EARLIEST_LANE = 1,
    /*! Timesync compensation earlist lane mode.  */
    BCMLTD_COMMON_PC_TS_COMP_MODE_T_T_PC_TIMESYNC_COMP_LATEST_LANE = 2,
} bcmltd_common_pc_ts_comp_mode_t_t;

/*! enum type for PC_TXFIR_TAP_MODE_T
 * \brief Port Control Tx tap modes.
 *
 *  PHY Tx tap modes are used to select how many taps to be used
 *  for the Tx equalization setting.
 */
typedef enum bcmltd_common_pc_txfir_tap_mode_t_e {
    BCMLTD_COMMON_PC_TXFIR_TAP_MODE_T_T_PC_TXFIR_TAP_DEFAULT = 0,
    /*! NRZ lower power 3 taps.  */
    BCMLTD_COMMON_PC_TXFIR_TAP_MODE_T_T_PC_TXFIR_NRZ_LP_TAPS_3 = 1,
    /*! NRZ 6 taps  */
    BCMLTD_COMMON_PC_TXFIR_TAP_MODE_T_T_PC_TXFIR_NRZ_TAPS_6 = 2,
    /*! PAM4 lower power 3 taps.  */
    BCMLTD_COMMON_PC_TXFIR_TAP_MODE_T_T_PC_TXFIR_PAM4_LP_TAPS_3 = 3,
    /*! PAM4 6 taps.  */
    BCMLTD_COMMON_PC_TXFIR_TAP_MODE_T_T_PC_TXFIR_PAM4_TAPS_6 = 4,
} bcmltd_common_pc_txfir_tap_mode_t_t;

/*! enum type for PC_TX_TAP_MODE_T
 * \brief Port Control Tx tap modes.
 *
 *  PHY Tx tap modes is used to select how many taps would be used
 *  for the Tx equalization setting.
 */
typedef enum bcmltd_common_pc_tx_tap_mode_t_e {
    /*!
     * Default mode.
     *
     *  Applicable only for PC_PM_LANE_STATUS.TX_TAP_MODE.
     *  To indicate the underlying PHY does not support the tap mode selection.
     */
    BCMLTD_COMMON_PC_TX_TAP_MODE_T_T_PC_TX_TAP_MODE_DEFAULT = 0,
    /*! 6-taps mode.  */
    BCMLTD_COMMON_PC_TX_TAP_MODE_T_T_PC_TX_TAP_MODE_TAPS_6 = 1,
    /*! 3-taps mode  */
    BCMLTD_COMMON_PC_TX_TAP_MODE_T_T_PC_TX_TAP_MODE_TAPS_3 = 2,
} bcmltd_common_pc_tx_tap_mode_t_t;

/*! enum type for PT_OP_STATUS_T
 * Operation Status Type definitions.
 */
typedef enum bcmltd_common_pt_op_status_t_e {
    /*! Operation completed successfully.  */
    BCMLTD_COMMON_PT_OP_STATUS_T_T_SUCCESS = 0,
    /*! Operation failed.  */
    BCMLTD_COMMON_PT_OP_STATUS_T_T_FAILURE = 1,
} bcmltd_common_pt_op_status_t_t;

/*! enum type for PT_OP_T
 * Physical Table Operation Type definitions.
 */
typedef enum bcmltd_common_pt_op_t_e {
    /*! No operation                        */
    BCMLTD_COMMON_PT_OP_T_T_PT_OP_NOP = 0,
    /*! Pop top entry off a HW FIFO.        */
    BCMLTD_COMMON_PT_OP_T_T_PT_OP_FIFO_POP = 1,
    /*! Push a new entry onto a HW FIFO.    */
    BCMLTD_COMMON_PT_OP_T_T_PT_OP_FIFO_PUSH = 2,
    /*! Set the entry contents.             */
    BCMLTD_COMMON_PT_OP_T_T_PT_OP_SET = 3,
    /*! Modify some fields of an entry.     */
    BCMLTD_COMMON_PT_OP_T_T_PT_OP_MODIFY = 4,
    /*! Retrieve the contents of an entry via PT index.  */
    BCMLTD_COMMON_PT_OP_T_T_PT_OP_GET = 5,
    /*! Restore entry to default values.    */
    BCMLTD_COMMON_PT_OP_T_T_PT_OP_CLEAR = 6,
    /*! Insert an entry via key.            */
    BCMLTD_COMMON_PT_OP_T_T_PT_OP_INSERT = 7,
    /*! Delete an entry via key.            */
    BCMLTD_COMMON_PT_OP_T_T_PT_OP_DELETE = 8,
    /*! Search for an entry via key.        */
    BCMLTD_COMMON_PT_OP_T_T_PT_OP_LOOKUP = 9,
} bcmltd_common_pt_op_t_t;

/*! enum type for SA_OPER_STATE_T
 * Enums defining the operational state of the entry.
 */
typedef enum bcmltd_common_sa_oper_state_t_e {
    /*! The SA is valid.  */
    BCMLTD_COMMON_SA_OPER_STATE_T_T_VALID = 0,
    /*! The SA is invalid.  */
    BCMLTD_COMMON_SA_OPER_STATE_T_T_INVALID = 1,
} bcmltd_common_sa_oper_state_t_t;

/*! enum type for SA_STATE_CONTROL_T
 * Enums defining the state of the security association (SA).
 */
typedef enum bcmltd_common_sa_state_control_t_e {
    /*! The SA is invalid.  */
    BCMLTD_COMMON_SA_STATE_CONTROL_T_T_INVALID = 0,
    /*! The SA is valid.  */
    BCMLTD_COMMON_SA_STATE_CONTROL_T_T_VALID = 1,
} bcmltd_common_sa_state_control_t_t;

/*! enum type for SA_STATE_T
 * Enums defining the state of the security association (SA).
 */
typedef enum bcmltd_common_sa_state_t_e {
    /*! The SA is invalid.  */
    BCMLTD_COMMON_SA_STATE_T_T_INVALID = 0,
    /*! The SA is valid.  */
    BCMLTD_COMMON_SA_STATE_T_T_VALID = 1,
    /*! The SA packet number (PN) has exceeded the soft threshold.  */
    BCMLTD_COMMON_SA_STATE_T_T_VALID_AND_SOFT_EXPIRED = 2,
    /*! The SA packet number (PN) has exceeded the hard threshold.  */
    BCMLTD_COMMON_SA_STATE_T_T_VALID_AND_HARD_EXPIRED = 3,
    /*!
     * The incoming packet number (PN) is greater than the
     *  REPLAY_PROTECT_WINDOW value.
     *  Applicable only for decrypt/ingress path.
     */
    BCMLTD_COMMON_SA_STATE_T_T_VALID_AND_REPLAY_THD = 4,
} bcmltd_common_sa_state_t_t;

/*! enum type for SEC_BLOCK_STATE_T
 * Enums defining the operational state of the SEC block.
 */
typedef enum bcmltd_common_sec_block_state_t_e {
    /*! Valid entry  */
    BCMLTD_COMMON_SEC_BLOCK_STATE_T_T_VALID = 0,
    /*! The number of SA to SC is invalid.  */
    BCMLTD_COMMON_SEC_BLOCK_STATE_T_T_INVALID_NUM_SA_PER_SC = 3,
} bcmltd_common_sec_block_state_t_t;

/*! enum type for SEC_HEADER_ICV_MODE_T
 * Enums defining the SecTAG/ESP header ICV remove mode.
 */
typedef enum bcmltd_common_sec_header_icv_mode_t_e {
    /*! Retain both SecTAG/ESP and ICV in the packet.  */
    BCMLTD_COMMON_SEC_HEADER_ICV_MODE_T_T_STRIP_NONE = 0,
    /*! Retain SecTAG/ESP in the packet but strip off ICV.  */
    BCMLTD_COMMON_SEC_HEADER_ICV_MODE_T_T_STRIP_ICV = 1,
    /*! Strip off both SecTAG/ESP and ICV from the packet.  */
    BCMLTD_COMMON_SEC_HEADER_ICV_MODE_T_T_STRIP_SEC_HEADER_ICV = 2,
} bcmltd_common_sec_header_icv_mode_t_t;

/*! enum type for SEC_PM_STATE_T
 * Enums defining the operational state for PM to SEC
 *  block mapping.
 */
typedef enum bcmltd_common_sec_pm_state_t_e {
    /*! Valid entry  */
    BCMLTD_COMMON_SEC_PM_STATE_T_T_VALID = 0,
    /*! The port macro pair has SEC enabled.  */
    BCMLTD_COMMON_SEC_PM_STATE_T_T_CONFLICTING_PM_PAIR = 1,
} bcmltd_common_sec_pm_state_t_t;

/*! enum type for SEC_PORT_ENTRY_STATE_T */
typedef enum bcmltd_common_sec_port_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_SEC_PORT_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_SEC_PORT_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
} bcmltd_common_sec_port_entry_state_t_t;

/*! enum type for SEC_SVTAG_PKT_T
 * Enums defining the SEC packet type
 *  in SVTAG.
 */
typedef enum bcmltd_common_sec_svtag_pkt_t_e {
    /*! Unsecured data packet (untagged control port packet).  */
    BCMLTD_COMMON_SEC_SVTAG_PKT_T_T_UNSECURED_DATA_PKT = 0,
    /*! Secured data packet (tagged control port packet).  */
    BCMLTD_COMMON_SEC_SVTAG_PKT_T_T_SECURED_DATA_PKT = 1,
    /*! Management packet (non KAY/IKE uncontrolled port packet).  */
    BCMLTD_COMMON_SEC_SVTAG_PKT_T_T_NONKAY_MGMT_PKT = 2,
    /*! KAY or IKE frame (KAY/IKE uncontrolled port packet)  */
    BCMLTD_COMMON_SEC_SVTAG_PKT_T_T_KAY_IKE_PKT = 3,
} bcmltd_common_sec_svtag_pkt_t_t;

/*! enum type for SEC_VLAN_TAG_T
 * Enums defining the number of VLAN tags in the packet.
 */
typedef enum bcmltd_common_sec_vlan_tag_t_e {
    BCMLTD_COMMON_SEC_VLAN_TAG_T_T_VLAN_NONE = 0,
    BCMLTD_COMMON_SEC_VLAN_TAG_T_T_NUM_VLAN_TAG_1 = 1,
    BCMLTD_COMMON_SEC_VLAN_TAG_T_T_NUM_VLAN_TAG_2 = 2,
    BCMLTD_COMMON_SEC_VLAN_TAG_T_T_NUM_VLAN_TAG_3 = 3,
    BCMLTD_COMMON_SEC_VLAN_TAG_T_T_NUM_VLAN_TAG_4 = 4,
    BCMLTD_COMMON_SEC_VLAN_TAG_T_T_NUM_VLAN_OTHERS = 5,
} bcmltd_common_sec_vlan_tag_t_t;

/*! enum type for SYNCE_CLK_STATE_T */
typedef enum bcmltd_common_synce_clk_state_t_e {
    /*! Valid configurations.  */
    BCMLTD_COMMON_SYNCE_CLK_STATE_T_T_CONFIG_VALID = 0,
    /*! Logical port to physical map unavailable or invalid logical port.  */
    BCMLTD_COMMON_SYNCE_CLK_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
} bcmltd_common_synce_clk_state_t_t;

/*! enum type for TABLE_MAP_T
 * Logical table map type.
 */
typedef enum bcmltd_common_table_map_t_e {
    /*! Direct map.  */
    BCMLTD_COMMON_TABLE_MAP_T_T_DIRECT = 0,
    /*! Custom Table Handler.  */
    BCMLTD_COMMON_TABLE_MAP_T_T_CTH = 1,
    /*!
     * Internal Logical Table - special tables which interact with the internal
     *  workings of the Logical Table Manager, such as the TABLE_* LTs.
     */
    BCMLTD_COMMON_TABLE_MAP_T_T_INTERNAL = 2,
} bcmltd_common_table_map_t_t;

/*! enum type for TABLE_TYPE_T
 * Logical table type.
 */
typedef enum bcmltd_common_table_type_t_e {
    /*! Simple Index.  */
    BCMLTD_COMMON_TABLE_TYPE_T_T_INDEX = 0,
    /*! Index with Allocation.  */
    BCMLTD_COMMON_TABLE_TYPE_T_T_INDEX_ALLOCATE = 1,
    /*! Hash.  */
    BCMLTD_COMMON_TABLE_TYPE_T_T_HASH = 2,
    /*! TCAM.  */
    BCMLTD_COMMON_TABLE_TYPE_T_T_TCAM = 3,
    /*! Configuration.  */
    BCMLTD_COMMON_TABLE_TYPE_T_T_CONFIG = 4,
} bcmltd_common_table_type_t_t;

/*! enum type for TAGGED_PKT_VALIDATE_MODE_T
 * Enums defining the validation modes for secured packets.
 */
typedef enum bcmltd_common_tagged_pkt_validate_mode_t_e {
    /*!
     * Account and forward packets bypassing the SEC
     *  functionality.
     */
    BCMLTD_COMMON_TAGGED_PKT_VALIDATE_MODE_T_T_BYPASS = 0,
    /*!
     * Account and drop secured data packets which are marked as error
     *  or have violated SEC policies listed below.
     *  1. Integrity Check Value (ICV) check failure.
     *  2. Security association is invalid.
     *  3. Secure channel is not found.
     */
    BCMLTD_COMMON_TAGGED_PKT_VALIDATE_MODE_T_T_STRICT = 1,
    /*!
     * Account and allow packets having ICV failures.
     *  All data packets are allowed and accounted for irrespective of
     *  other policy violations.
     */
    BCMLTD_COMMON_TAGGED_PKT_VALIDATE_MODE_T_T_CHECK_ICV = 2,
    /*!
     * All data packets are allowed and accounted for irrespective of
     *  any policy violations. ICV checks are not performed.
     */
    BCMLTD_COMMON_TAGGED_PKT_VALIDATE_MODE_T_T_DISABLED = 3,
    /*! Account and drop all control and data packets.  */
    BCMLTD_COMMON_TAGGED_PKT_VALIDATE_MODE_T_T_DISCARD_ALL = 4,
} bcmltd_common_tagged_pkt_validate_mode_t_t;

/*! enum type for TELEMETRY_CONTROL_STATE_T
 * Enum defines the operational state of
 *  MON_TELEMETRY_CONTROL_STATE_T entry
 */
typedef enum bcmltd_common_telemetry_control_state_t_e {
    /*! Control entry is valid.  */
    BCMLTD_COMMON_TELEMETRY_CONTROL_STATE_T_T_VALID = 0,
    /*!
     * Telemetry embedded application is not initialized
     *  in MON_TELEMETRY_CONTROL.STREAMING_TELEMETRY field.
     */
    BCMLTD_COMMON_TELEMETRY_CONTROL_STATE_T_T_APP_NOT_INITIALIZED = 1,
    /*! Telemetry embedded application communication failure.\n */
    BCMLTD_COMMON_TELEMETRY_CONTROL_STATE_T_T_APP_COMMUNICATION_FAILURE = 2,
} bcmltd_common_telemetry_control_state_t_t;

/*! enum type for TELEMETRY_INSTANCE_STATE_T
 * Enum defines the operational state of
 *  MON_TELEMETRY_INSTANCE_STATE_T entry
 */
typedef enum bcmltd_common_telemetry_instance_state_t_e {
    /*! Instance entry is valid.  */
    BCMLTD_COMMON_TELEMETRY_INSTANCE_STATE_T_T_VALID = 0,
    /*! Telemetry control table entry error.  */
    BCMLTD_COMMON_TELEMETRY_INSTANCE_STATE_T_T_CONTROL_ENTRY_ERROR = 1,
    /*! Port entry error.  */
    BCMLTD_COMMON_TELEMETRY_INSTANCE_STATE_T_T_PORT_ENTRY_ERROR = 2,
    /*! MMU Port entry error.  */
    BCMLTD_COMMON_TELEMETRY_INSTANCE_STATE_T_T_MMU_PORT_ENTRY_ERROR = 3,
    /*! Object table entry error.  */
    BCMLTD_COMMON_TELEMETRY_INSTANCE_STATE_T_T_OBJECT_ENTRY_ERROR = 4,
    /*! Collector table entry error.  */
    BCMLTD_COMMON_TELEMETRY_INSTANCE_STATE_T_T_COLLECTOR_ENTRY_ERROR = 5,
    /*! Export profile table entry error.  */
    BCMLTD_COMMON_TELEMETRY_INSTANCE_STATE_T_T_EXPORT_PROFILE_ENTRY_ERROR = 6,
    /*! Export profile interval is not valid.  */
    BCMLTD_COMMON_TELEMETRY_INSTANCE_STATE_T_T_INVALID_INTERVAL = 7,
    /*! Export profile packet length is not valid.  */
    BCMLTD_COMMON_TELEMETRY_INSTANCE_STATE_T_T_INVALID_PACKET_LENGTH = 8,
    /*! Export profile unsupported wire format.  */
    BCMLTD_COMMON_TELEMETRY_INSTANCE_STATE_T_T_UNSUPPORTED_WIRE_FORMAT = 9,
} bcmltd_common_telemetry_instance_state_t_t;

/*! enum type for TELEMETRY_STAT_T
 * Type of telemetry object statistics to be collected.
 */
typedef enum bcmltd_common_telemetry_stat_t_e {
    /*! No stats  */
    BCMLTD_COMMON_TELEMETRY_STAT_T_T_NONE = 0,
    /*! Interface ingress statistics.  */
    BCMLTD_COMMON_TELEMETRY_STAT_T_T_INTF_INGRESS = 1,
    /*! Interface egress statistics.  */
    BCMLTD_COMMON_TELEMETRY_STAT_T_T_INTF_EGRESS = 2,
    /*! Interface egress queue statistics.  */
    BCMLTD_COMMON_TELEMETRY_STAT_T_T_INTF_EGRESS_QUEUE = 3,
    /*! Interface Ingress errors.  */
    BCMLTD_COMMON_TELEMETRY_STAT_T_T_INTF_INGRESS_ERRORS = 4,
    /*! Interface metadata.  */
    BCMLTD_COMMON_TELEMETRY_STAT_T_T_INTF_METADATA = 5,
} bcmltd_common_telemetry_stat_t_t;

/*! enum type for TIMESTAMP_MODE_T
 * Packet timestamp mode definitions.
 */
typedef enum bcmltd_common_timestamp_mode_t_e {
    /*! PTP timestamp mode.  */
    BCMLTD_COMMON_TIMESTAMP_MODE_T_T_PTP = 0,
    /*! NTP timestamp mode.  */
    BCMLTD_COMMON_TIMESTAMP_MODE_T_T_NTP = 1,
} bcmltd_common_timestamp_mode_t_t;

/*! enum type for TM_EBST_ENABLE_MODE_T
 * TM EBST enable mode.
 */
typedef enum bcmltd_common_tm_ebst_enable_mode_t_e {
    /*! EBST turned OFF. No internal resources allocated.  */
    BCMLTD_COMMON_TM_EBST_ENABLE_MODE_T_T_OFF = 0,
    /*! EBST scan start.  */
    BCMLTD_COMMON_TM_EBST_ENABLE_MODE_T_T_EBST_START = 1,
    /*! EBST scan stop. Data LT is retained as is.  */
    BCMLTD_COMMON_TM_EBST_ENABLE_MODE_T_T_EBST_STOP = 2,
    /*! EBST hardware FIFO full hit.  */
    BCMLTD_COMMON_TM_EBST_ENABLE_MODE_T_T_EBST_FIFO_FULL = 3,
} bcmltd_common_tm_ebst_enable_mode_t_t;

/*! enum type for TM_EBST_GREEN_DROP_STATE_T
 * TM EBST drop state.
 */
typedef enum bcmltd_common_tm_ebst_green_drop_state_t_e {
    /*! Accepting all packets.  */
    BCMLTD_COMMON_TM_EBST_GREEN_DROP_STATE_T_T_ACCEPT_ALL = 0,
    /*! Dropping all packets.  */
    BCMLTD_COMMON_TM_EBST_GREEN_DROP_STATE_T_T_DROP_ALL = 1,
} bcmltd_common_tm_ebst_green_drop_state_t_t;

/*! enum type for TM_EBST_MONITOR_STATE_T
 * TM EBST monitor state.
 */
typedef enum bcmltd_common_tm_ebst_monitor_state_t_e {
    /*! EBST monitor invalid cause no port/queue ebst is enabled.  */
    BCMLTD_COMMON_TM_EBST_MONITOR_STATE_T_T_INVALID = 0,
    /*! EBST monitor valid.  */
    BCMLTD_COMMON_TM_EBST_MONITOR_STATE_T_T_VALID = 1,
} bcmltd_common_tm_ebst_monitor_state_t_t;

/*! enum type for TM_EBST_RED_DROP_STATE_T
 * TM EBST red drop state.
 */
typedef enum bcmltd_common_tm_ebst_red_drop_state_t_e {
    /*! Accepting red packets.  */
    BCMLTD_COMMON_TM_EBST_RED_DROP_STATE_T_T_ACCEPT_RED = 0,
    /*! Dropping red packets.  */
    BCMLTD_COMMON_TM_EBST_RED_DROP_STATE_T_T_DROP_RED = 1,
} bcmltd_common_tm_ebst_red_drop_state_t_t;

/*! enum type for TM_EBST_SCAN_MODE_T
 * TM EBST scan mode.
 */
typedef enum bcmltd_common_tm_ebst_scan_mode_t_e {
    /*! Queues.  */
    BCMLTD_COMMON_TM_EBST_SCAN_MODE_T_T_QUEUES = 0,
    /*! Unicast port service pool.  */
    BCMLTD_COMMON_TM_EBST_SCAN_MODE_T_T_UC_PORT_SERVICE_POOL = 1,
    /*! Multicast port service pool.  */
    BCMLTD_COMMON_TM_EBST_SCAN_MODE_T_T_MC_PORT_SERVICE_POOL = 2,
} bcmltd_common_tm_ebst_scan_mode_t_t;

/*! enum type for TM_EBST_YELLOW_DROP_STATE_T
 * TM EBST yellow drop state.
 */
typedef enum bcmltd_common_tm_ebst_yellow_drop_state_t_e {
    /*! Accepting yellow and red packets.  */
    BCMLTD_COMMON_TM_EBST_YELLOW_DROP_STATE_T_T_ACCEPT_YELLOW_RED = 0,
    /*! Dropping yellow and red packets.  */
    BCMLTD_COMMON_TM_EBST_YELLOW_DROP_STATE_T_T_DROP_YELLOW_RED = 1,
} bcmltd_common_tm_ebst_yellow_drop_state_t_t;

/*! enum type for TM_EGR_THD_SERVICE_POOL_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_egr_thd_service_pool_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_EGR_THD_SERVICE_POOL_ENTRY_STATE_T_T_VALID = 0,
    /*!
     * Incorrect shared limit configuration.
     *  Sum of shared limit over all service pools cannot exceed available shared
     *  buffer size (maximum buffer size - total reserved buffer cells) .
     *  Applies to per service pool resource allocation.
     */
    BCMLTD_COMMON_TM_EGR_THD_SERVICE_POOL_ENTRY_STATE_T_T_INCORRECT_SHARED_LIMIT = 1,
    /*!
     * Incorrect resume limit.
     *  Resume limit must be less or equal to the corresponding shared limit.
     *  Applies to per service pool, per {port, service pool} resource allocation
     *  depending on the LT.
     */
    BCMLTD_COMMON_TM_EGR_THD_SERVICE_POOL_ENTRY_STATE_T_T_INCORRECT_RESUME_LIMIT = 2,
    /*!
     * Incorrect color (yellow/green) shared limit.
     *  Color limits should follow the relationship below:
     *  Red limit <= yellow limit <= green limit (default shared limit).
     */
    BCMLTD_COMMON_TM_EGR_THD_SERVICE_POOL_ENTRY_STATE_T_T_INCORRECT_COLOR_LIMIT = 3,
} bcmltd_common_tm_egr_thd_service_pool_entry_state_t_t;

/*! enum type for TM_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*! Profile incomplete.  */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_PROFILE_INCOMPELETE = 2,
    /*! Unicast queue exceeds the permissible limit for a port.  */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_UC_QUEUE_LIMIT_EXCEEDS = 3,
    /*! Multicast queue exceeds the permissible limit for a port.  */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_MC_QUEUE_LIMIT_EXCEEDS = 4,
    /*! Profile invalid.  */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_PROFILE_INVALID = 5,
    /*!
     * Incorrect minimum guarantee configuration.
     *  Total reserved buffer cells cannot exceed the maximum buffer size of the
     *  device.
     *  Applies to per {port, PG}, per {port, port service pool}, per queue
     *  resource allocation depending on the LT.
     */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_INCORRECT_MIN_GUARANTEE = 7,
    /*!
     * Incorrect headroom limit configuration.
     *  Total reserved buffer cells cannot exceed the maximum buffer size of the
     *  device.
     *  Applies to TM_ING_THD_HEADROOM_POOL.
     */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_INCORRECT_HEADROOM_LIMIT = 8,
    /*!
     * Incorrect shared limit configuration.
     *  Sum of shared limit over all service pools cannot exceed available shared
     *  buffer size (maximum buffer size - total reserved buffer cells) .
     *  Applies to per service pool resource allocation.
     */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_INCORRECT_SHARED_LIMIT = 9,
    /*!
     * Incorrect resume limit.
     *  Resume limit must be less or equal to the corresponding shared limit.
     *  Applies to per service pool, per {port, service pool} resource allocation
     *  depending on the LT.
     */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_INCORRECT_RESUME_LIMIT = 10,
    /*!
     * Incorrect PFC priority optimization.
     *  In order to be optimized, the specified
     *  TM_PFC_PRI_PROFILE.COS_LIST must meet following conditions:
     *  Condition 1: The set of COS_LIST array members associated with any
     *  PFC optimized priorities must either be mutually exclusive or equal.
     *  Condition 2: A priority N can be PFC optimized if there is no other
     *  priority M whose COS_LIST members are a subset of the
     *  COS_LIST members of priority N.
     *
     *  For example, consider the following scenario:
     *  - PFC_PRI (0) has COS_LIST {0, 1, 2}
     *  - PFC_PRI (1) has COS_LIST {0, 1}
     *  - PFC_PRI (2) has COS_LIST {2}
     *  In this case, PFC_PRI (1) and PFC_PRI (2) can be configured as PFC optimized
     *  since their COS_LIST members are mutually exclusive and
     *  there is no other priority whose COS_LIST members are a subset.
     *  However, PFC_PRI (0) cannot be configured as PFC optimized since
     *  the COS_LIST of PFC_PRI (1) and PFC_PRI (2) are subsets
     *  of the COS_LIST members of PFC_PRI (0).
     */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_INCORRECT_PFC_OPTIMIZATION = 11,
    /*!
     * Incorrect color (yellow/green) shared limit.
     *  Color limits should follow the relationship below:
     *  Red limit <= yellow limit <= green limit (default shared limit).
     */
    BCMLTD_COMMON_TM_ENTRY_STATE_T_T_INCORRECT_COLOR_LIMIT = 12,
} bcmltd_common_tm_entry_state_t_t;

/*! enum type for TM_FLOW_CTRL_T
 * Flow controls.
 */
typedef enum bcmltd_common_tm_flow_ctrl_t_e {
    /*! Pause flow control.  */
    BCMLTD_COMMON_TM_FLOW_CTRL_T_T_PAUSE = 0,
    /*! Priority based flow control.  */
    BCMLTD_COMMON_TM_FLOW_CTRL_T_T_PFC = 1,
} bcmltd_common_tm_flow_ctrl_t_t;

/*! enum type for TM_ING_THD_HEADROOM_POOL_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_ing_thd_headroom_pool_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_ING_THD_HEADROOM_POOL_ENTRY_STATE_T_T_VALID = 0,
    /*!
     * Incorrect headroom limit configuration.
     *  Total reserved buffer cells cannot exceed the maximum buffer size of the
     *  device.
     *  Applies to TM_ING_THD_HEADROOM_POOL.
     */
    BCMLTD_COMMON_TM_ING_THD_HEADROOM_POOL_ENTRY_STATE_T_T_INCORRECT_HEADROOM_LIMIT = 1,
} bcmltd_common_tm_ing_thd_headroom_pool_entry_state_t_t;

/*! enum type for TM_ING_THD_PORT_PRI_GRP_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_ing_thd_port_pri_grp_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_ING_THD_PORT_PRI_GRP_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_ING_THD_PORT_PRI_GRP_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*!
     * Incorrect minimum guarantee configuration.
     *  Total reserved buffer cells cannot exceed the maximum buffer size of the
     *  device.
     */
    BCMLTD_COMMON_TM_ING_THD_PORT_PRI_GRP_ENTRY_STATE_T_T_INCORRECT_MIN_GUARANTEE = 2,
} bcmltd_common_tm_ing_thd_port_pri_grp_entry_state_t_t;

/*! enum type for TM_ING_THD_PORT_SERVICE_POOL_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_ing_thd_port_service_pool_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_ING_THD_PORT_SERVICE_POOL_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_ING_THD_PORT_SERVICE_POOL_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*!
     * Incorrect minimum guarantee configuration.
     *  Total reserved buffer cells cannot exceed the maximum buffer size of the
     *  device.
     */
    BCMLTD_COMMON_TM_ING_THD_PORT_SERVICE_POOL_ENTRY_STATE_T_T_INCORRECT_MIN_GUARANTEE = 2,
    /*!
     * Incorrect resume limit.
     *  Resume limit must be less or equal to the corresponding shared limit.
     */
    BCMLTD_COMMON_TM_ING_THD_PORT_SERVICE_POOL_ENTRY_STATE_T_T_INCORRECT_RESUME_LIMIT = 3,
} bcmltd_common_tm_ing_thd_port_service_pool_entry_state_t_t;

/*! enum type for TM_ING_THD_SERVICE_POOL_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_ing_thd_service_pool_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_ING_THD_SERVICE_POOL_ENTRY_STATE_T_T_VALID = 0,
    /*!
     * Incorrect shared limit configuration.
     *  Sum of shared limit over all service pools cannot exceed available shared
     *  buffer size (maximum buffer size - total reserved buffer cells) .
     *  Applies to per service pool resource allocation.
     */
    BCMLTD_COMMON_TM_ING_THD_SERVICE_POOL_ENTRY_STATE_T_T_INCORRECT_SHARED_LIMIT = 1,
} bcmltd_common_tm_ing_thd_service_pool_entry_state_t_t;

/*! enum type for TM_MC_PORT_AGG_LIST_STATE_T
 * Multicast port aggregate list entry state.
 */
typedef enum bcmltd_common_tm_mc_port_agg_list_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_MC_PORT_AGG_LIST_STATE_T_T_VALID = 0,
    /*!
     * Replication resource for the index is not
     *  available in hardware.
     */
    BCMLTD_COMMON_TM_MC_PORT_AGG_LIST_STATE_T_T_RESOURCE_UNAVAILABLE = 1,
} bcmltd_common_tm_mc_port_agg_list_state_t_t;

/*! enum type for TM_MIRROR_DROP_CONTROL_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_mirror_drop_control_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_MIRROR_DROP_CONTROL_ENTRY_STATE_T_T_VALID = 0,
    /*!
     * Incorrect buffer limit configuration.
     *  Reserved limit cannot exceed available shared
     *  buffer size (maximum buffer size - reserved buffer cells) .
     */
    BCMLTD_COMMON_TM_MIRROR_DROP_CONTROL_ENTRY_STATE_T_T_INCORRECT_RESERVED_CELLS_LIMIT = 1,
} bcmltd_common_tm_mirror_drop_control_entry_state_t_t;

/*! enum type for TM_MIRROR_DROP_DESTINATION_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_mirror_drop_destination_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_MIRROR_DROP_DESTINATION_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_MIRROR_DROP_DESTINATION_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*! Logical port do not have this queue configured.  */
    BCMLTD_COMMON_TM_MIRROR_DROP_DESTINATION_ENTRY_STATE_T_T_INVALID_Q_NUM = 2,
} bcmltd_common_tm_mirror_drop_destination_entry_state_t_t;

/*! enum type for TM_OBM_MAX_USG_MODE_T
 * OBM maximum usage mode traffic class.
 */
typedef enum bcmltd_common_tm_obm_max_usg_mode_t_e {
    /*!
     * OBM all priority traffic class.
     *  This includes both lossy and lossless traffic class.
     */
    BCMLTD_COMMON_TM_OBM_MAX_USG_MODE_T_T_OBM_TC_ALL = 0,
    /*! OBM lossy traffic class.  */
    BCMLTD_COMMON_TM_OBM_MAX_USG_MODE_T_T_OBM_TC_LOSSY = 1,
    /*! OBM lossless class 0.  */
    BCMLTD_COMMON_TM_OBM_MAX_USG_MODE_T_T_OBM_TC_LOSSLESS0 = 2,
    /*! OBM lossless class 1.  */
    BCMLTD_COMMON_TM_OBM_MAX_USG_MODE_T_T_OBM_TC_LOSSLESS1 = 3,
} bcmltd_common_tm_obm_max_usg_mode_t_t;

/*! enum type for TM_OBM_TC_T
 * OBM traffic class types.
 */
typedef enum bcmltd_common_tm_obm_tc_t_e {
    /*! OBM lossy low traffic class.  */
    BCMLTD_COMMON_TM_OBM_TC_T_T_OBM_TC_LOSSY_LOW = 0,
    /*! OBM lossy high traffic class.  */
    BCMLTD_COMMON_TM_OBM_TC_T_T_OBM_TC_LOSSY_HIGH = 1,
    /*! OBM lossless class 0.  */
    BCMLTD_COMMON_TM_OBM_TC_T_T_OBM_TC_LOSSLESS0 = 2,
    /*! OBM lossless class 1.  */
    BCMLTD_COMMON_TM_OBM_TC_T_T_OBM_TC_LOSSLESS1 = 3,
} bcmltd_common_tm_obm_tc_t_t;

/*! enum type for TM_OOBFC_MC_Q_ENTRY_STATE_T
 * Enumerations defining entry operational status.
 */
typedef enum bcmltd_common_tm_oobfc_mc_q_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_OOBFC_MC_Q_ENTRY_STATE_T_T_VALID = 0,
    /*!
     * The bit position is invalid if OOB_BIT_OFFSET exceeds
     *  TM_OOBFC_CONTROL.EGRESS_STATUS_SIZE.
     */
    BCMLTD_COMMON_TM_OOBFC_MC_Q_ENTRY_STATE_T_T_BIT_OFFSET_INVALID = 1,
    /*!
     * Multicast queue number is invalid if TM_MC_Q_ID exceeds
     *  TM_SCHDEULER_CONFIG.NUM_MC_Q.
     */
    BCMLTD_COMMON_TM_OOBFC_MC_Q_ENTRY_STATE_T_T_MC_Q_INVALID = 2,
} bcmltd_common_tm_oobfc_mc_q_entry_state_t_t;

/*! enum type for TM_OOBFC_UC_Q_ENTRY_STATE_T
 * Enumerations defining entry operational status.
 */
typedef enum bcmltd_common_tm_oobfc_uc_q_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_OOBFC_UC_Q_ENTRY_STATE_T_T_VALID = 0,
    /*!
     * The bit position is invalid if OOB_BIT_OFFSET exceeds
     *  TM_OOBFC_CONTROL.EGRESS_STATUS_SIZE.
     */
    BCMLTD_COMMON_TM_OOBFC_UC_Q_ENTRY_STATE_T_T_BIT_OFFSET_INVALID = 1,
    /*!
     * Unicast queue number is invalid if TM_UC_Q_ID exceeds
     *  TM_DEVICE_INFO.NUM_Q - TM_SCHDEULER_CONFIG.NUM_MC_Q.
     */
    BCMLTD_COMMON_TM_OOBFC_UC_Q_ENTRY_STATE_T_T_UC_Q_INVALID = 2,
} bcmltd_common_tm_oobfc_uc_q_entry_state_t_t;

/*! enum type for TM_PORT_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_port_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*! Configuration is not applicable to the current port encapsulation.\n */
    BCMLTD_COMMON_TM_PORT_ENTRY_STATE_T_T_PORT_ENCAP_MISMATCH = 2,
} bcmltd_common_tm_port_entry_state_t_t;

/*! enum type for TM_PORT_MC_Q_ENTRY_STATE_T
 * Enumerations defining entry operational status.
 */
typedef enum bcmltd_common_tm_port_mc_q_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_PORT_MC_Q_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_PORT_MC_Q_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*! Invalid multicast queue number.  */
    BCMLTD_COMMON_TM_PORT_MC_Q_ENTRY_STATE_T_T_MC_Q_INVALID = 2,
} bcmltd_common_tm_port_mc_q_entry_state_t_t;

/*! enum type for TM_PORT_UC_Q_ENTRY_STATE_T
 * Enumerations defining entry operational status.
 */
typedef enum bcmltd_common_tm_port_uc_q_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_PORT_UC_Q_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_PORT_UC_Q_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*! Invalid unicast queue number.  */
    BCMLTD_COMMON_TM_PORT_UC_Q_ENTRY_STATE_T_T_UC_Q_INVALID = 2,
} bcmltd_common_tm_port_uc_q_entry_state_t_t;

/*! enum type for TM_SCHED_CPU_CREDIT_WDRR_T
 * Credits associated with WDRR mode for CPU scheduler.
 */
typedef enum bcmltd_common_tm_sched_cpu_credit_wdrr_t_e {
    /*! 4K bytes WDRR mode.  */
    BCMLTD_COMMON_TM_SCHED_CPU_CREDIT_WDRR_T_T_WDRR_MODE_4K_BYTES = 0,
    /*! 8K bytes WDRR mode.  */
    BCMLTD_COMMON_TM_SCHED_CPU_CREDIT_WDRR_T_T_WDRR_MODE_8K_BYTES = 1,
    /*! 16K bytes WDRR mode.  */
    BCMLTD_COMMON_TM_SCHED_CPU_CREDIT_WDRR_T_T_WDRR_MODE_16K_BYTES = 2,
    /*! 32K bytes WDRR mode.  */
    BCMLTD_COMMON_TM_SCHED_CPU_CREDIT_WDRR_T_T_WDRR_MODE_32K_BYTES = 3,
} bcmltd_common_tm_sched_cpu_credit_wdrr_t_t;

/*! enum type for TM_SCHED_CPU_CREDIT_WRR_T
 * Credits associated with WRR mode for CPU scheduler.
 */
typedef enum bcmltd_common_tm_sched_cpu_credit_wrr_t_e {
    /*! 2 Packets WRR mode.  */
    BCMLTD_COMMON_TM_SCHED_CPU_CREDIT_WRR_T_T_WRR_MODE_2_PKT = 0,
    /*! 4 Packets WRR mode.  */
    BCMLTD_COMMON_TM_SCHED_CPU_CREDIT_WRR_T_T_WRR_MODE_4_PKT = 1,
    /*! 8 Packets WRR mode.  */
    BCMLTD_COMMON_TM_SCHED_CPU_CREDIT_WRR_T_T_WRR_MODE_8_PKT = 2,
    /*! 16 Packets WRR mode.  */
    BCMLTD_COMMON_TM_SCHED_CPU_CREDIT_WRR_T_T_WRR_MODE_16_PKT = 3,
} bcmltd_common_tm_sched_cpu_credit_wrr_t_t;

/*! enum type for TM_SCHED_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_sched_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_SCHED_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_SCHED_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*!
     * Scheduler profile is invalid.
     *  TM_SCHEDULER_PROFILE mapped to the port is not valid.
     */
    BCMLTD_COMMON_TM_SCHED_ENTRY_STATE_T_T_PROFILE_INVALID = 2,
} bcmltd_common_tm_sched_entry_state_t_t;

/*! enum type for TM_SCHED_NODE_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_sched_node_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_SCHED_NODE_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_SCHED_NODE_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*!
     * Scheduler profile is invalid.
     *  TM_SCHEDULER_PROFILE mapped to the port is not valid.
     */
    BCMLTD_COMMON_TM_SCHED_NODE_ENTRY_STATE_T_T_PROFILE_INVALID = 2,
    /*! TM_SCHEDULER_NODE_ID is invalid.\n */
    BCMLTD_COMMON_TM_SCHED_NODE_ENTRY_STATE_T_T_SCHED_NODE_INVALID = 6,
} bcmltd_common_tm_sched_node_entry_state_t_t;

/*! enum type for TM_SCHED_PORT_NUM_MC_Q_T
 * Number of multicast queues per port.
 */
typedef enum bcmltd_common_tm_sched_port_num_mc_q_t_e {
    /*! 0 Multicast Queues.  */
    BCMLTD_COMMON_TM_SCHED_PORT_NUM_MC_Q_T_T_NUM_MC_Q_0 = 0,
    /*! 2 Multicast Queues.  */
    BCMLTD_COMMON_TM_SCHED_PORT_NUM_MC_Q_T_T_NUM_MC_Q_2 = 1,
    /*! 4 Multicast Queues.  */
    BCMLTD_COMMON_TM_SCHED_PORT_NUM_MC_Q_T_T_NUM_MC_Q_4 = 2,
    /*! 6 Multicast Queues.  */
    BCMLTD_COMMON_TM_SCHED_PORT_NUM_MC_Q_T_T_NUM_MC_Q_6 = 3,
} bcmltd_common_tm_sched_port_num_mc_q_t_t;

/*! enum type for TM_SCHED_PROFILE_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_sched_profile_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_SCHED_PROFILE_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_SCHED_PROFILE_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*!
     * Invalid scheduler profile.
     *  Profile is invalid if mapping between
     *  L0_SCHED_NODE to L1_SCHED_NODE_UC/MC is invalid.
     */
    BCMLTD_COMMON_TM_SCHED_PROFILE_ENTRY_STATE_T_T_PROFILE_INVALID = 2,
    /*!
     * Profile incomplete.
     *  The number of queues configured is less than TM_DEVICE_INFO.NUM_Q.
     */
    BCMLTD_COMMON_TM_SCHED_PROFILE_ENTRY_STATE_T_T_PROFILE_INCOMPELETE = 3,
    /*!
     * Unicast queue exceeds the permissible limit for a port.
     *  Number of permissible unicast queues =
     *  TM_DEVICE_INFO.NUM_Q - TM_SCHEDULER_CONFIG.NUM_MC_Q.
     */
    BCMLTD_COMMON_TM_SCHED_PROFILE_ENTRY_STATE_T_T_UC_Q_LIMIT_EXCEEDS = 4,
    /*!
     * Multicast queue exceeds the permissible limit for a port.
     *  Number of permissible multicast queues is TM_SCHEDULER_CONFIG.NUM_MC_Q.
     */
    BCMLTD_COMMON_TM_SCHED_PROFILE_ENTRY_STATE_T_T_MC_Q_LIMIT_EXCEEDS = 5,
} bcmltd_common_tm_sched_profile_entry_state_t_t;

/*! enum type for TM_SERVICE_POOL_CNG_STATE_T
 * Service pool congestion state.
 */
typedef enum bcmltd_common_tm_service_pool_cng_state_t_e {
    /*! Low congestion.  */
    BCMLTD_COMMON_TM_SERVICE_POOL_CNG_STATE_T_T_LOW_CONGESTION = 0,
    /*! Medium congestion.  */
    BCMLTD_COMMON_TM_SERVICE_POOL_CNG_STATE_T_T_MEDIUM_CONGESTION = 1,
    /*! High congestion.  */
    BCMLTD_COMMON_TM_SERVICE_POOL_CNG_STATE_T_T_HIGH_CONGESTION = 2,
} bcmltd_common_tm_service_pool_cng_state_t_t;

/*! enum type for TM_SHAPER_REFRESH_TIME_T
 * Shaper refresh timer.
 */
typedef enum bcmltd_common_tm_shaper_refresh_time_t_e {
    /*! Refresh time 3.90625 us.  */
    BCMLTD_COMMON_TM_SHAPER_REFRESH_TIME_T_T_REFRESH_TIME_3_90625_US = 0,
    /*! Refresh time 7.8125 us.  */
    BCMLTD_COMMON_TM_SHAPER_REFRESH_TIME_T_T_REFRESH_TIME_7_8125_US = 1,
} bcmltd_common_tm_shaper_refresh_time_t_t;

/*! enum type for TM_SHAPING_MODE_T
 * Traffic shaping mode
 */
typedef enum bcmltd_common_tm_shaping_mode_t_e {
    /*! Byte shaping mode.  */
    BCMLTD_COMMON_TM_SHAPING_MODE_T_T_BYTE_MODE = 0,
    /*! Packet shaping mode.  */
    BCMLTD_COMMON_TM_SHAPING_MODE_T_T_PACKET_MODE = 1,
} bcmltd_common_tm_shaping_mode_t_t;

/*! enum type for TM_THD_MC_Q_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_thd_mc_q_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_THD_MC_Q_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_THD_MC_Q_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*! Multicast queue exceeds the permissible limit for a port.  */
    BCMLTD_COMMON_TM_THD_MC_Q_ENTRY_STATE_T_T_MC_Q_INVALID = 2,
    /*!
     * Incorrect minimum guarantee configuration.
     *  Total reserved buffer cells cannot exceed the maximum buffer size of the
     *  device.
     *  Applies to per {port, PG}, per {port, port service pool}, per queue
     *  resource allocation depending on the LT.
     */
    BCMLTD_COMMON_TM_THD_MC_Q_ENTRY_STATE_T_T_INCORRECT_MIN_GUARANTEE = 3,
} bcmltd_common_tm_thd_mc_q_entry_state_t_t;

/*! enum type for TM_THD_Q_GRP_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_thd_q_grp_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_THD_Q_GRP_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_THD_Q_GRP_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*!
     * Incorrect minimum guarantee configuration.
     *  Total reserved buffer cells cannot exceed the maximum buffer size of the
     *  device.
     *  Applies to per {port, PG}, per {port, port service pool}, per queue
     *  resource allocation depending on the LT.
     */
    BCMLTD_COMMON_TM_THD_Q_GRP_ENTRY_STATE_T_T_INCORRECT_MIN_GUARANTEE = 2,
} bcmltd_common_tm_thd_q_grp_entry_state_t_t;

/*! enum type for TM_THD_UC_Q_ENTRY_STATE_T */
typedef enum bcmltd_common_tm_thd_uc_q_entry_state_t_e {
    /*! Valid entry.  */
    BCMLTD_COMMON_TM_THD_UC_Q_ENTRY_STATE_T_T_VALID = 0,
    /*! Logical to physical port map unavailable.  */
    BCMLTD_COMMON_TM_THD_UC_Q_ENTRY_STATE_T_T_PORT_INFO_UNAVAILABLE = 1,
    /*! Unicast queue exceeds the permissible limit for a port.  */
    BCMLTD_COMMON_TM_THD_UC_Q_ENTRY_STATE_T_T_UC_Q_INVALID = 2,
    /*!
     * Incorrect minimum guarantee configuration.
     *  Total reserved buffer cells cannot exceed the maximum buffer size of the
     *  device.
     *  Applies to per {port, PG}, per {port, port service pool}, per queue
     *  resource allocation depending on the LT.
     */
    BCMLTD_COMMON_TM_THD_UC_Q_ENTRY_STATE_T_T_INCORRECT_MIN_GUARANTEE = 3,
} bcmltd_common_tm_thd_uc_q_entry_state_t_t;

/*! enum type for TM_WRED_ECN_MODE_T
 * WRED ECN mode.
 */
typedef enum bcmltd_common_tm_wred_ecn_mode_t_e {
    /*! Average queue size based ECN marking.  */
    BCMLTD_COMMON_TM_WRED_ECN_MODE_T_T_AVG_Q_SIZE = 0,
    /*! Instantaneous queue size based ECN marking.  */
    BCMLTD_COMMON_TM_WRED_ECN_MODE_T_T_INSTANT_Q_SIZE = 1,
} bcmltd_common_tm_wred_ecn_mode_t_t;

/*! enum type for TOD_HW_UPDATE_STATE_T */
typedef enum bcmltd_common_tod_hw_update_state_t_e {
    /*! HW_UPDATE ToD successfully.  */
    BCMLTD_COMMON_TOD_HW_UPDATE_STATE_T_T_SUCCESS = 0,
    /*! HW_UPDATE ToD failed.  */
    BCMLTD_COMMON_TOD_HW_UPDATE_STATE_T_T_FAIL = 1,
} bcmltd_common_tod_hw_update_state_t_t;

/*! enum type for VXLAN_HEADER_UPDATE_T
 * Enums defining the various secured VXLAN packet update operations.
 */
typedef enum bcmltd_common_vxlan_header_update_t_e {
    /*! No L3 or L4 updates for secured VXLAN packets.  */
    BCMLTD_COMMON_VXLAN_HEADER_UPDATE_T_T_UPDATE_NONE = 0,
    /*!
     * Update the length parameter in L3 and L4 headers according to
     *  the packet type. Do not update the L4 destination port.
     *  L3 and L4 checksum fields are set to 0.
     */
    BCMLTD_COMMON_VXLAN_HEADER_UPDATE_T_T_UPDATE_LENGTH = 1,
    /*!
     * Update the destination port field in L4 header according to
     *  the packet type. The length fields are not updated.
     *  L3 checksum field is set to 0.
     */
    BCMLTD_COMMON_VXLAN_HEADER_UPDATE_T_T_UPDATE_DEST_PORT = 2,
    /*!
     * Update the length fields in L3 and L4 header according to
     *  the packet type. Update the L4 destination port field.
     *  L3 and L4 checksum field is set to 0.
     */
    BCMLTD_COMMON_VXLAN_HEADER_UPDATE_T_T_UPDATE_L3_L4 = 3,
} bcmltd_common_vxlan_header_update_t_t;

/*! enum type for VXLAN_PKT_TYPE_T
 * Enums defining the various VXLAN encrypted packet types.
 */
typedef enum bcmltd_common_vxlan_pkt_type_t_e {
    /*! An IPv4 packet with untagged VLAN.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_IPV4_UNTAG = 0,
    /*! An IPv4 packet with single VLAN tag.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_IPV4_SINGLE_TAG = 1,
    /*! An IPv4 packet with 2 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_IPV4_DOUBLE_TAG = 2,
    /*! An IPv6 packet with 0 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_IPV6_UNTAG = 3,
    /*! An IPv6 packet with 1 VLAN tag.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_IPV6_SINGLE_TAG = 4,
    /*! An IPv6 packet with 2 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_IPV6_DOUBLE_TAG = 5,
    /*! A TCP over IPv4 packet with 0 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_TCP_IPV4_UNTAG = 6,
    /*! A TCP over IPv4 packet with 1 VLAN tag.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_TCP_IPV4_SINGLE_TAG = 7,
    /*! A TCP over IPv4 packet with 2 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_TCP_IPV4_DOUBLE_TAG = 8,
    /*! A TCP over IPv6 packet with 0 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_TCP_IPV6_UNTAG = 9,
    /*! A TCP over IPv6 packet with 1 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_TCP_IPV6_SINGLE_TAG = 10,
    /*! A TCP over IPv6 packet with 2 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_TCP_IPV6_DOUBLE_TAG = 11,
    /*! A UDP over IPv4 packet with 0 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_UDP_IPV4_UNTAG = 12,
    /*! A UDP over IPv4 packet with 1 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_UDP_IPV4_SINGLE_TAG = 13,
    /*! A UDP over IPv4 packet with 2 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_UDP_IPV4_DOUBLE_TAG = 14,
    /*! A UDP over IPv6 packet with 0 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_UDP_IPV6_UNTAG = 15,
    /*! A UDP over IPv6 packet with 1 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_UDP_IPV6_SINGLE_TAG = 16,
    /*! A UDP over IPv6 packet with 2 VLAN tags.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_UDP_IPV6_DOUBLE_TAG = 17,
    /*! Not a VXLAN encrypted packet.  */
    BCMLTD_COMMON_VXLAN_PKT_TYPE_T_T_NON_VXLAN = 18,
} bcmltd_common_vxlan_pkt_type_t_t;

/*! enum type for WIRE_FORMAT_T
 * Wire format used in exporting statistics to collector.
 */
typedef enum bcmltd_common_wire_format_t_e {
    /*! IPFIX wire format.  */
    BCMLTD_COMMON_WIRE_FORMAT_T_T_IPFIX = 0,
    /*! Protocol buffer wire format.  */
    BCMLTD_COMMON_WIRE_FORMAT_T_T_PROTOBUF = 1,
} bcmltd_common_wire_format_t_t;

#endif /* DOXYGEN_IGNORE_AUTOGEN */
#endif /* BCMLTD_COMMON_ENUM_CTYPE_H */
