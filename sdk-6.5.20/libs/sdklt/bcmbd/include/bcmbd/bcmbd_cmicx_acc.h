#ifndef BCMBD_CMICX_ACC_H
#define BCMBD_CMICX_ACC_H
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 * Tool: INTERNAL/regs/xgs/generate-chip.pl
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <sal/sal_libc.h>
#include <bcmdrd/bcmdrd_dev.h>
#include <bcmdrd/bcmdrd_field.h>
#include <bcmbd/bcmbd_cmicx.h>
#include <bcmbd/bcmbd_cmicx_mem.h>
#include <bcmbd/bcmbd_cmicx_reg.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 */



/*******************************************************************************
 * REGISTER:  AXI_PCIE_S0_IDM_IDM_RESET_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_OFFSET 0x1810a804

#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program AXI_PCIE_S0_IDM_IDM_RESET_STATUS.
 */
typedef union AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_s {
    uint32_t v[1];
    uint32_t axi_pcie_s0_idm_idm_reset_status[1];
    uint32_t _axi_pcie_s0_idm_idm_reset_status;
} AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_t;

#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_CLR(r) (r).axi_pcie_s0_idm_idm_reset_status[0] = 0
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_SET(r,d) (r).axi_pcie_s0_idm_idm_reset_status[0] = d
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_GET(r) (r).axi_pcie_s0_idm_idm_reset_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_ACTIVE_READf_GET(r) (((r).axi_pcie_s0_idm_idm_reset_status[0]) & 0x1)
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_ACTIVE_READf_SET(r,f) (r).axi_pcie_s0_idm_idm_reset_status[0]=(((r).axi_pcie_s0_idm_idm_reset_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_ACTIVE_WRITEf_GET(r) ((((r).axi_pcie_s0_idm_idm_reset_status[0]) >> 1) & 0x1)
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_ACTIVE_WRITEf_SET(r,f) (r).axi_pcie_s0_idm_idm_reset_status[0]=(((r).axi_pcie_s0_idm_idm_reset_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_READ_RECEIVEDf_GET(r) ((((r).axi_pcie_s0_idm_idm_reset_status[0]) >> 2) & 0x1)
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_READ_RECEIVEDf_SET(r,f) (r).axi_pcie_s0_idm_idm_reset_status[0]=(((r).axi_pcie_s0_idm_idm_reset_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_WRITE_RECEIVEDf_GET(r) ((((r).axi_pcie_s0_idm_idm_reset_status[0]) >> 3) & 0x1)
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_WRITE_RECEIVEDf_SET(r,f) (r).axi_pcie_s0_idm_idm_reset_status[0]=(((r).axi_pcie_s0_idm_idm_reset_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_RESERVEDf_GET(r) ((((r).axi_pcie_s0_idm_idm_reset_status[0]) >> 4) & 0xfffffff)
#define AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_RESERVEDf_SET(r,f) (r).axi_pcie_s0_idm_idm_reset_status[0]=(((r).axi_pcie_s0_idm_idm_reset_status[0] & ~((uint32_t)0xfffffff << 4)) | ((((uint32_t)f) & 0xfffffff) << 4))

/*
 * These macros can be used to access AXI_PCIE_S0_IDM_IDM_RESET_STATUS.
 */
#define READ_AXI_PCIE_S0_IDM_IDM_RESET_STATUSr(u,r) BCMDRD_IPROC_READ(u,AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_OFFSET,r._axi_pcie_s0_idm_idm_reset_status)
#define WRITE_AXI_PCIE_S0_IDM_IDM_RESET_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,AXI_PCIE_S0_IDM_IDM_RESET_STATUSr_OFFSET,r._axi_pcie_s0_idm_idm_reset_status)

/*******************************************************************************
 * End of 'AXI_PCIE_S0_IDM_IDM_RESET_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CMICX_M0_IDM_IDM_RESET_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMICX_M0_IDM_IDM_RESET_STATUSr_OFFSET 0x18103804

#define CMICX_M0_IDM_IDM_RESET_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMICX_M0_IDM_IDM_RESET_STATUS.
 */
typedef union CMICX_M0_IDM_IDM_RESET_STATUSr_s {
    uint32_t v[1];
    uint32_t cmicx_m0_idm_idm_reset_status[1];
    uint32_t _cmicx_m0_idm_idm_reset_status;
} CMICX_M0_IDM_IDM_RESET_STATUSr_t;

#define CMICX_M0_IDM_IDM_RESET_STATUSr_CLR(r) (r).cmicx_m0_idm_idm_reset_status[0] = 0
#define CMICX_M0_IDM_IDM_RESET_STATUSr_SET(r,d) (r).cmicx_m0_idm_idm_reset_status[0] = d
#define CMICX_M0_IDM_IDM_RESET_STATUSr_GET(r) (r).cmicx_m0_idm_idm_reset_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMICX_M0_IDM_IDM_RESET_STATUSr_ACTIVE_READf_GET(r) (((r).cmicx_m0_idm_idm_reset_status[0]) & 0x1)
#define CMICX_M0_IDM_IDM_RESET_STATUSr_ACTIVE_READf_SET(r,f) (r).cmicx_m0_idm_idm_reset_status[0]=(((r).cmicx_m0_idm_idm_reset_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMICX_M0_IDM_IDM_RESET_STATUSr_ACTIVE_WRITEf_GET(r) ((((r).cmicx_m0_idm_idm_reset_status[0]) >> 1) & 0x1)
#define CMICX_M0_IDM_IDM_RESET_STATUSr_ACTIVE_WRITEf_SET(r,f) (r).cmicx_m0_idm_idm_reset_status[0]=(((r).cmicx_m0_idm_idm_reset_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMICX_M0_IDM_IDM_RESET_STATUSr_READ_RECEIVEDf_GET(r) ((((r).cmicx_m0_idm_idm_reset_status[0]) >> 2) & 0x1)
#define CMICX_M0_IDM_IDM_RESET_STATUSr_READ_RECEIVEDf_SET(r,f) (r).cmicx_m0_idm_idm_reset_status[0]=(((r).cmicx_m0_idm_idm_reset_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMICX_M0_IDM_IDM_RESET_STATUSr_WRITE_RECEIVEDf_GET(r) ((((r).cmicx_m0_idm_idm_reset_status[0]) >> 3) & 0x1)
#define CMICX_M0_IDM_IDM_RESET_STATUSr_WRITE_RECEIVEDf_SET(r,f) (r).cmicx_m0_idm_idm_reset_status[0]=(((r).cmicx_m0_idm_idm_reset_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMICX_M0_IDM_IDM_RESET_STATUSr_RESERVEDf_GET(r) ((((r).cmicx_m0_idm_idm_reset_status[0]) >> 4) & 0xfffffff)
#define CMICX_M0_IDM_IDM_RESET_STATUSr_RESERVEDf_SET(r,f) (r).cmicx_m0_idm_idm_reset_status[0]=(((r).cmicx_m0_idm_idm_reset_status[0] & ~((uint32_t)0xfffffff << 4)) | ((((uint32_t)f) & 0xfffffff) << 4))

/*
 * These macros can be used to access CMICX_M0_IDM_IDM_RESET_STATUS.
 */
#define READ_CMICX_M0_IDM_IDM_RESET_STATUSr(u,r) BCMDRD_IPROC_READ(u,CMICX_M0_IDM_IDM_RESET_STATUSr_OFFSET,r._cmicx_m0_idm_idm_reset_status)
#define WRITE_CMICX_M0_IDM_IDM_RESET_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,CMICX_M0_IDM_IDM_RESET_STATUSr_OFFSET,r._cmicx_m0_idm_idm_reset_status)

/*******************************************************************************
 * End of 'CMICX_M0_IDM_IDM_RESET_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_CFG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_CFGr_OFFSET 0x00003418

#define CMIC_CMC_CCMDMA_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_CFG.
 */
typedef union CMIC_CMC_CCMDMA_CFGr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_cfg[1];
    uint32_t _cmic_cmc_ccmdma_cfg;
} CMIC_CMC_CCMDMA_CFGr_t;

#define CMIC_CMC_CCMDMA_CFGr_CLR(r) (r).cmic_cmc_ccmdma_cfg[0] = 0
#define CMIC_CMC_CCMDMA_CFGr_SET(r,d) (r).cmic_cmc_ccmdma_cfg[0] = d
#define CMIC_CMC_CCMDMA_CFGr_GET(r) (r).cmic_cmc_ccmdma_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_CFGr_ENf_GET(r) (((r).cmic_cmc_ccmdma_cfg[0]) & 0x1)
#define CMIC_CMC_CCMDMA_CFGr_ENf_SET(r,f) (r).cmic_cmc_ccmdma_cfg[0]=(((r).cmic_cmc_ccmdma_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_CCMDMA_CFGr_ABORTf_GET(r) ((((r).cmic_cmc_ccmdma_cfg[0]) >> 1) & 0x1)
#define CMIC_CMC_CCMDMA_CFGr_ABORTf_SET(r,f) (r).cmic_cmc_ccmdma_cfg[0]=(((r).cmic_cmc_ccmdma_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_CCMDMA_CFGr_PROCESSOR0_ENDIANESSf_GET(r) ((((r).cmic_cmc_ccmdma_cfg[0]) >> 2) & 0x1)
#define CMIC_CMC_CCMDMA_CFGr_PROCESSOR0_ENDIANESSf_SET(r,f) (r).cmic_cmc_ccmdma_cfg[0]=(((r).cmic_cmc_ccmdma_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_CCMDMA_CFGr_PROCESSOR1_ENDIANESSf_GET(r) ((((r).cmic_cmc_ccmdma_cfg[0]) >> 3) & 0x1)
#define CMIC_CMC_CCMDMA_CFGr_PROCESSOR1_ENDIANESSf_SET(r,f) (r).cmic_cmc_ccmdma_cfg[0]=(((r).cmic_cmc_ccmdma_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_CFG.
 */
#define READ_CMIC_CMC_CCMDMA_CFGr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_CFGr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_cfg)
#define WRITE_CMIC_CMC_CCMDMA_CFGr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_CFGr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_cfg)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_CFGr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr_OFFSET 0x00003424

#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HI.
 */
typedef union CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_cur_host0_addr_hi[1];
    uint32_t _cmic_cmc_ccmdma_cur_host0_addr_hi;
} CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr_t;

#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr_CLR(r) (r).cmic_cmc_ccmdma_cur_host0_addr_hi[0] = 0
#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr_SET(r,d) (r).cmic_cmc_ccmdma_cur_host0_addr_hi[0] = d
#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr_GET(r) (r).cmic_cmc_ccmdma_cur_host0_addr_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr_ADDRf_GET(r) ((r).cmic_cmc_ccmdma_cur_host0_addr_hi[0])
#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr_ADDRf_SET(r,f) (r).cmic_cmc_ccmdma_cur_host0_addr_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HI.
 */
#define READ_CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_cur_host0_addr_hi)
#define WRITE_CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_cur_host0_addr_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr_OFFSET 0x00003420

#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LO.
 */
typedef union CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_cur_host0_addr_lo[1];
    uint32_t _cmic_cmc_ccmdma_cur_host0_addr_lo;
} CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr_t;

#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr_CLR(r) (r).cmic_cmc_ccmdma_cur_host0_addr_lo[0] = 0
#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr_SET(r,d) (r).cmic_cmc_ccmdma_cur_host0_addr_lo[0] = d
#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr_GET(r) (r).cmic_cmc_ccmdma_cur_host0_addr_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr_ADDRf_GET(r) ((r).cmic_cmc_ccmdma_cur_host0_addr_lo[0])
#define CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr_ADDRf_SET(r,f) (r).cmic_cmc_ccmdma_cur_host0_addr_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LO.
 */
#define READ_CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_cur_host0_addr_lo)
#define WRITE_CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_cur_host0_addr_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_CUR_HOST0_ADDR_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr_OFFSET 0x0000342c

#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HI.
 */
typedef union CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_cur_host1_addr_hi[1];
    uint32_t _cmic_cmc_ccmdma_cur_host1_addr_hi;
} CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr_t;

#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr_CLR(r) (r).cmic_cmc_ccmdma_cur_host1_addr_hi[0] = 0
#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr_SET(r,d) (r).cmic_cmc_ccmdma_cur_host1_addr_hi[0] = d
#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr_GET(r) (r).cmic_cmc_ccmdma_cur_host1_addr_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr_ADDRf_GET(r) ((r).cmic_cmc_ccmdma_cur_host1_addr_hi[0])
#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr_ADDRf_SET(r,f) (r).cmic_cmc_ccmdma_cur_host1_addr_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HI.
 */
#define READ_CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_cur_host1_addr_hi)
#define WRITE_CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_cur_host1_addr_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr_OFFSET 0x00003428

#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LO.
 */
typedef union CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_cur_host1_addr_lo[1];
    uint32_t _cmic_cmc_ccmdma_cur_host1_addr_lo;
} CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr_t;

#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr_CLR(r) (r).cmic_cmc_ccmdma_cur_host1_addr_lo[0] = 0
#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr_SET(r,d) (r).cmic_cmc_ccmdma_cur_host1_addr_lo[0] = d
#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr_GET(r) (r).cmic_cmc_ccmdma_cur_host1_addr_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr_ADDRf_GET(r) ((r).cmic_cmc_ccmdma_cur_host1_addr_lo[0])
#define CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr_ADDRf_SET(r,f) (r).cmic_cmc_ccmdma_cur_host1_addr_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LO.
 */
#define READ_CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_cur_host1_addr_lo)
#define WRITE_CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_cur_host1_addr_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_CUR_HOST1_ADDR_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_ECC_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_ECC_CONTROLr_OFFSET 0x00003430

#define CMIC_CMC_CCMDMA_ECC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_ECC_CONTROL.
 */
typedef union CMIC_CMC_CCMDMA_ECC_CONTROLr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_ecc_control[1];
    uint32_t _cmic_cmc_ccmdma_ecc_control;
} CMIC_CMC_CCMDMA_ECC_CONTROLr_t;

#define CMIC_CMC_CCMDMA_ECC_CONTROLr_CLR(r) (r).cmic_cmc_ccmdma_ecc_control[0] = 0
#define CMIC_CMC_CCMDMA_ECC_CONTROLr_SET(r,d) (r).cmic_cmc_ccmdma_ecc_control[0] = d
#define CMIC_CMC_CCMDMA_ECC_CONTROLr_GET(r) (r).cmic_cmc_ccmdma_ecc_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_ECC_CONTROLr_INJECT_1BIT_ERR_IN_DMARDf_GET(r) (((r).cmic_cmc_ccmdma_ecc_control[0]) & 0x1)
#define CMIC_CMC_CCMDMA_ECC_CONTROLr_INJECT_1BIT_ERR_IN_DMARDf_SET(r,f) (r).cmic_cmc_ccmdma_ecc_control[0]=(((r).cmic_cmc_ccmdma_ecc_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_CCMDMA_ECC_CONTROLr_INJECT_2BIT_ERR_IN_DMARDf_GET(r) ((((r).cmic_cmc_ccmdma_ecc_control[0]) >> 1) & 0x1)
#define CMIC_CMC_CCMDMA_ECC_CONTROLr_INJECT_2BIT_ERR_IN_DMARDf_SET(r,f) (r).cmic_cmc_ccmdma_ecc_control[0]=(((r).cmic_cmc_ccmdma_ecc_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_CCMDMA_ECC_CONTROLr_DISABLE_ECC_LOGICf_GET(r) ((((r).cmic_cmc_ccmdma_ecc_control[0]) >> 2) & 0x1)
#define CMIC_CMC_CCMDMA_ECC_CONTROLr_DISABLE_ECC_LOGICf_SET(r,f) (r).cmic_cmc_ccmdma_ecc_control[0]=(((r).cmic_cmc_ccmdma_ecc_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_ECC_CONTROL.
 */
#define READ_CMIC_CMC_CCMDMA_ECC_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_ECC_CONTROLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_ecc_control)
#define WRITE_CMIC_CMC_CCMDMA_ECC_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_ECC_CONTROLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_ecc_control)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_ECC_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_ECC_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_ECC_STATUSr_OFFSET 0x00003434

#define CMIC_CMC_CCMDMA_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_ECC_STATUS.
 */
typedef union CMIC_CMC_CCMDMA_ECC_STATUSr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_ecc_status[1];
    uint32_t _cmic_cmc_ccmdma_ecc_status;
} CMIC_CMC_CCMDMA_ECC_STATUSr_t;

#define CMIC_CMC_CCMDMA_ECC_STATUSr_CLR(r) (r).cmic_cmc_ccmdma_ecc_status[0] = 0
#define CMIC_CMC_CCMDMA_ECC_STATUSr_SET(r,d) (r).cmic_cmc_ccmdma_ecc_status[0] = d
#define CMIC_CMC_CCMDMA_ECC_STATUSr_GET(r) (r).cmic_cmc_ccmdma_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_ECC_STATUSr_SINGLE_BIT_ERR_DETECTEDf_GET(r) (((r).cmic_cmc_ccmdma_ecc_status[0]) & 0x1)
#define CMIC_CMC_CCMDMA_ECC_STATUSr_SINGLE_BIT_ERR_DETECTEDf_SET(r,f) (r).cmic_cmc_ccmdma_ecc_status[0]=(((r).cmic_cmc_ccmdma_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_CCMDMA_ECC_STATUSr_DOUBLE_BIT_ERR_DETECTEDf_GET(r) ((((r).cmic_cmc_ccmdma_ecc_status[0]) >> 1) & 0x1)
#define CMIC_CMC_CCMDMA_ECC_STATUSr_DOUBLE_BIT_ERR_DETECTEDf_SET(r,f) (r).cmic_cmc_ccmdma_ecc_status[0]=(((r).cmic_cmc_ccmdma_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_CCMDMA_ECC_STATUSr_MULTIPLE_ERR_DETECTEDf_GET(r) ((((r).cmic_cmc_ccmdma_ecc_status[0]) >> 2) & 0x1)
#define CMIC_CMC_CCMDMA_ECC_STATUSr_MULTIPLE_ERR_DETECTEDf_SET(r,f) (r).cmic_cmc_ccmdma_ecc_status[0]=(((r).cmic_cmc_ccmdma_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_CCMDMA_ECC_STATUSr_FIRST_ERR_ADDRESSf_GET(r) ((((r).cmic_cmc_ccmdma_ecc_status[0]) >> 9) & 0x7)
#define CMIC_CMC_CCMDMA_ECC_STATUSr_FIRST_ERR_ADDRESSf_SET(r,f) (r).cmic_cmc_ccmdma_ecc_status[0]=(((r).cmic_cmc_ccmdma_ecc_status[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_ECC_STATUS.
 */
#define READ_CMIC_CMC_CCMDMA_ECC_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_ECC_STATUSr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_ecc_status)
#define WRITE_CMIC_CMC_CCMDMA_ECC_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_ECC_STATUSr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_ecc_status)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_ECC_STATUS_CLR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_ECC_STATUS_CLRr_OFFSET 0x00003438

#define CMIC_CMC_CCMDMA_ECC_STATUS_CLRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_ECC_STATUS_CLR.
 */
typedef union CMIC_CMC_CCMDMA_ECC_STATUS_CLRr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_ecc_status_clr[1];
    uint32_t _cmic_cmc_ccmdma_ecc_status_clr;
} CMIC_CMC_CCMDMA_ECC_STATUS_CLRr_t;

#define CMIC_CMC_CCMDMA_ECC_STATUS_CLRr_CLR(r) (r).cmic_cmc_ccmdma_ecc_status_clr[0] = 0
#define CMIC_CMC_CCMDMA_ECC_STATUS_CLRr_SET(r,d) (r).cmic_cmc_ccmdma_ecc_status_clr[0] = d
#define CMIC_CMC_CCMDMA_ECC_STATUS_CLRr_GET(r) (r).cmic_cmc_ccmdma_ecc_status_clr[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_ECC_STATUS_CLRr_CLEARf_GET(r) (((r).cmic_cmc_ccmdma_ecc_status_clr[0]) & 0x1)
#define CMIC_CMC_CCMDMA_ECC_STATUS_CLRr_CLEARf_SET(r,f) (r).cmic_cmc_ccmdma_ecc_status_clr[0]=(((r).cmic_cmc_ccmdma_ecc_status_clr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_ECC_STATUS_CLR.
 */
#define READ_CMIC_CMC_CCMDMA_ECC_STATUS_CLRr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_ECC_STATUS_CLRr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_ecc_status_clr)
#define WRITE_CMIC_CMC_CCMDMA_ECC_STATUS_CLRr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_ECC_STATUS_CLRr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_ecc_status_clr)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_ECC_STATUS_CLRr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_ENTRY_COUNT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_ENTRY_COUNTr_OFFSET 0x00003414

#define CMIC_CMC_CCMDMA_ENTRY_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_ENTRY_COUNT.
 */
typedef union CMIC_CMC_CCMDMA_ENTRY_COUNTr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_entry_count[1];
    uint32_t _cmic_cmc_ccmdma_entry_count;
} CMIC_CMC_CCMDMA_ENTRY_COUNTr_t;

#define CMIC_CMC_CCMDMA_ENTRY_COUNTr_CLR(r) (r).cmic_cmc_ccmdma_entry_count[0] = 0
#define CMIC_CMC_CCMDMA_ENTRY_COUNTr_SET(r,d) (r).cmic_cmc_ccmdma_entry_count[0] = d
#define CMIC_CMC_CCMDMA_ENTRY_COUNTr_GET(r) (r).cmic_cmc_ccmdma_entry_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_ENTRY_COUNTr_COUNTf_GET(r) (((r).cmic_cmc_ccmdma_entry_count[0]) & 0x3fffffff)
#define CMIC_CMC_CCMDMA_ENTRY_COUNTr_COUNTf_SET(r,f) (r).cmic_cmc_ccmdma_entry_count[0]=(((r).cmic_cmc_ccmdma_entry_count[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_ENTRY_COUNT.
 */
#define READ_CMIC_CMC_CCMDMA_ENTRY_COUNTr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_ENTRY_COUNTr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_entry_count)
#define WRITE_CMIC_CMC_CCMDMA_ENTRY_COUNTr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_ENTRY_COUNTr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_entry_count)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_ENTRY_COUNTr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr_OFFSET 0x00003408

#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HI.
 */
typedef union CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_host0_mem_start_addr_hi[1];
    uint32_t _cmic_cmc_ccmdma_host0_mem_start_addr_hi;
} CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr_t;

#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr_CLR(r) (r).cmic_cmc_ccmdma_host0_mem_start_addr_hi[0] = 0
#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr_SET(r,d) (r).cmic_cmc_ccmdma_host0_mem_start_addr_hi[0] = d
#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr_GET(r) (r).cmic_cmc_ccmdma_host0_mem_start_addr_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr_ADDRf_GET(r) ((r).cmic_cmc_ccmdma_host0_mem_start_addr_hi[0])
#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr_ADDRf_SET(r,f) (r).cmic_cmc_ccmdma_host0_mem_start_addr_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HI.
 */
#define READ_CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_host0_mem_start_addr_hi)
#define WRITE_CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_host0_mem_start_addr_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr_OFFSET 0x00003404

#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LO.
 */
typedef union CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_host0_mem_start_addr_lo[1];
    uint32_t _cmic_cmc_ccmdma_host0_mem_start_addr_lo;
} CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr_t;

#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr_CLR(r) (r).cmic_cmc_ccmdma_host0_mem_start_addr_lo[0] = 0
#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr_SET(r,d) (r).cmic_cmc_ccmdma_host0_mem_start_addr_lo[0] = d
#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr_GET(r) (r).cmic_cmc_ccmdma_host0_mem_start_addr_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr_ADDRf_GET(r) ((r).cmic_cmc_ccmdma_host0_mem_start_addr_lo[0])
#define CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr_ADDRf_SET(r,f) (r).cmic_cmc_ccmdma_host0_mem_start_addr_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LO.
 */
#define READ_CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_host0_mem_start_addr_lo)
#define WRITE_CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_host0_mem_start_addr_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_HOST0_MEM_START_ADDR_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr_OFFSET 0x00003410

#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HI.
 */
typedef union CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_host1_mem_start_addr_hi[1];
    uint32_t _cmic_cmc_ccmdma_host1_mem_start_addr_hi;
} CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr_t;

#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr_CLR(r) (r).cmic_cmc_ccmdma_host1_mem_start_addr_hi[0] = 0
#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr_SET(r,d) (r).cmic_cmc_ccmdma_host1_mem_start_addr_hi[0] = d
#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr_GET(r) (r).cmic_cmc_ccmdma_host1_mem_start_addr_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr_ADDRf_GET(r) ((r).cmic_cmc_ccmdma_host1_mem_start_addr_hi[0])
#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr_ADDRf_SET(r,f) (r).cmic_cmc_ccmdma_host1_mem_start_addr_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HI.
 */
#define READ_CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_host1_mem_start_addr_hi)
#define WRITE_CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_host1_mem_start_addr_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr_OFFSET 0x0000340c

#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LO.
 */
typedef union CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_host1_mem_start_addr_lo[1];
    uint32_t _cmic_cmc_ccmdma_host1_mem_start_addr_lo;
} CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr_t;

#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr_CLR(r) (r).cmic_cmc_ccmdma_host1_mem_start_addr_lo[0] = 0
#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr_SET(r,d) (r).cmic_cmc_ccmdma_host1_mem_start_addr_lo[0] = d
#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr_GET(r) (r).cmic_cmc_ccmdma_host1_mem_start_addr_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr_ADDRf_GET(r) ((r).cmic_cmc_ccmdma_host1_mem_start_addr_lo[0])
#define CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr_ADDRf_SET(r,f) (r).cmic_cmc_ccmdma_host1_mem_start_addr_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LO.
 */
#define READ_CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_host1_mem_start_addr_lo)
#define WRITE_CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_host1_mem_start_addr_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_HOST1_MEM_START_ADDR_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_STAT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_STATr_OFFSET 0x0000341c

#define CMIC_CMC_CCMDMA_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_STAT.
 */
typedef union CMIC_CMC_CCMDMA_STATr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_stat[1];
    uint32_t _cmic_cmc_ccmdma_stat;
} CMIC_CMC_CCMDMA_STATr_t;

#define CMIC_CMC_CCMDMA_STATr_CLR(r) (r).cmic_cmc_ccmdma_stat[0] = 0
#define CMIC_CMC_CCMDMA_STATr_SET(r,d) (r).cmic_cmc_ccmdma_stat[0] = d
#define CMIC_CMC_CCMDMA_STATr_GET(r) (r).cmic_cmc_ccmdma_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_STATr_DONEf_GET(r) (((r).cmic_cmc_ccmdma_stat[0]) & 0x1)
#define CMIC_CMC_CCMDMA_STATr_DONEf_SET(r,f) (r).cmic_cmc_ccmdma_stat[0]=(((r).cmic_cmc_ccmdma_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_CCMDMA_STATr_ERRORf_GET(r) ((((r).cmic_cmc_ccmdma_stat[0]) >> 1) & 0x1)
#define CMIC_CMC_CCMDMA_STATr_ERRORf_SET(r,f) (r).cmic_cmc_ccmdma_stat[0]=(((r).cmic_cmc_ccmdma_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_CCMDMA_STATr_ECC_2BIT_CHECK_FAILf_GET(r) ((((r).cmic_cmc_ccmdma_stat[0]) >> 2) & 0x1)
#define CMIC_CMC_CCMDMA_STATr_ECC_2BIT_CHECK_FAILf_SET(r,f) (r).cmic_cmc_ccmdma_stat[0]=(((r).cmic_cmc_ccmdma_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_STAT.
 */
#define READ_CMIC_CMC_CCMDMA_STATr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_STATr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_stat)
#define WRITE_CMIC_CMC_CCMDMA_STATr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_STATr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_stat)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_STATr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_CCMDMA_TM_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_CCMDMA_TM_CONTROLr_OFFSET 0x0000343c

#define CMIC_CMC_CCMDMA_TM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CCMDMA_TM_CONTROL.
 */
typedef union CMIC_CMC_CCMDMA_TM_CONTROLr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_ccmdma_tm_control[1];
    uint32_t _cmic_cmc_ccmdma_tm_control;
} CMIC_CMC_CCMDMA_TM_CONTROLr_t;

#define CMIC_CMC_CCMDMA_TM_CONTROLr_CLR(r) (r).cmic_cmc_ccmdma_tm_control[0] = 0
#define CMIC_CMC_CCMDMA_TM_CONTROLr_SET(r,d) (r).cmic_cmc_ccmdma_tm_control[0] = d
#define CMIC_CMC_CCMDMA_TM_CONTROLr_GET(r) (r).cmic_cmc_ccmdma_tm_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CCMDMA_TM_CONTROLr_TMf_GET(r) (((r).cmic_cmc_ccmdma_tm_control[0]) & 0x1f)
#define CMIC_CMC_CCMDMA_TM_CONTROLr_TMf_SET(r,f) (r).cmic_cmc_ccmdma_tm_control[0]=(((r).cmic_cmc_ccmdma_tm_control[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access CMIC_CMC_CCMDMA_TM_CONTROL.
 */
#define READ_CMIC_CMC_CCMDMA_TM_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_CCMDMA_TM_CONTROLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_tm_control)
#define WRITE_CMIC_CMC_CCMDMA_TM_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_CCMDMA_TM_CONTROLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_ccmdma_tm_control)

/*******************************************************************************
 * End of 'CMIC_CMC_CCMDMA_TM_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_COS_CTRL_RX_0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_COS_CTRL_RX_0r_OFFSET 0x00002118

#define CMIC_CMC_PKTDMA_COS_CTRL_RX_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_COS_CTRL_RX_0.
 */
typedef union CMIC_CMC_PKTDMA_COS_CTRL_RX_0r_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_cos_ctrl_rx_0[1];
    uint32_t _cmic_cmc_pktdma_cos_ctrl_rx_0;
} CMIC_CMC_PKTDMA_COS_CTRL_RX_0r_t;

#define CMIC_CMC_PKTDMA_COS_CTRL_RX_0r_CLR(r) (r).cmic_cmc_pktdma_cos_ctrl_rx_0[0] = 0
#define CMIC_CMC_PKTDMA_COS_CTRL_RX_0r_SET(r,d) (r).cmic_cmc_pktdma_cos_ctrl_rx_0[0] = d
#define CMIC_CMC_PKTDMA_COS_CTRL_RX_0r_GET(r) (r).cmic_cmc_pktdma_cos_ctrl_rx_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_COS_CTRL_RX_0r_COS_BMPf_GET(r) ((r).cmic_cmc_pktdma_cos_ctrl_rx_0[0])
#define CMIC_CMC_PKTDMA_COS_CTRL_RX_0r_COS_BMPf_SET(r,f) (r).cmic_cmc_pktdma_cos_ctrl_rx_0[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_COS_CTRL_RX_0.
 */
#define READ_CMIC_CMC_PKTDMA_COS_CTRL_RX_0r(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_COS_CTRL_RX_0r_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_cos_ctrl_rx_0)
#define WRITE_CMIC_CMC_PKTDMA_COS_CTRL_RX_0r(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_COS_CTRL_RX_0r_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_cos_ctrl_rx_0)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_COS_CTRL_RX_0r'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_COS_CTRL_RX_1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_COS_CTRL_RX_1r_OFFSET 0x0000211c

#define CMIC_CMC_PKTDMA_COS_CTRL_RX_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_COS_CTRL_RX_1.
 */
typedef union CMIC_CMC_PKTDMA_COS_CTRL_RX_1r_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_cos_ctrl_rx_1[1];
    uint32_t _cmic_cmc_pktdma_cos_ctrl_rx_1;
} CMIC_CMC_PKTDMA_COS_CTRL_RX_1r_t;

#define CMIC_CMC_PKTDMA_COS_CTRL_RX_1r_CLR(r) (r).cmic_cmc_pktdma_cos_ctrl_rx_1[0] = 0
#define CMIC_CMC_PKTDMA_COS_CTRL_RX_1r_SET(r,d) (r).cmic_cmc_pktdma_cos_ctrl_rx_1[0] = d
#define CMIC_CMC_PKTDMA_COS_CTRL_RX_1r_GET(r) (r).cmic_cmc_pktdma_cos_ctrl_rx_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_COS_CTRL_RX_1r_COS_BMPf_GET(r) ((r).cmic_cmc_pktdma_cos_ctrl_rx_1[0])
#define CMIC_CMC_PKTDMA_COS_CTRL_RX_1r_COS_BMPf_SET(r,f) (r).cmic_cmc_pktdma_cos_ctrl_rx_1[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_COS_CTRL_RX_1.
 */
#define READ_CMIC_CMC_PKTDMA_COS_CTRL_RX_1r(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_COS_CTRL_RX_1r_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_cos_ctrl_rx_1)
#define WRITE_CMIC_CMC_PKTDMA_COS_CTRL_RX_1r(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_COS_CTRL_RX_1r_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_cos_ctrl_rx_1)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_COS_CTRL_RX_1r'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_CTRLr_OFFSET 0x00002100

#define CMIC_CMC_PKTDMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_CTRL.
 */
typedef union CMIC_CMC_PKTDMA_CTRLr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_ctrl[1];
    uint32_t _cmic_cmc_pktdma_ctrl;
} CMIC_CMC_PKTDMA_CTRLr_t;

#define CMIC_CMC_PKTDMA_CTRLr_CLR(r) (r).cmic_cmc_pktdma_ctrl[0] = 0
#define CMIC_CMC_PKTDMA_CTRLr_SET(r,d) (r).cmic_cmc_pktdma_ctrl[0] = d
#define CMIC_CMC_PKTDMA_CTRLr_GET(r) (r).cmic_cmc_pktdma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_CTRLr_DIRECTIONf_GET(r) (((r).cmic_cmc_pktdma_ctrl[0]) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_DIRECTIONf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_PKTDMA_CTRLr_DMA_ENf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_DMA_ENf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_PKTDMA_CTRLr_ABORT_DMAf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 2) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_ABORT_DMAf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_PKTDMA_CTRLr_PKTDMA_ENDIANESSf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 3) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_PKTDMA_ENDIANESSf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_PKTDMA_CTRLr_DESC_ENDIANESSf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 4) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_DESC_ENDIANESSf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_PKTDMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 5) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CMC_PKTDMA_CTRLr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 6) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_PKTDMA_CTRLr_DESC_DONE_INTR_MODEf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 7) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_DESC_DONE_INTR_MODEf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_CMC_PKTDMA_CTRLr_ENABLE_CONTINUOUS_DMAf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 8) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_ENABLE_CONTINUOUS_DMAf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_CMC_PKTDMA_CTRLr_CONTIGUOUS_DESCRIPTORSf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 9) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_CONTIGUOUS_DESCRIPTORSf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_CMC_PKTDMA_CTRLr_EP_TO_CPU_ALIGNMENT_BYTESf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 10) & 0x3)
#define CMIC_CMC_PKTDMA_CTRLr_EP_TO_CPU_ALIGNMENT_BYTESf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define CMIC_CMC_PKTDMA_CTRLr_HEADER_ENDIANESSf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 12) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_HEADER_ENDIANESSf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_CMC_PKTDMA_CTRLr_DISABLE_ABORT_ON_ERRORf_GET(r) ((((r).cmic_cmc_pktdma_ctrl[0]) >> 13) & 0x1)
#define CMIC_CMC_PKTDMA_CTRLr_DISABLE_ABORT_ON_ERRORf_SET(r,f) (r).cmic_cmc_pktdma_ctrl[0]=(((r).cmic_cmc_pktdma_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_CTRL.
 */
#define READ_CMIC_CMC_PKTDMA_CTRLr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_CTRLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_ctrl)
#define WRITE_CMIC_CMC_PKTDMA_CTRLr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_CTRLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_ctrl)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_CURR_DESC_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_CURR_DESC_HIr_OFFSET 0x00002128

#define CMIC_CMC_PKTDMA_CURR_DESC_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_CURR_DESC_HI.
 */
typedef union CMIC_CMC_PKTDMA_CURR_DESC_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_curr_desc_hi[1];
    uint32_t _cmic_cmc_pktdma_curr_desc_hi;
} CMIC_CMC_PKTDMA_CURR_DESC_HIr_t;

#define CMIC_CMC_PKTDMA_CURR_DESC_HIr_CLR(r) (r).cmic_cmc_pktdma_curr_desc_hi[0] = 0
#define CMIC_CMC_PKTDMA_CURR_DESC_HIr_SET(r,d) (r).cmic_cmc_pktdma_curr_desc_hi[0] = d
#define CMIC_CMC_PKTDMA_CURR_DESC_HIr_GET(r) (r).cmic_cmc_pktdma_curr_desc_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_CURR_DESC_HIr_ADDRf_GET(r) ((r).cmic_cmc_pktdma_curr_desc_hi[0])
#define CMIC_CMC_PKTDMA_CURR_DESC_HIr_ADDRf_SET(r,f) (r).cmic_cmc_pktdma_curr_desc_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_CURR_DESC_HI.
 */
#define READ_CMIC_CMC_PKTDMA_CURR_DESC_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_CURR_DESC_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_curr_desc_hi)
#define WRITE_CMIC_CMC_PKTDMA_CURR_DESC_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_CURR_DESC_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_curr_desc_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_CURR_DESC_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_CURR_DESC_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_CURR_DESC_LOr_OFFSET 0x00002124

#define CMIC_CMC_PKTDMA_CURR_DESC_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_CURR_DESC_LO.
 */
typedef union CMIC_CMC_PKTDMA_CURR_DESC_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_curr_desc_lo[1];
    uint32_t _cmic_cmc_pktdma_curr_desc_lo;
} CMIC_CMC_PKTDMA_CURR_DESC_LOr_t;

#define CMIC_CMC_PKTDMA_CURR_DESC_LOr_CLR(r) (r).cmic_cmc_pktdma_curr_desc_lo[0] = 0
#define CMIC_CMC_PKTDMA_CURR_DESC_LOr_SET(r,d) (r).cmic_cmc_pktdma_curr_desc_lo[0] = d
#define CMIC_CMC_PKTDMA_CURR_DESC_LOr_GET(r) (r).cmic_cmc_pktdma_curr_desc_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_CURR_DESC_LOr_ADDRf_GET(r) ((r).cmic_cmc_pktdma_curr_desc_lo[0])
#define CMIC_CMC_PKTDMA_CURR_DESC_LOr_ADDRf_SET(r,f) (r).cmic_cmc_pktdma_curr_desc_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_CURR_DESC_LO.
 */
#define READ_CMIC_CMC_PKTDMA_CURR_DESC_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_CURR_DESC_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_curr_desc_lo)
#define WRITE_CMIC_CMC_PKTDMA_CURR_DESC_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_CURR_DESC_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_curr_desc_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_CURR_DESC_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DEBUG_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_OFFSET 0x00002130

#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DEBUG_CONTROL.
 */
typedef union CMIC_CMC_PKTDMA_DEBUG_CONTROLr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_debug_control[1];
    uint32_t _cmic_cmc_pktdma_debug_control;
} CMIC_CMC_PKTDMA_DEBUG_CONTROLr_t;

#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_CLR(r) (r).cmic_cmc_pktdma_debug_control[0] = 0
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_SET(r,d) (r).cmic_cmc_pktdma_debug_control[0] = d
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_GET(r) (r).cmic_cmc_pktdma_debug_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_DESC_PENDING_SER_Q_SIZEf_GET(r) (((r).cmic_cmc_pktdma_debug_control[0]) & 0x3)
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_DESC_PENDING_SER_Q_SIZEf_SET(r,f) (r).cmic_cmc_pktdma_debug_control[0]=(((r).cmic_cmc_pktdma_debug_control[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_DESC_PENDING_RESP_Q_SIZEf_GET(r) ((((r).cmic_cmc_pktdma_debug_control[0]) >> 2) & 0x3)
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_DESC_PENDING_RESP_Q_SIZEf_SET(r,f) (r).cmic_cmc_pktdma_debug_control[0]=(((r).cmic_cmc_pktdma_debug_control[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_DESC_PENDING_WRITE_Q_SIZEf_GET(r) ((((r).cmic_cmc_pktdma_debug_control[0]) >> 4) & 0x3)
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_DESC_PENDING_WRITE_Q_SIZEf_SET(r,f) (r).cmic_cmc_pktdma_debug_control[0]=(((r).cmic_cmc_pktdma_debug_control[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_FLUSH_DESC_Qf_GET(r) ((((r).cmic_cmc_pktdma_debug_control[0]) >> 6) & 0x1)
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_FLUSH_DESC_Qf_SET(r,f) (r).cmic_cmc_pktdma_debug_control[0]=(((r).cmic_cmc_pktdma_debug_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_RESET_OUTSTANDING_CNTf_GET(r) ((((r).cmic_cmc_pktdma_debug_control[0]) >> 7) & 0x1)
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_RESET_OUTSTANDING_CNTf_SET(r,f) (r).cmic_cmc_pktdma_debug_control[0]=(((r).cmic_cmc_pktdma_debug_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_SM_SELECTf_GET(r) ((((r).cmic_cmc_pktdma_debug_control[0]) >> 8) & 0x3)
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_SM_SELECTf_SET(r,f) (r).cmic_cmc_pktdma_debug_control[0]=(((r).cmic_cmc_pktdma_debug_control[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_RESET_DESC_READ_SM_IDLEf_GET(r) ((((r).cmic_cmc_pktdma_debug_control[0]) >> 10) & 0x1)
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_RESET_DESC_READ_SM_IDLEf_SET(r,f) (r).cmic_cmc_pktdma_debug_control[0]=(((r).cmic_cmc_pktdma_debug_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_RESET_MEM_RDWR_SM_IDLEf_GET(r) ((((r).cmic_cmc_pktdma_debug_control[0]) >> 11) & 0x1)
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_RESET_MEM_RDWR_SM_IDLEf_SET(r,f) (r).cmic_cmc_pktdma_debug_control[0]=(((r).cmic_cmc_pktdma_debug_control[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_RESET_DESC_RESP_COL_SM_IDLEf_GET(r) ((((r).cmic_cmc_pktdma_debug_control[0]) >> 12) & 0x1)
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_RESET_DESC_RESP_COL_SM_IDLEf_SET(r,f) (r).cmic_cmc_pktdma_debug_control[0]=(((r).cmic_cmc_pktdma_debug_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_RESET_DESC_STATUS_WR_SM_IDLEf_GET(r) ((((r).cmic_cmc_pktdma_debug_control[0]) >> 13) & 0x1)
#define CMIC_CMC_PKTDMA_DEBUG_CONTROLr_RESET_DESC_STATUS_WR_SM_IDLEf_SET(r,f) (r).cmic_cmc_pktdma_debug_control[0]=(((r).cmic_cmc_pktdma_debug_control[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DEBUG_CONTROL.
 */
#define READ_CMIC_CMC_PKTDMA_DEBUG_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DEBUG_CONTROLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_debug_control)
#define WRITE_CMIC_CMC_PKTDMA_DEBUG_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DEBUG_CONTROLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_debug_control)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DEBUG_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DEBUG_SM_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr_OFFSET 0x00002134

#define CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DEBUG_SM_STATUS.
 */
typedef union CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_debug_sm_status[1];
    uint32_t _cmic_cmc_pktdma_debug_sm_status;
} CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr_t;

#define CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr_CLR(r) (r).cmic_cmc_pktdma_debug_sm_status[0] = 0
#define CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr_SET(r,d) (r).cmic_cmc_pktdma_debug_sm_status[0] = d
#define CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr_GET(r) (r).cmic_cmc_pktdma_debug_sm_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr_STATEf_GET(r) ((r).cmic_cmc_pktdma_debug_sm_status[0])
#define CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr_STATEf_SET(r,f) (r).cmic_cmc_pktdma_debug_sm_status[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DEBUG_SM_STATUS.
 */
#define READ_CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_debug_sm_status)
#define WRITE_CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_debug_sm_status)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DEBUG_SM_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DEBUG_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_OFFSET 0x00002138

#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DEBUG_STATUS.
 */
typedef union CMIC_CMC_PKTDMA_DEBUG_STATUSr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_debug_status[1];
    uint32_t _cmic_cmc_pktdma_debug_status;
} CMIC_CMC_PKTDMA_DEBUG_STATUSr_t;

#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_CLR(r) (r).cmic_cmc_pktdma_debug_status[0] = 0
#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_SET(r,d) (r).cmic_cmc_pktdma_debug_status[0] = d
#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_GET(r) (r).cmic_cmc_pktdma_debug_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_DESC_PENDING_SER_Q_SIZE_NUM_ENTRIESf_GET(r) (((r).cmic_cmc_pktdma_debug_status[0]) & 0xf)
#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_DESC_PENDING_SER_Q_SIZE_NUM_ENTRIESf_SET(r,f) (r).cmic_cmc_pktdma_debug_status[0]=(((r).cmic_cmc_pktdma_debug_status[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_DESC_PENDING_RESP_Q_SIZE_NUM_ENTRIESf_GET(r) ((((r).cmic_cmc_pktdma_debug_status[0]) >> 4) & 0xf)
#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_DESC_PENDING_RESP_Q_SIZE_NUM_ENTRIESf_SET(r,f) (r).cmic_cmc_pktdma_debug_status[0]=(((r).cmic_cmc_pktdma_debug_status[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_DESC_PENDING_WRITE_Q_NUM_ENTRIESf_GET(r) ((((r).cmic_cmc_pktdma_debug_status[0]) >> 8) & 0xf)
#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_DESC_PENDING_WRITE_Q_NUM_ENTRIESf_SET(r,f) (r).cmic_cmc_pktdma_debug_status[0]=(((r).cmic_cmc_pktdma_debug_status[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_NUM_TXPKTBUF_CELL_USEDf_GET(r) ((((r).cmic_cmc_pktdma_debug_status[0]) >> 12) & 0xf)
#define CMIC_CMC_PKTDMA_DEBUG_STATUSr_NUM_TXPKTBUF_CELL_USEDf_SET(r,f) (r).cmic_cmc_pktdma_debug_status[0]=(((r).cmic_cmc_pktdma_debug_status[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DEBUG_STATUS.
 */
#define READ_CMIC_CMC_PKTDMA_DEBUG_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DEBUG_STATUSr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_debug_status)
#define WRITE_CMIC_CMC_PKTDMA_DEBUG_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DEBUG_STATUSr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_debug_status)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DEBUG_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DESC_ADDR_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DESC_ADDR_HIr_OFFSET 0x00002108

#define CMIC_CMC_PKTDMA_DESC_ADDR_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DESC_ADDR_HI.
 */
typedef union CMIC_CMC_PKTDMA_DESC_ADDR_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_desc_addr_hi[1];
    uint32_t _cmic_cmc_pktdma_desc_addr_hi;
} CMIC_CMC_PKTDMA_DESC_ADDR_HIr_t;

#define CMIC_CMC_PKTDMA_DESC_ADDR_HIr_CLR(r) (r).cmic_cmc_pktdma_desc_addr_hi[0] = 0
#define CMIC_CMC_PKTDMA_DESC_ADDR_HIr_SET(r,d) (r).cmic_cmc_pktdma_desc_addr_hi[0] = d
#define CMIC_CMC_PKTDMA_DESC_ADDR_HIr_GET(r) (r).cmic_cmc_pktdma_desc_addr_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DESC_ADDR_HIr_ADDRf_GET(r) ((r).cmic_cmc_pktdma_desc_addr_hi[0])
#define CMIC_CMC_PKTDMA_DESC_ADDR_HIr_ADDRf_SET(r,f) (r).cmic_cmc_pktdma_desc_addr_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DESC_ADDR_HI.
 */
#define READ_CMIC_CMC_PKTDMA_DESC_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DESC_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_addr_hi)
#define WRITE_CMIC_CMC_PKTDMA_DESC_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DESC_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_addr_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DESC_ADDR_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DESC_ADDR_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DESC_ADDR_LOr_OFFSET 0x00002104

#define CMIC_CMC_PKTDMA_DESC_ADDR_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DESC_ADDR_LO.
 */
typedef union CMIC_CMC_PKTDMA_DESC_ADDR_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_desc_addr_lo[1];
    uint32_t _cmic_cmc_pktdma_desc_addr_lo;
} CMIC_CMC_PKTDMA_DESC_ADDR_LOr_t;

#define CMIC_CMC_PKTDMA_DESC_ADDR_LOr_CLR(r) (r).cmic_cmc_pktdma_desc_addr_lo[0] = 0
#define CMIC_CMC_PKTDMA_DESC_ADDR_LOr_SET(r,d) (r).cmic_cmc_pktdma_desc_addr_lo[0] = d
#define CMIC_CMC_PKTDMA_DESC_ADDR_LOr_GET(r) (r).cmic_cmc_pktdma_desc_addr_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DESC_ADDR_LOr_ADDRf_GET(r) ((r).cmic_cmc_pktdma_desc_addr_lo[0])
#define CMIC_CMC_PKTDMA_DESC_ADDR_LOr_ADDRf_SET(r,f) (r).cmic_cmc_pktdma_desc_addr_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DESC_ADDR_LO.
 */
#define READ_CMIC_CMC_PKTDMA_DESC_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DESC_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_addr_lo)
#define WRITE_CMIC_CMC_PKTDMA_DESC_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DESC_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_addr_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DESC_ADDR_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DESC_COUNT_REQ
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DESC_COUNT_REQr_OFFSET 0x00002148

#define CMIC_CMC_PKTDMA_DESC_COUNT_REQr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DESC_COUNT_REQ.
 */
typedef union CMIC_CMC_PKTDMA_DESC_COUNT_REQr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_desc_count_req[1];
    uint32_t _cmic_cmc_pktdma_desc_count_req;
} CMIC_CMC_PKTDMA_DESC_COUNT_REQr_t;

#define CMIC_CMC_PKTDMA_DESC_COUNT_REQr_CLR(r) (r).cmic_cmc_pktdma_desc_count_req[0] = 0
#define CMIC_CMC_PKTDMA_DESC_COUNT_REQr_SET(r,d) (r).cmic_cmc_pktdma_desc_count_req[0] = d
#define CMIC_CMC_PKTDMA_DESC_COUNT_REQr_GET(r) (r).cmic_cmc_pktdma_desc_count_req[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DESC_COUNT_REQr_COUNTf_GET(r) ((r).cmic_cmc_pktdma_desc_count_req[0])
#define CMIC_CMC_PKTDMA_DESC_COUNT_REQr_COUNTf_SET(r,f) (r).cmic_cmc_pktdma_desc_count_req[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DESC_COUNT_REQ.
 */
#define READ_CMIC_CMC_PKTDMA_DESC_COUNT_REQr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DESC_COUNT_REQr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_count_req)
#define WRITE_CMIC_CMC_PKTDMA_DESC_COUNT_REQr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DESC_COUNT_REQr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_count_req)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DESC_COUNT_REQr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DESC_COUNT_RX
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DESC_COUNT_RXr_OFFSET 0x0000214c

#define CMIC_CMC_PKTDMA_DESC_COUNT_RXr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DESC_COUNT_RX.
 */
typedef union CMIC_CMC_PKTDMA_DESC_COUNT_RXr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_desc_count_rx[1];
    uint32_t _cmic_cmc_pktdma_desc_count_rx;
} CMIC_CMC_PKTDMA_DESC_COUNT_RXr_t;

#define CMIC_CMC_PKTDMA_DESC_COUNT_RXr_CLR(r) (r).cmic_cmc_pktdma_desc_count_rx[0] = 0
#define CMIC_CMC_PKTDMA_DESC_COUNT_RXr_SET(r,d) (r).cmic_cmc_pktdma_desc_count_rx[0] = d
#define CMIC_CMC_PKTDMA_DESC_COUNT_RXr_GET(r) (r).cmic_cmc_pktdma_desc_count_rx[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DESC_COUNT_RXr_COUNTf_GET(r) ((r).cmic_cmc_pktdma_desc_count_rx[0])
#define CMIC_CMC_PKTDMA_DESC_COUNT_RXr_COUNTf_SET(r,f) (r).cmic_cmc_pktdma_desc_count_rx[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DESC_COUNT_RX.
 */
#define READ_CMIC_CMC_PKTDMA_DESC_COUNT_RXr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DESC_COUNT_RXr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_count_rx)
#define WRITE_CMIC_CMC_PKTDMA_DESC_COUNT_RXr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DESC_COUNT_RXr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_count_rx)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DESC_COUNT_RXr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr_OFFSET 0x00002150

#define CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WR.
 */
typedef union CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_desc_count_status_wr[1];
    uint32_t _cmic_cmc_pktdma_desc_count_status_wr;
} CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr_t;

#define CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr_CLR(r) (r).cmic_cmc_pktdma_desc_count_status_wr[0] = 0
#define CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr_SET(r,d) (r).cmic_cmc_pktdma_desc_count_status_wr[0] = d
#define CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr_GET(r) (r).cmic_cmc_pktdma_desc_count_status_wr[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr_COUNTf_GET(r) ((r).cmic_cmc_pktdma_desc_count_status_wr[0])
#define CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr_COUNTf_SET(r,f) (r).cmic_cmc_pktdma_desc_count_status_wr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WR.
 */
#define READ_CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_count_status_wr)
#define WRITE_CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_count_status_wr)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DESC_COUNT_STATUS_WRr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr_OFFSET 0x00002110

#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HI.
 */
typedef union CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_desc_halt_addr_hi[1];
    uint32_t _cmic_cmc_pktdma_desc_halt_addr_hi;
} CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr_t;

#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr_CLR(r) (r).cmic_cmc_pktdma_desc_halt_addr_hi[0] = 0
#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr_SET(r,d) (r).cmic_cmc_pktdma_desc_halt_addr_hi[0] = d
#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr_GET(r) (r).cmic_cmc_pktdma_desc_halt_addr_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr_ADDRf_GET(r) ((r).cmic_cmc_pktdma_desc_halt_addr_hi[0])
#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr_ADDRf_SET(r,f) (r).cmic_cmc_pktdma_desc_halt_addr_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HI.
 */
#define READ_CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_halt_addr_hi)
#define WRITE_CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_halt_addr_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DESC_HALT_ADDR_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr_OFFSET 0x0000210c

#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LO.
 */
typedef union CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_desc_halt_addr_lo[1];
    uint32_t _cmic_cmc_pktdma_desc_halt_addr_lo;
} CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr_t;

#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr_CLR(r) (r).cmic_cmc_pktdma_desc_halt_addr_lo[0] = 0
#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr_SET(r,d) (r).cmic_cmc_pktdma_desc_halt_addr_lo[0] = d
#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr_GET(r) (r).cmic_cmc_pktdma_desc_halt_addr_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr_ADDRf_GET(r) ((r).cmic_cmc_pktdma_desc_halt_addr_lo[0])
#define CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr_ADDRf_SET(r,f) (r).cmic_cmc_pktdma_desc_halt_addr_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LO.
 */
#define READ_CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_halt_addr_lo)
#define WRITE_CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_halt_addr_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DESC_HALT_ADDR_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_OFFSET 0x00002158

#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROL.
 */
typedef union CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_desc_mem_ecc_control[1];
    uint32_t _cmic_cmc_pktdma_desc_mem_ecc_control;
} CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_t;

#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_CLR(r) (r).cmic_cmc_pktdma_desc_mem_ecc_control[0] = 0
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_SET(r,d) (r).cmic_cmc_pktdma_desc_mem_ecc_control[0] = d
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_GET(r) (r).cmic_cmc_pktdma_desc_mem_ecc_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_CLEAR_ECC_STATUSf_GET(r) (((r).cmic_cmc_pktdma_desc_mem_ecc_control[0]) & 0x1)
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_CLEAR_ECC_STATUSf_SET(r,f) (r).cmic_cmc_pktdma_desc_mem_ecc_control[0]=(((r).cmic_cmc_pktdma_desc_mem_ecc_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_INJECT_1BIT_ERRf_GET(r) ((((r).cmic_cmc_pktdma_desc_mem_ecc_control[0]) >> 1) & 0x1)
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_INJECT_1BIT_ERRf_SET(r,f) (r).cmic_cmc_pktdma_desc_mem_ecc_control[0]=(((r).cmic_cmc_pktdma_desc_mem_ecc_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_INJECT_2BITS_ERRf_GET(r) ((((r).cmic_cmc_pktdma_desc_mem_ecc_control[0]) >> 2) & 0x1)
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_INJECT_2BITS_ERRf_SET(r,f) (r).cmic_cmc_pktdma_desc_mem_ecc_control[0]=(((r).cmic_cmc_pktdma_desc_mem_ecc_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_DISABLE_ECCf_GET(r) ((((r).cmic_cmc_pktdma_desc_mem_ecc_control[0]) >> 3) & 0x1)
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_DISABLE_ECCf_SET(r,f) (r).cmic_cmc_pktdma_desc_mem_ecc_control[0]=(((r).cmic_cmc_pktdma_desc_mem_ecc_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROL.
 */
#define READ_CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_mem_ecc_control)
#define WRITE_CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_mem_ecc_control)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DESC_MEM_ECC_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_OFFSET 0x00002154

#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUS.
 */
typedef union CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_desc_mem_ecc_status[1];
    uint32_t _cmic_cmc_pktdma_desc_mem_ecc_status;
} CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_t;

#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_CLR(r) (r).cmic_cmc_pktdma_desc_mem_ecc_status[0] = 0
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_SET(r,d) (r).cmic_cmc_pktdma_desc_mem_ecc_status[0] = d
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_GET(r) (r).cmic_cmc_pktdma_desc_mem_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_SINGLE_BIT_ERR_DETECTEDf_GET(r) (((r).cmic_cmc_pktdma_desc_mem_ecc_status[0]) & 0x1)
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_SINGLE_BIT_ERR_DETECTEDf_SET(r,f) (r).cmic_cmc_pktdma_desc_mem_ecc_status[0]=(((r).cmic_cmc_pktdma_desc_mem_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_DOUBLE_BITS_ERR_DETECTEDf_GET(r) ((((r).cmic_cmc_pktdma_desc_mem_ecc_status[0]) >> 1) & 0x1)
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_DOUBLE_BITS_ERR_DETECTEDf_SET(r,f) (r).cmic_cmc_pktdma_desc_mem_ecc_status[0]=(((r).cmic_cmc_pktdma_desc_mem_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_MULTIPLE_ERR_DETECTEDf_GET(r) ((((r).cmic_cmc_pktdma_desc_mem_ecc_status[0]) >> 2) & 0x1)
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_MULTIPLE_ERR_DETECTEDf_SET(r,f) (r).cmic_cmc_pktdma_desc_mem_ecc_status[0]=(((r).cmic_cmc_pktdma_desc_mem_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_ECC_ERR_ADDRESSf_GET(r) ((((r).cmic_cmc_pktdma_desc_mem_ecc_status[0]) >> 3) & 0x1f)
#define CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_ECC_ERR_ADDRESSf_SET(r,f) (r).cmic_cmc_pktdma_desc_mem_ecc_status[0]=(((r).cmic_cmc_pktdma_desc_mem_ecc_status[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUS.
 */
#define READ_CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_mem_ecc_status)
#define WRITE_CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_mem_ecc_status)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DESC_MEM_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_OFFSET 0x0000215c

#define CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROL.
 */
typedef union CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_desc_mem_tm_control[1];
    uint32_t _cmic_cmc_pktdma_desc_mem_tm_control;
} CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_t;

#define CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_CLR(r) (r).cmic_cmc_pktdma_desc_mem_tm_control[0] = 0
#define CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_SET(r,d) (r).cmic_cmc_pktdma_desc_mem_tm_control[0] = d
#define CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_GET(r) (r).cmic_cmc_pktdma_desc_mem_tm_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_TM_MEM0f_GET(r) (((r).cmic_cmc_pktdma_desc_mem_tm_control[0]) & 0x1f)
#define CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_TM_MEM0f_SET(r,f) (r).cmic_cmc_pktdma_desc_mem_tm_control[0]=(((r).cmic_cmc_pktdma_desc_mem_tm_control[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_TM_MEM1f_GET(r) ((((r).cmic_cmc_pktdma_desc_mem_tm_control[0]) >> 5) & 0x1f)
#define CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_TM_MEM1f_SET(r,f) (r).cmic_cmc_pktdma_desc_mem_tm_control[0]=(((r).cmic_cmc_pktdma_desc_mem_tm_control[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROL.
 */
#define READ_CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_mem_tm_control)
#define WRITE_CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_desc_mem_tm_control)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_DESC_MEM_TM_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_INTR_COAL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_INTR_COALr_OFFSET 0x00002120

#define CMIC_CMC_PKTDMA_INTR_COALr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_INTR_COAL.
 */
typedef union CMIC_CMC_PKTDMA_INTR_COALr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_intr_coal[1];
    uint32_t _cmic_cmc_pktdma_intr_coal;
} CMIC_CMC_PKTDMA_INTR_COALr_t;

#define CMIC_CMC_PKTDMA_INTR_COALr_CLR(r) (r).cmic_cmc_pktdma_intr_coal[0] = 0
#define CMIC_CMC_PKTDMA_INTR_COALr_SET(r,d) (r).cmic_cmc_pktdma_intr_coal[0] = d
#define CMIC_CMC_PKTDMA_INTR_COALr_GET(r) (r).cmic_cmc_pktdma_intr_coal[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_INTR_COALr_TIMERf_GET(r) (((r).cmic_cmc_pktdma_intr_coal[0]) & 0xffff)
#define CMIC_CMC_PKTDMA_INTR_COALr_TIMERf_SET(r,f) (r).cmic_cmc_pktdma_intr_coal[0]=(((r).cmic_cmc_pktdma_intr_coal[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CMIC_CMC_PKTDMA_INTR_COALr_COUNTf_GET(r) ((((r).cmic_cmc_pktdma_intr_coal[0]) >> 16) & 0x7fff)
#define CMIC_CMC_PKTDMA_INTR_COALr_COUNTf_SET(r,f) (r).cmic_cmc_pktdma_intr_coal[0]=(((r).cmic_cmc_pktdma_intr_coal[0] & ~((uint32_t)0x7fff << 16)) | ((((uint32_t)f) & 0x7fff) << 16))
#define CMIC_CMC_PKTDMA_INTR_COALr_ENABLEf_GET(r) ((((r).cmic_cmc_pktdma_intr_coal[0]) >> 31) & 0x1)
#define CMIC_CMC_PKTDMA_INTR_COALr_ENABLEf_SET(r,f) (r).cmic_cmc_pktdma_intr_coal[0]=(((r).cmic_cmc_pktdma_intr_coal[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_INTR_COAL.
 */
#define READ_CMIC_CMC_PKTDMA_INTR_COALr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_INTR_COALr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_intr_coal)
#define WRITE_CMIC_CMC_PKTDMA_INTR_COALr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_INTR_COALr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_intr_coal)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_INTR_COALr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr_OFFSET 0x0000213c

#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT.
 */
typedef union CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_pkt_count_rxpkt[1];
    uint32_t _cmic_cmc_pktdma_pkt_count_rxpkt;
} CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr_t;

#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr_CLR(r) (r).cmic_cmc_pktdma_pkt_count_rxpkt[0] = 0
#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr_SET(r,d) (r).cmic_cmc_pktdma_pkt_count_rxpkt[0] = d
#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr_GET(r) (r).cmic_cmc_pktdma_pkt_count_rxpkt[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr_COUNTf_GET(r) ((r).cmic_cmc_pktdma_pkt_count_rxpkt[0])
#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr_COUNTf_SET(r,f) (r).cmic_cmc_pktdma_pkt_count_rxpkt[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT.
 */
#define READ_CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_pkt_count_rxpkt)
#define WRITE_CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_pkt_count_rxpkt)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_PKT_COUNT_RXPKTr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROP
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr_OFFSET 0x00002144

#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROP.
 */
typedef union CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_pkt_count_rxpkt_drop[1];
    uint32_t _cmic_cmc_pktdma_pkt_count_rxpkt_drop;
} CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr_t;

#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr_CLR(r) (r).cmic_cmc_pktdma_pkt_count_rxpkt_drop[0] = 0
#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr_SET(r,d) (r).cmic_cmc_pktdma_pkt_count_rxpkt_drop[0] = d
#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr_GET(r) (r).cmic_cmc_pktdma_pkt_count_rxpkt_drop[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr_COUNTf_GET(r) ((r).cmic_cmc_pktdma_pkt_count_rxpkt_drop[0])
#define CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr_COUNTf_SET(r,f) (r).cmic_cmc_pktdma_pkt_count_rxpkt_drop[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROP.
 */
#define READ_CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_pkt_count_rxpkt_drop)
#define WRITE_CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_pkt_count_rxpkt_drop)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_PKT_COUNT_RXPKT_DROPr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_PKT_COUNT_TXPKT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr_OFFSET 0x00002140

#define CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_PKT_COUNT_TXPKT.
 */
typedef union CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_pkt_count_txpkt[1];
    uint32_t _cmic_cmc_pktdma_pkt_count_txpkt;
} CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr_t;

#define CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr_CLR(r) (r).cmic_cmc_pktdma_pkt_count_txpkt[0] = 0
#define CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr_SET(r,d) (r).cmic_cmc_pktdma_pkt_count_txpkt[0] = d
#define CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr_GET(r) (r).cmic_cmc_pktdma_pkt_count_txpkt[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr_COUNTf_GET(r) ((r).cmic_cmc_pktdma_pkt_count_txpkt[0])
#define CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr_COUNTf_SET(r,f) (r).cmic_cmc_pktdma_pkt_count_txpkt[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_PKT_COUNT_TXPKT.
 */
#define READ_CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_pkt_count_txpkt)
#define WRITE_CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_pkt_count_txpkt)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_PKT_COUNT_TXPKTr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_OFFSET 0x0000212c

#define CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIG.
 */
typedef union CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_rxbuf_threshold_config[1];
    uint32_t _cmic_cmc_pktdma_rxbuf_threshold_config;
} CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_t;

#define CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_CLR(r) (r).cmic_cmc_pktdma_rxbuf_threshold_config[0] = 0
#define CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_SET(r,d) (r).cmic_cmc_pktdma_rxbuf_threshold_config[0] = d
#define CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_GET(r) (r).cmic_cmc_pktdma_rxbuf_threshold_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_RXBUF_THRESHOLDf_GET(r) (((r).cmic_cmc_pktdma_rxbuf_threshold_config[0]) & 0xff)
#define CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_RXBUF_THRESHOLDf_SET(r,f) (r).cmic_cmc_pktdma_rxbuf_threshold_config[0]=(((r).cmic_cmc_pktdma_rxbuf_threshold_config[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_ENABLEf_GET(r) ((((r).cmic_cmc_pktdma_rxbuf_threshold_config[0]) >> 8) & 0x1)
#define CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_ENABLEf_SET(r,f) (r).cmic_cmc_pktdma_rxbuf_threshold_config[0]=(((r).cmic_cmc_pktdma_rxbuf_threshold_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIG.
 */
#define READ_CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_rxbuf_threshold_config)
#define WRITE_CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_rxbuf_threshold_config)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_RXBUF_THRESHOLD_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PKTDMA_STAT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_PKTDMA_STATr_OFFSET 0x00002114

#define CMIC_CMC_PKTDMA_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_STAT.
 */
typedef union CMIC_CMC_PKTDMA_STATr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_pktdma_stat[1];
    uint32_t _cmic_cmc_pktdma_stat;
} CMIC_CMC_PKTDMA_STATr_t;

#define CMIC_CMC_PKTDMA_STATr_CLR(r) (r).cmic_cmc_pktdma_stat[0] = 0
#define CMIC_CMC_PKTDMA_STATr_SET(r,d) (r).cmic_cmc_pktdma_stat[0] = d
#define CMIC_CMC_PKTDMA_STATr_GET(r) (r).cmic_cmc_pktdma_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_STATr_CHAIN_DONEf_GET(r) (((r).cmic_cmc_pktdma_stat[0]) & 0x1)
#define CMIC_CMC_PKTDMA_STATr_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_pktdma_stat[0]=(((r).cmic_cmc_pktdma_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_PKTDMA_STATr_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc_pktdma_stat[0]) >> 1) & 0x1)
#define CMIC_CMC_PKTDMA_STATr_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc_pktdma_stat[0]=(((r).cmic_cmc_pktdma_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_PKTDMA_STATr_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_pktdma_stat[0]) >> 2) & 0x1)
#define CMIC_CMC_PKTDMA_STATr_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_pktdma_stat[0]=(((r).cmic_cmc_pktdma_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_PKTDMA_STATr_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_pktdma_stat[0]) >> 3) & 0x1)
#define CMIC_CMC_PKTDMA_STATr_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_pktdma_stat[0]=(((r).cmic_cmc_pktdma_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_PKTDMA_STATr_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_pktdma_stat[0]) >> 4) & 0x1)
#define CMIC_CMC_PKTDMA_STATr_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_pktdma_stat[0]=(((r).cmic_cmc_pktdma_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_PKTDMA_STATr_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_pktdma_stat[0]) >> 5) & 0x1)
#define CMIC_CMC_PKTDMA_STATr_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_pktdma_stat[0]=(((r).cmic_cmc_pktdma_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CMC_PKTDMA_STATr_CH_IN_HALTf_GET(r) ((((r).cmic_cmc_pktdma_stat[0]) >> 6) & 0x1)
#define CMIC_CMC_PKTDMA_STATr_CH_IN_HALTf_SET(r,f) (r).cmic_cmc_pktdma_stat[0]=(((r).cmic_cmc_pktdma_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_PKTDMA_STATr_RELOAD_UNALIGNED_ERRf_GET(r) ((((r).cmic_cmc_pktdma_stat[0]) >> 7) & 0x1)
#define CMIC_CMC_PKTDMA_STATr_RELOAD_UNALIGNED_ERRf_SET(r,f) (r).cmic_cmc_pktdma_stat[0]=(((r).cmic_cmc_pktdma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_STAT.
 */
#define READ_CMIC_CMC_PKTDMA_STATr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_PKTDMA_STATr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_stat)
#define WRITE_CMIC_CMC_PKTDMA_STATr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_PKTDMA_STATr_OFFSET+(0x80*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_pktdma_stat)

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_STATr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CONTROLr_OFFSET 0x00003000

#define CMIC_CMC_SBUSDMA_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CONTROL.
 */
typedef union CMIC_CMC_SBUSDMA_CONTROLr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_control[1];
    uint32_t _cmic_cmc_sbusdma_control;
} CMIC_CMC_SBUSDMA_CONTROLr_t;

#define CMIC_CMC_SBUSDMA_CONTROLr_CLR(r) (r).cmic_cmc_sbusdma_control[0] = 0
#define CMIC_CMC_SBUSDMA_CONTROLr_SET(r,d) (r).cmic_cmc_sbusdma_control[0] = d
#define CMIC_CMC_SBUSDMA_CONTROLr_GET(r) (r).cmic_cmc_sbusdma_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CONTROLr_STARTf_GET(r) (((r).cmic_cmc_sbusdma_control[0]) & 0x1)
#define CMIC_CMC_SBUSDMA_CONTROLr_STARTf_SET(r,f) (r).cmic_cmc_sbusdma_control[0]=(((r).cmic_cmc_sbusdma_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_SBUSDMA_CONTROLr_ABORTf_GET(r) ((((r).cmic_cmc_sbusdma_control[0]) >> 1) & 0x1)
#define CMIC_CMC_SBUSDMA_CONTROLr_ABORTf_SET(r,f) (r).cmic_cmc_sbusdma_control[0]=(((r).cmic_cmc_sbusdma_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_SBUSDMA_CONTROLr_MODEf_GET(r) ((((r).cmic_cmc_sbusdma_control[0]) >> 2) & 0x1)
#define CMIC_CMC_SBUSDMA_CONTROLr_MODEf_SET(r,f) (r).cmic_cmc_sbusdma_control[0]=(((r).cmic_cmc_sbusdma_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_SBUSDMA_CONTROLr_DESCRIPTOR_ENDIANESSf_GET(r) ((((r).cmic_cmc_sbusdma_control[0]) >> 3) & 0x1)
#define CMIC_CMC_SBUSDMA_CONTROLr_DESCRIPTOR_ENDIANESSf_SET(r,f) (r).cmic_cmc_sbusdma_control[0]=(((r).cmic_cmc_sbusdma_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_SBUSDMA_CONTROLr_DESC_PREFETCH_ENABLEf_GET(r) ((((r).cmic_cmc_sbusdma_control[0]) >> 4) & 0x1)
#define CMIC_CMC_SBUSDMA_CONTROLr_DESC_PREFETCH_ENABLEf_SET(r,f) (r).cmic_cmc_sbusdma_control[0]=(((r).cmic_cmc_sbusdma_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CONTROL.
 */
#define READ_CMIC_CMC_SBUSDMA_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CONTROLr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_control)
#define WRITE_CMIC_CMC_SBUSDMA_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CONTROLr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_control)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_COUNT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_COUNTr_OFFSET 0x00003008

#define CMIC_CMC_SBUSDMA_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_COUNT.
 */
typedef union CMIC_CMC_SBUSDMA_COUNTr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_count[1];
    uint32_t _cmic_cmc_sbusdma_count;
} CMIC_CMC_SBUSDMA_COUNTr_t;

#define CMIC_CMC_SBUSDMA_COUNTr_CLR(r) (r).cmic_cmc_sbusdma_count[0] = 0
#define CMIC_CMC_SBUSDMA_COUNTr_SET(r,d) (r).cmic_cmc_sbusdma_count[0] = d
#define CMIC_CMC_SBUSDMA_COUNTr_GET(r) (r).cmic_cmc_sbusdma_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_COUNTr_COUNTf_GET(r) ((r).cmic_cmc_sbusdma_count[0])
#define CMIC_CMC_SBUSDMA_COUNTr_COUNTf_SET(r,f) (r).cmic_cmc_sbusdma_count[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_COUNT.
 */
#define READ_CMIC_CMC_SBUSDMA_COUNTr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_COUNTr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_count)
#define WRITE_CMIC_CMC_SBUSDMA_COUNTr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_COUNTr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_count)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_COUNTr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr_OFFSET 0x00003038

#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HI.
 */
typedef union CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_cur_desc_address_hi[1];
    uint32_t _cmic_cmc_sbusdma_cur_desc_address_hi;
} CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr_t;

#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr_CLR(r) (r).cmic_cmc_sbusdma_cur_desc_address_hi[0] = 0
#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr_SET(r,d) (r).cmic_cmc_sbusdma_cur_desc_address_hi[0] = d
#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr_GET(r) (r).cmic_cmc_sbusdma_cur_desc_address_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_cur_desc_address_hi[0])
#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_cur_desc_address_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HI.
 */
#define READ_CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_desc_address_hi)
#define WRITE_CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_desc_address_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr_OFFSET 0x00003034

#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LO.
 */
typedef union CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_cur_desc_address_lo[1];
    uint32_t _cmic_cmc_sbusdma_cur_desc_address_lo;
} CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr_t;

#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr_CLR(r) (r).cmic_cmc_sbusdma_cur_desc_address_lo[0] = 0
#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr_SET(r,d) (r).cmic_cmc_sbusdma_cur_desc_address_lo[0] = d
#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr_GET(r) (r).cmic_cmc_sbusdma_cur_desc_address_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_cur_desc_address_lo[0])
#define CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_cur_desc_address_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LO.
 */
#define READ_CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_desc_address_lo)
#define WRITE_CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_desc_address_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CUR_DESC_ADDRESS_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr_OFFSET 0x0000302c

#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HI.
 */
typedef union CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_cur_hostmem_address_hi[1];
    uint32_t _cmic_cmc_sbusdma_cur_hostmem_address_hi;
} CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr_t;

#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr_CLR(r) (r).cmic_cmc_sbusdma_cur_hostmem_address_hi[0] = 0
#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr_SET(r,d) (r).cmic_cmc_sbusdma_cur_hostmem_address_hi[0] = d
#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr_GET(r) (r).cmic_cmc_sbusdma_cur_hostmem_address_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_cur_hostmem_address_hi[0])
#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_cur_hostmem_address_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HI.
 */
#define READ_CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_hostmem_address_hi)
#define WRITE_CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_hostmem_address_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr_OFFSET 0x00003028

#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LO.
 */
typedef union CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_cur_hostmem_address_lo[1];
    uint32_t _cmic_cmc_sbusdma_cur_hostmem_address_lo;
} CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr_t;

#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr_CLR(r) (r).cmic_cmc_sbusdma_cur_hostmem_address_lo[0] = 0
#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr_SET(r,d) (r).cmic_cmc_sbusdma_cur_hostmem_address_lo[0] = d
#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr_GET(r) (r).cmic_cmc_sbusdma_cur_hostmem_address_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_cur_hostmem_address_lo[0])
#define CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_cur_hostmem_address_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LO.
 */
#define READ_CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_hostmem_address_lo)
#define WRITE_CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_hostmem_address_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CUR_HOSTMEM_ADDRESS_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr_OFFSET 0x00003050

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNT.
 */
typedef union CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_cur_sbusdma_config_count[1];
    uint32_t _cmic_cmc_sbusdma_cur_sbusdma_config_count;
} CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr_t;

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr_CLR(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_count[0] = 0
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr_SET(r,d) (r).cmic_cmc_sbusdma_cur_sbusdma_config_count[0] = d
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr_GET(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr_COUNTf_GET(r) ((r).cmic_cmc_sbusdma_cur_sbusdma_config_count[0])
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr_COUNTf_SET(r,f) (r).cmic_cmc_sbusdma_cur_sbusdma_config_count[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNT.
 */
#define READ_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_count)
#define WRITE_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_count)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_COUNTr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr_OFFSET 0x0000304c

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HI.
 */
typedef union CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_hi[1];
    uint32_t _cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_hi;
} CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr_t;

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr_CLR(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_hi[0] = 0
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr_SET(r,d) (r).cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_hi[0] = d
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr_GET(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_hi[0])
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HI.
 */
#define READ_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_hi)
#define WRITE_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr_OFFSET 0x00003048

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LO.
 */
typedef union CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_lo[1];
    uint32_t _cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_lo;
} CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr_t;

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr_CLR(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_lo[0] = 0
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr_SET(r,d) (r).cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_lo[0] = d
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr_GET(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_lo[0])
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LO.
 */
#define READ_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_lo)
#define WRITE_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_hostmem_start_address_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_HOSTMEM_START_ADDRESS_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr_OFFSET 0x00003040

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODE.
 */
typedef union CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_cur_sbusdma_config_opcode[1];
    uint32_t _cmic_cmc_sbusdma_cur_sbusdma_config_opcode;
} CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr_t;

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr_CLR(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_opcode[0] = 0
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr_SET(r,d) (r).cmic_cmc_sbusdma_cur_sbusdma_config_opcode[0] = d
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr_GET(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_opcode[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr_OPCODEf_GET(r) ((r).cmic_cmc_sbusdma_cur_sbusdma_config_opcode[0])
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr_OPCODEf_SET(r,f) (r).cmic_cmc_sbusdma_cur_sbusdma_config_opcode[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODE.
 */
#define READ_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_opcode)
#define WRITE_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_opcode)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_OPCODEr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUEST
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr_OFFSET 0x0000303c

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUEST.
 */
typedef union CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_cur_sbusdma_config_request[1];
    uint32_t _cmic_cmc_sbusdma_cur_sbusdma_config_request;
} CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr_t;

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr_CLR(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_request[0] = 0
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr_SET(r,d) (r).cmic_cmc_sbusdma_cur_sbusdma_config_request[0] = d
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr_GET(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_request[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr_REQUESTf_GET(r) ((r).cmic_cmc_sbusdma_cur_sbusdma_config_request[0])
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr_REQUESTf_SET(r,f) (r).cmic_cmc_sbusdma_cur_sbusdma_config_request[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUEST.
 */
#define READ_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_request)
#define WRITE_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_request)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_REQUESTr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr_OFFSET 0x00003044

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESS.
 */
typedef union CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_cur_sbusdma_config_sbus_start_address[1];
    uint32_t _cmic_cmc_sbusdma_cur_sbusdma_config_sbus_start_address;
} CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr_t;

#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr_CLR(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_sbus_start_address[0] = 0
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr_SET(r,d) (r).cmic_cmc_sbusdma_cur_sbusdma_config_sbus_start_address[0] = d
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr_GET(r) (r).cmic_cmc_sbusdma_cur_sbusdma_config_sbus_start_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_cur_sbusdma_config_sbus_start_address[0])
#define CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_cur_sbusdma_config_sbus_start_address[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESS.
 */
#define READ_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_sbus_start_address)
#define WRITE_CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbusdma_config_sbus_start_address)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CUR_SBUSDMA_CONFIG_SBUS_START_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr_OFFSET 0x00003030

#define CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESS.
 */
typedef union CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_cur_sbus_address[1];
    uint32_t _cmic_cmc_sbusdma_cur_sbus_address;
} CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr_t;

#define CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr_CLR(r) (r).cmic_cmc_sbusdma_cur_sbus_address[0] = 0
#define CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr_SET(r,d) (r).cmic_cmc_sbusdma_cur_sbus_address[0] = d
#define CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr_GET(r) (r).cmic_cmc_sbusdma_cur_sbus_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_cur_sbus_address[0])
#define CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_cur_sbus_address[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESS.
 */
#define READ_CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbus_address)
#define WRITE_CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_cur_sbus_address)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_CUR_SBUS_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr_OFFSET 0x00003020

#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HI.
 */
typedef union CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_desc_start_address_hi[1];
    uint32_t _cmic_cmc_sbusdma_desc_start_address_hi;
} CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr_t;

#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr_CLR(r) (r).cmic_cmc_sbusdma_desc_start_address_hi[0] = 0
#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr_SET(r,d) (r).cmic_cmc_sbusdma_desc_start_address_hi[0] = d
#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr_GET(r) (r).cmic_cmc_sbusdma_desc_start_address_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_desc_start_address_hi[0])
#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_desc_start_address_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HI.
 */
#define READ_CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_desc_start_address_hi)
#define WRITE_CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_desc_start_address_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr_OFFSET 0x0000301c

#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LO.
 */
typedef union CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_desc_start_address_lo[1];
    uint32_t _cmic_cmc_sbusdma_desc_start_address_lo;
} CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr_t;

#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr_CLR(r) (r).cmic_cmc_sbusdma_desc_start_address_lo[0] = 0
#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr_SET(r,d) (r).cmic_cmc_sbusdma_desc_start_address_lo[0] = d
#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr_GET(r) (r).cmic_cmc_sbusdma_desc_start_address_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_desc_start_address_lo[0])
#define CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_desc_start_address_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LO.
 */
#define READ_CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_desc_start_address_lo)
#define WRITE_CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_desc_start_address_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_DESC_START_ADDRESS_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_ECC_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_OFFSET 0x00003064

#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_ECC_CONTROL.
 */
typedef union CMIC_CMC_SBUSDMA_ECC_CONTROLr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_ecc_control[1];
    uint32_t _cmic_cmc_sbusdma_ecc_control;
} CMIC_CMC_SBUSDMA_ECC_CONTROLr_t;

#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_CLR(r) (r).cmic_cmc_sbusdma_ecc_control[0] = 0
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_SET(r,d) (r).cmic_cmc_sbusdma_ecc_control[0] = d
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_GET(r) (r).cmic_cmc_sbusdma_ecc_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_INJECT_1BIT_ERR_IN_HOSTWR_MEMf_GET(r) (((r).cmic_cmc_sbusdma_ecc_control[0]) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_INJECT_1BIT_ERR_IN_HOSTWR_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_control[0]=(((r).cmic_cmc_sbusdma_ecc_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_INJECT_2BIT_ERR_IN_HOSTWR_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_control[0]) >> 1) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_INJECT_2BIT_ERR_IN_HOSTWR_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_control[0]=(((r).cmic_cmc_sbusdma_ecc_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_INJECT_1BIT_ERR_IN_HOSTRD_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_control[0]) >> 2) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_INJECT_1BIT_ERR_IN_HOSTRD_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_control[0]=(((r).cmic_cmc_sbusdma_ecc_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_INJECT_2BIT_ERR_IN_HOSTRD_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_control[0]) >> 3) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_INJECT_2BIT_ERR_IN_HOSTRD_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_control[0]=(((r).cmic_cmc_sbusdma_ecc_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_DISABLE_ECC_LOGIC_HOSTWR_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_control[0]) >> 4) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_DISABLE_ECC_LOGIC_HOSTWR_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_control[0]=(((r).cmic_cmc_sbusdma_ecc_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_DISABLE_ECC_LOGIC_HOSTRD_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_control[0]) >> 5) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_CONTROLr_DISABLE_ECC_LOGIC_HOSTRD_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_control[0]=(((r).cmic_cmc_sbusdma_ecc_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_ECC_CONTROL.
 */
#define READ_CMIC_CMC_SBUSDMA_ECC_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_ECC_CONTROLr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_ecc_control)
#define WRITE_CMIC_CMC_SBUSDMA_ECC_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_ECC_CONTROLr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_ecc_control)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_ECC_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_ECC_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_OFFSET 0x00003068

#define CMIC_CMC_SBUSDMA_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_ECC_STATUS.
 */
typedef union CMIC_CMC_SBUSDMA_ECC_STATUSr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_ecc_status[1];
    uint32_t _cmic_cmc_sbusdma_ecc_status;
} CMIC_CMC_SBUSDMA_ECC_STATUSr_t;

#define CMIC_CMC_SBUSDMA_ECC_STATUSr_CLR(r) (r).cmic_cmc_sbusdma_ecc_status[0] = 0
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_SET(r,d) (r).cmic_cmc_sbusdma_ecc_status[0] = d
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_GET(r) (r).cmic_cmc_sbusdma_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_SINGLE_BIT_ERR_DETECTED_IN_HOSTWR_MEMf_GET(r) (((r).cmic_cmc_sbusdma_ecc_status[0]) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_SINGLE_BIT_ERR_DETECTED_IN_HOSTWR_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_status[0]=(((r).cmic_cmc_sbusdma_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_SINGLE_BIT_ERR_DETECTED_IN_HOSTRD_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_status[0]) >> 1) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_SINGLE_BIT_ERR_DETECTED_IN_HOSTRD_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_status[0]=(((r).cmic_cmc_sbusdma_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_DOUBLE_BIT_ERR_DETECTED_IN_HOSTWR_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_status[0]) >> 2) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_DOUBLE_BIT_ERR_DETECTED_IN_HOSTWR_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_status[0]=(((r).cmic_cmc_sbusdma_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_DOUBLE_BIT_ERR_DETECTED_IN_HOSTRD_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_status[0]) >> 3) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_DOUBLE_BIT_ERR_DETECTED_IN_HOSTRD_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_status[0]=(((r).cmic_cmc_sbusdma_ecc_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_MULTIPLE_ERR_DETECTED_IN_HOSTWR_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_status[0]) >> 4) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_MULTIPLE_ERR_DETECTED_IN_HOSTWR_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_status[0]=(((r).cmic_cmc_sbusdma_ecc_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_MULTIPLE_ERR_DETECTED_IN_HOSTRD_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_status[0]) >> 5) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_MULTIPLE_ERR_DETECTED_IN_HOSTRD_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_status[0]=(((r).cmic_cmc_sbusdma_ecc_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_FIRST_ERR_ADDRESS_OF_HOSTWR_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_status[0]) >> 6) & 0xf)
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_FIRST_ERR_ADDRESS_OF_HOSTWR_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_status[0]=(((r).cmic_cmc_sbusdma_ecc_status[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_FIRST_ERR_ADDRESS_OF_HOSTRD_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_status[0]) >> 10) & 0xf)
#define CMIC_CMC_SBUSDMA_ECC_STATUSr_FIRST_ERR_ADDRESS_OF_HOSTRD_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_status[0]=(((r).cmic_cmc_sbusdma_ecc_status[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_ECC_STATUS.
 */
#define READ_CMIC_CMC_SBUSDMA_ECC_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_ECC_STATUSr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_ecc_status)
#define WRITE_CMIC_CMC_SBUSDMA_ECC_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_ECC_STATUSr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_ecc_status)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_ECC_STATUS_CLR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_OFFSET 0x0000306c

#define CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_ECC_STATUS_CLR.
 */
typedef union CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_ecc_status_clr[1];
    uint32_t _cmic_cmc_sbusdma_ecc_status_clr;
} CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_t;

#define CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_CLR(r) (r).cmic_cmc_sbusdma_ecc_status_clr[0] = 0
#define CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_SET(r,d) (r).cmic_cmc_sbusdma_ecc_status_clr[0] = d
#define CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_GET(r) (r).cmic_cmc_sbusdma_ecc_status_clr[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_CLEAR_HOSTWR_MEMf_GET(r) (((r).cmic_cmc_sbusdma_ecc_status_clr[0]) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_CLEAR_HOSTWR_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_status_clr[0]=(((r).cmic_cmc_sbusdma_ecc_status_clr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_CLEAR_HOSTRD_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_ecc_status_clr[0]) >> 1) & 0x1)
#define CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_CLEAR_HOSTRD_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_ecc_status_clr[0]=(((r).cmic_cmc_sbusdma_ecc_status_clr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_ECC_STATUS_CLR.
 */
#define READ_CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_ecc_status_clr)
#define WRITE_CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_ecc_status_clr)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_ECC_STATUS_CLRr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr_OFFSET 0x00003018

#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HI.
 */
typedef union CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_hostmem_start_address_hi[1];
    uint32_t _cmic_cmc_sbusdma_hostmem_start_address_hi;
} CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr_t;

#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr_CLR(r) (r).cmic_cmc_sbusdma_hostmem_start_address_hi[0] = 0
#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr_SET(r,d) (r).cmic_cmc_sbusdma_hostmem_start_address_hi[0] = d
#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr_GET(r) (r).cmic_cmc_sbusdma_hostmem_start_address_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_hostmem_start_address_hi[0])
#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_hostmem_start_address_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HI.
 */
#define READ_CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_hostmem_start_address_hi)
#define WRITE_CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_hostmem_start_address_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr_OFFSET 0x00003014

#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LO.
 */
typedef union CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_hostmem_start_address_lo[1];
    uint32_t _cmic_cmc_sbusdma_hostmem_start_address_lo;
} CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr_t;

#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr_CLR(r) (r).cmic_cmc_sbusdma_hostmem_start_address_lo[0] = 0
#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr_SET(r,d) (r).cmic_cmc_sbusdma_hostmem_start_address_lo[0] = d
#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr_GET(r) (r).cmic_cmc_sbusdma_hostmem_start_address_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_hostmem_start_address_lo[0])
#define CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_hostmem_start_address_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LO.
 */
#define READ_CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_hostmem_start_address_lo)
#define WRITE_CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_hostmem_start_address_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_HOSTMEM_START_ADDRESS_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_ITER_COUNT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_ITER_COUNTr_OFFSET 0x00003074

#define CMIC_CMC_SBUSDMA_ITER_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_ITER_COUNT.
 */
typedef union CMIC_CMC_SBUSDMA_ITER_COUNTr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_iter_count[1];
    uint32_t _cmic_cmc_sbusdma_iter_count;
} CMIC_CMC_SBUSDMA_ITER_COUNTr_t;

#define CMIC_CMC_SBUSDMA_ITER_COUNTr_CLR(r) (r).cmic_cmc_sbusdma_iter_count[0] = 0
#define CMIC_CMC_SBUSDMA_ITER_COUNTr_SET(r,d) (r).cmic_cmc_sbusdma_iter_count[0] = d
#define CMIC_CMC_SBUSDMA_ITER_COUNTr_GET(r) (r).cmic_cmc_sbusdma_iter_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_ITER_COUNTr_TIMERf_GET(r) ((r).cmic_cmc_sbusdma_iter_count[0])
#define CMIC_CMC_SBUSDMA_ITER_COUNTr_TIMERf_SET(r,f) (r).cmic_cmc_sbusdma_iter_count[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_ITER_COUNT.
 */
#define READ_CMIC_CMC_SBUSDMA_ITER_COUNTr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_ITER_COUNTr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_iter_count)
#define WRITE_CMIC_CMC_SBUSDMA_ITER_COUNTr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_ITER_COUNTr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_iter_count)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_ITER_COUNTr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_OPCODE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_OPCODEr_OFFSET 0x0000300c

#define CMIC_CMC_SBUSDMA_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_OPCODE.
 */
typedef union CMIC_CMC_SBUSDMA_OPCODEr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_opcode[1];
    uint32_t _cmic_cmc_sbusdma_opcode;
} CMIC_CMC_SBUSDMA_OPCODEr_t;

#define CMIC_CMC_SBUSDMA_OPCODEr_CLR(r) (r).cmic_cmc_sbusdma_opcode[0] = 0
#define CMIC_CMC_SBUSDMA_OPCODEr_SET(r,d) (r).cmic_cmc_sbusdma_opcode[0] = d
#define CMIC_CMC_SBUSDMA_OPCODEr_GET(r) (r).cmic_cmc_sbusdma_opcode[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_OPCODEr_OPCODEf_GET(r) ((r).cmic_cmc_sbusdma_opcode[0])
#define CMIC_CMC_SBUSDMA_OPCODEr_OPCODEf_SET(r,f) (r).cmic_cmc_sbusdma_opcode[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_OPCODE.
 */
#define READ_CMIC_CMC_SBUSDMA_OPCODEr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_OPCODEr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_opcode)
#define WRITE_CMIC_CMC_SBUSDMA_OPCODEr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_OPCODEr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_opcode)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_OPCODEr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_REQUEST
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_REQUESTr_OFFSET 0x00003004

#define CMIC_CMC_SBUSDMA_REQUESTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_REQUEST.
 */
typedef union CMIC_CMC_SBUSDMA_REQUESTr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_request[1];
    uint32_t _cmic_cmc_sbusdma_request;
} CMIC_CMC_SBUSDMA_REQUESTr_t;

#define CMIC_CMC_SBUSDMA_REQUESTr_CLR(r) (r).cmic_cmc_sbusdma_request[0] = 0
#define CMIC_CMC_SBUSDMA_REQUESTr_SET(r,d) (r).cmic_cmc_sbusdma_request[0] = d
#define CMIC_CMC_SBUSDMA_REQUESTr_GET(r) (r).cmic_cmc_sbusdma_request[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_REQUESTr_REP_WORDSf_GET(r) (((r).cmic_cmc_sbusdma_request[0]) & 0x1f)
#define CMIC_CMC_SBUSDMA_REQUESTr_REP_WORDSf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define CMIC_CMC_SBUSDMA_REQUESTr_REQ_WORDSf_GET(r) ((((r).cmic_cmc_sbusdma_request[0]) >> 5) & 0x1f)
#define CMIC_CMC_SBUSDMA_REQUESTr_REQ_WORDSf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define CMIC_CMC_SBUSDMA_REQUESTr_HOSTMEMRD_ENDIANESSf_GET(r) ((((r).cmic_cmc_sbusdma_request[0]) >> 10) & 0x1)
#define CMIC_CMC_SBUSDMA_REQUESTr_HOSTMEMRD_ENDIANESSf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_CMC_SBUSDMA_REQUESTr_HOSTMEMWR_ENDIANESSf_GET(r) ((((r).cmic_cmc_sbusdma_request[0]) >> 11) & 0x1)
#define CMIC_CMC_SBUSDMA_REQUESTr_HOSTMEMWR_ENDIANESSf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_CMC_SBUSDMA_REQUESTr_WORDSWAP_IN_64BIT_SBUSDATAf_GET(r) ((((r).cmic_cmc_sbusdma_request[0]) >> 12) & 0x1)
#define CMIC_CMC_SBUSDMA_REQUESTr_WORDSWAP_IN_64BIT_SBUSDATAf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_CMC_SBUSDMA_REQUESTr_DMA_WR_TO_NULLSPACEf_GET(r) ((((r).cmic_cmc_sbusdma_request[0]) >> 13) & 0x1)
#define CMIC_CMC_SBUSDMA_REQUESTr_DMA_WR_TO_NULLSPACEf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CMIC_CMC_SBUSDMA_REQUESTr_IGNORE_SBUS_EARLYACKf_GET(r) ((((r).cmic_cmc_sbusdma_request[0]) >> 14) & 0x1)
#define CMIC_CMC_SBUSDMA_REQUESTr_IGNORE_SBUS_EARLYACKf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CMIC_CMC_SBUSDMA_REQUESTr_PEND_CLOCKSf_GET(r) ((((r).cmic_cmc_sbusdma_request[0]) >> 16) & 0xff)
#define CMIC_CMC_SBUSDMA_REQUESTr_PEND_CLOCKSf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define CMIC_CMC_SBUSDMA_REQUESTr_INCR_SHIFTf_GET(r) ((((r).cmic_cmc_sbusdma_request[0]) >> 24) & 0x1f)
#define CMIC_CMC_SBUSDMA_REQUESTr_INCR_SHIFTf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define CMIC_CMC_SBUSDMA_REQUESTr_INCR_NOADDf_GET(r) ((((r).cmic_cmc_sbusdma_request[0]) >> 29) & 0x1)
#define CMIC_CMC_SBUSDMA_REQUESTr_INCR_NOADDf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define CMIC_CMC_SBUSDMA_REQUESTr_REQ_SINGLEf_GET(r) ((((r).cmic_cmc_sbusdma_request[0]) >> 30) & 0x1)
#define CMIC_CMC_SBUSDMA_REQUESTr_REQ_SINGLEf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define CMIC_CMC_SBUSDMA_REQUESTr_DECRf_GET(r) ((((r).cmic_cmc_sbusdma_request[0]) >> 31) & 0x1)
#define CMIC_CMC_SBUSDMA_REQUESTr_DECRf_SET(r,f) (r).cmic_cmc_sbusdma_request[0]=(((r).cmic_cmc_sbusdma_request[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_REQUEST.
 */
#define READ_CMIC_CMC_SBUSDMA_REQUESTr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_REQUESTr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_request)
#define WRITE_CMIC_CMC_SBUSDMA_REQUESTr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_REQUESTr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_request)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_REQUESTr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr_OFFSET 0x00003054

#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG.
 */
typedef union CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_sbusdma_debug[1];
    uint32_t _cmic_cmc_sbusdma_sbusdma_debug;
} CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr_t;

#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr_CLR(r) (r).cmic_cmc_sbusdma_sbusdma_debug[0] = 0
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr_SET(r,d) (r).cmic_cmc_sbusdma_sbusdma_debug[0] = d
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr_GET(r) (r).cmic_cmc_sbusdma_sbusdma_debug[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr_DESC_DONEf_GET(r) (((r).cmic_cmc_sbusdma_sbusdma_debug[0]) & 0x1)
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr_DESC_DONEf_SET(r,f) (r).cmic_cmc_sbusdma_sbusdma_debug[0]=(((r).cmic_cmc_sbusdma_sbusdma_debug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG.
 */
#define READ_CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_sbusdma_debug)
#define WRITE_CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_sbusdma_debug)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_SBUSDMA_DEBUGr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_OFFSET 0x00003058

#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLR.
 */
typedef union CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_sbusdma_debug_clr[1];
    uint32_t _cmic_cmc_sbusdma_sbusdma_debug_clr;
} CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_t;

#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_CLR(r) (r).cmic_cmc_sbusdma_sbusdma_debug_clr[0] = 0
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_SET(r,d) (r).cmic_cmc_sbusdma_sbusdma_debug_clr[0] = d
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_GET(r) (r).cmic_cmc_sbusdma_sbusdma_debug_clr[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_DESC_DONEf_GET(r) (((r).cmic_cmc_sbusdma_sbusdma_debug_clr[0]) & 0x1)
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_DESC_DONEf_SET(r,f) (r).cmic_cmc_sbusdma_sbusdma_debug_clr[0]=(((r).cmic_cmc_sbusdma_sbusdma_debug_clr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_ECC_2BIT_CHECK_FAILf_GET(r) ((((r).cmic_cmc_sbusdma_sbusdma_debug_clr[0]) >> 1) & 0x1)
#define CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_ECC_2BIT_CHECK_FAILf_SET(r,f) (r).cmic_cmc_sbusdma_sbusdma_debug_clr[0]=(((r).cmic_cmc_sbusdma_sbusdma_debug_clr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLR.
 */
#define READ_CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_sbusdma_debug_clr)
#define WRITE_CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_sbusdma_debug_clr)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_SBUSDMA_DEBUG_CLRr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr_OFFSET 0x00003060

#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HI.
 */
typedef union CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_sbusdma_eccerr_address_hi[1];
    uint32_t _cmic_cmc_sbusdma_sbusdma_eccerr_address_hi;
} CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr_t;

#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr_CLR(r) (r).cmic_cmc_sbusdma_sbusdma_eccerr_address_hi[0] = 0
#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr_SET(r,d) (r).cmic_cmc_sbusdma_sbusdma_eccerr_address_hi[0] = d
#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr_GET(r) (r).cmic_cmc_sbusdma_sbusdma_eccerr_address_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_sbusdma_eccerr_address_hi[0])
#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_sbusdma_eccerr_address_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HI.
 */
#define READ_CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_sbusdma_eccerr_address_hi)
#define WRITE_CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_sbusdma_eccerr_address_hi)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr_OFFSET 0x0000305c

#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LO.
 */
typedef union CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_sbusdma_eccerr_address_lo[1];
    uint32_t _cmic_cmc_sbusdma_sbusdma_eccerr_address_lo;
} CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr_t;

#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr_CLR(r) (r).cmic_cmc_sbusdma_sbusdma_eccerr_address_lo[0] = 0
#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr_SET(r,d) (r).cmic_cmc_sbusdma_sbusdma_eccerr_address_lo[0] = d
#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr_GET(r) (r).cmic_cmc_sbusdma_sbusdma_eccerr_address_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_sbusdma_eccerr_address_lo[0])
#define CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_sbusdma_eccerr_address_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LO.
 */
#define READ_CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_sbusdma_eccerr_address_lo)
#define WRITE_CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_sbusdma_eccerr_address_lo)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_SBUSDMA_ECCERR_ADDRESS_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_SBUS_START_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr_OFFSET 0x00003010

#define CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_SBUS_START_ADDRESS.
 */
typedef union CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_sbus_start_address[1];
    uint32_t _cmic_cmc_sbusdma_sbus_start_address;
} CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr_t;

#define CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr_CLR(r) (r).cmic_cmc_sbusdma_sbus_start_address[0] = 0
#define CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr_SET(r,d) (r).cmic_cmc_sbusdma_sbus_start_address[0] = d
#define CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr_GET(r) (r).cmic_cmc_sbusdma_sbus_start_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr_ADDRESSf_GET(r) ((r).cmic_cmc_sbusdma_sbus_start_address[0])
#define CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr_ADDRESSf_SET(r,f) (r).cmic_cmc_sbusdma_sbus_start_address[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_SBUS_START_ADDRESS.
 */
#define READ_CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_sbus_start_address)
#define WRITE_CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_sbus_start_address)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_SBUS_START_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_STATUSr_OFFSET 0x00003024

#define CMIC_CMC_SBUSDMA_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_STATUS.
 */
typedef union CMIC_CMC_SBUSDMA_STATUSr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_status[1];
    uint32_t _cmic_cmc_sbusdma_status;
} CMIC_CMC_SBUSDMA_STATUSr_t;

#define CMIC_CMC_SBUSDMA_STATUSr_CLR(r) (r).cmic_cmc_sbusdma_status[0] = 0
#define CMIC_CMC_SBUSDMA_STATUSr_SET(r,d) (r).cmic_cmc_sbusdma_status[0] = d
#define CMIC_CMC_SBUSDMA_STATUSr_GET(r) (r).cmic_cmc_sbusdma_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_STATUSr_DONEf_GET(r) (((r).cmic_cmc_sbusdma_status[0]) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_DONEf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_SBUSDMA_STATUSr_ERRORf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 1) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_ERRORf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_SBUSDMA_STATUSr_HOSTMEMWR_ERRORf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 2) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_HOSTMEMWR_ERRORf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_SBUSDMA_STATUSr_HOSTMEMRD_ERRORf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 3) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_HOSTMEMRD_ERRORf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_SBUSDMA_STATUSr_SER_CHECK_FAILf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 4) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_SER_CHECK_FAILf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSACK_WRONG_BEATCOUNTf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 5) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSACK_WRONG_BEATCOUNTf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSACK_WRONG_OPCODEf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 6) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSACK_WRONG_OPCODEf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSACK_NACKf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 7) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSACK_NACKf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSACK_ERRORf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 8) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSACK_ERRORf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSACK_TIMEOUTf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 9) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSACK_TIMEOUTf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_CMC_SBUSDMA_STATUSr_DESCRD_ERRORf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 10) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_DESCRD_ERRORf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_CMC_SBUSDMA_STATUSr_ACTIVEf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 11) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_ACTIVEf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSDMA_ACTIVEf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 12) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_SBUSDMA_ACTIVEf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_CMC_SBUSDMA_STATUSr_ECC_2BIT_CHECK_FAILf_GET(r) ((((r).cmic_cmc_sbusdma_status[0]) >> 13) & 0x1)
#define CMIC_CMC_SBUSDMA_STATUSr_ECC_2BIT_CHECK_FAILf_SET(r,f) (r).cmic_cmc_sbusdma_status[0]=(((r).cmic_cmc_sbusdma_status[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_STATUS.
 */
#define READ_CMIC_CMC_SBUSDMA_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_STATUSr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_status)
#define WRITE_CMIC_CMC_SBUSDMA_STATUSr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_STATUSr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_status)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_TIMER
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_TIMERr_OFFSET 0x00003070

#define CMIC_CMC_SBUSDMA_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_TIMER.
 */
typedef union CMIC_CMC_SBUSDMA_TIMERr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_timer[1];
    uint32_t _cmic_cmc_sbusdma_timer;
} CMIC_CMC_SBUSDMA_TIMERr_t;

#define CMIC_CMC_SBUSDMA_TIMERr_CLR(r) (r).cmic_cmc_sbusdma_timer[0] = 0
#define CMIC_CMC_SBUSDMA_TIMERr_SET(r,d) (r).cmic_cmc_sbusdma_timer[0] = d
#define CMIC_CMC_SBUSDMA_TIMERr_GET(r) (r).cmic_cmc_sbusdma_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_TIMERr_TIMERf_GET(r) ((r).cmic_cmc_sbusdma_timer[0])
#define CMIC_CMC_SBUSDMA_TIMERr_TIMERf_SET(r,f) (r).cmic_cmc_sbusdma_timer[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_TIMER.
 */
#define READ_CMIC_CMC_SBUSDMA_TIMERr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_TIMERr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_timer)
#define WRITE_CMIC_CMC_SBUSDMA_TIMERr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_TIMERr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_timer)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_TIMERr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SBUSDMA_TM_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SBUSDMA_TM_CONTROLr_OFFSET 0x00003078

#define CMIC_CMC_SBUSDMA_TM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SBUSDMA_TM_CONTROL.
 */
typedef union CMIC_CMC_SBUSDMA_TM_CONTROLr_s {
    uint32_t v[1];
    uint32_t cmic_cmc_sbusdma_tm_control[1];
    uint32_t _cmic_cmc_sbusdma_tm_control;
} CMIC_CMC_SBUSDMA_TM_CONTROLr_t;

#define CMIC_CMC_SBUSDMA_TM_CONTROLr_CLR(r) (r).cmic_cmc_sbusdma_tm_control[0] = 0
#define CMIC_CMC_SBUSDMA_TM_CONTROLr_SET(r,d) (r).cmic_cmc_sbusdma_tm_control[0] = d
#define CMIC_CMC_SBUSDMA_TM_CONTROLr_GET(r) (r).cmic_cmc_sbusdma_tm_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SBUSDMA_TM_CONTROLr_TM_HOSTWR_MEMf_GET(r) (((r).cmic_cmc_sbusdma_tm_control[0]) & 0x1f)
#define CMIC_CMC_SBUSDMA_TM_CONTROLr_TM_HOSTWR_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_tm_control[0]=(((r).cmic_cmc_sbusdma_tm_control[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define CMIC_CMC_SBUSDMA_TM_CONTROLr_TM_HOSTRD_MEMf_GET(r) ((((r).cmic_cmc_sbusdma_tm_control[0]) >> 5) & 0x1f)
#define CMIC_CMC_SBUSDMA_TM_CONTROLr_TM_HOSTRD_MEMf_SET(r,f) (r).cmic_cmc_sbusdma_tm_control[0]=(((r).cmic_cmc_sbusdma_tm_control[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))

/*
 * These macros can be used to access CMIC_CMC_SBUSDMA_TM_CONTROL.
 */
#define READ_CMIC_CMC_SBUSDMA_TM_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SBUSDMA_TM_CONTROLr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_tm_control)
#define WRITE_CMIC_CMC_SBUSDMA_TM_CONTROLr(u,_cmc,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SBUSDMA_TM_CONTROLr_OFFSET+(0x100*(_ch))+(0x3000*(_cmc)),r._cmic_cmc_sbusdma_tm_control)

/*******************************************************************************
 * End of 'CMIC_CMC_SBUSDMA_TM_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SHARED_IRQ_STAT0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_CMC_SHARED_IRQ_STAT0r_OFFSET 0x0000106c

#define CMIC_CMC_SHARED_IRQ_STAT0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SHARED_IRQ_STAT0.
 */
typedef union CMIC_CMC_SHARED_IRQ_STAT0r_s {
    uint32_t v[1];
    uint32_t cmic_cmc_shared_irq_stat0[1];
    uint32_t _cmic_cmc_shared_irq_stat0;
} CMIC_CMC_SHARED_IRQ_STAT0r_t;

#define CMIC_CMC_SHARED_IRQ_STAT0r_CLR(r) (r).cmic_cmc_shared_irq_stat0[0] = 0
#define CMIC_CMC_SHARED_IRQ_STAT0r_SET(r,d) (r).cmic_cmc_shared_irq_stat0[0] = d
#define CMIC_CMC_SHARED_IRQ_STAT0r_GET(r) (r).cmic_cmc_shared_irq_stat0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SHARED_IRQ_STAT0r_DATAf_GET(r) ((r).[0])
#define CMIC_CMC_SHARED_IRQ_STAT0r_DATAf_SET(r,f) (r).[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SHARED_IRQ_STAT0.
 */
#define READ_CMIC_CMC_SHARED_IRQ_STAT0r(u,_cmc,r) BCMDRD_DEV_READ32(u,CMIC_CMC_SHARED_IRQ_STAT0r_OFFSET+(0x3000*(_cmc)),r._cmic_cmc_shared_irq_stat0)
#define WRITE_CMIC_CMC_SHARED_IRQ_STAT0r(u,_cmc,r) BCMDRD_DEV_WRITE32(u,CMIC_CMC_SHARED_IRQ_STAT0r_OFFSET+(0x3000*(_cmc)),r._cmic_cmc_shared_irq_stat0)

/*******************************************************************************
 * End of 'CMIC_CMC_SHARED_IRQ_STAT0r'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_CFG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_CFGr_OFFSET 0x00011000

#define CMIC_FIFO_RD_DMA_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_CFG.
 */
typedef union CMIC_FIFO_RD_DMA_CFGr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_cfg[1];
    uint32_t _cmic_fifo_rd_dma_cfg;
} CMIC_FIFO_RD_DMA_CFGr_t;

#define CMIC_FIFO_RD_DMA_CFGr_CLR(r) (r).cmic_fifo_rd_dma_cfg[0] = 0
#define CMIC_FIFO_RD_DMA_CFGr_SET(r,d) (r).cmic_fifo_rd_dma_cfg[0] = d
#define CMIC_FIFO_RD_DMA_CFGr_GET(r) (r).cmic_fifo_rd_dma_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_CFGr_ENABLEf_GET(r) (((r).cmic_fifo_rd_dma_cfg[0]) & 0x1)
#define CMIC_FIFO_RD_DMA_CFGr_ENABLEf_SET(r,f) (r).cmic_fifo_rd_dma_cfg[0]=(((r).cmic_fifo_rd_dma_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_FIFO_RD_DMA_CFGr_NACK_FATALf_GET(r) ((((r).cmic_fifo_rd_dma_cfg[0]) >> 1) & 0x1)
#define CMIC_FIFO_RD_DMA_CFGr_NACK_FATALf_SET(r,f) (r).cmic_fifo_rd_dma_cfg[0]=(((r).cmic_fifo_rd_dma_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_FIFO_RD_DMA_CFGr_BEAT_COUNTf_GET(r) ((((r).cmic_fifo_rd_dma_cfg[0]) >> 2) & 0x1f)
#define CMIC_FIFO_RD_DMA_CFGr_BEAT_COUNTf_SET(r,f) (r).cmic_fifo_rd_dma_cfg[0]=(((r).cmic_fifo_rd_dma_cfg[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define CMIC_FIFO_RD_DMA_CFGr_HOST_NUM_ENTRIES_SELf_GET(r) ((((r).cmic_fifo_rd_dma_cfg[0]) >> 7) & 0xf)
#define CMIC_FIFO_RD_DMA_CFGr_HOST_NUM_ENTRIES_SELf_SET(r,f) (r).cmic_fifo_rd_dma_cfg[0]=(((r).cmic_fifo_rd_dma_cfg[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define CMIC_FIFO_RD_DMA_CFGr_ENDIANESSf_GET(r) ((((r).cmic_fifo_rd_dma_cfg[0]) >> 11) & 0x1)
#define CMIC_FIFO_RD_DMA_CFGr_ENDIANESSf_SET(r,f) (r).cmic_fifo_rd_dma_cfg[0]=(((r).cmic_fifo_rd_dma_cfg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_FIFO_RD_DMA_CFGr_TIMEOUT_COUNTf_GET(r) ((((r).cmic_fifo_rd_dma_cfg[0]) >> 12) & 0x3fff)
#define CMIC_FIFO_RD_DMA_CFGr_TIMEOUT_COUNTf_SET(r,f) (r).cmic_fifo_rd_dma_cfg[0]=(((r).cmic_fifo_rd_dma_cfg[0] & ~((uint32_t)0x3fff << 12)) | ((((uint32_t)f) & 0x3fff) << 12))
#define CMIC_FIFO_RD_DMA_CFGr_MULTIPLE_SBUS_CMD_SPACINGf_GET(r) ((((r).cmic_fifo_rd_dma_cfg[0]) >> 26) & 0x1f)
#define CMIC_FIFO_RD_DMA_CFGr_MULTIPLE_SBUS_CMD_SPACINGf_SET(r,f) (r).cmic_fifo_rd_dma_cfg[0]=(((r).cmic_fifo_rd_dma_cfg[0] & ~((uint32_t)0x1f << 26)) | ((((uint32_t)f) & 0x1f) << 26))
#define CMIC_FIFO_RD_DMA_CFGr_ABORTf_GET(r) ((((r).cmic_fifo_rd_dma_cfg[0]) >> 31) & 0x1)
#define CMIC_FIFO_RD_DMA_CFGr_ABORTf_SET(r,f) (r).cmic_fifo_rd_dma_cfg[0]=(((r).cmic_fifo_rd_dma_cfg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_CFG.
 */
#define READ_CMIC_FIFO_RD_DMA_CFGr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_CFGr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_cfg)
#define WRITE_CMIC_FIFO_RD_DMA_CFGr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_CFGr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_cfg)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_CFGr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_CFG_1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_CFG_1r_OFFSET 0x00011004

#define CMIC_FIFO_RD_DMA_CFG_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_CFG_1.
 */
typedef union CMIC_FIFO_RD_DMA_CFG_1r_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_cfg_1[1];
    uint32_t _cmic_fifo_rd_dma_cfg_1;
} CMIC_FIFO_RD_DMA_CFG_1r_t;

#define CMIC_FIFO_RD_DMA_CFG_1r_CLR(r) (r).cmic_fifo_rd_dma_cfg_1[0] = 0
#define CMIC_FIFO_RD_DMA_CFG_1r_SET(r,d) (r).cmic_fifo_rd_dma_cfg_1[0] = d
#define CMIC_FIFO_RD_DMA_CFG_1r_GET(r) (r).cmic_fifo_rd_dma_cfg_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_CFG_1r_IGNORE_SBUS_EARLYACKf_GET(r) (((r).cmic_fifo_rd_dma_cfg_1[0]) & 0x1)
#define CMIC_FIFO_RD_DMA_CFG_1r_IGNORE_SBUS_EARLYACKf_SET(r,f) (r).cmic_fifo_rd_dma_cfg_1[0]=(((r).cmic_fifo_rd_dma_cfg_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_FIFO_RD_DMA_CFG_1r_MULTIPLE_SBUS_CMD_SPACING_MSB_BITSf_GET(r) ((((r).cmic_fifo_rd_dma_cfg_1[0]) >> 1) & 0x7)
#define CMIC_FIFO_RD_DMA_CFG_1r_MULTIPLE_SBUS_CMD_SPACING_MSB_BITSf_SET(r,f) (r).cmic_fifo_rd_dma_cfg_1[0]=(((r).cmic_fifo_rd_dma_cfg_1[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define CMIC_FIFO_RD_DMA_CFG_1r_TIMEOUT_COUNT_MSB_BITSf_GET(r) ((((r).cmic_fifo_rd_dma_cfg_1[0]) >> 4) & 0x3ffff)
#define CMIC_FIFO_RD_DMA_CFG_1r_TIMEOUT_COUNT_MSB_BITSf_SET(r,f) (r).cmic_fifo_rd_dma_cfg_1[0]=(((r).cmic_fifo_rd_dma_cfg_1[0] & ~((uint32_t)0x3ffff << 4)) | ((((uint32_t)f) & 0x3ffff) << 4))

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_CFG_1.
 */
#define READ_CMIC_FIFO_RD_DMA_CFG_1r(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_CFG_1r_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_cfg_1)
#define WRITE_CMIC_FIFO_RD_DMA_CFG_1r(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_CFG_1r_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_cfg_1)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_CFG_1r'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr_OFFSET 0x00011048

#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HI.
 */
typedef union CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_cur_hostmem_write_ptr_hi[1];
    uint32_t _cmic_fifo_rd_dma_cur_hostmem_write_ptr_hi;
} CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr_t;

#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr_CLR(r) (r).cmic_fifo_rd_dma_cur_hostmem_write_ptr_hi[0] = 0
#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr_SET(r,d) (r).cmic_fifo_rd_dma_cur_hostmem_write_ptr_hi[0] = d
#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr_GET(r) (r).cmic_fifo_rd_dma_cur_hostmem_write_ptr_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr_ADDRESSf_GET(r) ((r).cmic_fifo_rd_dma_cur_hostmem_write_ptr_hi[0])
#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr_ADDRESSf_SET(r,f) (r).cmic_fifo_rd_dma_cur_hostmem_write_ptr_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HI.
 */
#define READ_CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_cur_hostmem_write_ptr_hi)
#define WRITE_CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_cur_hostmem_write_ptr_hi)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr_OFFSET 0x00011044

#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LO.
 */
typedef union CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_cur_hostmem_write_ptr_lo[1];
    uint32_t _cmic_fifo_rd_dma_cur_hostmem_write_ptr_lo;
} CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr_t;

#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr_CLR(r) (r).cmic_fifo_rd_dma_cur_hostmem_write_ptr_lo[0] = 0
#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr_SET(r,d) (r).cmic_fifo_rd_dma_cur_hostmem_write_ptr_lo[0] = d
#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr_GET(r) (r).cmic_fifo_rd_dma_cur_hostmem_write_ptr_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr_ADDRESSf_GET(r) ((r).cmic_fifo_rd_dma_cur_hostmem_write_ptr_lo[0])
#define CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr_ADDRESSf_SET(r,f) (r).cmic_fifo_rd_dma_cur_hostmem_write_ptr_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LO.
 */
#define READ_CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_cur_hostmem_write_ptr_lo)
#define WRITE_CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_cur_hostmem_write_ptr_lo)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_CUR_HOSTMEM_WRITE_PTR_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr_OFFSET 0x00011030

#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HI.
 */
typedef union CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_eccerr_address_hi[1];
    uint32_t _cmic_fifo_rd_dma_eccerr_address_hi;
} CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr_t;

#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr_CLR(r) (r).cmic_fifo_rd_dma_eccerr_address_hi[0] = 0
#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr_SET(r,d) (r).cmic_fifo_rd_dma_eccerr_address_hi[0] = d
#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr_GET(r) (r).cmic_fifo_rd_dma_eccerr_address_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr_ADDRESSf_GET(r) ((r).cmic_fifo_rd_dma_eccerr_address_hi[0])
#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr_ADDRESSf_SET(r,f) (r).cmic_fifo_rd_dma_eccerr_address_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HI.
 */
#define READ_CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_eccerr_address_hi)
#define WRITE_CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_eccerr_address_hi)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr_OFFSET 0x0001102c

#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LO.
 */
typedef union CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_eccerr_address_lo[1];
    uint32_t _cmic_fifo_rd_dma_eccerr_address_lo;
} CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr_t;

#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr_CLR(r) (r).cmic_fifo_rd_dma_eccerr_address_lo[0] = 0
#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr_SET(r,d) (r).cmic_fifo_rd_dma_eccerr_address_lo[0] = d
#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr_GET(r) (r).cmic_fifo_rd_dma_eccerr_address_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr_ADDRESSf_GET(r) ((r).cmic_fifo_rd_dma_eccerr_address_lo[0])
#define CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr_ADDRESSf_SET(r,f) (r).cmic_fifo_rd_dma_eccerr_address_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LO.
 */
#define READ_CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_eccerr_address_lo)
#define WRITE_CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_eccerr_address_lo)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_ECCERR_ADDRESS_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_ECC_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_ECC_CONTROLr_OFFSET 0x00011034

#define CMIC_FIFO_RD_DMA_ECC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_ECC_CONTROL.
 */
typedef union CMIC_FIFO_RD_DMA_ECC_CONTROLr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_ecc_control[1];
    uint32_t _cmic_fifo_rd_dma_ecc_control;
} CMIC_FIFO_RD_DMA_ECC_CONTROLr_t;

#define CMIC_FIFO_RD_DMA_ECC_CONTROLr_CLR(r) (r).cmic_fifo_rd_dma_ecc_control[0] = 0
#define CMIC_FIFO_RD_DMA_ECC_CONTROLr_SET(r,d) (r).cmic_fifo_rd_dma_ecc_control[0] = d
#define CMIC_FIFO_RD_DMA_ECC_CONTROLr_GET(r) (r).cmic_fifo_rd_dma_ecc_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_ECC_CONTROLr_INJECT_1BIT_ERR_IN_HOSTRD_MEMf_GET(r) (((r).cmic_fifo_rd_dma_ecc_control[0]) & 0x1)
#define CMIC_FIFO_RD_DMA_ECC_CONTROLr_INJECT_1BIT_ERR_IN_HOSTRD_MEMf_SET(r,f) (r).cmic_fifo_rd_dma_ecc_control[0]=(((r).cmic_fifo_rd_dma_ecc_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_FIFO_RD_DMA_ECC_CONTROLr_INJECT_2BIT_ERR_IN_HOSTRD_MEMf_GET(r) ((((r).cmic_fifo_rd_dma_ecc_control[0]) >> 1) & 0x1)
#define CMIC_FIFO_RD_DMA_ECC_CONTROLr_INJECT_2BIT_ERR_IN_HOSTRD_MEMf_SET(r,f) (r).cmic_fifo_rd_dma_ecc_control[0]=(((r).cmic_fifo_rd_dma_ecc_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_FIFO_RD_DMA_ECC_CONTROLr_DISABLE_ECC_LOGIC_HOSTRD_MEMf_GET(r) ((((r).cmic_fifo_rd_dma_ecc_control[0]) >> 2) & 0x1)
#define CMIC_FIFO_RD_DMA_ECC_CONTROLr_DISABLE_ECC_LOGIC_HOSTRD_MEMf_SET(r,f) (r).cmic_fifo_rd_dma_ecc_control[0]=(((r).cmic_fifo_rd_dma_ecc_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_ECC_CONTROL.
 */
#define READ_CMIC_FIFO_RD_DMA_ECC_CONTROLr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_ECC_CONTROLr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_ecc_control)
#define WRITE_CMIC_FIFO_RD_DMA_ECC_CONTROLr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_ECC_CONTROLr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_ecc_control)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_ECC_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_ECC_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_ECC_STATUSr_OFFSET 0x00011038

#define CMIC_FIFO_RD_DMA_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_ECC_STATUS.
 */
typedef union CMIC_FIFO_RD_DMA_ECC_STATUSr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_ecc_status[1];
    uint32_t _cmic_fifo_rd_dma_ecc_status;
} CMIC_FIFO_RD_DMA_ECC_STATUSr_t;

#define CMIC_FIFO_RD_DMA_ECC_STATUSr_CLR(r) (r).cmic_fifo_rd_dma_ecc_status[0] = 0
#define CMIC_FIFO_RD_DMA_ECC_STATUSr_SET(r,d) (r).cmic_fifo_rd_dma_ecc_status[0] = d
#define CMIC_FIFO_RD_DMA_ECC_STATUSr_GET(r) (r).cmic_fifo_rd_dma_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_ECC_STATUSr_SINGLE_BIT_ERR_DETECTED_IN_HOSTRD_MEMf_GET(r) (((r).cmic_fifo_rd_dma_ecc_status[0]) & 0x1)
#define CMIC_FIFO_RD_DMA_ECC_STATUSr_SINGLE_BIT_ERR_DETECTED_IN_HOSTRD_MEMf_SET(r,f) (r).cmic_fifo_rd_dma_ecc_status[0]=(((r).cmic_fifo_rd_dma_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_FIFO_RD_DMA_ECC_STATUSr_DOUBLE_BIT_ERR_DETECTED_IN_HOSTRD_MEMf_GET(r) ((((r).cmic_fifo_rd_dma_ecc_status[0]) >> 1) & 0x1)
#define CMIC_FIFO_RD_DMA_ECC_STATUSr_DOUBLE_BIT_ERR_DETECTED_IN_HOSTRD_MEMf_SET(r,f) (r).cmic_fifo_rd_dma_ecc_status[0]=(((r).cmic_fifo_rd_dma_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_FIFO_RD_DMA_ECC_STATUSr_MULTIPLE_ERR_DETECTED_IN_HOSTRD_MEMf_GET(r) ((((r).cmic_fifo_rd_dma_ecc_status[0]) >> 2) & 0x1)
#define CMIC_FIFO_RD_DMA_ECC_STATUSr_MULTIPLE_ERR_DETECTED_IN_HOSTRD_MEMf_SET(r,f) (r).cmic_fifo_rd_dma_ecc_status[0]=(((r).cmic_fifo_rd_dma_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_FIFO_RD_DMA_ECC_STATUSr_FIRST_ERR_ADDRESS_OF_HOSTRD_MEMf_GET(r) ((((r).cmic_fifo_rd_dma_ecc_status[0]) >> 9) & 0xf)
#define CMIC_FIFO_RD_DMA_ECC_STATUSr_FIRST_ERR_ADDRESS_OF_HOSTRD_MEMf_SET(r,f) (r).cmic_fifo_rd_dma_ecc_status[0]=(((r).cmic_fifo_rd_dma_ecc_status[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_ECC_STATUS.
 */
#define READ_CMIC_FIFO_RD_DMA_ECC_STATUSr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_ECC_STATUSr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_ecc_status)
#define WRITE_CMIC_FIFO_RD_DMA_ECC_STATUSr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_ECC_STATUSr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_ecc_status)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_ECC_STATUS_CLR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr_OFFSET 0x0001103c

#define CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_ECC_STATUS_CLR.
 */
typedef union CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_ecc_status_clr[1];
    uint32_t _cmic_fifo_rd_dma_ecc_status_clr;
} CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr_t;

#define CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr_CLR(r) (r).cmic_fifo_rd_dma_ecc_status_clr[0] = 0
#define CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr_SET(r,d) (r).cmic_fifo_rd_dma_ecc_status_clr[0] = d
#define CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr_GET(r) (r).cmic_fifo_rd_dma_ecc_status_clr[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr_CLEAR_HOSTRD_MEMf_GET(r) (((r).cmic_fifo_rd_dma_ecc_status_clr[0]) & 0x1)
#define CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr_CLEAR_HOSTRD_MEMf_SET(r,f) (r).cmic_fifo_rd_dma_ecc_status_clr[0]=(((r).cmic_fifo_rd_dma_ecc_status_clr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_ECC_STATUS_CLR.
 */
#define READ_CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_ecc_status_clr)
#define WRITE_CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_ecc_status_clr)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_ECC_STATUS_CLRr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HI
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr_OFFSET 0x00011010

#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HI.
 */
typedef union CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_hostmem_start_address_hi[1];
    uint32_t _cmic_fifo_rd_dma_hostmem_start_address_hi;
} CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr_t;

#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr_CLR(r) (r).cmic_fifo_rd_dma_hostmem_start_address_hi[0] = 0
#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr_SET(r,d) (r).cmic_fifo_rd_dma_hostmem_start_address_hi[0] = d
#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr_GET(r) (r).cmic_fifo_rd_dma_hostmem_start_address_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr_ADDRESSf_GET(r) ((r).cmic_fifo_rd_dma_hostmem_start_address_hi[0])
#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr_ADDRESSf_SET(r,f) (r).cmic_fifo_rd_dma_hostmem_start_address_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HI.
 */
#define READ_CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_hostmem_start_address_hi)
#define WRITE_CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_hostmem_start_address_hi)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_HIr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr_OFFSET 0x0001100c

#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LO.
 */
typedef union CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_hostmem_start_address_lo[1];
    uint32_t _cmic_fifo_rd_dma_hostmem_start_address_lo;
} CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr_t;

#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr_CLR(r) (r).cmic_fifo_rd_dma_hostmem_start_address_lo[0] = 0
#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr_SET(r,d) (r).cmic_fifo_rd_dma_hostmem_start_address_lo[0] = d
#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr_GET(r) (r).cmic_fifo_rd_dma_hostmem_start_address_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr_ADDRESSf_GET(r) ((r).cmic_fifo_rd_dma_hostmem_start_address_lo[0])
#define CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr_ADDRESSf_SET(r,f) (r).cmic_fifo_rd_dma_hostmem_start_address_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LO.
 */
#define READ_CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_hostmem_start_address_lo)
#define WRITE_CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_hostmem_start_address_lo)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_HOSTMEM_START_ADDRESS_LOr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLD
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr_OFFSET 0x0001101c

#define CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLD.
 */
typedef union CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_hostmem_threshold[1];
    uint32_t _cmic_fifo_rd_dma_hostmem_threshold;
} CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr_t;

#define CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr_CLR(r) (r).cmic_fifo_rd_dma_hostmem_threshold[0] = 0
#define CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr_SET(r,d) (r).cmic_fifo_rd_dma_hostmem_threshold[0] = d
#define CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr_GET(r) (r).cmic_fifo_rd_dma_hostmem_threshold[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr_THRESHOLDf_GET(r) ((r).cmic_fifo_rd_dma_hostmem_threshold[0])
#define CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr_THRESHOLDf_SET(r,f) (r).cmic_fifo_rd_dma_hostmem_threshold[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLD.
 */
#define READ_CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_hostmem_threshold)
#define WRITE_CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_hostmem_threshold)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_HOSTMEM_THRESHOLDr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEM
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_OFFSET 0x00011014

#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEM.
 */
typedef union CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem[1];
    uint32_t _cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem;
} CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_t;

#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_CLR(r) (r).cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem[0] = 0
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_SET(r,d) (r).cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem[0] = d
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_GET(r) (r).cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_ENTRYCOUNTf_GET(r) (((r).cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem[0]) & 0x1ffff)
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_ENTRYCOUNTf_SET(r,f) (r).cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem[0]=(((r).cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_WR_NUMBER_OF_ENTRIESf_GET(r) ((((r).cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem[0]) >> 17) & 0x1)
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_WR_NUMBER_OF_ENTRIESf_SET(r,f) (r).cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem[0]=(((r).cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEM.
 */
#define READ_CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem)
#define WRITE_CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_num_of_entries_read_frm_hostmem)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_READ_FRM_HOSTMEMr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEM
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr_OFFSET 0x00011018

#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEM.
 */
typedef union CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_num_of_entries_valid_in_hostmem[1];
    uint32_t _cmic_fifo_rd_dma_num_of_entries_valid_in_hostmem;
} CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr_t;

#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr_CLR(r) (r).cmic_fifo_rd_dma_num_of_entries_valid_in_hostmem[0] = 0
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr_SET(r,d) (r).cmic_fifo_rd_dma_num_of_entries_valid_in_hostmem[0] = d
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr_GET(r) (r).cmic_fifo_rd_dma_num_of_entries_valid_in_hostmem[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr_ENTRYCOUNTf_GET(r) (((r).cmic_fifo_rd_dma_num_of_entries_valid_in_hostmem[0]) & 0x1ffff)
#define CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr_ENTRYCOUNTf_SET(r,f) (r).cmic_fifo_rd_dma_num_of_entries_valid_in_hostmem[0]=(((r).cmic_fifo_rd_dma_num_of_entries_valid_in_hostmem[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEM.
 */
#define READ_CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_num_of_entries_valid_in_hostmem)
#define WRITE_CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_num_of_entries_valid_in_hostmem)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_NUM_OF_ENTRIES_VALID_IN_HOSTMEMr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_OPCODE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_OPCODEr_OFFSET 0x00011028

#define CMIC_FIFO_RD_DMA_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_OPCODE.
 */
typedef union CMIC_FIFO_RD_DMA_OPCODEr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_opcode[1];
    uint32_t _cmic_fifo_rd_dma_opcode;
} CMIC_FIFO_RD_DMA_OPCODEr_t;

#define CMIC_FIFO_RD_DMA_OPCODEr_CLR(r) (r).cmic_fifo_rd_dma_opcode[0] = 0
#define CMIC_FIFO_RD_DMA_OPCODEr_SET(r,d) (r).cmic_fifo_rd_dma_opcode[0] = d
#define CMIC_FIFO_RD_DMA_OPCODEr_GET(r) (r).cmic_fifo_rd_dma_opcode[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_OPCODEr_OPCODEf_GET(r) ((r).cmic_fifo_rd_dma_opcode[0])
#define CMIC_FIFO_RD_DMA_OPCODEr_OPCODEf_SET(r,f) (r).cmic_fifo_rd_dma_opcode[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_OPCODE.
 */
#define READ_CMIC_FIFO_RD_DMA_OPCODEr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_OPCODEr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_opcode)
#define WRITE_CMIC_FIFO_RD_DMA_OPCODEr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_OPCODEr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_opcode)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_OPCODEr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_SBUS_START_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr_OFFSET 0x00011008

#define CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_SBUS_START_ADDRESS.
 */
typedef union CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_sbus_start_address[1];
    uint32_t _cmic_fifo_rd_dma_sbus_start_address;
} CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr_t;

#define CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr_CLR(r) (r).cmic_fifo_rd_dma_sbus_start_address[0] = 0
#define CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr_SET(r,d) (r).cmic_fifo_rd_dma_sbus_start_address[0] = d
#define CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr_GET(r) (r).cmic_fifo_rd_dma_sbus_start_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr_ADDRESSf_GET(r) ((r).cmic_fifo_rd_dma_sbus_start_address[0])
#define CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr_ADDRESSf_SET(r,f) (r).cmic_fifo_rd_dma_sbus_start_address[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_SBUS_START_ADDRESS.
 */
#define READ_CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_sbus_start_address)
#define WRITE_CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_sbus_start_address)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_SBUS_START_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_STAT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_STATr_OFFSET 0x00011020

#define CMIC_FIFO_RD_DMA_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_STAT.
 */
typedef union CMIC_FIFO_RD_DMA_STATr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_stat[1];
    uint32_t _cmic_fifo_rd_dma_stat;
} CMIC_FIFO_RD_DMA_STATr_t;

#define CMIC_FIFO_RD_DMA_STATr_CLR(r) (r).cmic_fifo_rd_dma_stat[0] = 0
#define CMIC_FIFO_RD_DMA_STATr_SET(r,d) (r).cmic_fifo_rd_dma_stat[0] = d
#define CMIC_FIFO_RD_DMA_STATr_GET(r) (r).cmic_fifo_rd_dma_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_STATr_ERRORf_GET(r) (((r).cmic_fifo_rd_dma_stat[0]) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_ERRORf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_FIFO_RD_DMA_STATr_ACTIVEf_GET(r) ((((r).cmic_fifo_rd_dma_stat[0]) >> 1) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_ACTIVEf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_FIFO_RD_DMA_STATr_HOSTMEM_OVERFLOWf_GET(r) ((((r).cmic_fifo_rd_dma_stat[0]) >> 2) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_HOSTMEM_OVERFLOWf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_FIFO_RD_DMA_STATr_HOSTMEM_TIMEOUTf_GET(r) ((((r).cmic_fifo_rd_dma_stat[0]) >> 3) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_HOSTMEM_TIMEOUTf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_FIFO_RD_DMA_STATr_ABORTEDf_GET(r) ((((r).cmic_fifo_rd_dma_stat[0]) >> 4) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_ABORTEDf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_FIFO_RD_DMA_STATr_HOSTMEMWR_ERRORf_GET(r) ((((r).cmic_fifo_rd_dma_stat[0]) >> 5) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_HOSTMEMWR_ERRORf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_FIFO_RD_DMA_STATr_SBUSACK_WRONG_BEATCOUNTf_GET(r) ((((r).cmic_fifo_rd_dma_stat[0]) >> 6) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_SBUSACK_WRONG_BEATCOUNTf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_FIFO_RD_DMA_STATr_SBUSACK_WRONG_OPCODEf_GET(r) ((((r).cmic_fifo_rd_dma_stat[0]) >> 7) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_SBUSACK_WRONG_OPCODEf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_FIFO_RD_DMA_STATr_SBUSACK_NACKf_GET(r) ((((r).cmic_fifo_rd_dma_stat[0]) >> 8) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_SBUSACK_NACKf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_FIFO_RD_DMA_STATr_SBUSACK_ERRORf_GET(r) ((((r).cmic_fifo_rd_dma_stat[0]) >> 9) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_SBUSACK_ERRORf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_FIFO_RD_DMA_STATr_SBUSACK_TIMEOUTf_GET(r) ((((r).cmic_fifo_rd_dma_stat[0]) >> 10) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_SBUSACK_TIMEOUTf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_FIFO_RD_DMA_STATr_ECC_2BIT_CHECK_FAILf_GET(r) ((((r).cmic_fifo_rd_dma_stat[0]) >> 11) & 0x1)
#define CMIC_FIFO_RD_DMA_STATr_ECC_2BIT_CHECK_FAILf_SET(r,f) (r).cmic_fifo_rd_dma_stat[0]=(((r).cmic_fifo_rd_dma_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_STAT.
 */
#define READ_CMIC_FIFO_RD_DMA_STATr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_STATr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_stat)
#define WRITE_CMIC_FIFO_RD_DMA_STATr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_STATr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_stat)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_STATr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_STAT_CLR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_STAT_CLRr_OFFSET 0x00011024

#define CMIC_FIFO_RD_DMA_STAT_CLRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_STAT_CLR.
 */
typedef union CMIC_FIFO_RD_DMA_STAT_CLRr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_stat_clr[1];
    uint32_t _cmic_fifo_rd_dma_stat_clr;
} CMIC_FIFO_RD_DMA_STAT_CLRr_t;

#define CMIC_FIFO_RD_DMA_STAT_CLRr_CLR(r) (r).cmic_fifo_rd_dma_stat_clr[0] = 0
#define CMIC_FIFO_RD_DMA_STAT_CLRr_SET(r,d) (r).cmic_fifo_rd_dma_stat_clr[0] = d
#define CMIC_FIFO_RD_DMA_STAT_CLRr_GET(r) (r).cmic_fifo_rd_dma_stat_clr[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_STAT_CLRr_HOSTMEM_OVERFLOWf_GET(r) (((r).cmic_fifo_rd_dma_stat_clr[0]) & 0x1)
#define CMIC_FIFO_RD_DMA_STAT_CLRr_HOSTMEM_OVERFLOWf_SET(r,f) (r).cmic_fifo_rd_dma_stat_clr[0]=(((r).cmic_fifo_rd_dma_stat_clr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_FIFO_RD_DMA_STAT_CLRr_HOSTMEM_TIMEOUTf_GET(r) ((((r).cmic_fifo_rd_dma_stat_clr[0]) >> 1) & 0x1)
#define CMIC_FIFO_RD_DMA_STAT_CLRr_HOSTMEM_TIMEOUTf_SET(r,f) (r).cmic_fifo_rd_dma_stat_clr[0]=(((r).cmic_fifo_rd_dma_stat_clr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_FIFO_RD_DMA_STAT_CLRr_ECC_2BIT_CHECK_FAILf_GET(r) ((((r).cmic_fifo_rd_dma_stat_clr[0]) >> 2) & 0x1)
#define CMIC_FIFO_RD_DMA_STAT_CLRr_ECC_2BIT_CHECK_FAILf_SET(r,f) (r).cmic_fifo_rd_dma_stat_clr[0]=(((r).cmic_fifo_rd_dma_stat_clr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_STAT_CLR.
 */
#define READ_CMIC_FIFO_RD_DMA_STAT_CLRr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_STAT_CLRr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_stat_clr)
#define WRITE_CMIC_FIFO_RD_DMA_STAT_CLRr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_STAT_CLRr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_stat_clr)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_STAT_CLRr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_FIFO_RD_DMA_TM_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_FIFO_RD_DMA_TM_CONTROLr_OFFSET 0x00011040

#define CMIC_FIFO_RD_DMA_TM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_FIFO_RD_DMA_TM_CONTROL.
 */
typedef union CMIC_FIFO_RD_DMA_TM_CONTROLr_s {
    uint32_t v[1];
    uint32_t cmic_fifo_rd_dma_tm_control[1];
    uint32_t _cmic_fifo_rd_dma_tm_control;
} CMIC_FIFO_RD_DMA_TM_CONTROLr_t;

#define CMIC_FIFO_RD_DMA_TM_CONTROLr_CLR(r) (r).cmic_fifo_rd_dma_tm_control[0] = 0
#define CMIC_FIFO_RD_DMA_TM_CONTROLr_SET(r,d) (r).cmic_fifo_rd_dma_tm_control[0] = d
#define CMIC_FIFO_RD_DMA_TM_CONTROLr_GET(r) (r).cmic_fifo_rd_dma_tm_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_FIFO_RD_DMA_TM_CONTROLr_TM_HOSTRD_MEMf_GET(r) (((r).cmic_fifo_rd_dma_tm_control[0]) & 0x1f)
#define CMIC_FIFO_RD_DMA_TM_CONTROLr_TM_HOSTRD_MEMf_SET(r,f) (r).cmic_fifo_rd_dma_tm_control[0]=(((r).cmic_fifo_rd_dma_tm_control[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access CMIC_FIFO_RD_DMA_TM_CONTROL.
 */
#define READ_CMIC_FIFO_RD_DMA_TM_CONTROLr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_FIFO_RD_DMA_TM_CONTROLr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_tm_control)
#define WRITE_CMIC_FIFO_RD_DMA_TM_CONTROLr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_FIFO_RD_DMA_TM_CONTROLr_OFFSET+(0x80*(_ch)),r._cmic_fifo_rd_dma_tm_control)

/*******************************************************************************
 * End of 'CMIC_FIFO_RD_DMA_TM_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_SCHANFIFO_COMMAND_MEMORY
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_SCHANFIFO_COMMAND_MEMORYr_OFFSET 0x00012100

#define CMIC_SCHANFIFO_COMMAND_MEMORYr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHANFIFO_COMMAND_MEMORY.
 */
typedef union CMIC_SCHANFIFO_COMMAND_MEMORYr_s {
    uint32_t v[1];
    uint32_t cmic_schanfifo_command_memory[1];
    uint32_t _cmic_schanfifo_command_memory;
} CMIC_SCHANFIFO_COMMAND_MEMORYr_t;

#define CMIC_SCHANFIFO_COMMAND_MEMORYr_CLR(r) (r).cmic_schanfifo_command_memory[0] = 0
#define CMIC_SCHANFIFO_COMMAND_MEMORYr_SET(r,d) (r).cmic_schanfifo_command_memory[0] = d
#define CMIC_SCHANFIFO_COMMAND_MEMORYr_GET(r) (r).cmic_schanfifo_command_memory[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SCHANFIFO_COMMAND_MEMORYr_OPCODE_OR_ADDR_OR_DATAf_GET(r) ((r).cmic_schanfifo_command_memory[0])
#define CMIC_SCHANFIFO_COMMAND_MEMORYr_OPCODE_OR_ADDR_OR_DATAf_SET(r,f) (r).cmic_schanfifo_command_memory[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHANFIFO_COMMAND_MEMORY.
 */
#define READ_CMIC_SCHANFIFO_COMMAND_MEMORYr(u,_ch,i,r) BCMDRD_DEV_READ32(u,CMIC_SCHANFIFO_COMMAND_MEMORYr_OFFSET+(4*(i))+(0x580*(_ch)),r._cmic_schanfifo_command_memory)
#define WRITE_CMIC_SCHANFIFO_COMMAND_MEMORYr(u,_ch,i,r) BCMDRD_DEV_WRITE32(u,CMIC_SCHANFIFO_COMMAND_MEMORYr_OFFSET+(4*(i))+(0x580*(_ch)),r._cmic_schanfifo_command_memory)

/*******************************************************************************
 * End of 'CMIC_SCHANFIFO_COMMAND_MEMORYr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_SCHANFIFO_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_SCHANFIFO_CTRLr_OFFSET 0x0001200c

#define CMIC_SCHANFIFO_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHANFIFO_CTRL.
 */
typedef union CMIC_SCHANFIFO_CTRLr_s {
    uint32_t v[1];
    uint32_t cmic_schanfifo_ctrl[1];
    uint32_t _cmic_schanfifo_ctrl;
} CMIC_SCHANFIFO_CTRLr_t;

#define CMIC_SCHANFIFO_CTRLr_CLR(r) (r).cmic_schanfifo_ctrl[0] = 0
#define CMIC_SCHANFIFO_CTRLr_SET(r,d) (r).cmic_schanfifo_ctrl[0] = d
#define CMIC_SCHANFIFO_CTRLr_GET(r) (r).cmic_schanfifo_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SCHANFIFO_CTRLr_STARTf_GET(r) (((r).cmic_schanfifo_ctrl[0]) & 0x1)
#define CMIC_SCHANFIFO_CTRLr_STARTf_SET(r,f) (r).cmic_schanfifo_ctrl[0]=(((r).cmic_schanfifo_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_SCHANFIFO_CTRLr_ABORTf_GET(r) ((((r).cmic_schanfifo_ctrl[0]) >> 1) & 0x1)
#define CMIC_SCHANFIFO_CTRLr_ABORTf_SET(r,f) (r).cmic_schanfifo_ctrl[0]=(((r).cmic_schanfifo_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_SCHANFIFO_CTRLr_NUMB_OF_COMMANDSf_GET(r) ((((r).cmic_schanfifo_ctrl[0]) >> 2) & 0xff)
#define CMIC_SCHANFIFO_CTRLr_NUMB_OF_COMMANDSf_SET(r,f) (r).cmic_schanfifo_ctrl[0]=(((r).cmic_schanfifo_ctrl[0] & ~((uint32_t)0xff << 2)) | ((((uint32_t)f) & 0xff) << 2))
#define CMIC_SCHANFIFO_CTRLr_RESPONSE_ENDIANESSf_GET(r) ((((r).cmic_schanfifo_ctrl[0]) >> 10) & 0x1)
#define CMIC_SCHANFIFO_CTRLr_RESPONSE_ENDIANESSf_SET(r,f) (r).cmic_schanfifo_ctrl[0]=(((r).cmic_schanfifo_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_SCHANFIFO_CTRLr_SUMMARY_ENDIANESSf_GET(r) ((((r).cmic_schanfifo_ctrl[0]) >> 11) & 0x1)
#define CMIC_SCHANFIFO_CTRLr_SUMMARY_ENDIANESSf_SET(r,f) (r).cmic_schanfifo_ctrl[0]=(((r).cmic_schanfifo_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_SCHANFIFO_CTRLr_AXI_IDf_GET(r) ((((r).cmic_schanfifo_ctrl[0]) >> 12) & 0x7)
#define CMIC_SCHANFIFO_CTRLr_AXI_IDf_SET(r,f) (r).cmic_schanfifo_ctrl[0]=(((r).cmic_schanfifo_ctrl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define CMIC_SCHANFIFO_CTRLr_RESPONSE_WRITE_DISABLEf_GET(r) ((((r).cmic_schanfifo_ctrl[0]) >> 15) & 0x1)
#define CMIC_SCHANFIFO_CTRLr_RESPONSE_WRITE_DISABLEf_SET(r,f) (r).cmic_schanfifo_ctrl[0]=(((r).cmic_schanfifo_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_SCHANFIFO_CTRLr_SUMMARY_UPDATE_INTERVALf_GET(r) ((((r).cmic_schanfifo_ctrl[0]) >> 16) & 0x1f)
#define CMIC_SCHANFIFO_CTRLr_SUMMARY_UPDATE_INTERVALf_SET(r,f) (r).cmic_schanfifo_ctrl[0]=(((r).cmic_schanfifo_ctrl[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define CMIC_SCHANFIFO_CTRLr_ENABLE_RESP_MEM_ECCERR_BASED_ABORTf_GET(r) ((((r).cmic_schanfifo_ctrl[0]) >> 21) & 0x1)
#define CMIC_SCHANFIFO_CTRLr_ENABLE_RESP_MEM_ECCERR_BASED_ABORTf_SET(r,f) (r).cmic_schanfifo_ctrl[0]=(((r).cmic_schanfifo_ctrl[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_SCHANFIFO_CTRLr_DISABLE_SBUS_ERR_BASED_ABORTf_GET(r) ((((r).cmic_schanfifo_ctrl[0]) >> 22) & 0x1)
#define CMIC_SCHANFIFO_CTRLr_DISABLE_SBUS_ERR_BASED_ABORTf_SET(r,f) (r).cmic_schanfifo_ctrl[0]=(((r).cmic_schanfifo_ctrl[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))

/*
 * These macros can be used to access CMIC_SCHANFIFO_CTRL.
 */
#define READ_CMIC_SCHANFIFO_CTRLr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_SCHANFIFO_CTRLr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_ctrl)
#define WRITE_CMIC_SCHANFIFO_CTRLr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_SCHANFIFO_CTRLr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_ctrl)

/*******************************************************************************
 * End of 'CMIC_SCHANFIFO_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWER
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr_OFFSET 0x00012014

#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWER.
 */
typedef union CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr_s {
    uint32_t v[1];
    uint32_t cmic_schanfifo_resp_hostmem_start_addr_lower[1];
    uint32_t _cmic_schanfifo_resp_hostmem_start_addr_lower;
} CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr_t;

#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr_CLR(r) (r).cmic_schanfifo_resp_hostmem_start_addr_lower[0] = 0
#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr_SET(r,d) (r).cmic_schanfifo_resp_hostmem_start_addr_lower[0] = d
#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr_GET(r) (r).cmic_schanfifo_resp_hostmem_start_addr_lower[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr_ADDRf_GET(r) ((r).cmic_schanfifo_resp_hostmem_start_addr_lower[0])
#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr_ADDRf_SET(r,f) (r).cmic_schanfifo_resp_hostmem_start_addr_lower[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWER.
 */
#define READ_CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_resp_hostmem_start_addr_lower)
#define WRITE_CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_resp_hostmem_start_addr_lower)

/*******************************************************************************
 * End of 'CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_LOWERr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPER
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr_OFFSET 0x00012010

#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPER.
 */
typedef union CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr_s {
    uint32_t v[1];
    uint32_t cmic_schanfifo_resp_hostmem_start_addr_upper[1];
    uint32_t _cmic_schanfifo_resp_hostmem_start_addr_upper;
} CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr_t;

#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr_CLR(r) (r).cmic_schanfifo_resp_hostmem_start_addr_upper[0] = 0
#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr_SET(r,d) (r).cmic_schanfifo_resp_hostmem_start_addr_upper[0] = d
#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr_GET(r) (r).cmic_schanfifo_resp_hostmem_start_addr_upper[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr_ADDRf_GET(r) ((r).cmic_schanfifo_resp_hostmem_start_addr_upper[0])
#define CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr_ADDRf_SET(r,f) (r).cmic_schanfifo_resp_hostmem_start_addr_upper[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPER.
 */
#define READ_CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_resp_hostmem_start_addr_upper)
#define WRITE_CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_resp_hostmem_start_addr_upper)

/*******************************************************************************
 * End of 'CMIC_SCHANFIFO_RESP_HOSTMEM_START_ADDR_UPPERr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_SCHANFIFO_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_SCHANFIFO_STATUSr_OFFSET 0x00012020

#define CMIC_SCHANFIFO_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHANFIFO_STATUS.
 */
typedef union CMIC_SCHANFIFO_STATUSr_s {
    uint32_t v[1];
    uint32_t cmic_schanfifo_status[1];
    uint32_t _cmic_schanfifo_status;
} CMIC_SCHANFIFO_STATUSr_t;

#define CMIC_SCHANFIFO_STATUSr_CLR(r) (r).cmic_schanfifo_status[0] = 0
#define CMIC_SCHANFIFO_STATUSr_SET(r,d) (r).cmic_schanfifo_status[0] = d
#define CMIC_SCHANFIFO_STATUSr_GET(r) (r).cmic_schanfifo_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SCHANFIFO_STATUSr_DONEf_GET(r) (((r).cmic_schanfifo_status[0]) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_DONEf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_SCHANFIFO_STATUSr_ERRORf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 1) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERRORf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_SCHANFIFO_STATUSr_ACTIVEf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 2) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ACTIVEf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_SCHANFIFO_STATUSr_CURR_SBUS_CMD_NUMf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 3) & 0xff)
#define CMIC_SCHANFIFO_STATUSr_CURR_SBUS_CMD_NUMf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_NACKf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 11) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_NACKf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_MESSAGE_ERRf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 12) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_MESSAGE_ERRf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_MESSAGE_ERR_CODEf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 13) & 0x3)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_MESSAGE_ERR_CODEf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_ACK_OPCODE_MISMATCHf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 15) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_ACK_OPCODE_MISMATCHf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_CMD_MEM_ECC_ERRf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 16) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_CMD_MEM_ECC_ERRf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_RESP_MEM_ECC_ERRf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 17) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_RESP_MEM_ECC_ERRf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_CMD_OPCODE_IS_INVALIDf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 18) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_CMD_OPCODE_IS_INVALIDf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_CMD_DLEN_IS_INVALIDf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 19) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_CMD_DLEN_IS_INVALIDf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_SBUS_TIMEOUTf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 20) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_SBUS_TIMEOUTf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_ACK_DATA_BEAT_GT20f_GET(r) ((((r).cmic_schanfifo_status[0]) >> 21) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_ACK_DATA_BEAT_GT20f_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_AXI_RESP_ERRf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 22) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_AXI_RESP_ERRf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_AXI_SLAVE_ABORTf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 23) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_AXI_SLAVE_ABORTf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_SW_ABORTf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 24) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_SW_ABORTf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_CMD_MEM_RD_ACCESS_INVALIDf_GET(r) ((((r).cmic_schanfifo_status[0]) >> 25) & 0x1)
#define CMIC_SCHANFIFO_STATUSr_ERR_TYPE_CMD_MEM_RD_ACCESS_INVALIDf_SET(r,f) (r).cmic_schanfifo_status[0]=(((r).cmic_schanfifo_status[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access CMIC_SCHANFIFO_STATUS.
 */
#define READ_CMIC_SCHANFIFO_STATUSr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_SCHANFIFO_STATUSr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_status)
#define WRITE_CMIC_SCHANFIFO_STATUSr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_SCHANFIFO_STATUSr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_status)

/*******************************************************************************
 * End of 'CMIC_SCHANFIFO_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWER
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr_OFFSET 0x0001201c

#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWER.
 */
typedef union CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr_s {
    uint32_t v[1];
    uint32_t cmic_schanfifo_summary_hostmem_start_addr_lower[1];
    uint32_t _cmic_schanfifo_summary_hostmem_start_addr_lower;
} CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr_t;

#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr_CLR(r) (r).cmic_schanfifo_summary_hostmem_start_addr_lower[0] = 0
#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr_SET(r,d) (r).cmic_schanfifo_summary_hostmem_start_addr_lower[0] = d
#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr_GET(r) (r).cmic_schanfifo_summary_hostmem_start_addr_lower[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr_ADDRf_GET(r) ((r).cmic_schanfifo_summary_hostmem_start_addr_lower[0])
#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr_ADDRf_SET(r,f) (r).cmic_schanfifo_summary_hostmem_start_addr_lower[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWER.
 */
#define READ_CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_summary_hostmem_start_addr_lower)
#define WRITE_CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_summary_hostmem_start_addr_lower)

/*******************************************************************************
 * End of 'CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_LOWERr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPER
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr_OFFSET 0x00012018

#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPER.
 */
typedef union CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr_s {
    uint32_t v[1];
    uint32_t cmic_schanfifo_summary_hostmem_start_addr_upper[1];
    uint32_t _cmic_schanfifo_summary_hostmem_start_addr_upper;
} CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr_t;

#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr_CLR(r) (r).cmic_schanfifo_summary_hostmem_start_addr_upper[0] = 0
#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr_SET(r,d) (r).cmic_schanfifo_summary_hostmem_start_addr_upper[0] = d
#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr_GET(r) (r).cmic_schanfifo_summary_hostmem_start_addr_upper[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr_ADDRf_GET(r) ((r).cmic_schanfifo_summary_hostmem_start_addr_upper[0])
#define CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr_ADDRf_SET(r,f) (r).cmic_schanfifo_summary_hostmem_start_addr_upper[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPER.
 */
#define READ_CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_summary_hostmem_start_addr_upper)
#define WRITE_CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr_OFFSET+(0x18*(_ch)),r._cmic_schanfifo_summary_hostmem_start_addr_upper)

/*******************************************************************************
 * End of 'CMIC_SCHANFIFO_SUMMARY_HOSTMEM_START_ADDR_UPPERr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_SCHAN_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_OFFSET 0x00010004

#define CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_ACK_DATA_BEAT_COUNT.
 */
typedef union CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_s {
    uint32_t v[1];
    uint32_t cmic_schan_ack_data_beat_count[1];
    uint32_t _cmic_schan_ack_data_beat_count;
} CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_t;

#define CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_schan_ack_data_beat_count[0] = 0
#define CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_schan_ack_data_beat_count[0] = d
#define CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_schan_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_schan_ack_data_beat_count[0]) & 0x1f)
#define CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_schan_ack_data_beat_count[0]=(((r).cmic_schan_ack_data_beat_count[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_schan_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_schan_ack_data_beat_count[0]=(((r).cmic_schan_ack_data_beat_count[0] & ~((uint32_t)0x7ffffff << 5)) | ((((uint32_t)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_SCHAN_ACK_DATA_BEAT_COUNT.
 */
#define READ_CMIC_SCHAN_ACK_DATA_BEAT_COUNTr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_OFFSET+(0x100*(_ch)),r._cmic_schan_ack_data_beat_count)
#define WRITE_CMIC_SCHAN_ACK_DATA_BEAT_COUNTr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_SCHAN_ACK_DATA_BEAT_COUNTr_OFFSET+(0x100*(_ch)),r._cmic_schan_ack_data_beat_count)

/*******************************************************************************
 * End of 'CMIC_SCHAN_ACK_DATA_BEAT_COUNTr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_SCHAN_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_SCHAN_CTRLr_OFFSET 0x00010000

#define CMIC_SCHAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_CTRL.
 */
typedef union CMIC_SCHAN_CTRLr_s {
    uint32_t v[1];
    uint32_t cmic_schan_ctrl[1];
    uint32_t _cmic_schan_ctrl;
} CMIC_SCHAN_CTRLr_t;

#define CMIC_SCHAN_CTRLr_CLR(r) (r).cmic_schan_ctrl[0] = 0
#define CMIC_SCHAN_CTRLr_SET(r,d) (r).cmic_schan_ctrl[0] = d
#define CMIC_SCHAN_CTRLr_GET(r) (r).cmic_schan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SCHAN_CTRLr_MSG_STARTf_GET(r) (((r).cmic_schan_ctrl[0]) & 0x1)
#define CMIC_SCHAN_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_SCHAN_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 1) & 0x1)
#define CMIC_SCHAN_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_SCHAN_CTRLr_ABORTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 2) & 0x1)
#define CMIC_SCHAN_CTRLr_ABORTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_SCHAN_CTRLr_SER_CHECK_FAILf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 20) & 0x1)
#define CMIC_SCHAN_CTRLr_SER_CHECK_FAILf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_SCHAN_CTRLr_NACKf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 21) & 0x1)
#define CMIC_SCHAN_CTRLr_NACKf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_SCHAN_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 22) & 0x1)
#define CMIC_SCHAN_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define CMIC_SCHAN_CTRLr_SCHAN_ERRORf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 23) & 0x1)
#define CMIC_SCHAN_CTRLr_SCHAN_ERRORf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))

/*
 * These macros can be used to access CMIC_SCHAN_CTRL.
 */
#define READ_CMIC_SCHAN_CTRLr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_SCHAN_CTRLr_OFFSET+(0x100*(_ch)),r._cmic_schan_ctrl)
#define WRITE_CMIC_SCHAN_CTRLr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_SCHAN_CTRLr_OFFSET+(0x100*(_ch)),r._cmic_schan_ctrl)

/*******************************************************************************
 * End of 'CMIC_SCHAN_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_SCHAN_ERR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_SCHAN_ERRr_OFFSET 0x00010008

#define CMIC_SCHAN_ERRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_ERR.
 */
typedef union CMIC_SCHAN_ERRr_s {
    uint32_t v[1];
    uint32_t cmic_schan_err[1];
    uint32_t _cmic_schan_err;
} CMIC_SCHAN_ERRr_t;

#define CMIC_SCHAN_ERRr_CLR(r) (r).cmic_schan_err[0] = 0
#define CMIC_SCHAN_ERRr_SET(r,d) (r).cmic_schan_err[0] = d
#define CMIC_SCHAN_ERRr_GET(r) (r).cmic_schan_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SCHAN_ERRr_NACKf_GET(r) (((r).cmic_schan_err[0]) & 0x1)
#define CMIC_SCHAN_ERRr_NACKf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_SCHAN_ERRr_ERR_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 4) & 0x3)
#define CMIC_SCHAN_ERRr_ERR_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define CMIC_SCHAN_ERRr_ERRBITf_GET(r) ((((r).cmic_schan_err[0]) >> 6) & 0x1)
#define CMIC_SCHAN_ERRr_ERRBITf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_SCHAN_ERRr_DATA_LENf_GET(r) ((((r).cmic_schan_err[0]) >> 7) & 0x7f)
#define CMIC_SCHAN_ERRr_DATA_LENf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define CMIC_SCHAN_ERRr_SRC_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 14) & 0x3f)
#define CMIC_SCHAN_ERRr_SRC_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define CMIC_SCHAN_ERRr_DST_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 20) & 0x3f)
#define CMIC_SCHAN_ERRr_DST_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define CMIC_SCHAN_ERRr_OP_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 26) & 0x3f)
#define CMIC_SCHAN_ERRr_OP_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_SCHAN_ERR.
 */
#define READ_CMIC_SCHAN_ERRr(u,_ch,r) BCMDRD_DEV_READ32(u,CMIC_SCHAN_ERRr_OFFSET+(0x100*(_ch)),r._cmic_schan_err)
#define WRITE_CMIC_SCHAN_ERRr(u,_ch,r) BCMDRD_DEV_WRITE32(u,CMIC_SCHAN_ERRr_OFFSET+(0x100*(_ch)),r._cmic_schan_err)

/*******************************************************************************
 * End of 'CMIC_SCHAN_ERRr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_SCHAN_MESSAGE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_SCHAN_MESSAGEr_OFFSET 0x0001000c

#define CMIC_SCHAN_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_MESSAGE.
 */
typedef union CMIC_SCHAN_MESSAGEr_s {
    uint32_t v[1];
    uint32_t cmic_schan_message[1];
    uint32_t _cmic_schan_message;
} CMIC_SCHAN_MESSAGEr_t;

#define CMIC_SCHAN_MESSAGEr_CLR(r) (r).cmic_schan_message[0] = 0
#define CMIC_SCHAN_MESSAGEr_SET(r,d) (r).cmic_schan_message[0] = d
#define CMIC_SCHAN_MESSAGEr_GET(r) (r).cmic_schan_message[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SCHAN_MESSAGEr_DATAf_GET(r) ((r).cmic_schan_message[0])
#define CMIC_SCHAN_MESSAGEr_DATAf_SET(r,f) (r).cmic_schan_message[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHAN_MESSAGE.
 */
#define READ_CMIC_SCHAN_MESSAGEr(u,_ch,i,r) BCMDRD_DEV_READ32(u,CMIC_SCHAN_MESSAGEr_OFFSET+(4*(i))+(0x100*(_ch)),r._cmic_schan_message)
#define WRITE_CMIC_SCHAN_MESSAGEr(u,_ch,i,r) BCMDRD_DEV_WRITE32(u,CMIC_SCHAN_MESSAGEr_OFFSET+(4*(i))+(0x100*(_ch)),r._cmic_schan_message)

/*******************************************************************************
 * End of 'CMIC_SCHAN_MESSAGEr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_TOP_CONFIG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_TOP_CONFIGr_OFFSET 0x00000008

#define CMIC_TOP_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TOP_CONFIG.
 */
typedef union CMIC_TOP_CONFIGr_s {
    uint32_t v[1];
    uint32_t cmic_top_config[1];
    uint32_t _cmic_top_config;
} CMIC_TOP_CONFIGr_t;

#define CMIC_TOP_CONFIGr_CLR(r) (r).cmic_top_config[0] = 0
#define CMIC_TOP_CONFIGr_SET(r,d) (r).cmic_top_config[0] = d
#define CMIC_TOP_CONFIGr_GET(r) (r).cmic_top_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_CONFIGr_ENABLE_PIO_WRITE_NON_POSTEDf_GET(r) (((r).cmic_top_config[0]) & 0x1)
#define CMIC_TOP_CONFIGr_ENABLE_PIO_WRITE_NON_POSTEDf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_TOP_CONFIGr_IP_2_EP_LOOPBACK_ENABLEf_GET(r) ((((r).cmic_top_config[0]) >> 1) & 0x1)
#define CMIC_TOP_CONFIGr_IP_2_EP_LOOPBACK_ENABLEf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_TOP_CONFIGr_CMC0_CLK_ENf_GET(r) ((((r).cmic_top_config[0]) >> 2) & 0x1)
#define CMIC_TOP_CONFIGr_CMC0_CLK_ENf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_TOP_CONFIGr_CMC1_CLK_ENf_GET(r) ((((r).cmic_top_config[0]) >> 3) & 0x1)
#define CMIC_TOP_CONFIGr_CMC1_CLK_ENf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_TOP_CONFIGr_COMMON_POOL_CLK_ENf_GET(r) ((((r).cmic_top_config[0]) >> 4) & 0x1)
#define CMIC_TOP_CONFIGr_COMMON_POOL_CLK_ENf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_TOP_CONFIGr_RPE_CLK_ENf_GET(r) ((((r).cmic_top_config[0]) >> 5) & 0x1)
#define CMIC_TOP_CONFIGr_RPE_CLK_ENf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_TOP_CONFIGr_IP_INTERFACE_PAYLOAD_ENDIANESSf_GET(r) ((((r).cmic_top_config[0]) >> 6) & 0x1)
#define CMIC_TOP_CONFIGr_IP_INTERFACE_PAYLOAD_ENDIANESSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_TOP_CONFIGr_IP_INTERFACE_HEADER_ENDIANESSf_GET(r) ((((r).cmic_top_config[0]) >> 7) & 0x1)
#define CMIC_TOP_CONFIGr_IP_INTERFACE_HEADER_ENDIANESSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_TOP_CONFIGr_EP_INTERFACE_PAYLOAD_ENDIANESSf_GET(r) ((((r).cmic_top_config[0]) >> 8) & 0x1)
#define CMIC_TOP_CONFIGr_EP_INTERFACE_PAYLOAD_ENDIANESSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_TOP_CONFIGr_EP_INTERFACE_HEADER_ENDIANESSf_GET(r) ((((r).cmic_top_config[0]) >> 9) & 0x1)
#define CMIC_TOP_CONFIGr_EP_INTERFACE_HEADER_ENDIANESSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_TOP_CONFIGr_CLEAR_ON_READ_ENABLEf_GET(r) ((((r).cmic_top_config[0]) >> 10) & 0x1)
#define CMIC_TOP_CONFIGr_CLEAR_ON_READ_ENABLEf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_TOP_CONFIGr_SATURATE_ENABLEf_GET(r) ((((r).cmic_top_config[0]) >> 11) & 0x1)
#define CMIC_TOP_CONFIGr_SATURATE_ENABLEf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_TOP_CONFIGr_CLEAR_CMC0_COUNTERSf_GET(r) ((((r).cmic_top_config[0]) >> 12) & 0x1)
#define CMIC_TOP_CONFIGr_CLEAR_CMC0_COUNTERSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_TOP_CONFIGr_CLEAR_CMC1_COUNTERSf_GET(r) ((((r).cmic_top_config[0]) >> 13) & 0x1)
#define CMIC_TOP_CONFIGr_CLEAR_CMC1_COUNTERSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CMIC_TOP_CONFIGr_CLEAR_RPE_COUNTERSf_GET(r) ((((r).cmic_top_config[0]) >> 14) & 0x1)
#define CMIC_TOP_CONFIGr_CLEAR_RPE_COUNTERSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CMIC_TOP_CONFIGr_CLEAR_TOP_COUNTERSf_GET(r) ((((r).cmic_top_config[0]) >> 15) & 0x1)
#define CMIC_TOP_CONFIGr_CLEAR_TOP_COUNTERSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_TOP_CONFIGr_DISABLE_CMIC_RESET_UPON_IPROC_PIO_RESETf_GET(r) ((((r).cmic_top_config[0]) >> 16) & 0x1)
#define CMIC_TOP_CONFIGr_DISABLE_CMIC_RESET_UPON_IPROC_PIO_RESETf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access CMIC_TOP_CONFIG.
 */
#define READ_CMIC_TOP_CONFIGr(u,r) BCMDRD_DEV_READ32(u,CMIC_TOP_CONFIGr_OFFSET,r._cmic_top_config)
#define WRITE_CMIC_TOP_CONFIGr(u,r) BCMDRD_DEV_WRITE32(u,CMIC_TOP_CONFIGr_OFFSET,r._cmic_top_config)

/*******************************************************************************
 * End of 'CMIC_TOP_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_TOP_EPINTF_BUF_DEPTH
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_TOP_EPINTF_BUF_DEPTHr_OFFSET 0x00000074

#define CMIC_TOP_EPINTF_BUF_DEPTHr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TOP_EPINTF_BUF_DEPTH.
 */
typedef union CMIC_TOP_EPINTF_BUF_DEPTHr_s {
    uint32_t v[1];
    uint32_t cmic_top_epintf_buf_depth[1];
    uint32_t _cmic_top_epintf_buf_depth;
} CMIC_TOP_EPINTF_BUF_DEPTHr_t;

#define CMIC_TOP_EPINTF_BUF_DEPTHr_CLR(r) (r).cmic_top_epintf_buf_depth[0] = 0
#define CMIC_TOP_EPINTF_BUF_DEPTHr_SET(r,d) (r).cmic_top_epintf_buf_depth[0] = d
#define CMIC_TOP_EPINTF_BUF_DEPTHr_GET(r) (r).cmic_top_epintf_buf_depth[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_EPINTF_BUF_DEPTHr_BUF_DEPTHf_GET(r) (((r).cmic_top_epintf_buf_depth[0]) & 0x7f)
#define CMIC_TOP_EPINTF_BUF_DEPTHr_BUF_DEPTHf_SET(r,f) (r).cmic_top_epintf_buf_depth[0]=(((r).cmic_top_epintf_buf_depth[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define CMIC_TOP_EPINTF_BUF_DEPTHr_ISSUED_CREDITSf_GET(r) ((((r).cmic_top_epintf_buf_depth[0]) >> 7) & 0x7f)
#define CMIC_TOP_EPINTF_BUF_DEPTHr_ISSUED_CREDITSf_SET(r,f) (r).cmic_top_epintf_buf_depth[0]=(((r).cmic_top_epintf_buf_depth[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))

/*
 * These macros can be used to access CMIC_TOP_EPINTF_BUF_DEPTH.
 */
#define READ_CMIC_TOP_EPINTF_BUF_DEPTHr(u,r) BCMDRD_DEV_READ32(u,CMIC_TOP_EPINTF_BUF_DEPTHr_OFFSET,r._cmic_top_epintf_buf_depth)
#define WRITE_CMIC_TOP_EPINTF_BUF_DEPTHr(u,r) BCMDRD_DEV_WRITE32(u,CMIC_TOP_EPINTF_BUF_DEPTHr_OFFSET,r._cmic_top_epintf_buf_depth)

/*******************************************************************************
 * End of 'CMIC_TOP_EPINTF_BUF_DEPTHr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_OFFSET 0x00000070

#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITS.
 */
typedef union CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_s {
    uint32_t v[1];
    uint32_t cmic_top_epintf_max_interface_credits[1];
    uint32_t _cmic_top_epintf_max_interface_credits;
} CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_t;

#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_CLR(r) (r).cmic_top_epintf_max_interface_credits[0] = 0
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_SET(r,d) (r).cmic_top_epintf_max_interface_credits[0] = d
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_GET(r) (r).cmic_top_epintf_max_interface_credits[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_MAX_CREDITSf_GET(r) (((r).cmic_top_epintf_max_interface_credits[0]) & 0x7f)
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_MAX_CREDITSf_SET(r,f) (r).cmic_top_epintf_max_interface_credits[0]=(((r).cmic_top_epintf_max_interface_credits[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_FLUSH_EPINTFBUFf_GET(r) ((((r).cmic_top_epintf_max_interface_credits[0]) >> 7) & 0x1)
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_FLUSH_EPINTFBUFf_SET(r,f) (r).cmic_top_epintf_max_interface_credits[0]=(((r).cmic_top_epintf_max_interface_credits[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_WR_EP_INTF_CREDITSf_GET(r) ((((r).cmic_top_epintf_max_interface_credits[0]) >> 8) & 0x1)
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_WR_EP_INTF_CREDITSf_SET(r,f) (r).cmic_top_epintf_max_interface_credits[0]=(((r).cmic_top_epintf_max_interface_credits[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITS.
 */
#define READ_CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr(u,r) BCMDRD_DEV_READ32(u,CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_OFFSET,r._cmic_top_epintf_max_interface_credits)
#define WRITE_CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr(u,r) BCMDRD_DEV_WRITE32(u,CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_OFFSET,r._cmic_top_epintf_max_interface_credits)

/*******************************************************************************
 * End of 'CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_TOP_EPINTF_RELEASE_ALL_CREDITS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_OFFSET 0x0000006c

#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TOP_EPINTF_RELEASE_ALL_CREDITS.
 */
typedef union CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_s {
    uint32_t v[1];
    uint32_t cmic_top_epintf_release_all_credits[1];
    uint32_t _cmic_top_epintf_release_all_credits;
} CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_t;

#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_CLR(r) (r).cmic_top_epintf_release_all_credits[0] = 0
#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_SET(r,d) (r).cmic_top_epintf_release_all_credits[0] = d
#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_GET(r) (r).cmic_top_epintf_release_all_credits[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_RELEASE_ALL_CREDITSf_GET(r) (((r).cmic_top_epintf_release_all_credits[0]) & 0x1)
#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_RELEASE_ALL_CREDITSf_SET(r,f) (r).cmic_top_epintf_release_all_credits[0]=(((r).cmic_top_epintf_release_all_credits[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CMIC_TOP_EPINTF_RELEASE_ALL_CREDITS.
 */
#define READ_CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr(u,r) BCMDRD_DEV_READ32(u,CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_OFFSET,r._cmic_top_epintf_release_all_credits)
#define WRITE_CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr(u,r) BCMDRD_DEV_WRITE32(u,CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_OFFSET,r._cmic_top_epintf_release_all_credits)

/*******************************************************************************
 * End of 'CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr'
 */




/*******************************************************************************
 * REGISTER:  CMIC_TOP_EP_TO_CPU_HEADER_SIZE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_OFFSET 0x00000004

#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TOP_EP_TO_CPU_HEADER_SIZE.
 */
typedef union CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_s {
    uint32_t v[1];
    uint32_t cmic_top_ep_to_cpu_header_size[1];
    uint32_t _cmic_top_ep_to_cpu_header_size;
} CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_t;

#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_CLR(r) (r).cmic_top_ep_to_cpu_header_size[0] = 0
#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_SET(r,d) (r).cmic_top_ep_to_cpu_header_size[0] = d
#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_GET(r) (r).cmic_top_ep_to_cpu_header_size[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_EP_TO_CPU_HEADER_SIZEf_GET(r) (((r).cmic_top_ep_to_cpu_header_size[0]) & 0xf)
#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_EP_TO_CPU_HEADER_SIZEf_SET(r,f) (r).cmic_top_ep_to_cpu_header_size[0]=(((r).cmic_top_ep_to_cpu_header_size[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CMIC_TOP_EP_TO_CPU_HEADER_SIZE.
 */
#define READ_CMIC_TOP_EP_TO_CPU_HEADER_SIZEr(u,r) BCMDRD_DEV_READ32(u,CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_OFFSET,r._cmic_top_ep_to_cpu_header_size)
#define WRITE_CMIC_TOP_EP_TO_CPU_HEADER_SIZEr(u,r) BCMDRD_DEV_WRITE32(u,CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_OFFSET,r._cmic_top_ep_to_cpu_header_size)

/*******************************************************************************
 * End of 'CMIC_TOP_EP_TO_CPU_HEADER_SIZEr'
 */




/*******************************************************************************
 * REGISTER:  CRU_control
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define CRU_CONTROLr_OFFSET 0x1802e000

#define CRU_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CRU_control.
 */
typedef union CRU_CONTROLr_s {
    uint32_t v[1];
    uint32_t cru_control[1];
    uint32_t _cru_control;
} CRU_CONTROLr_t;

#define CRU_CONTROLr_CLR(r) (r).cru_control[0] = 0
#define CRU_CONTROLr_SET(r,d) (r).cru_control[0] = d
#define CRU_CONTROLr_GET(r) (r).cru_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CRU_CONTROLr_SW_RESETf_GET(r) (((r).cru_control[0]) & 0x1)
#define CRU_CONTROLr_SW_RESETf_SET(r,f) (r).cru_control[0]=(((r).cru_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CRU_CONTROLr_QSPI_CLK_SELf_GET(r) ((((r).cru_control[0]) >> 1) & 0x3)
#define CRU_CONTROLr_QSPI_CLK_SELf_SET(r,f) (r).cru_control[0]=(((r).cru_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))

/*
 * These macros can be used to access CRU_control.
 */
#define READ_CRU_CONTROLr(u,r) BCMDRD_IPROC_READ(u,CRU_CONTROLr_OFFSET,r._cru_control)
#define WRITE_CRU_CONTROLr(u,r) BCMDRD_IPROC_WRITE(u,CRU_CONTROLr_OFFSET,r._cru_control)

/*******************************************************************************
 * End of 'CRU_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_AUX_SEL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_AUX_SELr_OFFSET 0x03225028

#define GPIO_AUX_SELr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_AUX_SEL.
 */
typedef union GPIO_AUX_SELr_s {
    uint32_t v[1];
    uint32_t gpio_aux_sel[1];
    uint32_t _gpio_aux_sel;
} GPIO_AUX_SELr_t;

#define GPIO_AUX_SELr_CLR(r) (r).gpio_aux_sel[0] = 0
#define GPIO_AUX_SELr_SET(r,d) (r).gpio_aux_sel[0] = d
#define GPIO_AUX_SELr_GET(r) (r).gpio_aux_sel[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_AUX_SELr_AUX_SELf_GET(r) ((r).gpio_aux_sel[0])
#define GPIO_AUX_SELr_AUX_SELf_SET(r,f) (r).gpio_aux_sel[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_AUX_SEL.
 */
#define READ_GPIO_AUX_SELr(u,r) BCMDRD_IPROC_READ(u,GPIO_AUX_SELr_OFFSET,r._gpio_aux_sel)
#define WRITE_GPIO_AUX_SELr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_AUX_SELr_OFFSET,r._gpio_aux_sel)

/*******************************************************************************
 * End of 'GPIO_AUX_SELr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_DATA_IN
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_DATA_INr_OFFSET 0x03225000

#define GPIO_DATA_INr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_DATA_IN.
 */
typedef union GPIO_DATA_INr_s {
    uint32_t v[1];
    uint32_t gpio_data_in[1];
    uint32_t _gpio_data_in;
} GPIO_DATA_INr_t;

#define GPIO_DATA_INr_CLR(r) (r).gpio_data_in[0] = 0
#define GPIO_DATA_INr_SET(r,d) (r).gpio_data_in[0] = d
#define GPIO_DATA_INr_GET(r) (r).gpio_data_in[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_DATA_INr_DATA_INf_GET(r) ((r).gpio_data_in[0])
#define GPIO_DATA_INr_DATA_INf_SET(r,f) (r).gpio_data_in[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_DATA_IN.
 */
#define READ_GPIO_DATA_INr(u,r) BCMDRD_IPROC_READ(u,GPIO_DATA_INr_OFFSET,r._gpio_data_in)
#define WRITE_GPIO_DATA_INr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_DATA_INr_OFFSET,r._gpio_data_in)

/*******************************************************************************
 * End of 'GPIO_DATA_INr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_DATA_OUT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_DATA_OUTr_OFFSET 0x03225004

#define GPIO_DATA_OUTr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_DATA_OUT.
 */
typedef union GPIO_DATA_OUTr_s {
    uint32_t v[1];
    uint32_t gpio_data_out[1];
    uint32_t _gpio_data_out;
} GPIO_DATA_OUTr_t;

#define GPIO_DATA_OUTr_CLR(r) (r).gpio_data_out[0] = 0
#define GPIO_DATA_OUTr_SET(r,d) (r).gpio_data_out[0] = d
#define GPIO_DATA_OUTr_GET(r) (r).gpio_data_out[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_DATA_OUTr_DATA_OUTf_GET(r) ((r).gpio_data_out[0])
#define GPIO_DATA_OUTr_DATA_OUTf_SET(r,f) (r).gpio_data_out[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_DATA_OUT.
 */
#define READ_GPIO_DATA_OUTr(u,r) BCMDRD_IPROC_READ(u,GPIO_DATA_OUTr_OFFSET,r._gpio_data_out)
#define WRITE_GPIO_DATA_OUTr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_DATA_OUTr_OFFSET,r._gpio_data_out)

/*******************************************************************************
 * End of 'GPIO_DATA_OUTr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_INIT_VAL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_INIT_VALr_OFFSET 0x03225030

#define GPIO_INIT_VALr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INIT_VAL.
 */
typedef union GPIO_INIT_VALr_s {
    uint32_t v[1];
    uint32_t gpio_init_val[1];
    uint32_t _gpio_init_val;
} GPIO_INIT_VALr_t;

#define GPIO_INIT_VALr_CLR(r) (r).gpio_init_val[0] = 0
#define GPIO_INIT_VALr_SET(r,d) (r).gpio_init_val[0] = d
#define GPIO_INIT_VALr_GET(r) (r).gpio_init_val[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INIT_VALr_INIT_VALf_GET(r) ((r).gpio_init_val[0])
#define GPIO_INIT_VALr_INIT_VALf_SET(r,f) (r).gpio_init_val[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_INIT_VAL.
 */
#define READ_GPIO_INIT_VALr(u,r) BCMDRD_IPROC_READ(u,GPIO_INIT_VALr_OFFSET,r._gpio_init_val)
#define WRITE_GPIO_INIT_VALr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_INIT_VALr_OFFSET,r._gpio_init_val)

/*******************************************************************************
 * End of 'GPIO_INIT_VALr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_INT_CLR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_INT_CLRr_OFFSET 0x03225024

#define GPIO_INT_CLRr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_CLR.
 */
typedef union GPIO_INT_CLRr_s {
    uint32_t v[1];
    uint32_t gpio_int_clr[1];
    uint32_t _gpio_int_clr;
} GPIO_INT_CLRr_t;

#define GPIO_INT_CLRr_CLR(r) (r).gpio_int_clr[0] = 0
#define GPIO_INT_CLRr_SET(r,d) (r).gpio_int_clr[0] = d
#define GPIO_INT_CLRr_GET(r) (r).gpio_int_clr[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_CLRr_INT_CLRf_GET(r) ((r).gpio_int_clr[0])
#define GPIO_INT_CLRr_INT_CLRf_SET(r,f) (r).gpio_int_clr[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_INT_CLR.
 */
#define READ_GPIO_INT_CLRr(u,r) BCMDRD_IPROC_READ(u,GPIO_INT_CLRr_OFFSET,r._gpio_int_clr)
#define WRITE_GPIO_INT_CLRr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_INT_CLRr_OFFSET,r._gpio_int_clr)

/*******************************************************************************
 * End of 'GPIO_INT_CLRr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_INT_DE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_INT_DEr_OFFSET 0x03225010

#define GPIO_INT_DEr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_DE.
 */
typedef union GPIO_INT_DEr_s {
    uint32_t v[1];
    uint32_t gpio_int_de[1];
    uint32_t _gpio_int_de;
} GPIO_INT_DEr_t;

#define GPIO_INT_DEr_CLR(r) (r).gpio_int_de[0] = 0
#define GPIO_INT_DEr_SET(r,d) (r).gpio_int_de[0] = d
#define GPIO_INT_DEr_GET(r) (r).gpio_int_de[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_DEr_INT_DEf_GET(r) ((r).gpio_int_de[0])
#define GPIO_INT_DEr_INT_DEf_SET(r,f) (r).gpio_int_de[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_INT_DE.
 */
#define READ_GPIO_INT_DEr(u,r) BCMDRD_IPROC_READ(u,GPIO_INT_DEr_OFFSET,r._gpio_int_de)
#define WRITE_GPIO_INT_DEr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_INT_DEr_OFFSET,r._gpio_int_de)

/*******************************************************************************
 * End of 'GPIO_INT_DEr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_INT_EDGE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_INT_EDGEr_OFFSET 0x03225014

#define GPIO_INT_EDGEr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_EDGE.
 */
typedef union GPIO_INT_EDGEr_s {
    uint32_t v[1];
    uint32_t gpio_int_edge[1];
    uint32_t _gpio_int_edge;
} GPIO_INT_EDGEr_t;

#define GPIO_INT_EDGEr_CLR(r) (r).gpio_int_edge[0] = 0
#define GPIO_INT_EDGEr_SET(r,d) (r).gpio_int_edge[0] = d
#define GPIO_INT_EDGEr_GET(r) (r).gpio_int_edge[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_EDGEr_INT_EDGEf_GET(r) ((r).gpio_int_edge[0])
#define GPIO_INT_EDGEr_INT_EDGEf_SET(r,f) (r).gpio_int_edge[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_INT_EDGE.
 */
#define READ_GPIO_INT_EDGEr(u,r) BCMDRD_IPROC_READ(u,GPIO_INT_EDGEr_OFFSET,r._gpio_int_edge)
#define WRITE_GPIO_INT_EDGEr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_INT_EDGEr_OFFSET,r._gpio_int_edge)

/*******************************************************************************
 * End of 'GPIO_INT_EDGEr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_INT_MSK
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_INT_MSKr_OFFSET 0x03225018

#define GPIO_INT_MSKr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_MSK.
 */
typedef union GPIO_INT_MSKr_s {
    uint32_t v[1];
    uint32_t gpio_int_msk[1];
    uint32_t _gpio_int_msk;
} GPIO_INT_MSKr_t;

#define GPIO_INT_MSKr_CLR(r) (r).gpio_int_msk[0] = 0
#define GPIO_INT_MSKr_SET(r,d) (r).gpio_int_msk[0] = d
#define GPIO_INT_MSKr_GET(r) (r).gpio_int_msk[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_MSKr_INT_MSKf_GET(r) ((r).gpio_int_msk[0])
#define GPIO_INT_MSKr_INT_MSKf_SET(r,f) (r).gpio_int_msk[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_INT_MSK.
 */
#define READ_GPIO_INT_MSKr(u,r) BCMDRD_IPROC_READ(u,GPIO_INT_MSKr_OFFSET,r._gpio_int_msk)
#define WRITE_GPIO_INT_MSKr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_INT_MSKr_OFFSET,r._gpio_int_msk)

/*******************************************************************************
 * End of 'GPIO_INT_MSKr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_INT_MSTAT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_INT_MSTATr_OFFSET 0x03225020

#define GPIO_INT_MSTATr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_MSTAT.
 */
typedef union GPIO_INT_MSTATr_s {
    uint32_t v[1];
    uint32_t gpio_int_mstat[1];
    uint32_t _gpio_int_mstat;
} GPIO_INT_MSTATr_t;

#define GPIO_INT_MSTATr_CLR(r) (r).gpio_int_mstat[0] = 0
#define GPIO_INT_MSTATr_SET(r,d) (r).gpio_int_mstat[0] = d
#define GPIO_INT_MSTATr_GET(r) (r).gpio_int_mstat[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_MSTATr_INT_MSTATf_GET(r) ((r).gpio_int_mstat[0])
#define GPIO_INT_MSTATr_INT_MSTATf_SET(r,f) (r).gpio_int_mstat[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_INT_MSTAT.
 */
#define READ_GPIO_INT_MSTATr(u,r) BCMDRD_IPROC_READ(u,GPIO_INT_MSTATr_OFFSET,r._gpio_int_mstat)
#define WRITE_GPIO_INT_MSTATr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_INT_MSTATr_OFFSET,r._gpio_int_mstat)

/*******************************************************************************
 * End of 'GPIO_INT_MSTATr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_INT_STAT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_INT_STATr_OFFSET 0x0322501c

#define GPIO_INT_STATr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_STAT.
 */
typedef union GPIO_INT_STATr_s {
    uint32_t v[1];
    uint32_t gpio_int_stat[1];
    uint32_t _gpio_int_stat;
} GPIO_INT_STATr_t;

#define GPIO_INT_STATr_CLR(r) (r).gpio_int_stat[0] = 0
#define GPIO_INT_STATr_SET(r,d) (r).gpio_int_stat[0] = d
#define GPIO_INT_STATr_GET(r) (r).gpio_int_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_STATr_INT_STATf_GET(r) ((r).gpio_int_stat[0])
#define GPIO_INT_STATr_INT_STATf_SET(r,f) (r).gpio_int_stat[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_INT_STAT.
 */
#define READ_GPIO_INT_STATr(u,r) BCMDRD_IPROC_READ(u,GPIO_INT_STATr_OFFSET,r._gpio_int_stat)
#define WRITE_GPIO_INT_STATr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_INT_STATr_OFFSET,r._gpio_int_stat)

/*******************************************************************************
 * End of 'GPIO_INT_STATr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_INT_TYPE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_INT_TYPEr_OFFSET 0x0322500c

#define GPIO_INT_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_TYPE.
 */
typedef union GPIO_INT_TYPEr_s {
    uint32_t v[1];
    uint32_t gpio_int_type[1];
    uint32_t _gpio_int_type;
} GPIO_INT_TYPEr_t;

#define GPIO_INT_TYPEr_CLR(r) (r).gpio_int_type[0] = 0
#define GPIO_INT_TYPEr_SET(r,d) (r).gpio_int_type[0] = d
#define GPIO_INT_TYPEr_GET(r) (r).gpio_int_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_TYPEr_INT_TYPEf_GET(r) ((r).gpio_int_type[0])
#define GPIO_INT_TYPEr_INT_TYPEf_SET(r,f) (r).gpio_int_type[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_INT_TYPE.
 */
#define READ_GPIO_INT_TYPEr(u,r) BCMDRD_IPROC_READ(u,GPIO_INT_TYPEr_OFFSET,r._gpio_int_type)
#define WRITE_GPIO_INT_TYPEr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_INT_TYPEr_OFFSET,r._gpio_int_type)

/*******************************************************************************
 * End of 'GPIO_INT_TYPEr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_OUT_EN
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_OUT_ENr_OFFSET 0x03225008

#define GPIO_OUT_ENr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_OUT_EN.
 */
typedef union GPIO_OUT_ENr_s {
    uint32_t v[1];
    uint32_t gpio_out_en[1];
    uint32_t _gpio_out_en;
} GPIO_OUT_ENr_t;

#define GPIO_OUT_ENr_CLR(r) (r).gpio_out_en[0] = 0
#define GPIO_OUT_ENr_SET(r,d) (r).gpio_out_en[0] = d
#define GPIO_OUT_ENr_GET(r) (r).gpio_out_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_OUT_ENr_OUT_ENABLEf_GET(r) ((r).gpio_out_en[0])
#define GPIO_OUT_ENr_OUT_ENABLEf_SET(r,f) (r).gpio_out_en[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_OUT_EN.
 */
#define READ_GPIO_OUT_ENr(u,r) BCMDRD_IPROC_READ(u,GPIO_OUT_ENr_OFFSET,r._gpio_out_en)
#define WRITE_GPIO_OUT_ENr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_OUT_ENr_OFFSET,r._gpio_out_en)

/*******************************************************************************
 * End of 'GPIO_OUT_ENr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_PAD_RES
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_PAD_RESr_OFFSET 0x03225034

#define GPIO_PAD_RESr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_PAD_RES.
 */
typedef union GPIO_PAD_RESr_s {
    uint32_t v[1];
    uint32_t gpio_pad_res[1];
    uint32_t _gpio_pad_res;
} GPIO_PAD_RESr_t;

#define GPIO_PAD_RESr_CLR(r) (r).gpio_pad_res[0] = 0
#define GPIO_PAD_RESr_SET(r,d) (r).gpio_pad_res[0] = d
#define GPIO_PAD_RESr_GET(r) (r).gpio_pad_res[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_PAD_RESr_PAD_RESf_GET(r) ((r).gpio_pad_res[0])
#define GPIO_PAD_RESr_PAD_RESf_SET(r,f) (r).gpio_pad_res[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_PAD_RES.
 */
#define READ_GPIO_PAD_RESr(u,r) BCMDRD_IPROC_READ(u,GPIO_PAD_RESr_OFFSET,r._gpio_pad_res)
#define WRITE_GPIO_PAD_RESr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_PAD_RESr_OFFSET,r._gpio_pad_res)

/*******************************************************************************
 * End of 'GPIO_PAD_RESr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_PRB_ENABLE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_PRB_ENABLEr_OFFSET 0x03225048

#define GPIO_PRB_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_PRB_ENABLE.
 */
typedef union GPIO_PRB_ENABLEr_s {
    uint32_t v[1];
    uint32_t gpio_prb_enable[1];
    uint32_t _gpio_prb_enable;
} GPIO_PRB_ENABLEr_t;

#define GPIO_PRB_ENABLEr_CLR(r) (r).gpio_prb_enable[0] = 0
#define GPIO_PRB_ENABLEr_SET(r,d) (r).gpio_prb_enable[0] = d
#define GPIO_PRB_ENABLEr_GET(r) (r).gpio_prb_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_PRB_ENABLEr_PRB_SELf_GET(r) (((r).gpio_prb_enable[0]) & 0x1)
#define GPIO_PRB_ENABLEr_PRB_SELf_SET(r,f) (r).gpio_prb_enable[0]=(((r).gpio_prb_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define GPIO_PRB_ENABLEr_TEST_SELf_GET(r) ((((r).gpio_prb_enable[0]) >> 1) & 0x1)
#define GPIO_PRB_ENABLEr_TEST_SELf_SET(r,f) (r).gpio_prb_enable[0]=(((r).gpio_prb_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access GPIO_PRB_ENABLE.
 */
#define READ_GPIO_PRB_ENABLEr(u,r) BCMDRD_IPROC_READ(u,GPIO_PRB_ENABLEr_OFFSET,r._gpio_prb_enable)
#define WRITE_GPIO_PRB_ENABLEr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_PRB_ENABLEr_OFFSET,r._gpio_prb_enable)

/*******************************************************************************
 * End of 'GPIO_PRB_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_PRB_OE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_PRB_OEr_OFFSET 0x0322504c

#define GPIO_PRB_OEr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_PRB_OE.
 */
typedef union GPIO_PRB_OEr_s {
    uint32_t v[1];
    uint32_t gpio_prb_oe[1];
    uint32_t _gpio_prb_oe;
} GPIO_PRB_OEr_t;

#define GPIO_PRB_OEr_CLR(r) (r).gpio_prb_oe[0] = 0
#define GPIO_PRB_OEr_SET(r,d) (r).gpio_prb_oe[0] = d
#define GPIO_PRB_OEr_GET(r) (r).gpio_prb_oe[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_PRB_OEr_GP_PRB_OEf_GET(r) ((r).gpio_prb_oe[0])
#define GPIO_PRB_OEr_GP_PRB_OEf_SET(r,f) (r).gpio_prb_oe[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_PRB_OE.
 */
#define READ_GPIO_PRB_OEr(u,r) BCMDRD_IPROC_READ(u,GPIO_PRB_OEr_OFFSET,r._gpio_prb_oe)
#define WRITE_GPIO_PRB_OEr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_PRB_OEr_OFFSET,r._gpio_prb_oe)

/*******************************************************************************
 * End of 'GPIO_PRB_OEr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_RES_EN
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_RES_ENr_OFFSET 0x03225038

#define GPIO_RES_ENr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_RES_EN.
 */
typedef union GPIO_RES_ENr_s {
    uint32_t v[1];
    uint32_t gpio_res_en[1];
    uint32_t _gpio_res_en;
} GPIO_RES_ENr_t;

#define GPIO_RES_ENr_CLR(r) (r).gpio_res_en[0] = 0
#define GPIO_RES_ENr_SET(r,d) (r).gpio_res_en[0] = d
#define GPIO_RES_ENr_GET(r) (r).gpio_res_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_RES_ENr_RES_ENf_GET(r) ((r).gpio_res_en[0])
#define GPIO_RES_ENr_RES_ENf_SET(r,f) (r).gpio_res_en[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_RES_EN.
 */
#define READ_GPIO_RES_ENr(u,r) BCMDRD_IPROC_READ(u,GPIO_RES_ENr_OFFSET,r._gpio_res_en)
#define WRITE_GPIO_RES_ENr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_RES_ENr_OFFSET,r._gpio_res_en)

/*******************************************************************************
 * End of 'GPIO_RES_ENr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_TEST_ENABLE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_TEST_ENABLEr_OFFSET 0x03225044

#define GPIO_TEST_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_TEST_ENABLE.
 */
typedef union GPIO_TEST_ENABLEr_s {
    uint32_t v[1];
    uint32_t gpio_test_enable[1];
    uint32_t _gpio_test_enable;
} GPIO_TEST_ENABLEr_t;

#define GPIO_TEST_ENABLEr_CLR(r) (r).gpio_test_enable[0] = 0
#define GPIO_TEST_ENABLEr_SET(r,d) (r).gpio_test_enable[0] = d
#define GPIO_TEST_ENABLEr_GET(r) (r).gpio_test_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_TEST_ENABLEr_TEST_ENABLEf_GET(r) ((r).gpio_test_enable[0])
#define GPIO_TEST_ENABLEr_TEST_ENABLEf_SET(r,f) (r).gpio_test_enable[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_TEST_ENABLE.
 */
#define READ_GPIO_TEST_ENABLEr(u,r) BCMDRD_IPROC_READ(u,GPIO_TEST_ENABLEr_OFFSET,r._gpio_test_enable)
#define WRITE_GPIO_TEST_ENABLEr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_TEST_ENABLEr_OFFSET,r._gpio_test_enable)

/*******************************************************************************
 * End of 'GPIO_TEST_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_TEST_INPUT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_TEST_INPUTr_OFFSET 0x0322503c

#define GPIO_TEST_INPUTr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_TEST_INPUT.
 */
typedef union GPIO_TEST_INPUTr_s {
    uint32_t v[1];
    uint32_t gpio_test_input[1];
    uint32_t _gpio_test_input;
} GPIO_TEST_INPUTr_t;

#define GPIO_TEST_INPUTr_CLR(r) (r).gpio_test_input[0] = 0
#define GPIO_TEST_INPUTr_SET(r,d) (r).gpio_test_input[0] = d
#define GPIO_TEST_INPUTr_GET(r) (r).gpio_test_input[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_TEST_INPUTr_TEST_INPUTf_GET(r) ((r).gpio_test_input[0])
#define GPIO_TEST_INPUTr_TEST_INPUTf_SET(r,f) (r).gpio_test_input[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_TEST_INPUT.
 */
#define READ_GPIO_TEST_INPUTr(u,r) BCMDRD_IPROC_READ(u,GPIO_TEST_INPUTr_OFFSET,r._gpio_test_input)
#define WRITE_GPIO_TEST_INPUTr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_TEST_INPUTr_OFFSET,r._gpio_test_input)

/*******************************************************************************
 * End of 'GPIO_TEST_INPUTr'
 */




/*******************************************************************************
 * REGISTER:  GPIO_TEST_OUTPUT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define GPIO_TEST_OUTPUTr_OFFSET 0x03225040

#define GPIO_TEST_OUTPUTr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_TEST_OUTPUT.
 */
typedef union GPIO_TEST_OUTPUTr_s {
    uint32_t v[1];
    uint32_t gpio_test_output[1];
    uint32_t _gpio_test_output;
} GPIO_TEST_OUTPUTr_t;

#define GPIO_TEST_OUTPUTr_CLR(r) (r).gpio_test_output[0] = 0
#define GPIO_TEST_OUTPUTr_SET(r,d) (r).gpio_test_output[0] = d
#define GPIO_TEST_OUTPUTr_GET(r) (r).gpio_test_output[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_TEST_OUTPUTr_TEST_OUTPUTf_GET(r) ((r).gpio_test_output[0])
#define GPIO_TEST_OUTPUTr_TEST_OUTPUTf_SET(r,f) (r).gpio_test_output[0]=((uint32_t)f)

/*
 * These macros can be used to access GPIO_TEST_OUTPUT.
 */
#define READ_GPIO_TEST_OUTPUTr(u,r) BCMDRD_IPROC_READ(u,GPIO_TEST_OUTPUTr_OFFSET,r._gpio_test_output)
#define WRITE_GPIO_TEST_OUTPUTr(u,r) BCMDRD_IPROC_WRITE(u,GPIO_TEST_OUTPUTr_OFFSET,r._gpio_test_output)

/*******************************************************************************
 * End of 'GPIO_TEST_OUTPUTr'
 */




/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_ENABLE_REG0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_ENABLE_REG0r_OFFSET 0x03241730

#define ICFG_CHIP_LP_INTR_ENABLE_REG0r_SIZE 4

/* ICFG_CHIP_LP_INTR_ENABLE_REG0r is element of ICFG_CHIP_LP_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_ENABLE_REG1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_ENABLE_REG1r_OFFSET 0x03241734

#define ICFG_CHIP_LP_INTR_ENABLE_REG1r_SIZE 4

/* ICFG_CHIP_LP_INTR_ENABLE_REG1r is element of ICFG_CHIP_LP_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_ENABLE_REG2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_ENABLE_REG2r_OFFSET 0x03241738

#define ICFG_CHIP_LP_INTR_ENABLE_REG2r_SIZE 4

/* ICFG_CHIP_LP_INTR_ENABLE_REG2r is element of ICFG_CHIP_LP_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_ENABLE_REG3
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_ENABLE_REG3r_OFFSET 0x0324173c

#define ICFG_CHIP_LP_INTR_ENABLE_REG3r_SIZE 4

/* ICFG_CHIP_LP_INTR_ENABLE_REG3r is element of ICFG_CHIP_LP_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_ENABLE_REG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_ENABLE_REGr_OFFSET 0x03241730

#define ICFG_CHIP_LP_INTR_ENABLE_REGr_SIZE 4

/*
 * This structure should be used to declare and program ICFG_CHIP_LP_INTR_ENABLE_REG.
 */
typedef union ICFG_CHIP_LP_INTR_ENABLE_REGr_s {
    uint32_t v[1];
    uint32_t icfg_chip_lp_intr_enable_reg[1];
    uint32_t _icfg_chip_lp_intr_enable_reg;
} ICFG_CHIP_LP_INTR_ENABLE_REGr_t;

#define ICFG_CHIP_LP_INTR_ENABLE_REGr_CLR(r) (r).icfg_chip_lp_intr_enable_reg[0] = 0
#define ICFG_CHIP_LP_INTR_ENABLE_REGr_SET(r,d) (r).icfg_chip_lp_intr_enable_reg[0] = d
#define ICFG_CHIP_LP_INTR_ENABLE_REGr_GET(r) (r).icfg_chip_lp_intr_enable_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define ICFG_CHIP_LP_INTR_ENABLE_REGr_B31_TO_0f_GET(r) ((r).icfg_chip_lp_intr_enable_reg[0])
#define ICFG_CHIP_LP_INTR_ENABLE_REGr_B31_TO_0f_SET(r,f) (r).icfg_chip_lp_intr_enable_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access ICFG_CHIP_LP_INTR_ENABLE_REG.
 */
#define READ_ICFG_CHIP_LP_INTR_ENABLE_REGr(u,i,r) BCMDRD_IPROC_READ(u,ICFG_CHIP_LP_INTR_ENABLE_REGr_OFFSET+(4*(i)),r._icfg_chip_lp_intr_enable_reg)
#define WRITE_ICFG_CHIP_LP_INTR_ENABLE_REGr(u,i,r) BCMDRD_IPROC_WRITE(u,ICFG_CHIP_LP_INTR_ENABLE_REGr_OFFSET+(4*(i)),r._icfg_chip_lp_intr_enable_reg)

/*******************************************************************************
 * End of 'ICFG_CHIP_LP_INTR_ENABLE_REGr'
 */




/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_RAW_STATUS_REG0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_RAW_STATUS_REG0r_OFFSET 0x03241740

#define ICFG_CHIP_LP_INTR_RAW_STATUS_REG0r_SIZE 4

/* ICFG_CHIP_LP_INTR_RAW_STATUS_REG0r is element of ICFG_CHIP_LP_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_RAW_STATUS_REG1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_RAW_STATUS_REG1r_OFFSET 0x03241744

#define ICFG_CHIP_LP_INTR_RAW_STATUS_REG1r_SIZE 4

/* ICFG_CHIP_LP_INTR_RAW_STATUS_REG1r is element of ICFG_CHIP_LP_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_RAW_STATUS_REG2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_RAW_STATUS_REG2r_OFFSET 0x03241748

#define ICFG_CHIP_LP_INTR_RAW_STATUS_REG2r_SIZE 4

/* ICFG_CHIP_LP_INTR_RAW_STATUS_REG2r is element of ICFG_CHIP_LP_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_RAW_STATUS_REG3
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_RAW_STATUS_REG3r_OFFSET 0x0324174c

#define ICFG_CHIP_LP_INTR_RAW_STATUS_REG3r_SIZE 4

/* ICFG_CHIP_LP_INTR_RAW_STATUS_REG3r is element of ICFG_CHIP_LP_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_RAW_STATUS_REG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_RAW_STATUS_REGr_OFFSET 0x03241740

#define ICFG_CHIP_LP_INTR_RAW_STATUS_REGr_SIZE 4

/*
 * This structure should be used to declare and program ICFG_CHIP_LP_INTR_RAW_STATUS_REG.
 */
typedef union ICFG_CHIP_LP_INTR_RAW_STATUS_REGr_s {
    uint32_t v[1];
    uint32_t icfg_chip_lp_intr_raw_status_reg[1];
    uint32_t _icfg_chip_lp_intr_raw_status_reg;
} ICFG_CHIP_LP_INTR_RAW_STATUS_REGr_t;

#define ICFG_CHIP_LP_INTR_RAW_STATUS_REGr_CLR(r) (r).icfg_chip_lp_intr_raw_status_reg[0] = 0
#define ICFG_CHIP_LP_INTR_RAW_STATUS_REGr_SET(r,d) (r).icfg_chip_lp_intr_raw_status_reg[0] = d
#define ICFG_CHIP_LP_INTR_RAW_STATUS_REGr_GET(r) (r).icfg_chip_lp_intr_raw_status_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define ICFG_CHIP_LP_INTR_RAW_STATUS_REGr_B31_TO_0f_GET(r) ((r).icfg_chip_lp_intr_raw_status_reg[0])
#define ICFG_CHIP_LP_INTR_RAW_STATUS_REGr_B31_TO_0f_SET(r,f) (r).icfg_chip_lp_intr_raw_status_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access ICFG_CHIP_LP_INTR_RAW_STATUS_REG.
 */
#define READ_ICFG_CHIP_LP_INTR_RAW_STATUS_REGr(u,i,r) BCMDRD_IPROC_READ(u,ICFG_CHIP_LP_INTR_RAW_STATUS_REGr_OFFSET+(4*(i)),r._icfg_chip_lp_intr_raw_status_reg)
#define WRITE_ICFG_CHIP_LP_INTR_RAW_STATUS_REGr(u,i,r) BCMDRD_IPROC_WRITE(u,ICFG_CHIP_LP_INTR_RAW_STATUS_REGr_OFFSET+(4*(i)),r._icfg_chip_lp_intr_raw_status_reg)

/*******************************************************************************
 * End of 'ICFG_CHIP_LP_INTR_RAW_STATUS_REGr'
 */




/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_STATUS_REG0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_STATUS_REG0r_OFFSET 0x03241750

#define ICFG_CHIP_LP_INTR_STATUS_REG0r_SIZE 4

/* ICFG_CHIP_LP_INTR_STATUS_REG0r is element of ICFG_CHIP_LP_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_STATUS_REG1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_STATUS_REG1r_OFFSET 0x03241754

#define ICFG_CHIP_LP_INTR_STATUS_REG1r_SIZE 4

/* ICFG_CHIP_LP_INTR_STATUS_REG1r is element of ICFG_CHIP_LP_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_STATUS_REG2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_STATUS_REG2r_OFFSET 0x03241758

#define ICFG_CHIP_LP_INTR_STATUS_REG2r_SIZE 4

/* ICFG_CHIP_LP_INTR_STATUS_REG2r is element of ICFG_CHIP_LP_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_STATUS_REG3
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_STATUS_REG3r_OFFSET 0x0324175c

#define ICFG_CHIP_LP_INTR_STATUS_REG3r_SIZE 4

/* ICFG_CHIP_LP_INTR_STATUS_REG3r is element of ICFG_CHIP_LP_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  ICFG_CHIP_LP_INTR_STATUS_REG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CHIP_LP_INTR_STATUS_REGr_OFFSET 0x03241750

#define ICFG_CHIP_LP_INTR_STATUS_REGr_SIZE 4

/*
 * This structure should be used to declare and program ICFG_CHIP_LP_INTR_STATUS_REG.
 */
typedef union ICFG_CHIP_LP_INTR_STATUS_REGr_s {
    uint32_t v[1];
    uint32_t icfg_chip_lp_intr_status_reg[1];
    uint32_t _icfg_chip_lp_intr_status_reg;
} ICFG_CHIP_LP_INTR_STATUS_REGr_t;

#define ICFG_CHIP_LP_INTR_STATUS_REGr_CLR(r) (r).icfg_chip_lp_intr_status_reg[0] = 0
#define ICFG_CHIP_LP_INTR_STATUS_REGr_SET(r,d) (r).icfg_chip_lp_intr_status_reg[0] = d
#define ICFG_CHIP_LP_INTR_STATUS_REGr_GET(r) (r).icfg_chip_lp_intr_status_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define ICFG_CHIP_LP_INTR_STATUS_REGr_B31_TO_0f_GET(r) ((r).icfg_chip_lp_intr_status_reg[0])
#define ICFG_CHIP_LP_INTR_STATUS_REGr_B31_TO_0f_SET(r,f) (r).icfg_chip_lp_intr_status_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access ICFG_CHIP_LP_INTR_STATUS_REG.
 */
#define READ_ICFG_CHIP_LP_INTR_STATUS_REGr(u,i,r) BCMDRD_IPROC_READ(u,ICFG_CHIP_LP_INTR_STATUS_REGr_OFFSET+(4*(i)),r._icfg_chip_lp_intr_status_reg)
#define WRITE_ICFG_CHIP_LP_INTR_STATUS_REGr(u,i,r) BCMDRD_IPROC_WRITE(u,ICFG_CHIP_LP_INTR_STATUS_REGr_OFFSET+(4*(i)),r._icfg_chip_lp_intr_status_reg)

/*******************************************************************************
 * End of 'ICFG_CHIP_LP_INTR_STATUS_REGr'
 */




/*******************************************************************************
 * REGISTER:  ICFG_CMIC_RCPU_SW_PROG_INTR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_OFFSET 0x032417a0

#define ICFG_CMIC_RCPU_SW_PROG_INTRr_SIZE 4

/*
 * This structure should be used to declare and program ICFG_CMIC_RCPU_SW_PROG_INTR.
 */
typedef union ICFG_CMIC_RCPU_SW_PROG_INTRr_s {
    uint32_t v[1];
    uint32_t icfg_cmic_rcpu_sw_prog_intr[1];
    uint32_t _icfg_cmic_rcpu_sw_prog_intr;
} ICFG_CMIC_RCPU_SW_PROG_INTRr_t;

#define ICFG_CMIC_RCPU_SW_PROG_INTRr_CLR(r) (r).icfg_cmic_rcpu_sw_prog_intr[0] = 0
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_SET(r,d) (r).icfg_cmic_rcpu_sw_prog_intr[0] = d
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_GET(r) (r).icfg_cmic_rcpu_sw_prog_intr[0]

/*
 * These macros can be used to access individual fields.
 */
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_PCIEf_GET(r) (((r).icfg_cmic_rcpu_sw_prog_intr[0]) & 0x1)
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_PCIEf_SET(r,f) (r).icfg_cmic_rcpu_sw_prog_intr[0]=(((r).icfg_cmic_rcpu_sw_prog_intr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_MHOST0f_GET(r) ((((r).icfg_cmic_rcpu_sw_prog_intr[0]) >> 1) & 0x1)
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_MHOST0f_SET(r,f) (r).icfg_cmic_rcpu_sw_prog_intr[0]=(((r).icfg_cmic_rcpu_sw_prog_intr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_MHOST1f_GET(r) ((((r).icfg_cmic_rcpu_sw_prog_intr[0]) >> 2) & 0x1)
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_MHOST1f_SET(r,f) (r).icfg_cmic_rcpu_sw_prog_intr[0]=(((r).icfg_cmic_rcpu_sw_prog_intr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_CORTEXM0_U0f_GET(r) ((((r).icfg_cmic_rcpu_sw_prog_intr[0]) >> 8) & 0x1)
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_CORTEXM0_U0f_SET(r,f) (r).icfg_cmic_rcpu_sw_prog_intr[0]=(((r).icfg_cmic_rcpu_sw_prog_intr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_CORTEXM0_U1f_GET(r) ((((r).icfg_cmic_rcpu_sw_prog_intr[0]) >> 9) & 0x1)
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_CORTEXM0_U1f_SET(r,f) (r).icfg_cmic_rcpu_sw_prog_intr[0]=(((r).icfg_cmic_rcpu_sw_prog_intr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_CORTEXM0_U2f_GET(r) ((((r).icfg_cmic_rcpu_sw_prog_intr[0]) >> 10) & 0x1)
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_CORTEXM0_U2f_SET(r,f) (r).icfg_cmic_rcpu_sw_prog_intr[0]=(((r).icfg_cmic_rcpu_sw_prog_intr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_CORTEXM0_U3f_GET(r) ((((r).icfg_cmic_rcpu_sw_prog_intr[0]) >> 11) & 0x1)
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_CORTEXM0_U3f_SET(r,f) (r).icfg_cmic_rcpu_sw_prog_intr[0]=(((r).icfg_cmic_rcpu_sw_prog_intr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_CMIC_RCPUf_GET(r) ((((r).icfg_cmic_rcpu_sw_prog_intr[0]) >> 12) & 0x1)
#define ICFG_CMIC_RCPU_SW_PROG_INTRr_CMIC_RCPUf_SET(r,f) (r).icfg_cmic_rcpu_sw_prog_intr[0]=(((r).icfg_cmic_rcpu_sw_prog_intr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access ICFG_CMIC_RCPU_SW_PROG_INTR.
 */
#define READ_ICFG_CMIC_RCPU_SW_PROG_INTRr(u,r) BCMDRD_IPROC_READ(u,ICFG_CMIC_RCPU_SW_PROG_INTRr_OFFSET,r._icfg_cmic_rcpu_sw_prog_intr)
#define WRITE_ICFG_CMIC_RCPU_SW_PROG_INTRr(u,r) BCMDRD_IPROC_WRITE(u,ICFG_CMIC_RCPU_SW_PROG_INTRr_OFFSET,r._icfg_cmic_rcpu_sw_prog_intr)

/*******************************************************************************
 * End of 'ICFG_CMIC_RCPU_SW_PROG_INTRr'
 */




/*******************************************************************************
 * REGISTER:  ICFG_CortexM0_SW_PROG_INTR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CORTEXM0_SW_PROG_INTRr_OFFSET 0x03241790

#define ICFG_CORTEXM0_SW_PROG_INTRr_SIZE 4

/*
 * This structure should be used to declare and program ICFG_CortexM0_SW_PROG_INTR.
 */
typedef union ICFG_CORTEXM0_SW_PROG_INTRr_s {
    uint32_t v[1];
    uint32_t icfg_cortexm0_sw_prog_intr[1];
    uint32_t _icfg_cortexm0_sw_prog_intr;
} ICFG_CORTEXM0_SW_PROG_INTRr_t;

#define ICFG_CORTEXM0_SW_PROG_INTRr_CLR(r) (r).icfg_cortexm0_sw_prog_intr[0] = 0
#define ICFG_CORTEXM0_SW_PROG_INTRr_SET(r,d) (r).icfg_cortexm0_sw_prog_intr[0] = d
#define ICFG_CORTEXM0_SW_PROG_INTRr_GET(r) (r).icfg_cortexm0_sw_prog_intr[0]

/*
 * These macros can be used to access individual fields.
 */
#define ICFG_CORTEXM0_SW_PROG_INTRr_PCIEf_GET(r) (((r).icfg_cortexm0_sw_prog_intr[0]) & 0x1)
#define ICFG_CORTEXM0_SW_PROG_INTRr_PCIEf_SET(r,f) (r).icfg_cortexm0_sw_prog_intr[0]=(((r).icfg_cortexm0_sw_prog_intr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define ICFG_CORTEXM0_SW_PROG_INTRr_MHOST0f_GET(r) ((((r).icfg_cortexm0_sw_prog_intr[0]) >> 1) & 0x1)
#define ICFG_CORTEXM0_SW_PROG_INTRr_MHOST0f_SET(r,f) (r).icfg_cortexm0_sw_prog_intr[0]=(((r).icfg_cortexm0_sw_prog_intr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define ICFG_CORTEXM0_SW_PROG_INTRr_MHOST1f_GET(r) ((((r).icfg_cortexm0_sw_prog_intr[0]) >> 2) & 0x1)
#define ICFG_CORTEXM0_SW_PROG_INTRr_MHOST1f_SET(r,f) (r).icfg_cortexm0_sw_prog_intr[0]=(((r).icfg_cortexm0_sw_prog_intr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define ICFG_CORTEXM0_SW_PROG_INTRr_CORTEXM0_U0f_GET(r) ((((r).icfg_cortexm0_sw_prog_intr[0]) >> 8) & 0x1)
#define ICFG_CORTEXM0_SW_PROG_INTRr_CORTEXM0_U0f_SET(r,f) (r).icfg_cortexm0_sw_prog_intr[0]=(((r).icfg_cortexm0_sw_prog_intr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define ICFG_CORTEXM0_SW_PROG_INTRr_CORTEXM0_U1f_GET(r) ((((r).icfg_cortexm0_sw_prog_intr[0]) >> 9) & 0x1)
#define ICFG_CORTEXM0_SW_PROG_INTRr_CORTEXM0_U1f_SET(r,f) (r).icfg_cortexm0_sw_prog_intr[0]=(((r).icfg_cortexm0_sw_prog_intr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define ICFG_CORTEXM0_SW_PROG_INTRr_CORTEXM0_U2f_GET(r) ((((r).icfg_cortexm0_sw_prog_intr[0]) >> 10) & 0x1)
#define ICFG_CORTEXM0_SW_PROG_INTRr_CORTEXM0_U2f_SET(r,f) (r).icfg_cortexm0_sw_prog_intr[0]=(((r).icfg_cortexm0_sw_prog_intr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define ICFG_CORTEXM0_SW_PROG_INTRr_CORTEXM0_U3f_GET(r) ((((r).icfg_cortexm0_sw_prog_intr[0]) >> 11) & 0x1)
#define ICFG_CORTEXM0_SW_PROG_INTRr_CORTEXM0_U3f_SET(r,f) (r).icfg_cortexm0_sw_prog_intr[0]=(((r).icfg_cortexm0_sw_prog_intr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define ICFG_CORTEXM0_SW_PROG_INTRr_CMIC_RCPUf_GET(r) ((((r).icfg_cortexm0_sw_prog_intr[0]) >> 12) & 0x1)
#define ICFG_CORTEXM0_SW_PROG_INTRr_CMIC_RCPUf_SET(r,f) (r).icfg_cortexm0_sw_prog_intr[0]=(((r).icfg_cortexm0_sw_prog_intr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access ICFG_CortexM0_SW_PROG_INTR.
 */
#define READ_ICFG_CORTEXM0_SW_PROG_INTRr(u,i,r) BCMDRD_IPROC_READ(u,ICFG_CORTEXM0_SW_PROG_INTRr_OFFSET+(4*(i)),r._icfg_cortexm0_sw_prog_intr)
#define WRITE_ICFG_CORTEXM0_SW_PROG_INTRr(u,i,r) BCMDRD_IPROC_WRITE(u,ICFG_CORTEXM0_SW_PROG_INTRr_OFFSET+(4*(i)),r._icfg_cortexm0_sw_prog_intr)

/*******************************************************************************
 * End of 'ICFG_CORTEXM0_SW_PROG_INTRr'
 */




/*******************************************************************************
 * REGISTER:  ICFG_CortexM0_u0_SW_PROG_INTR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CORTEXM0_U0_SW_PROG_INTRr_OFFSET 0x03241790

#define ICFG_CORTEXM0_U0_SW_PROG_INTRr_SIZE 4

/* ICFG_CORTEXM0_U0_SW_PROG_INTRr is element of ICFG_CortexM0_SW_PROG_INTR */

/*******************************************************************************
 * REGISTER:  ICFG_CortexM0_u1_SW_PROG_INTR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CORTEXM0_U1_SW_PROG_INTRr_OFFSET 0x03241794

#define ICFG_CORTEXM0_U1_SW_PROG_INTRr_SIZE 4

/* ICFG_CORTEXM0_U1_SW_PROG_INTRr is element of ICFG_CortexM0_SW_PROG_INTR */

/*******************************************************************************
 * REGISTER:  ICFG_CortexM0_u2_SW_PROG_INTR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CORTEXM0_U2_SW_PROG_INTRr_OFFSET 0x03241798

#define ICFG_CORTEXM0_U2_SW_PROG_INTRr_SIZE 4

/* ICFG_CORTEXM0_U2_SW_PROG_INTRr is element of ICFG_CortexM0_SW_PROG_INTR */

/*******************************************************************************
 * REGISTER:  ICFG_CortexM0_u3_SW_PROG_INTR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_CORTEXM0_U3_SW_PROG_INTRr_OFFSET 0x0324179c

#define ICFG_CORTEXM0_U3_SW_PROG_INTRr_SIZE 4

/* ICFG_CORTEXM0_U3_SW_PROG_INTRr is element of ICFG_CortexM0_SW_PROG_INTR */

/*******************************************************************************
 * REGISTER:  ICFG_GEN_PURPOSE_REG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_GEN_PURPOSE_REGr_OFFSET 0x032417d4

#define ICFG_GEN_PURPOSE_REGr_SIZE 4

/*
 * This structure should be used to declare and program ICFG_GEN_PURPOSE_REG.
 */
typedef union ICFG_GEN_PURPOSE_REGr_s {
    uint32_t v[1];
    uint32_t icfg_gen_purpose_reg[1];
    uint32_t _icfg_gen_purpose_reg;
} ICFG_GEN_PURPOSE_REGr_t;

#define ICFG_GEN_PURPOSE_REGr_CLR(r) (r).icfg_gen_purpose_reg[0] = 0
#define ICFG_GEN_PURPOSE_REGr_SET(r,d) (r).icfg_gen_purpose_reg[0] = d
#define ICFG_GEN_PURPOSE_REGr_GET(r) (r).icfg_gen_purpose_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define ICFG_GEN_PURPOSE_REGr_DATAf_GET(r) ((r).icfg_gen_purpose_reg[0])
#define ICFG_GEN_PURPOSE_REGr_DATAf_SET(r,f) (r).icfg_gen_purpose_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access ICFG_GEN_PURPOSE_REG.
 */
#define READ_ICFG_GEN_PURPOSE_REGr(u,i,r) BCMDRD_IPROC_READ(u,ICFG_GEN_PURPOSE_REGr_OFFSET+(4*(i)),r._icfg_gen_purpose_reg)
#define WRITE_ICFG_GEN_PURPOSE_REGr(u,i,r) BCMDRD_IPROC_WRITE(u,ICFG_GEN_PURPOSE_REGr_OFFSET+(4*(i)),r._icfg_gen_purpose_reg)

/*******************************************************************************
 * End of 'ICFG_GEN_PURPOSE_REGr'
 */




/*******************************************************************************
 * REGISTER:  ICFG_MHOST0_SW_PROG_INTR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_MHOST0_SW_PROG_INTRr_OFFSET 0x03241788

#define ICFG_MHOST0_SW_PROG_INTRr_SIZE 4

/*
 * This structure should be used to declare and program ICFG_MHOST0_SW_PROG_INTR.
 */
typedef union ICFG_MHOST0_SW_PROG_INTRr_s {
    uint32_t v[1];
    uint32_t icfg_mhost0_sw_prog_intr[1];
    uint32_t _icfg_mhost0_sw_prog_intr;
} ICFG_MHOST0_SW_PROG_INTRr_t;

#define ICFG_MHOST0_SW_PROG_INTRr_CLR(r) (r).icfg_mhost0_sw_prog_intr[0] = 0
#define ICFG_MHOST0_SW_PROG_INTRr_SET(r,d) (r).icfg_mhost0_sw_prog_intr[0] = d
#define ICFG_MHOST0_SW_PROG_INTRr_GET(r) (r).icfg_mhost0_sw_prog_intr[0]

/*
 * These macros can be used to access individual fields.
 */
#define ICFG_MHOST0_SW_PROG_INTRr_PCIEf_GET(r) (((r).icfg_mhost0_sw_prog_intr[0]) & 0x1)
#define ICFG_MHOST0_SW_PROG_INTRr_PCIEf_SET(r,f) (r).icfg_mhost0_sw_prog_intr[0]=(((r).icfg_mhost0_sw_prog_intr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define ICFG_MHOST0_SW_PROG_INTRr_MHOST0f_GET(r) ((((r).icfg_mhost0_sw_prog_intr[0]) >> 1) & 0x1)
#define ICFG_MHOST0_SW_PROG_INTRr_MHOST0f_SET(r,f) (r).icfg_mhost0_sw_prog_intr[0]=(((r).icfg_mhost0_sw_prog_intr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define ICFG_MHOST0_SW_PROG_INTRr_MHOST1f_GET(r) ((((r).icfg_mhost0_sw_prog_intr[0]) >> 2) & 0x1)
#define ICFG_MHOST0_SW_PROG_INTRr_MHOST1f_SET(r,f) (r).icfg_mhost0_sw_prog_intr[0]=(((r).icfg_mhost0_sw_prog_intr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define ICFG_MHOST0_SW_PROG_INTRr_CORTEXM0_U0f_GET(r) ((((r).icfg_mhost0_sw_prog_intr[0]) >> 8) & 0x1)
#define ICFG_MHOST0_SW_PROG_INTRr_CORTEXM0_U0f_SET(r,f) (r).icfg_mhost0_sw_prog_intr[0]=(((r).icfg_mhost0_sw_prog_intr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define ICFG_MHOST0_SW_PROG_INTRr_CORTEXM0_U1f_GET(r) ((((r).icfg_mhost0_sw_prog_intr[0]) >> 9) & 0x1)
#define ICFG_MHOST0_SW_PROG_INTRr_CORTEXM0_U1f_SET(r,f) (r).icfg_mhost0_sw_prog_intr[0]=(((r).icfg_mhost0_sw_prog_intr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define ICFG_MHOST0_SW_PROG_INTRr_CORTEXM0_U2f_GET(r) ((((r).icfg_mhost0_sw_prog_intr[0]) >> 10) & 0x1)
#define ICFG_MHOST0_SW_PROG_INTRr_CORTEXM0_U2f_SET(r,f) (r).icfg_mhost0_sw_prog_intr[0]=(((r).icfg_mhost0_sw_prog_intr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define ICFG_MHOST0_SW_PROG_INTRr_CORTEXM0_U3f_GET(r) ((((r).icfg_mhost0_sw_prog_intr[0]) >> 11) & 0x1)
#define ICFG_MHOST0_SW_PROG_INTRr_CORTEXM0_U3f_SET(r,f) (r).icfg_mhost0_sw_prog_intr[0]=(((r).icfg_mhost0_sw_prog_intr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define ICFG_MHOST0_SW_PROG_INTRr_CMIC_RCPUf_GET(r) ((((r).icfg_mhost0_sw_prog_intr[0]) >> 12) & 0x1)
#define ICFG_MHOST0_SW_PROG_INTRr_CMIC_RCPUf_SET(r,f) (r).icfg_mhost0_sw_prog_intr[0]=(((r).icfg_mhost0_sw_prog_intr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access ICFG_MHOST0_SW_PROG_INTR.
 */
#define READ_ICFG_MHOST0_SW_PROG_INTRr(u,r) BCMDRD_IPROC_READ(u,ICFG_MHOST0_SW_PROG_INTRr_OFFSET,r._icfg_mhost0_sw_prog_intr)
#define WRITE_ICFG_MHOST0_SW_PROG_INTRr(u,r) BCMDRD_IPROC_WRITE(u,ICFG_MHOST0_SW_PROG_INTRr_OFFSET,r._icfg_mhost0_sw_prog_intr)

/*******************************************************************************
 * End of 'ICFG_MHOST0_SW_PROG_INTRr'
 */




/*******************************************************************************
 * REGISTER:  ICFG_MHOST1_SW_PROG_INTR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_MHOST1_SW_PROG_INTRr_OFFSET 0x0324178c

#define ICFG_MHOST1_SW_PROG_INTRr_SIZE 4

/*
 * This structure should be used to declare and program ICFG_MHOST1_SW_PROG_INTR.
 */
typedef union ICFG_MHOST1_SW_PROG_INTRr_s {
    uint32_t v[1];
    uint32_t icfg_mhost1_sw_prog_intr[1];
    uint32_t _icfg_mhost1_sw_prog_intr;
} ICFG_MHOST1_SW_PROG_INTRr_t;

#define ICFG_MHOST1_SW_PROG_INTRr_CLR(r) (r).icfg_mhost1_sw_prog_intr[0] = 0
#define ICFG_MHOST1_SW_PROG_INTRr_SET(r,d) (r).icfg_mhost1_sw_prog_intr[0] = d
#define ICFG_MHOST1_SW_PROG_INTRr_GET(r) (r).icfg_mhost1_sw_prog_intr[0]

/*
 * These macros can be used to access individual fields.
 */
#define ICFG_MHOST1_SW_PROG_INTRr_PCIEf_GET(r) (((r).icfg_mhost1_sw_prog_intr[0]) & 0x1)
#define ICFG_MHOST1_SW_PROG_INTRr_PCIEf_SET(r,f) (r).icfg_mhost1_sw_prog_intr[0]=(((r).icfg_mhost1_sw_prog_intr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define ICFG_MHOST1_SW_PROG_INTRr_MHOST0f_GET(r) ((((r).icfg_mhost1_sw_prog_intr[0]) >> 1) & 0x1)
#define ICFG_MHOST1_SW_PROG_INTRr_MHOST0f_SET(r,f) (r).icfg_mhost1_sw_prog_intr[0]=(((r).icfg_mhost1_sw_prog_intr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define ICFG_MHOST1_SW_PROG_INTRr_MHOST1f_GET(r) ((((r).icfg_mhost1_sw_prog_intr[0]) >> 2) & 0x1)
#define ICFG_MHOST1_SW_PROG_INTRr_MHOST1f_SET(r,f) (r).icfg_mhost1_sw_prog_intr[0]=(((r).icfg_mhost1_sw_prog_intr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define ICFG_MHOST1_SW_PROG_INTRr_CORTEXM0_U0f_GET(r) ((((r).icfg_mhost1_sw_prog_intr[0]) >> 8) & 0x1)
#define ICFG_MHOST1_SW_PROG_INTRr_CORTEXM0_U0f_SET(r,f) (r).icfg_mhost1_sw_prog_intr[0]=(((r).icfg_mhost1_sw_prog_intr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define ICFG_MHOST1_SW_PROG_INTRr_CORTEXM0_U1f_GET(r) ((((r).icfg_mhost1_sw_prog_intr[0]) >> 9) & 0x1)
#define ICFG_MHOST1_SW_PROG_INTRr_CORTEXM0_U1f_SET(r,f) (r).icfg_mhost1_sw_prog_intr[0]=(((r).icfg_mhost1_sw_prog_intr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define ICFG_MHOST1_SW_PROG_INTRr_CORTEXM0_U2f_GET(r) ((((r).icfg_mhost1_sw_prog_intr[0]) >> 10) & 0x1)
#define ICFG_MHOST1_SW_PROG_INTRr_CORTEXM0_U2f_SET(r,f) (r).icfg_mhost1_sw_prog_intr[0]=(((r).icfg_mhost1_sw_prog_intr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define ICFG_MHOST1_SW_PROG_INTRr_CORTEXM0_U3f_GET(r) ((((r).icfg_mhost1_sw_prog_intr[0]) >> 11) & 0x1)
#define ICFG_MHOST1_SW_PROG_INTRr_CORTEXM0_U3f_SET(r,f) (r).icfg_mhost1_sw_prog_intr[0]=(((r).icfg_mhost1_sw_prog_intr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define ICFG_MHOST1_SW_PROG_INTRr_CMIC_RCPUf_GET(r) ((((r).icfg_mhost1_sw_prog_intr[0]) >> 12) & 0x1)
#define ICFG_MHOST1_SW_PROG_INTRr_CMIC_RCPUf_SET(r,f) (r).icfg_mhost1_sw_prog_intr[0]=(((r).icfg_mhost1_sw_prog_intr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access ICFG_MHOST1_SW_PROG_INTR.
 */
#define READ_ICFG_MHOST1_SW_PROG_INTRr(u,r) BCMDRD_IPROC_READ(u,ICFG_MHOST1_SW_PROG_INTRr_OFFSET,r._icfg_mhost1_sw_prog_intr)
#define WRITE_ICFG_MHOST1_SW_PROG_INTRr(u,r) BCMDRD_IPROC_WRITE(u,ICFG_MHOST1_SW_PROG_INTRr_OFFSET,r._icfg_mhost1_sw_prog_intr)

/*******************************************************************************
 * End of 'ICFG_MHOST1_SW_PROG_INTRr'
 */




/*******************************************************************************
 * REGISTER:  ICFG_PCIE_SW_PROG_INTR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define ICFG_PCIE_SW_PROG_INTRr_OFFSET 0x03241784

#define ICFG_PCIE_SW_PROG_INTRr_SIZE 4

/*
 * This structure should be used to declare and program ICFG_PCIE_SW_PROG_INTR.
 */
typedef union ICFG_PCIE_SW_PROG_INTRr_s {
    uint32_t v[1];
    uint32_t icfg_pcie_sw_prog_intr[1];
    uint32_t _icfg_pcie_sw_prog_intr;
} ICFG_PCIE_SW_PROG_INTRr_t;

#define ICFG_PCIE_SW_PROG_INTRr_CLR(r) (r).icfg_pcie_sw_prog_intr[0] = 0
#define ICFG_PCIE_SW_PROG_INTRr_SET(r,d) (r).icfg_pcie_sw_prog_intr[0] = d
#define ICFG_PCIE_SW_PROG_INTRr_GET(r) (r).icfg_pcie_sw_prog_intr[0]

/*
 * These macros can be used to access individual fields.
 */
#define ICFG_PCIE_SW_PROG_INTRr_PCIEf_GET(r) (((r).icfg_pcie_sw_prog_intr[0]) & 0x1)
#define ICFG_PCIE_SW_PROG_INTRr_PCIEf_SET(r,f) (r).icfg_pcie_sw_prog_intr[0]=(((r).icfg_pcie_sw_prog_intr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define ICFG_PCIE_SW_PROG_INTRr_MHOST0f_GET(r) ((((r).icfg_pcie_sw_prog_intr[0]) >> 1) & 0x1)
#define ICFG_PCIE_SW_PROG_INTRr_MHOST0f_SET(r,f) (r).icfg_pcie_sw_prog_intr[0]=(((r).icfg_pcie_sw_prog_intr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define ICFG_PCIE_SW_PROG_INTRr_MHOST1f_GET(r) ((((r).icfg_pcie_sw_prog_intr[0]) >> 2) & 0x1)
#define ICFG_PCIE_SW_PROG_INTRr_MHOST1f_SET(r,f) (r).icfg_pcie_sw_prog_intr[0]=(((r).icfg_pcie_sw_prog_intr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define ICFG_PCIE_SW_PROG_INTRr_CORTEXM0_U0f_GET(r) ((((r).icfg_pcie_sw_prog_intr[0]) >> 8) & 0x1)
#define ICFG_PCIE_SW_PROG_INTRr_CORTEXM0_U0f_SET(r,f) (r).icfg_pcie_sw_prog_intr[0]=(((r).icfg_pcie_sw_prog_intr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define ICFG_PCIE_SW_PROG_INTRr_CORTEXM0_U1f_GET(r) ((((r).icfg_pcie_sw_prog_intr[0]) >> 9) & 0x1)
#define ICFG_PCIE_SW_PROG_INTRr_CORTEXM0_U1f_SET(r,f) (r).icfg_pcie_sw_prog_intr[0]=(((r).icfg_pcie_sw_prog_intr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define ICFG_PCIE_SW_PROG_INTRr_CORTEXM0_U2f_GET(r) ((((r).icfg_pcie_sw_prog_intr[0]) >> 10) & 0x1)
#define ICFG_PCIE_SW_PROG_INTRr_CORTEXM0_U2f_SET(r,f) (r).icfg_pcie_sw_prog_intr[0]=(((r).icfg_pcie_sw_prog_intr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define ICFG_PCIE_SW_PROG_INTRr_CORTEXM0_U3f_GET(r) ((((r).icfg_pcie_sw_prog_intr[0]) >> 11) & 0x1)
#define ICFG_PCIE_SW_PROG_INTRr_CORTEXM0_U3f_SET(r,f) (r).icfg_pcie_sw_prog_intr[0]=(((r).icfg_pcie_sw_prog_intr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define ICFG_PCIE_SW_PROG_INTRr_CMIC_RCPUf_GET(r) ((((r).icfg_pcie_sw_prog_intr[0]) >> 12) & 0x1)
#define ICFG_PCIE_SW_PROG_INTRr_CMIC_RCPUf_SET(r,f) (r).icfg_pcie_sw_prog_intr[0]=(((r).icfg_pcie_sw_prog_intr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access ICFG_PCIE_SW_PROG_INTR.
 */
#define READ_ICFG_PCIE_SW_PROG_INTRr(u,r) BCMDRD_IPROC_READ(u,ICFG_PCIE_SW_PROG_INTRr_OFFSET,r._icfg_pcie_sw_prog_intr)
#define WRITE_ICFG_PCIE_SW_PROG_INTRr(u,r) BCMDRD_IPROC_WRITE(u,ICFG_PCIE_SW_PROG_INTRr_OFFSET,r._icfg_pcie_sw_prog_intr)

/*******************************************************************************
 * End of 'ICFG_PCIE_SW_PROG_INTRr'
 */




/*******************************************************************************
 * REGISTER:  INTC_INTR_ENABLE_REG0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_ENABLE_REG0r_OFFSET 0x180130f0

#define INTC_INTR_ENABLE_REG0r_SIZE 4

/* INTC_INTR_ENABLE_REG0r is element of INTC_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_ENABLE_REG1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_ENABLE_REG1r_OFFSET 0x180130f4

#define INTC_INTR_ENABLE_REG1r_SIZE 4

/* INTC_INTR_ENABLE_REG1r is element of INTC_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_ENABLE_REG2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_ENABLE_REG2r_OFFSET 0x180130f8

#define INTC_INTR_ENABLE_REG2r_SIZE 4

/* INTC_INTR_ENABLE_REG2r is element of INTC_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_ENABLE_REG3
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_ENABLE_REG3r_OFFSET 0x180130fc

#define INTC_INTR_ENABLE_REG3r_SIZE 4

/* INTC_INTR_ENABLE_REG3r is element of INTC_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_ENABLE_REG4
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_ENABLE_REG4r_OFFSET 0x18013100

#define INTC_INTR_ENABLE_REG4r_SIZE 4

/* INTC_INTR_ENABLE_REG4r is element of INTC_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_ENABLE_REG5
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_ENABLE_REG5r_OFFSET 0x18013104

#define INTC_INTR_ENABLE_REG5r_SIZE 4

/* INTC_INTR_ENABLE_REG5r is element of INTC_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_ENABLE_REG6
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_ENABLE_REG6r_OFFSET 0x18013108

#define INTC_INTR_ENABLE_REG6r_SIZE 4

/* INTC_INTR_ENABLE_REG6r is element of INTC_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_ENABLE_REG7
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_ENABLE_REG7r_OFFSET 0x1801310c

#define INTC_INTR_ENABLE_REG7r_SIZE 4

/* INTC_INTR_ENABLE_REG7r is element of INTC_INTR_ENABLE_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_ENABLE_REG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_ENABLE_REGr_OFFSET 0x180130f0

#define INTC_INTR_ENABLE_REGr_SIZE 4

/*
 * This structure should be used to declare and program INTC_INTR_ENABLE_REG.
 */
typedef union INTC_INTR_ENABLE_REGr_s {
    uint32_t v[1];
    uint32_t intc_intr_enable_reg[1];
    uint32_t _intc_intr_enable_reg;
} INTC_INTR_ENABLE_REGr_t;

#define INTC_INTR_ENABLE_REGr_CLR(r) (r).intc_intr_enable_reg[0] = 0
#define INTC_INTR_ENABLE_REGr_SET(r,d) (r).intc_intr_enable_reg[0] = d
#define INTC_INTR_ENABLE_REGr_GET(r) (r).intc_intr_enable_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define INTC_INTR_ENABLE_REGr_B31_TO_0f_GET(r) ((r).intc_intr_enable_reg[0])
#define INTC_INTR_ENABLE_REGr_B31_TO_0f_SET(r,f) (r).intc_intr_enable_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access INTC_INTR_ENABLE_REG.
 */
#define READ_INTC_INTR_ENABLE_REGr(u,i,r) BCMDRD_IPROC_READ(u,INTC_INTR_ENABLE_REGr_OFFSET+(4*(i)),r._intc_intr_enable_reg)
#define WRITE_INTC_INTR_ENABLE_REGr(u,i,r) BCMDRD_IPROC_WRITE(u,INTC_INTR_ENABLE_REGr_OFFSET+(4*(i)),r._intc_intr_enable_reg)

/*******************************************************************************
 * End of 'INTC_INTR_ENABLE_REGr'
 */




/*******************************************************************************
 * REGISTER:  INTC_INTR_RAW_STATUS_REG0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_RAW_STATUS_REG0r_OFFSET 0x18013140

#define INTC_INTR_RAW_STATUS_REG0r_SIZE 4

/* INTC_INTR_RAW_STATUS_REG0r is element of INTC_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_RAW_STATUS_REG1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_RAW_STATUS_REG1r_OFFSET 0x18013144

#define INTC_INTR_RAW_STATUS_REG1r_SIZE 4

/* INTC_INTR_RAW_STATUS_REG1r is element of INTC_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_RAW_STATUS_REG2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_RAW_STATUS_REG2r_OFFSET 0x18013148

#define INTC_INTR_RAW_STATUS_REG2r_SIZE 4

/* INTC_INTR_RAW_STATUS_REG2r is element of INTC_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_RAW_STATUS_REG3
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_RAW_STATUS_REG3r_OFFSET 0x1801314c

#define INTC_INTR_RAW_STATUS_REG3r_SIZE 4

/* INTC_INTR_RAW_STATUS_REG3r is element of INTC_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_RAW_STATUS_REG4
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_RAW_STATUS_REG4r_OFFSET 0x18013150

#define INTC_INTR_RAW_STATUS_REG4r_SIZE 4

/* INTC_INTR_RAW_STATUS_REG4r is element of INTC_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_RAW_STATUS_REG5
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_RAW_STATUS_REG5r_OFFSET 0x18013154

#define INTC_INTR_RAW_STATUS_REG5r_SIZE 4

/* INTC_INTR_RAW_STATUS_REG5r is element of INTC_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_RAW_STATUS_REG6
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_RAW_STATUS_REG6r_OFFSET 0x18013158

#define INTC_INTR_RAW_STATUS_REG6r_SIZE 4

/* INTC_INTR_RAW_STATUS_REG6r is element of INTC_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_RAW_STATUS_REG7
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_RAW_STATUS_REG7r_OFFSET 0x1801315c

#define INTC_INTR_RAW_STATUS_REG7r_SIZE 4

/* INTC_INTR_RAW_STATUS_REG7r is element of INTC_INTR_RAW_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_RAW_STATUS_REG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_RAW_STATUS_REGr_OFFSET 0x18013140

#define INTC_INTR_RAW_STATUS_REGr_SIZE 4

/*
 * This structure should be used to declare and program INTC_INTR_RAW_STATUS_REG.
 */
typedef union INTC_INTR_RAW_STATUS_REGr_s {
    uint32_t v[1];
    uint32_t intc_intr_raw_status_reg[1];
    uint32_t _intc_intr_raw_status_reg;
} INTC_INTR_RAW_STATUS_REGr_t;

#define INTC_INTR_RAW_STATUS_REGr_CLR(r) (r).intc_intr_raw_status_reg[0] = 0
#define INTC_INTR_RAW_STATUS_REGr_SET(r,d) (r).intc_intr_raw_status_reg[0] = d
#define INTC_INTR_RAW_STATUS_REGr_GET(r) (r).intc_intr_raw_status_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define INTC_INTR_RAW_STATUS_REGr_B31_TO_0f_GET(r) ((r).intc_intr_raw_status_reg[0])
#define INTC_INTR_RAW_STATUS_REGr_B31_TO_0f_SET(r,f) (r).intc_intr_raw_status_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access INTC_INTR_RAW_STATUS_REG.
 */
#define READ_INTC_INTR_RAW_STATUS_REGr(u,i,r) BCMDRD_IPROC_READ(u,INTC_INTR_RAW_STATUS_REGr_OFFSET+(4*(i)),r._intc_intr_raw_status_reg)
#define WRITE_INTC_INTR_RAW_STATUS_REGr(u,i,r) BCMDRD_IPROC_WRITE(u,INTC_INTR_RAW_STATUS_REGr_OFFSET+(4*(i)),r._intc_intr_raw_status_reg)

/*******************************************************************************
 * End of 'INTC_INTR_RAW_STATUS_REGr'
 */




/*******************************************************************************
 * REGISTER:  INTC_INTR_STATUS_REG0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_STATUS_REG0r_OFFSET 0x18013190

#define INTC_INTR_STATUS_REG0r_SIZE 4

/* INTC_INTR_STATUS_REG0r is element of INTC_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_STATUS_REG1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_STATUS_REG1r_OFFSET 0x18013194

#define INTC_INTR_STATUS_REG1r_SIZE 4

/* INTC_INTR_STATUS_REG1r is element of INTC_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_STATUS_REG2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_STATUS_REG2r_OFFSET 0x18013198

#define INTC_INTR_STATUS_REG2r_SIZE 4

/* INTC_INTR_STATUS_REG2r is element of INTC_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_STATUS_REG3
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_STATUS_REG3r_OFFSET 0x1801319c

#define INTC_INTR_STATUS_REG3r_SIZE 4

/* INTC_INTR_STATUS_REG3r is element of INTC_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_STATUS_REG4
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_STATUS_REG4r_OFFSET 0x180131a0

#define INTC_INTR_STATUS_REG4r_SIZE 4

/* INTC_INTR_STATUS_REG4r is element of INTC_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_STATUS_REG5
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_STATUS_REG5r_OFFSET 0x180131a4

#define INTC_INTR_STATUS_REG5r_SIZE 4

/* INTC_INTR_STATUS_REG5r is element of INTC_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_STATUS_REG6
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_STATUS_REG6r_OFFSET 0x180131a8

#define INTC_INTR_STATUS_REG6r_SIZE 4

/* INTC_INTR_STATUS_REG6r is element of INTC_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_STATUS_REG7
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_STATUS_REG7r_OFFSET 0x180131ac

#define INTC_INTR_STATUS_REG7r_SIZE 4

/* INTC_INTR_STATUS_REG7r is element of INTC_INTR_STATUS_REG */

/*******************************************************************************
 * REGISTER:  INTC_INTR_STATUS_REG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define INTC_INTR_STATUS_REGr_OFFSET 0x18013190

#define INTC_INTR_STATUS_REGr_SIZE 4

/*
 * This structure should be used to declare and program INTC_INTR_STATUS_REG.
 */
typedef union INTC_INTR_STATUS_REGr_s {
    uint32_t v[1];
    uint32_t intc_intr_status_reg[1];
    uint32_t _intc_intr_status_reg;
} INTC_INTR_STATUS_REGr_t;

#define INTC_INTR_STATUS_REGr_CLR(r) (r).intc_intr_status_reg[0] = 0
#define INTC_INTR_STATUS_REGr_SET(r,d) (r).intc_intr_status_reg[0] = d
#define INTC_INTR_STATUS_REGr_GET(r) (r).intc_intr_status_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define INTC_INTR_STATUS_REGr_B31_TO_0f_GET(r) ((r).intc_intr_status_reg[0])
#define INTC_INTR_STATUS_REGr_B31_TO_0f_SET(r,f) (r).intc_intr_status_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access INTC_INTR_STATUS_REG.
 */
#define READ_INTC_INTR_STATUS_REGr(u,i,r) BCMDRD_IPROC_READ(u,INTC_INTR_STATUS_REGr_OFFSET+(4*(i)),r._intc_intr_status_reg)
#define WRITE_INTC_INTR_STATUS_REGr(u,i,r) BCMDRD_IPROC_WRITE(u,INTC_INTR_STATUS_REGr_OFFSET+(4*(i)),r._intc_intr_status_reg)

/*******************************************************************************
 * End of 'INTC_INTR_STATUS_REGr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_CH0_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH0_ADDRESSr_OFFSET 0x01319008

#define MIIM_CH0_ADDRESSr_SIZE 4

/* MIIM_CH0_ADDRESSr is element of MIIM_CH_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_CH0_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH0_CONTROLr_OFFSET 0x01319000

#define MIIM_CH0_CONTROLr_SIZE 4

/* MIIM_CH0_CONTROLr is element of MIIM_CH_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_CH0_PARAMS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH0_PARAMSr_OFFSET 0x01319004

#define MIIM_CH0_PARAMSr_SIZE 4

/* MIIM_CH0_PARAMSr is element of MIIM_CH_PARAMS */

/*******************************************************************************
 * REGISTER:  MIIM_CH0_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH0_STATUSr_OFFSET 0x0131900c

#define MIIM_CH0_STATUSr_SIZE 4

/* MIIM_CH0_STATUSr is element of MIIM_CH_STATUS */

/*******************************************************************************
 * REGISTER:  MIIM_CH1_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH1_ADDRESSr_OFFSET 0x01319018

#define MIIM_CH1_ADDRESSr_SIZE 4

/* MIIM_CH1_ADDRESSr is element of MIIM_CH_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_CH1_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH1_CONTROLr_OFFSET 0x01319010

#define MIIM_CH1_CONTROLr_SIZE 4

/* MIIM_CH1_CONTROLr is element of MIIM_CH_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_CH1_PARAMS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH1_PARAMSr_OFFSET 0x01319014

#define MIIM_CH1_PARAMSr_SIZE 4

/* MIIM_CH1_PARAMSr is element of MIIM_CH_PARAMS */

/*******************************************************************************
 * REGISTER:  MIIM_CH1_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH1_STATUSr_OFFSET 0x0131901c

#define MIIM_CH1_STATUSr_SIZE 4

/* MIIM_CH1_STATUSr is element of MIIM_CH_STATUS */

/*******************************************************************************
 * REGISTER:  MIIM_CH2_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH2_ADDRESSr_OFFSET 0x01319028

#define MIIM_CH2_ADDRESSr_SIZE 4

/* MIIM_CH2_ADDRESSr is element of MIIM_CH_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_CH2_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH2_CONTROLr_OFFSET 0x01319020

#define MIIM_CH2_CONTROLr_SIZE 4

/* MIIM_CH2_CONTROLr is element of MIIM_CH_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_CH2_PARAMS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH2_PARAMSr_OFFSET 0x01319024

#define MIIM_CH2_PARAMSr_SIZE 4

/* MIIM_CH2_PARAMSr is element of MIIM_CH_PARAMS */

/*******************************************************************************
 * REGISTER:  MIIM_CH2_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH2_STATUSr_OFFSET 0x0131902c

#define MIIM_CH2_STATUSr_SIZE 4

/* MIIM_CH2_STATUSr is element of MIIM_CH_STATUS */

/*******************************************************************************
 * REGISTER:  MIIM_CH3_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH3_ADDRESSr_OFFSET 0x01319038

#define MIIM_CH3_ADDRESSr_SIZE 4

/* MIIM_CH3_ADDRESSr is element of MIIM_CH_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_CH3_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH3_CONTROLr_OFFSET 0x01319030

#define MIIM_CH3_CONTROLr_SIZE 4

/* MIIM_CH3_CONTROLr is element of MIIM_CH_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_CH3_PARAMS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH3_PARAMSr_OFFSET 0x01319034

#define MIIM_CH3_PARAMSr_SIZE 4

/* MIIM_CH3_PARAMSr is element of MIIM_CH_PARAMS */

/*******************************************************************************
 * REGISTER:  MIIM_CH3_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH3_STATUSr_OFFSET 0x0131903c

#define MIIM_CH3_STATUSr_SIZE 4

/* MIIM_CH3_STATUSr is element of MIIM_CH_STATUS */

/*******************************************************************************
 * REGISTER:  MIIM_CH_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH_ADDRESSr_OFFSET 0x01319008

#define MIIM_CH_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_CH_ADDRESS.
 */
typedef union MIIM_CH_ADDRESSr_s {
    uint32_t v[1];
    uint32_t miim_ch_address[1];
    uint32_t _miim_ch_address;
} MIIM_CH_ADDRESSr_t;

#define MIIM_CH_ADDRESSr_CLR(r) (r).miim_ch_address[0] = 0
#define MIIM_CH_ADDRESSr_SET(r,d) (r).miim_ch_address[0] = d
#define MIIM_CH_ADDRESSr_GET(r) (r).miim_ch_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_CH_ADDRESSr_PHY_IDf_GET(r) ((((r).miim_ch_address[0]) >> 6) & 0x1f)
#define MIIM_CH_ADDRESSr_PHY_IDf_SET(r,f) (r).miim_ch_address[0]=(((r).miim_ch_address[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define MIIM_CH_ADDRESSr_CLAUSE_22_REGADRR_OR_45_DTYPEf_GET(r) ((((r).miim_ch_address[0]) >> 11) & 0x1f)
#define MIIM_CH_ADDRESSr_CLAUSE_22_REGADRR_OR_45_DTYPEf_SET(r,f) (r).miim_ch_address[0]=(((r).miim_ch_address[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define MIIM_CH_ADDRESSr_CLAUSE_45_REG_ADRRf_GET(r) ((((r).miim_ch_address[0]) >> 16) & 0xffff)
#define MIIM_CH_ADDRESSr_CLAUSE_45_REG_ADRRf_SET(r,f) (r).miim_ch_address[0]=(((r).miim_ch_address[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MIIM_CH_ADDRESS.
 */
#define READ_MIIM_CH_ADDRESSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_CH_ADDRESSr_OFFSET+(4*(i)*4),r._miim_ch_address)
#define WRITE_MIIM_CH_ADDRESSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_CH_ADDRESSr_OFFSET+(4*(i)*4),r._miim_ch_address)

/*******************************************************************************
 * End of 'MIIM_CH_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_CH_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH_CONTROLr_OFFSET 0x01319000

#define MIIM_CH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_CH_CONTROL.
 */
typedef union MIIM_CH_CONTROLr_s {
    uint32_t v[1];
    uint32_t miim_ch_control[1];
    uint32_t _miim_ch_control;
} MIIM_CH_CONTROLr_t;

#define MIIM_CH_CONTROLr_CLR(r) (r).miim_ch_control[0] = 0
#define MIIM_CH_CONTROLr_SET(r,d) (r).miim_ch_control[0] = d
#define MIIM_CH_CONTROLr_GET(r) (r).miim_ch_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_CH_CONTROLr_STARTf_GET(r) (((r).miim_ch_control[0]) & 0x1)
#define MIIM_CH_CONTROLr_STARTf_SET(r,f) (r).miim_ch_control[0]=(((r).miim_ch_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MIIM_CH_CONTROL.
 */
#define READ_MIIM_CH_CONTROLr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_CH_CONTROLr_OFFSET+(4*(i)*4),r._miim_ch_control)
#define WRITE_MIIM_CH_CONTROLr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_CH_CONTROLr_OFFSET+(4*(i)*4),r._miim_ch_control)

/*******************************************************************************
 * End of 'MIIM_CH_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_CH_PARAMS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH_PARAMSr_OFFSET 0x01319004

#define MIIM_CH_PARAMSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_CH_PARAMS.
 */
typedef union MIIM_CH_PARAMSr_s {
    uint32_t v[1];
    uint32_t miim_ch_params[1];
    uint32_t _miim_ch_params;
} MIIM_CH_PARAMSr_t;

#define MIIM_CH_PARAMSr_CLR(r) (r).miim_ch_params[0] = 0
#define MIIM_CH_PARAMSr_SET(r,d) (r).miim_ch_params[0] = d
#define MIIM_CH_PARAMSr_GET(r) (r).miim_ch_params[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_CH_PARAMSr_PHY_WR_DATAf_GET(r) (((r).miim_ch_params[0]) & 0xffff)
#define MIIM_CH_PARAMSr_PHY_WR_DATAf_SET(r,f) (r).miim_ch_params[0]=(((r).miim_ch_params[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define MIIM_CH_PARAMSr_SEL_INT_PHYf_GET(r) ((((r).miim_ch_params[0]) >> 16) & 0x1)
#define MIIM_CH_PARAMSr_SEL_INT_PHYf_SET(r,f) (r).miim_ch_params[0]=(((r).miim_ch_params[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define MIIM_CH_PARAMSr_MDIO_OP_TYPEf_GET(r) ((((r).miim_ch_params[0]) >> 17) & 0x7)
#define MIIM_CH_PARAMSr_MDIO_OP_TYPEf_SET(r,f) (r).miim_ch_params[0]=(((r).miim_ch_params[0] & ~((uint32_t)0x7 << 17)) | ((((uint32_t)f) & 0x7) << 17))
#define MIIM_CH_PARAMSr_RING_MAPf_GET(r) ((((r).miim_ch_params[0]) >> 20) & 0xfff)
#define MIIM_CH_PARAMSr_RING_MAPf_SET(r,f) (r).miim_ch_params[0]=(((r).miim_ch_params[0] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))

/*
 * These macros can be used to access MIIM_CH_PARAMS.
 */
#define READ_MIIM_CH_PARAMSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_CH_PARAMSr_OFFSET+(4*(i)*4),r._miim_ch_params)
#define WRITE_MIIM_CH_PARAMSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_CH_PARAMSr_OFFSET+(4*(i)*4),r._miim_ch_params)

/*******************************************************************************
 * End of 'MIIM_CH_PARAMSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_CH_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_CH_STATUSr_OFFSET 0x0131900c

#define MIIM_CH_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_CH_STATUS.
 */
typedef union MIIM_CH_STATUSr_s {
    uint32_t v[1];
    uint32_t miim_ch_status[1];
    uint32_t _miim_ch_status;
} MIIM_CH_STATUSr_t;

#define MIIM_CH_STATUSr_CLR(r) (r).miim_ch_status[0] = 0
#define MIIM_CH_STATUSr_SET(r,d) (r).miim_ch_status[0] = d
#define MIIM_CH_STATUSr_GET(r) (r).miim_ch_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_CH_STATUSr_PHY_RD_DATAf_GET(r) (((r).miim_ch_status[0]) & 0xffff)
#define MIIM_CH_STATUSr_PHY_RD_DATAf_SET(r,f) (r).miim_ch_status[0]=(((r).miim_ch_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define MIIM_CH_STATUSr_ACTIVEf_GET(r) ((((r).miim_ch_status[0]) >> 16) & 0x1)
#define MIIM_CH_STATUSr_ACTIVEf_SET(r,f) (r).miim_ch_status[0]=(((r).miim_ch_status[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define MIIM_CH_STATUSr_ERRORf_GET(r) ((((r).miim_ch_status[0]) >> 17) & 0x1)
#define MIIM_CH_STATUSr_ERRORf_SET(r,f) (r).miim_ch_status[0]=(((r).miim_ch_status[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define MIIM_CH_STATUSr_DONEf_GET(r) ((((r).miim_ch_status[0]) >> 18) & 0x1)
#define MIIM_CH_STATUSr_DONEf_SET(r,f) (r).miim_ch_status[0]=(((r).miim_ch_status[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access MIIM_CH_STATUS.
 */
#define READ_MIIM_CH_STATUSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_CH_STATUSr_OFFSET+(4*(i)*4),r._miim_ch_status)
#define WRITE_MIIM_CH_STATUSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_CH_STATUSr_OFFSET+(4*(i)*4),r._miim_ch_status)

/*******************************************************************************
 * End of 'MIIM_CH_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_COMMON_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_COMMON_CONTROLr_OFFSET 0x01319140

#define MIIM_COMMON_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_COMMON_CONTROL.
 */
typedef union MIIM_COMMON_CONTROLr_s {
    uint32_t v[1];
    uint32_t miim_common_control[1];
    uint32_t _miim_common_control;
} MIIM_COMMON_CONTROLr_t;

#define MIIM_COMMON_CONTROLr_CLR(r) (r).miim_common_control[0] = 0
#define MIIM_COMMON_CONTROLr_SET(r,d) (r).miim_common_control[0] = d
#define MIIM_COMMON_CONTROLr_GET(r) (r).miim_common_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_COMMON_CONTROLr_OVRD_EXT_MDIO_MSTR_CNTRLf_GET(r) (((r).miim_common_control[0]) & 0x1)
#define MIIM_COMMON_CONTROLr_OVRD_EXT_MDIO_MSTR_CNTRLf_SET(r,f) (r).miim_common_control[0]=(((r).miim_common_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MIIM_COMMON_CONTROL.
 */
#define READ_MIIM_COMMON_CONTROLr(u,r) BCMDRD_IPROC_READ(u,MIIM_COMMON_CONTROLr_OFFSET,r._miim_common_control)
#define WRITE_MIIM_COMMON_CONTROLr(u,r) BCMDRD_IPROC_WRITE(u,MIIM_COMMON_CONTROLr_OFFSET,r._miim_common_control)

/*******************************************************************************
 * End of 'MIIM_COMMON_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH0_CONFIG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH0_CONFIGr_OFFSET 0x01319050

#define MIIM_DMA_CH0_CONFIGr_SIZE 4

/* MIIM_DMA_CH0_CONFIGr is element of MIIM_DMA_CH_CONFIG */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH0_CURR_DST_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH0_CURR_DST_HOST_ADDRESSr_OFFSET 0x01319068

#define MIIM_DMA_CH0_CURR_DST_HOST_ADDRESSr_SIZE 4

/* MIIM_DMA_CH0_CURR_DST_HOST_ADDRESSr is element of MIIM_DMA_CH_CURR_DST_HOST_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH0_CURR_SRC_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH0_CURR_SRC_HOST_ADDRESSr_OFFSET 0x01319064

#define MIIM_DMA_CH0_CURR_SRC_HOST_ADDRESSr_SIZE 4

/* MIIM_DMA_CH0_CURR_SRC_HOST_ADDRESSr is element of MIIM_DMA_CH_CURR_SRC_HOST_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH0_DATA_ONLY_MODE_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH0_DATA_ONLY_MODE_ADDRESSr_OFFSET 0x01319058

#define MIIM_DMA_CH0_DATA_ONLY_MODE_ADDRESSr_SIZE 4

/* MIIM_DMA_CH0_DATA_ONLY_MODE_ADDRESSr is element of MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH0_DATA_ONLY_MODE_PARAMS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH0_DATA_ONLY_MODE_PARAMSr_OFFSET 0x01319054

#define MIIM_DMA_CH0_DATA_ONLY_MODE_PARAMSr_SIZE 4

/* MIIM_DMA_CH0_DATA_ONLY_MODE_PARAMSr is element of MIIM_DMA_CH_DATA_ONLY_MODE_PARAMS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH0_DST_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH0_DST_HOST_ADDRESSr_OFFSET 0x01319060

#define MIIM_DMA_CH0_DST_HOST_ADDRESSr_SIZE 4

/* MIIM_DMA_CH0_DST_HOST_ADDRESSr is element of MIIM_DMA_CH_DST_HOST_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH0_SRC_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH0_SRC_HOST_ADDRESSr_OFFSET 0x0131905c

#define MIIM_DMA_CH0_SRC_HOST_ADDRESSr_SIZE 4

/* MIIM_DMA_CH0_SRC_HOST_ADDRESSr is element of MIIM_DMA_CH_SRC_HOST_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH0_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH0_STATUSr_OFFSET 0x0131906c

#define MIIM_DMA_CH0_STATUSr_SIZE 4

/* MIIM_DMA_CH0_STATUSr is element of MIIM_DMA_CH_STATUS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH1_CONFIG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH1_CONFIGr_OFFSET 0x013190a0

#define MIIM_DMA_CH1_CONFIGr_SIZE 4

/* MIIM_DMA_CH1_CONFIGr is element of MIIM_DMA_CH_CONFIG */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH1_CURR_DST_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH1_CURR_DST_HOST_ADDRESSr_OFFSET 0x013190b8

#define MIIM_DMA_CH1_CURR_DST_HOST_ADDRESSr_SIZE 4

/* MIIM_DMA_CH1_CURR_DST_HOST_ADDRESSr is element of MIIM_DMA_CH_CURR_DST_HOST_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH1_CURR_SRC_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH1_CURR_SRC_HOST_ADDRESSr_OFFSET 0x013190b4

#define MIIM_DMA_CH1_CURR_SRC_HOST_ADDRESSr_SIZE 4

/* MIIM_DMA_CH1_CURR_SRC_HOST_ADDRESSr is element of MIIM_DMA_CH_CURR_SRC_HOST_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH1_DATA_ONLY_MODE_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH1_DATA_ONLY_MODE_ADDRESSr_OFFSET 0x013190a8

#define MIIM_DMA_CH1_DATA_ONLY_MODE_ADDRESSr_SIZE 4

/* MIIM_DMA_CH1_DATA_ONLY_MODE_ADDRESSr is element of MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH1_DATA_ONLY_MODE_PARAMS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH1_DATA_ONLY_MODE_PARAMSr_OFFSET 0x013190a4

#define MIIM_DMA_CH1_DATA_ONLY_MODE_PARAMSr_SIZE 4

/* MIIM_DMA_CH1_DATA_ONLY_MODE_PARAMSr is element of MIIM_DMA_CH_DATA_ONLY_MODE_PARAMS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH1_DST_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH1_DST_HOST_ADDRESSr_OFFSET 0x013190b0

#define MIIM_DMA_CH1_DST_HOST_ADDRESSr_SIZE 4

/* MIIM_DMA_CH1_DST_HOST_ADDRESSr is element of MIIM_DMA_CH_DST_HOST_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH1_SRC_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH1_SRC_HOST_ADDRESSr_OFFSET 0x013190ac

#define MIIM_DMA_CH1_SRC_HOST_ADDRESSr_SIZE 4

/* MIIM_DMA_CH1_SRC_HOST_ADDRESSr is element of MIIM_DMA_CH_SRC_HOST_ADDRESS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH1_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH1_STATUSr_OFFSET 0x013190bc

#define MIIM_DMA_CH1_STATUSr_SIZE 4

/* MIIM_DMA_CH1_STATUSr is element of MIIM_DMA_CH_STATUS */

/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH_CONFIG
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH_CONFIGr_OFFSET 0x01319050

#define MIIM_DMA_CH_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_DMA_CH_CONFIG.
 */
typedef union MIIM_DMA_CH_CONFIGr_s {
    uint32_t v[1];
    uint32_t miim_dma_ch_config[1];
    uint32_t _miim_dma_ch_config;
} MIIM_DMA_CH_CONFIGr_t;

#define MIIM_DMA_CH_CONFIGr_CLR(r) (r).miim_dma_ch_config[0] = 0
#define MIIM_DMA_CH_CONFIGr_SET(r,d) (r).miim_dma_ch_config[0] = d
#define MIIM_DMA_CH_CONFIGr_GET(r) (r).miim_dma_ch_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_DMA_CH_CONFIGr_STARTf_GET(r) (((r).miim_dma_ch_config[0]) & 0x1)
#define MIIM_DMA_CH_CONFIGr_STARTf_SET(r,f) (r).miim_dma_ch_config[0]=(((r).miim_dma_ch_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define MIIM_DMA_CH_CONFIGr_ABORTf_GET(r) ((((r).miim_dma_ch_config[0]) >> 3) & 0x1)
#define MIIM_DMA_CH_CONFIGr_ABORTf_SET(r,f) (r).miim_dma_ch_config[0]=(((r).miim_dma_ch_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define MIIM_DMA_CH_CONFIGr_DATA_ONLY_MODEf_GET(r) ((((r).miim_dma_ch_config[0]) >> 4) & 0x1)
#define MIIM_DMA_CH_CONFIGr_DATA_ONLY_MODEf_SET(r,f) (r).miim_dma_ch_config[0]=(((r).miim_dma_ch_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define MIIM_DMA_CH_CONFIGr_SRC_ENDIANESSf_GET(r) ((((r).miim_dma_ch_config[0]) >> 19) & 0x1)
#define MIIM_DMA_CH_CONFIGr_SRC_ENDIANESSf_SET(r,f) (r).miim_dma_ch_config[0]=(((r).miim_dma_ch_config[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define MIIM_DMA_CH_CONFIGr_DST_ENDIANESSf_GET(r) ((((r).miim_dma_ch_config[0]) >> 20) & 0x1)
#define MIIM_DMA_CH_CONFIGr_DST_ENDIANESSf_SET(r,f) (r).miim_dma_ch_config[0]=(((r).miim_dma_ch_config[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define MIIM_DMA_CH_CONFIGr_NUM_COMMANDSf_GET(r) ((((r).miim_dma_ch_config[0]) >> 21) & 0xff)
#define MIIM_DMA_CH_CONFIGr_NUM_COMMANDSf_SET(r,f) (r).miim_dma_ch_config[0]=(((r).miim_dma_ch_config[0] & ~((uint32_t)0xff << 21)) | ((((uint32_t)f) & 0xff) << 21))

/*
 * These macros can be used to access MIIM_DMA_CH_CONFIG.
 */
#define READ_MIIM_DMA_CH_CONFIGr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_DMA_CH_CONFIGr_OFFSET+(4*(i)*20),r._miim_dma_ch_config)
#define WRITE_MIIM_DMA_CH_CONFIGr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_DMA_CH_CONFIGr_OFFSET+(4*(i)*20),r._miim_dma_ch_config)

/*******************************************************************************
 * End of 'MIIM_DMA_CH_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH_CURR_DST_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr_OFFSET 0x01319068

#define MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_DMA_CH_CURR_DST_HOST_ADDRESS.
 */
typedef union MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr_s {
    uint32_t v[1];
    uint32_t miim_dma_ch_curr_dst_host_address[1];
    uint32_t _miim_dma_ch_curr_dst_host_address;
} MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr_t;

#define MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr_CLR(r) (r).miim_dma_ch_curr_dst_host_address[0] = 0
#define MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr_SET(r,d) (r).miim_dma_ch_curr_dst_host_address[0] = d
#define MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr_GET(r) (r).miim_dma_ch_curr_dst_host_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr_VALf_GET(r) ((r).miim_dma_ch_curr_dst_host_address[0])
#define MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr_VALf_SET(r,f) (r).miim_dma_ch_curr_dst_host_address[0]=((uint32_t)f)

/*
 * These macros can be used to access MIIM_DMA_CH_CURR_DST_HOST_ADDRESS.
 */
#define READ_MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr_OFFSET+(4*(i)*20),r._miim_dma_ch_curr_dst_host_address)
#define WRITE_MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr_OFFSET+(4*(i)*20),r._miim_dma_ch_curr_dst_host_address)

/*******************************************************************************
 * End of 'MIIM_DMA_CH_CURR_DST_HOST_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH_CURR_SRC_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr_OFFSET 0x01319064

#define MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_DMA_CH_CURR_SRC_HOST_ADDRESS.
 */
typedef union MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr_s {
    uint32_t v[1];
    uint32_t miim_dma_ch_curr_src_host_address[1];
    uint32_t _miim_dma_ch_curr_src_host_address;
} MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr_t;

#define MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr_CLR(r) (r).miim_dma_ch_curr_src_host_address[0] = 0
#define MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr_SET(r,d) (r).miim_dma_ch_curr_src_host_address[0] = d
#define MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr_GET(r) (r).miim_dma_ch_curr_src_host_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr_VALf_GET(r) ((r).miim_dma_ch_curr_src_host_address[0])
#define MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr_VALf_SET(r,f) (r).miim_dma_ch_curr_src_host_address[0]=((uint32_t)f)

/*
 * These macros can be used to access MIIM_DMA_CH_CURR_SRC_HOST_ADDRESS.
 */
#define READ_MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr_OFFSET+(4*(i)*20),r._miim_dma_ch_curr_src_host_address)
#define WRITE_MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr_OFFSET+(4*(i)*20),r._miim_dma_ch_curr_src_host_address)

/*******************************************************************************
 * End of 'MIIM_DMA_CH_CURR_SRC_HOST_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_OFFSET 0x01319058

#define MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESS.
 */
typedef union MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_s {
    uint32_t v[1];
    uint32_t miim_dma_ch_data_only_mode_address[1];
    uint32_t _miim_dma_ch_data_only_mode_address;
} MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_t;

#define MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_CLR(r) (r).miim_dma_ch_data_only_mode_address[0] = 0
#define MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_SET(r,d) (r).miim_dma_ch_data_only_mode_address[0] = d
#define MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_GET(r) (r).miim_dma_ch_data_only_mode_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_PHY_IDf_GET(r) ((((r).miim_dma_ch_data_only_mode_address[0]) >> 6) & 0x1f)
#define MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_PHY_IDf_SET(r,f) (r).miim_dma_ch_data_only_mode_address[0]=(((r).miim_dma_ch_data_only_mode_address[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_CLAUSE_22_REGADRR_OR_45_DTYPEf_GET(r) ((((r).miim_dma_ch_data_only_mode_address[0]) >> 11) & 0x1f)
#define MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_CLAUSE_22_REGADRR_OR_45_DTYPEf_SET(r,f) (r).miim_dma_ch_data_only_mode_address[0]=(((r).miim_dma_ch_data_only_mode_address[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_CLAUSE_45_REG_ADRRf_GET(r) ((((r).miim_dma_ch_data_only_mode_address[0]) >> 16) & 0xffff)
#define MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_CLAUSE_45_REG_ADRRf_SET(r,f) (r).miim_dma_ch_data_only_mode_address[0]=(((r).miim_dma_ch_data_only_mode_address[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESS.
 */
#define READ_MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_OFFSET+(4*(i)*20),r._miim_dma_ch_data_only_mode_address)
#define WRITE_MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr_OFFSET+(4*(i)*20),r._miim_dma_ch_data_only_mode_address)

/*******************************************************************************
 * End of 'MIIM_DMA_CH_DATA_ONLY_MODE_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH_DATA_ONLY_MODE_PARAMS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_OFFSET 0x01319054

#define MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_DMA_CH_DATA_ONLY_MODE_PARAMS.
 */
typedef union MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_s {
    uint32_t v[1];
    uint32_t miim_dma_ch_data_only_mode_params[1];
    uint32_t _miim_dma_ch_data_only_mode_params;
} MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_t;

#define MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_CLR(r) (r).miim_dma_ch_data_only_mode_params[0] = 0
#define MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_SET(r,d) (r).miim_dma_ch_data_only_mode_params[0] = d
#define MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_GET(r) (r).miim_dma_ch_data_only_mode_params[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_SEL_INT_PHYf_GET(r) ((((r).miim_dma_ch_data_only_mode_params[0]) >> 16) & 0x1)
#define MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_SEL_INT_PHYf_SET(r,f) (r).miim_dma_ch_data_only_mode_params[0]=(((r).miim_dma_ch_data_only_mode_params[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_MDIO_OP_TYPEf_GET(r) ((((r).miim_dma_ch_data_only_mode_params[0]) >> 17) & 0x7)
#define MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_MDIO_OP_TYPEf_SET(r,f) (r).miim_dma_ch_data_only_mode_params[0]=(((r).miim_dma_ch_data_only_mode_params[0] & ~((uint32_t)0x7 << 17)) | ((((uint32_t)f) & 0x7) << 17))
#define MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_RING_MAPf_GET(r) ((((r).miim_dma_ch_data_only_mode_params[0]) >> 20) & 0xfff)
#define MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_RING_MAPf_SET(r,f) (r).miim_dma_ch_data_only_mode_params[0]=(((r).miim_dma_ch_data_only_mode_params[0] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))

/*
 * These macros can be used to access MIIM_DMA_CH_DATA_ONLY_MODE_PARAMS.
 */
#define READ_MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_OFFSET+(4*(i)*20),r._miim_dma_ch_data_only_mode_params)
#define WRITE_MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr_OFFSET+(4*(i)*20),r._miim_dma_ch_data_only_mode_params)

/*******************************************************************************
 * End of 'MIIM_DMA_CH_DATA_ONLY_MODE_PARAMSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH_DST_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH_DST_HOST_ADDRESSr_OFFSET 0x01319060

#define MIIM_DMA_CH_DST_HOST_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_DMA_CH_DST_HOST_ADDRESS.
 */
typedef union MIIM_DMA_CH_DST_HOST_ADDRESSr_s {
    uint32_t v[1];
    uint32_t miim_dma_ch_dst_host_address[1];
    uint32_t _miim_dma_ch_dst_host_address;
} MIIM_DMA_CH_DST_HOST_ADDRESSr_t;

#define MIIM_DMA_CH_DST_HOST_ADDRESSr_CLR(r) (r).miim_dma_ch_dst_host_address[0] = 0
#define MIIM_DMA_CH_DST_HOST_ADDRESSr_SET(r,d) (r).miim_dma_ch_dst_host_address[0] = d
#define MIIM_DMA_CH_DST_HOST_ADDRESSr_GET(r) (r).miim_dma_ch_dst_host_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_DMA_CH_DST_HOST_ADDRESSr_VALf_GET(r) ((r).miim_dma_ch_dst_host_address[0])
#define MIIM_DMA_CH_DST_HOST_ADDRESSr_VALf_SET(r,f) (r).miim_dma_ch_dst_host_address[0]=((uint32_t)f)

/*
 * These macros can be used to access MIIM_DMA_CH_DST_HOST_ADDRESS.
 */
#define READ_MIIM_DMA_CH_DST_HOST_ADDRESSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_DMA_CH_DST_HOST_ADDRESSr_OFFSET+(4*(i)*20),r._miim_dma_ch_dst_host_address)
#define WRITE_MIIM_DMA_CH_DST_HOST_ADDRESSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_DMA_CH_DST_HOST_ADDRESSr_OFFSET+(4*(i)*20),r._miim_dma_ch_dst_host_address)

/*******************************************************************************
 * End of 'MIIM_DMA_CH_DST_HOST_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH_SRC_HOST_ADDRESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH_SRC_HOST_ADDRESSr_OFFSET 0x0131905c

#define MIIM_DMA_CH_SRC_HOST_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_DMA_CH_SRC_HOST_ADDRESS.
 */
typedef union MIIM_DMA_CH_SRC_HOST_ADDRESSr_s {
    uint32_t v[1];
    uint32_t miim_dma_ch_src_host_address[1];
    uint32_t _miim_dma_ch_src_host_address;
} MIIM_DMA_CH_SRC_HOST_ADDRESSr_t;

#define MIIM_DMA_CH_SRC_HOST_ADDRESSr_CLR(r) (r).miim_dma_ch_src_host_address[0] = 0
#define MIIM_DMA_CH_SRC_HOST_ADDRESSr_SET(r,d) (r).miim_dma_ch_src_host_address[0] = d
#define MIIM_DMA_CH_SRC_HOST_ADDRESSr_GET(r) (r).miim_dma_ch_src_host_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_DMA_CH_SRC_HOST_ADDRESSr_VALf_GET(r) ((r).miim_dma_ch_src_host_address[0])
#define MIIM_DMA_CH_SRC_HOST_ADDRESSr_VALf_SET(r,f) (r).miim_dma_ch_src_host_address[0]=((uint32_t)f)

/*
 * These macros can be used to access MIIM_DMA_CH_SRC_HOST_ADDRESS.
 */
#define READ_MIIM_DMA_CH_SRC_HOST_ADDRESSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_DMA_CH_SRC_HOST_ADDRESSr_OFFSET+(4*(i)*20),r._miim_dma_ch_src_host_address)
#define WRITE_MIIM_DMA_CH_SRC_HOST_ADDRESSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_DMA_CH_SRC_HOST_ADDRESSr_OFFSET+(4*(i)*20),r._miim_dma_ch_src_host_address)

/*******************************************************************************
 * End of 'MIIM_DMA_CH_SRC_HOST_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_DMA_CH_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_DMA_CH_STATUSr_OFFSET 0x0131906c

#define MIIM_DMA_CH_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_DMA_CH_STATUS.
 */
typedef union MIIM_DMA_CH_STATUSr_s {
    uint32_t v[1];
    uint32_t miim_dma_ch_status[1];
    uint32_t _miim_dma_ch_status;
} MIIM_DMA_CH_STATUSr_t;

#define MIIM_DMA_CH_STATUSr_CLR(r) (r).miim_dma_ch_status[0] = 0
#define MIIM_DMA_CH_STATUSr_SET(r,d) (r).miim_dma_ch_status[0] = d
#define MIIM_DMA_CH_STATUSr_GET(r) (r).miim_dma_ch_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_DMA_CH_STATUSr_ACTIVEf_GET(r) (((r).miim_dma_ch_status[0]) & 0x1)
#define MIIM_DMA_CH_STATUSr_ACTIVEf_SET(r,f) (r).miim_dma_ch_status[0]=(((r).miim_dma_ch_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define MIIM_DMA_CH_STATUSr_DONEf_GET(r) ((((r).miim_dma_ch_status[0]) >> 1) & 0x1)
#define MIIM_DMA_CH_STATUSr_DONEf_SET(r,f) (r).miim_dma_ch_status[0]=(((r).miim_dma_ch_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define MIIM_DMA_CH_STATUSr_ABORTEDf_GET(r) ((((r).miim_dma_ch_status[0]) >> 2) & 0x1)
#define MIIM_DMA_CH_STATUSr_ABORTEDf_SET(r,f) (r).miim_dma_ch_status[0]=(((r).miim_dma_ch_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define MIIM_DMA_CH_STATUSr_DEBUGf_GET(r) ((((r).miim_dma_ch_status[0]) >> 16) & 0xffff)
#define MIIM_DMA_CH_STATUSr_DEBUGf_SET(r,f) (r).miim_dma_ch_status[0]=(((r).miim_dma_ch_status[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MIIM_DMA_CH_STATUS.
 */
#define READ_MIIM_DMA_CH_STATUSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_DMA_CH_STATUSr_OFFSET+(4*(i)*20),r._miim_dma_ch_status)
#define WRITE_MIIM_DMA_CH_STATUSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_DMA_CH_STATUSr_OFFSET+(4*(i)*20),r._miim_dma_ch_status)

/*******************************************************************************
 * End of 'MIIM_DMA_CH_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_INTERRUPT_ENABLE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_INTERRUPT_ENABLEr_OFFSET 0x01319144

#define MIIM_INTERRUPT_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_INTERRUPT_ENABLE.
 */
typedef union MIIM_INTERRUPT_ENABLEr_s {
    uint32_t v[1];
    uint32_t miim_interrupt_enable[1];
    uint32_t _miim_interrupt_enable;
} MIIM_INTERRUPT_ENABLEr_t;

#define MIIM_INTERRUPT_ENABLEr_CLR(r) (r).miim_interrupt_enable[0] = 0
#define MIIM_INTERRUPT_ENABLEr_SET(r,d) (r).miim_interrupt_enable[0] = d
#define MIIM_INTERRUPT_ENABLEr_GET(r) (r).miim_interrupt_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_INTERRUPT_ENABLEr_CH0_DONEf_GET(r) (((r).miim_interrupt_enable[0]) & 0x1)
#define MIIM_INTERRUPT_ENABLEr_CH0_DONEf_SET(r,f) (r).miim_interrupt_enable[0]=(((r).miim_interrupt_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define MIIM_INTERRUPT_ENABLEr_CH1_DONEf_GET(r) ((((r).miim_interrupt_enable[0]) >> 1) & 0x1)
#define MIIM_INTERRUPT_ENABLEr_CH1_DONEf_SET(r,f) (r).miim_interrupt_enable[0]=(((r).miim_interrupt_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define MIIM_INTERRUPT_ENABLEr_CH2_DONEf_GET(r) ((((r).miim_interrupt_enable[0]) >> 2) & 0x1)
#define MIIM_INTERRUPT_ENABLEr_CH2_DONEf_SET(r,f) (r).miim_interrupt_enable[0]=(((r).miim_interrupt_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define MIIM_INTERRUPT_ENABLEr_CH3_DONEf_GET(r) ((((r).miim_interrupt_enable[0]) >> 3) & 0x1)
#define MIIM_INTERRUPT_ENABLEr_CH3_DONEf_SET(r,f) (r).miim_interrupt_enable[0]=(((r).miim_interrupt_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define MIIM_INTERRUPT_ENABLEr_DMA_CH0_DONEf_GET(r) ((((r).miim_interrupt_enable[0]) >> 4) & 0x1)
#define MIIM_INTERRUPT_ENABLEr_DMA_CH0_DONEf_SET(r,f) (r).miim_interrupt_enable[0]=(((r).miim_interrupt_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define MIIM_INTERRUPT_ENABLEr_DMA_CH1_DONEf_GET(r) ((((r).miim_interrupt_enable[0]) >> 5) & 0x1)
#define MIIM_INTERRUPT_ENABLEr_DMA_CH1_DONEf_SET(r,f) (r).miim_interrupt_enable[0]=(((r).miim_interrupt_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access MIIM_INTERRUPT_ENABLE.
 */
#define READ_MIIM_INTERRUPT_ENABLEr(u,r) BCMDRD_IPROC_READ(u,MIIM_INTERRUPT_ENABLEr_OFFSET,r._miim_interrupt_enable)
#define WRITE_MIIM_INTERRUPT_ENABLEr(u,r) BCMDRD_IPROC_WRITE(u,MIIM_INTERRUPT_ENABLEr_OFFSET,r._miim_interrupt_enable)

/*******************************************************************************
 * End of 'MIIM_INTERRUPT_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_INTERRUPT_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_INTERRUPT_STATUSr_OFFSET 0x01319148

#define MIIM_INTERRUPT_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_INTERRUPT_STATUS.
 */
typedef union MIIM_INTERRUPT_STATUSr_s {
    uint32_t v[1];
    uint32_t miim_interrupt_status[1];
    uint32_t _miim_interrupt_status;
} MIIM_INTERRUPT_STATUSr_t;

#define MIIM_INTERRUPT_STATUSr_CLR(r) (r).miim_interrupt_status[0] = 0
#define MIIM_INTERRUPT_STATUSr_SET(r,d) (r).miim_interrupt_status[0] = d
#define MIIM_INTERRUPT_STATUSr_GET(r) (r).miim_interrupt_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_INTERRUPT_STATUSr_CH0_DONEf_GET(r) (((r).miim_interrupt_status[0]) & 0x1)
#define MIIM_INTERRUPT_STATUSr_CH0_DONEf_SET(r,f) (r).miim_interrupt_status[0]=(((r).miim_interrupt_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define MIIM_INTERRUPT_STATUSr_CH1_DONEf_GET(r) ((((r).miim_interrupt_status[0]) >> 1) & 0x1)
#define MIIM_INTERRUPT_STATUSr_CH1_DONEf_SET(r,f) (r).miim_interrupt_status[0]=(((r).miim_interrupt_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define MIIM_INTERRUPT_STATUSr_CH2_DONEf_GET(r) ((((r).miim_interrupt_status[0]) >> 2) & 0x1)
#define MIIM_INTERRUPT_STATUSr_CH2_DONEf_SET(r,f) (r).miim_interrupt_status[0]=(((r).miim_interrupt_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define MIIM_INTERRUPT_STATUSr_CH3_DONEf_GET(r) ((((r).miim_interrupt_status[0]) >> 3) & 0x1)
#define MIIM_INTERRUPT_STATUSr_CH3_DONEf_SET(r,f) (r).miim_interrupt_status[0]=(((r).miim_interrupt_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define MIIM_INTERRUPT_STATUSr_DMA_CH0_DONEf_GET(r) ((((r).miim_interrupt_status[0]) >> 4) & 0x1)
#define MIIM_INTERRUPT_STATUSr_DMA_CH0_DONEf_SET(r,f) (r).miim_interrupt_status[0]=(((r).miim_interrupt_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define MIIM_INTERRUPT_STATUSr_DMA_CH1_DONEf_GET(r) ((((r).miim_interrupt_status[0]) >> 5) & 0x1)
#define MIIM_INTERRUPT_STATUSr_DMA_CH1_DONEf_SET(r,f) (r).miim_interrupt_status[0]=(((r).miim_interrupt_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access MIIM_INTERRUPT_STATUS.
 */
#define READ_MIIM_INTERRUPT_STATUSr(u,r) BCMDRD_IPROC_READ(u,MIIM_INTERRUPT_STATUSr_OFFSET,r._miim_interrupt_status)
#define WRITE_MIIM_INTERRUPT_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,MIIM_INTERRUPT_STATUSr_OFFSET,r._miim_interrupt_status)

/*******************************************************************************
 * End of 'MIIM_INTERRUPT_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_INT_PHY_LINK_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_INT_PHY_LINK_STATUSr_OFFSET 0x01319174

#define MIIM_INT_PHY_LINK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_INT_PHY_LINK_STATUS.
 */
typedef union MIIM_INT_PHY_LINK_STATUSr_s {
    uint32_t v[1];
    uint32_t miim_int_phy_link_status[1];
    uint32_t _miim_int_phy_link_status;
} MIIM_INT_PHY_LINK_STATUSr_t;

#define MIIM_INT_PHY_LINK_STATUSr_CLR(r) (r).miim_int_phy_link_status[0] = 0
#define MIIM_INT_PHY_LINK_STATUSr_SET(r,d) (r).miim_int_phy_link_status[0] = d
#define MIIM_INT_PHY_LINK_STATUSr_GET(r) (r).miim_int_phy_link_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_INT_PHY_LINK_STATUSr_VALf_GET(r) ((r).miim_int_phy_link_status[0])
#define MIIM_INT_PHY_LINK_STATUSr_VALf_SET(r,f) (r).miim_int_phy_link_status[0]=((uint32_t)f)

/*
 * These macros can be used to access MIIM_INT_PHY_LINK_STATUS.
 */
#define READ_MIIM_INT_PHY_LINK_STATUSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_INT_PHY_LINK_STATUSr_OFFSET+(4*(i)),r._miim_int_phy_link_status)
#define WRITE_MIIM_INT_PHY_LINK_STATUSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_INT_PHY_LINK_STATUSr_OFFSET+(4*(i)),r._miim_int_phy_link_status)

/*******************************************************************************
 * End of 'MIIM_INT_PHY_LINK_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_LINK_SCAN_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_LINK_SCAN_STATUSr_OFFSET 0x0131914c

#define MIIM_LINK_SCAN_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_LINK_SCAN_STATUS.
 */
typedef union MIIM_LINK_SCAN_STATUSr_s {
    uint32_t v[1];
    uint32_t miim_link_scan_status[1];
    uint32_t _miim_link_scan_status;
} MIIM_LINK_SCAN_STATUSr_t;

#define MIIM_LINK_SCAN_STATUSr_CLR(r) (r).miim_link_scan_status[0] = 0
#define MIIM_LINK_SCAN_STATUSr_SET(r,d) (r).miim_link_scan_status[0] = d
#define MIIM_LINK_SCAN_STATUSr_GET(r) (r).miim_link_scan_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_LINK_SCAN_STATUSr_VALf_GET(r) ((r).miim_link_scan_status[0])
#define MIIM_LINK_SCAN_STATUSr_VALf_SET(r,f) (r).miim_link_scan_status[0]=((uint32_t)f)

/*
 * These macros can be used to access MIIM_LINK_SCAN_STATUS.
 */
#define READ_MIIM_LINK_SCAN_STATUSr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_LINK_SCAN_STATUSr_OFFSET+(4*(i)),r._miim_link_scan_status)
#define WRITE_MIIM_LINK_SCAN_STATUSr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_LINK_SCAN_STATUSr_OFFSET+(4*(i)),r._miim_link_scan_status)

/*******************************************************************************
 * End of 'MIIM_LINK_SCAN_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  MIIM_RING0_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING0_CONTROLr_OFFSET 0x013190f0

#define MIIM_RING0_CONTROLr_SIZE 4

/* MIIM_RING0_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING10_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING10_CONTROLr_OFFSET 0x01319118

#define MIIM_RING10_CONTROLr_SIZE 4

/* MIIM_RING10_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING11_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING11_CONTROLr_OFFSET 0x0131911c

#define MIIM_RING11_CONTROLr_SIZE 4

/* MIIM_RING11_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING1_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING1_CONTROLr_OFFSET 0x013190f4

#define MIIM_RING1_CONTROLr_SIZE 4

/* MIIM_RING1_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING2_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING2_CONTROLr_OFFSET 0x013190f8

#define MIIM_RING2_CONTROLr_SIZE 4

/* MIIM_RING2_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING3_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING3_CONTROLr_OFFSET 0x013190fc

#define MIIM_RING3_CONTROLr_SIZE 4

/* MIIM_RING3_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING4_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING4_CONTROLr_OFFSET 0x01319100

#define MIIM_RING4_CONTROLr_SIZE 4

/* MIIM_RING4_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING5_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING5_CONTROLr_OFFSET 0x01319104

#define MIIM_RING5_CONTROLr_SIZE 4

/* MIIM_RING5_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING6_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING6_CONTROLr_OFFSET 0x01319108

#define MIIM_RING6_CONTROLr_SIZE 4

/* MIIM_RING6_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING7_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING7_CONTROLr_OFFSET 0x0131910c

#define MIIM_RING7_CONTROLr_SIZE 4

/* MIIM_RING7_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING8_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING8_CONTROLr_OFFSET 0x01319110

#define MIIM_RING8_CONTROLr_SIZE 4

/* MIIM_RING8_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING9_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING9_CONTROLr_OFFSET 0x01319114

#define MIIM_RING9_CONTROLr_SIZE 4

/* MIIM_RING9_CONTROLr is element of MIIM_RING_CONTROL */

/*******************************************************************************
 * REGISTER:  MIIM_RING_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define MIIM_RING_CONTROLr_OFFSET 0x013190f0

#define MIIM_RING_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MIIM_RING_CONTROL.
 */
typedef union MIIM_RING_CONTROLr_s {
    uint32_t v[1];
    uint32_t miim_ring_control[1];
    uint32_t _miim_ring_control;
} MIIM_RING_CONTROLr_t;

#define MIIM_RING_CONTROLr_CLR(r) (r).miim_ring_control[0] = 0
#define MIIM_RING_CONTROLr_SET(r,d) (r).miim_ring_control[0] = d
#define MIIM_RING_CONTROLr_GET(r) (r).miim_ring_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIIM_RING_CONTROLr_CLOCK_DIVIDER_INTf_GET(r) (((r).miim_ring_control[0]) & 0xff)
#define MIIM_RING_CONTROLr_CLOCK_DIVIDER_INTf_SET(r,f) (r).miim_ring_control[0]=(((r).miim_ring_control[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define MIIM_RING_CONTROLr_CLOCK_DIVIDER_EXTf_GET(r) ((((r).miim_ring_control[0]) >> 8) & 0xff)
#define MIIM_RING_CONTROLr_CLOCK_DIVIDER_EXTf_SET(r,f) (r).miim_ring_control[0]=(((r).miim_ring_control[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define MIIM_RING_CONTROLr_MDIO_OUT_DELAYf_GET(r) ((((r).miim_ring_control[0]) >> 16) & 0xff)
#define MIIM_RING_CONTROLr_MDIO_OUT_DELAYf_SET(r,f) (r).miim_ring_control[0]=(((r).miim_ring_control[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define MIIM_RING_CONTROLr_PREAMBLEf_GET(r) ((((r).miim_ring_control[0]) >> 24) & 0x3)
#define MIIM_RING_CONTROLr_PREAMBLEf_SET(r,f) (r).miim_ring_control[0]=(((r).miim_ring_control[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define MIIM_RING_CONTROLr_MDC_MODEf_GET(r) ((((r).miim_ring_control[0]) >> 26) & 0x1)
#define MIIM_RING_CONTROLr_MDC_MODEf_SET(r,f) (r).miim_ring_control[0]=(((r).miim_ring_control[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access MIIM_RING_CONTROL.
 */
#define READ_MIIM_RING_CONTROLr(u,i,r) BCMDRD_IPROC_READ(u,MIIM_RING_CONTROLr_OFFSET+(4*(i)),r._miim_ring_control)
#define WRITE_MIIM_RING_CONTROLr(u,i,r) BCMDRD_IPROC_WRITE(u,MIIM_RING_CONTROLr_OFFSET+(4*(i)),r._miim_ring_control)

/*******************************************************************************
 * End of 'MIIM_RING_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_CONFIG_IND_ADDR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_CONFIG_IND_ADDRr_OFFSET 0x18012120

#define PAXB_0_CONFIG_IND_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_CONFIG_IND_ADDR.
 */
typedef union PAXB_0_CONFIG_IND_ADDRr_s {
    uint32_t v[1];
    uint32_t paxb_0_config_ind_addr[1];
    uint32_t _paxb_0_config_ind_addr;
} PAXB_0_CONFIG_IND_ADDRr_t;

#define PAXB_0_CONFIG_IND_ADDRr_CLR(r) (r).paxb_0_config_ind_addr[0] = 0
#define PAXB_0_CONFIG_IND_ADDRr_SET(r,d) (r).paxb_0_config_ind_addr[0] = d
#define PAXB_0_CONFIG_IND_ADDRr_GET(r) (r).paxb_0_config_ind_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_CONFIG_IND_ADDRr_ADDRESSf_GET(r) (((r).paxb_0_config_ind_addr[0]) & 0x7ff)
#define PAXB_0_CONFIG_IND_ADDRr_ADDRESSf_SET(r,f) (r).paxb_0_config_ind_addr[0]=(((r).paxb_0_config_ind_addr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define PAXB_0_CONFIG_IND_ADDRr_PROTOCOL_LAYERf_GET(r) ((((r).paxb_0_config_ind_addr[0]) >> 11) & 0x3)
#define PAXB_0_CONFIG_IND_ADDRr_PROTOCOL_LAYERf_SET(r,f) (r).paxb_0_config_ind_addr[0]=(((r).paxb_0_config_ind_addr[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define PAXB_0_CONFIG_IND_ADDRr_FUNCTION_NUMf_GET(r) ((((r).paxb_0_config_ind_addr[0]) >> 13) & 0x7)
#define PAXB_0_CONFIG_IND_ADDRr_FUNCTION_NUMf_SET(r,f) (r).paxb_0_config_ind_addr[0]=(((r).paxb_0_config_ind_addr[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PAXB_0_CONFIG_IND_ADDR.
 */
#define READ_PAXB_0_CONFIG_IND_ADDRr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_CONFIG_IND_ADDRr_OFFSET,r._paxb_0_config_ind_addr)
#define WRITE_PAXB_0_CONFIG_IND_ADDRr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_CONFIG_IND_ADDRr_OFFSET,r._paxb_0_config_ind_addr)

/*******************************************************************************
 * End of 'PAXB_0_CONFIG_IND_ADDRr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_CONFIG_IND_DATA
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_CONFIG_IND_DATAr_OFFSET 0x18012124

#define PAXB_0_CONFIG_IND_DATAr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_CONFIG_IND_DATA.
 */
typedef union PAXB_0_CONFIG_IND_DATAr_s {
    uint32_t v[1];
    uint32_t paxb_0_config_ind_data[1];
    uint32_t _paxb_0_config_ind_data;
} PAXB_0_CONFIG_IND_DATAr_t;

#define PAXB_0_CONFIG_IND_DATAr_CLR(r) (r).paxb_0_config_ind_data[0] = 0
#define PAXB_0_CONFIG_IND_DATAr_SET(r,d) (r).paxb_0_config_ind_data[0] = d
#define PAXB_0_CONFIG_IND_DATAr_GET(r) (r).paxb_0_config_ind_data[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_CONFIG_IND_DATAr_DATAf_GET(r) ((r).paxb_0_config_ind_data[0])
#define PAXB_0_CONFIG_IND_DATAr_DATAf_SET(r,f) (r).paxb_0_config_ind_data[0]=((uint32_t)f)

/*
 * These macros can be used to access PAXB_0_CONFIG_IND_DATA.
 */
#define READ_PAXB_0_CONFIG_IND_DATAr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_CONFIG_IND_DATAr_OFFSET,r._paxb_0_config_ind_data)
#define WRITE_PAXB_0_CONFIG_IND_DATAr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_CONFIG_IND_DATAr_OFFSET,r._paxb_0_config_ind_data)

/*******************************************************************************
 * End of 'PAXB_0_CONFIG_IND_DATAr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_GEN3_UC_LOADER_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_GEN3_UC_LOADER_STATUSr_OFFSET 0x18012f84

#define PAXB_0_GEN3_UC_LOADER_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_GEN3_UC_LOADER_STATUS.
 */
typedef union PAXB_0_GEN3_UC_LOADER_STATUSr_s {
    uint32_t v[1];
    uint32_t paxb_0_gen3_uc_loader_status[1];
    uint32_t _paxb_0_gen3_uc_loader_status;
} PAXB_0_GEN3_UC_LOADER_STATUSr_t;

#define PAXB_0_GEN3_UC_LOADER_STATUSr_CLR(r) (r).paxb_0_gen3_uc_loader_status[0] = 0
#define PAXB_0_GEN3_UC_LOADER_STATUSr_SET(r,d) (r).paxb_0_gen3_uc_loader_status[0] = d
#define PAXB_0_GEN3_UC_LOADER_STATUSr_GET(r) (r).paxb_0_gen3_uc_loader_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_GEN3_UC_LOADER_STATUSr_UC_PROG_DONEf_GET(r) (((r).paxb_0_gen3_uc_loader_status[0]) & 0x1)
#define PAXB_0_GEN3_UC_LOADER_STATUSr_UC_PROG_DONEf_SET(r,f) (r).paxb_0_gen3_uc_loader_status[0]=(((r).paxb_0_gen3_uc_loader_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PAXB_0_GEN3_UC_LOADER_STATUS.
 */
#define READ_PAXB_0_GEN3_UC_LOADER_STATUSr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_GEN3_UC_LOADER_STATUSr_OFFSET,r._paxb_0_gen3_uc_loader_status)
#define WRITE_PAXB_0_GEN3_UC_LOADER_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_GEN3_UC_LOADER_STATUSr_OFFSET,r._paxb_0_gen3_uc_loader_status)

/*******************************************************************************
 * End of 'PAXB_0_GEN3_UC_LOADER_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_ENDIANNESS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_ENDIANNESSr_OFFSET 0x18012030

#define PAXB_0_PAXB_ENDIANNESSr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_ENDIANNESS.
 */
typedef union PAXB_0_PAXB_ENDIANNESSr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_endianness[1];
    uint32_t _paxb_0_paxb_endianness;
} PAXB_0_PAXB_ENDIANNESSr_t;

#define PAXB_0_PAXB_ENDIANNESSr_CLR(r) (r).paxb_0_paxb_endianness[0] = 0
#define PAXB_0_PAXB_ENDIANNESSr_SET(r,d) (r).paxb_0_paxb_endianness[0] = d
#define PAXB_0_PAXB_ENDIANNESSr_GET(r) (r).paxb_0_paxb_endianness[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_ENDIANNESSr_BIGENDIANf_GET(r) (((r).paxb_0_paxb_endianness[0]) & 0x1)
#define PAXB_0_PAXB_ENDIANNESSr_BIGENDIANf_SET(r,f) (r).paxb_0_paxb_endianness[0]=(((r).paxb_0_paxb_endianness[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PAXB_0_PAXB_ENDIANNESS.
 */
#define READ_PAXB_0_PAXB_ENDIANNESSr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_ENDIANNESSr_OFFSET,r._paxb_0_paxb_endianness)
#define WRITE_PAXB_0_PAXB_ENDIANNESSr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_ENDIANNESSr_OFFSET,r._paxb_0_paxb_endianness)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_ENDIANNESSr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_HOTSWAP_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_HOTSWAP_CTRLr_OFFSET 0x18012f54

#define PAXB_0_PAXB_HOTSWAP_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_HOTSWAP_CTRL.
 */
typedef union PAXB_0_PAXB_HOTSWAP_CTRLr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_hotswap_ctrl[1];
    uint32_t _paxb_0_paxb_hotswap_ctrl;
} PAXB_0_PAXB_HOTSWAP_CTRLr_t;

#define PAXB_0_PAXB_HOTSWAP_CTRLr_CLR(r) (r).paxb_0_paxb_hotswap_ctrl[0] = 0
#define PAXB_0_PAXB_HOTSWAP_CTRLr_SET(r,d) (r).paxb_0_paxb_hotswap_ctrl[0] = d
#define PAXB_0_PAXB_HOTSWAP_CTRLr_GET(r) (r).paxb_0_paxb_hotswap_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_HOTSWAP_CTRLr_ENABLEf_GET(r) (((r).paxb_0_paxb_hotswap_ctrl[0]) & 0x1)
#define PAXB_0_PAXB_HOTSWAP_CTRLr_ENABLEf_SET(r,f) (r).paxb_0_paxb_hotswap_ctrl[0]=(((r).paxb_0_paxb_hotswap_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define PAXB_0_PAXB_HOTSWAP_CTRLr_AXIDUMMYSLAVE_MODEf_GET(r) ((((r).paxb_0_paxb_hotswap_ctrl[0]) >> 1) & 0x1)
#define PAXB_0_PAXB_HOTSWAP_CTRLr_AXIDUMMYSLAVE_MODEf_SET(r,f) (r).paxb_0_paxb_hotswap_ctrl[0]=(((r).paxb_0_paxb_hotswap_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define PAXB_0_PAXB_HOTSWAP_CTRLr_SERVICE_COMPLETEf_GET(r) ((((r).paxb_0_paxb_hotswap_ctrl[0]) >> 2) & 0x1)
#define PAXB_0_PAXB_HOTSWAP_CTRLr_SERVICE_COMPLETEf_SET(r,f) (r).paxb_0_paxb_hotswap_ctrl[0]=(((r).paxb_0_paxb_hotswap_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access PAXB_0_PAXB_HOTSWAP_CTRL.
 */
#define READ_PAXB_0_PAXB_HOTSWAP_CTRLr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_HOTSWAP_CTRLr_OFFSET,r._paxb_0_paxb_hotswap_ctrl)
#define WRITE_PAXB_0_PAXB_HOTSWAP_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_HOTSWAP_CTRLr_OFFSET,r._paxb_0_paxb_hotswap_ctrl)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_HOTSWAP_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_HOTSWAP_DEBUG_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_OFFSET 0x18012f5c

#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_HOTSWAP_DEBUG_CTRL.
 */
typedef union PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_hotswap_debug_ctrl[1];
    uint32_t _paxb_0_paxb_hotswap_debug_ctrl;
} PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_t;

#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_CLR(r) (r).paxb_0_paxb_hotswap_debug_ctrl[0] = 0
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_SET(r,d) (r).paxb_0_paxb_hotswap_debug_ctrl[0] = d
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_GET(r) (r).paxb_0_paxb_hotswap_debug_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_FLUSHMODEf_GET(r) (((r).paxb_0_paxb_hotswap_debug_ctrl[0]) & 0x1)
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_FLUSHMODEf_SET(r,f) (r).paxb_0_paxb_hotswap_debug_ctrl[0]=(((r).paxb_0_paxb_hotswap_debug_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_SW_PROGRAMMABLE_PERTSBf_GET(r) ((((r).paxb_0_paxb_hotswap_debug_ctrl[0]) >> 1) & 0x1)
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_SW_PROGRAMMABLE_PERTSBf_SET(r,f) (r).paxb_0_paxb_hotswap_debug_ctrl[0]=(((r).paxb_0_paxb_hotswap_debug_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_DEBUG_FSM_FLIST_SELf_GET(r) ((((r).paxb_0_paxb_hotswap_debug_ctrl[0]) >> 2) & 0x7)
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_DEBUG_FSM_FLIST_SELf_SET(r,f) (r).paxb_0_paxb_hotswap_debug_ctrl[0]=(((r).paxb_0_paxb_hotswap_debug_ctrl[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_AXIDUMMY_WRRESPf_GET(r) ((((r).paxb_0_paxb_hotswap_debug_ctrl[0]) >> 5) & 0x3)
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_AXIDUMMY_WRRESPf_SET(r,f) (r).paxb_0_paxb_hotswap_debug_ctrl[0]=(((r).paxb_0_paxb_hotswap_debug_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_AXIDUMMY_RDRESPf_GET(r) ((((r).paxb_0_paxb_hotswap_debug_ctrl[0]) >> 7) & 0x3)
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_AXIDUMMY_RDRESPf_SET(r,f) (r).paxb_0_paxb_hotswap_debug_ctrl[0]=(((r).paxb_0_paxb_hotswap_debug_ctrl[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_ALLOWMSIINDUMMYf_GET(r) ((((r).paxb_0_paxb_hotswap_debug_ctrl[0]) >> 9) & 0x1)
#define PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_ALLOWMSIINDUMMYf_SET(r,f) (r).paxb_0_paxb_hotswap_debug_ctrl[0]=(((r).paxb_0_paxb_hotswap_debug_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access PAXB_0_PAXB_HOTSWAP_DEBUG_CTRL.
 */
#define READ_PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_OFFSET,r._paxb_0_paxb_hotswap_debug_ctrl)
#define WRITE_PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr_OFFSET,r._paxb_0_paxb_hotswap_debug_ctrl)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_HOTSWAP_DEBUG_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_HOTSWAP_DEBUG_STAT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_OFFSET 0x18012f60

#define PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_HOTSWAP_DEBUG_STAT.
 */
typedef union PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_hotswap_debug_stat[1];
    uint32_t _paxb_0_paxb_hotswap_debug_stat;
} PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_t;

#define PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_CLR(r) (r).paxb_0_paxb_hotswap_debug_stat[0] = 0
#define PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_SET(r,d) (r).paxb_0_paxb_hotswap_debug_stat[0] = d
#define PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_GET(r) (r).paxb_0_paxb_hotswap_debug_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_STAT_8_0f_GET(r) (((r).paxb_0_paxb_hotswap_debug_stat[0]) & 0x1ff)
#define PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_STAT_8_0f_SET(r,f) (r).paxb_0_paxb_hotswap_debug_stat[0]=(((r).paxb_0_paxb_hotswap_debug_stat[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_DEBUG_FSM_FLISTf_GET(r) ((((r).paxb_0_paxb_hotswap_debug_stat[0]) >> 9) & 0xffff)
#define PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_DEBUG_FSM_FLISTf_SET(r,f) (r).paxb_0_paxb_hotswap_debug_stat[0]=(((r).paxb_0_paxb_hotswap_debug_stat[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))

/*
 * These macros can be used to access PAXB_0_PAXB_HOTSWAP_DEBUG_STAT.
 */
#define READ_PAXB_0_PAXB_HOTSWAP_DEBUG_STATr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_OFFSET,r._paxb_0_paxb_hotswap_debug_stat)
#define WRITE_PAXB_0_PAXB_HOTSWAP_DEBUG_STATr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_HOTSWAP_DEBUG_STATr_OFFSET,r._paxb_0_paxb_hotswap_debug_stat)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_HOTSWAP_DEBUG_STATr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_HOTSWAP_STAT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_HOTSWAP_STATr_OFFSET 0x18012f58

#define PAXB_0_PAXB_HOTSWAP_STATr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_HOTSWAP_STAT.
 */
typedef union PAXB_0_PAXB_HOTSWAP_STATr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_hotswap_stat[1];
    uint32_t _paxb_0_paxb_hotswap_stat;
} PAXB_0_PAXB_HOTSWAP_STATr_t;

#define PAXB_0_PAXB_HOTSWAP_STATr_CLR(r) (r).paxb_0_paxb_hotswap_stat[0] = 0
#define PAXB_0_PAXB_HOTSWAP_STATr_SET(r,d) (r).paxb_0_paxb_hotswap_stat[0] = d
#define PAXB_0_PAXB_HOTSWAP_STATr_GET(r) (r).paxb_0_paxb_hotswap_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_HOTSWAP_STATr_PAXB_RDYf_GET(r) (((r).paxb_0_paxb_hotswap_stat[0]) & 0x1)
#define PAXB_0_PAXB_HOTSWAP_STATr_PAXB_RDYf_SET(r,f) (r).paxb_0_paxb_hotswap_stat[0]=(((r).paxb_0_paxb_hotswap_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define PAXB_0_PAXB_HOTSWAP_STATr_HOTSWAP_CAUSEf_GET(r) ((((r).paxb_0_paxb_hotswap_stat[0]) >> 1) & 0x7)
#define PAXB_0_PAXB_HOTSWAP_STATr_HOTSWAP_CAUSEf_SET(r,f) (r).paxb_0_paxb_hotswap_stat[0]=(((r).paxb_0_paxb_hotswap_stat[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define PAXB_0_PAXB_HOTSWAP_STATr_FSM_STATEf_GET(r) ((((r).paxb_0_paxb_hotswap_stat[0]) >> 4) & 0x3)
#define PAXB_0_PAXB_HOTSWAP_STATr_FSM_STATEf_SET(r,f) (r).paxb_0_paxb_hotswap_stat[0]=(((r).paxb_0_paxb_hotswap_stat[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))

/*
 * These macros can be used to access PAXB_0_PAXB_HOTSWAP_STAT.
 */
#define READ_PAXB_0_PAXB_HOTSWAP_STATr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_HOTSWAP_STATr_OFFSET,r._paxb_0_paxb_hotswap_stat)
#define WRITE_PAXB_0_PAXB_HOTSWAP_STATr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_HOTSWAP_STATr_OFFSET,r._paxb_0_paxb_hotswap_stat)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_HOTSWAP_STATr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLRr_OFFSET 0x180123a0

#define PAXB_0_PAXB_IC_INTRCLRr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_IC_INTRCLR.
 */
typedef union PAXB_0_PAXB_IC_INTRCLRr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_ic_intrclr[1];
    uint32_t _paxb_0_paxb_ic_intrclr;
} PAXB_0_PAXB_IC_INTRCLRr_t;

#define PAXB_0_PAXB_IC_INTRCLRr_CLR(r) (r).paxb_0_paxb_ic_intrclr[0] = 0
#define PAXB_0_PAXB_IC_INTRCLRr_SET(r,d) (r).paxb_0_paxb_ic_intrclr[0] = d
#define PAXB_0_PAXB_IC_INTRCLRr_GET(r) (r).paxb_0_paxb_ic_intrclr[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_IC_INTRCLRr_INT31_0f_GET(r) ((r).paxb_0_paxb_ic_intrclr[0])
#define PAXB_0_PAXB_IC_INTRCLRr_INT31_0f_SET(r,f) (r).paxb_0_paxb_ic_intrclr[0]=((uint32_t)f)

/*
 * These macros can be used to access PAXB_0_PAXB_IC_INTRCLR.
 */
#define READ_PAXB_0_PAXB_IC_INTRCLRr(u,i,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_IC_INTRCLRr_OFFSET+(4*(i)),r._paxb_0_paxb_ic_intrclr)
#define WRITE_PAXB_0_PAXB_IC_INTRCLRr(u,i,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_IC_INTRCLRr_OFFSET+(4*(i)),r._paxb_0_paxb_ic_intrclr)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_IC_INTRCLRr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_0r_OFFSET 0x180123a0

#define PAXB_0_PAXB_IC_INTRCLR_0r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_0r is element of PAXB_0_PAXB_IC_INTRCLR */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_1r_OFFSET 0x180123a4

#define PAXB_0_PAXB_IC_INTRCLR_1r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_1r is element of PAXB_0_PAXB_IC_INTRCLR */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_OFFSET 0x180123b0

#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_IC_INTRCLR_DELAY.
 */
typedef union PAXB_0_PAXB_IC_INTRCLR_DELAYr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_ic_intrclr_delay[1];
    uint32_t _paxb_0_paxb_ic_intrclr_delay;
} PAXB_0_PAXB_IC_INTRCLR_DELAYr_t;

#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_CLR(r) (r).paxb_0_paxb_ic_intrclr_delay[0] = 0
#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_SET(r,d) (r).paxb_0_paxb_ic_intrclr_delay[0] = d
#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_GET(r) (r).paxb_0_paxb_ic_intrclr_delay[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_INT0f_GET(r) (((r).paxb_0_paxb_ic_intrclr_delay[0]) & 0xff)
#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_INT0f_SET(r,f) (r).paxb_0_paxb_ic_intrclr_delay[0]=(((r).paxb_0_paxb_ic_intrclr_delay[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_INT1f_GET(r) ((((r).paxb_0_paxb_ic_intrclr_delay[0]) >> 8) & 0xff)
#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_INT1f_SET(r,f) (r).paxb_0_paxb_ic_intrclr_delay[0]=(((r).paxb_0_paxb_ic_intrclr_delay[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_INT2f_GET(r) ((((r).paxb_0_paxb_ic_intrclr_delay[0]) >> 16) & 0xff)
#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_INT2f_SET(r,f) (r).paxb_0_paxb_ic_intrclr_delay[0]=(((r).paxb_0_paxb_ic_intrclr_delay[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_INT3f_GET(r) ((((r).paxb_0_paxb_ic_intrclr_delay[0]) >> 24) & 0xff)
#define PAXB_0_PAXB_IC_INTRCLR_DELAYr_INT3f_SET(r,f) (r).paxb_0_paxb_ic_intrclr_delay[0]=(((r).paxb_0_paxb_ic_intrclr_delay[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PAXB_0_PAXB_IC_INTRCLR_DELAY.
 */
#define READ_PAXB_0_PAXB_IC_INTRCLR_DELAYr(u,i,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_IC_INTRCLR_DELAYr_OFFSET+(4*(i)),r._paxb_0_paxb_ic_intrclr_delay)
#define WRITE_PAXB_0_PAXB_IC_INTRCLR_DELAYr(u,i,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_IC_INTRCLR_DELAYr_OFFSET+(4*(i)),r._paxb_0_paxb_ic_intrclr_delay)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_IC_INTRCLR_DELAYr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_0r_OFFSET 0x180123b0

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_0r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_0r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_10
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_10r_OFFSET 0x180123d8

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_10r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_10r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_11
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_11r_OFFSET 0x180123dc

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_11r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_11r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_12
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_12r_OFFSET 0x180123e0

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_12r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_12r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_13
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_13r_OFFSET 0x180123e4

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_13r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_13r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_14
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_14r_OFFSET 0x180123e8

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_14r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_14r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_15
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_15r_OFFSET 0x180123ec

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_15r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_15r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_1r_OFFSET 0x180123b4

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_1r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_1r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_2r_OFFSET 0x180123b8

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_2r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_2r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_3
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_3r_OFFSET 0x180123bc

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_3r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_3r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_4
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_4r_OFFSET 0x180123c0

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_4r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_4r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_5
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_5r_OFFSET 0x180123c4

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_5r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_5r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_6
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_6r_OFFSET 0x180123c8

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_6r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_6r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_7
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_7r_OFFSET 0x180123cc

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_7r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_7r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_8
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_8r_OFFSET 0x180123d0

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_8r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_8r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_DELAY_9
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_DELAY_9r_OFFSET 0x180123d4

#define PAXB_0_PAXB_IC_INTRCLR_DELAY_9r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_DELAY_9r is element of PAXB_0_PAXB_IC_INTRCLR_DELAY */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_MODE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_MODEr_OFFSET 0x180123a8

#define PAXB_0_PAXB_IC_INTRCLR_MODEr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_IC_INTRCLR_MODE.
 */
typedef union PAXB_0_PAXB_IC_INTRCLR_MODEr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_ic_intrclr_mode[1];
    uint32_t _paxb_0_paxb_ic_intrclr_mode;
} PAXB_0_PAXB_IC_INTRCLR_MODEr_t;

#define PAXB_0_PAXB_IC_INTRCLR_MODEr_CLR(r) (r).paxb_0_paxb_ic_intrclr_mode[0] = 0
#define PAXB_0_PAXB_IC_INTRCLR_MODEr_SET(r,d) (r).paxb_0_paxb_ic_intrclr_mode[0] = d
#define PAXB_0_PAXB_IC_INTRCLR_MODEr_GET(r) (r).paxb_0_paxb_ic_intrclr_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_IC_INTRCLR_MODEr_INT31_0f_GET(r) ((r).paxb_0_paxb_ic_intrclr_mode[0])
#define PAXB_0_PAXB_IC_INTRCLR_MODEr_INT31_0f_SET(r,f) (r).paxb_0_paxb_ic_intrclr_mode[0]=((uint32_t)f)

/*
 * These macros can be used to access PAXB_0_PAXB_IC_INTRCLR_MODE.
 */
#define READ_PAXB_0_PAXB_IC_INTRCLR_MODEr(u,i,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_IC_INTRCLR_MODEr_OFFSET+(4*(i)),r._paxb_0_paxb_ic_intrclr_mode)
#define WRITE_PAXB_0_PAXB_IC_INTRCLR_MODEr(u,i,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_IC_INTRCLR_MODEr_OFFSET+(4*(i)),r._paxb_0_paxb_ic_intrclr_mode)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_IC_INTRCLR_MODEr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_MODE_0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_MODE_0r_OFFSET 0x180123a8

#define PAXB_0_PAXB_IC_INTRCLR_MODE_0r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_MODE_0r is element of PAXB_0_PAXB_IC_INTRCLR_MODE */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTRCLR_MODE_1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTRCLR_MODE_1r_OFFSET 0x180123ac

#define PAXB_0_PAXB_IC_INTRCLR_MODE_1r_SIZE 4

/* PAXB_0_PAXB_IC_INTRCLR_MODE_1r is element of PAXB_0_PAXB_IC_INTRCLR_MODE */

/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_IC_INTR_PACING_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_IC_INTR_PACING_CTRLr_OFFSET 0x18012398

#define PAXB_0_PAXB_IC_INTR_PACING_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_IC_INTR_PACING_CTRL.
 */
typedef union PAXB_0_PAXB_IC_INTR_PACING_CTRLr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_ic_intr_pacing_ctrl[1];
    uint32_t _paxb_0_paxb_ic_intr_pacing_ctrl;
} PAXB_0_PAXB_IC_INTR_PACING_CTRLr_t;

#define PAXB_0_PAXB_IC_INTR_PACING_CTRLr_CLR(r) (r).paxb_0_paxb_ic_intr_pacing_ctrl[0] = 0
#define PAXB_0_PAXB_IC_INTR_PACING_CTRLr_SET(r,d) (r).paxb_0_paxb_ic_intr_pacing_ctrl[0] = d
#define PAXB_0_PAXB_IC_INTR_PACING_CTRLr_GET(r) (r).paxb_0_paxb_ic_intr_pacing_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_IC_INTR_PACING_CTRLr_ENABLEf_GET(r) (((r).paxb_0_paxb_ic_intr_pacing_ctrl[0]) & 0x1)
#define PAXB_0_PAXB_IC_INTR_PACING_CTRLr_ENABLEf_SET(r,f) (r).paxb_0_paxb_ic_intr_pacing_ctrl[0]=(((r).paxb_0_paxb_ic_intr_pacing_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define PAXB_0_PAXB_IC_INTR_PACING_CTRLr_DELAY_UNITf_GET(r) ((((r).paxb_0_paxb_ic_intr_pacing_ctrl[0]) >> 8) & 0xff)
#define PAXB_0_PAXB_IC_INTR_PACING_CTRLr_DELAY_UNITf_SET(r,f) (r).paxb_0_paxb_ic_intr_pacing_ctrl[0]=(((r).paxb_0_paxb_ic_intr_pacing_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define PAXB_0_PAXB_IC_INTR_PACING_CTRLr_MIN_DELAYf_GET(r) ((((r).paxb_0_paxb_ic_intr_pacing_ctrl[0]) >> 16) & 0xffff)
#define PAXB_0_PAXB_IC_INTR_PACING_CTRLr_MIN_DELAYf_SET(r,f) (r).paxb_0_paxb_ic_intr_pacing_ctrl[0]=(((r).paxb_0_paxb_ic_intr_pacing_ctrl[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access PAXB_0_PAXB_IC_INTR_PACING_CTRL.
 */
#define READ_PAXB_0_PAXB_IC_INTR_PACING_CTRLr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_IC_INTR_PACING_CTRLr_OFFSET,r._paxb_0_paxb_ic_intr_pacing_ctrl)
#define WRITE_PAXB_0_PAXB_IC_INTR_PACING_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_IC_INTR_PACING_CTRLr_OFFSET,r._paxb_0_paxb_ic_intr_pacing_ctrl)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_IC_INTR_PACING_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_INTRCLR_DELAY_UNIT
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_INTRCLR_DELAY_UNITr_OFFSET 0x1801239c

#define PAXB_0_PAXB_INTRCLR_DELAY_UNITr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_INTRCLR_DELAY_UNIT.
 */
typedef union PAXB_0_PAXB_INTRCLR_DELAY_UNITr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_intrclr_delay_unit[1];
    uint32_t _paxb_0_paxb_intrclr_delay_unit;
} PAXB_0_PAXB_INTRCLR_DELAY_UNITr_t;

#define PAXB_0_PAXB_INTRCLR_DELAY_UNITr_CLR(r) (r).paxb_0_paxb_intrclr_delay_unit[0] = 0
#define PAXB_0_PAXB_INTRCLR_DELAY_UNITr_SET(r,d) (r).paxb_0_paxb_intrclr_delay_unit[0] = d
#define PAXB_0_PAXB_INTRCLR_DELAY_UNITr_GET(r) (r).paxb_0_paxb_intrclr_delay_unit[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_INTRCLR_DELAY_UNITr_NUM_OF_25M_CLKSf_GET(r) (((r).paxb_0_paxb_intrclr_delay_unit[0]) & 0xffff)
#define PAXB_0_PAXB_INTRCLR_DELAY_UNITr_NUM_OF_25M_CLKSf_SET(r,f) (r).paxb_0_paxb_intrclr_delay_unit[0]=(((r).paxb_0_paxb_intrclr_delay_unit[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PAXB_0_PAXB_INTRCLR_DELAY_UNIT.
 */
#define READ_PAXB_0_PAXB_INTRCLR_DELAY_UNITr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_INTRCLR_DELAY_UNITr_OFFSET,r._paxb_0_paxb_intrclr_delay_unit)
#define WRITE_PAXB_0_PAXB_INTRCLR_DELAY_UNITr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_INTRCLR_DELAY_UNITr_OFFSET,r._paxb_0_paxb_intrclr_delay_unit)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_INTRCLR_DELAY_UNITr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_INTR_EN
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_INTR_ENr_OFFSET 0x18012f30

#define PAXB_0_PAXB_INTR_ENr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_INTR_EN.
 */
typedef union PAXB_0_PAXB_INTR_ENr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_intr_en[1];
    uint32_t _paxb_0_paxb_intr_en;
} PAXB_0_PAXB_INTR_ENr_t;

#define PAXB_0_PAXB_INTR_ENr_CLR(r) (r).paxb_0_paxb_intr_en[0] = 0
#define PAXB_0_PAXB_INTR_ENr_SET(r,d) (r).paxb_0_paxb_intr_en[0] = d
#define PAXB_0_PAXB_INTR_ENr_GET(r) (r).paxb_0_paxb_intr_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_INTR_ENr_PCIE_IN_WAKE_B_INTR_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 4) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_PCIE_IN_WAKE_B_INTR_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define PAXB_0_PAXB_INTR_ENr_PCIE_ERR_ATTN_INTR_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 5) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_PCIE_ERR_ATTN_INTR_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define PAXB_0_PAXB_INTR_ENr_PCIE_CMPL_TIMEOUT_INTR_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 6) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_PCIE_CMPL_TIMEOUT_INTR_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define PAXB_0_PAXB_INTR_ENr_PCIE_ECRC_ERR_INTR_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 7) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_PCIE_ECRC_ERR_INTR_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define PAXB_0_PAXB_INTR_ENr_PAXB_AXI_MASTER_RRESP_DECERR_INTR_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 8) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_PAXB_AXI_MASTER_RRESP_DECERR_INTR_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define PAXB_0_PAXB_INTR_ENr_PAXB_AXI_MASTER_RRESP_SLVERR_INTR_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 9) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_PAXB_AXI_MASTER_RRESP_SLVERR_INTR_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define PAXB_0_PAXB_INTR_ENr_PCIE_OVERFLOW_UNDERFLOW_INTR_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 10) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_PCIE_OVERFLOW_UNDERFLOW_INTR_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define PAXB_0_PAXB_INTR_ENr_APB_TIMEOUT_INTR_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 11) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_APB_TIMEOUT_INTR_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define PAXB_0_PAXB_INTR_ENr_HOTSWAP_SWFLUSHREQ_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 19) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_HOTSWAP_SWFLUSHREQ_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define PAXB_0_PAXB_INTR_ENr_HOTSWAP_ENABLED_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 20) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_HOTSWAP_ENABLED_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define PAXB_0_PAXB_INTR_ENr_ILLEGAL_MSI_REQ_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 21) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_ILLEGAL_MSI_REQ_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define PAXB_0_PAXB_INTR_ENr_ILLEGAL_MSIX_DB_ACCESS_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 22) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_ILLEGAL_MSIX_DB_ACCESS_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define PAXB_0_PAXB_INTR_ENr_MEM_ECC_ERR_ENf_GET(r) ((((r).paxb_0_paxb_intr_en[0]) >> 31) & 0x1)
#define PAXB_0_PAXB_INTR_ENr_MEM_ECC_ERR_ENf_SET(r,f) (r).paxb_0_paxb_intr_en[0]=(((r).paxb_0_paxb_intr_en[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access PAXB_0_PAXB_INTR_EN.
 */
#define READ_PAXB_0_PAXB_INTR_ENr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_INTR_ENr_OFFSET,r._paxb_0_paxb_intr_en)
#define WRITE_PAXB_0_PAXB_INTR_ENr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_INTR_ENr_OFFSET,r._paxb_0_paxb_intr_en)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_INTR_ENr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_PAXB_INTR_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_PAXB_INTR_STATUSr_OFFSET 0x18012f38

#define PAXB_0_PAXB_INTR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_PAXB_INTR_STATUS.
 */
typedef union PAXB_0_PAXB_INTR_STATUSr_s {
    uint32_t v[1];
    uint32_t paxb_0_paxb_intr_status[1];
    uint32_t _paxb_0_paxb_intr_status;
} PAXB_0_PAXB_INTR_STATUSr_t;

#define PAXB_0_PAXB_INTR_STATUSr_CLR(r) (r).paxb_0_paxb_intr_status[0] = 0
#define PAXB_0_PAXB_INTR_STATUSr_SET(r,d) (r).paxb_0_paxb_intr_status[0] = d
#define PAXB_0_PAXB_INTR_STATUSr_GET(r) (r).paxb_0_paxb_intr_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_PAXB_INTR_STATUSr_PCIE_IN_WAKE_B_INTR_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 4) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_PCIE_IN_WAKE_B_INTR_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define PAXB_0_PAXB_INTR_STATUSr_PCIE_ERR_ATTN_INTR_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 5) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_PCIE_ERR_ATTN_INTR_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define PAXB_0_PAXB_INTR_STATUSr_PCIE_CMPL_TIMEOUT_INTR_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 6) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_PCIE_CMPL_TIMEOUT_INTR_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define PAXB_0_PAXB_INTR_STATUSr_PCIE_ECRC_ERR_INTR_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 7) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_PCIE_ECRC_ERR_INTR_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define PAXB_0_PAXB_INTR_STATUSr_PAXB_AXI_MASTER_RRESP_DECERR_INTR_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 8) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_PAXB_AXI_MASTER_RRESP_DECERR_INTR_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define PAXB_0_PAXB_INTR_STATUSr_PAXB_AXI_MASTER_RRESP_SLVERR_INTR_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 9) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_PAXB_AXI_MASTER_RRESP_SLVERR_INTR_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define PAXB_0_PAXB_INTR_STATUSr_PCIE_OVERFLOW_UNDERFLOW_INTR_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 10) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_PCIE_OVERFLOW_UNDERFLOW_INTR_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define PAXB_0_PAXB_INTR_STATUSr_APB_TIMEOUT_INTR_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 11) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_APB_TIMEOUT_INTR_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define PAXB_0_PAXB_INTR_STATUSr_HOTSWAP_SWFLUSHREQ_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 19) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_HOTSWAP_SWFLUSHREQ_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define PAXB_0_PAXB_INTR_STATUSr_HOTSWAP_ENABLED_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 20) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_HOTSWAP_ENABLED_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define PAXB_0_PAXB_INTR_STATUSr_ILLEGAL_MSI_REQ_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 21) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_ILLEGAL_MSI_REQ_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define PAXB_0_PAXB_INTR_STATUSr_ILLEGAL_MSIX_DB_ACCESS_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 22) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_ILLEGAL_MSIX_DB_ACCESS_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define PAXB_0_PAXB_INTR_STATUSr_MEM_ECC_ERR_STATUSf_GET(r) ((((r).paxb_0_paxb_intr_status[0]) >> 31) & 0x1)
#define PAXB_0_PAXB_INTR_STATUSr_MEM_ECC_ERR_STATUSf_SET(r,f) (r).paxb_0_paxb_intr_status[0]=(((r).paxb_0_paxb_intr_status[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access PAXB_0_PAXB_INTR_STATUS.
 */
#define READ_PAXB_0_PAXB_INTR_STATUSr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_PAXB_INTR_STATUSr_OFFSET,r._paxb_0_paxb_intr_status)
#define WRITE_PAXB_0_PAXB_INTR_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_PAXB_INTR_STATUSr_OFFSET,r._paxb_0_paxb_intr_status)

/*******************************************************************************
 * End of 'PAXB_0_PAXB_INTR_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWN
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_OFFSET 0x18012f18

#define PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWN.
 */
typedef union PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_s {
    uint32_t v[1];
    uint32_t paxb_0_reset_enable_in_pcie_link_down[1];
    uint32_t _paxb_0_reset_enable_in_pcie_link_down;
} PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_t;

#define PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_CLR(r) (r).paxb_0_reset_enable_in_pcie_link_down[0] = 0
#define PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_SET(r,d) (r).paxb_0_reset_enable_in_pcie_link_down[0] = d
#define PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_GET(r) (r).paxb_0_reset_enable_in_pcie_link_down[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_EN_IPROC_RESETf_GET(r) (((r).paxb_0_reset_enable_in_pcie_link_down[0]) & 0x1)
#define PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_EN_IPROC_RESETf_SET(r,f) (r).paxb_0_reset_enable_in_pcie_link_down[0]=(((r).paxb_0_reset_enable_in_pcie_link_down[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_EN_PAXB_RESETf_GET(r) ((((r).paxb_0_reset_enable_in_pcie_link_down[0]) >> 1) & 0x1)
#define PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_EN_PAXB_RESETf_SET(r,f) (r).paxb_0_reset_enable_in_pcie_link_down[0]=(((r).paxb_0_reset_enable_in_pcie_link_down[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_EN_CHIP_RESETf_GET(r) ((((r).paxb_0_reset_enable_in_pcie_link_down[0]) >> 2) & 0x1)
#define PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_EN_CHIP_RESETf_SET(r,f) (r).paxb_0_reset_enable_in_pcie_link_down[0]=(((r).paxb_0_reset_enable_in_pcie_link_down[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWN.
 */
#define READ_PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_OFFSET,r._paxb_0_reset_enable_in_pcie_link_down)
#define WRITE_PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr_OFFSET,r._paxb_0_reset_enable_in_pcie_link_down)

/*******************************************************************************
 * End of 'PAXB_0_RESET_ENABLE_IN_PCIE_LINK_DOWNr'
 */




/*******************************************************************************
 * REGISTER:  PAXB_0_RESET_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define PAXB_0_RESET_STATUSr_OFFSET 0x18012f14

#define PAXB_0_RESET_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program PAXB_0_RESET_STATUS.
 */
typedef union PAXB_0_RESET_STATUSr_s {
    uint32_t v[1];
    uint32_t paxb_0_reset_status[1];
    uint32_t _paxb_0_reset_status;
} PAXB_0_RESET_STATUSr_t;

#define PAXB_0_RESET_STATUSr_CLR(r) (r).paxb_0_reset_status[0] = 0
#define PAXB_0_RESET_STATUSr_SET(r,d) (r).paxb_0_reset_status[0] = d
#define PAXB_0_RESET_STATUSr_GET(r) (r).paxb_0_reset_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define PAXB_0_RESET_STATUSr_RC_PERST_Bf_GET(r) (((r).paxb_0_reset_status[0]) & 0x1)
#define PAXB_0_RESET_STATUSr_RC_PERST_Bf_SET(r,f) (r).paxb_0_reset_status[0]=(((r).paxb_0_reset_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define PAXB_0_RESET_STATUSr_EP_PERST_Bf_GET(r) ((((r).paxb_0_reset_status[0]) >> 1) & 0x1)
#define PAXB_0_RESET_STATUSr_EP_PERST_Bf_SET(r,f) (r).paxb_0_reset_status[0]=(((r).paxb_0_reset_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define PAXB_0_RESET_STATUSr_PERST_Bf_GET(r) ((((r).paxb_0_reset_status[0]) >> 2) & 0x1)
#define PAXB_0_RESET_STATUSr_PERST_Bf_SET(r,f) (r).paxb_0_reset_status[0]=(((r).paxb_0_reset_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define PAXB_0_RESET_STATUSr_SOFT_RESET_Nf_GET(r) ((((r).paxb_0_reset_status[0]) >> 3) & 0x1)
#define PAXB_0_RESET_STATUSr_SOFT_RESET_Nf_SET(r,f) (r).paxb_0_reset_status[0]=(((r).paxb_0_reset_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define PAXB_0_RESET_STATUSr_HARD_RST_Bf_GET(r) ((((r).paxb_0_reset_status[0]) >> 4) & 0x1)
#define PAXB_0_RESET_STATUSr_HARD_RST_Bf_SET(r,f) (r).paxb_0_reset_status[0]=(((r).paxb_0_reset_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define PAXB_0_RESET_STATUSr_REG_HARD_RST_Bf_GET(r) ((((r).paxb_0_reset_status[0]) >> 5) & 0x1)
#define PAXB_0_RESET_STATUSr_REG_HARD_RST_Bf_SET(r,f) (r).paxb_0_reset_status[0]=(((r).paxb_0_reset_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define PAXB_0_RESET_STATUSr_PCIE_SLAVEMODE_IPROC_RST_Nf_GET(r) ((((r).paxb_0_reset_status[0]) >> 6) & 0x1)
#define PAXB_0_RESET_STATUSr_PCIE_SLAVEMODE_IPROC_RST_Nf_SET(r,f) (r).paxb_0_reset_status[0]=(((r).paxb_0_reset_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define PAXB_0_RESET_STATUSr_PCIE_SLAVEMODE_CHIP_RST_Nf_GET(r) ((((r).paxb_0_reset_status[0]) >> 7) & 0x1)
#define PAXB_0_RESET_STATUSr_PCIE_SLAVEMODE_CHIP_RST_Nf_SET(r,f) (r).paxb_0_reset_status[0]=(((r).paxb_0_reset_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define PAXB_0_RESET_STATUSr_PCIE_RC_MODE_PERST_Bf_GET(r) ((((r).paxb_0_reset_status[0]) >> 8) & 0x1)
#define PAXB_0_RESET_STATUSr_PCIE_RC_MODE_PERST_Bf_SET(r,f) (r).paxb_0_reset_status[0]=(((r).paxb_0_reset_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define PAXB_0_RESET_STATUSr_PCIE_PHY_PIPE_RESETMDIO_Nf_GET(r) ((((r).paxb_0_reset_status[0]) >> 9) & 0x1)
#define PAXB_0_RESET_STATUSr_PCIE_PHY_PIPE_RESETMDIO_Nf_SET(r,f) (r).paxb_0_reset_status[0]=(((r).paxb_0_reset_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define PAXB_0_RESET_STATUSr_PAXB_RST_Nf_GET(r) ((((r).paxb_0_reset_status[0]) >> 10) & 0x1)
#define PAXB_0_RESET_STATUSr_PAXB_RST_Nf_SET(r,f) (r).paxb_0_reset_status[0]=(((r).paxb_0_reset_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))

/*
 * These macros can be used to access PAXB_0_RESET_STATUS.
 */
#define READ_PAXB_0_RESET_STATUSr(u,r) BCMDRD_IPROC_READ(u,PAXB_0_RESET_STATUSr_OFFSET,r._paxb_0_reset_status)
#define WRITE_PAXB_0_RESET_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,PAXB_0_RESET_STATUSr_OFFSET,r._paxb_0_reset_status)

/*******************************************************************************
 * End of 'PAXB_0_RESET_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_B0_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_B0_CTRLr_OFFSET 0x18021018

#define QSPI_BSPI_B0_CTRLr_SIZE 4

/* QSPI_BSPI_B0_CTRLr is element of QSPI_bspi_B_CTRL */

/*******************************************************************************
 * REGISTER:  QSPI_bspi_B0_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_B0_STATUSr_OFFSET 0x18021014

#define QSPI_BSPI_B0_STATUSr_SIZE 4

/* QSPI_BSPI_B0_STATUSr is element of QSPI_bspi_B_STATUS */

/*******************************************************************************
 * REGISTER:  QSPI_bspi_B1_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_B1_CTRLr_OFFSET 0x18021020

#define QSPI_BSPI_B1_CTRLr_SIZE 4

/* QSPI_BSPI_B1_CTRLr is element of QSPI_bspi_B_CTRL */

/*******************************************************************************
 * REGISTER:  QSPI_bspi_B1_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_B1_STATUSr_OFFSET 0x1802101c

#define QSPI_BSPI_B1_STATUSr_SIZE 4

/* QSPI_BSPI_B1_STATUSr is element of QSPI_bspi_B_STATUS */

/*******************************************************************************
 * REGISTER:  QSPI_bspi_BITS_PER_CYCLE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_BITS_PER_CYCLEr_OFFSET 0x1802102c

#define QSPI_BSPI_BITS_PER_CYCLEr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_BITS_PER_CYCLE.
 */
typedef union QSPI_BSPI_BITS_PER_CYCLEr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_bits_per_cycle[1];
    uint32_t _qspi_bspi_bits_per_cycle;
} QSPI_BSPI_BITS_PER_CYCLEr_t;

#define QSPI_BSPI_BITS_PER_CYCLEr_CLR(r) (r).qspi_bspi_bits_per_cycle[0] = 0
#define QSPI_BSPI_BITS_PER_CYCLEr_SET(r,d) (r).qspi_bspi_bits_per_cycle[0] = d
#define QSPI_BSPI_BITS_PER_CYCLEr_GET(r) (r).qspi_bspi_bits_per_cycle[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_BITS_PER_CYCLEr_DATA_BPC_SELECTf_GET(r) (((r).qspi_bspi_bits_per_cycle[0]) & 0x3)
#define QSPI_BSPI_BITS_PER_CYCLEr_DATA_BPC_SELECTf_SET(r,f) (r).qspi_bspi_bits_per_cycle[0]=(((r).qspi_bspi_bits_per_cycle[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define QSPI_BSPI_BITS_PER_CYCLEr_RESERVEDf_GET(r) ((((r).qspi_bspi_bits_per_cycle[0]) >> 2) & 0x3f)
#define QSPI_BSPI_BITS_PER_CYCLEr_RESERVEDf_SET(r,f) (r).qspi_bspi_bits_per_cycle[0]=(((r).qspi_bspi_bits_per_cycle[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define QSPI_BSPI_BITS_PER_CYCLEr_MODE_BPC_SELECTf_GET(r) ((((r).qspi_bspi_bits_per_cycle[0]) >> 8) & 0x3)
#define QSPI_BSPI_BITS_PER_CYCLEr_MODE_BPC_SELECTf_SET(r,f) (r).qspi_bspi_bits_per_cycle[0]=(((r).qspi_bspi_bits_per_cycle[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define QSPI_BSPI_BITS_PER_CYCLEr_ADDR_BPC_SELECTf_GET(r) ((((r).qspi_bspi_bits_per_cycle[0]) >> 16) & 0x3)
#define QSPI_BSPI_BITS_PER_CYCLEr_ADDR_BPC_SELECTf_SET(r,f) (r).qspi_bspi_bits_per_cycle[0]=(((r).qspi_bspi_bits_per_cycle[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define QSPI_BSPI_BITS_PER_CYCLEr_CMD_BPC_SELECTf_GET(r) ((((r).qspi_bspi_bits_per_cycle[0]) >> 24) & 0x3)
#define QSPI_BSPI_BITS_PER_CYCLEr_CMD_BPC_SELECTf_SET(r,f) (r).qspi_bspi_bits_per_cycle[0]=(((r).qspi_bspi_bits_per_cycle[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))

/*
 * These macros can be used to access QSPI_bspi_BITS_PER_CYCLE.
 */
#define READ_QSPI_BSPI_BITS_PER_CYCLEr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_BITS_PER_CYCLEr_OFFSET,r._qspi_bspi_bits_per_cycle)
#define WRITE_QSPI_BSPI_BITS_PER_CYCLEr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_BITS_PER_CYCLEr_OFFSET,r._qspi_bspi_bits_per_cycle)

/*******************************************************************************
 * End of 'QSPI_BSPI_BITS_PER_CYCLEr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_BITS_PER_PHASE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_BITS_PER_PHASEr_OFFSET 0x18021030

#define QSPI_BSPI_BITS_PER_PHASEr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_BITS_PER_PHASE.
 */
typedef union QSPI_BSPI_BITS_PER_PHASEr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_bits_per_phase[1];
    uint32_t _qspi_bspi_bits_per_phase;
} QSPI_BSPI_BITS_PER_PHASEr_t;

#define QSPI_BSPI_BITS_PER_PHASEr_CLR(r) (r).qspi_bspi_bits_per_phase[0] = 0
#define QSPI_BSPI_BITS_PER_PHASEr_SET(r,d) (r).qspi_bspi_bits_per_phase[0] = d
#define QSPI_BSPI_BITS_PER_PHASEr_GET(r) (r).qspi_bspi_bits_per_phase[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_BITS_PER_PHASEr_DUMMY_CYCLESf_GET(r) (((r).qspi_bspi_bits_per_phase[0]) & 0xff)
#define QSPI_BSPI_BITS_PER_PHASEr_DUMMY_CYCLESf_SET(r,f) (r).qspi_bspi_bits_per_phase[0]=(((r).qspi_bspi_bits_per_phase[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define QSPI_BSPI_BITS_PER_PHASEr_MODE_BPPf_GET(r) ((((r).qspi_bspi_bits_per_phase[0]) >> 8) & 0x1)
#define QSPI_BSPI_BITS_PER_PHASEr_MODE_BPPf_SET(r,f) (r).qspi_bspi_bits_per_phase[0]=(((r).qspi_bspi_bits_per_phase[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define QSPI_BSPI_BITS_PER_PHASEr_RESERVEDf_GET(r) ((((r).qspi_bspi_bits_per_phase[0]) >> 9) & 0x7f)
#define QSPI_BSPI_BITS_PER_PHASEr_RESERVEDf_SET(r,f) (r).qspi_bspi_bits_per_phase[0]=(((r).qspi_bspi_bits_per_phase[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define QSPI_BSPI_BITS_PER_PHASEr_ADDR_BPP_SELECTf_GET(r) ((((r).qspi_bspi_bits_per_phase[0]) >> 16) & 0x1)
#define QSPI_BSPI_BITS_PER_PHASEr_ADDR_BPP_SELECTf_SET(r,f) (r).qspi_bspi_bits_per_phase[0]=(((r).qspi_bspi_bits_per_phase[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define QSPI_BSPI_BITS_PER_PHASEr_CMD_BPP_SELECTf_GET(r) ((((r).qspi_bspi_bits_per_phase[0]) >> 24) & 0x1)
#define QSPI_BSPI_BITS_PER_PHASEr_CMD_BPP_SELECTf_SET(r,f) (r).qspi_bspi_bits_per_phase[0]=(((r).qspi_bspi_bits_per_phase[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))

/*
 * These macros can be used to access QSPI_bspi_BITS_PER_PHASE.
 */
#define READ_QSPI_BSPI_BITS_PER_PHASEr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_BITS_PER_PHASEr_OFFSET,r._qspi_bspi_bits_per_phase)
#define WRITE_QSPI_BSPI_BITS_PER_PHASEr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_BITS_PER_PHASEr_OFFSET,r._qspi_bspi_bits_per_phase)

/*******************************************************************************
 * End of 'QSPI_BSPI_BITS_PER_PHASEr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_BSPI_FLASH_UPPER_ADDR_BYTE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_OFFSET 0x18021038

#define QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_BSPI_FLASH_UPPER_ADDR_BYTE.
 */
typedef union QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_bspi_flash_upper_addr_byte[1];
    uint32_t _qspi_bspi_bspi_flash_upper_addr_byte;
} QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_t;

#define QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_CLR(r) (r).qspi_bspi_bspi_flash_upper_addr_byte[0] = 0
#define QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_SET(r,d) (r).qspi_bspi_bspi_flash_upper_addr_byte[0] = d
#define QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_GET(r) (r).qspi_bspi_bspi_flash_upper_addr_byte[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_RESERVEDf_GET(r) (((r).qspi_bspi_bspi_flash_upper_addr_byte[0]) & 0xffffff)
#define QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_RESERVEDf_SET(r,f) (r).qspi_bspi_bspi_flash_upper_addr_byte[0]=(((r).qspi_bspi_bspi_flash_upper_addr_byte[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_BSPI_FLASH_UPPER_ADDRf_GET(r) ((((r).qspi_bspi_bspi_flash_upper_addr_byte[0]) >> 24) & 0xff)
#define QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_BSPI_FLASH_UPPER_ADDRf_SET(r,f) (r).qspi_bspi_bspi_flash_upper_addr_byte[0]=(((r).qspi_bspi_bspi_flash_upper_addr_byte[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access QSPI_bspi_BSPI_FLASH_UPPER_ADDR_BYTE.
 */
#define READ_QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_OFFSET,r._qspi_bspi_bspi_flash_upper_addr_byte)
#define WRITE_QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr_OFFSET,r._qspi_bspi_bspi_flash_upper_addr_byte)

/*******************************************************************************
 * End of 'QSPI_BSPI_BSPI_FLASH_UPPER_ADDR_BYTEr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_BSPI_PIO_DATA
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_BSPI_PIO_DATAr_OFFSET 0x1802104c

#define QSPI_BSPI_BSPI_PIO_DATAr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_BSPI_PIO_DATA.
 */
typedef union QSPI_BSPI_BSPI_PIO_DATAr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_bspi_pio_data[1];
    uint32_t _qspi_bspi_bspi_pio_data;
} QSPI_BSPI_BSPI_PIO_DATAr_t;

#define QSPI_BSPI_BSPI_PIO_DATAr_CLR(r) (r).qspi_bspi_bspi_pio_data[0] = 0
#define QSPI_BSPI_BSPI_PIO_DATAr_SET(r,d) (r).qspi_bspi_bspi_pio_data[0] = d
#define QSPI_BSPI_BSPI_PIO_DATAr_GET(r) (r).qspi_bspi_bspi_pio_data[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_BSPI_PIO_DATAr_BSPI_PIO_DATAf_GET(r) (((r).qspi_bspi_bspi_pio_data[0]) & 0x7)
#define QSPI_BSPI_BSPI_PIO_DATAr_BSPI_PIO_DATAf_SET(r,f) (r).qspi_bspi_bspi_pio_data[0]=(((r).qspi_bspi_bspi_pio_data[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define QSPI_BSPI_BSPI_PIO_DATAr_RESERVEDf_GET(r) ((((r).qspi_bspi_bspi_pio_data[0]) >> 3) & 0x1fffffff)
#define QSPI_BSPI_BSPI_PIO_DATAr_RESERVEDf_SET(r,f) (r).qspi_bspi_bspi_pio_data[0]=(((r).qspi_bspi_bspi_pio_data[0] & ~((uint32_t)0x1fffffff << 3)) | ((((uint32_t)f) & 0x1fffffff) << 3))

/*
 * These macros can be used to access QSPI_bspi_BSPI_PIO_DATA.
 */
#define READ_QSPI_BSPI_BSPI_PIO_DATAr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_BSPI_PIO_DATAr_OFFSET,r._qspi_bspi_bspi_pio_data)
#define WRITE_QSPI_BSPI_BSPI_PIO_DATAr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_BSPI_PIO_DATAr_OFFSET,r._qspi_bspi_bspi_pio_data)

/*******************************************************************************
 * End of 'QSPI_BSPI_BSPI_PIO_DATAr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_BSPI_PIO_IODIR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_BSPI_PIO_IODIRr_OFFSET 0x18021048

#define QSPI_BSPI_BSPI_PIO_IODIRr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_BSPI_PIO_IODIR.
 */
typedef union QSPI_BSPI_BSPI_PIO_IODIRr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_bspi_pio_iodir[1];
    uint32_t _qspi_bspi_bspi_pio_iodir;
} QSPI_BSPI_BSPI_PIO_IODIRr_t;

#define QSPI_BSPI_BSPI_PIO_IODIRr_CLR(r) (r).qspi_bspi_bspi_pio_iodir[0] = 0
#define QSPI_BSPI_BSPI_PIO_IODIRr_SET(r,d) (r).qspi_bspi_bspi_pio_iodir[0] = d
#define QSPI_BSPI_BSPI_PIO_IODIRr_GET(r) (r).qspi_bspi_bspi_pio_iodir[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_BSPI_PIO_IODIRr_BSPI_PIO_DIRf_GET(r) (((r).qspi_bspi_bspi_pio_iodir[0]) & 0x7)
#define QSPI_BSPI_BSPI_PIO_IODIRr_BSPI_PIO_DIRf_SET(r,f) (r).qspi_bspi_bspi_pio_iodir[0]=(((r).qspi_bspi_bspi_pio_iodir[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define QSPI_BSPI_BSPI_PIO_IODIRr_RESERVEDf_GET(r) ((((r).qspi_bspi_bspi_pio_iodir[0]) >> 3) & 0x1fffffff)
#define QSPI_BSPI_BSPI_PIO_IODIRr_RESERVEDf_SET(r,f) (r).qspi_bspi_bspi_pio_iodir[0]=(((r).qspi_bspi_bspi_pio_iodir[0] & ~((uint32_t)0x1fffffff << 3)) | ((((uint32_t)f) & 0x1fffffff) << 3))

/*
 * These macros can be used to access QSPI_bspi_BSPI_PIO_IODIR.
 */
#define READ_QSPI_BSPI_BSPI_PIO_IODIRr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_BSPI_PIO_IODIRr_OFFSET,r._qspi_bspi_bspi_pio_iodir)
#define WRITE_QSPI_BSPI_BSPI_PIO_IODIRr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_BSPI_PIO_IODIRr_OFFSET,r._qspi_bspi_bspi_pio_iodir)

/*******************************************************************************
 * End of 'QSPI_BSPI_BSPI_PIO_IODIRr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_BSPI_PIO_MODE_ENABLE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_OFFSET 0x18021044

#define QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_BSPI_PIO_MODE_ENABLE.
 */
typedef union QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_bspi_pio_mode_enable[1];
    uint32_t _qspi_bspi_bspi_pio_mode_enable;
} QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_t;

#define QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_CLR(r) (r).qspi_bspi_bspi_pio_mode_enable[0] = 0
#define QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_SET(r,d) (r).qspi_bspi_bspi_pio_mode_enable[0] = d
#define QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_GET(r) (r).qspi_bspi_bspi_pio_mode_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_BSPI_PIO_MODEf_GET(r) (((r).qspi_bspi_bspi_pio_mode_enable[0]) & 0x1)
#define QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_BSPI_PIO_MODEf_SET(r,f) (r).qspi_bspi_bspi_pio_mode_enable[0]=(((r).qspi_bspi_bspi_pio_mode_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_RESERVEDf_GET(r) ((((r).qspi_bspi_bspi_pio_mode_enable[0]) >> 1) & 0x7fffffff)
#define QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_RESERVEDf_SET(r,f) (r).qspi_bspi_bspi_pio_mode_enable[0]=(((r).qspi_bspi_bspi_pio_mode_enable[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access QSPI_bspi_BSPI_PIO_MODE_ENABLE.
 */
#define READ_QSPI_BSPI_BSPI_PIO_MODE_ENABLEr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_OFFSET,r._qspi_bspi_bspi_pio_mode_enable)
#define WRITE_QSPI_BSPI_BSPI_PIO_MODE_ENABLEr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_BSPI_PIO_MODE_ENABLEr_OFFSET,r._qspi_bspi_bspi_pio_mode_enable)

/*******************************************************************************
 * End of 'QSPI_BSPI_BSPI_PIO_MODE_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_BSPI_XOR_ENABLE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_BSPI_XOR_ENABLEr_OFFSET 0x18021040

#define QSPI_BSPI_BSPI_XOR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_BSPI_XOR_ENABLE.
 */
typedef union QSPI_BSPI_BSPI_XOR_ENABLEr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_bspi_xor_enable[1];
    uint32_t _qspi_bspi_bspi_xor_enable;
} QSPI_BSPI_BSPI_XOR_ENABLEr_t;

#define QSPI_BSPI_BSPI_XOR_ENABLEr_CLR(r) (r).qspi_bspi_bspi_xor_enable[0] = 0
#define QSPI_BSPI_BSPI_XOR_ENABLEr_SET(r,d) (r).qspi_bspi_bspi_xor_enable[0] = d
#define QSPI_BSPI_BSPI_XOR_ENABLEr_GET(r) (r).qspi_bspi_bspi_xor_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_BSPI_XOR_ENABLEr_BSPI_XOR_ENABLEf_GET(r) (((r).qspi_bspi_bspi_xor_enable[0]) & 0x1)
#define QSPI_BSPI_BSPI_XOR_ENABLEr_BSPI_XOR_ENABLEf_SET(r,f) (r).qspi_bspi_bspi_xor_enable[0]=(((r).qspi_bspi_bspi_xor_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_BSPI_BSPI_XOR_ENABLEr_RESERVEDf_GET(r) ((((r).qspi_bspi_bspi_xor_enable[0]) >> 1) & 0x7fffffff)
#define QSPI_BSPI_BSPI_XOR_ENABLEr_RESERVEDf_SET(r,f) (r).qspi_bspi_bspi_xor_enable[0]=(((r).qspi_bspi_bspi_xor_enable[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access QSPI_bspi_BSPI_XOR_ENABLE.
 */
#define READ_QSPI_BSPI_BSPI_XOR_ENABLEr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_BSPI_XOR_ENABLEr_OFFSET,r._qspi_bspi_bspi_xor_enable)
#define WRITE_QSPI_BSPI_BSPI_XOR_ENABLEr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_BSPI_XOR_ENABLEr_OFFSET,r._qspi_bspi_bspi_xor_enable)

/*******************************************************************************
 * End of 'QSPI_BSPI_BSPI_XOR_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_BSPI_XOR_VALUE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_BSPI_XOR_VALUEr_OFFSET 0x1802103c

#define QSPI_BSPI_BSPI_XOR_VALUEr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_BSPI_XOR_VALUE.
 */
typedef union QSPI_BSPI_BSPI_XOR_VALUEr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_bspi_xor_value[1];
    uint32_t _qspi_bspi_bspi_xor_value;
} QSPI_BSPI_BSPI_XOR_VALUEr_t;

#define QSPI_BSPI_BSPI_XOR_VALUEr_CLR(r) (r).qspi_bspi_bspi_xor_value[0] = 0
#define QSPI_BSPI_BSPI_XOR_VALUEr_SET(r,d) (r).qspi_bspi_bspi_xor_value[0] = d
#define QSPI_BSPI_BSPI_XOR_VALUEr_GET(r) (r).qspi_bspi_bspi_xor_value[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_BSPI_XOR_VALUEr_RESERVEDf_GET(r) (((r).qspi_bspi_bspi_xor_value[0]) & 0xfffff)
#define QSPI_BSPI_BSPI_XOR_VALUEr_RESERVEDf_SET(r,f) (r).qspi_bspi_bspi_xor_value[0]=(((r).qspi_bspi_bspi_xor_value[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define QSPI_BSPI_BSPI_XOR_VALUEr_BSPI_XOR_VALUEf_GET(r) ((((r).qspi_bspi_bspi_xor_value[0]) >> 20) & 0xfff)
#define QSPI_BSPI_BSPI_XOR_VALUEr_BSPI_XOR_VALUEf_SET(r,f) (r).qspi_bspi_bspi_xor_value[0]=(((r).qspi_bspi_bspi_xor_value[0] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))

/*
 * These macros can be used to access QSPI_bspi_BSPI_XOR_VALUE.
 */
#define READ_QSPI_BSPI_BSPI_XOR_VALUEr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_BSPI_XOR_VALUEr_OFFSET,r._qspi_bspi_bspi_xor_value)
#define WRITE_QSPI_BSPI_BSPI_XOR_VALUEr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_BSPI_XOR_VALUEr_OFFSET,r._qspi_bspi_bspi_xor_value)

/*******************************************************************************
 * End of 'QSPI_BSPI_BSPI_XOR_VALUEr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_BUSY_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_BUSY_STATUSr_OFFSET 0x1802100c

#define QSPI_BSPI_BUSY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_BUSY_STATUS.
 */
typedef union QSPI_BSPI_BUSY_STATUSr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_busy_status[1];
    uint32_t _qspi_bspi_busy_status;
} QSPI_BSPI_BUSY_STATUSr_t;

#define QSPI_BSPI_BUSY_STATUSr_CLR(r) (r).qspi_bspi_busy_status[0] = 0
#define QSPI_BSPI_BUSY_STATUSr_SET(r,d) (r).qspi_bspi_busy_status[0] = d
#define QSPI_BSPI_BUSY_STATUSr_GET(r) (r).qspi_bspi_busy_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_BUSY_STATUSr_BUSYf_GET(r) (((r).qspi_bspi_busy_status[0]) & 0x1)
#define QSPI_BSPI_BUSY_STATUSr_BUSYf_SET(r,f) (r).qspi_bspi_busy_status[0]=(((r).qspi_bspi_busy_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_BSPI_BUSY_STATUSr_RESERVEDf_GET(r) ((((r).qspi_bspi_busy_status[0]) >> 1) & 0x7fffffff)
#define QSPI_BSPI_BUSY_STATUSr_RESERVEDf_SET(r,f) (r).qspi_bspi_busy_status[0]=(((r).qspi_bspi_busy_status[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access QSPI_bspi_BUSY_STATUS.
 */
#define READ_QSPI_BSPI_BUSY_STATUSr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_BUSY_STATUSr_OFFSET,r._qspi_bspi_busy_status)
#define WRITE_QSPI_BSPI_BUSY_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_BUSY_STATUSr_OFFSET,r._qspi_bspi_busy_status)

/*******************************************************************************
 * End of 'QSPI_BSPI_BUSY_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_B_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_B_CTRLr_OFFSET 0x18021018

#define QSPI_BSPI_B_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_B_CTRL.
 */
typedef union QSPI_BSPI_B_CTRLr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_b_ctrl[1];
    uint32_t _qspi_bspi_b_ctrl;
} QSPI_BSPI_B_CTRLr_t;

#define QSPI_BSPI_B_CTRLr_CLR(r) (r).qspi_bspi_b_ctrl[0] = 0
#define QSPI_BSPI_B_CTRLr_SET(r,d) (r).qspi_bspi_b_ctrl[0] = d
#define QSPI_BSPI_B_CTRLr_GET(r) (r).qspi_bspi_b_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_B_CTRLr_B0_FLUSHf_GET(r) (((r).qspi_bspi_b_ctrl[0]) & 0x1)
#define QSPI_BSPI_B_CTRLr_B0_FLUSHf_SET(r,f) (r).qspi_bspi_b_ctrl[0]=(((r).qspi_bspi_b_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_BSPI_B_CTRLr_RESERVEDf_GET(r) ((((r).qspi_bspi_b_ctrl[0]) >> 1) & 0x7fffffff)
#define QSPI_BSPI_B_CTRLr_RESERVEDf_SET(r,f) (r).qspi_bspi_b_ctrl[0]=(((r).qspi_bspi_b_ctrl[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access QSPI_bspi_B_CTRL.
 */
#define READ_QSPI_BSPI_B_CTRLr(u,i,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_B_CTRLr_OFFSET+(4*(i)*2),r._qspi_bspi_b_ctrl)
#define WRITE_QSPI_BSPI_B_CTRLr(u,i,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_B_CTRLr_OFFSET+(4*(i)*2),r._qspi_bspi_b_ctrl)

/*******************************************************************************
 * End of 'QSPI_BSPI_B_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_B_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_B_STATUSr_OFFSET 0x18021014

#define QSPI_BSPI_B_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_B_STATUS.
 */
typedef union QSPI_BSPI_B_STATUSr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_b_status[1];
    uint32_t _qspi_bspi_b_status;
} QSPI_BSPI_B_STATUSr_t;

#define QSPI_BSPI_B_STATUSr_CLR(r) (r).qspi_bspi_b_status[0] = 0
#define QSPI_BSPI_B_STATUSr_SET(r,d) (r).qspi_bspi_b_status[0] = d
#define QSPI_BSPI_B_STATUSr_GET(r) (r).qspi_bspi_b_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_B_STATUSr_B0_ADDRESSf_GET(r) (((r).qspi_bspi_b_status[0]) & 0x3ffffff)
#define QSPI_BSPI_B_STATUSr_B0_ADDRESSf_SET(r,f) (r).qspi_bspi_b_status[0]=(((r).qspi_bspi_b_status[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))
#define QSPI_BSPI_B_STATUSr_B0_HITf_GET(r) ((((r).qspi_bspi_b_status[0]) >> 26) & 0x1)
#define QSPI_BSPI_B_STATUSr_B0_HITf_SET(r,f) (r).qspi_bspi_b_status[0]=(((r).qspi_bspi_b_status[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define QSPI_BSPI_B_STATUSr_B0_MISSf_GET(r) ((((r).qspi_bspi_b_status[0]) >> 27) & 0x1)
#define QSPI_BSPI_B_STATUSr_B0_MISSf_SET(r,f) (r).qspi_bspi_b_status[0]=(((r).qspi_bspi_b_status[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define QSPI_BSPI_B_STATUSr_B0_EMPTYf_GET(r) ((((r).qspi_bspi_b_status[0]) >> 28) & 0x1)
#define QSPI_BSPI_B_STATUSr_B0_EMPTYf_SET(r,f) (r).qspi_bspi_b_status[0]=(((r).qspi_bspi_b_status[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define QSPI_BSPI_B_STATUSr_B0_FULLf_GET(r) ((((r).qspi_bspi_b_status[0]) >> 29) & 0x1)
#define QSPI_BSPI_B_STATUSr_B0_FULLf_SET(r,f) (r).qspi_bspi_b_status[0]=(((r).qspi_bspi_b_status[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define QSPI_BSPI_B_STATUSr_B0_PREFETCH_ACTIVEf_GET(r) ((((r).qspi_bspi_b_status[0]) >> 30) & 0x1)
#define QSPI_BSPI_B_STATUSr_B0_PREFETCH_ACTIVEf_SET(r,f) (r).qspi_bspi_b_status[0]=(((r).qspi_bspi_b_status[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define QSPI_BSPI_B_STATUSr_RESERVEDf_GET(r) ((((r).qspi_bspi_b_status[0]) >> 31) & 0x1)
#define QSPI_BSPI_B_STATUSr_RESERVEDf_SET(r,f) (r).qspi_bspi_b_status[0]=(((r).qspi_bspi_b_status[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access QSPI_bspi_B_STATUS.
 */
#define READ_QSPI_BSPI_B_STATUSr(u,i,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_B_STATUSr_OFFSET+(4*(i)*2),r._qspi_bspi_b_status)
#define WRITE_QSPI_BSPI_B_STATUSr(u,i,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_B_STATUSr_OFFSET+(4*(i)*2),r._qspi_bspi_b_status)

/*******************************************************************************
 * End of 'QSPI_BSPI_B_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_CMD_AND_MODE_BYTE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_CMD_AND_MODE_BYTEr_OFFSET 0x18021034

#define QSPI_BSPI_CMD_AND_MODE_BYTEr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_CMD_AND_MODE_BYTE.
 */
typedef union QSPI_BSPI_CMD_AND_MODE_BYTEr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_cmd_and_mode_byte[1];
    uint32_t _qspi_bspi_cmd_and_mode_byte;
} QSPI_BSPI_CMD_AND_MODE_BYTEr_t;

#define QSPI_BSPI_CMD_AND_MODE_BYTEr_CLR(r) (r).qspi_bspi_cmd_and_mode_byte[0] = 0
#define QSPI_BSPI_CMD_AND_MODE_BYTEr_SET(r,d) (r).qspi_bspi_cmd_and_mode_byte[0] = d
#define QSPI_BSPI_CMD_AND_MODE_BYTEr_GET(r) (r).qspi_bspi_cmd_and_mode_byte[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_CMD_AND_MODE_BYTEr_BSPI_CMD_BYTEf_GET(r) (((r).qspi_bspi_cmd_and_mode_byte[0]) & 0xff)
#define QSPI_BSPI_CMD_AND_MODE_BYTEr_BSPI_CMD_BYTEf_SET(r,f) (r).qspi_bspi_cmd_and_mode_byte[0]=(((r).qspi_bspi_cmd_and_mode_byte[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define QSPI_BSPI_CMD_AND_MODE_BYTEr_RESERVEDf_GET(r) ((((r).qspi_bspi_cmd_and_mode_byte[0]) >> 8) & 0xff)
#define QSPI_BSPI_CMD_AND_MODE_BYTEr_RESERVEDf_SET(r,f) (r).qspi_bspi_cmd_and_mode_byte[0]=(((r).qspi_bspi_cmd_and_mode_byte[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define QSPI_BSPI_CMD_AND_MODE_BYTEr_BSPI_MODE_BYTEf_GET(r) ((((r).qspi_bspi_cmd_and_mode_byte[0]) >> 16) & 0xff)
#define QSPI_BSPI_CMD_AND_MODE_BYTEr_BSPI_MODE_BYTEf_SET(r,f) (r).qspi_bspi_cmd_and_mode_byte[0]=(((r).qspi_bspi_cmd_and_mode_byte[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))

/*
 * These macros can be used to access QSPI_bspi_CMD_AND_MODE_BYTE.
 */
#define READ_QSPI_BSPI_CMD_AND_MODE_BYTEr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_CMD_AND_MODE_BYTEr_OFFSET,r._qspi_bspi_cmd_and_mode_byte)
#define WRITE_QSPI_BSPI_CMD_AND_MODE_BYTEr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_CMD_AND_MODE_BYTEr_OFFSET,r._qspi_bspi_cmd_and_mode_byte)

/*******************************************************************************
 * End of 'QSPI_BSPI_CMD_AND_MODE_BYTEr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_FLEX_MODE_ENABLE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_FLEX_MODE_ENABLEr_OFFSET 0x18021028

#define QSPI_BSPI_FLEX_MODE_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_FLEX_MODE_ENABLE.
 */
typedef union QSPI_BSPI_FLEX_MODE_ENABLEr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_flex_mode_enable[1];
    uint32_t _qspi_bspi_flex_mode_enable;
} QSPI_BSPI_FLEX_MODE_ENABLEr_t;

#define QSPI_BSPI_FLEX_MODE_ENABLEr_CLR(r) (r).qspi_bspi_flex_mode_enable[0] = 0
#define QSPI_BSPI_FLEX_MODE_ENABLEr_SET(r,d) (r).qspi_bspi_flex_mode_enable[0] = d
#define QSPI_BSPI_FLEX_MODE_ENABLEr_GET(r) (r).qspi_bspi_flex_mode_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_FLEX_MODE_ENABLEr_BSPI_FLEX_MODE_ENABLEf_GET(r) (((r).qspi_bspi_flex_mode_enable[0]) & 0x1)
#define QSPI_BSPI_FLEX_MODE_ENABLEr_BSPI_FLEX_MODE_ENABLEf_SET(r,f) (r).qspi_bspi_flex_mode_enable[0]=(((r).qspi_bspi_flex_mode_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_BSPI_FLEX_MODE_ENABLEr_RESERVEDf_GET(r) ((((r).qspi_bspi_flex_mode_enable[0]) >> 1) & 0x7fffffff)
#define QSPI_BSPI_FLEX_MODE_ENABLEr_RESERVEDf_SET(r,f) (r).qspi_bspi_flex_mode_enable[0]=(((r).qspi_bspi_flex_mode_enable[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access QSPI_bspi_FLEX_MODE_ENABLE.
 */
#define READ_QSPI_BSPI_FLEX_MODE_ENABLEr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_FLEX_MODE_ENABLEr_OFFSET,r._qspi_bspi_flex_mode_enable)
#define WRITE_QSPI_BSPI_FLEX_MODE_ENABLEr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_FLEX_MODE_ENABLEr_OFFSET,r._qspi_bspi_flex_mode_enable)

/*******************************************************************************
 * End of 'QSPI_BSPI_FLEX_MODE_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_INTR_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_INTR_STATUSr_OFFSET 0x18021010

#define QSPI_BSPI_INTR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_INTR_STATUS.
 */
typedef union QSPI_BSPI_INTR_STATUSr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_intr_status[1];
    uint32_t _qspi_bspi_intr_status;
} QSPI_BSPI_INTR_STATUSr_t;

#define QSPI_BSPI_INTR_STATUSr_CLR(r) (r).qspi_bspi_intr_status[0] = 0
#define QSPI_BSPI_INTR_STATUSr_SET(r,d) (r).qspi_bspi_intr_status[0] = d
#define QSPI_BSPI_INTR_STATUSr_GET(r) (r).qspi_bspi_intr_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_INTR_STATUSr_INTR_0f_GET(r) (((r).qspi_bspi_intr_status[0]) & 0x1)
#define QSPI_BSPI_INTR_STATUSr_INTR_0f_SET(r,f) (r).qspi_bspi_intr_status[0]=(((r).qspi_bspi_intr_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_BSPI_INTR_STATUSr_INTR_1f_GET(r) ((((r).qspi_bspi_intr_status[0]) >> 1) & 0x1)
#define QSPI_BSPI_INTR_STATUSr_INTR_1f_SET(r,f) (r).qspi_bspi_intr_status[0]=(((r).qspi_bspi_intr_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define QSPI_BSPI_INTR_STATUSr_RESERVEDf_GET(r) ((((r).qspi_bspi_intr_status[0]) >> 2) & 0x3fffffff)
#define QSPI_BSPI_INTR_STATUSr_RESERVEDf_SET(r,f) (r).qspi_bspi_intr_status[0]=(((r).qspi_bspi_intr_status[0] & ~((uint32_t)0x3fffffff << 2)) | ((((uint32_t)f) & 0x3fffffff) << 2))

/*
 * These macros can be used to access QSPI_bspi_INTR_STATUS.
 */
#define READ_QSPI_BSPI_INTR_STATUSr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_INTR_STATUSr_OFFSET,r._qspi_bspi_intr_status)
#define WRITE_QSPI_BSPI_INTR_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_INTR_STATUSr_OFFSET,r._qspi_bspi_intr_status)

/*******************************************************************************
 * End of 'QSPI_BSPI_INTR_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_MAST_N_BOOT_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_MAST_N_BOOT_CTRLr_OFFSET 0x18021008

#define QSPI_BSPI_MAST_N_BOOT_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_MAST_N_BOOT_CTRL.
 */
typedef union QSPI_BSPI_MAST_N_BOOT_CTRLr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_mast_n_boot_ctrl[1];
    uint32_t _qspi_bspi_mast_n_boot_ctrl;
} QSPI_BSPI_MAST_N_BOOT_CTRLr_t;

#define QSPI_BSPI_MAST_N_BOOT_CTRLr_CLR(r) (r).qspi_bspi_mast_n_boot_ctrl[0] = 0
#define QSPI_BSPI_MAST_N_BOOT_CTRLr_SET(r,d) (r).qspi_bspi_mast_n_boot_ctrl[0] = d
#define QSPI_BSPI_MAST_N_BOOT_CTRLr_GET(r) (r).qspi_bspi_mast_n_boot_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_MAST_N_BOOT_CTRLr_MAST_N_BOOTf_GET(r) (((r).qspi_bspi_mast_n_boot_ctrl[0]) & 0x1)
#define QSPI_BSPI_MAST_N_BOOT_CTRLr_MAST_N_BOOTf_SET(r,f) (r).qspi_bspi_mast_n_boot_ctrl[0]=(((r).qspi_bspi_mast_n_boot_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_BSPI_MAST_N_BOOT_CTRLr_RESERVEDf_GET(r) ((((r).qspi_bspi_mast_n_boot_ctrl[0]) >> 1) & 0x7fffffff)
#define QSPI_BSPI_MAST_N_BOOT_CTRLr_RESERVEDf_SET(r,f) (r).qspi_bspi_mast_n_boot_ctrl[0]=(((r).qspi_bspi_mast_n_boot_ctrl[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access QSPI_bspi_MAST_N_BOOT_CTRL.
 */
#define READ_QSPI_BSPI_MAST_N_BOOT_CTRLr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_MAST_N_BOOT_CTRLr_OFFSET,r._qspi_bspi_mast_n_boot_ctrl)
#define WRITE_QSPI_BSPI_MAST_N_BOOT_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_MAST_N_BOOT_CTRLr_OFFSET,r._qspi_bspi_mast_n_boot_ctrl)

/*******************************************************************************
 * End of 'QSPI_BSPI_MAST_N_BOOT_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_REVISION_ID
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_REVISION_IDr_OFFSET 0x18021000

#define QSPI_BSPI_REVISION_IDr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_REVISION_ID.
 */
typedef union QSPI_BSPI_REVISION_IDr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_revision_id[1];
    uint32_t _qspi_bspi_revision_id;
} QSPI_BSPI_REVISION_IDr_t;

#define QSPI_BSPI_REVISION_IDr_CLR(r) (r).qspi_bspi_revision_id[0] = 0
#define QSPI_BSPI_REVISION_IDr_SET(r,d) (r).qspi_bspi_revision_id[0] = d
#define QSPI_BSPI_REVISION_IDr_GET(r) (r).qspi_bspi_revision_id[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_REVISION_IDr_MINORf_GET(r) (((r).qspi_bspi_revision_id[0]) & 0xff)
#define QSPI_BSPI_REVISION_IDr_MINORf_SET(r,f) (r).qspi_bspi_revision_id[0]=(((r).qspi_bspi_revision_id[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define QSPI_BSPI_REVISION_IDr_MAJORf_GET(r) ((((r).qspi_bspi_revision_id[0]) >> 8) & 0xff)
#define QSPI_BSPI_REVISION_IDr_MAJORf_SET(r,f) (r).qspi_bspi_revision_id[0]=(((r).qspi_bspi_revision_id[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define QSPI_BSPI_REVISION_IDr_RESERVEDf_GET(r) ((((r).qspi_bspi_revision_id[0]) >> 16) & 0xffff)
#define QSPI_BSPI_REVISION_IDr_RESERVEDf_SET(r,f) (r).qspi_bspi_revision_id[0]=(((r).qspi_bspi_revision_id[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access QSPI_bspi_REVISION_ID.
 */
#define READ_QSPI_BSPI_REVISION_IDr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_REVISION_IDr_OFFSET,r._qspi_bspi_revision_id)
#define WRITE_QSPI_BSPI_REVISION_IDr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_REVISION_IDr_OFFSET,r._qspi_bspi_revision_id)

/*******************************************************************************
 * End of 'QSPI_BSPI_REVISION_IDr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_SCRATCH
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_SCRATCHr_OFFSET 0x18021004

#define QSPI_BSPI_SCRATCHr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_SCRATCH.
 */
typedef union QSPI_BSPI_SCRATCHr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_scratch[1];
    uint32_t _qspi_bspi_scratch;
} QSPI_BSPI_SCRATCHr_t;

#define QSPI_BSPI_SCRATCHr_CLR(r) (r).qspi_bspi_scratch[0] = 0
#define QSPI_BSPI_SCRATCHr_SET(r,d) (r).qspi_bspi_scratch[0] = d
#define QSPI_BSPI_SCRATCHr_GET(r) (r).qspi_bspi_scratch[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_SCRATCHr_SCRATCHf_GET(r) ((r).qspi_bspi_scratch[0])
#define QSPI_BSPI_SCRATCHr_SCRATCHf_SET(r,f) (r).qspi_bspi_scratch[0]=((uint32_t)f)

/*
 * These macros can be used to access QSPI_bspi_SCRATCH.
 */
#define READ_QSPI_BSPI_SCRATCHr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_SCRATCHr_OFFSET,r._qspi_bspi_scratch)
#define WRITE_QSPI_BSPI_SCRATCHr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_SCRATCHr_OFFSET,r._qspi_bspi_scratch)

/*******************************************************************************
 * End of 'QSPI_BSPI_SCRATCHr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_bspi_STRAP_OVERRIDE_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_OFFSET 0x18021024

#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_STRAP_OVERRIDE_CTRL.
 */
typedef union QSPI_BSPI_STRAP_OVERRIDE_CTRLr_s {
    uint32_t v[1];
    uint32_t qspi_bspi_strap_override_ctrl[1];
    uint32_t _qspi_bspi_strap_override_ctrl;
} QSPI_BSPI_STRAP_OVERRIDE_CTRLr_t;

#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_CLR(r) (r).qspi_bspi_strap_override_ctrl[0] = 0
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_SET(r,d) (r).qspi_bspi_strap_override_ctrl[0] = d
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_GET(r) (r).qspi_bspi_strap_override_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_OVERRIDEf_GET(r) (((r).qspi_bspi_strap_override_ctrl[0]) & 0x1)
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_OVERRIDEf_SET(r,f) (r).qspi_bspi_strap_override_ctrl[0]=(((r).qspi_bspi_strap_override_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_DATA_DUAL_N_SGLf_GET(r) ((((r).qspi_bspi_strap_override_ctrl[0]) >> 1) & 0x1)
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_DATA_DUAL_N_SGLf_SET(r,f) (r).qspi_bspi_strap_override_ctrl[0]=(((r).qspi_bspi_strap_override_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_ADDR_4BYTE_N_3BYTEf_GET(r) ((((r).qspi_bspi_strap_override_ctrl[0]) >> 2) & 0x1)
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_ADDR_4BYTE_N_3BYTEf_SET(r,f) (r).qspi_bspi_strap_override_ctrl[0]=(((r).qspi_bspi_strap_override_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_DATA_QUADf_GET(r) ((((r).qspi_bspi_strap_override_ctrl[0]) >> 3) & 0x1)
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_DATA_QUADf_SET(r,f) (r).qspi_bspi_strap_override_ctrl[0]=(((r).qspi_bspi_strap_override_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_ENDIAN_MODEf_GET(r) ((((r).qspi_bspi_strap_override_ctrl[0]) >> 4) & 0x1)
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_ENDIAN_MODEf_SET(r,f) (r).qspi_bspi_strap_override_ctrl[0]=(((r).qspi_bspi_strap_override_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_ADDR_BPC_MODEf_GET(r) ((((r).qspi_bspi_strap_override_ctrl[0]) >> 5) & 0x1)
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_ADDR_BPC_MODEf_SET(r,f) (r).qspi_bspi_strap_override_ctrl[0]=(((r).qspi_bspi_strap_override_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_RESERVEDf_GET(r) ((((r).qspi_bspi_strap_override_ctrl[0]) >> 6) & 0x3ffffff)
#define QSPI_BSPI_STRAP_OVERRIDE_CTRLr_RESERVEDf_SET(r,f) (r).qspi_bspi_strap_override_ctrl[0]=(((r).qspi_bspi_strap_override_ctrl[0] & ~((uint32_t)0x3ffffff << 6)) | ((((uint32_t)f) & 0x3ffffff) << 6))

/*
 * These macros can be used to access QSPI_bspi_STRAP_OVERRIDE_CTRL.
 */
#define READ_QSPI_BSPI_STRAP_OVERRIDE_CTRLr(u,r) BCMDRD_IPROC_READ(u,QSPI_BSPI_STRAP_OVERRIDE_CTRLr_OFFSET,r._qspi_bspi_strap_override_ctrl)
#define WRITE_QSPI_BSPI_STRAP_OVERRIDE_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_BSPI_STRAP_OVERRIDE_CTRLr_OFFSET,r._qspi_bspi_strap_override_ctrl)

/*******************************************************************************
 * End of 'QSPI_BSPI_STRAP_OVERRIDE_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM00
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM00r_OFFSET 0x18021340

#define QSPI_MSPI_CDRAM00r_SIZE 4

/* QSPI_MSPI_CDRAM00r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM01
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM01r_OFFSET 0x18021344

#define QSPI_MSPI_CDRAM01r_SIZE 4

/* QSPI_MSPI_CDRAM01r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM02
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM02r_OFFSET 0x18021348

#define QSPI_MSPI_CDRAM02r_SIZE 4

/* QSPI_MSPI_CDRAM02r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM03
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM03r_OFFSET 0x1802134c

#define QSPI_MSPI_CDRAM03r_SIZE 4

/* QSPI_MSPI_CDRAM03r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM04
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM04r_OFFSET 0x18021350

#define QSPI_MSPI_CDRAM04r_SIZE 4

/* QSPI_MSPI_CDRAM04r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM05
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM05r_OFFSET 0x18021354

#define QSPI_MSPI_CDRAM05r_SIZE 4

/* QSPI_MSPI_CDRAM05r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM06
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM06r_OFFSET 0x18021358

#define QSPI_MSPI_CDRAM06r_SIZE 4

/* QSPI_MSPI_CDRAM06r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM07
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM07r_OFFSET 0x1802135c

#define QSPI_MSPI_CDRAM07r_SIZE 4

/* QSPI_MSPI_CDRAM07r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM08
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM08r_OFFSET 0x18021360

#define QSPI_MSPI_CDRAM08r_SIZE 4

/* QSPI_MSPI_CDRAM08r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM09
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM09r_OFFSET 0x18021364

#define QSPI_MSPI_CDRAM09r_SIZE 4

/* QSPI_MSPI_CDRAM09r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM10
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM10r_OFFSET 0x18021368

#define QSPI_MSPI_CDRAM10r_SIZE 4

/* QSPI_MSPI_CDRAM10r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM11
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM11r_OFFSET 0x1802136c

#define QSPI_MSPI_CDRAM11r_SIZE 4

/* QSPI_MSPI_CDRAM11r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM12
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM12r_OFFSET 0x18021370

#define QSPI_MSPI_CDRAM12r_SIZE 4

/* QSPI_MSPI_CDRAM12r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM13
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM13r_OFFSET 0x18021374

#define QSPI_MSPI_CDRAM13r_SIZE 4

/* QSPI_MSPI_CDRAM13r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM14
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM14r_OFFSET 0x18021378

#define QSPI_MSPI_CDRAM14r_SIZE 4

/* QSPI_MSPI_CDRAM14r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM15
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAM15r_OFFSET 0x1802137c

#define QSPI_MSPI_CDRAM15r_SIZE 4

/* QSPI_MSPI_CDRAM15r is element of QSPI_mspi_CDRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_CDRAM
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CDRAMr_OFFSET 0x18021340

#define QSPI_MSPI_CDRAMr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_CDRAM.
 */
typedef union QSPI_MSPI_CDRAMr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_cdram[1];
    uint32_t _qspi_mspi_cdram;
} QSPI_MSPI_CDRAMr_t;

#define QSPI_MSPI_CDRAMr_CLR(r) (r).qspi_mspi_cdram[0] = 0
#define QSPI_MSPI_CDRAMr_SET(r,d) (r).qspi_mspi_cdram[0] = d
#define QSPI_MSPI_CDRAMr_GET(r) (r).qspi_mspi_cdram[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_CDRAMr_CDRAMf_GET(r) (((r).qspi_mspi_cdram[0]) & 0xff)
#define QSPI_MSPI_CDRAMr_CDRAMf_SET(r,f) (r).qspi_mspi_cdram[0]=(((r).qspi_mspi_cdram[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define QSPI_MSPI_CDRAMr_RESERVEDf_GET(r) ((((r).qspi_mspi_cdram[0]) >> 8) & 0xffffff)
#define QSPI_MSPI_CDRAMr_RESERVEDf_SET(r,f) (r).qspi_mspi_cdram[0]=(((r).qspi_mspi_cdram[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access QSPI_mspi_CDRAM.
 */
#define READ_QSPI_MSPI_CDRAMr(u,i,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_CDRAMr_OFFSET+(4*(i)),r._qspi_mspi_cdram)
#define WRITE_QSPI_MSPI_CDRAMr(u,i,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_CDRAMr_OFFSET+(4*(i)),r._qspi_mspi_cdram)

/*******************************************************************************
 * End of 'QSPI_MSPI_CDRAMr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_CPTQP
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_CPTQPr_OFFSET 0x18021224

#define QSPI_MSPI_CPTQPr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_CPTQP.
 */
typedef union QSPI_MSPI_CPTQPr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_cptqp[1];
    uint32_t _qspi_mspi_cptqp;
} QSPI_MSPI_CPTQPr_t;

#define QSPI_MSPI_CPTQPr_CLR(r) (r).qspi_mspi_cptqp[0] = 0
#define QSPI_MSPI_CPTQPr_SET(r,d) (r).qspi_mspi_cptqp[0] = d
#define QSPI_MSPI_CPTQPr_GET(r) (r).qspi_mspi_cptqp[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_CPTQPr_CPTQPf_GET(r) (((r).qspi_mspi_cptqp[0]) & 0xf)
#define QSPI_MSPI_CPTQPr_CPTQPf_SET(r,f) (r).qspi_mspi_cptqp[0]=(((r).qspi_mspi_cptqp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define QSPI_MSPI_CPTQPr_RESERVEDf_GET(r) ((((r).qspi_mspi_cptqp[0]) >> 4) & 0xfffffff)
#define QSPI_MSPI_CPTQPr_RESERVEDf_SET(r,f) (r).qspi_mspi_cptqp[0]=(((r).qspi_mspi_cptqp[0] & ~((uint32_t)0xfffffff << 4)) | ((((uint32_t)f) & 0xfffffff) << 4))

/*
 * These macros can be used to access QSPI_mspi_CPTQP.
 */
#define READ_QSPI_MSPI_CPTQPr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_CPTQPr_OFFSET,r._qspi_mspi_cptqp)
#define WRITE_QSPI_MSPI_CPTQPr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_CPTQPr_OFFSET,r._qspi_mspi_cptqp)

/*******************************************************************************
 * End of 'QSPI_MSPI_CPTQPr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_DISABLE_FLUSH_GEN
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_DISABLE_FLUSH_GENr_OFFSET 0x18021384

#define QSPI_MSPI_DISABLE_FLUSH_GENr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_DISABLE_FLUSH_GEN.
 */
typedef union QSPI_MSPI_DISABLE_FLUSH_GENr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_disable_flush_gen[1];
    uint32_t _qspi_mspi_disable_flush_gen;
} QSPI_MSPI_DISABLE_FLUSH_GENr_t;

#define QSPI_MSPI_DISABLE_FLUSH_GENr_CLR(r) (r).qspi_mspi_disable_flush_gen[0] = 0
#define QSPI_MSPI_DISABLE_FLUSH_GENr_SET(r,d) (r).qspi_mspi_disable_flush_gen[0] = d
#define QSPI_MSPI_DISABLE_FLUSH_GENr_GET(r) (r).qspi_mspi_disable_flush_gen[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_DISABLE_FLUSH_GENr_DISABLEFLUSHGENf_GET(r) (((r).qspi_mspi_disable_flush_gen[0]) & 0x1)
#define QSPI_MSPI_DISABLE_FLUSH_GENr_DISABLEFLUSHGENf_SET(r,f) (r).qspi_mspi_disable_flush_gen[0]=(((r).qspi_mspi_disable_flush_gen[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_MSPI_DISABLE_FLUSH_GENr_RESERVEDf_GET(r) ((((r).qspi_mspi_disable_flush_gen[0]) >> 1) & 0x7fffffff)
#define QSPI_MSPI_DISABLE_FLUSH_GENr_RESERVEDf_SET(r,f) (r).qspi_mspi_disable_flush_gen[0]=(((r).qspi_mspi_disable_flush_gen[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access QSPI_mspi_DISABLE_FLUSH_GEN.
 */
#define READ_QSPI_MSPI_DISABLE_FLUSH_GENr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_DISABLE_FLUSH_GENr_OFFSET,r._qspi_mspi_disable_flush_gen)
#define WRITE_QSPI_MSPI_DISABLE_FLUSH_GENr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_DISABLE_FLUSH_GENr_OFFSET,r._qspi_mspi_disable_flush_gen)

/*******************************************************************************
 * End of 'QSPI_MSPI_DISABLE_FLUSH_GENr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_ENDQP
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_ENDQPr_OFFSET 0x18021214

#define QSPI_MSPI_ENDQPr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_ENDQP.
 */
typedef union QSPI_MSPI_ENDQPr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_endqp[1];
    uint32_t _qspi_mspi_endqp;
} QSPI_MSPI_ENDQPr_t;

#define QSPI_MSPI_ENDQPr_CLR(r) (r).qspi_mspi_endqp[0] = 0
#define QSPI_MSPI_ENDQPr_SET(r,d) (r).qspi_mspi_endqp[0] = d
#define QSPI_MSPI_ENDQPr_GET(r) (r).qspi_mspi_endqp[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_ENDQPr_ENDQPf_GET(r) (((r).qspi_mspi_endqp[0]) & 0xf)
#define QSPI_MSPI_ENDQPr_ENDQPf_SET(r,f) (r).qspi_mspi_endqp[0]=(((r).qspi_mspi_endqp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define QSPI_MSPI_ENDQPr_RESERVEDf_GET(r) ((((r).qspi_mspi_endqp[0]) >> 4) & 0xfffffff)
#define QSPI_MSPI_ENDQPr_RESERVEDf_SET(r,f) (r).qspi_mspi_endqp[0]=(((r).qspi_mspi_endqp[0] & ~((uint32_t)0xfffffff << 4)) | ((((uint32_t)f) & 0xfffffff) << 4))

/*
 * These macros can be used to access QSPI_mspi_ENDQP.
 */
#define READ_QSPI_MSPI_ENDQPr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_ENDQPr_OFFSET,r._qspi_mspi_endqp)
#define WRITE_QSPI_MSPI_ENDQPr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_ENDQPr_OFFSET,r._qspi_mspi_endqp)

/*******************************************************************************
 * End of 'QSPI_MSPI_ENDQPr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_interrupt_MSPI_done
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_INTERRUPT_MSPI_DONEr_OFFSET 0x180213b4

#define QSPI_MSPI_INTERRUPT_MSPI_DONEr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_interrupt_MSPI_done.
 */
typedef union QSPI_MSPI_INTERRUPT_MSPI_DONEr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_interrupt_mspi_done[1];
    uint32_t _qspi_mspi_interrupt_mspi_done;
} QSPI_MSPI_INTERRUPT_MSPI_DONEr_t;

#define QSPI_MSPI_INTERRUPT_MSPI_DONEr_CLR(r) (r).qspi_mspi_interrupt_mspi_done[0] = 0
#define QSPI_MSPI_INTERRUPT_MSPI_DONEr_SET(r,d) (r).qspi_mspi_interrupt_mspi_done[0] = d
#define QSPI_MSPI_INTERRUPT_MSPI_DONEr_GET(r) (r).qspi_mspi_interrupt_mspi_done[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_INTERRUPT_MSPI_DONEr_MSPI_DONEf_GET(r) (((r).qspi_mspi_interrupt_mspi_done[0]) & 0x1)
#define QSPI_MSPI_INTERRUPT_MSPI_DONEr_MSPI_DONEf_SET(r,f) (r).qspi_mspi_interrupt_mspi_done[0]=(((r).qspi_mspi_interrupt_mspi_done[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access QSPI_mspi_interrupt_MSPI_done.
 */
#define READ_QSPI_MSPI_INTERRUPT_MSPI_DONEr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_INTERRUPT_MSPI_DONEr_OFFSET,r._qspi_mspi_interrupt_mspi_done)
#define WRITE_QSPI_MSPI_INTERRUPT_MSPI_DONEr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_INTERRUPT_MSPI_DONEr_OFFSET,r._qspi_mspi_interrupt_mspi_done)

/*******************************************************************************
 * End of 'QSPI_MSPI_INTERRUPT_MSPI_DONEr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_interrupt_MSPI_halt_set_transaction_done
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr_OFFSET 0x180213b8

#define QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_interrupt_MSPI_halt_set_transaction_done.
 */
typedef union QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_interrupt_mspi_halt_set_transaction_done[1];
    uint32_t _qspi_mspi_interrupt_mspi_halt_set_transaction_done;
} QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr_t;

#define QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr_CLR(r) (r).qspi_mspi_interrupt_mspi_halt_set_transaction_done[0] = 0
#define QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr_SET(r,d) (r).qspi_mspi_interrupt_mspi_halt_set_transaction_done[0] = d
#define QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr_GET(r) (r).qspi_mspi_interrupt_mspi_halt_set_transaction_done[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr_MSPI_HALT_SET_TRANSACTION_DONEf_GET(r) (((r).qspi_mspi_interrupt_mspi_halt_set_transaction_done[0]) & 0x1)
#define QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr_MSPI_HALT_SET_TRANSACTION_DONEf_SET(r,f) (r).qspi_mspi_interrupt_mspi_halt_set_transaction_done[0]=(((r).qspi_mspi_interrupt_mspi_halt_set_transaction_done[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access QSPI_mspi_interrupt_MSPI_halt_set_transaction_done.
 */
#define READ_QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr_OFFSET,r._qspi_mspi_interrupt_mspi_halt_set_transaction_done)
#define WRITE_QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr_OFFSET,r._qspi_mspi_interrupt_mspi_halt_set_transaction_done)

/*******************************************************************************
 * End of 'QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONEr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_MSPI_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_MSPI_STATUSr_OFFSET 0x18021220

#define QSPI_MSPI_MSPI_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_MSPI_STATUS.
 */
typedef union QSPI_MSPI_MSPI_STATUSr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_mspi_status[1];
    uint32_t _qspi_mspi_mspi_status;
} QSPI_MSPI_MSPI_STATUSr_t;

#define QSPI_MSPI_MSPI_STATUSr_CLR(r) (r).qspi_mspi_mspi_status[0] = 0
#define QSPI_MSPI_MSPI_STATUSr_SET(r,d) (r).qspi_mspi_mspi_status[0] = d
#define QSPI_MSPI_MSPI_STATUSr_GET(r) (r).qspi_mspi_mspi_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_MSPI_STATUSr_SPIFf_GET(r) (((r).qspi_mspi_mspi_status[0]) & 0x1)
#define QSPI_MSPI_MSPI_STATUSr_SPIFf_SET(r,f) (r).qspi_mspi_mspi_status[0]=(((r).qspi_mspi_mspi_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_MSPI_MSPI_STATUSr_HALTAf_GET(r) ((((r).qspi_mspi_mspi_status[0]) >> 1) & 0x1)
#define QSPI_MSPI_MSPI_STATUSr_HALTAf_SET(r,f) (r).qspi_mspi_mspi_status[0]=(((r).qspi_mspi_mspi_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define QSPI_MSPI_MSPI_STATUSr_RESERVEDf_GET(r) ((((r).qspi_mspi_mspi_status[0]) >> 2) & 0x3fffffff)
#define QSPI_MSPI_MSPI_STATUSr_RESERVEDf_SET(r,f) (r).qspi_mspi_mspi_status[0]=(((r).qspi_mspi_mspi_status[0] & ~((uint32_t)0x3fffffff << 2)) | ((((uint32_t)f) & 0x3fffffff) << 2))

/*
 * These macros can be used to access QSPI_mspi_MSPI_STATUS.
 */
#define READ_QSPI_MSPI_MSPI_STATUSr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_MSPI_STATUSr_OFFSET,r._qspi_mspi_mspi_status)
#define WRITE_QSPI_MSPI_MSPI_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_MSPI_STATUSr_OFFSET,r._qspi_mspi_mspi_status)

/*******************************************************************************
 * End of 'QSPI_MSPI_MSPI_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_NEWQP
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_NEWQPr_OFFSET 0x18021210

#define QSPI_MSPI_NEWQPr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_NEWQP.
 */
typedef union QSPI_MSPI_NEWQPr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_newqp[1];
    uint32_t _qspi_mspi_newqp;
} QSPI_MSPI_NEWQPr_t;

#define QSPI_MSPI_NEWQPr_CLR(r) (r).qspi_mspi_newqp[0] = 0
#define QSPI_MSPI_NEWQPr_SET(r,d) (r).qspi_mspi_newqp[0] = d
#define QSPI_MSPI_NEWQPr_GET(r) (r).qspi_mspi_newqp[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_NEWQPr_NEWQPf_GET(r) (((r).qspi_mspi_newqp[0]) & 0xf)
#define QSPI_MSPI_NEWQPr_NEWQPf_SET(r,f) (r).qspi_mspi_newqp[0]=(((r).qspi_mspi_newqp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define QSPI_MSPI_NEWQPr_RESERVEDf_GET(r) ((((r).qspi_mspi_newqp[0]) >> 4) & 0xfffffff)
#define QSPI_MSPI_NEWQPr_RESERVEDf_SET(r,f) (r).qspi_mspi_newqp[0]=(((r).qspi_mspi_newqp[0] & ~((uint32_t)0xfffffff << 4)) | ((((uint32_t)f) & 0xfffffff) << 4))

/*
 * These macros can be used to access QSPI_mspi_NEWQP.
 */
#define READ_QSPI_MSPI_NEWQPr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_NEWQPr_OFFSET,r._qspi_mspi_newqp)
#define WRITE_QSPI_MSPI_NEWQPr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_NEWQPr_OFFSET,r._qspi_mspi_newqp)

/*******************************************************************************
 * End of 'QSPI_MSPI_NEWQPr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM00
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM00r_OFFSET 0x180212c0

#define QSPI_MSPI_RXRAM00r_SIZE 4

/* QSPI_MSPI_RXRAM00r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM01
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM01r_OFFSET 0x180212c4

#define QSPI_MSPI_RXRAM01r_SIZE 4

/* QSPI_MSPI_RXRAM01r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM02
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM02r_OFFSET 0x180212c8

#define QSPI_MSPI_RXRAM02r_SIZE 4

/* QSPI_MSPI_RXRAM02r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM03
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM03r_OFFSET 0x180212cc

#define QSPI_MSPI_RXRAM03r_SIZE 4

/* QSPI_MSPI_RXRAM03r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM04
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM04r_OFFSET 0x180212d0

#define QSPI_MSPI_RXRAM04r_SIZE 4

/* QSPI_MSPI_RXRAM04r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM05
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM05r_OFFSET 0x180212d4

#define QSPI_MSPI_RXRAM05r_SIZE 4

/* QSPI_MSPI_RXRAM05r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM06
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM06r_OFFSET 0x180212d8

#define QSPI_MSPI_RXRAM06r_SIZE 4

/* QSPI_MSPI_RXRAM06r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM07
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM07r_OFFSET 0x180212dc

#define QSPI_MSPI_RXRAM07r_SIZE 4

/* QSPI_MSPI_RXRAM07r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM08
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM08r_OFFSET 0x180212e0

#define QSPI_MSPI_RXRAM08r_SIZE 4

/* QSPI_MSPI_RXRAM08r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM09
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM09r_OFFSET 0x180212e4

#define QSPI_MSPI_RXRAM09r_SIZE 4

/* QSPI_MSPI_RXRAM09r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM10
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM10r_OFFSET 0x180212e8

#define QSPI_MSPI_RXRAM10r_SIZE 4

/* QSPI_MSPI_RXRAM10r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM11
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM11r_OFFSET 0x180212ec

#define QSPI_MSPI_RXRAM11r_SIZE 4

/* QSPI_MSPI_RXRAM11r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM12
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM12r_OFFSET 0x180212f0

#define QSPI_MSPI_RXRAM12r_SIZE 4

/* QSPI_MSPI_RXRAM12r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM13
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM13r_OFFSET 0x180212f4

#define QSPI_MSPI_RXRAM13r_SIZE 4

/* QSPI_MSPI_RXRAM13r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM14
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM14r_OFFSET 0x180212f8

#define QSPI_MSPI_RXRAM14r_SIZE 4

/* QSPI_MSPI_RXRAM14r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM15
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM15r_OFFSET 0x180212fc

#define QSPI_MSPI_RXRAM15r_SIZE 4

/* QSPI_MSPI_RXRAM15r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM16
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM16r_OFFSET 0x18021300

#define QSPI_MSPI_RXRAM16r_SIZE 4

/* QSPI_MSPI_RXRAM16r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM17
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM17r_OFFSET 0x18021304

#define QSPI_MSPI_RXRAM17r_SIZE 4

/* QSPI_MSPI_RXRAM17r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM18
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM18r_OFFSET 0x18021308

#define QSPI_MSPI_RXRAM18r_SIZE 4

/* QSPI_MSPI_RXRAM18r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM19
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM19r_OFFSET 0x1802130c

#define QSPI_MSPI_RXRAM19r_SIZE 4

/* QSPI_MSPI_RXRAM19r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM20
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM20r_OFFSET 0x18021310

#define QSPI_MSPI_RXRAM20r_SIZE 4

/* QSPI_MSPI_RXRAM20r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM21
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM21r_OFFSET 0x18021314

#define QSPI_MSPI_RXRAM21r_SIZE 4

/* QSPI_MSPI_RXRAM21r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM22
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM22r_OFFSET 0x18021318

#define QSPI_MSPI_RXRAM22r_SIZE 4

/* QSPI_MSPI_RXRAM22r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM23
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM23r_OFFSET 0x1802131c

#define QSPI_MSPI_RXRAM23r_SIZE 4

/* QSPI_MSPI_RXRAM23r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM24
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM24r_OFFSET 0x18021320

#define QSPI_MSPI_RXRAM24r_SIZE 4

/* QSPI_MSPI_RXRAM24r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM25
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM25r_OFFSET 0x18021324

#define QSPI_MSPI_RXRAM25r_SIZE 4

/* QSPI_MSPI_RXRAM25r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM26
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM26r_OFFSET 0x18021328

#define QSPI_MSPI_RXRAM26r_SIZE 4

/* QSPI_MSPI_RXRAM26r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM27
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM27r_OFFSET 0x1802132c

#define QSPI_MSPI_RXRAM27r_SIZE 4

/* QSPI_MSPI_RXRAM27r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM28
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM28r_OFFSET 0x18021330

#define QSPI_MSPI_RXRAM28r_SIZE 4

/* QSPI_MSPI_RXRAM28r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM29
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM29r_OFFSET 0x18021334

#define QSPI_MSPI_RXRAM29r_SIZE 4

/* QSPI_MSPI_RXRAM29r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM30
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM30r_OFFSET 0x18021338

#define QSPI_MSPI_RXRAM30r_SIZE 4

/* QSPI_MSPI_RXRAM30r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM31
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAM31r_OFFSET 0x1802133c

#define QSPI_MSPI_RXRAM31r_SIZE 4

/* QSPI_MSPI_RXRAM31r is element of QSPI_mspi_RXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_RXRAM
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_RXRAMr_OFFSET 0x180212c0

#define QSPI_MSPI_RXRAMr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_RXRAM.
 */
typedef union QSPI_MSPI_RXRAMr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_rxram[1];
    uint32_t _qspi_mspi_rxram;
} QSPI_MSPI_RXRAMr_t;

#define QSPI_MSPI_RXRAMr_CLR(r) (r).qspi_mspi_rxram[0] = 0
#define QSPI_MSPI_RXRAMr_SET(r,d) (r).qspi_mspi_rxram[0] = d
#define QSPI_MSPI_RXRAMr_GET(r) (r).qspi_mspi_rxram[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_RXRAMr_RXRAMf_GET(r) (((r).qspi_mspi_rxram[0]) & 0xff)
#define QSPI_MSPI_RXRAMr_RXRAMf_SET(r,f) (r).qspi_mspi_rxram[0]=(((r).qspi_mspi_rxram[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define QSPI_MSPI_RXRAMr_RESERVEDf_GET(r) ((((r).qspi_mspi_rxram[0]) >> 8) & 0xffffff)
#define QSPI_MSPI_RXRAMr_RESERVEDf_SET(r,f) (r).qspi_mspi_rxram[0]=(((r).qspi_mspi_rxram[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access QSPI_mspi_RXRAM.
 */
#define READ_QSPI_MSPI_RXRAMr(u,i,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_RXRAMr_OFFSET+(4*(i)),r._qspi_mspi_rxram)
#define WRITE_QSPI_MSPI_RXRAMr(u,i,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_RXRAMr_OFFSET+(4*(i)),r._qspi_mspi_rxram)

/*******************************************************************************
 * End of 'QSPI_MSPI_RXRAMr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_SPCR0_LSB
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_SPCR0_LSBr_OFFSET 0x18021200

#define QSPI_MSPI_SPCR0_LSBr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_SPCR0_LSB.
 */
typedef union QSPI_MSPI_SPCR0_LSBr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_spcr0_lsb[1];
    uint32_t _qspi_mspi_spcr0_lsb;
} QSPI_MSPI_SPCR0_LSBr_t;

#define QSPI_MSPI_SPCR0_LSBr_CLR(r) (r).qspi_mspi_spcr0_lsb[0] = 0
#define QSPI_MSPI_SPCR0_LSBr_SET(r,d) (r).qspi_mspi_spcr0_lsb[0] = d
#define QSPI_MSPI_SPCR0_LSBr_GET(r) (r).qspi_mspi_spcr0_lsb[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_SPCR0_LSBr_SPBRf_GET(r) (((r).qspi_mspi_spcr0_lsb[0]) & 0xff)
#define QSPI_MSPI_SPCR0_LSBr_SPBRf_SET(r,f) (r).qspi_mspi_spcr0_lsb[0]=(((r).qspi_mspi_spcr0_lsb[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define QSPI_MSPI_SPCR0_LSBr_RESERVEDf_GET(r) ((((r).qspi_mspi_spcr0_lsb[0]) >> 8) & 0xffffff)
#define QSPI_MSPI_SPCR0_LSBr_RESERVEDf_SET(r,f) (r).qspi_mspi_spcr0_lsb[0]=(((r).qspi_mspi_spcr0_lsb[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access QSPI_mspi_SPCR0_LSB.
 */
#define READ_QSPI_MSPI_SPCR0_LSBr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_SPCR0_LSBr_OFFSET,r._qspi_mspi_spcr0_lsb)
#define WRITE_QSPI_MSPI_SPCR0_LSBr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_SPCR0_LSBr_OFFSET,r._qspi_mspi_spcr0_lsb)

/*******************************************************************************
 * End of 'QSPI_MSPI_SPCR0_LSBr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_SPCR0_MSB
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_SPCR0_MSBr_OFFSET 0x18021204

#define QSPI_MSPI_SPCR0_MSBr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_SPCR0_MSB.
 */
typedef union QSPI_MSPI_SPCR0_MSBr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_spcr0_msb[1];
    uint32_t _qspi_mspi_spcr0_msb;
} QSPI_MSPI_SPCR0_MSBr_t;

#define QSPI_MSPI_SPCR0_MSBr_CLR(r) (r).qspi_mspi_spcr0_msb[0] = 0
#define QSPI_MSPI_SPCR0_MSBr_SET(r,d) (r).qspi_mspi_spcr0_msb[0] = d
#define QSPI_MSPI_SPCR0_MSBr_GET(r) (r).qspi_mspi_spcr0_msb[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_SPCR0_MSBr_CPHAf_GET(r) (((r).qspi_mspi_spcr0_msb[0]) & 0x1)
#define QSPI_MSPI_SPCR0_MSBr_CPHAf_SET(r,f) (r).qspi_mspi_spcr0_msb[0]=(((r).qspi_mspi_spcr0_msb[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_MSPI_SPCR0_MSBr_CPOLf_GET(r) ((((r).qspi_mspi_spcr0_msb[0]) >> 1) & 0x1)
#define QSPI_MSPI_SPCR0_MSBr_CPOLf_SET(r,f) (r).qspi_mspi_spcr0_msb[0]=(((r).qspi_mspi_spcr0_msb[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define QSPI_MSPI_SPCR0_MSBr_BITSf_GET(r) ((((r).qspi_mspi_spcr0_msb[0]) >> 2) & 0xf)
#define QSPI_MSPI_SPCR0_MSBr_BITSf_SET(r,f) (r).qspi_mspi_spcr0_msb[0]=(((r).qspi_mspi_spcr0_msb[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define QSPI_MSPI_SPCR0_MSBr_STARTTRANSDELAYf_GET(r) ((((r).qspi_mspi_spcr0_msb[0]) >> 6) & 0x1)
#define QSPI_MSPI_SPCR0_MSBr_STARTTRANSDELAYf_SET(r,f) (r).qspi_mspi_spcr0_msb[0]=(((r).qspi_mspi_spcr0_msb[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define QSPI_MSPI_SPCR0_MSBr_MSTRf_GET(r) ((((r).qspi_mspi_spcr0_msb[0]) >> 7) & 0x1)
#define QSPI_MSPI_SPCR0_MSBr_MSTRf_SET(r,f) (r).qspi_mspi_spcr0_msb[0]=(((r).qspi_mspi_spcr0_msb[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define QSPI_MSPI_SPCR0_MSBr_RESERVEDf_GET(r) ((((r).qspi_mspi_spcr0_msb[0]) >> 8) & 0xffffff)
#define QSPI_MSPI_SPCR0_MSBr_RESERVEDf_SET(r,f) (r).qspi_mspi_spcr0_msb[0]=(((r).qspi_mspi_spcr0_msb[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access QSPI_mspi_SPCR0_MSB.
 */
#define READ_QSPI_MSPI_SPCR0_MSBr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_SPCR0_MSBr_OFFSET,r._qspi_mspi_spcr0_msb)
#define WRITE_QSPI_MSPI_SPCR0_MSBr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_SPCR0_MSBr_OFFSET,r._qspi_mspi_spcr0_msb)

/*******************************************************************************
 * End of 'QSPI_MSPI_SPCR0_MSBr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_SPCR1_LSB
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_SPCR1_LSBr_OFFSET 0x18021208

#define QSPI_MSPI_SPCR1_LSBr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_SPCR1_LSB.
 */
typedef union QSPI_MSPI_SPCR1_LSBr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_spcr1_lsb[1];
    uint32_t _qspi_mspi_spcr1_lsb;
} QSPI_MSPI_SPCR1_LSBr_t;

#define QSPI_MSPI_SPCR1_LSBr_CLR(r) (r).qspi_mspi_spcr1_lsb[0] = 0
#define QSPI_MSPI_SPCR1_LSBr_SET(r,d) (r).qspi_mspi_spcr1_lsb[0] = d
#define QSPI_MSPI_SPCR1_LSBr_GET(r) (r).qspi_mspi_spcr1_lsb[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_SPCR1_LSBr_DTLf_GET(r) (((r).qspi_mspi_spcr1_lsb[0]) & 0xff)
#define QSPI_MSPI_SPCR1_LSBr_DTLf_SET(r,f) (r).qspi_mspi_spcr1_lsb[0]=(((r).qspi_mspi_spcr1_lsb[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define QSPI_MSPI_SPCR1_LSBr_RESERVEDf_GET(r) ((((r).qspi_mspi_spcr1_lsb[0]) >> 8) & 0xffffff)
#define QSPI_MSPI_SPCR1_LSBr_RESERVEDf_SET(r,f) (r).qspi_mspi_spcr1_lsb[0]=(((r).qspi_mspi_spcr1_lsb[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access QSPI_mspi_SPCR1_LSB.
 */
#define READ_QSPI_MSPI_SPCR1_LSBr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_SPCR1_LSBr_OFFSET,r._qspi_mspi_spcr1_lsb)
#define WRITE_QSPI_MSPI_SPCR1_LSBr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_SPCR1_LSBr_OFFSET,r._qspi_mspi_spcr1_lsb)

/*******************************************************************************
 * End of 'QSPI_MSPI_SPCR1_LSBr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_SPCR1_MSB
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_SPCR1_MSBr_OFFSET 0x1802120c

#define QSPI_MSPI_SPCR1_MSBr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_SPCR1_MSB.
 */
typedef union QSPI_MSPI_SPCR1_MSBr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_spcr1_msb[1];
    uint32_t _qspi_mspi_spcr1_msb;
} QSPI_MSPI_SPCR1_MSBr_t;

#define QSPI_MSPI_SPCR1_MSBr_CLR(r) (r).qspi_mspi_spcr1_msb[0] = 0
#define QSPI_MSPI_SPCR1_MSBr_SET(r,d) (r).qspi_mspi_spcr1_msb[0] = d
#define QSPI_MSPI_SPCR1_MSBr_GET(r) (r).qspi_mspi_spcr1_msb[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_SPCR1_MSBr_RDSCLKf_GET(r) (((r).qspi_mspi_spcr1_msb[0]) & 0xff)
#define QSPI_MSPI_SPCR1_MSBr_RDSCLKf_SET(r,f) (r).qspi_mspi_spcr1_msb[0]=(((r).qspi_mspi_spcr1_msb[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define QSPI_MSPI_SPCR1_MSBr_RESERVEDf_GET(r) ((((r).qspi_mspi_spcr1_msb[0]) >> 8) & 0xffffff)
#define QSPI_MSPI_SPCR1_MSBr_RESERVEDf_SET(r,f) (r).qspi_mspi_spcr1_msb[0]=(((r).qspi_mspi_spcr1_msb[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access QSPI_mspi_SPCR1_MSB.
 */
#define READ_QSPI_MSPI_SPCR1_MSBr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_SPCR1_MSBr_OFFSET,r._qspi_mspi_spcr1_msb)
#define WRITE_QSPI_MSPI_SPCR1_MSBr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_SPCR1_MSBr_OFFSET,r._qspi_mspi_spcr1_msb)

/*******************************************************************************
 * End of 'QSPI_MSPI_SPCR1_MSBr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_SPCR2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_SPCR2r_OFFSET 0x18021218

#define QSPI_MSPI_SPCR2r_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_SPCR2.
 */
typedef union QSPI_MSPI_SPCR2r_s {
    uint32_t v[1];
    uint32_t qspi_mspi_spcr2[1];
    uint32_t _qspi_mspi_spcr2;
} QSPI_MSPI_SPCR2r_t;

#define QSPI_MSPI_SPCR2r_CLR(r) (r).qspi_mspi_spcr2[0] = 0
#define QSPI_MSPI_SPCR2r_SET(r,d) (r).qspi_mspi_spcr2[0] = d
#define QSPI_MSPI_SPCR2r_GET(r) (r).qspi_mspi_spcr2[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_SPCR2r_HALTf_GET(r) (((r).qspi_mspi_spcr2[0]) & 0x1)
#define QSPI_MSPI_SPCR2r_HALTf_SET(r,f) (r).qspi_mspi_spcr2[0]=(((r).qspi_mspi_spcr2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_MSPI_SPCR2r_HIEf_GET(r) ((((r).qspi_mspi_spcr2[0]) >> 1) & 0x1)
#define QSPI_MSPI_SPCR2r_HIEf_SET(r,f) (r).qspi_mspi_spcr2[0]=(((r).qspi_mspi_spcr2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define QSPI_MSPI_SPCR2r_LOOPQf_GET(r) ((((r).qspi_mspi_spcr2[0]) >> 2) & 0x1)
#define QSPI_MSPI_SPCR2r_LOOPQf_SET(r,f) (r).qspi_mspi_spcr2[0]=(((r).qspi_mspi_spcr2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define QSPI_MSPI_SPCR2r_WRT0f_GET(r) ((((r).qspi_mspi_spcr2[0]) >> 3) & 0x1)
#define QSPI_MSPI_SPCR2r_WRT0f_SET(r,f) (r).qspi_mspi_spcr2[0]=(((r).qspi_mspi_spcr2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define QSPI_MSPI_SPCR2r_WRENf_GET(r) ((((r).qspi_mspi_spcr2[0]) >> 4) & 0x1)
#define QSPI_MSPI_SPCR2r_WRENf_SET(r,f) (r).qspi_mspi_spcr2[0]=(((r).qspi_mspi_spcr2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define QSPI_MSPI_SPCR2r_SPIFIEf_GET(r) ((((r).qspi_mspi_spcr2[0]) >> 5) & 0x1)
#define QSPI_MSPI_SPCR2r_SPIFIEf_SET(r,f) (r).qspi_mspi_spcr2[0]=(((r).qspi_mspi_spcr2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define QSPI_MSPI_SPCR2r_SPEf_GET(r) ((((r).qspi_mspi_spcr2[0]) >> 6) & 0x1)
#define QSPI_MSPI_SPCR2r_SPEf_SET(r,f) (r).qspi_mspi_spcr2[0]=(((r).qspi_mspi_spcr2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define QSPI_MSPI_SPCR2r_CONT_AFTER_CMDf_GET(r) ((((r).qspi_mspi_spcr2[0]) >> 7) & 0x1)
#define QSPI_MSPI_SPCR2r_CONT_AFTER_CMDf_SET(r,f) (r).qspi_mspi_spcr2[0]=(((r).qspi_mspi_spcr2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define QSPI_MSPI_SPCR2r_RESERVEDf_GET(r) ((((r).qspi_mspi_spcr2[0]) >> 8) & 0xffffff)
#define QSPI_MSPI_SPCR2r_RESERVEDf_SET(r,f) (r).qspi_mspi_spcr2[0]=(((r).qspi_mspi_spcr2[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access QSPI_mspi_SPCR2.
 */
#define READ_QSPI_MSPI_SPCR2r(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_SPCR2r_OFFSET,r._qspi_mspi_spcr2)
#define WRITE_QSPI_MSPI_SPCR2r(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_SPCR2r_OFFSET,r._qspi_mspi_spcr2)

/*******************************************************************************
 * End of 'QSPI_MSPI_SPCR2r'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM00
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM00r_OFFSET 0x18021240

#define QSPI_MSPI_TXRAM00r_SIZE 4

/* QSPI_MSPI_TXRAM00r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM01
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM01r_OFFSET 0x18021244

#define QSPI_MSPI_TXRAM01r_SIZE 4

/* QSPI_MSPI_TXRAM01r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM02
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM02r_OFFSET 0x18021248

#define QSPI_MSPI_TXRAM02r_SIZE 4

/* QSPI_MSPI_TXRAM02r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM03
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM03r_OFFSET 0x1802124c

#define QSPI_MSPI_TXRAM03r_SIZE 4

/* QSPI_MSPI_TXRAM03r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM04
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM04r_OFFSET 0x18021250

#define QSPI_MSPI_TXRAM04r_SIZE 4

/* QSPI_MSPI_TXRAM04r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM05
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM05r_OFFSET 0x18021254

#define QSPI_MSPI_TXRAM05r_SIZE 4

/* QSPI_MSPI_TXRAM05r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM06
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM06r_OFFSET 0x18021258

#define QSPI_MSPI_TXRAM06r_SIZE 4

/* QSPI_MSPI_TXRAM06r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM07
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM07r_OFFSET 0x1802125c

#define QSPI_MSPI_TXRAM07r_SIZE 4

/* QSPI_MSPI_TXRAM07r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM08
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM08r_OFFSET 0x18021260

#define QSPI_MSPI_TXRAM08r_SIZE 4

/* QSPI_MSPI_TXRAM08r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM09
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM09r_OFFSET 0x18021264

#define QSPI_MSPI_TXRAM09r_SIZE 4

/* QSPI_MSPI_TXRAM09r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM10
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM10r_OFFSET 0x18021268

#define QSPI_MSPI_TXRAM10r_SIZE 4

/* QSPI_MSPI_TXRAM10r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM11
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM11r_OFFSET 0x1802126c

#define QSPI_MSPI_TXRAM11r_SIZE 4

/* QSPI_MSPI_TXRAM11r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM12
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM12r_OFFSET 0x18021270

#define QSPI_MSPI_TXRAM12r_SIZE 4

/* QSPI_MSPI_TXRAM12r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM13
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM13r_OFFSET 0x18021274

#define QSPI_MSPI_TXRAM13r_SIZE 4

/* QSPI_MSPI_TXRAM13r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM14
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM14r_OFFSET 0x18021278

#define QSPI_MSPI_TXRAM14r_SIZE 4

/* QSPI_MSPI_TXRAM14r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM15
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM15r_OFFSET 0x1802127c

#define QSPI_MSPI_TXRAM15r_SIZE 4

/* QSPI_MSPI_TXRAM15r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM16
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM16r_OFFSET 0x18021280

#define QSPI_MSPI_TXRAM16r_SIZE 4

/* QSPI_MSPI_TXRAM16r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM17
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM17r_OFFSET 0x18021284

#define QSPI_MSPI_TXRAM17r_SIZE 4

/* QSPI_MSPI_TXRAM17r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM18
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM18r_OFFSET 0x18021288

#define QSPI_MSPI_TXRAM18r_SIZE 4

/* QSPI_MSPI_TXRAM18r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM19
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM19r_OFFSET 0x1802128c

#define QSPI_MSPI_TXRAM19r_SIZE 4

/* QSPI_MSPI_TXRAM19r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM20
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM20r_OFFSET 0x18021290

#define QSPI_MSPI_TXRAM20r_SIZE 4

/* QSPI_MSPI_TXRAM20r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM21
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM21r_OFFSET 0x18021294

#define QSPI_MSPI_TXRAM21r_SIZE 4

/* QSPI_MSPI_TXRAM21r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM22
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM22r_OFFSET 0x18021298

#define QSPI_MSPI_TXRAM22r_SIZE 4

/* QSPI_MSPI_TXRAM22r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM23
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM23r_OFFSET 0x1802129c

#define QSPI_MSPI_TXRAM23r_SIZE 4

/* QSPI_MSPI_TXRAM23r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM24
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM24r_OFFSET 0x180212a0

#define QSPI_MSPI_TXRAM24r_SIZE 4

/* QSPI_MSPI_TXRAM24r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM25
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM25r_OFFSET 0x180212a4

#define QSPI_MSPI_TXRAM25r_SIZE 4

/* QSPI_MSPI_TXRAM25r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM26
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM26r_OFFSET 0x180212a8

#define QSPI_MSPI_TXRAM26r_SIZE 4

/* QSPI_MSPI_TXRAM26r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM27
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM27r_OFFSET 0x180212ac

#define QSPI_MSPI_TXRAM27r_SIZE 4

/* QSPI_MSPI_TXRAM27r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM28
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM28r_OFFSET 0x180212b0

#define QSPI_MSPI_TXRAM28r_SIZE 4

/* QSPI_MSPI_TXRAM28r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM29
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM29r_OFFSET 0x180212b4

#define QSPI_MSPI_TXRAM29r_SIZE 4

/* QSPI_MSPI_TXRAM29r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM30
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM30r_OFFSET 0x180212b8

#define QSPI_MSPI_TXRAM30r_SIZE 4

/* QSPI_MSPI_TXRAM30r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM31
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAM31r_OFFSET 0x180212bc

#define QSPI_MSPI_TXRAM31r_SIZE 4

/* QSPI_MSPI_TXRAM31r is element of QSPI_mspi_TXRAM */

/*******************************************************************************
 * REGISTER:  QSPI_mspi_TXRAM
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_TXRAMr_OFFSET 0x18021240

#define QSPI_MSPI_TXRAMr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_TXRAM.
 */
typedef union QSPI_MSPI_TXRAMr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_txram[1];
    uint32_t _qspi_mspi_txram;
} QSPI_MSPI_TXRAMr_t;

#define QSPI_MSPI_TXRAMr_CLR(r) (r).qspi_mspi_txram[0] = 0
#define QSPI_MSPI_TXRAMr_SET(r,d) (r).qspi_mspi_txram[0] = d
#define QSPI_MSPI_TXRAMr_GET(r) (r).qspi_mspi_txram[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_TXRAMr_TXRAMf_GET(r) (((r).qspi_mspi_txram[0]) & 0xff)
#define QSPI_MSPI_TXRAMr_TXRAMf_SET(r,f) (r).qspi_mspi_txram[0]=(((r).qspi_mspi_txram[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define QSPI_MSPI_TXRAMr_RESERVEDf_GET(r) ((((r).qspi_mspi_txram[0]) >> 8) & 0xffffff)
#define QSPI_MSPI_TXRAMr_RESERVEDf_SET(r,f) (r).qspi_mspi_txram[0]=(((r).qspi_mspi_txram[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access QSPI_mspi_TXRAM.
 */
#define READ_QSPI_MSPI_TXRAMr(u,i,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_TXRAMr_OFFSET+(4*(i)),r._qspi_mspi_txram)
#define WRITE_QSPI_MSPI_TXRAMr(u,i,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_TXRAMr_OFFSET+(4*(i)),r._qspi_mspi_txram)

/*******************************************************************************
 * End of 'QSPI_MSPI_TXRAMr'
 */




/*******************************************************************************
 * REGISTER:  QSPI_mspi_WRITE_LOCK
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define QSPI_MSPI_WRITE_LOCKr_OFFSET 0x18021380

#define QSPI_MSPI_WRITE_LOCKr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_mspi_WRITE_LOCK.
 */
typedef union QSPI_MSPI_WRITE_LOCKr_s {
    uint32_t v[1];
    uint32_t qspi_mspi_write_lock[1];
    uint32_t _qspi_mspi_write_lock;
} QSPI_MSPI_WRITE_LOCKr_t;

#define QSPI_MSPI_WRITE_LOCKr_CLR(r) (r).qspi_mspi_write_lock[0] = 0
#define QSPI_MSPI_WRITE_LOCKr_SET(r,d) (r).qspi_mspi_write_lock[0] = d
#define QSPI_MSPI_WRITE_LOCKr_GET(r) (r).qspi_mspi_write_lock[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_MSPI_WRITE_LOCKr_WRITELOCKf_GET(r) (((r).qspi_mspi_write_lock[0]) & 0x1)
#define QSPI_MSPI_WRITE_LOCKr_WRITELOCKf_SET(r,f) (r).qspi_mspi_write_lock[0]=(((r).qspi_mspi_write_lock[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define QSPI_MSPI_WRITE_LOCKr_RESERVEDf_GET(r) ((((r).qspi_mspi_write_lock[0]) >> 1) & 0x7fffffff)
#define QSPI_MSPI_WRITE_LOCKr_RESERVEDf_SET(r,f) (r).qspi_mspi_write_lock[0]=(((r).qspi_mspi_write_lock[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access QSPI_mspi_WRITE_LOCK.
 */
#define READ_QSPI_MSPI_WRITE_LOCKr(u,r) BCMDRD_IPROC_READ(u,QSPI_MSPI_WRITE_LOCKr_OFFSET,r._qspi_mspi_write_lock)
#define WRITE_QSPI_MSPI_WRITE_LOCKr(u,r) BCMDRD_IPROC_WRITE(u,QSPI_MSPI_WRITE_LOCKr_OFFSET,r._qspi_mspi_write_lock)

/*******************************************************************************
 * End of 'QSPI_MSPI_WRITE_LOCKr'
 */




/*******************************************************************************
 * SWFORMAT:  RX_DCB
 * BLOCKS:
 * SIZE:     128
 */
#define RX_DCB_OFFSET 0x00000000

#define RX_DCB_BLKACC ()

#define RX_DCB_SIZE 16

/*
 * This structure should be used to declare and program RX_DCB.
 */
typedef union RX_DCB_s {
    uint32_t v[4];
    uint32_t rx_dcb[4];
    uint32_t _rx_dcb;
} RX_DCB_t;

#define RX_DCB_CLR(r) sal_memset(&((r).rx_dcb[0]), 0, sizeof(RX_DCB_t))
#define RX_DCB_SET(r,i,d) (r).rx_dcb[i] = d
#define RX_DCB_GET(r,i) (r).rx_dcb[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).rx_dcb[3]) & 0xffff)
#define RX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).rx_dcb[3]=(((r).rx_dcb[3] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define RX_DCB_END_BITf_GET(r) ((((r).rx_dcb[3]) >> 16) & 0x1)
#define RX_DCB_END_BITf_SET(r,f) (r).rx_dcb[3]=(((r).rx_dcb[3] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define RX_DCB_START_BITf_GET(r) ((((r).rx_dcb[3]) >> 17) & 0x1)
#define RX_DCB_START_BITf_SET(r,f) (r).rx_dcb[3]=(((r).rx_dcb[3] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define RX_DCB_ERRORf_GET(r) ((((r).rx_dcb[3]) >> 18) & 0x1)
#define RX_DCB_ERRORf_SET(r,f) (r).rx_dcb[3]=(((r).rx_dcb[3] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define RX_DCB_DONEf_GET(r) ((((r).rx_dcb[3]) >> 31) & 0x1)
#define RX_DCB_DONEf_SET(r,f) (r).rx_dcb[3]=(((r).rx_dcb[3] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define RX_DCB_BYTE_COUNTf_GET(r) (((r).rx_dcb[2]) & 0xffff)
#define RX_DCB_BYTE_COUNTf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define RX_DCB_CHAINf_GET(r) ((((r).rx_dcb[2]) >> 16) & 0x1)
#define RX_DCB_CHAINf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define RX_DCB_SGf_GET(r) ((((r).rx_dcb[2]) >> 17) & 0x1)
#define RX_DCB_SGf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define RX_DCB_RELOADf_GET(r) ((((r).rx_dcb[2]) >> 18) & 0x1)
#define RX_DCB_RELOADf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define RX_DCB_DESC_DONE_INTRf_GET(r) ((((r).rx_dcb[2]) >> 23) & 0x1)
#define RX_DCB_DESC_DONE_INTRf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define RX_DCB_DESC_CTRL_INTRf_GET(r) ((((r).rx_dcb[2]) >> 24) & 0x1)
#define RX_DCB_DESC_CTRL_INTRf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define RX_DCB_DESC_REMAINf_GET(r) ((((r).rx_dcb[2]) >> 25) & 0xf)
#define RX_DCB_DESC_REMAINf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define RX_DCB_DESC_STAT_WR_DISABLEf_GET(r) ((((r).rx_dcb[2]) >> 29) & 0x1)
#define RX_DCB_DESC_STAT_WR_DISABLEf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define RX_DCB_ADDR_HIf_GET(r) ((r).rx_dcb[1])
#define RX_DCB_ADDR_HIf_SET(r,f) (r).rx_dcb[1]=((uint32_t)f)
#define RX_DCB_ADDR_LOf_GET(r) ((r).rx_dcb[0])
#define RX_DCB_ADDR_LOf_SET(r,f) (r).rx_dcb[0]=((uint32_t)f)

/*******************************************************************************
 * End of 'RX_DCB'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Address
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_ADDRESSr_OFFSET 0x03222008

#define SMBUS0_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Address.
 */
typedef union SMBUS0_ADDRESSr_s {
    uint32_t v[1];
    uint32_t smbus0_address[1];
    uint32_t _smbus0_address;
} SMBUS0_ADDRESSr_t;

#define SMBUS0_ADDRESSr_CLR(r) (r).smbus0_address[0] = 0
#define SMBUS0_ADDRESSr_SET(r,d) (r).smbus0_address[0] = d
#define SMBUS0_ADDRESSr_GET(r) (r).smbus0_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_ADDRESSr_NIC_SMB_ADDR0f_GET(r) (((r).smbus0_address[0]) & 0x7f)
#define SMBUS0_ADDRESSr_NIC_SMB_ADDR0f_SET(r,f) (r).smbus0_address[0]=(((r).smbus0_address[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define SMBUS0_ADDRESSr_EN_NIC_SMB_ADDR0f_GET(r) ((((r).smbus0_address[0]) >> 7) & 0x1)
#define SMBUS0_ADDRESSr_EN_NIC_SMB_ADDR0f_SET(r,f) (r).smbus0_address[0]=(((r).smbus0_address[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define SMBUS0_ADDRESSr_NIC_SMB_ADDR1f_GET(r) ((((r).smbus0_address[0]) >> 8) & 0x7f)
#define SMBUS0_ADDRESSr_NIC_SMB_ADDR1f_SET(r,f) (r).smbus0_address[0]=(((r).smbus0_address[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define SMBUS0_ADDRESSr_EN_NIC_SMB_ADDR1f_GET(r) ((((r).smbus0_address[0]) >> 15) & 0x1)
#define SMBUS0_ADDRESSr_EN_NIC_SMB_ADDR1f_SET(r,f) (r).smbus0_address[0]=(((r).smbus0_address[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define SMBUS0_ADDRESSr_NIC_SMB_ADDR2f_GET(r) ((((r).smbus0_address[0]) >> 16) & 0x7f)
#define SMBUS0_ADDRESSr_NIC_SMB_ADDR2f_SET(r,f) (r).smbus0_address[0]=(((r).smbus0_address[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define SMBUS0_ADDRESSr_EN_NIC_SMB_ADDR2f_GET(r) ((((r).smbus0_address[0]) >> 23) & 0x1)
#define SMBUS0_ADDRESSr_EN_NIC_SMB_ADDR2f_SET(r,f) (r).smbus0_address[0]=(((r).smbus0_address[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define SMBUS0_ADDRESSr_NIC_SMB_ADDR3f_GET(r) ((((r).smbus0_address[0]) >> 24) & 0x7f)
#define SMBUS0_ADDRESSr_NIC_SMB_ADDR3f_SET(r,f) (r).smbus0_address[0]=(((r).smbus0_address[0] & ~((uint32_t)0x7f << 24)) | ((((uint32_t)f) & 0x7f) << 24))
#define SMBUS0_ADDRESSr_EN_NIC_SMB_ADDR3f_GET(r) ((((r).smbus0_address[0]) >> 31) & 0x1)
#define SMBUS0_ADDRESSr_EN_NIC_SMB_ADDR3f_SET(r,f) (r).smbus0_address[0]=(((r).smbus0_address[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Address.
 */
#define READ_SMBUS0_ADDRESSr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_ADDRESSr_OFFSET,r._smbus0_address)
#define WRITE_SMBUS0_ADDRESSr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_ADDRESSr_OFFSET,r._smbus0_address)

/*******************************************************************************
 * End of 'SMBUS0_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Bit_Bang_Control
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_BIT_BANG_CONTROLr_OFFSET 0x03222014

#define SMBUS0_BIT_BANG_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Bit_Bang_Control.
 */
typedef union SMBUS0_BIT_BANG_CONTROLr_s {
    uint32_t v[1];
    uint32_t smbus0_bit_bang_control[1];
    uint32_t _smbus0_bit_bang_control;
} SMBUS0_BIT_BANG_CONTROLr_t;

#define SMBUS0_BIT_BANG_CONTROLr_CLR(r) (r).smbus0_bit_bang_control[0] = 0
#define SMBUS0_BIT_BANG_CONTROLr_SET(r,d) (r).smbus0_bit_bang_control[0] = d
#define SMBUS0_BIT_BANG_CONTROLr_GET(r) (r).smbus0_bit_bang_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_BIT_BANG_CONTROLr_SMBDAT_OUT_ENf_GET(r) ((((r).smbus0_bit_bang_control[0]) >> 28) & 0x1)
#define SMBUS0_BIT_BANG_CONTROLr_SMBDAT_OUT_ENf_SET(r,f) (r).smbus0_bit_bang_control[0]=(((r).smbus0_bit_bang_control[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS0_BIT_BANG_CONTROLr_SMBDAT_INf_GET(r) ((((r).smbus0_bit_bang_control[0]) >> 29) & 0x1)
#define SMBUS0_BIT_BANG_CONTROLr_SMBDAT_INf_SET(r,f) (r).smbus0_bit_bang_control[0]=(((r).smbus0_bit_bang_control[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS0_BIT_BANG_CONTROLr_SMBCLK_OUT_ENf_GET(r) ((((r).smbus0_bit_bang_control[0]) >> 30) & 0x1)
#define SMBUS0_BIT_BANG_CONTROLr_SMBCLK_OUT_ENf_SET(r,f) (r).smbus0_bit_bang_control[0]=(((r).smbus0_bit_bang_control[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS0_BIT_BANG_CONTROLr_SMBCLK_INf_GET(r) ((((r).smbus0_bit_bang_control[0]) >> 31) & 0x1)
#define SMBUS0_BIT_BANG_CONTROLr_SMBCLK_INf_SET(r,f) (r).smbus0_bit_bang_control[0]=(((r).smbus0_bit_bang_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Bit_Bang_Control.
 */
#define READ_SMBUS0_BIT_BANG_CONTROLr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_BIT_BANG_CONTROLr_OFFSET,r._smbus0_bit_bang_control)
#define WRITE_SMBUS0_BIT_BANG_CONTROLr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_BIT_BANG_CONTROLr_OFFSET,r._smbus0_bit_bang_control)

/*******************************************************************************
 * End of 'SMBUS0_BIT_BANG_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Config
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_CONFIGr_OFFSET 0x03222000

#define SMBUS0_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Config.
 */
typedef union SMBUS0_CONFIGr_s {
    uint32_t v[1];
    uint32_t smbus0_config[1];
    uint32_t _smbus0_config;
} SMBUS0_CONFIGr_t;

#define SMBUS0_CONFIGr_CLR(r) (r).smbus0_config[0] = 0
#define SMBUS0_CONFIGr_SET(r,d) (r).smbus0_config[0] = d
#define SMBUS0_CONFIGr_GET(r) (r).smbus0_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_CONFIGr_MASTER_RTRY_CNTf_GET(r) ((((r).smbus0_config[0]) >> 16) & 0xf)
#define SMBUS0_CONFIGr_MASTER_RTRY_CNTf_SET(r,f) (r).smbus0_config[0]=(((r).smbus0_config[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define SMBUS0_CONFIGr_TIMESTAMP_CNT_ENf_GET(r) ((((r).smbus0_config[0]) >> 26) & 0x1)
#define SMBUS0_CONFIGr_TIMESTAMP_CNT_ENf_SET(r,f) (r).smbus0_config[0]=(((r).smbus0_config[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define SMBUS0_CONFIGr_PROMISCOUS_MODEf_GET(r) ((((r).smbus0_config[0]) >> 27) & 0x1)
#define SMBUS0_CONFIGr_PROMISCOUS_MODEf_SET(r,f) (r).smbus0_config[0]=(((r).smbus0_config[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define SMBUS0_CONFIGr_EN_NIC_SMB_ADDR_0f_GET(r) ((((r).smbus0_config[0]) >> 28) & 0x1)
#define SMBUS0_CONFIGr_EN_NIC_SMB_ADDR_0f_SET(r,f) (r).smbus0_config[0]=(((r).smbus0_config[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS0_CONFIGr_BIT_BANG_ENf_GET(r) ((((r).smbus0_config[0]) >> 29) & 0x1)
#define SMBUS0_CONFIGr_BIT_BANG_ENf_SET(r,f) (r).smbus0_config[0]=(((r).smbus0_config[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS0_CONFIGr_SMB_ENf_GET(r) ((((r).smbus0_config[0]) >> 30) & 0x1)
#define SMBUS0_CONFIGr_SMB_ENf_SET(r,f) (r).smbus0_config[0]=(((r).smbus0_config[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS0_CONFIGr_RESETf_GET(r) ((((r).smbus0_config[0]) >> 31) & 0x1)
#define SMBUS0_CONFIGr_RESETf_SET(r,f) (r).smbus0_config[0]=(((r).smbus0_config[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Config.
 */
#define READ_SMBUS0_CONFIGr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_CONFIGr_OFFSET,r._smbus0_config)
#define WRITE_SMBUS0_CONFIGr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_CONFIGr_OFFSET,r._smbus0_config)

/*******************************************************************************
 * End of 'SMBUS0_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Event_Enable
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_EVENT_ENABLEr_OFFSET 0x03222038

#define SMBUS0_EVENT_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Event_Enable.
 */
typedef union SMBUS0_EVENT_ENABLEr_s {
    uint32_t v[1];
    uint32_t smbus0_event_enable[1];
    uint32_t _smbus0_event_enable;
} SMBUS0_EVENT_ENABLEr_t;

#define SMBUS0_EVENT_ENABLEr_CLR(r) (r).smbus0_event_enable[0] = 0
#define SMBUS0_EVENT_ENABLEr_SET(r,d) (r).smbus0_event_enable[0] = d
#define SMBUS0_EVENT_ENABLEr_GET(r) (r).smbus0_event_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_EVENT_ENABLEr_SLAVE_RD_EVENT_ENf_GET(r) ((((r).smbus0_event_enable[0]) >> 21) & 0x1)
#define SMBUS0_EVENT_ENABLEr_SLAVE_RD_EVENT_ENf_SET(r,f) (r).smbus0_event_enable[0]=(((r).smbus0_event_enable[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define SMBUS0_EVENT_ENABLEr_SLAVE_TX_UNDERRUN_ENf_GET(r) ((((r).smbus0_event_enable[0]) >> 22) & 0x1)
#define SMBUS0_EVENT_ENABLEr_SLAVE_TX_UNDERRUN_ENf_SET(r,f) (r).smbus0_event_enable[0]=(((r).smbus0_event_enable[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define SMBUS0_EVENT_ENABLEr_SLAVE_START_BUSY_ENf_GET(r) ((((r).smbus0_event_enable[0]) >> 23) & 0x1)
#define SMBUS0_EVENT_ENABLEr_SLAVE_START_BUSY_ENf_SET(r,f) (r).smbus0_event_enable[0]=(((r).smbus0_event_enable[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define SMBUS0_EVENT_ENABLEr_SLAVE_RX_EVENT_ENf_GET(r) ((((r).smbus0_event_enable[0]) >> 24) & 0x1)
#define SMBUS0_EVENT_ENABLEr_SLAVE_RX_EVENT_ENf_SET(r,f) (r).smbus0_event_enable[0]=(((r).smbus0_event_enable[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define SMBUS0_EVENT_ENABLEr_SLAVE_RX_THRESHOLD_HIT_ENf_GET(r) ((((r).smbus0_event_enable[0]) >> 25) & 0x1)
#define SMBUS0_EVENT_ENABLEr_SLAVE_RX_THRESHOLD_HIT_ENf_SET(r,f) (r).smbus0_event_enable[0]=(((r).smbus0_event_enable[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define SMBUS0_EVENT_ENABLEr_SLAVE_RX_FIFO_FULL_ENf_GET(r) ((((r).smbus0_event_enable[0]) >> 26) & 0x1)
#define SMBUS0_EVENT_ENABLEr_SLAVE_RX_FIFO_FULL_ENf_SET(r,f) (r).smbus0_event_enable[0]=(((r).smbus0_event_enable[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define SMBUS0_EVENT_ENABLEr_MASTER_TX_UNDERRUN_ENf_GET(r) ((((r).smbus0_event_enable[0]) >> 27) & 0x1)
#define SMBUS0_EVENT_ENABLEr_MASTER_TX_UNDERRUN_ENf_SET(r,f) (r).smbus0_event_enable[0]=(((r).smbus0_event_enable[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define SMBUS0_EVENT_ENABLEr_MASTER_START_BUSY_ENf_GET(r) ((((r).smbus0_event_enable[0]) >> 28) & 0x1)
#define SMBUS0_EVENT_ENABLEr_MASTER_START_BUSY_ENf_SET(r,f) (r).smbus0_event_enable[0]=(((r).smbus0_event_enable[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS0_EVENT_ENABLEr_MASTER_RX_EVENT_ENf_GET(r) ((((r).smbus0_event_enable[0]) >> 29) & 0x1)
#define SMBUS0_EVENT_ENABLEr_MASTER_RX_EVENT_ENf_SET(r,f) (r).smbus0_event_enable[0]=(((r).smbus0_event_enable[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS0_EVENT_ENABLEr_MASTER_RX_THRESHOLD_HIT_ENf_GET(r) ((((r).smbus0_event_enable[0]) >> 30) & 0x1)
#define SMBUS0_EVENT_ENABLEr_MASTER_RX_THRESHOLD_HIT_ENf_SET(r,f) (r).smbus0_event_enable[0]=(((r).smbus0_event_enable[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS0_EVENT_ENABLEr_MASTER_RX_FIFO_FULL_ENf_GET(r) ((((r).smbus0_event_enable[0]) >> 31) & 0x1)
#define SMBUS0_EVENT_ENABLEr_MASTER_RX_FIFO_FULL_ENf_SET(r,f) (r).smbus0_event_enable[0]=(((r).smbus0_event_enable[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Event_Enable.
 */
#define READ_SMBUS0_EVENT_ENABLEr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_EVENT_ENABLEr_OFFSET,r._smbus0_event_enable)
#define WRITE_SMBUS0_EVENT_ENABLEr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_EVENT_ENABLEr_OFFSET,r._smbus0_event_enable)

/*******************************************************************************
 * End of 'SMBUS0_EVENT_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Event_Status
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_EVENT_STATUSr_OFFSET 0x0322203c

#define SMBUS0_EVENT_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Event_Status.
 */
typedef union SMBUS0_EVENT_STATUSr_s {
    uint32_t v[1];
    uint32_t smbus0_event_status[1];
    uint32_t _smbus0_event_status;
} SMBUS0_EVENT_STATUSr_t;

#define SMBUS0_EVENT_STATUSr_CLR(r) (r).smbus0_event_status[0] = 0
#define SMBUS0_EVENT_STATUSr_SET(r,d) (r).smbus0_event_status[0] = d
#define SMBUS0_EVENT_STATUSr_GET(r) (r).smbus0_event_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_EVENT_STATUSr_SLAVE_RD_EVENT_ENf_GET(r) ((((r).smbus0_event_status[0]) >> 21) & 0x1)
#define SMBUS0_EVENT_STATUSr_SLAVE_RD_EVENT_ENf_SET(r,f) (r).smbus0_event_status[0]=(((r).smbus0_event_status[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define SMBUS0_EVENT_STATUSr_SLAVE_TX_UNDERRUN_ENf_GET(r) ((((r).smbus0_event_status[0]) >> 22) & 0x1)
#define SMBUS0_EVENT_STATUSr_SLAVE_TX_UNDERRUN_ENf_SET(r,f) (r).smbus0_event_status[0]=(((r).smbus0_event_status[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define SMBUS0_EVENT_STATUSr_SLAVE_START_BUSYf_GET(r) ((((r).smbus0_event_status[0]) >> 23) & 0x1)
#define SMBUS0_EVENT_STATUSr_SLAVE_START_BUSYf_SET(r,f) (r).smbus0_event_status[0]=(((r).smbus0_event_status[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define SMBUS0_EVENT_STATUSr_SLAVE_RX_EVENTf_GET(r) ((((r).smbus0_event_status[0]) >> 24) & 0x1)
#define SMBUS0_EVENT_STATUSr_SLAVE_RX_EVENTf_SET(r,f) (r).smbus0_event_status[0]=(((r).smbus0_event_status[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define SMBUS0_EVENT_STATUSr_SLAVE_RX_THRESHOLD_HITf_GET(r) ((((r).smbus0_event_status[0]) >> 25) & 0x1)
#define SMBUS0_EVENT_STATUSr_SLAVE_RX_THRESHOLD_HITf_SET(r,f) (r).smbus0_event_status[0]=(((r).smbus0_event_status[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define SMBUS0_EVENT_STATUSr_SLAVE_RX_FIFO_FULLf_GET(r) ((((r).smbus0_event_status[0]) >> 26) & 0x1)
#define SMBUS0_EVENT_STATUSr_SLAVE_RX_FIFO_FULLf_SET(r,f) (r).smbus0_event_status[0]=(((r).smbus0_event_status[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define SMBUS0_EVENT_STATUSr_MASTER_TX_UNDERRUNf_GET(r) ((((r).smbus0_event_status[0]) >> 27) & 0x1)
#define SMBUS0_EVENT_STATUSr_MASTER_TX_UNDERRUNf_SET(r,f) (r).smbus0_event_status[0]=(((r).smbus0_event_status[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define SMBUS0_EVENT_STATUSr_MASTER_START_BUSYf_GET(r) ((((r).smbus0_event_status[0]) >> 28) & 0x1)
#define SMBUS0_EVENT_STATUSr_MASTER_START_BUSYf_SET(r,f) (r).smbus0_event_status[0]=(((r).smbus0_event_status[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS0_EVENT_STATUSr_MASTER_RX_EVENTf_GET(r) ((((r).smbus0_event_status[0]) >> 29) & 0x1)
#define SMBUS0_EVENT_STATUSr_MASTER_RX_EVENTf_SET(r,f) (r).smbus0_event_status[0]=(((r).smbus0_event_status[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS0_EVENT_STATUSr_MASTER_RX_THRESHOLD_HITf_GET(r) ((((r).smbus0_event_status[0]) >> 30) & 0x1)
#define SMBUS0_EVENT_STATUSr_MASTER_RX_THRESHOLD_HITf_SET(r,f) (r).smbus0_event_status[0]=(((r).smbus0_event_status[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS0_EVENT_STATUSr_MASTER_RX_FIFO_FULLf_GET(r) ((((r).smbus0_event_status[0]) >> 31) & 0x1)
#define SMBUS0_EVENT_STATUSr_MASTER_RX_FIFO_FULLf_SET(r,f) (r).smbus0_event_status[0]=(((r).smbus0_event_status[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Event_Status.
 */
#define READ_SMBUS0_EVENT_STATUSr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_EVENT_STATUSr_OFFSET,r._smbus0_event_status)
#define WRITE_SMBUS0_EVENT_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_EVENT_STATUSr_OFFSET,r._smbus0_event_status)

/*******************************************************************************
 * End of 'SMBUS0_EVENT_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Master_Command
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_MASTER_COMMANDr_OFFSET 0x03222030

#define SMBUS0_MASTER_COMMANDr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Master_Command.
 */
typedef union SMBUS0_MASTER_COMMANDr_s {
    uint32_t v[1];
    uint32_t smbus0_master_command[1];
    uint32_t _smbus0_master_command;
} SMBUS0_MASTER_COMMANDr_t;

#define SMBUS0_MASTER_COMMANDr_CLR(r) (r).smbus0_master_command[0] = 0
#define SMBUS0_MASTER_COMMANDr_SET(r,d) (r).smbus0_master_command[0] = d
#define SMBUS0_MASTER_COMMANDr_GET(r) (r).smbus0_master_command[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_MASTER_COMMANDr_RD_BYTE_COUNTf_GET(r) (((r).smbus0_master_command[0]) & 0xff)
#define SMBUS0_MASTER_COMMANDr_RD_BYTE_COUNTf_SET(r,f) (r).smbus0_master_command[0]=(((r).smbus0_master_command[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS0_MASTER_COMMANDr_MASTER_PECf_GET(r) ((((r).smbus0_master_command[0]) >> 8) & 0x1)
#define SMBUS0_MASTER_COMMANDr_MASTER_PECf_SET(r,f) (r).smbus0_master_command[0]=(((r).smbus0_master_command[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define SMBUS0_MASTER_COMMANDr_SMBUS_PROTOCOLf_GET(r) ((((r).smbus0_master_command[0]) >> 9) & 0xf)
#define SMBUS0_MASTER_COMMANDr_SMBUS_PROTOCOLf_SET(r,f) (r).smbus0_master_command[0]=(((r).smbus0_master_command[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define SMBUS0_MASTER_COMMANDr_MASTER_STATUSf_GET(r) ((((r).smbus0_master_command[0]) >> 25) & 0x7)
#define SMBUS0_MASTER_COMMANDr_MASTER_STATUSf_SET(r,f) (r).smbus0_master_command[0]=(((r).smbus0_master_command[0] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define SMBUS0_MASTER_COMMANDr_MASTER_ABORTf_GET(r) ((((r).smbus0_master_command[0]) >> 30) & 0x1)
#define SMBUS0_MASTER_COMMANDr_MASTER_ABORTf_SET(r,f) (r).smbus0_master_command[0]=(((r).smbus0_master_command[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS0_MASTER_COMMANDr_MASTER_START_BUSY_COMMANDf_GET(r) ((((r).smbus0_master_command[0]) >> 31) & 0x1)
#define SMBUS0_MASTER_COMMANDr_MASTER_START_BUSY_COMMANDf_SET(r,f) (r).smbus0_master_command[0]=(((r).smbus0_master_command[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Master_Command.
 */
#define READ_SMBUS0_MASTER_COMMANDr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_MASTER_COMMANDr_OFFSET,r._smbus0_master_command)
#define WRITE_SMBUS0_MASTER_COMMANDr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_MASTER_COMMANDr_OFFSET,r._smbus0_master_command)

/*******************************************************************************
 * End of 'SMBUS0_MASTER_COMMANDr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Master_Data_Read
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_MASTER_DATA_READr_OFFSET 0x03222044

#define SMBUS0_MASTER_DATA_READr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Master_Data_Read.
 */
typedef union SMBUS0_MASTER_DATA_READr_s {
    uint32_t v[1];
    uint32_t smbus0_master_data_read[1];
    uint32_t _smbus0_master_data_read;
} SMBUS0_MASTER_DATA_READr_t;

#define SMBUS0_MASTER_DATA_READr_CLR(r) (r).smbus0_master_data_read[0] = 0
#define SMBUS0_MASTER_DATA_READr_SET(r,d) (r).smbus0_master_data_read[0] = d
#define SMBUS0_MASTER_DATA_READr_GET(r) (r).smbus0_master_data_read[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_MASTER_DATA_READr_MASTER_SMBUS_RD_DATAf_GET(r) (((r).smbus0_master_data_read[0]) & 0xff)
#define SMBUS0_MASTER_DATA_READr_MASTER_SMBUS_RD_DATAf_SET(r,f) (r).smbus0_master_data_read[0]=(((r).smbus0_master_data_read[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS0_MASTER_DATA_READr_PEC_ERRf_GET(r) ((((r).smbus0_master_data_read[0]) >> 29) & 0x1)
#define SMBUS0_MASTER_DATA_READr_PEC_ERRf_SET(r,f) (r).smbus0_master_data_read[0]=(((r).smbus0_master_data_read[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS0_MASTER_DATA_READr_MASTER_RD_STATUSf_GET(r) ((((r).smbus0_master_data_read[0]) >> 30) & 0x3)
#define SMBUS0_MASTER_DATA_READr_MASTER_RD_STATUSf_SET(r,f) (r).smbus0_master_data_read[0]=(((r).smbus0_master_data_read[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access SMBus0_Master_Data_Read.
 */
#define READ_SMBUS0_MASTER_DATA_READr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_MASTER_DATA_READr_OFFSET,r._smbus0_master_data_read)
#define WRITE_SMBUS0_MASTER_DATA_READr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_MASTER_DATA_READr_OFFSET,r._smbus0_master_data_read)

/*******************************************************************************
 * End of 'SMBUS0_MASTER_DATA_READr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Master_Data_Write
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_MASTER_DATA_WRITEr_OFFSET 0x03222040

#define SMBUS0_MASTER_DATA_WRITEr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Master_Data_Write.
 */
typedef union SMBUS0_MASTER_DATA_WRITEr_s {
    uint32_t v[1];
    uint32_t smbus0_master_data_write[1];
    uint32_t _smbus0_master_data_write;
} SMBUS0_MASTER_DATA_WRITEr_t;

#define SMBUS0_MASTER_DATA_WRITEr_CLR(r) (r).smbus0_master_data_write[0] = 0
#define SMBUS0_MASTER_DATA_WRITEr_SET(r,d) (r).smbus0_master_data_write[0] = d
#define SMBUS0_MASTER_DATA_WRITEr_GET(r) (r).smbus0_master_data_write[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_MASTER_DATA_WRITEr_MASTER_SMBUS_WR_DATAf_GET(r) (((r).smbus0_master_data_write[0]) & 0xff)
#define SMBUS0_MASTER_DATA_WRITEr_MASTER_SMBUS_WR_DATAf_SET(r,f) (r).smbus0_master_data_write[0]=(((r).smbus0_master_data_write[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS0_MASTER_DATA_WRITEr_MASTER_WR_STATUSf_GET(r) ((((r).smbus0_master_data_write[0]) >> 31) & 0x1)
#define SMBUS0_MASTER_DATA_WRITEr_MASTER_WR_STATUSf_SET(r,f) (r).smbus0_master_data_write[0]=(((r).smbus0_master_data_write[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Master_Data_Write.
 */
#define READ_SMBUS0_MASTER_DATA_WRITEr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_MASTER_DATA_WRITEr_OFFSET,r._smbus0_master_data_write)
#define WRITE_SMBUS0_MASTER_DATA_WRITEr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_MASTER_DATA_WRITEr_OFFSET,r._smbus0_master_data_write)

/*******************************************************************************
 * End of 'SMBUS0_MASTER_DATA_WRITEr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Master_FIFO_control
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_MASTER_FIFO_CONTROLr_OFFSET 0x0322200c

#define SMBUS0_MASTER_FIFO_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Master_FIFO_control.
 */
typedef union SMBUS0_MASTER_FIFO_CONTROLr_s {
    uint32_t v[1];
    uint32_t smbus0_master_fifo_control[1];
    uint32_t _smbus0_master_fifo_control;
} SMBUS0_MASTER_FIFO_CONTROLr_t;

#define SMBUS0_MASTER_FIFO_CONTROLr_CLR(r) (r).smbus0_master_fifo_control[0] = 0
#define SMBUS0_MASTER_FIFO_CONTROLr_SET(r,d) (r).smbus0_master_fifo_control[0] = d
#define SMBUS0_MASTER_FIFO_CONTROLr_GET(r) (r).smbus0_master_fifo_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_THRESHOLDf_GET(r) ((((r).smbus0_master_fifo_control[0]) >> 8) & 0x3f)
#define SMBUS0_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_THRESHOLDf_SET(r,f) (r).smbus0_master_fifo_control[0]=(((r).smbus0_master_fifo_control[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define SMBUS0_MASTER_FIFO_CONTROLr_MASTER_RX_PKT_COUNTf_GET(r) ((((r).smbus0_master_fifo_control[0]) >> 16) & 0x7f)
#define SMBUS0_MASTER_FIFO_CONTROLr_MASTER_RX_PKT_COUNTf_SET(r,f) (r).smbus0_master_fifo_control[0]=(((r).smbus0_master_fifo_control[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define SMBUS0_MASTER_FIFO_CONTROLr_MASTER_TX_FIFO_FLUSHf_GET(r) ((((r).smbus0_master_fifo_control[0]) >> 30) & 0x1)
#define SMBUS0_MASTER_FIFO_CONTROLr_MASTER_TX_FIFO_FLUSHf_SET(r,f) (r).smbus0_master_fifo_control[0]=(((r).smbus0_master_fifo_control[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS0_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_FLUSHf_GET(r) ((((r).smbus0_master_fifo_control[0]) >> 31) & 0x1)
#define SMBUS0_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_FLUSHf_SET(r,f) (r).smbus0_master_fifo_control[0]=(((r).smbus0_master_fifo_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Master_FIFO_control.
 */
#define READ_SMBUS0_MASTER_FIFO_CONTROLr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_MASTER_FIFO_CONTROLr_OFFSET,r._smbus0_master_fifo_control)
#define WRITE_SMBUS0_MASTER_FIFO_CONTROLr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_MASTER_FIFO_CONTROLr_OFFSET,r._smbus0_master_fifo_control)

/*******************************************************************************
 * End of 'SMBUS0_MASTER_FIFO_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Slave_Command
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_SLAVE_COMMANDr_OFFSET 0x03222034

#define SMBUS0_SLAVE_COMMANDr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Slave_Command.
 */
typedef union SMBUS0_SLAVE_COMMANDr_s {
    uint32_t v[1];
    uint32_t smbus0_slave_command[1];
    uint32_t _smbus0_slave_command;
} SMBUS0_SLAVE_COMMANDr_t;

#define SMBUS0_SLAVE_COMMANDr_CLR(r) (r).smbus0_slave_command[0] = 0
#define SMBUS0_SLAVE_COMMANDr_SET(r,d) (r).smbus0_slave_command[0] = d
#define SMBUS0_SLAVE_COMMANDr_GET(r) (r).smbus0_slave_command[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_SLAVE_COMMANDr_SLAVE_PECf_GET(r) ((((r).smbus0_slave_command[0]) >> 8) & 0x1)
#define SMBUS0_SLAVE_COMMANDr_SLAVE_PECf_SET(r,f) (r).smbus0_slave_command[0]=(((r).smbus0_slave_command[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define SMBUS0_SLAVE_COMMANDr_SLAVE_STATUSf_GET(r) ((((r).smbus0_slave_command[0]) >> 23) & 0x7)
#define SMBUS0_SLAVE_COMMANDr_SLAVE_STATUSf_SET(r,f) (r).smbus0_slave_command[0]=(((r).smbus0_slave_command[0] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define SMBUS0_SLAVE_COMMANDr_SLAVE_ABORTf_GET(r) ((((r).smbus0_slave_command[0]) >> 30) & 0x1)
#define SMBUS0_SLAVE_COMMANDr_SLAVE_ABORTf_SET(r,f) (r).smbus0_slave_command[0]=(((r).smbus0_slave_command[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS0_SLAVE_COMMANDr_SLAVE_START_BUSY_COMMANDf_GET(r) ((((r).smbus0_slave_command[0]) >> 31) & 0x1)
#define SMBUS0_SLAVE_COMMANDr_SLAVE_START_BUSY_COMMANDf_SET(r,f) (r).smbus0_slave_command[0]=(((r).smbus0_slave_command[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Slave_Command.
 */
#define READ_SMBUS0_SLAVE_COMMANDr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_SLAVE_COMMANDr_OFFSET,r._smbus0_slave_command)
#define WRITE_SMBUS0_SLAVE_COMMANDr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_SLAVE_COMMANDr_OFFSET,r._smbus0_slave_command)

/*******************************************************************************
 * End of 'SMBUS0_SLAVE_COMMANDr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Slave_Data_Read
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_SLAVE_DATA_READr_OFFSET 0x0322204c

#define SMBUS0_SLAVE_DATA_READr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Slave_Data_Read.
 */
typedef union SMBUS0_SLAVE_DATA_READr_s {
    uint32_t v[1];
    uint32_t smbus0_slave_data_read[1];
    uint32_t _smbus0_slave_data_read;
} SMBUS0_SLAVE_DATA_READr_t;

#define SMBUS0_SLAVE_DATA_READr_CLR(r) (r).smbus0_slave_data_read[0] = 0
#define SMBUS0_SLAVE_DATA_READr_SET(r,d) (r).smbus0_slave_data_read[0] = d
#define SMBUS0_SLAVE_DATA_READr_GET(r) (r).smbus0_slave_data_read[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_SLAVE_DATA_READr_SLAVE_SMBUS_RD_DATAf_GET(r) (((r).smbus0_slave_data_read[0]) & 0xff)
#define SMBUS0_SLAVE_DATA_READr_SLAVE_SMBUS_RD_DATAf_SET(r,f) (r).smbus0_slave_data_read[0]=(((r).smbus0_slave_data_read[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS0_SLAVE_DATA_READr_ERR_STATUSf_GET(r) ((((r).smbus0_slave_data_read[0]) >> 28) & 0x3)
#define SMBUS0_SLAVE_DATA_READr_ERR_STATUSf_SET(r,f) (r).smbus0_slave_data_read[0]=(((r).smbus0_slave_data_read[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define SMBUS0_SLAVE_DATA_READr_SLAVE_RD_STATUSf_GET(r) ((((r).smbus0_slave_data_read[0]) >> 30) & 0x3)
#define SMBUS0_SLAVE_DATA_READr_SLAVE_RD_STATUSf_SET(r,f) (r).smbus0_slave_data_read[0]=(((r).smbus0_slave_data_read[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access SMBus0_Slave_Data_Read.
 */
#define READ_SMBUS0_SLAVE_DATA_READr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_SLAVE_DATA_READr_OFFSET,r._smbus0_slave_data_read)
#define WRITE_SMBUS0_SLAVE_DATA_READr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_SLAVE_DATA_READr_OFFSET,r._smbus0_slave_data_read)

/*******************************************************************************
 * End of 'SMBUS0_SLAVE_DATA_READr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Slave_Data_Write
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_SLAVE_DATA_WRITEr_OFFSET 0x03222048

#define SMBUS0_SLAVE_DATA_WRITEr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Slave_Data_Write.
 */
typedef union SMBUS0_SLAVE_DATA_WRITEr_s {
    uint32_t v[1];
    uint32_t smbus0_slave_data_write[1];
    uint32_t _smbus0_slave_data_write;
} SMBUS0_SLAVE_DATA_WRITEr_t;

#define SMBUS0_SLAVE_DATA_WRITEr_CLR(r) (r).smbus0_slave_data_write[0] = 0
#define SMBUS0_SLAVE_DATA_WRITEr_SET(r,d) (r).smbus0_slave_data_write[0] = d
#define SMBUS0_SLAVE_DATA_WRITEr_GET(r) (r).smbus0_slave_data_write[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_SLAVE_DATA_WRITEr_SLAVE_SMBUS_WR_DATAf_GET(r) (((r).smbus0_slave_data_write[0]) & 0xff)
#define SMBUS0_SLAVE_DATA_WRITEr_SLAVE_SMBUS_WR_DATAf_SET(r,f) (r).smbus0_slave_data_write[0]=(((r).smbus0_slave_data_write[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS0_SLAVE_DATA_WRITEr_SLAVE_WR_STATUSf_GET(r) ((((r).smbus0_slave_data_write[0]) >> 31) & 0x1)
#define SMBUS0_SLAVE_DATA_WRITEr_SLAVE_WR_STATUSf_SET(r,f) (r).smbus0_slave_data_write[0]=(((r).smbus0_slave_data_write[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Slave_Data_Write.
 */
#define READ_SMBUS0_SLAVE_DATA_WRITEr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_SLAVE_DATA_WRITEr_OFFSET,r._smbus0_slave_data_write)
#define WRITE_SMBUS0_SLAVE_DATA_WRITEr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_SLAVE_DATA_WRITEr_OFFSET,r._smbus0_slave_data_write)

/*******************************************************************************
 * End of 'SMBUS0_SLAVE_DATA_WRITEr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Slave_FIFO_control
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_SLAVE_FIFO_CONTROLr_OFFSET 0x03222010

#define SMBUS0_SLAVE_FIFO_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Slave_FIFO_control.
 */
typedef union SMBUS0_SLAVE_FIFO_CONTROLr_s {
    uint32_t v[1];
    uint32_t smbus0_slave_fifo_control[1];
    uint32_t _smbus0_slave_fifo_control;
} SMBUS0_SLAVE_FIFO_CONTROLr_t;

#define SMBUS0_SLAVE_FIFO_CONTROLr_CLR(r) (r).smbus0_slave_fifo_control[0] = 0
#define SMBUS0_SLAVE_FIFO_CONTROLr_SET(r,d) (r).smbus0_slave_fifo_control[0] = d
#define SMBUS0_SLAVE_FIFO_CONTROLr_GET(r) (r).smbus0_slave_fifo_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_THRESHOLDf_GET(r) ((((r).smbus0_slave_fifo_control[0]) >> 8) & 0x3f)
#define SMBUS0_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_THRESHOLDf_SET(r,f) (r).smbus0_slave_fifo_control[0]=(((r).smbus0_slave_fifo_control[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define SMBUS0_SLAVE_FIFO_CONTROLr_SLAVE_RX_PKT_COUNTf_GET(r) ((((r).smbus0_slave_fifo_control[0]) >> 16) & 0x7f)
#define SMBUS0_SLAVE_FIFO_CONTROLr_SLAVE_RX_PKT_COUNTf_SET(r,f) (r).smbus0_slave_fifo_control[0]=(((r).smbus0_slave_fifo_control[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define SMBUS0_SLAVE_FIFO_CONTROLr_SLAVE_TX_FIFO_FLUSHf_GET(r) ((((r).smbus0_slave_fifo_control[0]) >> 30) & 0x1)
#define SMBUS0_SLAVE_FIFO_CONTROLr_SLAVE_TX_FIFO_FLUSHf_SET(r,f) (r).smbus0_slave_fifo_control[0]=(((r).smbus0_slave_fifo_control[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS0_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_FLUSHf_GET(r) ((((r).smbus0_slave_fifo_control[0]) >> 31) & 0x1)
#define SMBUS0_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_FLUSHf_SET(r,f) (r).smbus0_slave_fifo_control[0]=(((r).smbus0_slave_fifo_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Slave_FIFO_control.
 */
#define READ_SMBUS0_SLAVE_FIFO_CONTROLr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_SLAVE_FIFO_CONTROLr_OFFSET,r._smbus0_slave_fifo_control)
#define WRITE_SMBUS0_SLAVE_FIFO_CONTROLr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_SLAVE_FIFO_CONTROLr_OFFSET,r._smbus0_slave_fifo_control)

/*******************************************************************************
 * End of 'SMBUS0_SLAVE_FIFO_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Timing_Config
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_TIMING_CONFIGr_OFFSET 0x03222004

#define SMBUS0_TIMING_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Timing_Config.
 */
typedef union SMBUS0_TIMING_CONFIGr_s {
    uint32_t v[1];
    uint32_t smbus0_timing_config[1];
    uint32_t _smbus0_timing_config;
} SMBUS0_TIMING_CONFIGr_t;

#define SMBUS0_TIMING_CONFIGr_CLR(r) (r).smbus0_timing_config[0] = 0
#define SMBUS0_TIMING_CONFIGr_SET(r,d) (r).smbus0_timing_config[0] = d
#define SMBUS0_TIMING_CONFIGr_GET(r) (r).smbus0_timing_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_TIMING_CONFIGr_SMBUS_IDLE_TIMEf_GET(r) ((((r).smbus0_timing_config[0]) >> 8) & 0xff)
#define SMBUS0_TIMING_CONFIGr_SMBUS_IDLE_TIMEf_SET(r,f) (r).smbus0_timing_config[0]=(((r).smbus0_timing_config[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define SMBUS0_TIMING_CONFIGr_PERIODIC_SLAVE_STRETCHf_GET(r) ((((r).smbus0_timing_config[0]) >> 16) & 0xff)
#define SMBUS0_TIMING_CONFIGr_PERIODIC_SLAVE_STRETCHf_SET(r,f) (r).smbus0_timing_config[0]=(((r).smbus0_timing_config[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define SMBUS0_TIMING_CONFIGr_RANDOM_SLAVE_STRETCHf_GET(r) ((((r).smbus0_timing_config[0]) >> 24) & 0x7f)
#define SMBUS0_TIMING_CONFIGr_RANDOM_SLAVE_STRETCHf_SET(r,f) (r).smbus0_timing_config[0]=(((r).smbus0_timing_config[0] & ~((uint32_t)0x7f << 24)) | ((((uint32_t)f) & 0x7f) << 24))
#define SMBUS0_TIMING_CONFIGr_MODE_400f_GET(r) ((((r).smbus0_timing_config[0]) >> 31) & 0x1)
#define SMBUS0_TIMING_CONFIGr_MODE_400f_SET(r,f) (r).smbus0_timing_config[0]=(((r).smbus0_timing_config[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus0_Timing_Config.
 */
#define READ_SMBUS0_TIMING_CONFIGr(u,r) BCMDRD_IPROC_READ(u,SMBUS0_TIMING_CONFIGr_OFFSET,r._smbus0_timing_config)
#define WRITE_SMBUS0_TIMING_CONFIGr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_TIMING_CONFIGr_OFFSET,r._smbus0_timing_config)

/*******************************************************************************
 * End of 'SMBUS0_TIMING_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  SMBus0_Timing_Config_2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS0_TIMING_CONFIG_2r_OFFSET 0x032220b0

#define SMBUS0_TIMING_CONFIG_2r_SIZE 4

/*
 * This structure should be used to declare and program SMBus0_Timing_Config_2.
 */
typedef union SMBUS0_TIMING_CONFIG_2r_s {
    uint32_t v[1];
    uint32_t smbus0_timing_config_2[1];
    uint32_t _smbus0_timing_config_2;
} SMBUS0_TIMING_CONFIG_2r_t;

#define SMBUS0_TIMING_CONFIG_2r_CLR(r) (r).smbus0_timing_config_2[0] = 0
#define SMBUS0_TIMING_CONFIG_2r_SET(r,d) (r).smbus0_timing_config_2[0] = d
#define SMBUS0_TIMING_CONFIG_2r_GET(r) (r).smbus0_timing_config_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS0_TIMING_CONFIG_2r_TIMING_TLOW_100KHZf_GET(r) (((r).smbus0_timing_config_2[0]) & 0xff)
#define SMBUS0_TIMING_CONFIG_2r_TIMING_TLOW_100KHZf_SET(r,f) (r).smbus0_timing_config_2[0]=(((r).smbus0_timing_config_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS0_TIMING_CONFIG_2r_TIMING_THIGH_100KHZf_GET(r) ((((r).smbus0_timing_config_2[0]) >> 8) & 0xff)
#define SMBUS0_TIMING_CONFIG_2r_TIMING_THIGH_100KHZf_SET(r,f) (r).smbus0_timing_config_2[0]=(((r).smbus0_timing_config_2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define SMBUS0_TIMING_CONFIG_2r_TIMING_TLOW_400KHZf_GET(r) ((((r).smbus0_timing_config_2[0]) >> 16) & 0xff)
#define SMBUS0_TIMING_CONFIG_2r_TIMING_TLOW_400KHZf_SET(r,f) (r).smbus0_timing_config_2[0]=(((r).smbus0_timing_config_2[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define SMBUS0_TIMING_CONFIG_2r_TIMING_THIGH_400KHZf_GET(r) ((((r).smbus0_timing_config_2[0]) >> 24) & 0xff)
#define SMBUS0_TIMING_CONFIG_2r_TIMING_THIGH_400KHZf_SET(r,f) (r).smbus0_timing_config_2[0]=(((r).smbus0_timing_config_2[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access SMBus0_Timing_Config_2.
 */
#define READ_SMBUS0_TIMING_CONFIG_2r(u,r) BCMDRD_IPROC_READ(u,SMBUS0_TIMING_CONFIG_2r_OFFSET,r._smbus0_timing_config_2)
#define WRITE_SMBUS0_TIMING_CONFIG_2r(u,r) BCMDRD_IPROC_WRITE(u,SMBUS0_TIMING_CONFIG_2r_OFFSET,r._smbus0_timing_config_2)

/*******************************************************************************
 * End of 'SMBUS0_TIMING_CONFIG_2r'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Address
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_ADDRESSr_OFFSET 0x03223008

#define SMBUS1_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Address.
 */
typedef union SMBUS1_ADDRESSr_s {
    uint32_t v[1];
    uint32_t smbus1_address[1];
    uint32_t _smbus1_address;
} SMBUS1_ADDRESSr_t;

#define SMBUS1_ADDRESSr_CLR(r) (r).smbus1_address[0] = 0
#define SMBUS1_ADDRESSr_SET(r,d) (r).smbus1_address[0] = d
#define SMBUS1_ADDRESSr_GET(r) (r).smbus1_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_ADDRESSr_NIC_SMB_ADDR0f_GET(r) (((r).smbus1_address[0]) & 0x7f)
#define SMBUS1_ADDRESSr_NIC_SMB_ADDR0f_SET(r,f) (r).smbus1_address[0]=(((r).smbus1_address[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define SMBUS1_ADDRESSr_EN_NIC_SMB_ADDR0f_GET(r) ((((r).smbus1_address[0]) >> 7) & 0x1)
#define SMBUS1_ADDRESSr_EN_NIC_SMB_ADDR0f_SET(r,f) (r).smbus1_address[0]=(((r).smbus1_address[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define SMBUS1_ADDRESSr_NIC_SMB_ADDR1f_GET(r) ((((r).smbus1_address[0]) >> 8) & 0x7f)
#define SMBUS1_ADDRESSr_NIC_SMB_ADDR1f_SET(r,f) (r).smbus1_address[0]=(((r).smbus1_address[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define SMBUS1_ADDRESSr_EN_NIC_SMB_ADDR1f_GET(r) ((((r).smbus1_address[0]) >> 15) & 0x1)
#define SMBUS1_ADDRESSr_EN_NIC_SMB_ADDR1f_SET(r,f) (r).smbus1_address[0]=(((r).smbus1_address[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define SMBUS1_ADDRESSr_NIC_SMB_ADDR2f_GET(r) ((((r).smbus1_address[0]) >> 16) & 0x7f)
#define SMBUS1_ADDRESSr_NIC_SMB_ADDR2f_SET(r,f) (r).smbus1_address[0]=(((r).smbus1_address[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define SMBUS1_ADDRESSr_EN_NIC_SMB_ADDR2f_GET(r) ((((r).smbus1_address[0]) >> 23) & 0x1)
#define SMBUS1_ADDRESSr_EN_NIC_SMB_ADDR2f_SET(r,f) (r).smbus1_address[0]=(((r).smbus1_address[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define SMBUS1_ADDRESSr_NIC_SMB_ADDR3f_GET(r) ((((r).smbus1_address[0]) >> 24) & 0x7f)
#define SMBUS1_ADDRESSr_NIC_SMB_ADDR3f_SET(r,f) (r).smbus1_address[0]=(((r).smbus1_address[0] & ~((uint32_t)0x7f << 24)) | ((((uint32_t)f) & 0x7f) << 24))
#define SMBUS1_ADDRESSr_EN_NIC_SMB_ADDR3f_GET(r) ((((r).smbus1_address[0]) >> 31) & 0x1)
#define SMBUS1_ADDRESSr_EN_NIC_SMB_ADDR3f_SET(r,f) (r).smbus1_address[0]=(((r).smbus1_address[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Address.
 */
#define READ_SMBUS1_ADDRESSr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_ADDRESSr_OFFSET,r._smbus1_address)
#define WRITE_SMBUS1_ADDRESSr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_ADDRESSr_OFFSET,r._smbus1_address)

/*******************************************************************************
 * End of 'SMBUS1_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Bit_Bang_Control
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_BIT_BANG_CONTROLr_OFFSET 0x03223014

#define SMBUS1_BIT_BANG_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Bit_Bang_Control.
 */
typedef union SMBUS1_BIT_BANG_CONTROLr_s {
    uint32_t v[1];
    uint32_t smbus1_bit_bang_control[1];
    uint32_t _smbus1_bit_bang_control;
} SMBUS1_BIT_BANG_CONTROLr_t;

#define SMBUS1_BIT_BANG_CONTROLr_CLR(r) (r).smbus1_bit_bang_control[0] = 0
#define SMBUS1_BIT_BANG_CONTROLr_SET(r,d) (r).smbus1_bit_bang_control[0] = d
#define SMBUS1_BIT_BANG_CONTROLr_GET(r) (r).smbus1_bit_bang_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_BIT_BANG_CONTROLr_SMBDAT_OUT_ENf_GET(r) ((((r).smbus1_bit_bang_control[0]) >> 28) & 0x1)
#define SMBUS1_BIT_BANG_CONTROLr_SMBDAT_OUT_ENf_SET(r,f) (r).smbus1_bit_bang_control[0]=(((r).smbus1_bit_bang_control[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS1_BIT_BANG_CONTROLr_SMBDAT_INf_GET(r) ((((r).smbus1_bit_bang_control[0]) >> 29) & 0x1)
#define SMBUS1_BIT_BANG_CONTROLr_SMBDAT_INf_SET(r,f) (r).smbus1_bit_bang_control[0]=(((r).smbus1_bit_bang_control[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS1_BIT_BANG_CONTROLr_SMBCLK_OUT_ENf_GET(r) ((((r).smbus1_bit_bang_control[0]) >> 30) & 0x1)
#define SMBUS1_BIT_BANG_CONTROLr_SMBCLK_OUT_ENf_SET(r,f) (r).smbus1_bit_bang_control[0]=(((r).smbus1_bit_bang_control[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS1_BIT_BANG_CONTROLr_SMBCLK_INf_GET(r) ((((r).smbus1_bit_bang_control[0]) >> 31) & 0x1)
#define SMBUS1_BIT_BANG_CONTROLr_SMBCLK_INf_SET(r,f) (r).smbus1_bit_bang_control[0]=(((r).smbus1_bit_bang_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Bit_Bang_Control.
 */
#define READ_SMBUS1_BIT_BANG_CONTROLr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_BIT_BANG_CONTROLr_OFFSET,r._smbus1_bit_bang_control)
#define WRITE_SMBUS1_BIT_BANG_CONTROLr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_BIT_BANG_CONTROLr_OFFSET,r._smbus1_bit_bang_control)

/*******************************************************************************
 * End of 'SMBUS1_BIT_BANG_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Config
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_CONFIGr_OFFSET 0x03223000

#define SMBUS1_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Config.
 */
typedef union SMBUS1_CONFIGr_s {
    uint32_t v[1];
    uint32_t smbus1_config[1];
    uint32_t _smbus1_config;
} SMBUS1_CONFIGr_t;

#define SMBUS1_CONFIGr_CLR(r) (r).smbus1_config[0] = 0
#define SMBUS1_CONFIGr_SET(r,d) (r).smbus1_config[0] = d
#define SMBUS1_CONFIGr_GET(r) (r).smbus1_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_CONFIGr_MASTER_RTRY_CNTf_GET(r) ((((r).smbus1_config[0]) >> 16) & 0xf)
#define SMBUS1_CONFIGr_MASTER_RTRY_CNTf_SET(r,f) (r).smbus1_config[0]=(((r).smbus1_config[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define SMBUS1_CONFIGr_TIMESTAMP_CNT_ENf_GET(r) ((((r).smbus1_config[0]) >> 26) & 0x1)
#define SMBUS1_CONFIGr_TIMESTAMP_CNT_ENf_SET(r,f) (r).smbus1_config[0]=(((r).smbus1_config[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define SMBUS1_CONFIGr_PROMISCOUS_MODEf_GET(r) ((((r).smbus1_config[0]) >> 27) & 0x1)
#define SMBUS1_CONFIGr_PROMISCOUS_MODEf_SET(r,f) (r).smbus1_config[0]=(((r).smbus1_config[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define SMBUS1_CONFIGr_EN_NIC_SMB_ADDR_0f_GET(r) ((((r).smbus1_config[0]) >> 28) & 0x1)
#define SMBUS1_CONFIGr_EN_NIC_SMB_ADDR_0f_SET(r,f) (r).smbus1_config[0]=(((r).smbus1_config[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS1_CONFIGr_BIT_BANG_ENf_GET(r) ((((r).smbus1_config[0]) >> 29) & 0x1)
#define SMBUS1_CONFIGr_BIT_BANG_ENf_SET(r,f) (r).smbus1_config[0]=(((r).smbus1_config[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS1_CONFIGr_SMB_ENf_GET(r) ((((r).smbus1_config[0]) >> 30) & 0x1)
#define SMBUS1_CONFIGr_SMB_ENf_SET(r,f) (r).smbus1_config[0]=(((r).smbus1_config[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS1_CONFIGr_RESETf_GET(r) ((((r).smbus1_config[0]) >> 31) & 0x1)
#define SMBUS1_CONFIGr_RESETf_SET(r,f) (r).smbus1_config[0]=(((r).smbus1_config[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Config.
 */
#define READ_SMBUS1_CONFIGr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_CONFIGr_OFFSET,r._smbus1_config)
#define WRITE_SMBUS1_CONFIGr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_CONFIGr_OFFSET,r._smbus1_config)

/*******************************************************************************
 * End of 'SMBUS1_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Event_Enable
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_EVENT_ENABLEr_OFFSET 0x03223038

#define SMBUS1_EVENT_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Event_Enable.
 */
typedef union SMBUS1_EVENT_ENABLEr_s {
    uint32_t v[1];
    uint32_t smbus1_event_enable[1];
    uint32_t _smbus1_event_enable;
} SMBUS1_EVENT_ENABLEr_t;

#define SMBUS1_EVENT_ENABLEr_CLR(r) (r).smbus1_event_enable[0] = 0
#define SMBUS1_EVENT_ENABLEr_SET(r,d) (r).smbus1_event_enable[0] = d
#define SMBUS1_EVENT_ENABLEr_GET(r) (r).smbus1_event_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_EVENT_ENABLEr_SLAVE_RD_EVENT_ENf_GET(r) ((((r).smbus1_event_enable[0]) >> 21) & 0x1)
#define SMBUS1_EVENT_ENABLEr_SLAVE_RD_EVENT_ENf_SET(r,f) (r).smbus1_event_enable[0]=(((r).smbus1_event_enable[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define SMBUS1_EVENT_ENABLEr_SLAVE_TX_UNDERRUN_ENf_GET(r) ((((r).smbus1_event_enable[0]) >> 22) & 0x1)
#define SMBUS1_EVENT_ENABLEr_SLAVE_TX_UNDERRUN_ENf_SET(r,f) (r).smbus1_event_enable[0]=(((r).smbus1_event_enable[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define SMBUS1_EVENT_ENABLEr_SLAVE_START_BUSY_ENf_GET(r) ((((r).smbus1_event_enable[0]) >> 23) & 0x1)
#define SMBUS1_EVENT_ENABLEr_SLAVE_START_BUSY_ENf_SET(r,f) (r).smbus1_event_enable[0]=(((r).smbus1_event_enable[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define SMBUS1_EVENT_ENABLEr_SLAVE_RX_EVENT_ENf_GET(r) ((((r).smbus1_event_enable[0]) >> 24) & 0x1)
#define SMBUS1_EVENT_ENABLEr_SLAVE_RX_EVENT_ENf_SET(r,f) (r).smbus1_event_enable[0]=(((r).smbus1_event_enable[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define SMBUS1_EVENT_ENABLEr_SLAVE_RX_THRESHOLD_HIT_ENf_GET(r) ((((r).smbus1_event_enable[0]) >> 25) & 0x1)
#define SMBUS1_EVENT_ENABLEr_SLAVE_RX_THRESHOLD_HIT_ENf_SET(r,f) (r).smbus1_event_enable[0]=(((r).smbus1_event_enable[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define SMBUS1_EVENT_ENABLEr_SLAVE_RX_FIFO_FULL_ENf_GET(r) ((((r).smbus1_event_enable[0]) >> 26) & 0x1)
#define SMBUS1_EVENT_ENABLEr_SLAVE_RX_FIFO_FULL_ENf_SET(r,f) (r).smbus1_event_enable[0]=(((r).smbus1_event_enable[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define SMBUS1_EVENT_ENABLEr_MASTER_TX_UNDERRUN_ENf_GET(r) ((((r).smbus1_event_enable[0]) >> 27) & 0x1)
#define SMBUS1_EVENT_ENABLEr_MASTER_TX_UNDERRUN_ENf_SET(r,f) (r).smbus1_event_enable[0]=(((r).smbus1_event_enable[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define SMBUS1_EVENT_ENABLEr_MASTER_START_BUSY_ENf_GET(r) ((((r).smbus1_event_enable[0]) >> 28) & 0x1)
#define SMBUS1_EVENT_ENABLEr_MASTER_START_BUSY_ENf_SET(r,f) (r).smbus1_event_enable[0]=(((r).smbus1_event_enable[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS1_EVENT_ENABLEr_MASTER_RX_EVENT_ENf_GET(r) ((((r).smbus1_event_enable[0]) >> 29) & 0x1)
#define SMBUS1_EVENT_ENABLEr_MASTER_RX_EVENT_ENf_SET(r,f) (r).smbus1_event_enable[0]=(((r).smbus1_event_enable[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS1_EVENT_ENABLEr_MASTER_RX_THRESHOLD_HIT_ENf_GET(r) ((((r).smbus1_event_enable[0]) >> 30) & 0x1)
#define SMBUS1_EVENT_ENABLEr_MASTER_RX_THRESHOLD_HIT_ENf_SET(r,f) (r).smbus1_event_enable[0]=(((r).smbus1_event_enable[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS1_EVENT_ENABLEr_MASTER_RX_FIFO_FULL_ENf_GET(r) ((((r).smbus1_event_enable[0]) >> 31) & 0x1)
#define SMBUS1_EVENT_ENABLEr_MASTER_RX_FIFO_FULL_ENf_SET(r,f) (r).smbus1_event_enable[0]=(((r).smbus1_event_enable[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Event_Enable.
 */
#define READ_SMBUS1_EVENT_ENABLEr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_EVENT_ENABLEr_OFFSET,r._smbus1_event_enable)
#define WRITE_SMBUS1_EVENT_ENABLEr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_EVENT_ENABLEr_OFFSET,r._smbus1_event_enable)

/*******************************************************************************
 * End of 'SMBUS1_EVENT_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Event_Status
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_EVENT_STATUSr_OFFSET 0x0322303c

#define SMBUS1_EVENT_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Event_Status.
 */
typedef union SMBUS1_EVENT_STATUSr_s {
    uint32_t v[1];
    uint32_t smbus1_event_status[1];
    uint32_t _smbus1_event_status;
} SMBUS1_EVENT_STATUSr_t;

#define SMBUS1_EVENT_STATUSr_CLR(r) (r).smbus1_event_status[0] = 0
#define SMBUS1_EVENT_STATUSr_SET(r,d) (r).smbus1_event_status[0] = d
#define SMBUS1_EVENT_STATUSr_GET(r) (r).smbus1_event_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_EVENT_STATUSr_SLAVE_RD_EVENT_ENf_GET(r) ((((r).smbus1_event_status[0]) >> 21) & 0x1)
#define SMBUS1_EVENT_STATUSr_SLAVE_RD_EVENT_ENf_SET(r,f) (r).smbus1_event_status[0]=(((r).smbus1_event_status[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define SMBUS1_EVENT_STATUSr_SLAVE_TX_UNDERRUN_ENf_GET(r) ((((r).smbus1_event_status[0]) >> 22) & 0x1)
#define SMBUS1_EVENT_STATUSr_SLAVE_TX_UNDERRUN_ENf_SET(r,f) (r).smbus1_event_status[0]=(((r).smbus1_event_status[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define SMBUS1_EVENT_STATUSr_SLAVE_START_BUSYf_GET(r) ((((r).smbus1_event_status[0]) >> 23) & 0x1)
#define SMBUS1_EVENT_STATUSr_SLAVE_START_BUSYf_SET(r,f) (r).smbus1_event_status[0]=(((r).smbus1_event_status[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define SMBUS1_EVENT_STATUSr_SLAVE_RX_EVENTf_GET(r) ((((r).smbus1_event_status[0]) >> 24) & 0x1)
#define SMBUS1_EVENT_STATUSr_SLAVE_RX_EVENTf_SET(r,f) (r).smbus1_event_status[0]=(((r).smbus1_event_status[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define SMBUS1_EVENT_STATUSr_SLAVE_RX_THRESHOLD_HITf_GET(r) ((((r).smbus1_event_status[0]) >> 25) & 0x1)
#define SMBUS1_EVENT_STATUSr_SLAVE_RX_THRESHOLD_HITf_SET(r,f) (r).smbus1_event_status[0]=(((r).smbus1_event_status[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define SMBUS1_EVENT_STATUSr_SLAVE_RX_FIFO_FULLf_GET(r) ((((r).smbus1_event_status[0]) >> 26) & 0x1)
#define SMBUS1_EVENT_STATUSr_SLAVE_RX_FIFO_FULLf_SET(r,f) (r).smbus1_event_status[0]=(((r).smbus1_event_status[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define SMBUS1_EVENT_STATUSr_MASTER_TX_UNDERRUNf_GET(r) ((((r).smbus1_event_status[0]) >> 27) & 0x1)
#define SMBUS1_EVENT_STATUSr_MASTER_TX_UNDERRUNf_SET(r,f) (r).smbus1_event_status[0]=(((r).smbus1_event_status[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define SMBUS1_EVENT_STATUSr_MASTER_START_BUSYf_GET(r) ((((r).smbus1_event_status[0]) >> 28) & 0x1)
#define SMBUS1_EVENT_STATUSr_MASTER_START_BUSYf_SET(r,f) (r).smbus1_event_status[0]=(((r).smbus1_event_status[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS1_EVENT_STATUSr_MASTER_RX_EVENTf_GET(r) ((((r).smbus1_event_status[0]) >> 29) & 0x1)
#define SMBUS1_EVENT_STATUSr_MASTER_RX_EVENTf_SET(r,f) (r).smbus1_event_status[0]=(((r).smbus1_event_status[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS1_EVENT_STATUSr_MASTER_RX_THRESHOLD_HITf_GET(r) ((((r).smbus1_event_status[0]) >> 30) & 0x1)
#define SMBUS1_EVENT_STATUSr_MASTER_RX_THRESHOLD_HITf_SET(r,f) (r).smbus1_event_status[0]=(((r).smbus1_event_status[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS1_EVENT_STATUSr_MASTER_RX_FIFO_FULLf_GET(r) ((((r).smbus1_event_status[0]) >> 31) & 0x1)
#define SMBUS1_EVENT_STATUSr_MASTER_RX_FIFO_FULLf_SET(r,f) (r).smbus1_event_status[0]=(((r).smbus1_event_status[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Event_Status.
 */
#define READ_SMBUS1_EVENT_STATUSr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_EVENT_STATUSr_OFFSET,r._smbus1_event_status)
#define WRITE_SMBUS1_EVENT_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_EVENT_STATUSr_OFFSET,r._smbus1_event_status)

/*******************************************************************************
 * End of 'SMBUS1_EVENT_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Master_Command
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_MASTER_COMMANDr_OFFSET 0x03223030

#define SMBUS1_MASTER_COMMANDr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Master_Command.
 */
typedef union SMBUS1_MASTER_COMMANDr_s {
    uint32_t v[1];
    uint32_t smbus1_master_command[1];
    uint32_t _smbus1_master_command;
} SMBUS1_MASTER_COMMANDr_t;

#define SMBUS1_MASTER_COMMANDr_CLR(r) (r).smbus1_master_command[0] = 0
#define SMBUS1_MASTER_COMMANDr_SET(r,d) (r).smbus1_master_command[0] = d
#define SMBUS1_MASTER_COMMANDr_GET(r) (r).smbus1_master_command[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_MASTER_COMMANDr_RD_BYTE_COUNTf_GET(r) (((r).smbus1_master_command[0]) & 0xff)
#define SMBUS1_MASTER_COMMANDr_RD_BYTE_COUNTf_SET(r,f) (r).smbus1_master_command[0]=(((r).smbus1_master_command[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS1_MASTER_COMMANDr_MASTER_PECf_GET(r) ((((r).smbus1_master_command[0]) >> 8) & 0x1)
#define SMBUS1_MASTER_COMMANDr_MASTER_PECf_SET(r,f) (r).smbus1_master_command[0]=(((r).smbus1_master_command[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define SMBUS1_MASTER_COMMANDr_SMBUS_PROTOCOLf_GET(r) ((((r).smbus1_master_command[0]) >> 9) & 0xf)
#define SMBUS1_MASTER_COMMANDr_SMBUS_PROTOCOLf_SET(r,f) (r).smbus1_master_command[0]=(((r).smbus1_master_command[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define SMBUS1_MASTER_COMMANDr_MASTER_STATUSf_GET(r) ((((r).smbus1_master_command[0]) >> 25) & 0x7)
#define SMBUS1_MASTER_COMMANDr_MASTER_STATUSf_SET(r,f) (r).smbus1_master_command[0]=(((r).smbus1_master_command[0] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define SMBUS1_MASTER_COMMANDr_MASTER_ABORTf_GET(r) ((((r).smbus1_master_command[0]) >> 30) & 0x1)
#define SMBUS1_MASTER_COMMANDr_MASTER_ABORTf_SET(r,f) (r).smbus1_master_command[0]=(((r).smbus1_master_command[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS1_MASTER_COMMANDr_MASTER_START_BUSY_COMMANDf_GET(r) ((((r).smbus1_master_command[0]) >> 31) & 0x1)
#define SMBUS1_MASTER_COMMANDr_MASTER_START_BUSY_COMMANDf_SET(r,f) (r).smbus1_master_command[0]=(((r).smbus1_master_command[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Master_Command.
 */
#define READ_SMBUS1_MASTER_COMMANDr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_MASTER_COMMANDr_OFFSET,r._smbus1_master_command)
#define WRITE_SMBUS1_MASTER_COMMANDr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_MASTER_COMMANDr_OFFSET,r._smbus1_master_command)

/*******************************************************************************
 * End of 'SMBUS1_MASTER_COMMANDr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Master_Data_Read
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_MASTER_DATA_READr_OFFSET 0x03223044

#define SMBUS1_MASTER_DATA_READr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Master_Data_Read.
 */
typedef union SMBUS1_MASTER_DATA_READr_s {
    uint32_t v[1];
    uint32_t smbus1_master_data_read[1];
    uint32_t _smbus1_master_data_read;
} SMBUS1_MASTER_DATA_READr_t;

#define SMBUS1_MASTER_DATA_READr_CLR(r) (r).smbus1_master_data_read[0] = 0
#define SMBUS1_MASTER_DATA_READr_SET(r,d) (r).smbus1_master_data_read[0] = d
#define SMBUS1_MASTER_DATA_READr_GET(r) (r).smbus1_master_data_read[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_MASTER_DATA_READr_MASTER_SMBUS_RD_DATAf_GET(r) (((r).smbus1_master_data_read[0]) & 0xff)
#define SMBUS1_MASTER_DATA_READr_MASTER_SMBUS_RD_DATAf_SET(r,f) (r).smbus1_master_data_read[0]=(((r).smbus1_master_data_read[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS1_MASTER_DATA_READr_PEC_ERRf_GET(r) ((((r).smbus1_master_data_read[0]) >> 29) & 0x1)
#define SMBUS1_MASTER_DATA_READr_PEC_ERRf_SET(r,f) (r).smbus1_master_data_read[0]=(((r).smbus1_master_data_read[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS1_MASTER_DATA_READr_MASTER_RD_STATUSf_GET(r) ((((r).smbus1_master_data_read[0]) >> 30) & 0x3)
#define SMBUS1_MASTER_DATA_READr_MASTER_RD_STATUSf_SET(r,f) (r).smbus1_master_data_read[0]=(((r).smbus1_master_data_read[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access SMBus1_Master_Data_Read.
 */
#define READ_SMBUS1_MASTER_DATA_READr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_MASTER_DATA_READr_OFFSET,r._smbus1_master_data_read)
#define WRITE_SMBUS1_MASTER_DATA_READr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_MASTER_DATA_READr_OFFSET,r._smbus1_master_data_read)

/*******************************************************************************
 * End of 'SMBUS1_MASTER_DATA_READr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Master_Data_Write
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_MASTER_DATA_WRITEr_OFFSET 0x03223040

#define SMBUS1_MASTER_DATA_WRITEr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Master_Data_Write.
 */
typedef union SMBUS1_MASTER_DATA_WRITEr_s {
    uint32_t v[1];
    uint32_t smbus1_master_data_write[1];
    uint32_t _smbus1_master_data_write;
} SMBUS1_MASTER_DATA_WRITEr_t;

#define SMBUS1_MASTER_DATA_WRITEr_CLR(r) (r).smbus1_master_data_write[0] = 0
#define SMBUS1_MASTER_DATA_WRITEr_SET(r,d) (r).smbus1_master_data_write[0] = d
#define SMBUS1_MASTER_DATA_WRITEr_GET(r) (r).smbus1_master_data_write[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_MASTER_DATA_WRITEr_MASTER_SMBUS_WR_DATAf_GET(r) (((r).smbus1_master_data_write[0]) & 0xff)
#define SMBUS1_MASTER_DATA_WRITEr_MASTER_SMBUS_WR_DATAf_SET(r,f) (r).smbus1_master_data_write[0]=(((r).smbus1_master_data_write[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS1_MASTER_DATA_WRITEr_MASTER_WR_STATUSf_GET(r) ((((r).smbus1_master_data_write[0]) >> 31) & 0x1)
#define SMBUS1_MASTER_DATA_WRITEr_MASTER_WR_STATUSf_SET(r,f) (r).smbus1_master_data_write[0]=(((r).smbus1_master_data_write[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Master_Data_Write.
 */
#define READ_SMBUS1_MASTER_DATA_WRITEr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_MASTER_DATA_WRITEr_OFFSET,r._smbus1_master_data_write)
#define WRITE_SMBUS1_MASTER_DATA_WRITEr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_MASTER_DATA_WRITEr_OFFSET,r._smbus1_master_data_write)

/*******************************************************************************
 * End of 'SMBUS1_MASTER_DATA_WRITEr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Master_FIFO_control
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_MASTER_FIFO_CONTROLr_OFFSET 0x0322300c

#define SMBUS1_MASTER_FIFO_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Master_FIFO_control.
 */
typedef union SMBUS1_MASTER_FIFO_CONTROLr_s {
    uint32_t v[1];
    uint32_t smbus1_master_fifo_control[1];
    uint32_t _smbus1_master_fifo_control;
} SMBUS1_MASTER_FIFO_CONTROLr_t;

#define SMBUS1_MASTER_FIFO_CONTROLr_CLR(r) (r).smbus1_master_fifo_control[0] = 0
#define SMBUS1_MASTER_FIFO_CONTROLr_SET(r,d) (r).smbus1_master_fifo_control[0] = d
#define SMBUS1_MASTER_FIFO_CONTROLr_GET(r) (r).smbus1_master_fifo_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_THRESHOLDf_GET(r) ((((r).smbus1_master_fifo_control[0]) >> 8) & 0x3f)
#define SMBUS1_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_THRESHOLDf_SET(r,f) (r).smbus1_master_fifo_control[0]=(((r).smbus1_master_fifo_control[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define SMBUS1_MASTER_FIFO_CONTROLr_MASTER_RX_PKT_COUNTf_GET(r) ((((r).smbus1_master_fifo_control[0]) >> 16) & 0x7f)
#define SMBUS1_MASTER_FIFO_CONTROLr_MASTER_RX_PKT_COUNTf_SET(r,f) (r).smbus1_master_fifo_control[0]=(((r).smbus1_master_fifo_control[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define SMBUS1_MASTER_FIFO_CONTROLr_MASTER_TX_FIFO_FLUSHf_GET(r) ((((r).smbus1_master_fifo_control[0]) >> 30) & 0x1)
#define SMBUS1_MASTER_FIFO_CONTROLr_MASTER_TX_FIFO_FLUSHf_SET(r,f) (r).smbus1_master_fifo_control[0]=(((r).smbus1_master_fifo_control[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS1_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_FLUSHf_GET(r) ((((r).smbus1_master_fifo_control[0]) >> 31) & 0x1)
#define SMBUS1_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_FLUSHf_SET(r,f) (r).smbus1_master_fifo_control[0]=(((r).smbus1_master_fifo_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Master_FIFO_control.
 */
#define READ_SMBUS1_MASTER_FIFO_CONTROLr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_MASTER_FIFO_CONTROLr_OFFSET,r._smbus1_master_fifo_control)
#define WRITE_SMBUS1_MASTER_FIFO_CONTROLr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_MASTER_FIFO_CONTROLr_OFFSET,r._smbus1_master_fifo_control)

/*******************************************************************************
 * End of 'SMBUS1_MASTER_FIFO_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Slave_Command
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_SLAVE_COMMANDr_OFFSET 0x03223034

#define SMBUS1_SLAVE_COMMANDr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Slave_Command.
 */
typedef union SMBUS1_SLAVE_COMMANDr_s {
    uint32_t v[1];
    uint32_t smbus1_slave_command[1];
    uint32_t _smbus1_slave_command;
} SMBUS1_SLAVE_COMMANDr_t;

#define SMBUS1_SLAVE_COMMANDr_CLR(r) (r).smbus1_slave_command[0] = 0
#define SMBUS1_SLAVE_COMMANDr_SET(r,d) (r).smbus1_slave_command[0] = d
#define SMBUS1_SLAVE_COMMANDr_GET(r) (r).smbus1_slave_command[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_SLAVE_COMMANDr_SLAVE_PECf_GET(r) ((((r).smbus1_slave_command[0]) >> 8) & 0x1)
#define SMBUS1_SLAVE_COMMANDr_SLAVE_PECf_SET(r,f) (r).smbus1_slave_command[0]=(((r).smbus1_slave_command[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define SMBUS1_SLAVE_COMMANDr_SLAVE_STATUSf_GET(r) ((((r).smbus1_slave_command[0]) >> 23) & 0x7)
#define SMBUS1_SLAVE_COMMANDr_SLAVE_STATUSf_SET(r,f) (r).smbus1_slave_command[0]=(((r).smbus1_slave_command[0] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define SMBUS1_SLAVE_COMMANDr_SLAVE_ABORTf_GET(r) ((((r).smbus1_slave_command[0]) >> 30) & 0x1)
#define SMBUS1_SLAVE_COMMANDr_SLAVE_ABORTf_SET(r,f) (r).smbus1_slave_command[0]=(((r).smbus1_slave_command[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS1_SLAVE_COMMANDr_SLAVE_START_BUSY_COMMANDf_GET(r) ((((r).smbus1_slave_command[0]) >> 31) & 0x1)
#define SMBUS1_SLAVE_COMMANDr_SLAVE_START_BUSY_COMMANDf_SET(r,f) (r).smbus1_slave_command[0]=(((r).smbus1_slave_command[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Slave_Command.
 */
#define READ_SMBUS1_SLAVE_COMMANDr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_SLAVE_COMMANDr_OFFSET,r._smbus1_slave_command)
#define WRITE_SMBUS1_SLAVE_COMMANDr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_SLAVE_COMMANDr_OFFSET,r._smbus1_slave_command)

/*******************************************************************************
 * End of 'SMBUS1_SLAVE_COMMANDr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Slave_Data_Read
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_SLAVE_DATA_READr_OFFSET 0x0322304c

#define SMBUS1_SLAVE_DATA_READr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Slave_Data_Read.
 */
typedef union SMBUS1_SLAVE_DATA_READr_s {
    uint32_t v[1];
    uint32_t smbus1_slave_data_read[1];
    uint32_t _smbus1_slave_data_read;
} SMBUS1_SLAVE_DATA_READr_t;

#define SMBUS1_SLAVE_DATA_READr_CLR(r) (r).smbus1_slave_data_read[0] = 0
#define SMBUS1_SLAVE_DATA_READr_SET(r,d) (r).smbus1_slave_data_read[0] = d
#define SMBUS1_SLAVE_DATA_READr_GET(r) (r).smbus1_slave_data_read[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_SLAVE_DATA_READr_SLAVE_SMBUS_RD_DATAf_GET(r) (((r).smbus1_slave_data_read[0]) & 0xff)
#define SMBUS1_SLAVE_DATA_READr_SLAVE_SMBUS_RD_DATAf_SET(r,f) (r).smbus1_slave_data_read[0]=(((r).smbus1_slave_data_read[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS1_SLAVE_DATA_READr_ERR_STATUSf_GET(r) ((((r).smbus1_slave_data_read[0]) >> 28) & 0x3)
#define SMBUS1_SLAVE_DATA_READr_ERR_STATUSf_SET(r,f) (r).smbus1_slave_data_read[0]=(((r).smbus1_slave_data_read[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define SMBUS1_SLAVE_DATA_READr_SLAVE_RD_STATUSf_GET(r) ((((r).smbus1_slave_data_read[0]) >> 30) & 0x3)
#define SMBUS1_SLAVE_DATA_READr_SLAVE_RD_STATUSf_SET(r,f) (r).smbus1_slave_data_read[0]=(((r).smbus1_slave_data_read[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access SMBus1_Slave_Data_Read.
 */
#define READ_SMBUS1_SLAVE_DATA_READr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_SLAVE_DATA_READr_OFFSET,r._smbus1_slave_data_read)
#define WRITE_SMBUS1_SLAVE_DATA_READr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_SLAVE_DATA_READr_OFFSET,r._smbus1_slave_data_read)

/*******************************************************************************
 * End of 'SMBUS1_SLAVE_DATA_READr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Slave_Data_Write
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_SLAVE_DATA_WRITEr_OFFSET 0x03223048

#define SMBUS1_SLAVE_DATA_WRITEr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Slave_Data_Write.
 */
typedef union SMBUS1_SLAVE_DATA_WRITEr_s {
    uint32_t v[1];
    uint32_t smbus1_slave_data_write[1];
    uint32_t _smbus1_slave_data_write;
} SMBUS1_SLAVE_DATA_WRITEr_t;

#define SMBUS1_SLAVE_DATA_WRITEr_CLR(r) (r).smbus1_slave_data_write[0] = 0
#define SMBUS1_SLAVE_DATA_WRITEr_SET(r,d) (r).smbus1_slave_data_write[0] = d
#define SMBUS1_SLAVE_DATA_WRITEr_GET(r) (r).smbus1_slave_data_write[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_SLAVE_DATA_WRITEr_SLAVE_SMBUS_WR_DATAf_GET(r) (((r).smbus1_slave_data_write[0]) & 0xff)
#define SMBUS1_SLAVE_DATA_WRITEr_SLAVE_SMBUS_WR_DATAf_SET(r,f) (r).smbus1_slave_data_write[0]=(((r).smbus1_slave_data_write[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS1_SLAVE_DATA_WRITEr_SLAVE_WR_STATUSf_GET(r) ((((r).smbus1_slave_data_write[0]) >> 31) & 0x1)
#define SMBUS1_SLAVE_DATA_WRITEr_SLAVE_WR_STATUSf_SET(r,f) (r).smbus1_slave_data_write[0]=(((r).smbus1_slave_data_write[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Slave_Data_Write.
 */
#define READ_SMBUS1_SLAVE_DATA_WRITEr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_SLAVE_DATA_WRITEr_OFFSET,r._smbus1_slave_data_write)
#define WRITE_SMBUS1_SLAVE_DATA_WRITEr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_SLAVE_DATA_WRITEr_OFFSET,r._smbus1_slave_data_write)

/*******************************************************************************
 * End of 'SMBUS1_SLAVE_DATA_WRITEr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Slave_FIFO_control
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_SLAVE_FIFO_CONTROLr_OFFSET 0x03223010

#define SMBUS1_SLAVE_FIFO_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Slave_FIFO_control.
 */
typedef union SMBUS1_SLAVE_FIFO_CONTROLr_s {
    uint32_t v[1];
    uint32_t smbus1_slave_fifo_control[1];
    uint32_t _smbus1_slave_fifo_control;
} SMBUS1_SLAVE_FIFO_CONTROLr_t;

#define SMBUS1_SLAVE_FIFO_CONTROLr_CLR(r) (r).smbus1_slave_fifo_control[0] = 0
#define SMBUS1_SLAVE_FIFO_CONTROLr_SET(r,d) (r).smbus1_slave_fifo_control[0] = d
#define SMBUS1_SLAVE_FIFO_CONTROLr_GET(r) (r).smbus1_slave_fifo_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_THRESHOLDf_GET(r) ((((r).smbus1_slave_fifo_control[0]) >> 8) & 0x3f)
#define SMBUS1_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_THRESHOLDf_SET(r,f) (r).smbus1_slave_fifo_control[0]=(((r).smbus1_slave_fifo_control[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define SMBUS1_SLAVE_FIFO_CONTROLr_SLAVE_RX_PKT_COUNTf_GET(r) ((((r).smbus1_slave_fifo_control[0]) >> 16) & 0x7f)
#define SMBUS1_SLAVE_FIFO_CONTROLr_SLAVE_RX_PKT_COUNTf_SET(r,f) (r).smbus1_slave_fifo_control[0]=(((r).smbus1_slave_fifo_control[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define SMBUS1_SLAVE_FIFO_CONTROLr_SLAVE_TX_FIFO_FLUSHf_GET(r) ((((r).smbus1_slave_fifo_control[0]) >> 30) & 0x1)
#define SMBUS1_SLAVE_FIFO_CONTROLr_SLAVE_TX_FIFO_FLUSHf_SET(r,f) (r).smbus1_slave_fifo_control[0]=(((r).smbus1_slave_fifo_control[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS1_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_FLUSHf_GET(r) ((((r).smbus1_slave_fifo_control[0]) >> 31) & 0x1)
#define SMBUS1_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_FLUSHf_SET(r,f) (r).smbus1_slave_fifo_control[0]=(((r).smbus1_slave_fifo_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Slave_FIFO_control.
 */
#define READ_SMBUS1_SLAVE_FIFO_CONTROLr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_SLAVE_FIFO_CONTROLr_OFFSET,r._smbus1_slave_fifo_control)
#define WRITE_SMBUS1_SLAVE_FIFO_CONTROLr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_SLAVE_FIFO_CONTROLr_OFFSET,r._smbus1_slave_fifo_control)

/*******************************************************************************
 * End of 'SMBUS1_SLAVE_FIFO_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Timing_Config
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_TIMING_CONFIGr_OFFSET 0x03223004

#define SMBUS1_TIMING_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Timing_Config.
 */
typedef union SMBUS1_TIMING_CONFIGr_s {
    uint32_t v[1];
    uint32_t smbus1_timing_config[1];
    uint32_t _smbus1_timing_config;
} SMBUS1_TIMING_CONFIGr_t;

#define SMBUS1_TIMING_CONFIGr_CLR(r) (r).smbus1_timing_config[0] = 0
#define SMBUS1_TIMING_CONFIGr_SET(r,d) (r).smbus1_timing_config[0] = d
#define SMBUS1_TIMING_CONFIGr_GET(r) (r).smbus1_timing_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_TIMING_CONFIGr_SMBUS_IDLE_TIMEf_GET(r) ((((r).smbus1_timing_config[0]) >> 8) & 0xff)
#define SMBUS1_TIMING_CONFIGr_SMBUS_IDLE_TIMEf_SET(r,f) (r).smbus1_timing_config[0]=(((r).smbus1_timing_config[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define SMBUS1_TIMING_CONFIGr_PERIODIC_SLAVE_STRETCHf_GET(r) ((((r).smbus1_timing_config[0]) >> 16) & 0xff)
#define SMBUS1_TIMING_CONFIGr_PERIODIC_SLAVE_STRETCHf_SET(r,f) (r).smbus1_timing_config[0]=(((r).smbus1_timing_config[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define SMBUS1_TIMING_CONFIGr_RANDOM_SLAVE_STRETCHf_GET(r) ((((r).smbus1_timing_config[0]) >> 24) & 0x7f)
#define SMBUS1_TIMING_CONFIGr_RANDOM_SLAVE_STRETCHf_SET(r,f) (r).smbus1_timing_config[0]=(((r).smbus1_timing_config[0] & ~((uint32_t)0x7f << 24)) | ((((uint32_t)f) & 0x7f) << 24))
#define SMBUS1_TIMING_CONFIGr_MODE_400f_GET(r) ((((r).smbus1_timing_config[0]) >> 31) & 0x1)
#define SMBUS1_TIMING_CONFIGr_MODE_400f_SET(r,f) (r).smbus1_timing_config[0]=(((r).smbus1_timing_config[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBus1_Timing_Config.
 */
#define READ_SMBUS1_TIMING_CONFIGr(u,r) BCMDRD_IPROC_READ(u,SMBUS1_TIMING_CONFIGr_OFFSET,r._smbus1_timing_config)
#define WRITE_SMBUS1_TIMING_CONFIGr(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_TIMING_CONFIGr_OFFSET,r._smbus1_timing_config)

/*******************************************************************************
 * End of 'SMBUS1_TIMING_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  SMBus1_Timing_Config_2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS1_TIMING_CONFIG_2r_OFFSET 0x032230b0

#define SMBUS1_TIMING_CONFIG_2r_SIZE 4

/*
 * This structure should be used to declare and program SMBus1_Timing_Config_2.
 */
typedef union SMBUS1_TIMING_CONFIG_2r_s {
    uint32_t v[1];
    uint32_t smbus1_timing_config_2[1];
    uint32_t _smbus1_timing_config_2;
} SMBUS1_TIMING_CONFIG_2r_t;

#define SMBUS1_TIMING_CONFIG_2r_CLR(r) (r).smbus1_timing_config_2[0] = 0
#define SMBUS1_TIMING_CONFIG_2r_SET(r,d) (r).smbus1_timing_config_2[0] = d
#define SMBUS1_TIMING_CONFIG_2r_GET(r) (r).smbus1_timing_config_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS1_TIMING_CONFIG_2r_TIMING_TLOW_100KHZf_GET(r) (((r).smbus1_timing_config_2[0]) & 0xff)
#define SMBUS1_TIMING_CONFIG_2r_TIMING_TLOW_100KHZf_SET(r,f) (r).smbus1_timing_config_2[0]=(((r).smbus1_timing_config_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS1_TIMING_CONFIG_2r_TIMING_THIGH_100KHZf_GET(r) ((((r).smbus1_timing_config_2[0]) >> 8) & 0xff)
#define SMBUS1_TIMING_CONFIG_2r_TIMING_THIGH_100KHZf_SET(r,f) (r).smbus1_timing_config_2[0]=(((r).smbus1_timing_config_2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define SMBUS1_TIMING_CONFIG_2r_TIMING_TLOW_400KHZf_GET(r) ((((r).smbus1_timing_config_2[0]) >> 16) & 0xff)
#define SMBUS1_TIMING_CONFIG_2r_TIMING_TLOW_400KHZf_SET(r,f) (r).smbus1_timing_config_2[0]=(((r).smbus1_timing_config_2[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define SMBUS1_TIMING_CONFIG_2r_TIMING_THIGH_400KHZf_GET(r) ((((r).smbus1_timing_config_2[0]) >> 24) & 0xff)
#define SMBUS1_TIMING_CONFIG_2r_TIMING_THIGH_400KHZf_SET(r,f) (r).smbus1_timing_config_2[0]=(((r).smbus1_timing_config_2[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access SMBus1_Timing_Config_2.
 */
#define READ_SMBUS1_TIMING_CONFIG_2r(u,r) BCMDRD_IPROC_READ(u,SMBUS1_TIMING_CONFIG_2r_OFFSET,r._smbus1_timing_config_2)
#define WRITE_SMBUS1_TIMING_CONFIG_2r(u,r) BCMDRD_IPROC_WRITE(u,SMBUS1_TIMING_CONFIG_2r_OFFSET,r._smbus1_timing_config_2)

/*******************************************************************************
 * End of 'SMBUS1_TIMING_CONFIG_2r'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Address
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_ADDRESSr_OFFSET 0x03222008

#define SMBUS_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Address.
 */
typedef union SMBUS_ADDRESSr_s {
    uint32_t v[1];
    uint32_t smbus_address[1];
    uint32_t _smbus_address;
} SMBUS_ADDRESSr_t;

#define SMBUS_ADDRESSr_CLR(r) (r).smbus_address[0] = 0
#define SMBUS_ADDRESSr_SET(r,d) (r).smbus_address[0] = d
#define SMBUS_ADDRESSr_GET(r) (r).smbus_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_ADDRESSr_NIC_SMB_ADDR0f_GET(r) (((r).smbus_address[0]) & 0x7f)
#define SMBUS_ADDRESSr_NIC_SMB_ADDR0f_SET(r,f) (r).smbus_address[0]=(((r).smbus_address[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define SMBUS_ADDRESSr_EN_NIC_SMB_ADDR0f_GET(r) ((((r).smbus_address[0]) >> 7) & 0x1)
#define SMBUS_ADDRESSr_EN_NIC_SMB_ADDR0f_SET(r,f) (r).smbus_address[0]=(((r).smbus_address[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define SMBUS_ADDRESSr_NIC_SMB_ADDR1f_GET(r) ((((r).smbus_address[0]) >> 8) & 0x7f)
#define SMBUS_ADDRESSr_NIC_SMB_ADDR1f_SET(r,f) (r).smbus_address[0]=(((r).smbus_address[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define SMBUS_ADDRESSr_EN_NIC_SMB_ADDR1f_GET(r) ((((r).smbus_address[0]) >> 15) & 0x1)
#define SMBUS_ADDRESSr_EN_NIC_SMB_ADDR1f_SET(r,f) (r).smbus_address[0]=(((r).smbus_address[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define SMBUS_ADDRESSr_NIC_SMB_ADDR2f_GET(r) ((((r).smbus_address[0]) >> 16) & 0x7f)
#define SMBUS_ADDRESSr_NIC_SMB_ADDR2f_SET(r,f) (r).smbus_address[0]=(((r).smbus_address[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define SMBUS_ADDRESSr_EN_NIC_SMB_ADDR2f_GET(r) ((((r).smbus_address[0]) >> 23) & 0x1)
#define SMBUS_ADDRESSr_EN_NIC_SMB_ADDR2f_SET(r,f) (r).smbus_address[0]=(((r).smbus_address[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define SMBUS_ADDRESSr_NIC_SMB_ADDR3f_GET(r) ((((r).smbus_address[0]) >> 24) & 0x7f)
#define SMBUS_ADDRESSr_NIC_SMB_ADDR3f_SET(r,f) (r).smbus_address[0]=(((r).smbus_address[0] & ~((uint32_t)0x7f << 24)) | ((((uint32_t)f) & 0x7f) << 24))
#define SMBUS_ADDRESSr_EN_NIC_SMB_ADDR3f_GET(r) ((((r).smbus_address[0]) >> 31) & 0x1)
#define SMBUS_ADDRESSr_EN_NIC_SMB_ADDR3f_SET(r,f) (r).smbus_address[0]=(((r).smbus_address[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Address.
 */
#define READ_SMBUS_ADDRESSr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_ADDRESSr_OFFSET+(0x1000*(_ch)),r._smbus_address)
#define WRITE_SMBUS_ADDRESSr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_ADDRESSr_OFFSET+(0x1000*(_ch)),r._smbus_address)

/*******************************************************************************
 * End of 'SMBUS_ADDRESSr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Bit_Bang_Control
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_BIT_BANG_CONTROLr_OFFSET 0x03222014

#define SMBUS_BIT_BANG_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Bit_Bang_Control.
 */
typedef union SMBUS_BIT_BANG_CONTROLr_s {
    uint32_t v[1];
    uint32_t smbus_bit_bang_control[1];
    uint32_t _smbus_bit_bang_control;
} SMBUS_BIT_BANG_CONTROLr_t;

#define SMBUS_BIT_BANG_CONTROLr_CLR(r) (r).smbus_bit_bang_control[0] = 0
#define SMBUS_BIT_BANG_CONTROLr_SET(r,d) (r).smbus_bit_bang_control[0] = d
#define SMBUS_BIT_BANG_CONTROLr_GET(r) (r).smbus_bit_bang_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_BIT_BANG_CONTROLr_SMBDAT_OUT_ENf_GET(r) ((((r).smbus_bit_bang_control[0]) >> 28) & 0x1)
#define SMBUS_BIT_BANG_CONTROLr_SMBDAT_OUT_ENf_SET(r,f) (r).smbus_bit_bang_control[0]=(((r).smbus_bit_bang_control[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS_BIT_BANG_CONTROLr_SMBDAT_INf_GET(r) ((((r).smbus_bit_bang_control[0]) >> 29) & 0x1)
#define SMBUS_BIT_BANG_CONTROLr_SMBDAT_INf_SET(r,f) (r).smbus_bit_bang_control[0]=(((r).smbus_bit_bang_control[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS_BIT_BANG_CONTROLr_SMBCLK_OUT_ENf_GET(r) ((((r).smbus_bit_bang_control[0]) >> 30) & 0x1)
#define SMBUS_BIT_BANG_CONTROLr_SMBCLK_OUT_ENf_SET(r,f) (r).smbus_bit_bang_control[0]=(((r).smbus_bit_bang_control[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS_BIT_BANG_CONTROLr_SMBCLK_INf_GET(r) ((((r).smbus_bit_bang_control[0]) >> 31) & 0x1)
#define SMBUS_BIT_BANG_CONTROLr_SMBCLK_INf_SET(r,f) (r).smbus_bit_bang_control[0]=(((r).smbus_bit_bang_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Bit_Bang_Control.
 */
#define READ_SMBUS_BIT_BANG_CONTROLr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_BIT_BANG_CONTROLr_OFFSET+(0x1000*(_ch)),r._smbus_bit_bang_control)
#define WRITE_SMBUS_BIT_BANG_CONTROLr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_BIT_BANG_CONTROLr_OFFSET+(0x1000*(_ch)),r._smbus_bit_bang_control)

/*******************************************************************************
 * End of 'SMBUS_BIT_BANG_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Config
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_CONFIGr_OFFSET 0x03222000

#define SMBUS_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Config.
 */
typedef union SMBUS_CONFIGr_s {
    uint32_t v[1];
    uint32_t smbus_config[1];
    uint32_t _smbus_config;
} SMBUS_CONFIGr_t;

#define SMBUS_CONFIGr_CLR(r) (r).smbus_config[0] = 0
#define SMBUS_CONFIGr_SET(r,d) (r).smbus_config[0] = d
#define SMBUS_CONFIGr_GET(r) (r).smbus_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_CONFIGr_MASTER_RTRY_CNTf_GET(r) ((((r).smbus_config[0]) >> 16) & 0xf)
#define SMBUS_CONFIGr_MASTER_RTRY_CNTf_SET(r,f) (r).smbus_config[0]=(((r).smbus_config[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define SMBUS_CONFIGr_TIMESTAMP_CNT_ENf_GET(r) ((((r).smbus_config[0]) >> 26) & 0x1)
#define SMBUS_CONFIGr_TIMESTAMP_CNT_ENf_SET(r,f) (r).smbus_config[0]=(((r).smbus_config[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define SMBUS_CONFIGr_PROMISCOUS_MODEf_GET(r) ((((r).smbus_config[0]) >> 27) & 0x1)
#define SMBUS_CONFIGr_PROMISCOUS_MODEf_SET(r,f) (r).smbus_config[0]=(((r).smbus_config[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define SMBUS_CONFIGr_EN_NIC_SMB_ADDR_0f_GET(r) ((((r).smbus_config[0]) >> 28) & 0x1)
#define SMBUS_CONFIGr_EN_NIC_SMB_ADDR_0f_SET(r,f) (r).smbus_config[0]=(((r).smbus_config[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS_CONFIGr_BIT_BANG_ENf_GET(r) ((((r).smbus_config[0]) >> 29) & 0x1)
#define SMBUS_CONFIGr_BIT_BANG_ENf_SET(r,f) (r).smbus_config[0]=(((r).smbus_config[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS_CONFIGr_SMB_ENf_GET(r) ((((r).smbus_config[0]) >> 30) & 0x1)
#define SMBUS_CONFIGr_SMB_ENf_SET(r,f) (r).smbus_config[0]=(((r).smbus_config[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS_CONFIGr_RESETf_GET(r) ((((r).smbus_config[0]) >> 31) & 0x1)
#define SMBUS_CONFIGr_RESETf_SET(r,f) (r).smbus_config[0]=(((r).smbus_config[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Config.
 */
#define READ_SMBUS_CONFIGr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_CONFIGr_OFFSET+(0x1000*(_ch)),r._smbus_config)
#define WRITE_SMBUS_CONFIGr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_CONFIGr_OFFSET+(0x1000*(_ch)),r._smbus_config)

/*******************************************************************************
 * End of 'SMBUS_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Event_Enable
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_EVENT_ENABLEr_OFFSET 0x03222038

#define SMBUS_EVENT_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Event_Enable.
 */
typedef union SMBUS_EVENT_ENABLEr_s {
    uint32_t v[1];
    uint32_t smbus_event_enable[1];
    uint32_t _smbus_event_enable;
} SMBUS_EVENT_ENABLEr_t;

#define SMBUS_EVENT_ENABLEr_CLR(r) (r).smbus_event_enable[0] = 0
#define SMBUS_EVENT_ENABLEr_SET(r,d) (r).smbus_event_enable[0] = d
#define SMBUS_EVENT_ENABLEr_GET(r) (r).smbus_event_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_EVENT_ENABLEr_SLAVE_RD_EVENT_ENf_GET(r) ((((r).smbus_event_enable[0]) >> 21) & 0x1)
#define SMBUS_EVENT_ENABLEr_SLAVE_RD_EVENT_ENf_SET(r,f) (r).smbus_event_enable[0]=(((r).smbus_event_enable[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define SMBUS_EVENT_ENABLEr_SLAVE_TX_UNDERRUN_ENf_GET(r) ((((r).smbus_event_enable[0]) >> 22) & 0x1)
#define SMBUS_EVENT_ENABLEr_SLAVE_TX_UNDERRUN_ENf_SET(r,f) (r).smbus_event_enable[0]=(((r).smbus_event_enable[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define SMBUS_EVENT_ENABLEr_SLAVE_START_BUSY_ENf_GET(r) ((((r).smbus_event_enable[0]) >> 23) & 0x1)
#define SMBUS_EVENT_ENABLEr_SLAVE_START_BUSY_ENf_SET(r,f) (r).smbus_event_enable[0]=(((r).smbus_event_enable[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define SMBUS_EVENT_ENABLEr_SLAVE_RX_EVENT_ENf_GET(r) ((((r).smbus_event_enable[0]) >> 24) & 0x1)
#define SMBUS_EVENT_ENABLEr_SLAVE_RX_EVENT_ENf_SET(r,f) (r).smbus_event_enable[0]=(((r).smbus_event_enable[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define SMBUS_EVENT_ENABLEr_SLAVE_RX_THRESHOLD_HIT_ENf_GET(r) ((((r).smbus_event_enable[0]) >> 25) & 0x1)
#define SMBUS_EVENT_ENABLEr_SLAVE_RX_THRESHOLD_HIT_ENf_SET(r,f) (r).smbus_event_enable[0]=(((r).smbus_event_enable[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define SMBUS_EVENT_ENABLEr_SLAVE_RX_FIFO_FULL_ENf_GET(r) ((((r).smbus_event_enable[0]) >> 26) & 0x1)
#define SMBUS_EVENT_ENABLEr_SLAVE_RX_FIFO_FULL_ENf_SET(r,f) (r).smbus_event_enable[0]=(((r).smbus_event_enable[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define SMBUS_EVENT_ENABLEr_MASTER_TX_UNDERRUN_ENf_GET(r) ((((r).smbus_event_enable[0]) >> 27) & 0x1)
#define SMBUS_EVENT_ENABLEr_MASTER_TX_UNDERRUN_ENf_SET(r,f) (r).smbus_event_enable[0]=(((r).smbus_event_enable[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define SMBUS_EVENT_ENABLEr_MASTER_START_BUSY_ENf_GET(r) ((((r).smbus_event_enable[0]) >> 28) & 0x1)
#define SMBUS_EVENT_ENABLEr_MASTER_START_BUSY_ENf_SET(r,f) (r).smbus_event_enable[0]=(((r).smbus_event_enable[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS_EVENT_ENABLEr_MASTER_RX_EVENT_ENf_GET(r) ((((r).smbus_event_enable[0]) >> 29) & 0x1)
#define SMBUS_EVENT_ENABLEr_MASTER_RX_EVENT_ENf_SET(r,f) (r).smbus_event_enable[0]=(((r).smbus_event_enable[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS_EVENT_ENABLEr_MASTER_RX_THRESHOLD_HIT_ENf_GET(r) ((((r).smbus_event_enable[0]) >> 30) & 0x1)
#define SMBUS_EVENT_ENABLEr_MASTER_RX_THRESHOLD_HIT_ENf_SET(r,f) (r).smbus_event_enable[0]=(((r).smbus_event_enable[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS_EVENT_ENABLEr_MASTER_RX_FIFO_FULL_ENf_GET(r) ((((r).smbus_event_enable[0]) >> 31) & 0x1)
#define SMBUS_EVENT_ENABLEr_MASTER_RX_FIFO_FULL_ENf_SET(r,f) (r).smbus_event_enable[0]=(((r).smbus_event_enable[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Event_Enable.
 */
#define READ_SMBUS_EVENT_ENABLEr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_EVENT_ENABLEr_OFFSET+(0x1000*(_ch)),r._smbus_event_enable)
#define WRITE_SMBUS_EVENT_ENABLEr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_EVENT_ENABLEr_OFFSET+(0x1000*(_ch)),r._smbus_event_enable)

/*******************************************************************************
 * End of 'SMBUS_EVENT_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Event_Status
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_EVENT_STATUSr_OFFSET 0x0322203c

#define SMBUS_EVENT_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Event_Status.
 */
typedef union SMBUS_EVENT_STATUSr_s {
    uint32_t v[1];
    uint32_t smbus_event_status[1];
    uint32_t _smbus_event_status;
} SMBUS_EVENT_STATUSr_t;

#define SMBUS_EVENT_STATUSr_CLR(r) (r).smbus_event_status[0] = 0
#define SMBUS_EVENT_STATUSr_SET(r,d) (r).smbus_event_status[0] = d
#define SMBUS_EVENT_STATUSr_GET(r) (r).smbus_event_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_EVENT_STATUSr_SLAVE_RD_EVENT_ENf_GET(r) ((((r).smbus_event_status[0]) >> 21) & 0x1)
#define SMBUS_EVENT_STATUSr_SLAVE_RD_EVENT_ENf_SET(r,f) (r).smbus_event_status[0]=(((r).smbus_event_status[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define SMBUS_EVENT_STATUSr_SLAVE_TX_UNDERRUN_ENf_GET(r) ((((r).smbus_event_status[0]) >> 22) & 0x1)
#define SMBUS_EVENT_STATUSr_SLAVE_TX_UNDERRUN_ENf_SET(r,f) (r).smbus_event_status[0]=(((r).smbus_event_status[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define SMBUS_EVENT_STATUSr_SLAVE_START_BUSYf_GET(r) ((((r).smbus_event_status[0]) >> 23) & 0x1)
#define SMBUS_EVENT_STATUSr_SLAVE_START_BUSYf_SET(r,f) (r).smbus_event_status[0]=(((r).smbus_event_status[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define SMBUS_EVENT_STATUSr_SLAVE_RX_EVENTf_GET(r) ((((r).smbus_event_status[0]) >> 24) & 0x1)
#define SMBUS_EVENT_STATUSr_SLAVE_RX_EVENTf_SET(r,f) (r).smbus_event_status[0]=(((r).smbus_event_status[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define SMBUS_EVENT_STATUSr_SLAVE_RX_THRESHOLD_HITf_GET(r) ((((r).smbus_event_status[0]) >> 25) & 0x1)
#define SMBUS_EVENT_STATUSr_SLAVE_RX_THRESHOLD_HITf_SET(r,f) (r).smbus_event_status[0]=(((r).smbus_event_status[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define SMBUS_EVENT_STATUSr_SLAVE_RX_FIFO_FULLf_GET(r) ((((r).smbus_event_status[0]) >> 26) & 0x1)
#define SMBUS_EVENT_STATUSr_SLAVE_RX_FIFO_FULLf_SET(r,f) (r).smbus_event_status[0]=(((r).smbus_event_status[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define SMBUS_EVENT_STATUSr_MASTER_TX_UNDERRUNf_GET(r) ((((r).smbus_event_status[0]) >> 27) & 0x1)
#define SMBUS_EVENT_STATUSr_MASTER_TX_UNDERRUNf_SET(r,f) (r).smbus_event_status[0]=(((r).smbus_event_status[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define SMBUS_EVENT_STATUSr_MASTER_START_BUSYf_GET(r) ((((r).smbus_event_status[0]) >> 28) & 0x1)
#define SMBUS_EVENT_STATUSr_MASTER_START_BUSYf_SET(r,f) (r).smbus_event_status[0]=(((r).smbus_event_status[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SMBUS_EVENT_STATUSr_MASTER_RX_EVENTf_GET(r) ((((r).smbus_event_status[0]) >> 29) & 0x1)
#define SMBUS_EVENT_STATUSr_MASTER_RX_EVENTf_SET(r,f) (r).smbus_event_status[0]=(((r).smbus_event_status[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS_EVENT_STATUSr_MASTER_RX_THRESHOLD_HITf_GET(r) ((((r).smbus_event_status[0]) >> 30) & 0x1)
#define SMBUS_EVENT_STATUSr_MASTER_RX_THRESHOLD_HITf_SET(r,f) (r).smbus_event_status[0]=(((r).smbus_event_status[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS_EVENT_STATUSr_MASTER_RX_FIFO_FULLf_GET(r) ((((r).smbus_event_status[0]) >> 31) & 0x1)
#define SMBUS_EVENT_STATUSr_MASTER_RX_FIFO_FULLf_SET(r,f) (r).smbus_event_status[0]=(((r).smbus_event_status[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Event_Status.
 */
#define READ_SMBUS_EVENT_STATUSr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_EVENT_STATUSr_OFFSET+(0x1000*(_ch)),r._smbus_event_status)
#define WRITE_SMBUS_EVENT_STATUSr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_EVENT_STATUSr_OFFSET+(0x1000*(_ch)),r._smbus_event_status)

/*******************************************************************************
 * End of 'SMBUS_EVENT_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Master_Command
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_MASTER_COMMANDr_OFFSET 0x03222030

#define SMBUS_MASTER_COMMANDr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Master_Command.
 */
typedef union SMBUS_MASTER_COMMANDr_s {
    uint32_t v[1];
    uint32_t smbus_master_command[1];
    uint32_t _smbus_master_command;
} SMBUS_MASTER_COMMANDr_t;

#define SMBUS_MASTER_COMMANDr_CLR(r) (r).smbus_master_command[0] = 0
#define SMBUS_MASTER_COMMANDr_SET(r,d) (r).smbus_master_command[0] = d
#define SMBUS_MASTER_COMMANDr_GET(r) (r).smbus_master_command[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_MASTER_COMMANDr_RD_BYTE_COUNTf_GET(r) (((r).smbus_master_command[0]) & 0xff)
#define SMBUS_MASTER_COMMANDr_RD_BYTE_COUNTf_SET(r,f) (r).smbus_master_command[0]=(((r).smbus_master_command[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS_MASTER_COMMANDr_MASTER_PECf_GET(r) ((((r).smbus_master_command[0]) >> 8) & 0x1)
#define SMBUS_MASTER_COMMANDr_MASTER_PECf_SET(r,f) (r).smbus_master_command[0]=(((r).smbus_master_command[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define SMBUS_MASTER_COMMANDr_SMBUS_PROTOCOLf_GET(r) ((((r).smbus_master_command[0]) >> 9) & 0xf)
#define SMBUS_MASTER_COMMANDr_SMBUS_PROTOCOLf_SET(r,f) (r).smbus_master_command[0]=(((r).smbus_master_command[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define SMBUS_MASTER_COMMANDr_MASTER_STATUSf_GET(r) ((((r).smbus_master_command[0]) >> 25) & 0x7)
#define SMBUS_MASTER_COMMANDr_MASTER_STATUSf_SET(r,f) (r).smbus_master_command[0]=(((r).smbus_master_command[0] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define SMBUS_MASTER_COMMANDr_MASTER_ABORTf_GET(r) ((((r).smbus_master_command[0]) >> 30) & 0x1)
#define SMBUS_MASTER_COMMANDr_MASTER_ABORTf_SET(r,f) (r).smbus_master_command[0]=(((r).smbus_master_command[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS_MASTER_COMMANDr_MASTER_START_BUSY_COMMANDf_GET(r) ((((r).smbus_master_command[0]) >> 31) & 0x1)
#define SMBUS_MASTER_COMMANDr_MASTER_START_BUSY_COMMANDf_SET(r,f) (r).smbus_master_command[0]=(((r).smbus_master_command[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Master_Command.
 */
#define READ_SMBUS_MASTER_COMMANDr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_MASTER_COMMANDr_OFFSET+(0x1000*(_ch)),r._smbus_master_command)
#define WRITE_SMBUS_MASTER_COMMANDr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_MASTER_COMMANDr_OFFSET+(0x1000*(_ch)),r._smbus_master_command)

/*******************************************************************************
 * End of 'SMBUS_MASTER_COMMANDr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Master_Data_Read
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_MASTER_DATA_READr_OFFSET 0x03222044

#define SMBUS_MASTER_DATA_READr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Master_Data_Read.
 */
typedef union SMBUS_MASTER_DATA_READr_s {
    uint32_t v[1];
    uint32_t smbus_master_data_read[1];
    uint32_t _smbus_master_data_read;
} SMBUS_MASTER_DATA_READr_t;

#define SMBUS_MASTER_DATA_READr_CLR(r) (r).smbus_master_data_read[0] = 0
#define SMBUS_MASTER_DATA_READr_SET(r,d) (r).smbus_master_data_read[0] = d
#define SMBUS_MASTER_DATA_READr_GET(r) (r).smbus_master_data_read[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_MASTER_DATA_READr_MASTER_SMBUS_RD_DATAf_GET(r) (((r).smbus_master_data_read[0]) & 0xff)
#define SMBUS_MASTER_DATA_READr_MASTER_SMBUS_RD_DATAf_SET(r,f) (r).smbus_master_data_read[0]=(((r).smbus_master_data_read[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS_MASTER_DATA_READr_PEC_ERRf_GET(r) ((((r).smbus_master_data_read[0]) >> 29) & 0x1)
#define SMBUS_MASTER_DATA_READr_PEC_ERRf_SET(r,f) (r).smbus_master_data_read[0]=(((r).smbus_master_data_read[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SMBUS_MASTER_DATA_READr_MASTER_RD_STATUSf_GET(r) ((((r).smbus_master_data_read[0]) >> 30) & 0x3)
#define SMBUS_MASTER_DATA_READr_MASTER_RD_STATUSf_SET(r,f) (r).smbus_master_data_read[0]=(((r).smbus_master_data_read[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access SMBUS_Master_Data_Read.
 */
#define READ_SMBUS_MASTER_DATA_READr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_MASTER_DATA_READr_OFFSET+(0x1000*(_ch)),r._smbus_master_data_read)
#define WRITE_SMBUS_MASTER_DATA_READr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_MASTER_DATA_READr_OFFSET+(0x1000*(_ch)),r._smbus_master_data_read)

/*******************************************************************************
 * End of 'SMBUS_MASTER_DATA_READr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Master_Data_Write
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_MASTER_DATA_WRITEr_OFFSET 0x03222040

#define SMBUS_MASTER_DATA_WRITEr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Master_Data_Write.
 */
typedef union SMBUS_MASTER_DATA_WRITEr_s {
    uint32_t v[1];
    uint32_t smbus_master_data_write[1];
    uint32_t _smbus_master_data_write;
} SMBUS_MASTER_DATA_WRITEr_t;

#define SMBUS_MASTER_DATA_WRITEr_CLR(r) (r).smbus_master_data_write[0] = 0
#define SMBUS_MASTER_DATA_WRITEr_SET(r,d) (r).smbus_master_data_write[0] = d
#define SMBUS_MASTER_DATA_WRITEr_GET(r) (r).smbus_master_data_write[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_MASTER_DATA_WRITEr_MASTER_SMBUS_WR_DATAf_GET(r) (((r).smbus_master_data_write[0]) & 0xff)
#define SMBUS_MASTER_DATA_WRITEr_MASTER_SMBUS_WR_DATAf_SET(r,f) (r).smbus_master_data_write[0]=(((r).smbus_master_data_write[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS_MASTER_DATA_WRITEr_MASTER_WR_STATUSf_GET(r) ((((r).smbus_master_data_write[0]) >> 31) & 0x1)
#define SMBUS_MASTER_DATA_WRITEr_MASTER_WR_STATUSf_SET(r,f) (r).smbus_master_data_write[0]=(((r).smbus_master_data_write[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Master_Data_Write.
 */
#define READ_SMBUS_MASTER_DATA_WRITEr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_MASTER_DATA_WRITEr_OFFSET+(0x1000*(_ch)),r._smbus_master_data_write)
#define WRITE_SMBUS_MASTER_DATA_WRITEr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_MASTER_DATA_WRITEr_OFFSET+(0x1000*(_ch)),r._smbus_master_data_write)

/*******************************************************************************
 * End of 'SMBUS_MASTER_DATA_WRITEr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Master_FIFO_control
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_MASTER_FIFO_CONTROLr_OFFSET 0x0322200c

#define SMBUS_MASTER_FIFO_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Master_FIFO_control.
 */
typedef union SMBUS_MASTER_FIFO_CONTROLr_s {
    uint32_t v[1];
    uint32_t smbus_master_fifo_control[1];
    uint32_t _smbus_master_fifo_control;
} SMBUS_MASTER_FIFO_CONTROLr_t;

#define SMBUS_MASTER_FIFO_CONTROLr_CLR(r) (r).smbus_master_fifo_control[0] = 0
#define SMBUS_MASTER_FIFO_CONTROLr_SET(r,d) (r).smbus_master_fifo_control[0] = d
#define SMBUS_MASTER_FIFO_CONTROLr_GET(r) (r).smbus_master_fifo_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_THRESHOLDf_GET(r) ((((r).smbus_master_fifo_control[0]) >> 8) & 0x3f)
#define SMBUS_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_THRESHOLDf_SET(r,f) (r).smbus_master_fifo_control[0]=(((r).smbus_master_fifo_control[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define SMBUS_MASTER_FIFO_CONTROLr_MASTER_RX_PKT_COUNTf_GET(r) ((((r).smbus_master_fifo_control[0]) >> 16) & 0x7f)
#define SMBUS_MASTER_FIFO_CONTROLr_MASTER_RX_PKT_COUNTf_SET(r,f) (r).smbus_master_fifo_control[0]=(((r).smbus_master_fifo_control[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define SMBUS_MASTER_FIFO_CONTROLr_MASTER_TX_FIFO_FLUSHf_GET(r) ((((r).smbus_master_fifo_control[0]) >> 30) & 0x1)
#define SMBUS_MASTER_FIFO_CONTROLr_MASTER_TX_FIFO_FLUSHf_SET(r,f) (r).smbus_master_fifo_control[0]=(((r).smbus_master_fifo_control[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_FLUSHf_GET(r) ((((r).smbus_master_fifo_control[0]) >> 31) & 0x1)
#define SMBUS_MASTER_FIFO_CONTROLr_MASTER_RX_FIFO_FLUSHf_SET(r,f) (r).smbus_master_fifo_control[0]=(((r).smbus_master_fifo_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Master_FIFO_control.
 */
#define READ_SMBUS_MASTER_FIFO_CONTROLr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_MASTER_FIFO_CONTROLr_OFFSET+(0x1000*(_ch)),r._smbus_master_fifo_control)
#define WRITE_SMBUS_MASTER_FIFO_CONTROLr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_MASTER_FIFO_CONTROLr_OFFSET+(0x1000*(_ch)),r._smbus_master_fifo_control)

/*******************************************************************************
 * End of 'SMBUS_MASTER_FIFO_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Slave_Command
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_SLAVE_COMMANDr_OFFSET 0x03222034

#define SMBUS_SLAVE_COMMANDr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Slave_Command.
 */
typedef union SMBUS_SLAVE_COMMANDr_s {
    uint32_t v[1];
    uint32_t smbus_slave_command[1];
    uint32_t _smbus_slave_command;
} SMBUS_SLAVE_COMMANDr_t;

#define SMBUS_SLAVE_COMMANDr_CLR(r) (r).smbus_slave_command[0] = 0
#define SMBUS_SLAVE_COMMANDr_SET(r,d) (r).smbus_slave_command[0] = d
#define SMBUS_SLAVE_COMMANDr_GET(r) (r).smbus_slave_command[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_SLAVE_COMMANDr_SLAVE_PECf_GET(r) ((((r).smbus_slave_command[0]) >> 8) & 0x1)
#define SMBUS_SLAVE_COMMANDr_SLAVE_PECf_SET(r,f) (r).smbus_slave_command[0]=(((r).smbus_slave_command[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define SMBUS_SLAVE_COMMANDr_SLAVE_STATUSf_GET(r) ((((r).smbus_slave_command[0]) >> 23) & 0x7)
#define SMBUS_SLAVE_COMMANDr_SLAVE_STATUSf_SET(r,f) (r).smbus_slave_command[0]=(((r).smbus_slave_command[0] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define SMBUS_SLAVE_COMMANDr_SLAVE_ABORTf_GET(r) ((((r).smbus_slave_command[0]) >> 30) & 0x1)
#define SMBUS_SLAVE_COMMANDr_SLAVE_ABORTf_SET(r,f) (r).smbus_slave_command[0]=(((r).smbus_slave_command[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS_SLAVE_COMMANDr_SLAVE_START_BUSY_COMMANDf_GET(r) ((((r).smbus_slave_command[0]) >> 31) & 0x1)
#define SMBUS_SLAVE_COMMANDr_SLAVE_START_BUSY_COMMANDf_SET(r,f) (r).smbus_slave_command[0]=(((r).smbus_slave_command[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Slave_Command.
 */
#define READ_SMBUS_SLAVE_COMMANDr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_SLAVE_COMMANDr_OFFSET+(0x1000*(_ch)),r._smbus_slave_command)
#define WRITE_SMBUS_SLAVE_COMMANDr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_SLAVE_COMMANDr_OFFSET+(0x1000*(_ch)),r._smbus_slave_command)

/*******************************************************************************
 * End of 'SMBUS_SLAVE_COMMANDr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Slave_Data_Read
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_SLAVE_DATA_READr_OFFSET 0x0322204c

#define SMBUS_SLAVE_DATA_READr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Slave_Data_Read.
 */
typedef union SMBUS_SLAVE_DATA_READr_s {
    uint32_t v[1];
    uint32_t smbus_slave_data_read[1];
    uint32_t _smbus_slave_data_read;
} SMBUS_SLAVE_DATA_READr_t;

#define SMBUS_SLAVE_DATA_READr_CLR(r) (r).smbus_slave_data_read[0] = 0
#define SMBUS_SLAVE_DATA_READr_SET(r,d) (r).smbus_slave_data_read[0] = d
#define SMBUS_SLAVE_DATA_READr_GET(r) (r).smbus_slave_data_read[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_SLAVE_DATA_READr_SLAVE_SMBUS_RD_DATAf_GET(r) (((r).smbus_slave_data_read[0]) & 0xff)
#define SMBUS_SLAVE_DATA_READr_SLAVE_SMBUS_RD_DATAf_SET(r,f) (r).smbus_slave_data_read[0]=(((r).smbus_slave_data_read[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS_SLAVE_DATA_READr_ERR_STATUSf_GET(r) ((((r).smbus_slave_data_read[0]) >> 28) & 0x3)
#define SMBUS_SLAVE_DATA_READr_ERR_STATUSf_SET(r,f) (r).smbus_slave_data_read[0]=(((r).smbus_slave_data_read[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define SMBUS_SLAVE_DATA_READr_SLAVE_RD_STATUSf_GET(r) ((((r).smbus_slave_data_read[0]) >> 30) & 0x3)
#define SMBUS_SLAVE_DATA_READr_SLAVE_RD_STATUSf_SET(r,f) (r).smbus_slave_data_read[0]=(((r).smbus_slave_data_read[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access SMBUS_Slave_Data_Read.
 */
#define READ_SMBUS_SLAVE_DATA_READr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_SLAVE_DATA_READr_OFFSET+(0x1000*(_ch)),r._smbus_slave_data_read)
#define WRITE_SMBUS_SLAVE_DATA_READr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_SLAVE_DATA_READr_OFFSET+(0x1000*(_ch)),r._smbus_slave_data_read)

/*******************************************************************************
 * End of 'SMBUS_SLAVE_DATA_READr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Slave_Data_Write
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_SLAVE_DATA_WRITEr_OFFSET 0x03222048

#define SMBUS_SLAVE_DATA_WRITEr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Slave_Data_Write.
 */
typedef union SMBUS_SLAVE_DATA_WRITEr_s {
    uint32_t v[1];
    uint32_t smbus_slave_data_write[1];
    uint32_t _smbus_slave_data_write;
} SMBUS_SLAVE_DATA_WRITEr_t;

#define SMBUS_SLAVE_DATA_WRITEr_CLR(r) (r).smbus_slave_data_write[0] = 0
#define SMBUS_SLAVE_DATA_WRITEr_SET(r,d) (r).smbus_slave_data_write[0] = d
#define SMBUS_SLAVE_DATA_WRITEr_GET(r) (r).smbus_slave_data_write[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_SLAVE_DATA_WRITEr_SLAVE_SMBUS_WR_DATAf_GET(r) (((r).smbus_slave_data_write[0]) & 0xff)
#define SMBUS_SLAVE_DATA_WRITEr_SLAVE_SMBUS_WR_DATAf_SET(r,f) (r).smbus_slave_data_write[0]=(((r).smbus_slave_data_write[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS_SLAVE_DATA_WRITEr_SLAVE_WR_STATUSf_GET(r) ((((r).smbus_slave_data_write[0]) >> 31) & 0x1)
#define SMBUS_SLAVE_DATA_WRITEr_SLAVE_WR_STATUSf_SET(r,f) (r).smbus_slave_data_write[0]=(((r).smbus_slave_data_write[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Slave_Data_Write.
 */
#define READ_SMBUS_SLAVE_DATA_WRITEr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_SLAVE_DATA_WRITEr_OFFSET+(0x1000*(_ch)),r._smbus_slave_data_write)
#define WRITE_SMBUS_SLAVE_DATA_WRITEr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_SLAVE_DATA_WRITEr_OFFSET+(0x1000*(_ch)),r._smbus_slave_data_write)

/*******************************************************************************
 * End of 'SMBUS_SLAVE_DATA_WRITEr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Slave_FIFO_control
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_SLAVE_FIFO_CONTROLr_OFFSET 0x03222010

#define SMBUS_SLAVE_FIFO_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Slave_FIFO_control.
 */
typedef union SMBUS_SLAVE_FIFO_CONTROLr_s {
    uint32_t v[1];
    uint32_t smbus_slave_fifo_control[1];
    uint32_t _smbus_slave_fifo_control;
} SMBUS_SLAVE_FIFO_CONTROLr_t;

#define SMBUS_SLAVE_FIFO_CONTROLr_CLR(r) (r).smbus_slave_fifo_control[0] = 0
#define SMBUS_SLAVE_FIFO_CONTROLr_SET(r,d) (r).smbus_slave_fifo_control[0] = d
#define SMBUS_SLAVE_FIFO_CONTROLr_GET(r) (r).smbus_slave_fifo_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_THRESHOLDf_GET(r) ((((r).smbus_slave_fifo_control[0]) >> 8) & 0x3f)
#define SMBUS_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_THRESHOLDf_SET(r,f) (r).smbus_slave_fifo_control[0]=(((r).smbus_slave_fifo_control[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define SMBUS_SLAVE_FIFO_CONTROLr_SLAVE_RX_PKT_COUNTf_GET(r) ((((r).smbus_slave_fifo_control[0]) >> 16) & 0x7f)
#define SMBUS_SLAVE_FIFO_CONTROLr_SLAVE_RX_PKT_COUNTf_SET(r,f) (r).smbus_slave_fifo_control[0]=(((r).smbus_slave_fifo_control[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define SMBUS_SLAVE_FIFO_CONTROLr_SLAVE_TX_FIFO_FLUSHf_GET(r) ((((r).smbus_slave_fifo_control[0]) >> 30) & 0x1)
#define SMBUS_SLAVE_FIFO_CONTROLr_SLAVE_TX_FIFO_FLUSHf_SET(r,f) (r).smbus_slave_fifo_control[0]=(((r).smbus_slave_fifo_control[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SMBUS_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_FLUSHf_GET(r) ((((r).smbus_slave_fifo_control[0]) >> 31) & 0x1)
#define SMBUS_SLAVE_FIFO_CONTROLr_SLAVE_RX_FIFO_FLUSHf_SET(r,f) (r).smbus_slave_fifo_control[0]=(((r).smbus_slave_fifo_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Slave_FIFO_control.
 */
#define READ_SMBUS_SLAVE_FIFO_CONTROLr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_SLAVE_FIFO_CONTROLr_OFFSET+(0x1000*(_ch)),r._smbus_slave_fifo_control)
#define WRITE_SMBUS_SLAVE_FIFO_CONTROLr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_SLAVE_FIFO_CONTROLr_OFFSET+(0x1000*(_ch)),r._smbus_slave_fifo_control)

/*******************************************************************************
 * End of 'SMBUS_SLAVE_FIFO_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Timing_Config
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_TIMING_CONFIGr_OFFSET 0x03222004

#define SMBUS_TIMING_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Timing_Config.
 */
typedef union SMBUS_TIMING_CONFIGr_s {
    uint32_t v[1];
    uint32_t smbus_timing_config[1];
    uint32_t _smbus_timing_config;
} SMBUS_TIMING_CONFIGr_t;

#define SMBUS_TIMING_CONFIGr_CLR(r) (r).smbus_timing_config[0] = 0
#define SMBUS_TIMING_CONFIGr_SET(r,d) (r).smbus_timing_config[0] = d
#define SMBUS_TIMING_CONFIGr_GET(r) (r).smbus_timing_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_TIMING_CONFIGr_SMBUS_IDLE_TIMEf_GET(r) ((((r).smbus_timing_config[0]) >> 8) & 0xff)
#define SMBUS_TIMING_CONFIGr_SMBUS_IDLE_TIMEf_SET(r,f) (r).smbus_timing_config[0]=(((r).smbus_timing_config[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define SMBUS_TIMING_CONFIGr_PERIODIC_SLAVE_STRETCHf_GET(r) ((((r).smbus_timing_config[0]) >> 16) & 0xff)
#define SMBUS_TIMING_CONFIGr_PERIODIC_SLAVE_STRETCHf_SET(r,f) (r).smbus_timing_config[0]=(((r).smbus_timing_config[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define SMBUS_TIMING_CONFIGr_RANDOM_SLAVE_STRETCHf_GET(r) ((((r).smbus_timing_config[0]) >> 24) & 0x7f)
#define SMBUS_TIMING_CONFIGr_RANDOM_SLAVE_STRETCHf_SET(r,f) (r).smbus_timing_config[0]=(((r).smbus_timing_config[0] & ~((uint32_t)0x7f << 24)) | ((((uint32_t)f) & 0x7f) << 24))
#define SMBUS_TIMING_CONFIGr_MODE_400f_GET(r) ((((r).smbus_timing_config[0]) >> 31) & 0x1)
#define SMBUS_TIMING_CONFIGr_MODE_400f_SET(r,f) (r).smbus_timing_config[0]=(((r).smbus_timing_config[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SMBUS_Timing_Config.
 */
#define READ_SMBUS_TIMING_CONFIGr(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_TIMING_CONFIGr_OFFSET+(0x1000*(_ch)),r._smbus_timing_config)
#define WRITE_SMBUS_TIMING_CONFIGr(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_TIMING_CONFIGr_OFFSET+(0x1000*(_ch)),r._smbus_timing_config)

/*******************************************************************************
 * End of 'SMBUS_TIMING_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  SMBUS_Timing_Config_2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define SMBUS_TIMING_CONFIG_2r_OFFSET 0x032220b0

#define SMBUS_TIMING_CONFIG_2r_SIZE 4

/*
 * This structure should be used to declare and program SMBUS_Timing_Config_2.
 */
typedef union SMBUS_TIMING_CONFIG_2r_s {
    uint32_t v[1];
    uint32_t smbus_timing_config_2[1];
    uint32_t _smbus_timing_config_2;
} SMBUS_TIMING_CONFIG_2r_t;

#define SMBUS_TIMING_CONFIG_2r_CLR(r) (r).smbus_timing_config_2[0] = 0
#define SMBUS_TIMING_CONFIG_2r_SET(r,d) (r).smbus_timing_config_2[0] = d
#define SMBUS_TIMING_CONFIG_2r_GET(r) (r).smbus_timing_config_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define SMBUS_TIMING_CONFIG_2r_TIMING_TLOW_100KHZf_GET(r) (((r).smbus_timing_config_2[0]) & 0xff)
#define SMBUS_TIMING_CONFIG_2r_TIMING_TLOW_100KHZf_SET(r,f) (r).smbus_timing_config_2[0]=(((r).smbus_timing_config_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SMBUS_TIMING_CONFIG_2r_TIMING_THIGH_100KHZf_GET(r) ((((r).smbus_timing_config_2[0]) >> 8) & 0xff)
#define SMBUS_TIMING_CONFIG_2r_TIMING_THIGH_100KHZf_SET(r,f) (r).smbus_timing_config_2[0]=(((r).smbus_timing_config_2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define SMBUS_TIMING_CONFIG_2r_TIMING_TLOW_400KHZf_GET(r) ((((r).smbus_timing_config_2[0]) >> 16) & 0xff)
#define SMBUS_TIMING_CONFIG_2r_TIMING_TLOW_400KHZf_SET(r,f) (r).smbus_timing_config_2[0]=(((r).smbus_timing_config_2[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define SMBUS_TIMING_CONFIG_2r_TIMING_THIGH_400KHZf_GET(r) ((((r).smbus_timing_config_2[0]) >> 24) & 0xff)
#define SMBUS_TIMING_CONFIG_2r_TIMING_THIGH_400KHZf_SET(r,f) (r).smbus_timing_config_2[0]=(((r).smbus_timing_config_2[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access SMBUS_Timing_Config_2.
 */
#define READ_SMBUS_TIMING_CONFIG_2r(u,_ch,r) BCMDRD_IPROC_READ(u,SMBUS_TIMING_CONFIG_2r_OFFSET+(0x1000*(_ch)),r._smbus_timing_config_2)
#define WRITE_SMBUS_TIMING_CONFIG_2r(u,_ch,r) BCMDRD_IPROC_WRITE(u,SMBUS_TIMING_CONFIG_2r_OFFSET+(0x1000*(_ch)),r._smbus_timing_config_2)

/*******************************************************************************
 * End of 'SMBUS_TIMING_CONFIG_2r'
 */




/*******************************************************************************
 * SWFORMAT:  TX_DCB
 * BLOCKS:
 * SIZE:     128
 */
#define TX_DCB_OFFSET 0x00000000

#define TX_DCB_BLKACC ()

#define TX_DCB_SIZE 16

/*
 * This structure should be used to declare and program TX_DCB.
 */
typedef union TX_DCB_s {
    uint32_t v[4];
    uint32_t tx_dcb[4];
    uint32_t _tx_dcb;
} TX_DCB_t;

#define TX_DCB_CLR(r) sal_memset(&((r).tx_dcb[0]), 0, sizeof(TX_DCB_t))
#define TX_DCB_SET(r,i,d) (r).tx_dcb[i] = d
#define TX_DCB_GET(r,i) (r).tx_dcb[i]

/*
 * These macros can be used to access individual fields.
 */
#define TX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).tx_dcb[3]) & 0xffff)
#define TX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define TX_DCB_DONEf_GET(r) ((((r).tx_dcb[3]) >> 31) & 0x1)
#define TX_DCB_DONEf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define TX_DCB_BYTE_COUNTf_GET(r) (((r).tx_dcb[2]) & 0xffff)
#define TX_DCB_BYTE_COUNTf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define TX_DCB_CHAINf_GET(r) ((((r).tx_dcb[2]) >> 16) & 0x1)
#define TX_DCB_CHAINf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define TX_DCB_SGf_GET(r) ((((r).tx_dcb[2]) >> 17) & 0x1)
#define TX_DCB_SGf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define TX_DCB_RELOADf_GET(r) ((((r).tx_dcb[2]) >> 18) & 0x1)
#define TX_DCB_RELOADf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define TX_DCB_HGf_GET(r) ((((r).tx_dcb[2]) >> 19) & 0x1)
#define TX_DCB_HGf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define TX_DCB_PURGEf_GET(r) ((((r).tx_dcb[2]) >> 22) & 0x1)
#define TX_DCB_PURGEf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define TX_DCB_DESC_DONE_INTRf_GET(r) ((((r).tx_dcb[2]) >> 23) & 0x1)
#define TX_DCB_DESC_DONE_INTRf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define TX_DCB_DESC_CTRL_INTRf_GET(r) ((((r).tx_dcb[2]) >> 24) & 0x1)
#define TX_DCB_DESC_CTRL_INTRf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define TX_DCB_DESC_REMAINf_GET(r) ((((r).tx_dcb[2]) >> 25) & 0xf)
#define TX_DCB_DESC_REMAINf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define TX_DCB_DESC_STAT_WR_DISABLEf_GET(r) ((((r).tx_dcb[2]) >> 29) & 0x1)
#define TX_DCB_DESC_STAT_WR_DISABLEf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define TX_DCB_ADDR_HIf_GET(r) ((r).tx_dcb[1])
#define TX_DCB_ADDR_HIf_SET(r,f) (r).tx_dcb[1]=((uint32_t)f)
#define TX_DCB_ADDR_LOf_GET(r) ((r).tx_dcb[0])
#define TX_DCB_ADDR_LOf_SET(r,f) (r).tx_dcb[0]=((uint32_t)f)

/*******************************************************************************
 * End of 'TX_DCB'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_ACCU_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_ACCU_CTRLr_OFFSET 0x0130b00c

#define U0_LED_ACCU_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_ACCU_CTRL.
 */
typedef union U0_LED_ACCU_CTRLr_s {
    uint32_t v[1];
    uint32_t u0_led_accu_ctrl[1];
    uint32_t _u0_led_accu_ctrl;
} U0_LED_ACCU_CTRLr_t;

#define U0_LED_ACCU_CTRLr_CLR(r) (r).u0_led_accu_ctrl[0] = 0
#define U0_LED_ACCU_CTRLr_SET(r,d) (r).u0_led_accu_ctrl[0] = d
#define U0_LED_ACCU_CTRLr_GET(r) (r).u0_led_accu_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_ACCU_CTRLr_LED_ACCU_ENf_GET(r) (((r).u0_led_accu_ctrl[0]) & 0x1)
#define U0_LED_ACCU_CTRLr_LED_ACCU_ENf_SET(r,f) (r).u0_led_accu_ctrl[0]=(((r).u0_led_accu_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define U0_LED_ACCU_CTRLr_PORT_ENDIANNESSf_GET(r) ((((r).u0_led_accu_ctrl[0]) >> 1) & 0x1)
#define U0_LED_ACCU_CTRLr_PORT_ENDIANNESSf_SET(r,f) (r).u0_led_accu_ctrl[0]=(((r).u0_led_accu_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define U0_LED_ACCU_CTRLr_LAST_PORTf_GET(r) ((((r).u0_led_accu_ctrl[0]) >> 2) & 0x3ff)
#define U0_LED_ACCU_CTRLr_LAST_PORTf_SET(r,f) (r).u0_led_accu_ctrl[0]=(((r).u0_led_accu_ctrl[0] & ~((uint32_t)0x3ff << 2)) | ((((uint32_t)f) & 0x3ff) << 2))
#define U0_LED_ACCU_CTRLr_USE_SW_CNFG_LINKf_GET(r) ((((r).u0_led_accu_ctrl[0]) >> 12) & 0x1)
#define U0_LED_ACCU_CTRLr_USE_SW_CNFG_LINKf_SET(r,f) (r).u0_led_accu_ctrl[0]=(((r).u0_led_accu_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access u0_LED_ACCU_CTRL.
 */
#define READ_U0_LED_ACCU_CTRLr(u,r) BCMDRD_IPROC_READ(u,U0_LED_ACCU_CTRLr_OFFSET,r._u0_led_accu_ctrl)
#define WRITE_U0_LED_ACCU_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_ACCU_CTRLr_OFFSET,r._u0_led_accu_ctrl)

/*******************************************************************************
 * End of 'U0_LED_ACCU_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_ACCU_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_ACCU_STATUSr_OFFSET 0x0130b030

#define U0_LED_ACCU_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_ACCU_STATUS.
 */
typedef union U0_LED_ACCU_STATUSr_s {
    uint32_t v[1];
    uint32_t u0_led_accu_status[1];
    uint32_t _u0_led_accu_status;
} U0_LED_ACCU_STATUSr_t;

#define U0_LED_ACCU_STATUSr_CLR(r) (r).u0_led_accu_status[0] = 0
#define U0_LED_ACCU_STATUSr_SET(r,d) (r).u0_led_accu_status[0] = d
#define U0_LED_ACCU_STATUSr_GET(r) (r).u0_led_accu_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_ACCU_STATUSr_ACCU_DONEf_GET(r) (((r).u0_led_accu_status[0]) & 0x1)
#define U0_LED_ACCU_STATUSr_ACCU_DONEf_SET(r,f) (r).u0_led_accu_status[0]=(((r).u0_led_accu_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access u0_LED_ACCU_STATUS.
 */
#define READ_U0_LED_ACCU_STATUSr(u,r) BCMDRD_IPROC_READ(u,U0_LED_ACCU_STATUSr_OFFSET,r._u0_led_accu_status)
#define WRITE_U0_LED_ACCU_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_ACCU_STATUSr_OFFSET,r._u0_led_accu_status)

/*******************************************************************************
 * End of 'U0_LED_ACCU_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_CLK_DIV_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_CLK_DIV_CTRLr_OFFSET 0x0130b014

#define U0_LED_CLK_DIV_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_CLK_DIV_CTRL.
 */
typedef union U0_LED_CLK_DIV_CTRLr_s {
    uint32_t v[1];
    uint32_t u0_led_clk_div_ctrl[1];
    uint32_t _u0_led_clk_div_ctrl;
} U0_LED_CLK_DIV_CTRLr_t;

#define U0_LED_CLK_DIV_CTRLr_CLR(r) (r).u0_led_clk_div_ctrl[0] = 0
#define U0_LED_CLK_DIV_CTRLr_SET(r,d) (r).u0_led_clk_div_ctrl[0] = d
#define U0_LED_CLK_DIV_CTRLr_GET(r) (r).u0_led_clk_div_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_CLK_DIV_CTRLr_LEDCLK_HALF_PERIODf_GET(r) (((r).u0_led_clk_div_ctrl[0]) & 0xffff)
#define U0_LED_CLK_DIV_CTRLr_LEDCLK_HALF_PERIODf_SET(r,f) (r).u0_led_clk_div_ctrl[0]=(((r).u0_led_clk_div_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access u0_LED_CLK_DIV_CTRL.
 */
#define READ_U0_LED_CLK_DIV_CTRLr(u,r) BCMDRD_IPROC_READ(u,U0_LED_CLK_DIV_CTRLr_OFFSET,r._u0_led_clk_div_ctrl)
#define WRITE_U0_LED_CLK_DIV_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_CLK_DIV_CTRLr_OFFSET,r._u0_led_clk_div_ctrl)

/*******************************************************************************
 * End of 'U0_LED_CLK_DIV_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_INTR_ENABLE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_INTR_ENABLEr_OFFSET 0x0130b038

#define U0_LED_INTR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_INTR_ENABLE.
 */
typedef union U0_LED_INTR_ENABLEr_s {
    uint32_t v[1];
    uint32_t u0_led_intr_enable[1];
    uint32_t _u0_led_intr_enable;
} U0_LED_INTR_ENABLEr_t;

#define U0_LED_INTR_ENABLEr_CLR(r) (r).u0_led_intr_enable[0] = 0
#define U0_LED_INTR_ENABLEr_SET(r,d) (r).u0_led_intr_enable[0] = d
#define U0_LED_INTR_ENABLEr_GET(r) (r).u0_led_intr_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_INTR_ENABLEr_ACCU_DONEf_GET(r) (((r).u0_led_intr_enable[0]) & 0x1)
#define U0_LED_INTR_ENABLEr_ACCU_DONEf_SET(r,f) (r).u0_led_intr_enable[0]=(((r).u0_led_intr_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define U0_LED_INTR_ENABLEr_SEND_DONEf_GET(r) ((((r).u0_led_intr_enable[0]) >> 1) & 0x1)
#define U0_LED_INTR_ENABLEr_SEND_DONEf_SET(r,f) (r).u0_led_intr_enable[0]=(((r).u0_led_intr_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define U0_LED_INTR_ENABLEr_SINGLE_BIT_ERR_BNK_0f_GET(r) ((((r).u0_led_intr_enable[0]) >> 2) & 0x1)
#define U0_LED_INTR_ENABLEr_SINGLE_BIT_ERR_BNK_0f_SET(r,f) (r).u0_led_intr_enable[0]=(((r).u0_led_intr_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define U0_LED_INTR_ENABLEr_DOUBLE_BIT_ERR_BNK_0f_GET(r) ((((r).u0_led_intr_enable[0]) >> 3) & 0x1)
#define U0_LED_INTR_ENABLEr_DOUBLE_BIT_ERR_BNK_0f_SET(r,f) (r).u0_led_intr_enable[0]=(((r).u0_led_intr_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define U0_LED_INTR_ENABLEr_SINGLE_BIT_ERR_BNK_1f_GET(r) ((((r).u0_led_intr_enable[0]) >> 4) & 0x1)
#define U0_LED_INTR_ENABLEr_SINGLE_BIT_ERR_BNK_1f_SET(r,f) (r).u0_led_intr_enable[0]=(((r).u0_led_intr_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define U0_LED_INTR_ENABLEr_DOUBLE_BIT_ERR_BNK_1f_GET(r) ((((r).u0_led_intr_enable[0]) >> 5) & 0x1)
#define U0_LED_INTR_ENABLEr_DOUBLE_BIT_ERR_BNK_1f_SET(r,f) (r).u0_led_intr_enable[0]=(((r).u0_led_intr_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access u0_LED_INTR_ENABLE.
 */
#define READ_U0_LED_INTR_ENABLEr(u,r) BCMDRD_IPROC_READ(u,U0_LED_INTR_ENABLEr_OFFSET,r._u0_led_intr_enable)
#define WRITE_U0_LED_INTR_ENABLEr(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_INTR_ENABLEr_OFFSET,r._u0_led_intr_enable)

/*******************************************************************************
 * End of 'U0_LED_INTR_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_REFRESH_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_REFRESH_CTRLr_OFFSET 0x0130b010

#define U0_LED_REFRESH_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_REFRESH_CTRL.
 */
typedef union U0_LED_REFRESH_CTRLr_s {
    uint32_t v[1];
    uint32_t u0_led_refresh_ctrl[1];
    uint32_t _u0_led_refresh_ctrl;
} U0_LED_REFRESH_CTRLr_t;

#define U0_LED_REFRESH_CTRLr_CLR(r) (r).u0_led_refresh_ctrl[0] = 0
#define U0_LED_REFRESH_CTRLr_SET(r,d) (r).u0_led_refresh_ctrl[0] = d
#define U0_LED_REFRESH_CTRLr_GET(r) (r).u0_led_refresh_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_REFRESH_CTRLr_REFRESH_CYCLE_PERIODf_GET(r) ((r).u0_led_refresh_ctrl[0])
#define U0_LED_REFRESH_CTRLr_REFRESH_CYCLE_PERIODf_SET(r,f) (r).u0_led_refresh_ctrl[0]=((uint32_t)f)

/*
 * These macros can be used to access u0_LED_REFRESH_CTRL.
 */
#define READ_U0_LED_REFRESH_CTRLr(u,r) BCMDRD_IPROC_READ(u,U0_LED_REFRESH_CTRLr_OFFSET,r._u0_led_refresh_ctrl)
#define WRITE_U0_LED_REFRESH_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_REFRESH_CTRLr_OFFSET,r._u0_led_refresh_ctrl)

/*******************************************************************************
 * End of 'U0_LED_REFRESH_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SEND_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SEND_CTRLr_OFFSET 0x0130b018

#define U0_LED_SEND_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_SEND_CTRL.
 */
typedef union U0_LED_SEND_CTRLr_s {
    uint32_t v[1];
    uint32_t u0_led_send_ctrl[1];
    uint32_t _u0_led_send_ctrl;
} U0_LED_SEND_CTRLr_t;

#define U0_LED_SEND_CTRLr_CLR(r) (r).u0_led_send_ctrl[0] = 0
#define U0_LED_SEND_CTRLr_SET(r,d) (r).u0_led_send_ctrl[0] = d
#define U0_LED_SEND_CTRLr_GET(r) (r).u0_led_send_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_SEND_CTRLr_LED_SEND_ENf_GET(r) (((r).u0_led_send_ctrl[0]) & 0x1f)
#define U0_LED_SEND_CTRLr_LED_SEND_ENf_SET(r,f) (r).u0_led_send_ctrl[0]=(((r).u0_led_send_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access u0_LED_SEND_CTRL.
 */
#define READ_U0_LED_SEND_CTRLr(u,r) BCMDRD_IPROC_READ(u,U0_LED_SEND_CTRLr_OFFSET,r._u0_led_send_ctrl)
#define WRITE_U0_LED_SEND_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_SEND_CTRLr_OFFSET,r._u0_led_send_ctrl)

/*******************************************************************************
 * End of 'U0_LED_SEND_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SEND_CTRL_0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SEND_CTRL_0r_OFFSET 0x0130b01c

#define U0_LED_SEND_CTRL_0r_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_SEND_CTRL_0.
 */
typedef union U0_LED_SEND_CTRL_0r_s {
    uint32_t v[1];
    uint32_t u0_led_send_ctrl_0[1];
    uint32_t _u0_led_send_ctrl_0;
} U0_LED_SEND_CTRL_0r_t;

#define U0_LED_SEND_CTRL_0r_CLR(r) (r).u0_led_send_ctrl_0[0] = 0
#define U0_LED_SEND_CTRL_0r_SET(r,d) (r).u0_led_send_ctrl_0[0] = d
#define U0_LED_SEND_CTRL_0r_GET(r) (r).u0_led_send_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_SEND_CTRL_0r_LED_START_ADDRf_GET(r) ((((r).u0_led_send_ctrl_0[0]) >> 1) & 0x3ff)
#define U0_LED_SEND_CTRL_0r_LED_START_ADDRf_SET(r,f) (r).u0_led_send_ctrl_0[0]=(((r).u0_led_send_ctrl_0[0] & ~((uint32_t)0x3ff << 1)) | ((((uint32_t)f) & 0x3ff) << 1))
#define U0_LED_SEND_CTRL_0r_LED_NUM_OF_LOCSf_GET(r) ((((r).u0_led_send_ctrl_0[0]) >> 11) & 0x7ff)
#define U0_LED_SEND_CTRL_0r_LED_NUM_OF_LOCSf_SET(r,f) (r).u0_led_send_ctrl_0[0]=(((r).u0_led_send_ctrl_0[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))
#define U0_LED_SEND_CTRL_0r_LED_NUM_OF_BITS_PER_LOCf_GET(r) ((((r).u0_led_send_ctrl_0[0]) >> 22) & 0x1f)
#define U0_LED_SEND_CTRL_0r_LED_NUM_OF_BITS_PER_LOCf_SET(r,f) (r).u0_led_send_ctrl_0[0]=(((r).u0_led_send_ctrl_0[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))

/*
 * These macros can be used to access u0_LED_SEND_CTRL_0.
 */
#define READ_U0_LED_SEND_CTRL_0r(u,r) BCMDRD_IPROC_READ(u,U0_LED_SEND_CTRL_0r_OFFSET,r._u0_led_send_ctrl_0)
#define WRITE_U0_LED_SEND_CTRL_0r(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_SEND_CTRL_0r_OFFSET,r._u0_led_send_ctrl_0)

/*******************************************************************************
 * End of 'U0_LED_SEND_CTRL_0r'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SEND_CTRL_1
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SEND_CTRL_1r_OFFSET 0x0130b020

#define U0_LED_SEND_CTRL_1r_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_SEND_CTRL_1.
 */
typedef union U0_LED_SEND_CTRL_1r_s {
    uint32_t v[1];
    uint32_t u0_led_send_ctrl_1[1];
    uint32_t _u0_led_send_ctrl_1;
} U0_LED_SEND_CTRL_1r_t;

#define U0_LED_SEND_CTRL_1r_CLR(r) (r).u0_led_send_ctrl_1[0] = 0
#define U0_LED_SEND_CTRL_1r_SET(r,d) (r).u0_led_send_ctrl_1[0] = d
#define U0_LED_SEND_CTRL_1r_GET(r) (r).u0_led_send_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_SEND_CTRL_1r_LED_START_ADDRf_GET(r) ((((r).u0_led_send_ctrl_1[0]) >> 1) & 0x3ff)
#define U0_LED_SEND_CTRL_1r_LED_START_ADDRf_SET(r,f) (r).u0_led_send_ctrl_1[0]=(((r).u0_led_send_ctrl_1[0] & ~((uint32_t)0x3ff << 1)) | ((((uint32_t)f) & 0x3ff) << 1))
#define U0_LED_SEND_CTRL_1r_LED_NUM_OF_LOCSf_GET(r) ((((r).u0_led_send_ctrl_1[0]) >> 11) & 0x7ff)
#define U0_LED_SEND_CTRL_1r_LED_NUM_OF_LOCSf_SET(r,f) (r).u0_led_send_ctrl_1[0]=(((r).u0_led_send_ctrl_1[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))
#define U0_LED_SEND_CTRL_1r_LED_NUM_OF_BITS_PER_LOCf_GET(r) ((((r).u0_led_send_ctrl_1[0]) >> 22) & 0x1f)
#define U0_LED_SEND_CTRL_1r_LED_NUM_OF_BITS_PER_LOCf_SET(r,f) (r).u0_led_send_ctrl_1[0]=(((r).u0_led_send_ctrl_1[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))

/*
 * These macros can be used to access u0_LED_SEND_CTRL_1.
 */
#define READ_U0_LED_SEND_CTRL_1r(u,r) BCMDRD_IPROC_READ(u,U0_LED_SEND_CTRL_1r_OFFSET,r._u0_led_send_ctrl_1)
#define WRITE_U0_LED_SEND_CTRL_1r(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_SEND_CTRL_1r_OFFSET,r._u0_led_send_ctrl_1)

/*******************************************************************************
 * End of 'U0_LED_SEND_CTRL_1r'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SEND_CTRL_2
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SEND_CTRL_2r_OFFSET 0x0130b024

#define U0_LED_SEND_CTRL_2r_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_SEND_CTRL_2.
 */
typedef union U0_LED_SEND_CTRL_2r_s {
    uint32_t v[1];
    uint32_t u0_led_send_ctrl_2[1];
    uint32_t _u0_led_send_ctrl_2;
} U0_LED_SEND_CTRL_2r_t;

#define U0_LED_SEND_CTRL_2r_CLR(r) (r).u0_led_send_ctrl_2[0] = 0
#define U0_LED_SEND_CTRL_2r_SET(r,d) (r).u0_led_send_ctrl_2[0] = d
#define U0_LED_SEND_CTRL_2r_GET(r) (r).u0_led_send_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_SEND_CTRL_2r_LED_START_ADDRf_GET(r) ((((r).u0_led_send_ctrl_2[0]) >> 1) & 0x3ff)
#define U0_LED_SEND_CTRL_2r_LED_START_ADDRf_SET(r,f) (r).u0_led_send_ctrl_2[0]=(((r).u0_led_send_ctrl_2[0] & ~((uint32_t)0x3ff << 1)) | ((((uint32_t)f) & 0x3ff) << 1))
#define U0_LED_SEND_CTRL_2r_LED_NUM_OF_LOCSf_GET(r) ((((r).u0_led_send_ctrl_2[0]) >> 11) & 0x7ff)
#define U0_LED_SEND_CTRL_2r_LED_NUM_OF_LOCSf_SET(r,f) (r).u0_led_send_ctrl_2[0]=(((r).u0_led_send_ctrl_2[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))
#define U0_LED_SEND_CTRL_2r_LED_NUM_OF_BITS_PER_LOCf_GET(r) ((((r).u0_led_send_ctrl_2[0]) >> 22) & 0x1f)
#define U0_LED_SEND_CTRL_2r_LED_NUM_OF_BITS_PER_LOCf_SET(r,f) (r).u0_led_send_ctrl_2[0]=(((r).u0_led_send_ctrl_2[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))

/*
 * These macros can be used to access u0_LED_SEND_CTRL_2.
 */
#define READ_U0_LED_SEND_CTRL_2r(u,r) BCMDRD_IPROC_READ(u,U0_LED_SEND_CTRL_2r_OFFSET,r._u0_led_send_ctrl_2)
#define WRITE_U0_LED_SEND_CTRL_2r(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_SEND_CTRL_2r_OFFSET,r._u0_led_send_ctrl_2)

/*******************************************************************************
 * End of 'U0_LED_SEND_CTRL_2r'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SEND_CTRL_3
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SEND_CTRL_3r_OFFSET 0x0130b028

#define U0_LED_SEND_CTRL_3r_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_SEND_CTRL_3.
 */
typedef union U0_LED_SEND_CTRL_3r_s {
    uint32_t v[1];
    uint32_t u0_led_send_ctrl_3[1];
    uint32_t _u0_led_send_ctrl_3;
} U0_LED_SEND_CTRL_3r_t;

#define U0_LED_SEND_CTRL_3r_CLR(r) (r).u0_led_send_ctrl_3[0] = 0
#define U0_LED_SEND_CTRL_3r_SET(r,d) (r).u0_led_send_ctrl_3[0] = d
#define U0_LED_SEND_CTRL_3r_GET(r) (r).u0_led_send_ctrl_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_SEND_CTRL_3r_LED_START_ADDRf_GET(r) ((((r).u0_led_send_ctrl_3[0]) >> 1) & 0x3ff)
#define U0_LED_SEND_CTRL_3r_LED_START_ADDRf_SET(r,f) (r).u0_led_send_ctrl_3[0]=(((r).u0_led_send_ctrl_3[0] & ~((uint32_t)0x3ff << 1)) | ((((uint32_t)f) & 0x3ff) << 1))
#define U0_LED_SEND_CTRL_3r_LED_NUM_OF_LOCSf_GET(r) ((((r).u0_led_send_ctrl_3[0]) >> 11) & 0x7ff)
#define U0_LED_SEND_CTRL_3r_LED_NUM_OF_LOCSf_SET(r,f) (r).u0_led_send_ctrl_3[0]=(((r).u0_led_send_ctrl_3[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))
#define U0_LED_SEND_CTRL_3r_LED_NUM_OF_BITS_PER_LOCf_GET(r) ((((r).u0_led_send_ctrl_3[0]) >> 22) & 0x1f)
#define U0_LED_SEND_CTRL_3r_LED_NUM_OF_BITS_PER_LOCf_SET(r,f) (r).u0_led_send_ctrl_3[0]=(((r).u0_led_send_ctrl_3[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))

/*
 * These macros can be used to access u0_LED_SEND_CTRL_3.
 */
#define READ_U0_LED_SEND_CTRL_3r(u,r) BCMDRD_IPROC_READ(u,U0_LED_SEND_CTRL_3r_OFFSET,r._u0_led_send_ctrl_3)
#define WRITE_U0_LED_SEND_CTRL_3r(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_SEND_CTRL_3r_OFFSET,r._u0_led_send_ctrl_3)

/*******************************************************************************
 * End of 'U0_LED_SEND_CTRL_3r'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SEND_CTRL_4
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SEND_CTRL_4r_OFFSET 0x0130b02c

#define U0_LED_SEND_CTRL_4r_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_SEND_CTRL_4.
 */
typedef union U0_LED_SEND_CTRL_4r_s {
    uint32_t v[1];
    uint32_t u0_led_send_ctrl_4[1];
    uint32_t _u0_led_send_ctrl_4;
} U0_LED_SEND_CTRL_4r_t;

#define U0_LED_SEND_CTRL_4r_CLR(r) (r).u0_led_send_ctrl_4[0] = 0
#define U0_LED_SEND_CTRL_4r_SET(r,d) (r).u0_led_send_ctrl_4[0] = d
#define U0_LED_SEND_CTRL_4r_GET(r) (r).u0_led_send_ctrl_4[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_SEND_CTRL_4r_LED_START_ADDRf_GET(r) ((((r).u0_led_send_ctrl_4[0]) >> 1) & 0x3ff)
#define U0_LED_SEND_CTRL_4r_LED_START_ADDRf_SET(r,f) (r).u0_led_send_ctrl_4[0]=(((r).u0_led_send_ctrl_4[0] & ~((uint32_t)0x3ff << 1)) | ((((uint32_t)f) & 0x3ff) << 1))
#define U0_LED_SEND_CTRL_4r_LED_NUM_OF_LOCSf_GET(r) ((((r).u0_led_send_ctrl_4[0]) >> 11) & 0x7ff)
#define U0_LED_SEND_CTRL_4r_LED_NUM_OF_LOCSf_SET(r,f) (r).u0_led_send_ctrl_4[0]=(((r).u0_led_send_ctrl_4[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))
#define U0_LED_SEND_CTRL_4r_LED_NUM_OF_BITS_PER_LOCf_GET(r) ((((r).u0_led_send_ctrl_4[0]) >> 22) & 0x1f)
#define U0_LED_SEND_CTRL_4r_LED_NUM_OF_BITS_PER_LOCf_SET(r,f) (r).u0_led_send_ctrl_4[0]=(((r).u0_led_send_ctrl_4[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))

/*
 * These macros can be used to access u0_LED_SEND_CTRL_4.
 */
#define READ_U0_LED_SEND_CTRL_4r(u,r) BCMDRD_IPROC_READ(u,U0_LED_SEND_CTRL_4r_OFFSET,r._u0_led_send_ctrl_4)
#define WRITE_U0_LED_SEND_CTRL_4r(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_SEND_CTRL_4r_OFFSET,r._u0_led_send_ctrl_4)

/*******************************************************************************
 * End of 'U0_LED_SEND_CTRL_4r'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SEND_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SEND_STATUSr_OFFSET 0x0130b034

#define U0_LED_SEND_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_SEND_STATUS.
 */
typedef union U0_LED_SEND_STATUSr_s {
    uint32_t v[1];
    uint32_t u0_led_send_status[1];
    uint32_t _u0_led_send_status;
} U0_LED_SEND_STATUSr_t;

#define U0_LED_SEND_STATUSr_CLR(r) (r).u0_led_send_status[0] = 0
#define U0_LED_SEND_STATUSr_SET(r,d) (r).u0_led_send_status[0] = d
#define U0_LED_SEND_STATUSr_GET(r) (r).u0_led_send_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_SEND_STATUSr_SEND_DONEf_GET(r) (((r).u0_led_send_status[0]) & 0x1)
#define U0_LED_SEND_STATUSr_SEND_DONEf_SET(r,f) (r).u0_led_send_status[0]=(((r).u0_led_send_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access u0_LED_SEND_STATUS.
 */
#define READ_U0_LED_SEND_STATUSr(u,r) BCMDRD_IPROC_READ(u,U0_LED_SEND_STATUSr_OFFSET,r._u0_led_send_status)
#define WRITE_U0_LED_SEND_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_SEND_STATUSr_OFFSET,r._u0_led_send_status)

/*******************************************************************************
 * End of 'U0_LED_SEND_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SRAM_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SRAM_CTRLr_OFFSET 0x0130b000

#define U0_LED_SRAM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_SRAM_CTRL.
 */
typedef union U0_LED_SRAM_CTRLr_s {
    uint32_t v[1];
    uint32_t u0_led_sram_ctrl[1];
    uint32_t _u0_led_sram_ctrl;
} U0_LED_SRAM_CTRLr_t;

#define U0_LED_SRAM_CTRLr_CLR(r) (r).u0_led_sram_ctrl[0] = 0
#define U0_LED_SRAM_CTRLr_SET(r,d) (r).u0_led_sram_ctrl[0] = d
#define U0_LED_SRAM_CTRLr_GET(r) (r).u0_led_sram_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_SRAM_CTRLr_LED_TMf_GET(r) (((r).u0_led_sram_ctrl[0]) & 0x7f)
#define U0_LED_SRAM_CTRLr_LED_TMf_SET(r,f) (r).u0_led_sram_ctrl[0]=(((r).u0_led_sram_ctrl[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access u0_LED_SRAM_CTRL.
 */
#define READ_U0_LED_SRAM_CTRLr(u,r) BCMDRD_IPROC_READ(u,U0_LED_SRAM_CTRLr_OFFSET,r._u0_led_sram_ctrl)
#define WRITE_U0_LED_SRAM_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_SRAM_CTRLr_OFFSET,r._u0_led_sram_ctrl)

/*******************************************************************************
 * End of 'U0_LED_SRAM_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SRAM_ECC_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SRAM_ECC_CTRLr_OFFSET 0x0130b004

#define U0_LED_SRAM_ECC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_SRAM_ECC_CTRL.
 */
typedef union U0_LED_SRAM_ECC_CTRLr_s {
    uint32_t v[1];
    uint32_t u0_led_sram_ecc_ctrl[1];
    uint32_t _u0_led_sram_ecc_ctrl;
} U0_LED_SRAM_ECC_CTRLr_t;

#define U0_LED_SRAM_ECC_CTRLr_CLR(r) (r).u0_led_sram_ecc_ctrl[0] = 0
#define U0_LED_SRAM_ECC_CTRLr_SET(r,d) (r).u0_led_sram_ecc_ctrl[0] = d
#define U0_LED_SRAM_ECC_CTRLr_GET(r) (r).u0_led_sram_ecc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_SRAM_ECC_CTRLr_LED_ECC_ENf_GET(r) (((r).u0_led_sram_ecc_ctrl[0]) & 0x3)
#define U0_LED_SRAM_ECC_CTRLr_LED_ECC_ENf_SET(r,f) (r).u0_led_sram_ecc_ctrl[0]=(((r).u0_led_sram_ecc_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define U0_LED_SRAM_ECC_CTRLr_LED_FORCE_SINGLE_BIT_ERRf_GET(r) ((((r).u0_led_sram_ecc_ctrl[0]) >> 2) & 0x3)
#define U0_LED_SRAM_ECC_CTRLr_LED_FORCE_SINGLE_BIT_ERRf_SET(r,f) (r).u0_led_sram_ecc_ctrl[0]=(((r).u0_led_sram_ecc_ctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define U0_LED_SRAM_ECC_CTRLr_LED_FORCE_DOUBLE_BIT_ERRf_GET(r) ((((r).u0_led_sram_ecc_ctrl[0]) >> 4) & 0x3)
#define U0_LED_SRAM_ECC_CTRLr_LED_FORCE_DOUBLE_BIT_ERRf_SET(r,f) (r).u0_led_sram_ecc_ctrl[0]=(((r).u0_led_sram_ecc_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))

/*
 * These macros can be used to access u0_LED_SRAM_ECC_CTRL.
 */
#define READ_U0_LED_SRAM_ECC_CTRLr(u,r) BCMDRD_IPROC_READ(u,U0_LED_SRAM_ECC_CTRLr_OFFSET,r._u0_led_sram_ecc_ctrl)
#define WRITE_U0_LED_SRAM_ECC_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_SRAM_ECC_CTRLr_OFFSET,r._u0_led_sram_ecc_ctrl)

/*******************************************************************************
 * End of 'U0_LED_SRAM_ECC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SRAM_ECC_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SRAM_ECC_STATUSr_OFFSET 0x0130b008

#define U0_LED_SRAM_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_SRAM_ECC_STATUS.
 */
typedef union U0_LED_SRAM_ECC_STATUSr_s {
    uint32_t v[1];
    uint32_t u0_led_sram_ecc_status[1];
    uint32_t _u0_led_sram_ecc_status;
} U0_LED_SRAM_ECC_STATUSr_t;

#define U0_LED_SRAM_ECC_STATUSr_CLR(r) (r).u0_led_sram_ecc_status[0] = 0
#define U0_LED_SRAM_ECC_STATUSr_SET(r,d) (r).u0_led_sram_ecc_status[0] = d
#define U0_LED_SRAM_ECC_STATUSr_GET(r) (r).u0_led_sram_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_SRAM_ECC_STATUSr_ECC_ERR_BNK_0f_GET(r) (((r).u0_led_sram_ecc_status[0]) & 0x1)
#define U0_LED_SRAM_ECC_STATUSr_ECC_ERR_BNK_0f_SET(r,f) (r).u0_led_sram_ecc_status[0]=(((r).u0_led_sram_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define U0_LED_SRAM_ECC_STATUSr_MULTIPLE_ERR_BNK_0f_GET(r) ((((r).u0_led_sram_ecc_status[0]) >> 1) & 0x1)
#define U0_LED_SRAM_ECC_STATUSr_MULTIPLE_ERR_BNK_0f_SET(r,f) (r).u0_led_sram_ecc_status[0]=(((r).u0_led_sram_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define U0_LED_SRAM_ECC_STATUSr_DOUBLE_BIT_ERR_BNK_0f_GET(r) ((((r).u0_led_sram_ecc_status[0]) >> 2) & 0x1)
#define U0_LED_SRAM_ECC_STATUSr_DOUBLE_BIT_ERR_BNK_0f_SET(r,f) (r).u0_led_sram_ecc_status[0]=(((r).u0_led_sram_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define U0_LED_SRAM_ECC_STATUSr_ENTRY_IDX_BNK_0f_GET(r) ((((r).u0_led_sram_ecc_status[0]) >> 3) & 0x3ff)
#define U0_LED_SRAM_ECC_STATUSr_ENTRY_IDX_BNK_0f_SET(r,f) (r).u0_led_sram_ecc_status[0]=(((r).u0_led_sram_ecc_status[0] & ~((uint32_t)0x3ff << 3)) | ((((uint32_t)f) & 0x3ff) << 3))
#define U0_LED_SRAM_ECC_STATUSr_ECC_ERR_BNK_1f_GET(r) ((((r).u0_led_sram_ecc_status[0]) >> 16) & 0x1)
#define U0_LED_SRAM_ECC_STATUSr_ECC_ERR_BNK_1f_SET(r,f) (r).u0_led_sram_ecc_status[0]=(((r).u0_led_sram_ecc_status[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define U0_LED_SRAM_ECC_STATUSr_MULTIPLE_ERR_BNK_1f_GET(r) ((((r).u0_led_sram_ecc_status[0]) >> 17) & 0x1)
#define U0_LED_SRAM_ECC_STATUSr_MULTIPLE_ERR_BNK_1f_SET(r,f) (r).u0_led_sram_ecc_status[0]=(((r).u0_led_sram_ecc_status[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define U0_LED_SRAM_ECC_STATUSr_DOUBLE_BIT_ERR_BNK_1f_GET(r) ((((r).u0_led_sram_ecc_status[0]) >> 18) & 0x1)
#define U0_LED_SRAM_ECC_STATUSr_DOUBLE_BIT_ERR_BNK_1f_SET(r,f) (r).u0_led_sram_ecc_status[0]=(((r).u0_led_sram_ecc_status[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define U0_LED_SRAM_ECC_STATUSr_ENTRY_IDX_BNK_1f_GET(r) ((((r).u0_led_sram_ecc_status[0]) >> 19) & 0x3ff)
#define U0_LED_SRAM_ECC_STATUSr_ENTRY_IDX_BNK_1f_SET(r,f) (r).u0_led_sram_ecc_status[0]=(((r).u0_led_sram_ecc_status[0] & ~((uint32_t)0x3ff << 19)) | ((((uint32_t)f) & 0x3ff) << 19))

/*
 * These macros can be used to access u0_LED_SRAM_ECC_STATUS.
 */
#define READ_U0_LED_SRAM_ECC_STATUSr(u,r) BCMDRD_IPROC_READ(u,U0_LED_SRAM_ECC_STATUSr_OFFSET,r._u0_led_sram_ecc_status)
#define WRITE_U0_LED_SRAM_ECC_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,U0_LED_SRAM_ECC_STATUSr_OFFSET,r._u0_led_sram_ecc_status)

/*******************************************************************************
 * End of 'U0_LED_SRAM_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINKr_OFFSET 0x0130b03c

#define U0_LED_SW_CNFG_LINKr_SIZE 4

/*
 * This structure should be used to declare and program u0_LED_SW_CNFG_LINK.
 */
typedef union U0_LED_SW_CNFG_LINKr_s {
    uint32_t v[1];
    uint32_t u0_led_sw_cnfg_link[1];
    uint32_t _u0_led_sw_cnfg_link;
} U0_LED_SW_CNFG_LINKr_t;

#define U0_LED_SW_CNFG_LINKr_CLR(r) (r).u0_led_sw_cnfg_link[0] = 0
#define U0_LED_SW_CNFG_LINKr_SET(r,d) (r).u0_led_sw_cnfg_link[0] = d
#define U0_LED_SW_CNFG_LINKr_GET(r) (r).u0_led_sw_cnfg_link[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_LED_SW_CNFG_LINKr_STATUSf_GET(r) ((r).u0_led_sw_cnfg_link[0])
#define U0_LED_SW_CNFG_LINKr_STATUSf_SET(r,f) (r).u0_led_sw_cnfg_link[0]=((uint32_t)f)

/*
 * These macros can be used to access u0_LED_SW_CNFG_LINK.
 */
#define READ_U0_LED_SW_CNFG_LINKr(u,i,r) BCMDRD_IPROC_READ(u,U0_LED_SW_CNFG_LINKr_OFFSET+(4*(i)),r._u0_led_sw_cnfg_link)
#define WRITE_U0_LED_SW_CNFG_LINKr(u,i,r) BCMDRD_IPROC_WRITE(u,U0_LED_SW_CNFG_LINKr_OFFSET+(4*(i)),r._u0_led_sw_cnfg_link)

/*******************************************************************************
 * End of 'U0_LED_SW_CNFG_LINKr'
 */




/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_1023_992
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_1023_992r_OFFSET 0x0130b0b8

#define U0_LED_SW_CNFG_LINK_1023_992r_SIZE 4

/* U0_LED_SW_CNFG_LINK_1023_992r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_127_96
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_127_96r_OFFSET 0x0130b048

#define U0_LED_SW_CNFG_LINK_127_96r_SIZE 4

/* U0_LED_SW_CNFG_LINK_127_96r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_159_128
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_159_128r_OFFSET 0x0130b04c

#define U0_LED_SW_CNFG_LINK_159_128r_SIZE 4

/* U0_LED_SW_CNFG_LINK_159_128r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_191_160
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_191_160r_OFFSET 0x0130b050

#define U0_LED_SW_CNFG_LINK_191_160r_SIZE 4

/* U0_LED_SW_CNFG_LINK_191_160r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_223_192
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_223_192r_OFFSET 0x0130b054

#define U0_LED_SW_CNFG_LINK_223_192r_SIZE 4

/* U0_LED_SW_CNFG_LINK_223_192r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_255_224
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_255_224r_OFFSET 0x0130b058

#define U0_LED_SW_CNFG_LINK_255_224r_SIZE 4

/* U0_LED_SW_CNFG_LINK_255_224r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_287_256
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_287_256r_OFFSET 0x0130b05c

#define U0_LED_SW_CNFG_LINK_287_256r_SIZE 4

/* U0_LED_SW_CNFG_LINK_287_256r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_319_288
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_319_288r_OFFSET 0x0130b060

#define U0_LED_SW_CNFG_LINK_319_288r_SIZE 4

/* U0_LED_SW_CNFG_LINK_319_288r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_31_0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_31_0r_OFFSET 0x0130b03c

#define U0_LED_SW_CNFG_LINK_31_0r_SIZE 4

/* U0_LED_SW_CNFG_LINK_31_0r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_351_320
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_351_320r_OFFSET 0x0130b064

#define U0_LED_SW_CNFG_LINK_351_320r_SIZE 4

/* U0_LED_SW_CNFG_LINK_351_320r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_383_352
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_383_352r_OFFSET 0x0130b068

#define U0_LED_SW_CNFG_LINK_383_352r_SIZE 4

/* U0_LED_SW_CNFG_LINK_383_352r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_415_384
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_415_384r_OFFSET 0x0130b06c

#define U0_LED_SW_CNFG_LINK_415_384r_SIZE 4

/* U0_LED_SW_CNFG_LINK_415_384r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_447_416
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_447_416r_OFFSET 0x0130b070

#define U0_LED_SW_CNFG_LINK_447_416r_SIZE 4

/* U0_LED_SW_CNFG_LINK_447_416r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_479_448
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_479_448r_OFFSET 0x0130b074

#define U0_LED_SW_CNFG_LINK_479_448r_SIZE 4

/* U0_LED_SW_CNFG_LINK_479_448r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_511_480
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_511_480r_OFFSET 0x0130b078

#define U0_LED_SW_CNFG_LINK_511_480r_SIZE 4

/* U0_LED_SW_CNFG_LINK_511_480r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_543_512
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_543_512r_OFFSET 0x0130b07c

#define U0_LED_SW_CNFG_LINK_543_512r_SIZE 4

/* U0_LED_SW_CNFG_LINK_543_512r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_575_544
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_575_544r_OFFSET 0x0130b080

#define U0_LED_SW_CNFG_LINK_575_544r_SIZE 4

/* U0_LED_SW_CNFG_LINK_575_544r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_607_576
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_607_576r_OFFSET 0x0130b084

#define U0_LED_SW_CNFG_LINK_607_576r_SIZE 4

/* U0_LED_SW_CNFG_LINK_607_576r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_639_608
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_639_608r_OFFSET 0x0130b088

#define U0_LED_SW_CNFG_LINK_639_608r_SIZE 4

/* U0_LED_SW_CNFG_LINK_639_608r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_63_32
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_63_32r_OFFSET 0x0130b040

#define U0_LED_SW_CNFG_LINK_63_32r_SIZE 4

/* U0_LED_SW_CNFG_LINK_63_32r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_671_640
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_671_640r_OFFSET 0x0130b08c

#define U0_LED_SW_CNFG_LINK_671_640r_SIZE 4

/* U0_LED_SW_CNFG_LINK_671_640r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_703_672
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_703_672r_OFFSET 0x0130b090

#define U0_LED_SW_CNFG_LINK_703_672r_SIZE 4

/* U0_LED_SW_CNFG_LINK_703_672r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_735_704
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_735_704r_OFFSET 0x0130b094

#define U0_LED_SW_CNFG_LINK_735_704r_SIZE 4

/* U0_LED_SW_CNFG_LINK_735_704r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_767_736
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_767_736r_OFFSET 0x0130b098

#define U0_LED_SW_CNFG_LINK_767_736r_SIZE 4

/* U0_LED_SW_CNFG_LINK_767_736r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_799_768
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_799_768r_OFFSET 0x0130b09c

#define U0_LED_SW_CNFG_LINK_799_768r_SIZE 4

/* U0_LED_SW_CNFG_LINK_799_768r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_831_800
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_831_800r_OFFSET 0x0130b0a0

#define U0_LED_SW_CNFG_LINK_831_800r_SIZE 4

/* U0_LED_SW_CNFG_LINK_831_800r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_863_832
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_863_832r_OFFSET 0x0130b0a4

#define U0_LED_SW_CNFG_LINK_863_832r_SIZE 4

/* U0_LED_SW_CNFG_LINK_863_832r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_895_864
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_895_864r_OFFSET 0x0130b0a8

#define U0_LED_SW_CNFG_LINK_895_864r_SIZE 4

/* U0_LED_SW_CNFG_LINK_895_864r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_927_896
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_927_896r_OFFSET 0x0130b0ac

#define U0_LED_SW_CNFG_LINK_927_896r_SIZE 4

/* U0_LED_SW_CNFG_LINK_927_896r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_959_928
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_959_928r_OFFSET 0x0130b0b0

#define U0_LED_SW_CNFG_LINK_959_928r_SIZE 4

/* U0_LED_SW_CNFG_LINK_959_928r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_95_64
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_95_64r_OFFSET 0x0130b044

#define U0_LED_SW_CNFG_LINK_95_64r_SIZE 4

/* U0_LED_SW_CNFG_LINK_95_64r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_LED_SW_CNFG_LINK_991_960
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_LED_SW_CNFG_LINK_991_960r_OFFSET 0x0130b0b4

#define U0_LED_SW_CNFG_LINK_991_960r_SIZE 4

/* U0_LED_SW_CNFG_LINK_991_960r is element of u0_LED_SW_CNFG_LINK */

/*******************************************************************************
 * REGISTER:  u0_M0SSQ_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_M0SSQ_CTRLr_OFFSET 0x01360000

#define U0_M0SSQ_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program u0_M0SSQ_CTRL.
 */
typedef union U0_M0SSQ_CTRLr_s {
    uint32_t v[1];
    uint32_t u0_m0ssq_ctrl[1];
    uint32_t _u0_m0ssq_ctrl;
} U0_M0SSQ_CTRLr_t;

#define U0_M0SSQ_CTRLr_CLR(r) (r).u0_m0ssq_ctrl[0] = 0
#define U0_M0SSQ_CTRLr_SET(r,d) (r).u0_m0ssq_ctrl[0] = d
#define U0_M0SSQ_CTRLr_GET(r) (r).u0_m0ssq_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_M0SSQ_CTRLr_TCM_TMf_GET(r) (((r).u0_m0ssq_ctrl[0]) & 0x7f)
#define U0_M0SSQ_CTRLr_TCM_TMf_SET(r,f) (r).u0_m0ssq_ctrl[0]=(((r).u0_m0ssq_ctrl[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define U0_M0SSQ_CTRLr_SRAM_128K_CLK_ENf_GET(r) ((((r).u0_m0ssq_ctrl[0]) >> 7) & 0x1)
#define U0_M0SSQ_CTRLr_SRAM_128K_CLK_ENf_SET(r,f) (r).u0_m0ssq_ctrl[0]=(((r).u0_m0ssq_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define U0_M0SSQ_CTRLr_M0SS_CLK_ENf_GET(r) ((((r).u0_m0ssq_ctrl[0]) >> 8) & 0xf)
#define U0_M0SSQ_CTRLr_M0SS_CLK_ENf_SET(r,f) (r).u0_m0ssq_ctrl[0]=(((r).u0_m0ssq_ctrl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define U0_M0SSQ_CTRLr_SRAM_128K_SOFT_RESETf_GET(r) ((((r).u0_m0ssq_ctrl[0]) >> 15) & 0x1)
#define U0_M0SSQ_CTRLr_SRAM_128K_SOFT_RESETf_SET(r,f) (r).u0_m0ssq_ctrl[0]=(((r).u0_m0ssq_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define U0_M0SSQ_CTRLr_M0SS_SOFT_RESETf_GET(r) ((((r).u0_m0ssq_ctrl[0]) >> 16) & 0xf)
#define U0_M0SSQ_CTRLr_M0SS_SOFT_RESETf_SET(r,f) (r).u0_m0ssq_ctrl[0]=(((r).u0_m0ssq_ctrl[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))

/*
 * These macros can be used to access u0_M0SSQ_CTRL.
 */
#define READ_U0_M0SSQ_CTRLr(u,r) BCMDRD_IPROC_READ(u,U0_M0SSQ_CTRLr_OFFSET,r._u0_m0ssq_ctrl)
#define WRITE_U0_M0SSQ_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,U0_M0SSQ_CTRLr_OFFSET,r._u0_m0ssq_ctrl)

/*******************************************************************************
 * End of 'U0_M0SSQ_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  u0_M0SSQ_ECC_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_M0SSQ_ECC_CTRLr_OFFSET 0x01360004

#define U0_M0SSQ_ECC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program u0_M0SSQ_ECC_CTRL.
 */
typedef union U0_M0SSQ_ECC_CTRLr_s {
    uint32_t v[1];
    uint32_t u0_m0ssq_ecc_ctrl[1];
    uint32_t _u0_m0ssq_ecc_ctrl;
} U0_M0SSQ_ECC_CTRLr_t;

#define U0_M0SSQ_ECC_CTRLr_CLR(r) (r).u0_m0ssq_ecc_ctrl[0] = 0
#define U0_M0SSQ_ECC_CTRLr_SET(r,d) (r).u0_m0ssq_ecc_ctrl[0] = d
#define U0_M0SSQ_ECC_CTRLr_GET(r) (r).u0_m0ssq_ecc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_M0SSQ_ECC_CTRLr_TCM_ECC_ENf_GET(r) (((r).u0_m0ssq_ecc_ctrl[0]) & 0x1)
#define U0_M0SSQ_ECC_CTRLr_TCM_ECC_ENf_SET(r,f) (r).u0_m0ssq_ecc_ctrl[0]=(((r).u0_m0ssq_ecc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define U0_M0SSQ_ECC_CTRLr_TCM_FORCE_SINGLE_BIT_ERRf_GET(r) ((((r).u0_m0ssq_ecc_ctrl[0]) >> 1) & 0x1)
#define U0_M0SSQ_ECC_CTRLr_TCM_FORCE_SINGLE_BIT_ERRf_SET(r,f) (r).u0_m0ssq_ecc_ctrl[0]=(((r).u0_m0ssq_ecc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define U0_M0SSQ_ECC_CTRLr_TCM_FORCE_DOUBLE_BIT_ERRf_GET(r) ((((r).u0_m0ssq_ecc_ctrl[0]) >> 2) & 0x1)
#define U0_M0SSQ_ECC_CTRLr_TCM_FORCE_DOUBLE_BIT_ERRf_SET(r,f) (r).u0_m0ssq_ecc_ctrl[0]=(((r).u0_m0ssq_ecc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access u0_M0SSQ_ECC_CTRL.
 */
#define READ_U0_M0SSQ_ECC_CTRLr(u,r) BCMDRD_IPROC_READ(u,U0_M0SSQ_ECC_CTRLr_OFFSET,r._u0_m0ssq_ecc_ctrl)
#define WRITE_U0_M0SSQ_ECC_CTRLr(u,r) BCMDRD_IPROC_WRITE(u,U0_M0SSQ_ECC_CTRLr_OFFSET,r._u0_m0ssq_ecc_ctrl)

/*******************************************************************************
 * End of 'U0_M0SSQ_ECC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  u0_M0SSQ_ECC_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_M0SSQ_ECC_STATUSr_OFFSET 0x01360008

#define U0_M0SSQ_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program u0_M0SSQ_ECC_STATUS.
 */
typedef union U0_M0SSQ_ECC_STATUSr_s {
    uint32_t v[1];
    uint32_t u0_m0ssq_ecc_status[1];
    uint32_t _u0_m0ssq_ecc_status;
} U0_M0SSQ_ECC_STATUSr_t;

#define U0_M0SSQ_ECC_STATUSr_CLR(r) (r).u0_m0ssq_ecc_status[0] = 0
#define U0_M0SSQ_ECC_STATUSr_SET(r,d) (r).u0_m0ssq_ecc_status[0] = d
#define U0_M0SSQ_ECC_STATUSr_GET(r) (r).u0_m0ssq_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_M0SSQ_ECC_STATUSr_ECC_ERRf_GET(r) (((r).u0_m0ssq_ecc_status[0]) & 0x1)
#define U0_M0SSQ_ECC_STATUSr_ECC_ERRf_SET(r,f) (r).u0_m0ssq_ecc_status[0]=(((r).u0_m0ssq_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define U0_M0SSQ_ECC_STATUSr_MULTIPLE_ERRf_GET(r) ((((r).u0_m0ssq_ecc_status[0]) >> 1) & 0x1)
#define U0_M0SSQ_ECC_STATUSr_MULTIPLE_ERRf_SET(r,f) (r).u0_m0ssq_ecc_status[0]=(((r).u0_m0ssq_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define U0_M0SSQ_ECC_STATUSr_DOUBLE_BIT_ERRf_GET(r) ((((r).u0_m0ssq_ecc_status[0]) >> 2) & 0x1)
#define U0_M0SSQ_ECC_STATUSr_DOUBLE_BIT_ERRf_SET(r,f) (r).u0_m0ssq_ecc_status[0]=(((r).u0_m0ssq_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define U0_M0SSQ_ECC_STATUSr_ENTRY_IDXf_GET(r) ((((r).u0_m0ssq_ecc_status[0]) >> 3) & 0x7fff)
#define U0_M0SSQ_ECC_STATUSr_ENTRY_IDXf_SET(r,f) (r).u0_m0ssq_ecc_status[0]=(((r).u0_m0ssq_ecc_status[0] & ~((uint32_t)0x7fff << 3)) | ((((uint32_t)f) & 0x7fff) << 3))

/*
 * These macros can be used to access u0_M0SSQ_ECC_STATUS.
 */
#define READ_U0_M0SSQ_ECC_STATUSr(u,r) BCMDRD_IPROC_READ(u,U0_M0SSQ_ECC_STATUSr_OFFSET,r._u0_m0ssq_ecc_status)
#define WRITE_U0_M0SSQ_ECC_STATUSr(u,r) BCMDRD_IPROC_WRITE(u,U0_M0SSQ_ECC_STATUSr_OFFSET,r._u0_m0ssq_ecc_status)

/*******************************************************************************
 * End of 'U0_M0SSQ_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  u0_M0SSQ_INTR_ENABLE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define U0_M0SSQ_INTR_ENABLEr_OFFSET 0x0136000c

#define U0_M0SSQ_INTR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program u0_M0SSQ_INTR_ENABLE.
 */
typedef union U0_M0SSQ_INTR_ENABLEr_s {
    uint32_t v[1];
    uint32_t u0_m0ssq_intr_enable[1];
    uint32_t _u0_m0ssq_intr_enable;
} U0_M0SSQ_INTR_ENABLEr_t;

#define U0_M0SSQ_INTR_ENABLEr_CLR(r) (r).u0_m0ssq_intr_enable[0] = 0
#define U0_M0SSQ_INTR_ENABLEr_SET(r,d) (r).u0_m0ssq_intr_enable[0] = d
#define U0_M0SSQ_INTR_ENABLEr_GET(r) (r).u0_m0ssq_intr_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define U0_M0SSQ_INTR_ENABLEr_SINGLE_BIT_ERRf_GET(r) (((r).u0_m0ssq_intr_enable[0]) & 0x1)
#define U0_M0SSQ_INTR_ENABLEr_SINGLE_BIT_ERRf_SET(r,f) (r).u0_m0ssq_intr_enable[0]=(((r).u0_m0ssq_intr_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define U0_M0SSQ_INTR_ENABLEr_DOUBLE_BIT_ERRf_GET(r) ((((r).u0_m0ssq_intr_enable[0]) >> 1) & 0x1)
#define U0_M0SSQ_INTR_ENABLEr_DOUBLE_BIT_ERRf_SET(r,f) (r).u0_m0ssq_intr_enable[0]=(((r).u0_m0ssq_intr_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access u0_M0SSQ_INTR_ENABLE.
 */
#define READ_U0_M0SSQ_INTR_ENABLEr(u,r) BCMDRD_IPROC_READ(u,U0_M0SSQ_INTR_ENABLEr_OFFSET,r._u0_m0ssq_intr_enable)
#define WRITE_U0_M0SSQ_INTR_ENABLEr(u,r) BCMDRD_IPROC_WRITE(u,U0_M0SSQ_INTR_ENABLEr_OFFSET,r._u0_m0ssq_intr_enable)

/*******************************************************************************
 * End of 'U0_M0SSQ_INTR_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  UC_M0SS_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_CONTROLr_OFFSET 0x01308000

#define UC_M0SS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program UC_M0SS_CONTROL.
 */
typedef union UC_M0SS_CONTROLr_s {
    uint32_t v[1];
    uint32_t uc_m0ss_control[1];
    uint32_t _uc_m0ss_control;
} UC_M0SS_CONTROLr_t;

#define UC_M0SS_CONTROLr_CLR(r) (r).uc_m0ss_control[0] = 0
#define UC_M0SS_CONTROLr_SET(r,d) (r).uc_m0ss_control[0] = d
#define UC_M0SS_CONTROLr_GET(r) (r).uc_m0ss_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define UC_M0SS_CONTROLr_SOFT_RESETf_GET(r) (((r).uc_m0ss_control[0]) & 0x1)
#define UC_M0SS_CONTROLr_SOFT_RESETf_SET(r,f) (r).uc_m0ss_control[0]=(((r).uc_m0ss_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define UC_M0SS_CONTROLr_SYS_TICK_CLKENf_GET(r) ((((r).uc_m0ss_control[0]) >> 1) & 0x1)
#define UC_M0SS_CONTROLr_SYS_TICK_CLKENf_SET(r,f) (r).uc_m0ss_control[0]=(((r).uc_m0ss_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define UC_M0SS_CONTROLr_SYS_TICK_CALIBf_GET(r) ((((r).uc_m0ss_control[0]) >> 2) & 0x3ffffff)
#define UC_M0SS_CONTROLr_SYS_TICK_CALIBf_SET(r,f) (r).uc_m0ss_control[0]=(((r).uc_m0ss_control[0] & ~((uint32_t)0x3ffffff << 2)) | ((((uint32_t)f) & 0x3ffffff) << 2))

/*
 * These macros can be used to access UC_M0SS_CONTROL.
 */
#define READ_UC_M0SS_CONTROLr(u,_uc,r) BCMDRD_IPROC_READ(u,UC_M0SS_CONTROLr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_control)
#define WRITE_UC_M0SS_CONTROLr(u,_uc,r) BCMDRD_IPROC_WRITE(u,UC_M0SS_CONTROLr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_control)

/*******************************************************************************
 * End of 'UC_M0SS_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  UC_M0SS_DEBUG_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_DEBUG_CONTROLr_OFFSET 0x0130800c

#define UC_M0SS_DEBUG_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program UC_M0SS_DEBUG_CONTROL.
 */
typedef union UC_M0SS_DEBUG_CONTROLr_s {
    uint32_t v[1];
    uint32_t uc_m0ss_debug_control[1];
    uint32_t _uc_m0ss_debug_control;
} UC_M0SS_DEBUG_CONTROLr_t;

#define UC_M0SS_DEBUG_CONTROLr_CLR(r) (r).uc_m0ss_debug_control[0] = 0
#define UC_M0SS_DEBUG_CONTROLr_SET(r,d) (r).uc_m0ss_debug_control[0] = d
#define UC_M0SS_DEBUG_CONTROLr_GET(r) (r).uc_m0ss_debug_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define UC_M0SS_DEBUG_CONTROLr_EDBGRQf_GET(r) (((r).uc_m0ss_debug_control[0]) & 0x1)
#define UC_M0SS_DEBUG_CONTROLr_EDBGRQf_SET(r,f) (r).uc_m0ss_debug_control[0]=(((r).uc_m0ss_debug_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define UC_M0SS_DEBUG_CONTROLr_DBGRESTARTf_GET(r) ((((r).uc_m0ss_debug_control[0]) >> 1) & 0x1)
#define UC_M0SS_DEBUG_CONTROLr_DBGRESTARTf_SET(r,f) (r).uc_m0ss_debug_control[0]=(((r).uc_m0ss_debug_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access UC_M0SS_DEBUG_CONTROL.
 */
#define READ_UC_M0SS_DEBUG_CONTROLr(u,_uc,r) BCMDRD_IPROC_READ(u,UC_M0SS_DEBUG_CONTROLr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_debug_control)
#define WRITE_UC_M0SS_DEBUG_CONTROLr(u,_uc,r) BCMDRD_IPROC_WRITE(u,UC_M0SS_DEBUG_CONTROLr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_debug_control)

/*******************************************************************************
 * End of 'UC_M0SS_DEBUG_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  UC_M0SS_ECC_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_ECC_CTRLr_OFFSET 0x01308018

#define UC_M0SS_ECC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program UC_M0SS_ECC_CTRL.
 */
typedef union UC_M0SS_ECC_CTRLr_s {
    uint32_t v[1];
    uint32_t uc_m0ss_ecc_ctrl[1];
    uint32_t _uc_m0ss_ecc_ctrl;
} UC_M0SS_ECC_CTRLr_t;

#define UC_M0SS_ECC_CTRLr_CLR(r) (r).uc_m0ss_ecc_ctrl[0] = 0
#define UC_M0SS_ECC_CTRLr_SET(r,d) (r).uc_m0ss_ecc_ctrl[0] = d
#define UC_M0SS_ECC_CTRLr_GET(r) (r).uc_m0ss_ecc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define UC_M0SS_ECC_CTRLr_TCM_ECC_ENf_GET(r) (((r).uc_m0ss_ecc_ctrl[0]) & 0x1)
#define UC_M0SS_ECC_CTRLr_TCM_ECC_ENf_SET(r,f) (r).uc_m0ss_ecc_ctrl[0]=(((r).uc_m0ss_ecc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define UC_M0SS_ECC_CTRLr_TCM_FORCE_SINGLE_BIT_ERRf_GET(r) ((((r).uc_m0ss_ecc_ctrl[0]) >> 1) & 0x1)
#define UC_M0SS_ECC_CTRLr_TCM_FORCE_SINGLE_BIT_ERRf_SET(r,f) (r).uc_m0ss_ecc_ctrl[0]=(((r).uc_m0ss_ecc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define UC_M0SS_ECC_CTRLr_TCM_FORCE_DOUBLE_BIT_ERRf_GET(r) ((((r).uc_m0ss_ecc_ctrl[0]) >> 2) & 0x1)
#define UC_M0SS_ECC_CTRLr_TCM_FORCE_DOUBLE_BIT_ERRf_SET(r,f) (r).uc_m0ss_ecc_ctrl[0]=(((r).uc_m0ss_ecc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access UC_M0SS_ECC_CTRL.
 */
#define READ_UC_M0SS_ECC_CTRLr(u,_uc,r) BCMDRD_IPROC_READ(u,UC_M0SS_ECC_CTRLr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_ecc_ctrl)
#define WRITE_UC_M0SS_ECC_CTRLr(u,_uc,r) BCMDRD_IPROC_WRITE(u,UC_M0SS_ECC_CTRLr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_ecc_ctrl)

/*******************************************************************************
 * End of 'UC_M0SS_ECC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  UC_M0SS_ECC_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_ECC_STATUSr_OFFSET 0x0130801c

#define UC_M0SS_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program UC_M0SS_ECC_STATUS.
 */
typedef union UC_M0SS_ECC_STATUSr_s {
    uint32_t v[1];
    uint32_t uc_m0ss_ecc_status[1];
    uint32_t _uc_m0ss_ecc_status;
} UC_M0SS_ECC_STATUSr_t;

#define UC_M0SS_ECC_STATUSr_CLR(r) (r).uc_m0ss_ecc_status[0] = 0
#define UC_M0SS_ECC_STATUSr_SET(r,d) (r).uc_m0ss_ecc_status[0] = d
#define UC_M0SS_ECC_STATUSr_GET(r) (r).uc_m0ss_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define UC_M0SS_ECC_STATUSr_ECC_ERRf_GET(r) (((r).uc_m0ss_ecc_status[0]) & 0x1)
#define UC_M0SS_ECC_STATUSr_ECC_ERRf_SET(r,f) (r).uc_m0ss_ecc_status[0]=(((r).uc_m0ss_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define UC_M0SS_ECC_STATUSr_MULTIPLE_ERRf_GET(r) ((((r).uc_m0ss_ecc_status[0]) >> 1) & 0x1)
#define UC_M0SS_ECC_STATUSr_MULTIPLE_ERRf_SET(r,f) (r).uc_m0ss_ecc_status[0]=(((r).uc_m0ss_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define UC_M0SS_ECC_STATUSr_DOUBLE_BIT_ERRf_GET(r) ((((r).uc_m0ss_ecc_status[0]) >> 2) & 0x1)
#define UC_M0SS_ECC_STATUSr_DOUBLE_BIT_ERRf_SET(r,f) (r).uc_m0ss_ecc_status[0]=(((r).uc_m0ss_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define UC_M0SS_ECC_STATUSr_ENTRY_IDXf_GET(r) ((((r).uc_m0ss_ecc_status[0]) >> 3) & 0x1fff)
#define UC_M0SS_ECC_STATUSr_ENTRY_IDXf_SET(r,f) (r).uc_m0ss_ecc_status[0]=(((r).uc_m0ss_ecc_status[0] & ~((uint32_t)0x1fff << 3)) | ((((uint32_t)f) & 0x1fff) << 3))

/*
 * These macros can be used to access UC_M0SS_ECC_STATUS.
 */
#define READ_UC_M0SS_ECC_STATUSr(u,_uc,r) BCMDRD_IPROC_READ(u,UC_M0SS_ECC_STATUSr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_ecc_status)
#define WRITE_UC_M0SS_ECC_STATUSr(u,_uc,r) BCMDRD_IPROC_WRITE(u,UC_M0SS_ECC_STATUSr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_ecc_status)

/*******************************************************************************
 * End of 'UC_M0SS_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  UC_M0SS_ECO
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_ECOr_OFFSET 0x01308008

#define UC_M0SS_ECOr_SIZE 4

/*
 * This structure should be used to declare and program UC_M0SS_ECO.
 */
typedef union UC_M0SS_ECOr_s {
    uint32_t v[1];
    uint32_t uc_m0ss_eco[1];
    uint32_t _uc_m0ss_eco;
} UC_M0SS_ECOr_t;

#define UC_M0SS_ECOr_CLR(r) (r).uc_m0ss_eco[0] = 0
#define UC_M0SS_ECOr_SET(r,d) (r).uc_m0ss_eco[0] = d
#define UC_M0SS_ECOr_GET(r) (r).uc_m0ss_eco[0]

/*
 * These macros can be used to access individual fields.
 */
#define UC_M0SS_ECOr_REV_NUMf_GET(r) (((r).uc_m0ss_eco[0]) & 0xfffff)
#define UC_M0SS_ECOr_REV_NUMf_SET(r,f) (r).uc_m0ss_eco[0]=(((r).uc_m0ss_eco[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))

/*
 * These macros can be used to access UC_M0SS_ECO.
 */
#define READ_UC_M0SS_ECOr(u,_uc,r) BCMDRD_IPROC_READ(u,UC_M0SS_ECOr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_eco)
#define WRITE_UC_M0SS_ECOr(u,_uc,r) BCMDRD_IPROC_WRITE(u,UC_M0SS_ECOr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_eco)

/*******************************************************************************
 * End of 'UC_M0SS_ECOr'
 */




/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_127_96
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_127_96r_OFFSET 0x01308070

#define UC_M0SS_INTR_127_96r_SIZE 4

/* UC_M0SS_INTR_127_96r is element of u0_M0SS_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_159_128
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_159_128r_OFFSET 0x01308074

#define UC_M0SS_INTR_159_128r_SIZE 4

/* UC_M0SS_INTR_159_128r is element of u0_M0SS_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_191_160
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_191_160r_OFFSET 0x01308078

#define UC_M0SS_INTR_191_160r_SIZE 4

/* UC_M0SS_INTR_191_160r is element of u0_M0SS_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_223_192
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_223_192r_OFFSET 0x0130807c

#define UC_M0SS_INTR_223_192r_SIZE 4

/* UC_M0SS_INTR_223_192r is element of u0_M0SS_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_255_224
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_255_224r_OFFSET 0x01308080

#define UC_M0SS_INTR_255_224r_SIZE 4

/* UC_M0SS_INTR_255_224r is element of u0_M0SS_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_31_0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_31_0r_OFFSET 0x01308064

#define UC_M0SS_INTR_31_0r_SIZE 4

/* UC_M0SS_INTR_31_0r is element of u0_M0SS_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_63_32
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_63_32r_OFFSET 0x01308068

#define UC_M0SS_INTR_63_32r_SIZE 4

/* UC_M0SS_INTR_63_32r is element of u0_M0SS_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_95_64
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_95_64r_OFFSET 0x0130806c

#define UC_M0SS_INTR_95_64r_SIZE 4

/* UC_M0SS_INTR_95_64r is element of u0_M0SS_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_CONTROL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_CONTROLr_OFFSET 0x01308004

#define UC_M0SS_INTR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program UC_M0SS_INTR_CONTROL.
 */
typedef union UC_M0SS_INTR_CONTROLr_s {
    uint32_t v[1];
    uint32_t uc_m0ss_intr_control[1];
    uint32_t _uc_m0ss_intr_control;
} UC_M0SS_INTR_CONTROLr_t;

#define UC_M0SS_INTR_CONTROLr_CLR(r) (r).uc_m0ss_intr_control[0] = 0
#define UC_M0SS_INTR_CONTROLr_SET(r,d) (r).uc_m0ss_intr_control[0] = d
#define UC_M0SS_INTR_CONTROLr_GET(r) (r).uc_m0ss_intr_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define UC_M0SS_INTR_CONTROLr_IRQLATENCYf_GET(r) (((r).uc_m0ss_intr_control[0]) & 0xff)
#define UC_M0SS_INTR_CONTROLr_IRQLATENCYf_SET(r,f) (r).uc_m0ss_intr_control[0]=(((r).uc_m0ss_intr_control[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define UC_M0SS_INTR_CONTROLr_SLEEPHOLDREQNf_GET(r) ((((r).uc_m0ss_intr_control[0]) >> 8) & 0x1)
#define UC_M0SS_INTR_CONTROLr_SLEEPHOLDREQNf_SET(r,f) (r).uc_m0ss_intr_control[0]=(((r).uc_m0ss_intr_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define UC_M0SS_INTR_CONTROLr_WICENREQf_GET(r) ((((r).uc_m0ss_intr_control[0]) >> 9) & 0x1)
#define UC_M0SS_INTR_CONTROLr_WICENREQf_SET(r,f) (r).uc_m0ss_intr_control[0]=(((r).uc_m0ss_intr_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access UC_M0SS_INTR_CONTROL.
 */
#define READ_UC_M0SS_INTR_CONTROLr(u,_uc,r) BCMDRD_IPROC_READ(u,UC_M0SS_INTR_CONTROLr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_intr_control)
#define WRITE_UC_M0SS_INTR_CONTROLr(u,_uc,r) BCMDRD_IPROC_WRITE(u,UC_M0SS_INTR_CONTROLr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_intr_control)

/*******************************************************************************
 * End of 'UC_M0SS_INTR_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_ENABLE
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_ENABLEr_OFFSET 0x01308020

#define UC_M0SS_INTR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program UC_M0SS_INTR_ENABLE.
 */
typedef union UC_M0SS_INTR_ENABLEr_s {
    uint32_t v[1];
    uint32_t uc_m0ss_intr_enable[1];
    uint32_t _uc_m0ss_intr_enable;
} UC_M0SS_INTR_ENABLEr_t;

#define UC_M0SS_INTR_ENABLEr_CLR(r) (r).uc_m0ss_intr_enable[0] = 0
#define UC_M0SS_INTR_ENABLEr_SET(r,d) (r).uc_m0ss_intr_enable[0] = d
#define UC_M0SS_INTR_ENABLEr_GET(r) (r).uc_m0ss_intr_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define UC_M0SS_INTR_ENABLEr_SINGLE_BIT_ERRf_GET(r) (((r).uc_m0ss_intr_enable[0]) & 0x1)
#define UC_M0SS_INTR_ENABLEr_SINGLE_BIT_ERRf_SET(r,f) (r).uc_m0ss_intr_enable[0]=(((r).uc_m0ss_intr_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define UC_M0SS_INTR_ENABLEr_DOUBLE_BIT_ERRf_GET(r) ((((r).uc_m0ss_intr_enable[0]) >> 1) & 0x1)
#define UC_M0SS_INTR_ENABLEr_DOUBLE_BIT_ERRf_SET(r,f) (r).uc_m0ss_intr_enable[0]=(((r).uc_m0ss_intr_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access UC_M0SS_INTR_ENABLE.
 */
#define READ_UC_M0SS_INTR_ENABLEr(u,_uc,r) BCMDRD_IPROC_READ(u,UC_M0SS_INTR_ENABLEr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_intr_enable)
#define WRITE_UC_M0SS_INTR_ENABLEr(u,_uc,r) BCMDRD_IPROC_WRITE(u,UC_M0SS_INTR_ENABLEr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_intr_enable)

/*******************************************************************************
 * End of 'UC_M0SS_INTR_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_MASK
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_MASKr_OFFSET 0x01308044

#define UC_M0SS_INTR_MASKr_SIZE 4

/*
 * This structure should be used to declare and program UC_M0SS_INTR_MASK.
 */
typedef union UC_M0SS_INTR_MASKr_s {
    uint32_t v[1];
    uint32_t uc_m0ss_intr_mask[1];
    uint32_t _uc_m0ss_intr_mask;
} UC_M0SS_INTR_MASKr_t;

#define UC_M0SS_INTR_MASKr_CLR(r) (r).uc_m0ss_intr_mask[0] = 0
#define UC_M0SS_INTR_MASKr_SET(r,d) (r).uc_m0ss_intr_mask[0] = d
#define UC_M0SS_INTR_MASKr_GET(r) (r).uc_m0ss_intr_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define UC_M0SS_INTR_MASKr_CNFGf_GET(r) ((r).uc_m0ss_intr_mask[0])
#define UC_M0SS_INTR_MASKr_CNFGf_SET(r,f) (r).uc_m0ss_intr_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access UC_M0SS_INTR_MASK.
 */
#define READ_UC_M0SS_INTR_MASKr(u,_uc,i,r) BCMDRD_IPROC_READ(u,UC_M0SS_INTR_MASKr_OFFSET+(4*(i))+(0x10000*(_uc)),r._uc_m0ss_intr_mask)
#define WRITE_UC_M0SS_INTR_MASKr(u,_uc,i,r) BCMDRD_IPROC_WRITE(u,UC_M0SS_INTR_MASKr_OFFSET+(4*(i))+(0x10000*(_uc)),r._uc_m0ss_intr_mask)

/*******************************************************************************
 * End of 'UC_M0SS_INTR_MASKr'
 */




/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_MASK_127_96
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_MASK_127_96r_OFFSET 0x01308050

#define UC_M0SS_INTR_MASK_127_96r_SIZE 4

/* UC_M0SS_INTR_MASK_127_96r is element of u0_M0SS_INTR_MASK */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_MASK_159_128
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_MASK_159_128r_OFFSET 0x01308054

#define UC_M0SS_INTR_MASK_159_128r_SIZE 4

/* UC_M0SS_INTR_MASK_159_128r is element of u0_M0SS_INTR_MASK */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_MASK_191_160
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_MASK_191_160r_OFFSET 0x01308058

#define UC_M0SS_INTR_MASK_191_160r_SIZE 4

/* UC_M0SS_INTR_MASK_191_160r is element of u0_M0SS_INTR_MASK */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_MASK_223_192
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_MASK_223_192r_OFFSET 0x0130805c

#define UC_M0SS_INTR_MASK_223_192r_SIZE 4

/* UC_M0SS_INTR_MASK_223_192r is element of u0_M0SS_INTR_MASK */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_MASK_255_224
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_MASK_255_224r_OFFSET 0x01308060

#define UC_M0SS_INTR_MASK_255_224r_SIZE 4

/* UC_M0SS_INTR_MASK_255_224r is element of u0_M0SS_INTR_MASK */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_MASK_31_0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_MASK_31_0r_OFFSET 0x01308044

#define UC_M0SS_INTR_MASK_31_0r_SIZE 4

/* UC_M0SS_INTR_MASK_31_0r is element of u0_M0SS_INTR_MASK */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_MASK_63_32
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_MASK_63_32r_OFFSET 0x01308048

#define UC_M0SS_INTR_MASK_63_32r_SIZE 4

/* UC_M0SS_INTR_MASK_63_32r is element of u0_M0SS_INTR_MASK */

/*******************************************************************************
 * REGISTER:  UC_M0SS_INTR_MASK_95_64
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_INTR_MASK_95_64r_OFFSET 0x0130804c

#define UC_M0SS_INTR_MASK_95_64r_SIZE 4

/* UC_M0SS_INTR_MASK_95_64r is element of u0_M0SS_INTR_MASK */

/*******************************************************************************
 * REGISTER:  UC_M0SS_RAW_INTR
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_RAW_INTRr_OFFSET 0x01308024

#define UC_M0SS_RAW_INTRr_SIZE 4

/*
 * This structure should be used to declare and program UC_M0SS_RAW_INTR.
 */
typedef union UC_M0SS_RAW_INTRr_s {
    uint32_t v[1];
    uint32_t uc_m0ss_raw_intr[1];
    uint32_t _uc_m0ss_raw_intr;
} UC_M0SS_RAW_INTRr_t;

#define UC_M0SS_RAW_INTRr_CLR(r) (r).uc_m0ss_raw_intr[0] = 0
#define UC_M0SS_RAW_INTRr_SET(r,d) (r).uc_m0ss_raw_intr[0] = d
#define UC_M0SS_RAW_INTRr_GET(r) (r).uc_m0ss_raw_intr[0]

/*
 * These macros can be used to access individual fields.
 */
#define UC_M0SS_RAW_INTRr_STATUSf_GET(r) ((r).uc_m0ss_raw_intr[0])
#define UC_M0SS_RAW_INTRr_STATUSf_SET(r,f) (r).uc_m0ss_raw_intr[0]=((uint32_t)f)

/*
 * These macros can be used to access UC_M0SS_RAW_INTR.
 */
#define READ_UC_M0SS_RAW_INTRr(u,_uc,i,r) BCMDRD_IPROC_READ(u,UC_M0SS_RAW_INTRr_OFFSET+(4*(i))+(0x10000*(_uc)),r._uc_m0ss_raw_intr)
#define WRITE_UC_M0SS_RAW_INTRr(u,_uc,i,r) BCMDRD_IPROC_WRITE(u,UC_M0SS_RAW_INTRr_OFFSET+(4*(i))+(0x10000*(_uc)),r._uc_m0ss_raw_intr)

/*******************************************************************************
 * End of 'UC_M0SS_RAW_INTRr'
 */




/*******************************************************************************
 * REGISTER:  UC_M0SS_RAW_INTR_127_96
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_RAW_INTR_127_96r_OFFSET 0x01308030

#define UC_M0SS_RAW_INTR_127_96r_SIZE 4

/* UC_M0SS_RAW_INTR_127_96r is element of u0_M0SS_RAW_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_RAW_INTR_159_128
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_RAW_INTR_159_128r_OFFSET 0x01308034

#define UC_M0SS_RAW_INTR_159_128r_SIZE 4

/* UC_M0SS_RAW_INTR_159_128r is element of u0_M0SS_RAW_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_RAW_INTR_191_160
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_RAW_INTR_191_160r_OFFSET 0x01308038

#define UC_M0SS_RAW_INTR_191_160r_SIZE 4

/* UC_M0SS_RAW_INTR_191_160r is element of u0_M0SS_RAW_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_RAW_INTR_223_192
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_RAW_INTR_223_192r_OFFSET 0x0130803c

#define UC_M0SS_RAW_INTR_223_192r_SIZE 4

/* UC_M0SS_RAW_INTR_223_192r is element of u0_M0SS_RAW_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_RAW_INTR_255_224
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_RAW_INTR_255_224r_OFFSET 0x01308040

#define UC_M0SS_RAW_INTR_255_224r_SIZE 4

/* UC_M0SS_RAW_INTR_255_224r is element of u0_M0SS_RAW_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_RAW_INTR_31_0
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_RAW_INTR_31_0r_OFFSET 0x01308024

#define UC_M0SS_RAW_INTR_31_0r_SIZE 4

/* UC_M0SS_RAW_INTR_31_0r is element of u0_M0SS_RAW_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_RAW_INTR_63_32
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_RAW_INTR_63_32r_OFFSET 0x01308028

#define UC_M0SS_RAW_INTR_63_32r_SIZE 4

/* UC_M0SS_RAW_INTR_63_32r is element of u0_M0SS_RAW_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_RAW_INTR_95_64
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_RAW_INTR_95_64r_OFFSET 0x0130802c

#define UC_M0SS_RAW_INTR_95_64r_SIZE 4

/* UC_M0SS_RAW_INTR_95_64r is element of u0_M0SS_RAW_INTR */

/*******************************************************************************
 * REGISTER:  UC_M0SS_STATUS
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_STATUSr_OFFSET 0x01308010

#define UC_M0SS_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program UC_M0SS_STATUS.
 */
typedef union UC_M0SS_STATUSr_s {
    uint32_t v[1];
    uint32_t uc_m0ss_status[1];
    uint32_t _uc_m0ss_status;
} UC_M0SS_STATUSr_t;

#define UC_M0SS_STATUSr_CLR(r) (r).uc_m0ss_status[0] = 0
#define UC_M0SS_STATUSr_SET(r,d) (r).uc_m0ss_status[0] = d
#define UC_M0SS_STATUSr_GET(r) (r).uc_m0ss_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define UC_M0SS_STATUSr_DBGRESTARTEDf_GET(r) (((r).uc_m0ss_status[0]) & 0x1)
#define UC_M0SS_STATUSr_DBGRESTARTEDf_SET(r,f) (r).uc_m0ss_status[0]=(((r).uc_m0ss_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define UC_M0SS_STATUSr_SYSRESETREQf_GET(r) ((((r).uc_m0ss_status[0]) >> 1) & 0x1)
#define UC_M0SS_STATUSr_SYSRESETREQf_SET(r,f) (r).uc_m0ss_status[0]=(((r).uc_m0ss_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define UC_M0SS_STATUSr_SLEEPHOLDACKf_GET(r) ((((r).uc_m0ss_status[0]) >> 2) & 0x1)
#define UC_M0SS_STATUSr_SLEEPHOLDACKf_SET(r,f) (r).uc_m0ss_status[0]=(((r).uc_m0ss_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define UC_M0SS_STATUSr_WICENACKf_GET(r) ((((r).uc_m0ss_status[0]) >> 3) & 0x1)
#define UC_M0SS_STATUSr_WICENACKf_SET(r,f) (r).uc_m0ss_status[0]=(((r).uc_m0ss_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define UC_M0SS_STATUSr_WAKEUPf_GET(r) ((((r).uc_m0ss_status[0]) >> 4) & 0x1)
#define UC_M0SS_STATUSr_WAKEUPf_SET(r,f) (r).uc_m0ss_status[0]=(((r).uc_m0ss_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define UC_M0SS_STATUSr_HALTEDf_GET(r) ((((r).uc_m0ss_status[0]) >> 8) & 0x1)
#define UC_M0SS_STATUSr_HALTEDf_SET(r,f) (r).uc_m0ss_status[0]=(((r).uc_m0ss_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define UC_M0SS_STATUSr_LOCKUPf_GET(r) ((((r).uc_m0ss_status[0]) >> 9) & 0x1)
#define UC_M0SS_STATUSr_LOCKUPf_SET(r,f) (r).uc_m0ss_status[0]=(((r).uc_m0ss_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define UC_M0SS_STATUSr_SLEEPDEEPf_GET(r) ((((r).uc_m0ss_status[0]) >> 10) & 0x1)
#define UC_M0SS_STATUSr_SLEEPDEEPf_SET(r,f) (r).uc_m0ss_status[0]=(((r).uc_m0ss_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define UC_M0SS_STATUSr_SLEEPINGf_GET(r) ((((r).uc_m0ss_status[0]) >> 11) & 0x1)
#define UC_M0SS_STATUSr_SLEEPINGf_SET(r,f) (r).uc_m0ss_status[0]=(((r).uc_m0ss_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define UC_M0SS_STATUSr_TXEVf_GET(r) ((((r).uc_m0ss_status[0]) >> 16) & 0xffff)
#define UC_M0SS_STATUSr_TXEVf_SET(r,f) (r).uc_m0ss_status[0]=(((r).uc_m0ss_status[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access UC_M0SS_STATUS.
 */
#define READ_UC_M0SS_STATUSr(u,_uc,r) BCMDRD_IPROC_READ(u,UC_M0SS_STATUSr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_status)
#define WRITE_UC_M0SS_STATUSr(u,_uc,r) BCMDRD_IPROC_WRITE(u,UC_M0SS_STATUSr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_status)

/*******************************************************************************
 * End of 'UC_M0SS_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  UC_M0SS_TCM_CTRL
 * BLOCKS:   CMIC
 * SIZE:     32
 */
#define UC_M0SS_TCM_CTRLr_OFFSET 0x01308014

#define UC_M0SS_TCM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program UC_M0SS_TCM_CTRL.
 */
typedef union UC_M0SS_TCM_CTRLr_s {
    uint32_t v[1];
    uint32_t uc_m0ss_tcm_ctrl[1];
    uint32_t _uc_m0ss_tcm_ctrl;
} UC_M0SS_TCM_CTRLr_t;

#define UC_M0SS_TCM_CTRLr_CLR(r) (r).uc_m0ss_tcm_ctrl[0] = 0
#define UC_M0SS_TCM_CTRLr_SET(r,d) (r).uc_m0ss_tcm_ctrl[0] = d
#define UC_M0SS_TCM_CTRLr_GET(r) (r).uc_m0ss_tcm_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define UC_M0SS_TCM_CTRLr_TCM_TMf_GET(r) (((r).uc_m0ss_tcm_ctrl[0]) & 0x7f)
#define UC_M0SS_TCM_CTRLr_TCM_TMf_SET(r,f) (r).uc_m0ss_tcm_ctrl[0]=(((r).uc_m0ss_tcm_ctrl[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access UC_M0SS_TCM_CTRL.
 */
#define READ_UC_M0SS_TCM_CTRLr(u,_uc,r) BCMDRD_IPROC_READ(u,UC_M0SS_TCM_CTRLr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_tcm_ctrl)
#define WRITE_UC_M0SS_TCM_CTRLr(u,_uc,r) BCMDRD_IPROC_WRITE(u,UC_M0SS_TCM_CTRLr_OFFSET+(0x10000*(_uc)),r._uc_m0ss_tcm_ctrl)

/*******************************************************************************
 * End of 'UC_M0SS_TCM_CTRLr'
 */




#endif /* BCMBD_CMICX_ACC_H */
