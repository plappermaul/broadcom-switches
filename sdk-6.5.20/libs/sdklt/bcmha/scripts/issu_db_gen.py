#
# \file issu_db_gen.py
#
# This script creates a C file that can provide the offset of each field in
# the data structure. The file also contain the database description of the
# given data structure.
#
# This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
# 
# Copyright 2007-2020 Broadcom Inc. All rights reserved.
#

import os
import csv
import hashlib  # Support md5 hashing
import filecmp
import tempfile
import shutil
from shutil import copyfile
from filelock import Timeout, FileLock

STRUCT_DB_FILE = '/struct_def.db'
STRUCT_DEF_C_FILE = '/struct_def.c'
ISSU_DB_DEF_DIR = '/bcmissu/dll/db/'

STRUCT_PREFIX = 'bcmissu_struct_'
ENUM_PREFIX = 'bcmissu_enum_'


# Defines structure DB entry.
class struct_db_entry:
    name = ''  # Structure name.
    field_info = ''  # Variable name of the field information.
    struct_sig = ''  # Structure signature, used to identify structure changes.


def prepare_generic_output_file_header(fh, header_file):
    fh.write('/*************************************************************************\n')
    fh.write(' *\n')
    fh.write(' * DO NOT EDIT THIS FILE!\n')
    fh.write(' * This file is auto-generated by HA parser from YAML formated file.\n')
    fh.write(' * Edits to this file will be lost when it is regenerated.\n')
    fh.write(' * Tool: bcmha/scripts/issu_db_gen.py\n')
    fh.write(' *\n')
    fh.write(' * $Copyright:.$\n')
    fh.write(' *\n')
    fh.write(' *************************************************************************/\n')
    fh.write('\n')
    fh.write('#include <bcmissu/issu_types.h>\n')
    if header_file != None:
        fh.write('#include \"%s\"\n' % header_file)


def multiple_str_replace(in_str, replaces_list, replace_str):
    # Iterate over the list of strings to replace
    for elem in replaces_list :
        # Check if string is in the main string
        if elem in in_str :
            # Replace the string
            in_str = in_str.replace(elem, replace_str)

    return in_str


# This class maintains a database of all the data structures and enum types
# that were generated by the component module class.
# The database is being maintained as a text file named struct_def.db.
# The DB file is sorted based on the structure ID (digest
# of the structure name). It is assumed that the structure ID remains identical
# throughout the life cycle of the structure. The last element of the DB is
# the structure signature. This signature is being generated as a digest of all
# the fields of the structure (including their type). Therefore if any type
# or field will changed, the signature will change as well and the parser will
# know that this structure has changed.
class global_struct_db:
    """Maintains the global structure DB."""

    # The initializer reads the content of the structure DB into local
    # dictionary.
    def __init__(self, base_dir, header_file):
        self.base_dir = base_dir
        # Dictionary of structures that were changed in previous version to
        # current. It used to determine
        self.older_struct_dict = {}
        # Temporary dictionary used when processing older versions
        self.temp_struct_dict = {}
        # Initialized by generate_c_db(). Contain the version list in descending
        self.version_list = []
        self.output_header_file = header_file
        self.file_name = base_dir + STRUCT_DB_FILE
        # Dictionary of all structures based on struct ID
        self.struct_id_dict = {}
        self.out_fh = None

        lock_file = self.file_name + '.lock'
        try:
            lock = FileLock(lock_file)
            lock.acquire(timeout = 20)
        except Timeout:
            print('Failed to acquire file lock (init)')
            return
        self.read_struct_db_content(self.file_name, self.struct_id_dict)
        lock.release()

    def shutdown(self):
        local_dict = {}

        lock_file = self.file_name + '.lock'
        try:
            lock = FileLock(lock_file)
            lock.acquire(timeout = 20)
        except Timeout:
            print('Failed to acquire file lock (shutdown)')
            return
        self.read_struct_db_content(self.file_name, local_dict)

        # Merge the local_dict and the structure_id_dict
        for id in local_dict.keys():
            if id in self.struct_id_dict:
                continue

            ent = local_dict[id]
            self.struct_id_dict[id] = ent

        try:
            fh = open(self.file_name, 'w')
            # Write the content of the dictionary (sorted based on struct id)
            # back into the DB file
            for id in sorted(self.struct_id_dict.keys()):
                ent = self.struct_id_dict[id]
                fh.write('%s,%s,%s,%s\n' %
                          (id, ent.name, ent.field_info, ent.struct_sig))
            fh.close()
        except IOError:
            print('Failed to open file %s for write\n' % self.file_name)
        finally:
            lock.release()

        self.__finalize()

    def read_struct_db_content(self, f_name, dict):
        try:
            fh = open(f_name, 'r')
        except:
            return
        # Read the content of the file into csv dictionary
        csvdict = csv.DictReader(fh, fieldnames = ['id', 'name',
                                                 'field_info', 'struct_sig'])

        # Populate the structure dictionary with the content found in
        # STRUCT_DB_FILE
        for rec in csvdict:
            ent = struct_db_entry()
            ent.name = rec['name']
            ent.field_info = rec['field_info']
            ent.struct_sig = rec['struct_sig']
            dict[rec['id']] = ent

        fh.close()

    def add_struct_info(self, id, ent):
        if '0x' + id in self.struct_id_dict:
            return

        entry = struct_db_entry()
        entry.struct_sig = '0x' + ent.struct_sig
        entry.field_info = ent.field_info
        entry.name = ent.name
        self.struct_id_dict['0x' + id] = entry

    def generate_c_db(self, ver, version_list):
        idx = self.base_dir.rfind('/')
        if idx == -1:
            print('Error: Invalid base dir' % self.base_dir)
            return False
        dir_path = self.base_dir[:idx + 1] + 'base'
        # Verify that dir path exist
        if not os.path.isdir(dir_path):
            try:
                os.makedirs(dir_path)
            except:
                print('Directory %s already exist\n' % dir_path)

        try:
            fh = open(dir_path + STRUCT_DEF_C_FILE, 'w')
        except:
            print('Error: Failed to open output file %s'
                  % dir_path + STRUCT_DEF_C_FILE)
            return False

        self.out_fh = fh
        self.version_list = version_list
        prepare_generic_output_file_header(fh, self.output_header_file)

        self.__update_with_version(ver, self.struct_id_dict)

        return True;

    def __add_struct_older_ver(self, rec):
        # First let check that the structure was not already included in the
        # changed structure list. If it is in the changed list verify that
        # the structure signature is different. Return if it is the same.
        if rec['id'] in self.older_struct_dict:
            entry = self.older_struct_dict[rec['id']]
            if entry.struct_sig == rec['struct_sig']:
                return

        # Add the structure into the older structure list
        ent = struct_db_entry()
        ent.name = rec['name']
        ent.field_info = rec['field_info']
        ent.struct_sig = rec['struct_sig']

        if rec['id'] in self.older_struct_dict:
            # Struct in old version but was changed multiple times.
            # Just update the record
            entry.struct_sig = rec['struct_sig']
            self.older_struct_dict[rec['id']] = entry
        else:
            self.older_struct_dict[rec['id']] = ent

        # Add the structure to the temporary dictionary
        self.temp_struct_dict[rec['id']] = ent

    # Write the data structures and the enum definitions defined in the
    # given dictionary and associated with a given version.
    # The content of the dictionary varies based on the version. For the
    # current version the dictionary contains all the structures and enum
    # definitions. For older version the dictionary only contains the data
    # structure and enum definitions of those definitions that changed at
    # the version that is following the given one.
    def __update_with_version(self, ver, dict):
        fh = self.out_fh

        # Start by declaring all the external data structures
        fh.write('\n')

        for id in dict.keys():
            ent = dict[id]
            if ent.field_info.startswith(STRUCT_PREFIX):
                fh.write('extern const issu_struct_t %s;\n' % ent.field_info)
            else:
                fh.write('extern const issu_enum_symbol_t %s;\n' %
                         (ent.field_info))

        c_ver = multiple_str_replace(ver, ['.', '-'], '_')
        fh.write('\nstatic const issu_struct_db_t issu_struct_db_%s[] = {\n'
                 % c_ver)
        for id in dict.keys():
            ent = dict[id]
            if ent.field_info.startswith(STRUCT_PREFIX):
                fh.write('    {%s, &%s},\n' % (id, ent.field_info))
        # Terminate the list with NULL
        fh.write('    {0, NULL}\n')
        fh.write('};\n')

        # Now create the enum DB
        fh.write('static const issu_enum_db_t issu_enum_db_%s[] = {\n' % c_ver)
        for id in dict.keys():
            ent = dict[id]
            if ent.field_info.startswith(ENUM_PREFIX):
                fh.write('    {%s, \"%s\", &%s},\n' % (id, ent.name, ent.field_info))
        # Terminate the list with NULL entries
        fh.write('    {0, NULL}\n')
        fh.write('};\n')

    # Write the last section of the struct_db file. It has an entry per
    # version where each entry contains the version ID the data structures
    # and the enum definitions associated with this version.
    def __finalize(self):
        if self.out_fh == None:
            return

        # Declare the global version list
        self.out_fh.write('\nstatic const issu_version_list_t'
                          ' issu_struct_version[] = {\n')
        # If there are no versions simply place the current list there
        if len(self.version_list) == 0:
            self.out_fh.write('    {\n')
            self.out_fh.write('        .version = \"None\",\n')
            self.out_fh.write('        .ver_db = issu_struct_db_\n')
            self.out_fh.write('    },\n')
        else:
            for ver in self.version_list:
                c_ver = multiple_str_replace(ver, ['.', '-'], '_')
                self.out_fh.write('    {\"%s\",issu_struct_db_%s,issu_enum_db_%s},\n' %
                                  (ver, c_ver, c_ver))

        # Last entry should be NULL
        self.out_fh.write('    {NULL, NULL, NULL}\n')
        self.out_fh.write('};\n')

        # Generate get function to retrieve the global ISSU struct
        self.out_fh.write('\nconst issu_version_list_t'
                          ' *bcmissu_struct_db_get()\n')
        self.out_fh.write('{\n')
        self.out_fh.write('    return issu_struct_version;\n')
        self.out_fh.write('}\n')

        self.out_fh.close()

    # It is important that this function will be called with descending version
    # numbers (i.e. start from the latest version backward.
    def parse_previous_versions(self, base_dir, ver):
        file_name = base_dir + ver + STRUCT_DB_FILE
        try:
            fh = open(file_name, 'r')
        except:
            print('file %s not found' % file_name)
            return False

        # Clear the temporary dictionary
        self.temp_struct_dict.clear()
        # Read the content of the file into csv dictionary
        csvdict = csv.DictReader(fh, fieldnames = ['id', 'name',
                                                 'field_info', 'struct_sig'])
        for rec in csvdict:
            # A structure require migration if it still exist and its signature
            # had changed.
            if rec['id'] in self.struct_id_dict:
                ent = self.struct_id_dict[rec['id']]
                if ent.struct_sig != rec['struct_sig']:
                    self.__add_struct_older_ver(rec)

        # Last add the version changes to the C file
        self.__update_with_version(ver, self.temp_struct_dict)
        return True


# Defines active structure class.
class struct_entry:
    id = ''  # Structure ID (64 bit unique).
    field_info = ''  # Variable name of the field information.
    struct_sig = ''  # Structure signature, used to identify structure changes.


# This class is a singleton class that handles the processing of a complete
# yaml file structure definition. The class is generating a C file that contains
# the necessary structure information for every structure defined in the yaml
# file.
class component_module:
    """Handles file creation and generic file content"""

    # Dictionary keyed on structure name of all the structures defined in
    # this processed yaml file.
    struct_dict = {}

    # Dictionary of all the enum types, keyed by enum data type.
    enum_dict = {}

    def __init__(self, sdk_dir, ver, component, out_header):
        try:
            issu_db_dir = os.environ['ISSU_DB'] + '/'
        except:
            issu_db_dir = sdk_dir + ISSU_DB_DEF_DIR

        if ver != '' and ver != 'none':
            self.base_dir = issu_db_dir + 'ver_' + ver
        else:
            self.base_dir = issu_db_dir + 'current'
        # Create the directory if not exist
        if not os.path.isdir(self.base_dir):
            try:
                os.makedirs(self.base_dir)
            except OSError:
                print('Target directory exist\n')
        # For now, embed the version into the output file name
        self.file_name = self.base_dir + '/' + component + '_v' + ver + '.c'
        self.tmp_file = tempfile.mktemp('.gen')
        try:
            self.fh = open (self.tmp_file, 'w')
        except:
            print('Error: Failed to open temp file\n')
            return
        self.version = ver
        idx = out_header.rfind('/')
        if idx == -1:
            self.output_header_file = out_header
        else:
            self.output_header_file = out_header[idx + 1:]
        prepare_generic_output_file_header(self.fh, self.output_header_file)
        self.db_file_gen = global_struct_db(self.base_dir, self.output_header_file)

    def shutdown(self):
        ent = struct_db_entry()
        # For every structure processed, inform the structure DB class about
        # the structure.
        for name in self.struct_dict:
            st = self.struct_dict[name]
            ent.name = name
            ent.field_info = st.field_info
            ent.struct_sig = st.struct_sig
            self.db_file_gen.add_struct_info(st.id, ent)

        for name in self.enum_dict:
            st = self.enum_dict[name]
            ent.name = name
            ent.field_info = st.field_info
            ent.struct_sig = st.struct_sig
            self.db_file_gen.add_struct_info(st.id, ent)

        # Need to close the C file
        self.fh.close()
        # If the destination file does not exist or different from the temporary
        # file then move the temporary file over. Otherwise the temporary file
        # is not required (since identical file already present) so delete it.
        if (not os.path.isfile(self.file_name)) or \
           (not filecmp.cmp(self.tmp_file, self.file_name)):
            shutil.move(self.tmp_file, self.file_name)
        else:
            os.remove(self.tmp_file)

        self.db_file_gen.shutdown()

    def save_generated_header(self, header_file):
        # Verify that the source header file exist
        if not os.path.isfile(header_file):
            print('Error: Missing header file %s\n' % header_file)
            return
        # Verify that the destination directory exist
        if os.path.exists(self.base_dir):
            dest_file = self.base_dir + '/' + self.output_header_file
            copyfile(header_file, dest_file)
        else:
            print("Error destination directory %s does not exist" % self.base_dir)

    def save_source_yaml(self, src_yaml_file):
        # Verify that the source header file exist
        if not os.path.isfile(src_yaml_file):
            print('Error: Missing header file %s\n' % src_yaml_file)
            return
        index = src_yaml_file.rfind('/')
        # Verify that the destination directory exist
        if os.path.exists(self.base_dir):
            dest_file = self.base_dir + '/' + src_yaml_file[index + 1:]
            copyfile(src_yaml_file, dest_file)
        else:
            print("Error destination directory %s does not exist" % self.base_dir)


class field_entry:
    name = ''
    id = ''
    ftype = ''
    is_array = False
    is_table = False
    lt_ltid = False
    is_fid = False
    is_ha_ptr = 0
    table_size_var = None
    array_size = None
    array_size_num = 0
    ltid_field = ''
    struct_id = ''
    enum_name = None


class enum_field:
    name = ''
    val = 0


# This class handles a single data structure.
class structure_db:
    """Class that handles data structures for ISSU purpose"""

    # Initializing the class. The comp_cls is a class that handles the entire
    # component and is of type component_module.
    def __init__(self, file_name, struct_name, struct_id, comp_cls, is_struct):
        self.struct_name = struct_name
        self.struct_id = struct_id
        self.is_struct = is_struct
        idx = file_name.rfind('/')
        idx2 = file_name.find('.yml')
        if idx2 != -1:
            clean_file_name = file_name[idx + 1:idx2]
        else:
            clean_file_name = file_name[idx + 1:]
        c_ver = multiple_str_replace(comp_cls.version, ['.', '-'], '_')
        if is_struct:
            prefix = STRUCT_PREFIX
        else:
            prefix = ENUM_PREFIX
        self.external_struct_name = prefix + clean_file_name + \
                                    '_' + struct_name + '_v' + c_ver
        self.fields = []
        self.enums = []
        self.comp_class = comp_cls
        st_ent = struct_entry()
        st_ent.id = struct_id
        st_ent.field_info = self.external_struct_name
        if is_struct:
            comp_cls.struct_dict[struct_name] = st_ent
        else:
            comp_cls.enum_dict[struct_name] = st_ent

    def __create_struct_definition(self, fh):
        fh.write('\nstatic const issu_field_t bcmissu_fields_%s[] = {\n' %
                 self.struct_name)
        for entry in self.fields:
            fh.write('    {\n')
            fh.write('        .fid = 0x%s,\n' % entry.id)
            fh.write('        .width = sizeof(%s),\n' % entry.ftype)
            if entry.is_ha_ptr > 0:
                if entry.is_ha_ptr == 1:
                    fh.write('        .ha_ptr = HA_PTR,\n')
                else:
                    fh.write('        .ha_ptr = HA_LPTR,\n')
            else:
                fh.write('        .ha_ptr = HA_PTR_NONE,\n')

            if entry.is_ltid:
                fh.write('        .lt_attrib = HA_LT_LTID,\n')
                fh.write('        .ltid_var_for_fid = ISSU_INVALID_FIELD_ID,\n')
            elif entry.is_fid:
                fh.write('        .lt_attrib = HA_LT_FID,\n')
                for e in self.fields:
                    if e.name == entry.ltid_field:
                        fh.write('        .ltid_var_for_fid = 0x%s,\n' % e.id)
                        break
            else:
                fh.write('        .lt_attrib = HA_LT_NONE,\n')
                fh.write('        .ltid_var_for_fid = ISSU_INVALID_FIELD_ID,\n')

            if entry.is_array or entry.is_table:
                fh.write('        .is_array = true,\n')
                if entry.array_size:
                    fh.write('        .size = %s,\n' % str(entry.array_size))
                    fh.write('        .var_size_id = ISSU_INVALID_FIELD_ID,\n')
                else:
                    fh.write('        .size = 0,\n')
                    for e in self.fields:
                        if e.name == entry.table_size_var:
                            fh.write('        .var_size_id = 0x%s,\n' % e.id)
                            break
            else:
                 fh.write('        .is_array = false,\n')
                 fh.write('        .var_size_id = ISSU_INVALID_FIELD_ID,\n')
                 fh.write('        .size = 0,\n')

            if entry.ftype in self.comp_class.struct_dict or \
               entry.ftype in self.comp_class.enum_dict:
                fh.write('        .struct_id = 0x%s,\n' % entry.struct_id)
            else:
                fh.write('        .struct_id = %s,\n' % entry.struct_id)

            if entry.ftype in self.comp_class.enum_dict:
                fh.write('        .is_local_enum = true,\n')
            else:
                fh.write('        .is_local_enum = false,\n')

            if entry.enum_name == None:
                fh.write('        .enum_type_name = NULL,\n')
            else:
                fh.write('        .enum_type_name = \"%s\",\n' % entry.enum_name)

            fh.write('    },\n')

        fh.write('};\n')

    def __create_enum_definition(self, fh):
        fh.write('\nconst issu_enum_symbol_t %s[%d] = {\n' %
                 (self.external_struct_name, len(self.enums) + 1))
        for entry in self.enums:
            fh.write('    {\"%s\", %d},\n' % (entry.name, entry.val))
        fh.write('    {NULL, 0}\n')
        fh.write('};\n')

    def __generate_offset_calc_func(self, fh):
        fh.write('\nstatic uint32_t %s_field_offset_get (bcmissu_field_id_t field_id)\n'
                 % self.struct_name)
        fh.write('{\n')
        fh.write('    %s var;\n\n' % self.struct_name)
        fh.write('    switch (field_id) {\n')
        for entry in self.fields:
            fh.write('        case 0x%s:\n' % entry.id)
            fh.write('            return ((uint8_t *)&var.%s) - (uint8_t *)&var;\n'
                      % entry.name)
        fh.write('        default:\n')
        fh.write('            return ISSU_INVALID_FLD_OFFSET;\n')
        fh.write('    }\n')
        fh.write('}\n')

    def __finalize_struct_info(self, fh):
        fh.write('\nconst issu_struct_t %s = {\n' % self.external_struct_name)
        fh.write('    .offset_get_func = %s_field_offset_get,\n' %
                 self.struct_name)
        fh.write('    .generic_size = sizeof(%s),\n' % self.struct_name)
        fh.write('    .field_count = %s,\n' % len (self.fields))
        fh.write('    .fields = bcmissu_fields_%s,\n' % self.struct_name)
        fh.write('};\n')

    # Calculate the signature of a data structure.
    def __calc_struct_signature(self):
        m = hashlib.md5()
        for entry in self.fields:
            # For fields that are arrays include the array dimension within
            # the encoding so a change in array size (or constant definition)
            # will be identified as a structure signature change.
            if entry.is_array and not entry.is_table:
                struct_name = entry.name + entry.ftype + str(entry.array_size_num)
            else:
                struct_name = entry.name + entry.ftype
            m.update(struct_name.encode())
            # If the field is a structure (but not a pointer) include its
            # signature in the signature calculation. Therefore if it changes
            # it will tricles up to change in this structure signature.
            if entry.struct_id != 'ISSU_INVALID_STRUCT_ID' and \
                entry.ftype.find('*') == -1:
                if entry.ftype in self.comp_class.struct_dict:
                    st = self.comp_class.struct_dict[entry.ftype]
                else:
                    st = self.comp_class.enum_dict[entry.ftype]
                m.update(st.struct_sig.encode())

        st = self.comp_class.struct_dict[self.struct_name]
        st.struct_sig = m.hexdigest()[:16]
        self.comp_class.struct_dict[self.struct_name] = st

    # Calculate the signature of an enum type definition.
    def __calc_enum_signature(self):
        m = hashlib.md5()
        for entry in self.enums:
            struct_name = entry.name + str(entry.val)
            m.update(struct_name.encode())

        st = self.comp_class.enum_dict[self.struct_name]
        st.struct_sig = m.hexdigest()[:16]
        self.comp_class.enum_dict[self.struct_name] = st

    # Parameters:
    # field - The field name
    # ftype - The field type
    # is_array - Indicating if it is an array
    # array_size - Indicating the array size (required is_array = True). This
    # can be a constant name representing the actual size
    # array_size_num - An integer indicating the real array size
    # is_table - Indicating if it is an unbounded array (required is_array = True)
    # table_size_var - The name of the field containing the array size for
    #                  unbounded array size (required is_array = True)
    # is_ltid - Indicates if the field value contains LTID.
    # is_fid - Indicating if the field value contains LT field ID.
    # ltid_field - If is_fid is True this field indicates which LT this field
    #              belongs to.
    # enum_name - Indicates if the field value is associated with a particular
    #             LT enum type and specifies the name of this enum.
    def add_field(self, field, ftype, is_array, array_size, array_size_num,
                  is_table, table_size_var, is_ltid, is_fid, ltid_field, enum_name):
        m = hashlib.md5()
        m.update(field.encode())

        entry = field_entry()
        idx = field.find('[')
        if idx == -1:
            entry.name = field
        else:
            entry.name = field[:idx]
        entry.id = m.hexdigest()[:8]
        entry.ftype = ftype
        entry.is_array = is_array
        entry.is_table = is_table
        entry.is_ltid = is_ltid
        entry.is_fid = is_fid
        if (ftype == 'shr_ha_ptr_t'):
            entry.is_ha_ptr = 1
        elif (ftype == 'shr_ha_lptr_t'):
            entry.is_ha_ptr = 2
        else:
             entry.is_ha_ptr = 0
        entry.array_size = array_size
        entry.array_size_num = array_size_num
        entry.ltid_field = ltid_field
        entry.table_size_var = table_size_var
        entry.enum_name = enum_name
        if ftype in self.comp_class.struct_dict:
            entry.struct_id = self.comp_class.struct_dict[ftype].id
        elif ftype in self.comp_class.enum_dict:
            entry.struct_id = self.comp_class.enum_dict[ftype].id
        else:
            entry.struct_id = 'ISSU_INVALID_STRUCT_ID'
        self.fields.append(entry)

    def add_enum_val(self, field, val):
        entry = enum_field()
        entry.name = field
        entry.val = val
        self.enums.append(entry)

    def output_to_file(self):
        if self.is_struct:
            self.__calc_struct_signature()
            self.__create_struct_definition(self.comp_class.fh)
            self.__generate_offset_calc_func(self.comp_class.fh)
            self.__finalize_struct_info(self.comp_class.fh)
        else:
            self.__calc_enum_signature()
            self.__create_enum_definition(self.comp_class.fh)

        return True
