#ifndef BCM56996_A0_CDPORT_DEFS_H
#define BCM56996_A0_CDPORT_DEFS_H
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 * Tool: INTERNAL/regs/xgs/generate-chip.pl
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * Definition file for the BCM56996_A0.
 */

#include <sal/sal_libc.h>

/*******************************************************************************
 * MEMORY:  AM_TABLE
 * BLOCKS:   CDPORT
 * SIZE:     81
 */
#define AM_TABLEm_OFFSET 0x20000000

#define AM_TABLEm_MIN 0
#define AM_TABLEm_MAX 63
#define AM_TABLEm_CMAX(u) 63
#define AM_TABLEm_SIZE 11

/*
 * This structure should be used to declare and program AM_TABLE.
 */
typedef union AM_TABLEm_s {
    uint32_t v[3];
    uint32_t am_table[3];
    uint32_t _am_table;
} AM_TABLEm_t;

#define AM_TABLEm_CLR(r) sal_memset(&((r).am_table[0]), 0, sizeof(AM_TABLEm_t))
#define AM_TABLEm_SET(r,i,d) (r).am_table[i] = d
#define AM_TABLEm_GET(r,i) (r).am_table[i]

/*
 * These macros can be used to access individual fields.
 */
#define AM_TABLEm_AM_DATAf_GET(r,a) bcmpmac_field_get((r).am_table,0,80,a)
#define AM_TABLEm_AM_DATAf_SET(r,a) bcmpmac_field_set((r).am_table,0,80,a)
#define AM_TABLEm_AM_COMPRESSION_MODEf_GET(r) (((r).am_table[0]) & 0x7)
#define AM_TABLEm_AM_COMPRESSION_MODEf_SET(r,f) (r).am_table[0]=(((r).am_table[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define AM_TABLEm_AM_SIZEf_GET(r) ((((r).am_table[0]) >> 3) & 0xf)
#define AM_TABLEm_AM_SIZEf_SET(r,f) (r).am_table[0]=(((r).am_table[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define AM_TABLEm_PAD_MODEf_GET(r) ((((r).am_table[0]) >> 7) & 0x3)
#define AM_TABLEm_PAD_MODEf_SET(r,f) (r).am_table[0]=(((r).am_table[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define AM_TABLEm_UM_TABLE_COUNTf_GET(r) ((((r).am_table[0]) >> 9) & 0x1f)
#define AM_TABLEm_UM_TABLE_COUNTf_SET(r,f) (r).am_table[0]=(((r).am_table[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9))
#define AM_TABLEm_UM_TABLE_INDEXf_GET(r) ((((r).am_table[0]) >> 14) & 0x3f)
#define AM_TABLEm_UM_TABLE_INDEXf_SET(r,f) (r).am_table[0]=(((r).am_table[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define AM_TABLEm_CMf_GET(r) bcmpmac_field32_get((r).am_table,20,43)
#define AM_TABLEm_CMf_SET(r,f) bcmpmac_field32_set((r).am_table,20,43,f)
#define AM_TABLEm_USE_FIXEDf_GET(r) ((((r).am_table[1]) >> 12) & 0xf)
#define AM_TABLEm_USE_FIXEDf_SET(r,f) (r).am_table[1]=(((r).am_table[1] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define AM_TABLEm_AM_SPACING_RSf_GET(r) ((((r).am_table[1]) >> 16) & 0x1ff)
#define AM_TABLEm_AM_SPACING_RSf_SET(r,f) (r).am_table[1]=(((r).am_table[1] & ~((uint32_t)0x1ff << 16)) | ((((uint32_t)f) & 0x1ff) << 16))
#define AM_TABLEm_AM_SPACING_NO_RSf_GET(r) bcmpmac_field32_get((r).am_table,57,64)
#define AM_TABLEm_AM_SPACING_NO_RSf_SET(r,f) bcmpmac_field32_set((r).am_table,57,64,f)
#define AM_TABLEm_AM_SPACING_CREDITSf_GET(r) ((((r).am_table[2]) >> 1) & 0xff)
#define AM_TABLEm_AM_SPACING_CREDITSf_SET(r,f) (r).am_table[2]=(((r).am_table[2] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define AM_TABLEm_CM_AM_SELf_GET(r) ((((r).am_table[2]) >> 9) & 0x1)
#define AM_TABLEm_CM_AM_SELf_SET(r,f) (r).am_table[2]=(((r).am_table[2] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define AM_TABLEm_RSVDf_GET(r) ((((r).am_table[2]) >> 10) & 0x7f)
#define AM_TABLEm_RSVDf_SET(r,f) (r).am_table[2]=(((r).am_table[2] & ~((uint32_t)0x7f << 10)) | ((((uint32_t)f) & 0x7f) << 10))

/*
 * These macros can be used to access AM_TABLE.
 */
#define READ_AM_TABLEm(pa,p,i,m) bcmpmac_read(pa,p,AM_TABLEm_OFFSET,i,AM_TABLEm_SIZE,(m._am_table))
#define WRITE_AM_TABLEm(pa,p,i,m) bcmpmac_write(pa,p,AM_TABLEm_OFFSET,i,AM_TABLEm_SIZE,&(m._am_table))

/*******************************************************************************
 * End of 'AM_TABLEm'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_CLOCK_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_CLOCK_CTRLr_OFFSET 0x04041800

#define CDMAC_CLOCK_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_CLOCK_CTRL.
 */
typedef union CDMAC_CLOCK_CTRLr_s {
    uint32_t v[1];
    uint32_t cdmac_clock_ctrl[1];
    uint32_t _cdmac_clock_ctrl;
} CDMAC_CLOCK_CTRLr_t;

#define CDMAC_CLOCK_CTRLr_CLR(r) (r).cdmac_clock_ctrl[0] = 0
#define CDMAC_CLOCK_CTRLr_SET(r,d) (r).cdmac_clock_ctrl[0] = d
#define CDMAC_CLOCK_CTRLr_GET(r) (r).cdmac_clock_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_CLOCK_CTRLr_CORE_CLOCK_FASTERf_GET(r) (((r).cdmac_clock_ctrl[0]) & 0x1)
#define CDMAC_CLOCK_CTRLr_CORE_CLOCK_FASTERf_SET(r,f) (r).cdmac_clock_ctrl[0]=(((r).cdmac_clock_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CDMAC_CLOCK_CTRL.
 */
#define READ_CDMAC_CLOCK_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDMAC_CLOCK_CTRLr_OFFSET,0,CDMAC_CLOCK_CTRLr_SIZE,(r._cdmac_clock_ctrl))
#define WRITE_CDMAC_CLOCK_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDMAC_CLOCK_CTRLr_OFFSET,0,CDMAC_CLOCK_CTRLr_SIZE,&(r._cdmac_clock_ctrl))

/*******************************************************************************
 * End of 'CDMAC_CLOCK_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_CTRLr_OFFSET 0x14043000

#define CDMAC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_CTRL.
 */
typedef union CDMAC_CTRLr_s {
    uint32_t v[1];
    uint32_t cdmac_ctrl[1];
    uint32_t _cdmac_ctrl;
} CDMAC_CTRLr_t;

#define CDMAC_CTRLr_CLR(r) (r).cdmac_ctrl[0] = 0
#define CDMAC_CTRLr_SET(r,d) (r).cdmac_ctrl[0] = d
#define CDMAC_CTRLr_GET(r) (r).cdmac_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_CTRLr_TX_ENf_GET(r) (((r).cdmac_ctrl[0]) & 0x1)
#define CDMAC_CTRLr_TX_ENf_SET(r,f) (r).cdmac_ctrl[0]=(((r).cdmac_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_CTRLr_RX_ENf_GET(r) ((((r).cdmac_ctrl[0]) >> 1) & 0x1)
#define CDMAC_CTRLr_RX_ENf_SET(r,f) (r).cdmac_ctrl[0]=(((r).cdmac_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDMAC_CTRLr_LOCAL_LPBKf_GET(r) ((((r).cdmac_ctrl[0]) >> 2) & 0x1)
#define CDMAC_CTRLr_LOCAL_LPBKf_SET(r,f) (r).cdmac_ctrl[0]=(((r).cdmac_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CDMAC_CTRLr_REMOVE_FAILOVER_LPBKf_GET(r) ((((r).cdmac_ctrl[0]) >> 4) & 0x1)
#define CDMAC_CTRLr_REMOVE_FAILOVER_LPBKf_SET(r,f) (r).cdmac_ctrl[0]=(((r).cdmac_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CDMAC_CTRLr_LAG_FAILOVER_ENf_GET(r) ((((r).cdmac_ctrl[0]) >> 5) & 0x1)
#define CDMAC_CTRLr_LAG_FAILOVER_ENf_SET(r,f) (r).cdmac_ctrl[0]=(((r).cdmac_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CDMAC_CTRLr_SOFT_RESETf_GET(r) ((((r).cdmac_ctrl[0]) >> 6) & 0x1)
#define CDMAC_CTRLr_SOFT_RESETf_SET(r,f) (r).cdmac_ctrl[0]=(((r).cdmac_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CDMAC_CTRLr_LOCAL_LPBK_LEAK_ENBf_GET(r) ((((r).cdmac_ctrl[0]) >> 8) & 0x1)
#define CDMAC_CTRLr_LOCAL_LPBK_LEAK_ENBf_SET(r,f) (r).cdmac_ctrl[0]=(((r).cdmac_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CDMAC_CTRLr_RS_SOFT_RESETf_GET(r) ((((r).cdmac_ctrl[0]) >> 10) & 0x1)
#define CDMAC_CTRLr_RS_SOFT_RESETf_SET(r,f) (r).cdmac_ctrl[0]=(((r).cdmac_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CDMAC_CTRLr_SW_LINK_STATUSf_GET(r) ((((r).cdmac_ctrl[0]) >> 12) & 0x1)
#define CDMAC_CTRLr_SW_LINK_STATUSf_SET(r,f) (r).cdmac_ctrl[0]=(((r).cdmac_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CDMAC_CTRLr_LINK_STATUS_SELECTf_GET(r) ((((r).cdmac_ctrl[0]) >> 13) & 0x1)
#define CDMAC_CTRLr_LINK_STATUS_SELECTf_SET(r,f) (r).cdmac_ctrl[0]=(((r).cdmac_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CDMAC_CTRLr_MAC_LINK_DOWN_SEQ_ENf_GET(r) ((((r).cdmac_ctrl[0]) >> 14) & 0x1)
#define CDMAC_CTRLr_MAC_LINK_DOWN_SEQ_ENf_SET(r,f) (r).cdmac_ctrl[0]=(((r).cdmac_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access CDMAC_CTRL.
 */
#define READ_CDMAC_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDMAC_CTRLr_OFFSET,0,CDMAC_CTRLr_SIZE,(r._cdmac_ctrl))
#define WRITE_CDMAC_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDMAC_CTRLr_OFFSET,0,CDMAC_CTRLr_SIZE,&(r._cdmac_ctrl))

/*******************************************************************************
 * End of 'CDMAC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_ECC_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_ECC_CTRLr_OFFSET 0x04040c00

#define CDMAC_ECC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_ECC_CTRL.
 */
typedef union CDMAC_ECC_CTRLr_s {
    uint32_t v[1];
    uint32_t cdmac_ecc_ctrl[1];
    uint32_t _cdmac_ecc_ctrl;
} CDMAC_ECC_CTRLr_t;

#define CDMAC_ECC_CTRLr_CLR(r) (r).cdmac_ecc_ctrl[0] = 0
#define CDMAC_ECC_CTRLr_SET(r,d) (r).cdmac_ecc_ctrl[0] = d
#define CDMAC_ECC_CTRLr_GET(r) (r).cdmac_ecc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_ECC_CTRLr_TX_CDC_ECC_CTRL_ENf_GET(r) (((r).cdmac_ecc_ctrl[0]) & 0x1)
#define CDMAC_ECC_CTRLr_TX_CDC_ECC_CTRL_ENf_SET(r,f) (r).cdmac_ecc_ctrl[0]=(((r).cdmac_ecc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_ECC_CTRLr_TX_CDC_FORCE_DOUBLE_BIT_ERRf_GET(r) ((((r).cdmac_ecc_ctrl[0]) >> 1) & 0x1)
#define CDMAC_ECC_CTRLr_TX_CDC_FORCE_DOUBLE_BIT_ERRf_SET(r,f) (r).cdmac_ecc_ctrl[0]=(((r).cdmac_ecc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDMAC_ECC_CTRLr_TX_CDC_FORCE_SINGLE_BIT_ERRf_GET(r) ((((r).cdmac_ecc_ctrl[0]) >> 2) & 0x1)
#define CDMAC_ECC_CTRLr_TX_CDC_FORCE_SINGLE_BIT_ERRf_SET(r,f) (r).cdmac_ecc_ctrl[0]=(((r).cdmac_ecc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CDMAC_ECC_CTRLr_MIB_COUNTER_ECC_CTRL_ENf_GET(r) ((((r).cdmac_ecc_ctrl[0]) >> 3) & 0x1)
#define CDMAC_ECC_CTRLr_MIB_COUNTER_ECC_CTRL_ENf_SET(r,f) (r).cdmac_ecc_ctrl[0]=(((r).cdmac_ecc_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CDMAC_ECC_CTRLr_MIB_COUNTER_FORCE_DOUBLE_BIT_ERRf_GET(r) ((((r).cdmac_ecc_ctrl[0]) >> 4) & 0x1)
#define CDMAC_ECC_CTRLr_MIB_COUNTER_FORCE_DOUBLE_BIT_ERRf_SET(r,f) (r).cdmac_ecc_ctrl[0]=(((r).cdmac_ecc_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CDMAC_ECC_CTRLr_MIB_COUNTER_FORCE_SINGLE_BIT_ERRf_GET(r) ((((r).cdmac_ecc_ctrl[0]) >> 5) & 0x1)
#define CDMAC_ECC_CTRLr_MIB_COUNTER_FORCE_SINGLE_BIT_ERRf_SET(r,f) (r).cdmac_ecc_ctrl[0]=(((r).cdmac_ecc_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access CDMAC_ECC_CTRL.
 */
#define READ_CDMAC_ECC_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDMAC_ECC_CTRLr_OFFSET,0,CDMAC_ECC_CTRLr_SIZE,(r._cdmac_ecc_ctrl))
#define WRITE_CDMAC_ECC_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDMAC_ECC_CTRLr_OFFSET,0,CDMAC_ECC_CTRLr_SIZE,&(r._cdmac_ecc_ctrl))

/*******************************************************************************
 * End of 'CDMAC_ECC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_ECC_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_ECC_STATUSr_OFFSET 0x04041000

#define CDMAC_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_ECC_STATUS.
 */
typedef union CDMAC_ECC_STATUSr_s {
    uint32_t v[1];
    uint32_t cdmac_ecc_status[1];
    uint32_t _cdmac_ecc_status;
} CDMAC_ECC_STATUSr_t;

#define CDMAC_ECC_STATUSr_CLR(r) (r).cdmac_ecc_status[0] = 0
#define CDMAC_ECC_STATUSr_SET(r,d) (r).cdmac_ecc_status[0] = d
#define CDMAC_ECC_STATUSr_GET(r) (r).cdmac_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_ECC_STATUSr_TX_CDC_SINGLE_BIT_ERRf_GET(r) (((r).cdmac_ecc_status[0]) & 0x1)
#define CDMAC_ECC_STATUSr_TX_CDC_SINGLE_BIT_ERRf_SET(r,f) (r).cdmac_ecc_status[0]=(((r).cdmac_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_ECC_STATUSr_TX_CDC_DOUBLE_BIT_ERRf_GET(r) ((((r).cdmac_ecc_status[0]) >> 1) & 0x1)
#define CDMAC_ECC_STATUSr_TX_CDC_DOUBLE_BIT_ERRf_SET(r,f) (r).cdmac_ecc_status[0]=(((r).cdmac_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDMAC_ECC_STATUSr_MIB_COUNTER_SINGLE_BIT_ERRf_GET(r) ((((r).cdmac_ecc_status[0]) >> 2) & 0x1)
#define CDMAC_ECC_STATUSr_MIB_COUNTER_SINGLE_BIT_ERRf_SET(r,f) (r).cdmac_ecc_status[0]=(((r).cdmac_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CDMAC_ECC_STATUSr_MIB_COUNTER_DOUBLE_BIT_ERRf_GET(r) ((((r).cdmac_ecc_status[0]) >> 3) & 0x1)
#define CDMAC_ECC_STATUSr_MIB_COUNTER_DOUBLE_BIT_ERRf_SET(r,f) (r).cdmac_ecc_status[0]=(((r).cdmac_ecc_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CDMAC_ECC_STATUSr_MIB_COUNTER_MULTIPLE_ERRf_GET(r) ((((r).cdmac_ecc_status[0]) >> 4) & 0x1)
#define CDMAC_ECC_STATUSr_MIB_COUNTER_MULTIPLE_ERRf_SET(r,f) (r).cdmac_ecc_status[0]=(((r).cdmac_ecc_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CDMAC_ECC_STATUSr_MIB_COUNTER_ECC_ERR_ADDRESSf_GET(r) ((((r).cdmac_ecc_status[0]) >> 5) & 0x7f)
#define CDMAC_ECC_STATUSr_MIB_COUNTER_ECC_ERR_ADDRESSf_SET(r,f) (r).cdmac_ecc_status[0]=(((r).cdmac_ecc_status[0] & ~((uint32_t)0x7f << 5)) | ((((uint32_t)f) & 0x7f) << 5))

/*
 * These macros can be used to access CDMAC_ECC_STATUS.
 */
#define READ_CDMAC_ECC_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDMAC_ECC_STATUSr_OFFSET,0,CDMAC_ECC_STATUSr_SIZE,(r._cdmac_ecc_status))
#define WRITE_CDMAC_ECC_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDMAC_ECC_STATUSr_OFFSET,0,CDMAC_ECC_STATUSr_SIZE,&(r._cdmac_ecc_status))

/*******************************************************************************
 * End of 'CDMAC_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_FIFO_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_FIFO_STATUSr_OFFSET 0x14046c00

#define CDMAC_FIFO_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_FIFO_STATUS.
 */
typedef union CDMAC_FIFO_STATUSr_s {
    uint32_t v[1];
    uint32_t cdmac_fifo_status[1];
    uint32_t _cdmac_fifo_status;
} CDMAC_FIFO_STATUSr_t;

#define CDMAC_FIFO_STATUSr_CLR(r) (r).cdmac_fifo_status[0] = 0
#define CDMAC_FIFO_STATUSr_SET(r,d) (r).cdmac_fifo_status[0] = d
#define CDMAC_FIFO_STATUSr_GET(r) (r).cdmac_fifo_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_FIFO_STATUSr_TX_PKT_UNDERFLOWf_GET(r) (((r).cdmac_fifo_status[0]) & 0x1)
#define CDMAC_FIFO_STATUSr_TX_PKT_UNDERFLOWf_SET(r,f) (r).cdmac_fifo_status[0]=(((r).cdmac_fifo_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_FIFO_STATUSr_TX_PKT_OVERFLOWf_GET(r) ((((r).cdmac_fifo_status[0]) >> 1) & 0x1)
#define CDMAC_FIFO_STATUSr_TX_PKT_OVERFLOWf_SET(r,f) (r).cdmac_fifo_status[0]=(((r).cdmac_fifo_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDMAC_FIFO_STATUSr_LINK_STATUSf_GET(r) ((((r).cdmac_fifo_status[0]) >> 2) & 0x1)
#define CDMAC_FIFO_STATUSr_LINK_STATUSf_SET(r,f) (r).cdmac_fifo_status[0]=(((r).cdmac_fifo_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CDMAC_FIFO_STATUS.
 */
#define READ_CDMAC_FIFO_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDMAC_FIFO_STATUSr_OFFSET,0,CDMAC_FIFO_STATUSr_SIZE,(r._cdmac_fifo_status))
#define WRITE_CDMAC_FIFO_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDMAC_FIFO_STATUSr_OFFSET,0,CDMAC_FIFO_STATUSr_SIZE,&(r._cdmac_fifo_status))

/*******************************************************************************
 * End of 'CDMAC_FIFO_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_INTR_ENABLE
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_INTR_ENABLEr_OFFSET 0x14047800

#define CDMAC_INTR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_INTR_ENABLE.
 */
typedef union CDMAC_INTR_ENABLEr_s {
    uint32_t v[1];
    uint32_t cdmac_intr_enable[1];
    uint32_t _cdmac_intr_enable;
} CDMAC_INTR_ENABLEr_t;

#define CDMAC_INTR_ENABLEr_CLR(r) (r).cdmac_intr_enable[0] = 0
#define CDMAC_INTR_ENABLEr_SET(r,d) (r).cdmac_intr_enable[0] = d
#define CDMAC_INTR_ENABLEr_GET(r) (r).cdmac_intr_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_INTR_ENABLEr_TX_PKT_UNDERFLOWf_GET(r) (((r).cdmac_intr_enable[0]) & 0x1)
#define CDMAC_INTR_ENABLEr_TX_PKT_UNDERFLOWf_SET(r,f) (r).cdmac_intr_enable[0]=(((r).cdmac_intr_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_INTR_ENABLEr_TX_PKT_OVERFLOWf_GET(r) ((((r).cdmac_intr_enable[0]) >> 1) & 0x1)
#define CDMAC_INTR_ENABLEr_TX_PKT_OVERFLOWf_SET(r,f) (r).cdmac_intr_enable[0]=(((r).cdmac_intr_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDMAC_INTR_ENABLEr_LOCAL_FAULT_STATUSf_GET(r) ((((r).cdmac_intr_enable[0]) >> 2) & 0x1)
#define CDMAC_INTR_ENABLEr_LOCAL_FAULT_STATUSf_SET(r,f) (r).cdmac_intr_enable[0]=(((r).cdmac_intr_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CDMAC_INTR_ENABLEr_REMOTE_FAULT_STATUSf_GET(r) ((((r).cdmac_intr_enable[0]) >> 3) & 0x1)
#define CDMAC_INTR_ENABLEr_REMOTE_FAULT_STATUSf_SET(r,f) (r).cdmac_intr_enable[0]=(((r).cdmac_intr_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CDMAC_INTR_ENABLEr_LINK_INTERRUPTION_STATUSf_GET(r) ((((r).cdmac_intr_enable[0]) >> 4) & 0x1)
#define CDMAC_INTR_ENABLEr_LINK_INTERRUPTION_STATUSf_SET(r,f) (r).cdmac_intr_enable[0]=(((r).cdmac_intr_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CDMAC_INTR_ENABLEr_TX_CDC_SINGLE_BIT_ERRf_GET(r) ((((r).cdmac_intr_enable[0]) >> 5) & 0x1)
#define CDMAC_INTR_ENABLEr_TX_CDC_SINGLE_BIT_ERRf_SET(r,f) (r).cdmac_intr_enable[0]=(((r).cdmac_intr_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CDMAC_INTR_ENABLEr_TX_CDC_DOUBLE_BIT_ERRf_GET(r) ((((r).cdmac_intr_enable[0]) >> 6) & 0x1)
#define CDMAC_INTR_ENABLEr_TX_CDC_DOUBLE_BIT_ERRf_SET(r,f) (r).cdmac_intr_enable[0]=(((r).cdmac_intr_enable[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CDMAC_INTR_ENABLEr_MIB_COUNTER_SINGLE_BIT_ERRf_GET(r) ((((r).cdmac_intr_enable[0]) >> 7) & 0x1)
#define CDMAC_INTR_ENABLEr_MIB_COUNTER_SINGLE_BIT_ERRf_SET(r,f) (r).cdmac_intr_enable[0]=(((r).cdmac_intr_enable[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CDMAC_INTR_ENABLEr_MIB_COUNTER_DOUBLE_BIT_ERRf_GET(r) ((((r).cdmac_intr_enable[0]) >> 8) & 0x1)
#define CDMAC_INTR_ENABLEr_MIB_COUNTER_DOUBLE_BIT_ERRf_SET(r,f) (r).cdmac_intr_enable[0]=(((r).cdmac_intr_enable[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CDMAC_INTR_ENABLEr_MIB_COUNTER_MULTIPLE_ERRf_GET(r) ((((r).cdmac_intr_enable[0]) >> 9) & 0x1)
#define CDMAC_INTR_ENABLEr_MIB_COUNTER_MULTIPLE_ERRf_SET(r,f) (r).cdmac_intr_enable[0]=(((r).cdmac_intr_enable[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access CDMAC_INTR_ENABLE.
 */
#define READ_CDMAC_INTR_ENABLEr(pa,p,r) bcmpmac_read(pa,p,CDMAC_INTR_ENABLEr_OFFSET,0,CDMAC_INTR_ENABLEr_SIZE,(r._cdmac_intr_enable))
#define WRITE_CDMAC_INTR_ENABLEr(pa,p,r) bcmpmac_write(pa,p,CDMAC_INTR_ENABLEr_OFFSET,0,CDMAC_INTR_ENABLEr_SIZE,&(r._cdmac_intr_enable))

/*******************************************************************************
 * End of 'CDMAC_INTR_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_INTR_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_INTR_STATUSr_OFFSET 0x14047c00

#define CDMAC_INTR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_INTR_STATUS.
 */
typedef union CDMAC_INTR_STATUSr_s {
    uint32_t v[1];
    uint32_t cdmac_intr_status[1];
    uint32_t _cdmac_intr_status;
} CDMAC_INTR_STATUSr_t;

#define CDMAC_INTR_STATUSr_CLR(r) (r).cdmac_intr_status[0] = 0
#define CDMAC_INTR_STATUSr_SET(r,d) (r).cdmac_intr_status[0] = d
#define CDMAC_INTR_STATUSr_GET(r) (r).cdmac_intr_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_INTR_STATUSr_TX_PKT_UNDERFLOWf_GET(r) (((r).cdmac_intr_status[0]) & 0x1)
#define CDMAC_INTR_STATUSr_TX_PKT_UNDERFLOWf_SET(r,f) (r).cdmac_intr_status[0]=(((r).cdmac_intr_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_INTR_STATUSr_TX_PKT_OVERFLOWf_GET(r) ((((r).cdmac_intr_status[0]) >> 1) & 0x1)
#define CDMAC_INTR_STATUSr_TX_PKT_OVERFLOWf_SET(r,f) (r).cdmac_intr_status[0]=(((r).cdmac_intr_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDMAC_INTR_STATUSr_LOCAL_FAULT_STATUSf_GET(r) ((((r).cdmac_intr_status[0]) >> 2) & 0x1)
#define CDMAC_INTR_STATUSr_LOCAL_FAULT_STATUSf_SET(r,f) (r).cdmac_intr_status[0]=(((r).cdmac_intr_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CDMAC_INTR_STATUSr_REMOTE_FAULT_STATUSf_GET(r) ((((r).cdmac_intr_status[0]) >> 3) & 0x1)
#define CDMAC_INTR_STATUSr_REMOTE_FAULT_STATUSf_SET(r,f) (r).cdmac_intr_status[0]=(((r).cdmac_intr_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CDMAC_INTR_STATUSr_LINK_INTERRUPTION_STATUSf_GET(r) ((((r).cdmac_intr_status[0]) >> 4) & 0x1)
#define CDMAC_INTR_STATUSr_LINK_INTERRUPTION_STATUSf_SET(r,f) (r).cdmac_intr_status[0]=(((r).cdmac_intr_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CDMAC_INTR_STATUSr_TX_CDC_SINGLE_BIT_ERRf_GET(r) ((((r).cdmac_intr_status[0]) >> 5) & 0x1)
#define CDMAC_INTR_STATUSr_TX_CDC_SINGLE_BIT_ERRf_SET(r,f) (r).cdmac_intr_status[0]=(((r).cdmac_intr_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CDMAC_INTR_STATUSr_TX_CDC_DOUBLE_BIT_ERRf_GET(r) ((((r).cdmac_intr_status[0]) >> 6) & 0x1)
#define CDMAC_INTR_STATUSr_TX_CDC_DOUBLE_BIT_ERRf_SET(r,f) (r).cdmac_intr_status[0]=(((r).cdmac_intr_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CDMAC_INTR_STATUSr_MIB_COUNTER_SINGLE_BIT_ERRf_GET(r) ((((r).cdmac_intr_status[0]) >> 7) & 0x1)
#define CDMAC_INTR_STATUSr_MIB_COUNTER_SINGLE_BIT_ERRf_SET(r,f) (r).cdmac_intr_status[0]=(((r).cdmac_intr_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CDMAC_INTR_STATUSr_MIB_COUNTER_DOUBLE_BIT_ERRf_GET(r) ((((r).cdmac_intr_status[0]) >> 8) & 0x1)
#define CDMAC_INTR_STATUSr_MIB_COUNTER_DOUBLE_BIT_ERRf_SET(r,f) (r).cdmac_intr_status[0]=(((r).cdmac_intr_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CDMAC_INTR_STATUSr_MIB_COUNTER_MULTIPLE_ERRf_GET(r) ((((r).cdmac_intr_status[0]) >> 9) & 0x1)
#define CDMAC_INTR_STATUSr_MIB_COUNTER_MULTIPLE_ERRf_SET(r,f) (r).cdmac_intr_status[0]=(((r).cdmac_intr_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access CDMAC_INTR_STATUS.
 */
#define READ_CDMAC_INTR_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDMAC_INTR_STATUSr_OFFSET,0,CDMAC_INTR_STATUSr_SIZE,(r._cdmac_intr_status))
#define WRITE_CDMAC_INTR_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDMAC_INTR_STATUSr_OFFSET,0,CDMAC_INTR_STATUSr_SIZE,&(r._cdmac_intr_status))

/*******************************************************************************
 * End of 'CDMAC_INTR_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_LAG_FAILOVER_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_LAG_FAILOVER_STATUSr_OFFSET 0x14047000

#define CDMAC_LAG_FAILOVER_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_LAG_FAILOVER_STATUS.
 */
typedef union CDMAC_LAG_FAILOVER_STATUSr_s {
    uint32_t v[1];
    uint32_t cdmac_lag_failover_status[1];
    uint32_t _cdmac_lag_failover_status;
} CDMAC_LAG_FAILOVER_STATUSr_t;

#define CDMAC_LAG_FAILOVER_STATUSr_CLR(r) (r).cdmac_lag_failover_status[0] = 0
#define CDMAC_LAG_FAILOVER_STATUSr_SET(r,d) (r).cdmac_lag_failover_status[0] = d
#define CDMAC_LAG_FAILOVER_STATUSr_GET(r) (r).cdmac_lag_failover_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_GET(r) (((r).cdmac_lag_failover_status[0]) & 0x1)
#define CDMAC_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_SET(r,f) (r).cdmac_lag_failover_status[0]=(((r).cdmac_lag_failover_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CDMAC_LAG_FAILOVER_STATUS.
 */
#define READ_CDMAC_LAG_FAILOVER_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDMAC_LAG_FAILOVER_STATUSr_OFFSET,0,CDMAC_LAG_FAILOVER_STATUSr_SIZE,(r._cdmac_lag_failover_status))
#define WRITE_CDMAC_LAG_FAILOVER_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDMAC_LAG_FAILOVER_STATUSr_OFFSET,0,CDMAC_LAG_FAILOVER_STATUSr_SIZE,&(r._cdmac_lag_failover_status))

/*******************************************************************************
 * End of 'CDMAC_LAG_FAILOVER_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_LINK_INTR_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_LINK_INTR_CTRLr_OFFSET 0x04040400

#define CDMAC_LINK_INTR_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_LINK_INTR_CTRL.
 */
typedef union CDMAC_LINK_INTR_CTRLr_s {
    uint32_t v[1];
    uint32_t cdmac_link_intr_ctrl[1];
    uint32_t _cdmac_link_intr_ctrl;
} CDMAC_LINK_INTR_CTRLr_t;

#define CDMAC_LINK_INTR_CTRLr_CLR(r) (r).cdmac_link_intr_ctrl[0] = 0
#define CDMAC_LINK_INTR_CTRLr_SET(r,d) (r).cdmac_link_intr_ctrl[0] = d
#define CDMAC_LINK_INTR_CTRLr_GET(r) (r).cdmac_link_intr_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_LINK_INTR_CTRLr_ORDERED_SETf_GET(r) ((r).cdmac_link_intr_ctrl[0])
#define CDMAC_LINK_INTR_CTRLr_ORDERED_SETf_SET(r,f) (r).cdmac_link_intr_ctrl[0]=((uint32_t)f)

/*
 * These macros can be used to access CDMAC_LINK_INTR_CTRL.
 */
#define READ_CDMAC_LINK_INTR_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDMAC_LINK_INTR_CTRLr_OFFSET,0,CDMAC_LINK_INTR_CTRLr_SIZE,(r._cdmac_link_intr_ctrl))
#define WRITE_CDMAC_LINK_INTR_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDMAC_LINK_INTR_CTRLr_OFFSET,0,CDMAC_LINK_INTR_CTRLr_SIZE,&(r._cdmac_link_intr_ctrl))

/*******************************************************************************
 * End of 'CDMAC_LINK_INTR_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_LINK_INTR_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_LINK_INTR_STATUSr_OFFSET 0x04040800

#define CDMAC_LINK_INTR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_LINK_INTR_STATUS.
 */
typedef union CDMAC_LINK_INTR_STATUSr_s {
    uint32_t v[1];
    uint32_t cdmac_link_intr_status[1];
    uint32_t _cdmac_link_intr_status;
} CDMAC_LINK_INTR_STATUSr_t;

#define CDMAC_LINK_INTR_STATUSr_CLR(r) (r).cdmac_link_intr_status[0] = 0
#define CDMAC_LINK_INTR_STATUSr_SET(r,d) (r).cdmac_link_intr_status[0] = d
#define CDMAC_LINK_INTR_STATUSr_GET(r) (r).cdmac_link_intr_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_LINK_INTR_STATUSr_ORDERED_SETf_GET(r) ((r).cdmac_link_intr_status[0])
#define CDMAC_LINK_INTR_STATUSr_ORDERED_SETf_SET(r,f) (r).cdmac_link_intr_status[0]=((uint32_t)f)

/*
 * These macros can be used to access CDMAC_LINK_INTR_STATUS.
 */
#define READ_CDMAC_LINK_INTR_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDMAC_LINK_INTR_STATUSr_OFFSET,0,CDMAC_LINK_INTR_STATUSr_SIZE,(r._cdmac_link_intr_status))
#define WRITE_CDMAC_LINK_INTR_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDMAC_LINK_INTR_STATUSr_OFFSET,0,CDMAC_LINK_INTR_STATUSr_SIZE,&(r._cdmac_link_intr_status))

/*******************************************************************************
 * End of 'CDMAC_LINK_INTR_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_MEM_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_MEM_CTRLr_OFFSET 0x04041400

#define CDMAC_MEM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_MEM_CTRL.
 */
typedef union CDMAC_MEM_CTRLr_s {
    uint32_t v[1];
    uint32_t cdmac_mem_ctrl[1];
    uint32_t _cdmac_mem_ctrl;
} CDMAC_MEM_CTRLr_t;

#define CDMAC_MEM_CTRLr_CLR(r) (r).cdmac_mem_ctrl[0] = 0
#define CDMAC_MEM_CTRLr_SET(r,d) (r).cdmac_mem_ctrl[0] = d
#define CDMAC_MEM_CTRLr_GET(r) (r).cdmac_mem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_MEM_CTRLr_TX_CDC_MEM_CTRL_TMf_GET(r) (((r).cdmac_mem_ctrl[0]) & 0x1f)
#define CDMAC_MEM_CTRLr_TX_CDC_MEM_CTRL_TMf_SET(r,f) (r).cdmac_mem_ctrl[0]=(((r).cdmac_mem_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define CDMAC_MEM_CTRLr_MIB_COUNTER_MEM_CTRL_TMf_GET(r) ((((r).cdmac_mem_ctrl[0]) >> 5) & 0x1f)
#define CDMAC_MEM_CTRLr_MIB_COUNTER_MEM_CTRL_TMf_SET(r,f) (r).cdmac_mem_ctrl[0]=(((r).cdmac_mem_ctrl[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))

/*
 * These macros can be used to access CDMAC_MEM_CTRL.
 */
#define READ_CDMAC_MEM_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDMAC_MEM_CTRLr_OFFSET,0,CDMAC_MEM_CTRLr_SIZE,(r._cdmac_mem_ctrl))
#define WRITE_CDMAC_MEM_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDMAC_MEM_CTRLr_OFFSET,0,CDMAC_MEM_CTRLr_SIZE,&(r._cdmac_mem_ctrl))

/*******************************************************************************
 * End of 'CDMAC_MEM_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_MIB_COUNTER_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_MIB_COUNTER_CTRLr_OFFSET 0x14048400

#define CDMAC_MIB_COUNTER_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_MIB_COUNTER_CTRL.
 */
typedef union CDMAC_MIB_COUNTER_CTRLr_s {
    uint32_t v[1];
    uint32_t cdmac_mib_counter_ctrl[1];
    uint32_t _cdmac_mib_counter_ctrl;
} CDMAC_MIB_COUNTER_CTRLr_t;

#define CDMAC_MIB_COUNTER_CTRLr_CLR(r) (r).cdmac_mib_counter_ctrl[0] = 0
#define CDMAC_MIB_COUNTER_CTRLr_SET(r,d) (r).cdmac_mib_counter_ctrl[0] = d
#define CDMAC_MIB_COUNTER_CTRLr_GET(r) (r).cdmac_mib_counter_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_MIB_COUNTER_CTRLr_ENABLEf_GET(r) (((r).cdmac_mib_counter_ctrl[0]) & 0x1)
#define CDMAC_MIB_COUNTER_CTRLr_ENABLEf_SET(r,f) (r).cdmac_mib_counter_ctrl[0]=(((r).cdmac_mib_counter_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_MIB_COUNTER_CTRLr_CNT_CLEARf_GET(r) ((((r).cdmac_mib_counter_ctrl[0]) >> 1) & 0x1)
#define CDMAC_MIB_COUNTER_CTRLr_CNT_CLEARf_SET(r,f) (r).cdmac_mib_counter_ctrl[0]=(((r).cdmac_mib_counter_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDMAC_MIB_COUNTER_CTRLr_CNTMAXSIZEf_GET(r) ((((r).cdmac_mib_counter_ctrl[0]) >> 2) & 0x3fff)
#define CDMAC_MIB_COUNTER_CTRLr_CNTMAXSIZEf_SET(r,f) (r).cdmac_mib_counter_ctrl[0]=(((r).cdmac_mib_counter_ctrl[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))

/*
 * These macros can be used to access CDMAC_MIB_COUNTER_CTRL.
 */
#define READ_CDMAC_MIB_COUNTER_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDMAC_MIB_COUNTER_CTRLr_OFFSET,0,CDMAC_MIB_COUNTER_CTRLr_SIZE,(r._cdmac_mib_counter_ctrl))
#define WRITE_CDMAC_MIB_COUNTER_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDMAC_MIB_COUNTER_CTRLr_OFFSET,0,CDMAC_MIB_COUNTER_CTRLr_SIZE,&(r._cdmac_mib_counter_ctrl))

/*******************************************************************************
 * End of 'CDMAC_MIB_COUNTER_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_MIB_COUNTER_MODE
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_MIB_COUNTER_MODEr_OFFSET 0x04042c00

#define CDMAC_MIB_COUNTER_MODEr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_MIB_COUNTER_MODE.
 */
typedef union CDMAC_MIB_COUNTER_MODEr_s {
    uint32_t v[1];
    uint32_t cdmac_mib_counter_mode[1];
    uint32_t _cdmac_mib_counter_mode;
} CDMAC_MIB_COUNTER_MODEr_t;

#define CDMAC_MIB_COUNTER_MODEr_CLR(r) (r).cdmac_mib_counter_mode[0] = 0
#define CDMAC_MIB_COUNTER_MODEr_SET(r,d) (r).cdmac_mib_counter_mode[0] = d
#define CDMAC_MIB_COUNTER_MODEr_GET(r) (r).cdmac_mib_counter_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_MIB_COUNTER_MODEr_CLEAR_ON_READ_ENABLEf_GET(r) (((r).cdmac_mib_counter_mode[0]) & 0x1)
#define CDMAC_MIB_COUNTER_MODEr_CLEAR_ON_READ_ENABLEf_SET(r,f) (r).cdmac_mib_counter_mode[0]=(((r).cdmac_mib_counter_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_MIB_COUNTER_MODEr_SATURATE_ENABLEf_GET(r) ((((r).cdmac_mib_counter_mode[0]) >> 1) & 0x1)
#define CDMAC_MIB_COUNTER_MODEr_SATURATE_ENABLEf_SET(r,f) (r).cdmac_mib_counter_mode[0]=(((r).cdmac_mib_counter_mode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CDMAC_MIB_COUNTER_MODE.
 */
#define READ_CDMAC_MIB_COUNTER_MODEr(pa,p,r) bcmpmac_read(pa,p,CDMAC_MIB_COUNTER_MODEr_OFFSET,0,CDMAC_MIB_COUNTER_MODEr_SIZE,(r._cdmac_mib_counter_mode))
#define WRITE_CDMAC_MIB_COUNTER_MODEr(pa,p,r) bcmpmac_write(pa,p,CDMAC_MIB_COUNTER_MODEr_OFFSET,0,CDMAC_MIB_COUNTER_MODEr_SIZE,&(r._cdmac_mib_counter_mode))

/*******************************************************************************
 * End of 'CDMAC_MIB_COUNTER_MODEr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_OFFSET 0x04041c00

#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0.
 */
typedef union CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_s {
    uint32_t v[1];
    uint32_t cdmac_mib_counter_prog_range_cntr0[1];
    uint32_t _cdmac_mib_counter_prog_range_cntr0;
} CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_t;

#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_CLR(r) (r).cdmac_mib_counter_prog_range_cntr0[0] = 0
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_SET(r,d) (r).cdmac_mib_counter_prog_range_cntr0[0] = d
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_GET(r) (r).cdmac_mib_counter_prog_range_cntr0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_LOWERf_GET(r) (((r).cdmac_mib_counter_prog_range_cntr0[0]) & 0xffff)
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_LOWERf_SET(r,f) (r).cdmac_mib_counter_prog_range_cntr0[0]=(((r).cdmac_mib_counter_prog_range_cntr0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_UPPERf_GET(r) ((((r).cdmac_mib_counter_prog_range_cntr0[0]) >> 16) & 0xffff)
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_UPPERf_SET(r,f) (r).cdmac_mib_counter_prog_range_cntr0[0]=(((r).cdmac_mib_counter_prog_range_cntr0[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0.
 */
#define READ_CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r(pa,p,r) bcmpmac_read(pa,p,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_OFFSET,0,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_SIZE,(r._cdmac_mib_counter_prog_range_cntr0))
#define WRITE_CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r(pa,p,r) bcmpmac_write(pa,p,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_OFFSET,0,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r_SIZE,&(r._cdmac_mib_counter_prog_range_cntr0))

/*******************************************************************************
 * End of 'CDMAC_MIB_COUNTER_PROG_RANGE_CNTR0r'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_OFFSET 0x04042000

#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1.
 */
typedef union CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_s {
    uint32_t v[1];
    uint32_t cdmac_mib_counter_prog_range_cntr1[1];
    uint32_t _cdmac_mib_counter_prog_range_cntr1;
} CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_t;

#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_CLR(r) (r).cdmac_mib_counter_prog_range_cntr1[0] = 0
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_SET(r,d) (r).cdmac_mib_counter_prog_range_cntr1[0] = d
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_GET(r) (r).cdmac_mib_counter_prog_range_cntr1[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_LOWERf_GET(r) (((r).cdmac_mib_counter_prog_range_cntr1[0]) & 0xffff)
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_LOWERf_SET(r,f) (r).cdmac_mib_counter_prog_range_cntr1[0]=(((r).cdmac_mib_counter_prog_range_cntr1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_UPPERf_GET(r) ((((r).cdmac_mib_counter_prog_range_cntr1[0]) >> 16) & 0xffff)
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_UPPERf_SET(r,f) (r).cdmac_mib_counter_prog_range_cntr1[0]=(((r).cdmac_mib_counter_prog_range_cntr1[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1.
 */
#define READ_CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r(pa,p,r) bcmpmac_read(pa,p,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_OFFSET,0,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_SIZE,(r._cdmac_mib_counter_prog_range_cntr1))
#define WRITE_CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r(pa,p,r) bcmpmac_write(pa,p,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_OFFSET,0,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r_SIZE,&(r._cdmac_mib_counter_prog_range_cntr1))

/*******************************************************************************
 * End of 'CDMAC_MIB_COUNTER_PROG_RANGE_CNTR1r'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_OFFSET 0x04042400

#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2.
 */
typedef union CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_s {
    uint32_t v[1];
    uint32_t cdmac_mib_counter_prog_range_cntr2[1];
    uint32_t _cdmac_mib_counter_prog_range_cntr2;
} CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_t;

#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_CLR(r) (r).cdmac_mib_counter_prog_range_cntr2[0] = 0
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_SET(r,d) (r).cdmac_mib_counter_prog_range_cntr2[0] = d
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_GET(r) (r).cdmac_mib_counter_prog_range_cntr2[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_LOWERf_GET(r) (((r).cdmac_mib_counter_prog_range_cntr2[0]) & 0xffff)
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_LOWERf_SET(r,f) (r).cdmac_mib_counter_prog_range_cntr2[0]=(((r).cdmac_mib_counter_prog_range_cntr2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_UPPERf_GET(r) ((((r).cdmac_mib_counter_prog_range_cntr2[0]) >> 16) & 0xffff)
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_UPPERf_SET(r,f) (r).cdmac_mib_counter_prog_range_cntr2[0]=(((r).cdmac_mib_counter_prog_range_cntr2[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2.
 */
#define READ_CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r(pa,p,r) bcmpmac_read(pa,p,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_OFFSET,0,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_SIZE,(r._cdmac_mib_counter_prog_range_cntr2))
#define WRITE_CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r(pa,p,r) bcmpmac_write(pa,p,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_OFFSET,0,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r_SIZE,&(r._cdmac_mib_counter_prog_range_cntr2))

/*******************************************************************************
 * End of 'CDMAC_MIB_COUNTER_PROG_RANGE_CNTR2r'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_OFFSET 0x04042800

#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3.
 */
typedef union CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_s {
    uint32_t v[1];
    uint32_t cdmac_mib_counter_prog_range_cntr3[1];
    uint32_t _cdmac_mib_counter_prog_range_cntr3;
} CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_t;

#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_CLR(r) (r).cdmac_mib_counter_prog_range_cntr3[0] = 0
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_SET(r,d) (r).cdmac_mib_counter_prog_range_cntr3[0] = d
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_GET(r) (r).cdmac_mib_counter_prog_range_cntr3[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_LOWERf_GET(r) (((r).cdmac_mib_counter_prog_range_cntr3[0]) & 0xffff)
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_LOWERf_SET(r,f) (r).cdmac_mib_counter_prog_range_cntr3[0]=(((r).cdmac_mib_counter_prog_range_cntr3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_UPPERf_GET(r) ((((r).cdmac_mib_counter_prog_range_cntr3[0]) >> 16) & 0xffff)
#define CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_UPPERf_SET(r,f) (r).cdmac_mib_counter_prog_range_cntr3[0]=(((r).cdmac_mib_counter_prog_range_cntr3[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3.
 */
#define READ_CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r(pa,p,r) bcmpmac_read(pa,p,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_OFFSET,0,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_SIZE,(r._cdmac_mib_counter_prog_range_cntr3))
#define WRITE_CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r(pa,p,r) bcmpmac_write(pa,p,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_OFFSET,0,CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r_SIZE,&(r._cdmac_mib_counter_prog_range_cntr3))

/*******************************************************************************
 * End of 'CDMAC_MIB_COUNTER_PROG_RANGE_CNTR3r'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_MODE
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_MODEr_OFFSET 0x14043400

#define CDMAC_MODEr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_MODE.
 */
typedef union CDMAC_MODEr_s {
    uint32_t v[1];
    uint32_t cdmac_mode[1];
    uint32_t _cdmac_mode;
} CDMAC_MODEr_t;

#define CDMAC_MODEr_CLR(r) (r).cdmac_mode[0] = 0
#define CDMAC_MODEr_SET(r,d) (r).cdmac_mode[0] = d
#define CDMAC_MODEr_GET(r) (r).cdmac_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_MODEr_HDR_MODEf_GET(r) (((r).cdmac_mode[0]) & 0x7)
#define CDMAC_MODEr_HDR_MODEf_SET(r,f) (r).cdmac_mode[0]=(((r).cdmac_mode[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access CDMAC_MODE.
 */
#define READ_CDMAC_MODEr(pa,p,r) bcmpmac_read(pa,p,CDMAC_MODEr_OFFSET,0,CDMAC_MODEr_SIZE,(r._cdmac_mode))
#define WRITE_CDMAC_MODEr(pa,p,r) bcmpmac_write(pa,p,CDMAC_MODEr_OFFSET,0,CDMAC_MODEr_SIZE,&(r._cdmac_mode))

/*******************************************************************************
 * End of 'CDMAC_MODEr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_PAUSE_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     64
 */
#define CDMAC_PAUSE_CTRLr_OFFSET 0x14045800

#define CDMAC_PAUSE_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CDMAC_PAUSE_CTRL.
 */
typedef union CDMAC_PAUSE_CTRLr_s {
    uint32_t v[2];
    uint32_t cdmac_pause_ctrl[2];
    uint32_t _cdmac_pause_ctrl;
} CDMAC_PAUSE_CTRLr_t;

#define CDMAC_PAUSE_CTRLr_CLR(r) sal_memset(&((r).cdmac_pause_ctrl[0]), 0, sizeof(CDMAC_PAUSE_CTRLr_t))
#define CDMAC_PAUSE_CTRLr_SET(r,i,d) (r).cdmac_pause_ctrl[i] = d
#define CDMAC_PAUSE_CTRLr_GET(r,i) (r).cdmac_pause_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_PAUSE_CTRLr_PAUSE_REFRESH_TIMERf_GET(r) (((r).cdmac_pause_ctrl[0]) & 0xffff)
#define CDMAC_PAUSE_CTRLr_PAUSE_REFRESH_TIMERf_SET(r,f) (r).cdmac_pause_ctrl[0]=(((r).cdmac_pause_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CDMAC_PAUSE_CTRLr_PFC_REFRESH_TIMERf_GET(r) (((r).cdmac_pause_ctrl[0]) & 0xffff)
#define CDMAC_PAUSE_CTRLr_PFC_REFRESH_TIMERf_SET(r,f) (r).cdmac_pause_ctrl[0]=(((r).cdmac_pause_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CDMAC_PAUSE_CTRLr_PFC_REFRESH_ENf_GET(r) ((((r).cdmac_pause_ctrl[0]) >> 16) & 0x1)
#define CDMAC_PAUSE_CTRLr_PFC_REFRESH_ENf_SET(r,f) (r).cdmac_pause_ctrl[0]=(((r).cdmac_pause_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CDMAC_PAUSE_CTRLr_PAUSE_REFRESH_ENf_GET(r) ((((r).cdmac_pause_ctrl[0]) >> 17) & 0x1)
#define CDMAC_PAUSE_CTRLr_PAUSE_REFRESH_ENf_SET(r,f) (r).cdmac_pause_ctrl[0]=(((r).cdmac_pause_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CDMAC_PAUSE_CTRLr_TX_PAUSE_ENf_GET(r) ((((r).cdmac_pause_ctrl[0]) >> 18) & 0x1)
#define CDMAC_PAUSE_CTRLr_TX_PAUSE_ENf_SET(r,f) (r).cdmac_pause_ctrl[0]=(((r).cdmac_pause_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CDMAC_PAUSE_CTRLr_RX_PAUSE_ENf_GET(r) ((((r).cdmac_pause_ctrl[0]) >> 19) & 0x1)
#define CDMAC_PAUSE_CTRLr_RX_PAUSE_ENf_SET(r,f) (r).cdmac_pause_ctrl[0]=(((r).cdmac_pause_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CDMAC_PAUSE_CTRLr_PAUSE_XOFF_TIMERf_GET(r) bcmpmac_field32_get((r).cdmac_pause_ctrl,20,35)
#define CDMAC_PAUSE_CTRLr_PAUSE_XOFF_TIMERf_SET(r,f) bcmpmac_field32_set((r).cdmac_pause_ctrl,20,35,f)
#define CDMAC_PAUSE_CTRLr_PFC_XOFF_TIMERf_GET(r) bcmpmac_field32_get((r).cdmac_pause_ctrl,20,35)
#define CDMAC_PAUSE_CTRLr_PFC_XOFF_TIMERf_SET(r,f) bcmpmac_field32_set((r).cdmac_pause_ctrl,20,35,f)

/*
 * These macros can be used to access CDMAC_PAUSE_CTRL.
 */
#define READ_CDMAC_PAUSE_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDMAC_PAUSE_CTRLr_OFFSET,0,CDMAC_PAUSE_CTRLr_SIZE,(r._cdmac_pause_ctrl))
#define WRITE_CDMAC_PAUSE_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDMAC_PAUSE_CTRLr_OFFSET,0,CDMAC_PAUSE_CTRLr_SIZE,&(r._cdmac_pause_ctrl))

/*******************************************************************************
 * End of 'CDMAC_PAUSE_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_PFC_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_PFC_CTRLr_OFFSET 0x14045c00

#define CDMAC_PFC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_PFC_CTRL.
 */
typedef union CDMAC_PFC_CTRLr_s {
    uint32_t v[1];
    uint32_t cdmac_pfc_ctrl[1];
    uint32_t _cdmac_pfc_ctrl;
} CDMAC_PFC_CTRLr_t;

#define CDMAC_PFC_CTRLr_CLR(r) (r).cdmac_pfc_ctrl[0] = 0
#define CDMAC_PFC_CTRLr_SET(r,d) (r).cdmac_pfc_ctrl[0] = d
#define CDMAC_PFC_CTRLr_GET(r) (r).cdmac_pfc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_PFC_CTRLr_FORCE_PFC_XONf_GET(r) (((r).cdmac_pfc_ctrl[0]) & 0x1)
#define CDMAC_PFC_CTRLr_FORCE_PFC_XONf_SET(r,f) (r).cdmac_pfc_ctrl[0]=(((r).cdmac_pfc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_PFC_CTRLr_PFC_STATS_ENf_GET(r) ((((r).cdmac_pfc_ctrl[0]) >> 1) & 0x1)
#define CDMAC_PFC_CTRLr_PFC_STATS_ENf_SET(r,f) (r).cdmac_pfc_ctrl[0]=(((r).cdmac_pfc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDMAC_PFC_CTRLr_RX_PFC_ENf_GET(r) ((((r).cdmac_pfc_ctrl[0]) >> 2) & 0x1)
#define CDMAC_PFC_CTRLr_RX_PFC_ENf_SET(r,f) (r).cdmac_pfc_ctrl[0]=(((r).cdmac_pfc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CDMAC_PFC_CTRLr_TX_PFC_ENf_GET(r) ((((r).cdmac_pfc_ctrl[0]) >> 3) & 0x1)
#define CDMAC_PFC_CTRLr_TX_PFC_ENf_SET(r,f) (r).cdmac_pfc_ctrl[0]=(((r).cdmac_pfc_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CDMAC_PFC_CTRL.
 */
#define READ_CDMAC_PFC_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDMAC_PFC_CTRLr_OFFSET,0,CDMAC_PFC_CTRLr_SIZE,(r._cdmac_pfc_ctrl))
#define WRITE_CDMAC_PFC_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDMAC_PFC_CTRLr_OFFSET,0,CDMAC_PFC_CTRLr_SIZE,&(r._cdmac_pfc_ctrl))

/*******************************************************************************
 * End of 'CDMAC_PFC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_PFC_DA
 * BLOCKS:   CDPORT
 * SIZE:     64
 */
#define CDMAC_PFC_DAr_OFFSET 0x14046800

#define CDMAC_PFC_DAr_SIZE 8

/*
 * This structure should be used to declare and program CDMAC_PFC_DA.
 */
typedef union CDMAC_PFC_DAr_s {
    uint32_t v[2];
    uint32_t cdmac_pfc_da[2];
    uint32_t _cdmac_pfc_da;
} CDMAC_PFC_DAr_t;

#define CDMAC_PFC_DAr_CLR(r) sal_memset(&((r).cdmac_pfc_da[0]), 0, sizeof(CDMAC_PFC_DAr_t))
#define CDMAC_PFC_DAr_SET(r,i,d) (r).cdmac_pfc_da[i] = d
#define CDMAC_PFC_DAr_GET(r,i) (r).cdmac_pfc_da[i]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_PFC_DAr_PFC_MACDAf_GET(r,a) bcmpmac_field_get((r).cdmac_pfc_da,0,47,a)
#define CDMAC_PFC_DAr_PFC_MACDAf_SET(r,a) bcmpmac_field_set((r).cdmac_pfc_da,0,47,a)

/*
 * These macros can be used to access CDMAC_PFC_DA.
 */
#define READ_CDMAC_PFC_DAr(pa,p,r) bcmpmac_read(pa,p,CDMAC_PFC_DAr_OFFSET,0,CDMAC_PFC_DAr_SIZE,(r._cdmac_pfc_da))
#define WRITE_CDMAC_PFC_DAr(pa,p,r) bcmpmac_write(pa,p,CDMAC_PFC_DAr_OFFSET,0,CDMAC_PFC_DAr_SIZE,&(r._cdmac_pfc_da))

/*******************************************************************************
 * End of 'CDMAC_PFC_DAr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_PFC_OPCODE
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_PFC_OPCODEr_OFFSET 0x14046400

#define CDMAC_PFC_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_PFC_OPCODE.
 */
typedef union CDMAC_PFC_OPCODEr_s {
    uint32_t v[1];
    uint32_t cdmac_pfc_opcode[1];
    uint32_t _cdmac_pfc_opcode;
} CDMAC_PFC_OPCODEr_t;

#define CDMAC_PFC_OPCODEr_CLR(r) (r).cdmac_pfc_opcode[0] = 0
#define CDMAC_PFC_OPCODEr_SET(r,d) (r).cdmac_pfc_opcode[0] = d
#define CDMAC_PFC_OPCODEr_GET(r) (r).cdmac_pfc_opcode[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_PFC_OPCODEr_PFC_OPCODEf_GET(r) (((r).cdmac_pfc_opcode[0]) & 0xffff)
#define CDMAC_PFC_OPCODEr_PFC_OPCODEf_SET(r,f) (r).cdmac_pfc_opcode[0]=(((r).cdmac_pfc_opcode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CDMAC_PFC_OPCODE.
 */
#define READ_CDMAC_PFC_OPCODEr(pa,p,r) bcmpmac_read(pa,p,CDMAC_PFC_OPCODEr_OFFSET,0,CDMAC_PFC_OPCODEr_SIZE,(r._cdmac_pfc_opcode))
#define WRITE_CDMAC_PFC_OPCODEr(pa,p,r) bcmpmac_write(pa,p,CDMAC_PFC_OPCODEr_OFFSET,0,CDMAC_PFC_OPCODEr_SIZE,&(r._cdmac_pfc_opcode))

/*******************************************************************************
 * End of 'CDMAC_PFC_OPCODEr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_PFC_TYPE
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_PFC_TYPEr_OFFSET 0x14046000

#define CDMAC_PFC_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_PFC_TYPE.
 */
typedef union CDMAC_PFC_TYPEr_s {
    uint32_t v[1];
    uint32_t cdmac_pfc_type[1];
    uint32_t _cdmac_pfc_type;
} CDMAC_PFC_TYPEr_t;

#define CDMAC_PFC_TYPEr_CLR(r) (r).cdmac_pfc_type[0] = 0
#define CDMAC_PFC_TYPEr_SET(r,d) (r).cdmac_pfc_type[0] = d
#define CDMAC_PFC_TYPEr_GET(r) (r).cdmac_pfc_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_PFC_TYPEr_PFC_ETH_TYPEf_GET(r) (((r).cdmac_pfc_type[0]) & 0xffff)
#define CDMAC_PFC_TYPEr_PFC_ETH_TYPEf_SET(r,f) (r).cdmac_pfc_type[0]=(((r).cdmac_pfc_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CDMAC_PFC_TYPE.
 */
#define READ_CDMAC_PFC_TYPEr(pa,p,r) bcmpmac_read(pa,p,CDMAC_PFC_TYPEr_OFFSET,0,CDMAC_PFC_TYPEr_SIZE,(r._cdmac_pfc_type))
#define WRITE_CDMAC_PFC_TYPEr(pa,p,r) bcmpmac_write(pa,p,CDMAC_PFC_TYPEr_OFFSET,0,CDMAC_PFC_TYPEr_SIZE,&(r._cdmac_pfc_type))

/*******************************************************************************
 * End of 'CDMAC_PFC_TYPEr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_RSV_MASK
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_RSV_MASKr_OFFSET 0x14048000

#define CDMAC_RSV_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_RSV_MASK.
 */
typedef union CDMAC_RSV_MASKr_s {
    uint32_t v[1];
    uint32_t cdmac_rsv_mask[1];
    uint32_t _cdmac_rsv_mask;
} CDMAC_RSV_MASKr_t;

#define CDMAC_RSV_MASKr_CLR(r) (r).cdmac_rsv_mask[0] = 0
#define CDMAC_RSV_MASKr_SET(r,d) (r).cdmac_rsv_mask[0] = d
#define CDMAC_RSV_MASKr_GET(r) (r).cdmac_rsv_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_RSV_MASKr_MASKf_GET(r) (((r).cdmac_rsv_mask[0]) & 0x7ffff)
#define CDMAC_RSV_MASKr_MASKf_SET(r,f) (r).cdmac_rsv_mask[0]=(((r).cdmac_rsv_mask[0] & ~((uint32_t)0x7ffff)) | (((uint32_t)f) & 0x7ffff))

/*
 * These macros can be used to access CDMAC_RSV_MASK.
 */
#define READ_CDMAC_RSV_MASKr(pa,p,r) bcmpmac_read(pa,p,CDMAC_RSV_MASKr_OFFSET,0,CDMAC_RSV_MASKr_SIZE,(r._cdmac_rsv_mask))
#define WRITE_CDMAC_RSV_MASKr(pa,p,r) bcmpmac_write(pa,p,CDMAC_RSV_MASKr_OFFSET,0,CDMAC_RSV_MASKr_SIZE,&(r._cdmac_rsv_mask))

/*******************************************************************************
 * End of 'CDMAC_RSV_MASKr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_RX_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_RX_CTRLr_OFFSET 0x14044000

#define CDMAC_RX_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_RX_CTRL.
 */
typedef union CDMAC_RX_CTRLr_s {
    uint32_t v[1];
    uint32_t cdmac_rx_ctrl[1];
    uint32_t _cdmac_rx_ctrl;
} CDMAC_RX_CTRLr_t;

#define CDMAC_RX_CTRLr_CLR(r) (r).cdmac_rx_ctrl[0] = 0
#define CDMAC_RX_CTRLr_SET(r,d) (r).cdmac_rx_ctrl[0] = d
#define CDMAC_RX_CTRLr_GET(r) (r).cdmac_rx_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_RX_CTRLr_STRIP_CRCf_GET(r) ((((r).cdmac_rx_ctrl[0]) >> 2) & 0x1)
#define CDMAC_RX_CTRLr_STRIP_CRCf_SET(r,f) (r).cdmac_rx_ctrl[0]=(((r).cdmac_rx_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CDMAC_RX_CTRLr_STRICT_SFDf_GET(r) ((((r).cdmac_rx_ctrl[0]) >> 3) & 0x1)
#define CDMAC_RX_CTRLr_STRICT_SFDf_SET(r,f) (r).cdmac_rx_ctrl[0]=(((r).cdmac_rx_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CDMAC_RX_CTRLr_RUNT_THRESHOLDf_GET(r) ((((r).cdmac_rx_ctrl[0]) >> 4) & 0x7f)
#define CDMAC_RX_CTRLr_RUNT_THRESHOLDf_SET(r,f) (r).cdmac_rx_ctrl[0]=(((r).cdmac_rx_ctrl[0] & ~((uint32_t)0x7f << 4)) | ((((uint32_t)f) & 0x7f) << 4))
#define CDMAC_RX_CTRLr_RX_PASS_CTRLf_GET(r) ((((r).cdmac_rx_ctrl[0]) >> 13) & 0x1)
#define CDMAC_RX_CTRLr_RX_PASS_CTRLf_SET(r,f) (r).cdmac_rx_ctrl[0]=(((r).cdmac_rx_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CDMAC_RX_CTRLr_RX_PASS_PAUSEf_GET(r) ((((r).cdmac_rx_ctrl[0]) >> 14) & 0x1)
#define CDMAC_RX_CTRLr_RX_PASS_PAUSEf_SET(r,f) (r).cdmac_rx_ctrl[0]=(((r).cdmac_rx_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CDMAC_RX_CTRLr_RX_PASS_PFCf_GET(r) ((((r).cdmac_rx_ctrl[0]) >> 15) & 0x1)
#define CDMAC_RX_CTRLr_RX_PASS_PFCf_SET(r,f) (r).cdmac_rx_ctrl[0]=(((r).cdmac_rx_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CDMAC_RX_CTRLr_DA_TIMESTAMP_ENf_GET(r) ((((r).cdmac_rx_ctrl[0]) >> 16) & 0x1)
#define CDMAC_RX_CTRLr_DA_TIMESTAMP_ENf_SET(r,f) (r).cdmac_rx_ctrl[0]=(((r).cdmac_rx_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access CDMAC_RX_CTRL.
 */
#define READ_CDMAC_RX_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDMAC_RX_CTRLr_OFFSET,0,CDMAC_RX_CTRLr_SIZE,(r._cdmac_rx_ctrl))
#define WRITE_CDMAC_RX_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDMAC_RX_CTRLr_OFFSET,0,CDMAC_RX_CTRLr_SIZE,&(r._cdmac_rx_ctrl))

/*******************************************************************************
 * End of 'CDMAC_RX_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_RX_LSS_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_RX_LSS_CTRLr_OFFSET 0x14045000

#define CDMAC_RX_LSS_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_RX_LSS_CTRL.
 */
typedef union CDMAC_RX_LSS_CTRLr_s {
    uint32_t v[1];
    uint32_t cdmac_rx_lss_ctrl[1];
    uint32_t _cdmac_rx_lss_ctrl;
} CDMAC_RX_LSS_CTRLr_t;

#define CDMAC_RX_LSS_CTRLr_CLR(r) (r).cdmac_rx_lss_ctrl[0] = 0
#define CDMAC_RX_LSS_CTRLr_SET(r,d) (r).cdmac_rx_lss_ctrl[0] = d
#define CDMAC_RX_LSS_CTRLr_GET(r) (r).cdmac_rx_lss_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_RX_LSS_CTRLr_LOCAL_FAULT_DISABLEf_GET(r) (((r).cdmac_rx_lss_ctrl[0]) & 0x1)
#define CDMAC_RX_LSS_CTRLr_LOCAL_FAULT_DISABLEf_SET(r,f) (r).cdmac_rx_lss_ctrl[0]=(((r).cdmac_rx_lss_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_RX_LSS_CTRLr_REMOTE_FAULT_DISABLEf_GET(r) ((((r).cdmac_rx_lss_ctrl[0]) >> 1) & 0x1)
#define CDMAC_RX_LSS_CTRLr_REMOTE_FAULT_DISABLEf_SET(r,f) (r).cdmac_rx_lss_ctrl[0]=(((r).cdmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDMAC_RX_LSS_CTRLr_LINK_INTERRUPTION_DISABLEf_GET(r) ((((r).cdmac_rx_lss_ctrl[0]) >> 3) & 0x1)
#define CDMAC_RX_LSS_CTRLr_LINK_INTERRUPTION_DISABLEf_SET(r,f) (r).cdmac_rx_lss_ctrl[0]=(((r).cdmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CDMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LOCAL_FAULTf_GET(r) ((((r).cdmac_rx_lss_ctrl[0]) >> 4) & 0x1)
#define CDMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LOCAL_FAULTf_SET(r,f) (r).cdmac_rx_lss_ctrl[0]=(((r).cdmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CDMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_REMOTE_FAULTf_GET(r) ((((r).cdmac_rx_lss_ctrl[0]) >> 5) & 0x1)
#define CDMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_REMOTE_FAULTf_SET(r,f) (r).cdmac_rx_lss_ctrl[0]=(((r).cdmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CDMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LINK_INTERRUPTf_GET(r) ((((r).cdmac_rx_lss_ctrl[0]) >> 6) & 0x1)
#define CDMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LINK_INTERRUPTf_SET(r,f) (r).cdmac_rx_lss_ctrl[0]=(((r).cdmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CDMAC_RX_LSS_CTRLr_RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWNf_GET(r) ((((r).cdmac_rx_lss_ctrl[0]) >> 7) & 0x1)
#define CDMAC_RX_LSS_CTRLr_RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWNf_SET(r,f) (r).cdmac_rx_lss_ctrl[0]=(((r).cdmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CDMAC_RX_LSS_CTRLr_FORCE_LOCAL_FAULT_OSf_GET(r) ((((r).cdmac_rx_lss_ctrl[0]) >> 8) & 0x1)
#define CDMAC_RX_LSS_CTRLr_FORCE_LOCAL_FAULT_OSf_SET(r,f) (r).cdmac_rx_lss_ctrl[0]=(((r).cdmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CDMAC_RX_LSS_CTRLr_FORCE_REMOTE_FAULT_OSf_GET(r) ((((r).cdmac_rx_lss_ctrl[0]) >> 9) & 0x1)
#define CDMAC_RX_LSS_CTRLr_FORCE_REMOTE_FAULT_OSf_SET(r,f) (r).cdmac_rx_lss_ctrl[0]=(((r).cdmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CDMAC_RX_LSS_CTRLr_FORCE_LINK_INTERRUPT_OSf_GET(r) ((((r).cdmac_rx_lss_ctrl[0]) >> 10) & 0x1)
#define CDMAC_RX_LSS_CTRLr_FORCE_LINK_INTERRUPT_OSf_SET(r,f) (r).cdmac_rx_lss_ctrl[0]=(((r).cdmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CDMAC_RX_LSS_CTRLr_FAULT_SOURCE_FOR_TXf_GET(r) ((((r).cdmac_rx_lss_ctrl[0]) >> 11) & 0x3)
#define CDMAC_RX_LSS_CTRLr_FAULT_SOURCE_FOR_TXf_SET(r,f) (r).cdmac_rx_lss_ctrl[0]=(((r).cdmac_rx_lss_ctrl[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))

/*
 * These macros can be used to access CDMAC_RX_LSS_CTRL.
 */
#define READ_CDMAC_RX_LSS_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDMAC_RX_LSS_CTRLr_OFFSET,0,CDMAC_RX_LSS_CTRLr_SIZE,(r._cdmac_rx_lss_ctrl))
#define WRITE_CDMAC_RX_LSS_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDMAC_RX_LSS_CTRLr_OFFSET,0,CDMAC_RX_LSS_CTRLr_SIZE,&(r._cdmac_rx_lss_ctrl))

/*******************************************************************************
 * End of 'CDMAC_RX_LSS_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_RX_LSS_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_RX_LSS_STATUSr_OFFSET 0x14045400

#define CDMAC_RX_LSS_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_RX_LSS_STATUS.
 */
typedef union CDMAC_RX_LSS_STATUSr_s {
    uint32_t v[1];
    uint32_t cdmac_rx_lss_status[1];
    uint32_t _cdmac_rx_lss_status;
} CDMAC_RX_LSS_STATUSr_t;

#define CDMAC_RX_LSS_STATUSr_CLR(r) (r).cdmac_rx_lss_status[0] = 0
#define CDMAC_RX_LSS_STATUSr_SET(r,d) (r).cdmac_rx_lss_status[0] = d
#define CDMAC_RX_LSS_STATUSr_GET(r) (r).cdmac_rx_lss_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_RX_LSS_STATUSr_LOCAL_FAULT_STATUSf_GET(r) (((r).cdmac_rx_lss_status[0]) & 0x1)
#define CDMAC_RX_LSS_STATUSr_LOCAL_FAULT_STATUSf_SET(r,f) (r).cdmac_rx_lss_status[0]=(((r).cdmac_rx_lss_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_RX_LSS_STATUSr_REMOTE_FAULT_STATUSf_GET(r) ((((r).cdmac_rx_lss_status[0]) >> 1) & 0x1)
#define CDMAC_RX_LSS_STATUSr_REMOTE_FAULT_STATUSf_SET(r,f) (r).cdmac_rx_lss_status[0]=(((r).cdmac_rx_lss_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_STATUSf_GET(r) ((((r).cdmac_rx_lss_status[0]) >> 2) & 0x1)
#define CDMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_STATUSf_SET(r,f) (r).cdmac_rx_lss_status[0]=(((r).cdmac_rx_lss_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CDMAC_RX_LSS_STATUSr_LOCAL_FAULT_LIVE_STATUSf_GET(r) ((((r).cdmac_rx_lss_status[0]) >> 3) & 0x1)
#define CDMAC_RX_LSS_STATUSr_LOCAL_FAULT_LIVE_STATUSf_SET(r,f) (r).cdmac_rx_lss_status[0]=(((r).cdmac_rx_lss_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CDMAC_RX_LSS_STATUSr_REMOTE_FAULT_LIVE_STATUSf_GET(r) ((((r).cdmac_rx_lss_status[0]) >> 4) & 0x1)
#define CDMAC_RX_LSS_STATUSr_REMOTE_FAULT_LIVE_STATUSf_SET(r,f) (r).cdmac_rx_lss_status[0]=(((r).cdmac_rx_lss_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CDMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_LIVE_STATUSf_GET(r) ((((r).cdmac_rx_lss_status[0]) >> 5) & 0x1)
#define CDMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_LIVE_STATUSf_SET(r,f) (r).cdmac_rx_lss_status[0]=(((r).cdmac_rx_lss_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access CDMAC_RX_LSS_STATUS.
 */
#define READ_CDMAC_RX_LSS_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDMAC_RX_LSS_STATUSr_OFFSET,0,CDMAC_RX_LSS_STATUSr_SIZE,(r._cdmac_rx_lss_status))
#define WRITE_CDMAC_RX_LSS_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDMAC_RX_LSS_STATUSr_OFFSET,0,CDMAC_RX_LSS_STATUSr_SIZE,&(r._cdmac_rx_lss_status))

/*******************************************************************************
 * End of 'CDMAC_RX_LSS_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_RX_MAC_SA
 * BLOCKS:   CDPORT
 * SIZE:     64
 */
#define CDMAC_RX_MAC_SAr_OFFSET 0x14044400

#define CDMAC_RX_MAC_SAr_SIZE 8

/*
 * This structure should be used to declare and program CDMAC_RX_MAC_SA.
 */
typedef union CDMAC_RX_MAC_SAr_s {
    uint32_t v[2];
    uint32_t cdmac_rx_mac_sa[2];
    uint32_t _cdmac_rx_mac_sa;
} CDMAC_RX_MAC_SAr_t;

#define CDMAC_RX_MAC_SAr_CLR(r) sal_memset(&((r).cdmac_rx_mac_sa[0]), 0, sizeof(CDMAC_RX_MAC_SAr_t))
#define CDMAC_RX_MAC_SAr_SET(r,i,d) (r).cdmac_rx_mac_sa[i] = d
#define CDMAC_RX_MAC_SAr_GET(r,i) (r).cdmac_rx_mac_sa[i]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_RX_MAC_SAr_RX_SAf_GET(r,a) bcmpmac_field_get((r).cdmac_rx_mac_sa,0,47,a)
#define CDMAC_RX_MAC_SAr_RX_SAf_SET(r,a) bcmpmac_field_set((r).cdmac_rx_mac_sa,0,47,a)

/*
 * These macros can be used to access CDMAC_RX_MAC_SA.
 */
#define READ_CDMAC_RX_MAC_SAr(pa,p,r) bcmpmac_read(pa,p,CDMAC_RX_MAC_SAr_OFFSET,0,CDMAC_RX_MAC_SAr_SIZE,(r._cdmac_rx_mac_sa))
#define WRITE_CDMAC_RX_MAC_SAr(pa,p,r) bcmpmac_write(pa,p,CDMAC_RX_MAC_SAr_OFFSET,0,CDMAC_RX_MAC_SAr_SIZE,&(r._cdmac_rx_mac_sa))

/*******************************************************************************
 * End of 'CDMAC_RX_MAC_SAr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_RX_MAX_SIZE
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_RX_MAX_SIZEr_OFFSET 0x14044800

#define CDMAC_RX_MAX_SIZEr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_RX_MAX_SIZE.
 */
typedef union CDMAC_RX_MAX_SIZEr_s {
    uint32_t v[1];
    uint32_t cdmac_rx_max_size[1];
    uint32_t _cdmac_rx_max_size;
} CDMAC_RX_MAX_SIZEr_t;

#define CDMAC_RX_MAX_SIZEr_CLR(r) (r).cdmac_rx_max_size[0] = 0
#define CDMAC_RX_MAX_SIZEr_SET(r,d) (r).cdmac_rx_max_size[0] = d
#define CDMAC_RX_MAX_SIZEr_GET(r) (r).cdmac_rx_max_size[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_RX_MAX_SIZEr_RX_MAX_SIZEf_GET(r) (((r).cdmac_rx_max_size[0]) & 0x3fff)
#define CDMAC_RX_MAX_SIZEr_RX_MAX_SIZEf_SET(r,f) (r).cdmac_rx_max_size[0]=(((r).cdmac_rx_max_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CDMAC_RX_MAX_SIZE.
 */
#define READ_CDMAC_RX_MAX_SIZEr(pa,p,r) bcmpmac_read(pa,p,CDMAC_RX_MAX_SIZEr_OFFSET,0,CDMAC_RX_MAX_SIZEr_SIZE,(r._cdmac_rx_max_size))
#define WRITE_CDMAC_RX_MAX_SIZEr(pa,p,r) bcmpmac_write(pa,p,CDMAC_RX_MAX_SIZEr_OFFSET,0,CDMAC_RX_MAX_SIZEr_SIZE,&(r._cdmac_rx_max_size))

/*******************************************************************************
 * End of 'CDMAC_RX_MAX_SIZEr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_RX_VLAN_TAG
 * BLOCKS:   CDPORT
 * SIZE:     64
 */
#define CDMAC_RX_VLAN_TAGr_OFFSET 0x14044c00

#define CDMAC_RX_VLAN_TAGr_SIZE 8

/*
 * This structure should be used to declare and program CDMAC_RX_VLAN_TAG.
 */
typedef union CDMAC_RX_VLAN_TAGr_s {
    uint32_t v[2];
    uint32_t cdmac_rx_vlan_tag[2];
    uint32_t _cdmac_rx_vlan_tag;
} CDMAC_RX_VLAN_TAGr_t;

#define CDMAC_RX_VLAN_TAGr_CLR(r) sal_memset(&((r).cdmac_rx_vlan_tag[0]), 0, sizeof(CDMAC_RX_VLAN_TAGr_t))
#define CDMAC_RX_VLAN_TAGr_SET(r,i,d) (r).cdmac_rx_vlan_tag[i] = d
#define CDMAC_RX_VLAN_TAGr_GET(r,i) (r).cdmac_rx_vlan_tag[i]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_RX_VLAN_TAGr_INNER_VLAN_TAGf_GET(r) (((r).cdmac_rx_vlan_tag[0]) & 0xffff)
#define CDMAC_RX_VLAN_TAGr_INNER_VLAN_TAGf_SET(r,f) (r).cdmac_rx_vlan_tag[0]=(((r).cdmac_rx_vlan_tag[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CDMAC_RX_VLAN_TAGr_OUTER_VLAN_TAGf_GET(r) ((((r).cdmac_rx_vlan_tag[0]) >> 16) & 0xffff)
#define CDMAC_RX_VLAN_TAGr_OUTER_VLAN_TAGf_SET(r,f) (r).cdmac_rx_vlan_tag[0]=(((r).cdmac_rx_vlan_tag[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define CDMAC_RX_VLAN_TAGr_INNER_VLAN_TAG_ENABLEf_GET(r) (((r).cdmac_rx_vlan_tag[1]) & 0x1)
#define CDMAC_RX_VLAN_TAGr_INNER_VLAN_TAG_ENABLEf_SET(r,f) (r).cdmac_rx_vlan_tag[1]=(((r).cdmac_rx_vlan_tag[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDMAC_RX_VLAN_TAGr_OUTER_VLAN_TAG_ENABLEf_GET(r) ((((r).cdmac_rx_vlan_tag[1]) >> 1) & 0x1)
#define CDMAC_RX_VLAN_TAGr_OUTER_VLAN_TAG_ENABLEf_SET(r,f) (r).cdmac_rx_vlan_tag[1]=(((r).cdmac_rx_vlan_tag[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CDMAC_RX_VLAN_TAG.
 */
#define READ_CDMAC_RX_VLAN_TAGr(pa,p,r) bcmpmac_read(pa,p,CDMAC_RX_VLAN_TAGr_OFFSET,0,CDMAC_RX_VLAN_TAGr_SIZE,(r._cdmac_rx_vlan_tag))
#define WRITE_CDMAC_RX_VLAN_TAGr(pa,p,r) bcmpmac_write(pa,p,CDMAC_RX_VLAN_TAGr_OFFSET,0,CDMAC_RX_VLAN_TAGr_SIZE,&(r._cdmac_rx_vlan_tag))

/*******************************************************************************
 * End of 'CDMAC_RX_VLAN_TAGr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_SPARE
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_SPAREr_OFFSET 0x14048800

#define CDMAC_SPAREr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_SPARE.
 */
typedef union CDMAC_SPAREr_s {
    uint32_t v[1];
    uint32_t cdmac_spare[1];
    uint32_t _cdmac_spare;
} CDMAC_SPAREr_t;

#define CDMAC_SPAREr_CLR(r) (r).cdmac_spare[0] = 0
#define CDMAC_SPAREr_SET(r,d) (r).cdmac_spare[0] = d
#define CDMAC_SPAREr_GET(r) (r).cdmac_spare[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_SPAREr_SPAREf_GET(r) (((r).cdmac_spare[0]) & 0xff)
#define CDMAC_SPAREr_SPAREf_SET(r,f) (r).cdmac_spare[0]=(((r).cdmac_spare[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CDMAC_SPARE.
 */
#define READ_CDMAC_SPAREr(pa,p,r) bcmpmac_read(pa,p,CDMAC_SPAREr_OFFSET,0,CDMAC_SPAREr_SIZE,(r._cdmac_spare))
#define WRITE_CDMAC_SPAREr(pa,p,r) bcmpmac_write(pa,p,CDMAC_SPAREr_OFFSET,0,CDMAC_SPAREr_SIZE,&(r._cdmac_spare))

/*******************************************************************************
 * End of 'CDMAC_SPAREr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_TXFIFO_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_TXFIFO_STATUSr_OFFSET 0x14047400

#define CDMAC_TXFIFO_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_TXFIFO_STATUS.
 */
typedef union CDMAC_TXFIFO_STATUSr_s {
    uint32_t v[1];
    uint32_t cdmac_txfifo_status[1];
    uint32_t _cdmac_txfifo_status;
} CDMAC_TXFIFO_STATUSr_t;

#define CDMAC_TXFIFO_STATUSr_CLR(r) (r).cdmac_txfifo_status[0] = 0
#define CDMAC_TXFIFO_STATUSr_SET(r,d) (r).cdmac_txfifo_status[0] = d
#define CDMAC_TXFIFO_STATUSr_GET(r) (r).cdmac_txfifo_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_TXFIFO_STATUSr_CELL_CNTf_GET(r) (((r).cdmac_txfifo_status[0]) & 0x3ff)
#define CDMAC_TXFIFO_STATUSr_CELL_CNTf_SET(r,f) (r).cdmac_txfifo_status[0]=(((r).cdmac_txfifo_status[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define CDMAC_TXFIFO_STATUSr_CELL_REQ_CNTf_GET(r) ((((r).cdmac_txfifo_status[0]) >> 16) & 0x3ff)
#define CDMAC_TXFIFO_STATUSr_CELL_REQ_CNTf_SET(r,f) (r).cdmac_txfifo_status[0]=(((r).cdmac_txfifo_status[0] & ~((uint32_t)0x3ff << 16)) | ((((uint32_t)f) & 0x3ff) << 16))
#define CDMAC_TXFIFO_STATUSr_CREDIT_RESIDUEf_GET(r) ((((r).cdmac_txfifo_status[0]) >> 26) & 0xf)
#define CDMAC_TXFIFO_STATUSr_CREDIT_RESIDUEf_SET(r,f) (r).cdmac_txfifo_status[0]=(((r).cdmac_txfifo_status[0] & ~((uint32_t)0xf << 26)) | ((((uint32_t)f) & 0xf) << 26))

/*
 * These macros can be used to access CDMAC_TXFIFO_STATUS.
 */
#define READ_CDMAC_TXFIFO_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDMAC_TXFIFO_STATUSr_OFFSET,0,CDMAC_TXFIFO_STATUSr_SIZE,(r._cdmac_txfifo_status))
#define WRITE_CDMAC_TXFIFO_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDMAC_TXFIFO_STATUSr_OFFSET,0,CDMAC_TXFIFO_STATUSr_SIZE,&(r._cdmac_txfifo_status))

/*******************************************************************************
 * End of 'CDMAC_TXFIFO_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_TX_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_TX_CTRLr_OFFSET 0x14043800

#define CDMAC_TX_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_TX_CTRL.
 */
typedef union CDMAC_TX_CTRLr_s {
    uint32_t v[1];
    uint32_t cdmac_tx_ctrl[1];
    uint32_t _cdmac_tx_ctrl;
} CDMAC_TX_CTRLr_t;

#define CDMAC_TX_CTRLr_CLR(r) (r).cdmac_tx_ctrl[0] = 0
#define CDMAC_TX_CTRLr_SET(r,d) (r).cdmac_tx_ctrl[0] = d
#define CDMAC_TX_CTRLr_GET(r) (r).cdmac_tx_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_TX_CTRLr_CRC_MODEf_GET(r) (((r).cdmac_tx_ctrl[0]) & 0x3)
#define CDMAC_TX_CTRLr_CRC_MODEf_SET(r,f) (r).cdmac_tx_ctrl[0]=(((r).cdmac_tx_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define CDMAC_TX_CTRLr_DISCARDf_GET(r) ((((r).cdmac_tx_ctrl[0]) >> 2) & 0x1)
#define CDMAC_TX_CTRLr_DISCARDf_SET(r,f) (r).cdmac_tx_ctrl[0]=(((r).cdmac_tx_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CDMAC_TX_CTRLr_TX_CRC_CORRUPT_ENf_GET(r) ((((r).cdmac_tx_ctrl[0]) >> 3) & 0x1)
#define CDMAC_TX_CTRLr_TX_CRC_CORRUPT_ENf_SET(r,f) (r).cdmac_tx_ctrl[0]=(((r).cdmac_tx_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CDMAC_TX_CTRLr_PAD_ENf_GET(r) ((((r).cdmac_tx_ctrl[0]) >> 4) & 0x1)
#define CDMAC_TX_CTRLr_PAD_ENf_SET(r,f) (r).cdmac_tx_ctrl[0]=(((r).cdmac_tx_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CDMAC_TX_CTRLr_PAD_THRESHOLDf_GET(r) ((((r).cdmac_tx_ctrl[0]) >> 5) & 0x7f)
#define CDMAC_TX_CTRLr_PAD_THRESHOLDf_SET(r,f) (r).cdmac_tx_ctrl[0]=(((r).cdmac_tx_ctrl[0] & ~((uint32_t)0x7f << 5)) | ((((uint32_t)f) & 0x7f) << 5))
#define CDMAC_TX_CTRLr_AVERAGE_IPGf_GET(r) ((((r).cdmac_tx_ctrl[0]) >> 12) & 0x3f)
#define CDMAC_TX_CTRLr_AVERAGE_IPGf_SET(r,f) (r).cdmac_tx_ctrl[0]=(((r).cdmac_tx_ctrl[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define CDMAC_TX_CTRLr_CAP_DIC_TO_0f_GET(r) ((((r).cdmac_tx_ctrl[0]) >> 18) & 0x1)
#define CDMAC_TX_CTRLr_CAP_DIC_TO_0f_SET(r,f) (r).cdmac_tx_ctrl[0]=(((r).cdmac_tx_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CDMAC_TX_CTRLr_RECOVER_AM_IDLESf_GET(r) ((((r).cdmac_tx_ctrl[0]) >> 19) & 0x1)
#define CDMAC_TX_CTRLr_RECOVER_AM_IDLESf_SET(r,f) (r).cdmac_tx_ctrl[0]=(((r).cdmac_tx_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CDMAC_TX_CTRLr_TX_THRESHOLDf_GET(r) ((((r).cdmac_tx_ctrl[0]) >> 20) & 0x1f)
#define CDMAC_TX_CTRLr_TX_THRESHOLDf_SET(r,f) (r).cdmac_tx_ctrl[0]=(((r).cdmac_tx_ctrl[0] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define CDMAC_TX_CTRLr_STALL_TXf_GET(r) ((((r).cdmac_tx_ctrl[0]) >> 25) & 0x1)
#define CDMAC_TX_CTRLr_STALL_TXf_SET(r,f) (r).cdmac_tx_ctrl[0]=(((r).cdmac_tx_ctrl[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access CDMAC_TX_CTRL.
 */
#define READ_CDMAC_TX_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDMAC_TX_CTRLr_OFFSET,0,CDMAC_TX_CTRLr_SIZE,(r._cdmac_tx_ctrl))
#define WRITE_CDMAC_TX_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDMAC_TX_CTRLr_OFFSET,0,CDMAC_TX_CTRLr_SIZE,&(r._cdmac_tx_ctrl))

/*******************************************************************************
 * End of 'CDMAC_TX_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_TX_MAC_SA
 * BLOCKS:   CDPORT
 * SIZE:     64
 */
#define CDMAC_TX_MAC_SAr_OFFSET 0x14043c00

#define CDMAC_TX_MAC_SAr_SIZE 8

/*
 * This structure should be used to declare and program CDMAC_TX_MAC_SA.
 */
typedef union CDMAC_TX_MAC_SAr_s {
    uint32_t v[2];
    uint32_t cdmac_tx_mac_sa[2];
    uint32_t _cdmac_tx_mac_sa;
} CDMAC_TX_MAC_SAr_t;

#define CDMAC_TX_MAC_SAr_CLR(r) sal_memset(&((r).cdmac_tx_mac_sa[0]), 0, sizeof(CDMAC_TX_MAC_SAr_t))
#define CDMAC_TX_MAC_SAr_SET(r,i,d) (r).cdmac_tx_mac_sa[i] = d
#define CDMAC_TX_MAC_SAr_GET(r,i) (r).cdmac_tx_mac_sa[i]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_TX_MAC_SAr_CTRL_SAf_GET(r,a) bcmpmac_field_get((r).cdmac_tx_mac_sa,0,47,a)
#define CDMAC_TX_MAC_SAr_CTRL_SAf_SET(r,a) bcmpmac_field_set((r).cdmac_tx_mac_sa,0,47,a)

/*
 * These macros can be used to access CDMAC_TX_MAC_SA.
 */
#define READ_CDMAC_TX_MAC_SAr(pa,p,r) bcmpmac_read(pa,p,CDMAC_TX_MAC_SAr_OFFSET,0,CDMAC_TX_MAC_SAr_SIZE,(r._cdmac_tx_mac_sa))
#define WRITE_CDMAC_TX_MAC_SAr(pa,p,r) bcmpmac_write(pa,p,CDMAC_TX_MAC_SAr_OFFSET,0,CDMAC_TX_MAC_SAr_SIZE,&(r._cdmac_tx_mac_sa))

/*******************************************************************************
 * End of 'CDMAC_TX_MAC_SAr'
 */




/*******************************************************************************
 * REGISTER:  CDMAC_VERSION_ID
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDMAC_VERSION_IDr_OFFSET 0x04040000

#define CDMAC_VERSION_IDr_SIZE 4

/*
 * This structure should be used to declare and program CDMAC_VERSION_ID.
 */
typedef union CDMAC_VERSION_IDr_s {
    uint32_t v[1];
    uint32_t cdmac_version_id[1];
    uint32_t _cdmac_version_id;
} CDMAC_VERSION_IDr_t;

#define CDMAC_VERSION_IDr_CLR(r) (r).cdmac_version_id[0] = 0
#define CDMAC_VERSION_IDr_SET(r,d) (r).cdmac_version_id[0] = d
#define CDMAC_VERSION_IDr_GET(r) (r).cdmac_version_id[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDMAC_VERSION_IDr_CDMAC_VERSIONf_GET(r) ((r).cdmac_version_id[0])
#define CDMAC_VERSION_IDr_CDMAC_VERSIONf_SET(r,f) (r).cdmac_version_id[0]=((uint32_t)f)

/*
 * These macros can be used to access CDMAC_VERSION_ID.
 */
#define READ_CDMAC_VERSION_IDr(pa,p,r) bcmpmac_read(pa,p,CDMAC_VERSION_IDr_OFFSET,0,CDMAC_VERSION_IDr_SIZE,(r._cdmac_version_id))
#define WRITE_CDMAC_VERSION_IDr(pa,p,r) bcmpmac_write(pa,p,CDMAC_VERSION_IDr_OFFSET,0,CDMAC_VERSION_IDr_SIZE,&(r._cdmac_version_id))

/*******************************************************************************
 * End of 'CDMAC_VERSION_IDr'
 */




/*******************************************************************************
 * MEMORY:  CDMIB_MEM
 * BLOCKS:   CDPORT
 * SIZE:     512
 */
#define CDMIB_MEMm_OFFSET 0x24000000

#define CDMIB_MEMm_MIN 0
#define CDMIB_MEMm_MAX 63
#define CDMIB_MEMm_CMAX(u) 63
#define CDMIB_MEMm_SIZE 64

/*
 * This structure should be used to declare and program CDMIB_MEM.
 */
typedef union CDMIB_MEMm_s {
    uint32_t v[16];
    uint32_t cdmib_mem[16];
    uint32_t _cdmib_mem;
} CDMIB_MEMm_t;

#define CDMIB_MEMm_CLR(r) sal_memset(&((r).cdmib_mem[0]), 0, sizeof(CDMIB_MEMm_t))
#define CDMIB_MEMm_SET(r,i,d) (r).cdmib_mem[i] = d
#define CDMIB_MEMm_GET(r,i) (r).cdmib_mem[i]

/*
 * These macros can be used to access individual fields.
 */
#define CDMIB_MEMm_MIB_DATAf_GET(r,a) bcmpmac_field_get((r).cdmib_mem,0,511,a)
#define CDMIB_MEMm_MIB_DATAf_SET(r,a) bcmpmac_field_set((r).cdmib_mem,0,511,a)

/*
 * These macros can be used to access CDMIB_MEM.
 */
#define READ_CDMIB_MEMm(pa,p,i,m) bcmpmac_read(pa,p,CDMIB_MEMm_OFFSET,i,CDMIB_MEMm_SIZE,(m._cdmib_mem))
#define WRITE_CDMIB_MEMm(pa,p,i,m) bcmpmac_write(pa,p,CDMIB_MEMm_OFFSET,i,CDMIB_MEMm_SIZE,&(m._cdmib_mem))

/*******************************************************************************
 * End of 'CDMIB_MEMm'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_FAULT_LINK_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_FAULT_LINK_STATUSr_OFFSET 0x10000400

#define CDPORT_FAULT_LINK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_FAULT_LINK_STATUS.
 */
typedef union CDPORT_FAULT_LINK_STATUSr_s {
    uint32_t v[1];
    uint32_t cdport_fault_link_status[1];
    uint32_t _cdport_fault_link_status;
} CDPORT_FAULT_LINK_STATUSr_t;

#define CDPORT_FAULT_LINK_STATUSr_CLR(r) (r).cdport_fault_link_status[0] = 0
#define CDPORT_FAULT_LINK_STATUSr_SET(r,d) (r).cdport_fault_link_status[0] = d
#define CDPORT_FAULT_LINK_STATUSr_GET(r) (r).cdport_fault_link_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_FAULT_LINK_STATUSr_LOCAL_FAULTf_GET(r) (((r).cdport_fault_link_status[0]) & 0x1)
#define CDPORT_FAULT_LINK_STATUSr_LOCAL_FAULTf_SET(r,f) (r).cdport_fault_link_status[0]=(((r).cdport_fault_link_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDPORT_FAULT_LINK_STATUSr_REMOTE_FAULTf_GET(r) ((((r).cdport_fault_link_status[0]) >> 1) & 0x1)
#define CDPORT_FAULT_LINK_STATUSr_REMOTE_FAULTf_SET(r,f) (r).cdport_fault_link_status[0]=(((r).cdport_fault_link_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CDPORT_FAULT_LINK_STATUS.
 */
#define READ_CDPORT_FAULT_LINK_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDPORT_FAULT_LINK_STATUSr_OFFSET,0,CDPORT_FAULT_LINK_STATUSr_SIZE,(r._cdport_fault_link_status))
#define WRITE_CDPORT_FAULT_LINK_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDPORT_FAULT_LINK_STATUSr_OFFSET,0,CDPORT_FAULT_LINK_STATUSr_SIZE,&(r._cdport_fault_link_status))

/*******************************************************************************
 * End of 'CDPORT_FAULT_LINK_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_FLOW_CONTROL_CONFIG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_FLOW_CONTROL_CONFIGr_OFFSET 0x10000c00

#define CDPORT_FLOW_CONTROL_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_FLOW_CONTROL_CONFIG.
 */
typedef union CDPORT_FLOW_CONTROL_CONFIGr_s {
    uint32_t v[1];
    uint32_t cdport_flow_control_config[1];
    uint32_t _cdport_flow_control_config;
} CDPORT_FLOW_CONTROL_CONFIGr_t;

#define CDPORT_FLOW_CONTROL_CONFIGr_CLR(r) (r).cdport_flow_control_config[0] = 0
#define CDPORT_FLOW_CONTROL_CONFIGr_SET(r,d) (r).cdport_flow_control_config[0] = d
#define CDPORT_FLOW_CONTROL_CONFIGr_GET(r) (r).cdport_flow_control_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_FLOW_CONTROL_CONFIGr_RSVDf_GET(r) (((r).cdport_flow_control_config[0]) & 0x3)
#define CDPORT_FLOW_CONTROL_CONFIGr_RSVDf_SET(r,f) (r).cdport_flow_control_config[0]=(((r).cdport_flow_control_config[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access CDPORT_FLOW_CONTROL_CONFIG.
 */
#define READ_CDPORT_FLOW_CONTROL_CONFIGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_FLOW_CONTROL_CONFIGr_OFFSET,0,CDPORT_FLOW_CONTROL_CONFIGr_SIZE,(r._cdport_flow_control_config))
#define WRITE_CDPORT_FLOW_CONTROL_CONFIGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_FLOW_CONTROL_CONFIGr_OFFSET,0,CDPORT_FLOW_CONTROL_CONFIGr_SIZE,&(r._cdport_flow_control_config))

/*******************************************************************************
 * End of 'CDPORT_FLOW_CONTROL_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_GENERAL_SPARE0_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_GENERAL_SPARE0_REGr_OFFSET 0x00005800

#define CDPORT_GENERAL_SPARE0_REGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_GENERAL_SPARE0_REG.
 */
typedef union CDPORT_GENERAL_SPARE0_REGr_s {
    uint32_t v[1];
    uint32_t cdport_general_spare0_reg[1];
    uint32_t _cdport_general_spare0_reg;
} CDPORT_GENERAL_SPARE0_REGr_t;

#define CDPORT_GENERAL_SPARE0_REGr_CLR(r) (r).cdport_general_spare0_reg[0] = 0
#define CDPORT_GENERAL_SPARE0_REGr_SET(r,d) (r).cdport_general_spare0_reg[0] = d
#define CDPORT_GENERAL_SPARE0_REGr_GET(r) (r).cdport_general_spare0_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_GENERAL_SPARE0_REGr_RSVDf_GET(r) ((r).cdport_general_spare0_reg[0])
#define CDPORT_GENERAL_SPARE0_REGr_RSVDf_SET(r,f) (r).cdport_general_spare0_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access CDPORT_GENERAL_SPARE0_REG.
 */
#define READ_CDPORT_GENERAL_SPARE0_REGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_GENERAL_SPARE0_REGr_OFFSET,0,CDPORT_GENERAL_SPARE0_REGr_SIZE,(r._cdport_general_spare0_reg))
#define WRITE_CDPORT_GENERAL_SPARE0_REGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_GENERAL_SPARE0_REGr_OFFSET,0,CDPORT_GENERAL_SPARE0_REGr_SIZE,&(r._cdport_general_spare0_reg))

/*******************************************************************************
 * End of 'CDPORT_GENERAL_SPARE0_REGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_GENERAL_SPARE1_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_GENERAL_SPARE1_REGr_OFFSET 0x00005c00

#define CDPORT_GENERAL_SPARE1_REGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_GENERAL_SPARE1_REG.
 */
typedef union CDPORT_GENERAL_SPARE1_REGr_s {
    uint32_t v[1];
    uint32_t cdport_general_spare1_reg[1];
    uint32_t _cdport_general_spare1_reg;
} CDPORT_GENERAL_SPARE1_REGr_t;

#define CDPORT_GENERAL_SPARE1_REGr_CLR(r) (r).cdport_general_spare1_reg[0] = 0
#define CDPORT_GENERAL_SPARE1_REGr_SET(r,d) (r).cdport_general_spare1_reg[0] = d
#define CDPORT_GENERAL_SPARE1_REGr_GET(r) (r).cdport_general_spare1_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_GENERAL_SPARE1_REGr_RSVDf_GET(r) ((r).cdport_general_spare1_reg[0])
#define CDPORT_GENERAL_SPARE1_REGr_RSVDf_SET(r,f) (r).cdport_general_spare1_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access CDPORT_GENERAL_SPARE1_REG.
 */
#define READ_CDPORT_GENERAL_SPARE1_REGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_GENERAL_SPARE1_REGr_OFFSET,0,CDPORT_GENERAL_SPARE1_REGr_SIZE,(r._cdport_general_spare1_reg))
#define WRITE_CDPORT_GENERAL_SPARE1_REGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_GENERAL_SPARE1_REGr_OFFSET,0,CDPORT_GENERAL_SPARE1_REGr_SIZE,&(r._cdport_general_spare1_reg))

/*******************************************************************************
 * End of 'CDPORT_GENERAL_SPARE1_REGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_GENERAL_SPARE2_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_GENERAL_SPARE2_REGr_OFFSET 0x00006000

#define CDPORT_GENERAL_SPARE2_REGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_GENERAL_SPARE2_REG.
 */
typedef union CDPORT_GENERAL_SPARE2_REGr_s {
    uint32_t v[1];
    uint32_t cdport_general_spare2_reg[1];
    uint32_t _cdport_general_spare2_reg;
} CDPORT_GENERAL_SPARE2_REGr_t;

#define CDPORT_GENERAL_SPARE2_REGr_CLR(r) (r).cdport_general_spare2_reg[0] = 0
#define CDPORT_GENERAL_SPARE2_REGr_SET(r,d) (r).cdport_general_spare2_reg[0] = d
#define CDPORT_GENERAL_SPARE2_REGr_GET(r) (r).cdport_general_spare2_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_GENERAL_SPARE2_REGr_RSVDf_GET(r) ((r).cdport_general_spare2_reg[0])
#define CDPORT_GENERAL_SPARE2_REGr_RSVDf_SET(r,f) (r).cdport_general_spare2_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access CDPORT_GENERAL_SPARE2_REG.
 */
#define READ_CDPORT_GENERAL_SPARE2_REGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_GENERAL_SPARE2_REGr_OFFSET,0,CDPORT_GENERAL_SPARE2_REGr_SIZE,(r._cdport_general_spare2_reg))
#define WRITE_CDPORT_GENERAL_SPARE2_REGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_GENERAL_SPARE2_REGr_OFFSET,0,CDPORT_GENERAL_SPARE2_REGr_SIZE,&(r._cdport_general_spare2_reg))

/*******************************************************************************
 * End of 'CDPORT_GENERAL_SPARE2_REGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_GENERAL_SPARE3_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_GENERAL_SPARE3_REGr_OFFSET 0x00006400

#define CDPORT_GENERAL_SPARE3_REGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_GENERAL_SPARE3_REG.
 */
typedef union CDPORT_GENERAL_SPARE3_REGr_s {
    uint32_t v[1];
    uint32_t cdport_general_spare3_reg[1];
    uint32_t _cdport_general_spare3_reg;
} CDPORT_GENERAL_SPARE3_REGr_t;

#define CDPORT_GENERAL_SPARE3_REGr_CLR(r) (r).cdport_general_spare3_reg[0] = 0
#define CDPORT_GENERAL_SPARE3_REGr_SET(r,d) (r).cdport_general_spare3_reg[0] = d
#define CDPORT_GENERAL_SPARE3_REGr_GET(r) (r).cdport_general_spare3_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_GENERAL_SPARE3_REGr_RSVDf_GET(r) ((r).cdport_general_spare3_reg[0])
#define CDPORT_GENERAL_SPARE3_REGr_RSVDf_SET(r,f) (r).cdport_general_spare3_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access CDPORT_GENERAL_SPARE3_REG.
 */
#define READ_CDPORT_GENERAL_SPARE3_REGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_GENERAL_SPARE3_REGr_OFFSET,0,CDPORT_GENERAL_SPARE3_REGr_SIZE,(r._cdport_general_spare3_reg))
#define WRITE_CDPORT_GENERAL_SPARE3_REGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_GENERAL_SPARE3_REGr_OFFSET,0,CDPORT_GENERAL_SPARE3_REGr_SIZE,&(r._cdport_general_spare3_reg))

/*******************************************************************************
 * End of 'CDPORT_GENERAL_SPARE3_REGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_INTR_MASK
 * BLOCKS:   CDPORT
 * SIZE:     64
 */
#define CDPORT_INTR_MASKr_OFFSET 0x00006800

#define CDPORT_INTR_MASKr_SIZE 8

/*
 * This structure should be used to declare and program CDPORT_INTR_MASK.
 */
typedef union CDPORT_INTR_MASKr_s {
    uint32_t v[2];
    uint32_t cdport_intr_mask[2];
    uint32_t _cdport_intr_mask;
} CDPORT_INTR_MASKr_t;

#define CDPORT_INTR_MASKr_CLR(r) sal_memset(&((r).cdport_intr_mask[0]), 0, sizeof(CDPORT_INTR_MASKr_t))
#define CDPORT_INTR_MASKr_SET(r,i,d) (r).cdport_intr_mask[i] = d
#define CDPORT_INTR_MASKr_GET(r,i) (r).cdport_intr_mask[i]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_INTR_MASKr_LINK_DOWNf_GET(r) (((r).cdport_intr_mask[0]) & 0xf)
#define CDPORT_INTR_MASKr_LINK_DOWNf_SET(r,f) (r).cdport_intr_mask[0]=(((r).cdport_intr_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define CDPORT_INTR_MASKr_LINK_UPf_GET(r) ((((r).cdport_intr_mask[0]) >> 4) & 0xf)
#define CDPORT_INTR_MASKr_LINK_UPf_SET(r,f) (r).cdport_intr_mask[0]=(((r).cdport_intr_mask[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define CDPORT_INTR_MASKr_FLOWCONTROL_REQ_FULLf_GET(r) ((((r).cdport_intr_mask[0]) >> 8) & 0xf)
#define CDPORT_INTR_MASKr_FLOWCONTROL_REQ_FULLf_SET(r,f) (r).cdport_intr_mask[0]=(((r).cdport_intr_mask[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define CDPORT_INTR_MASKr_CDMAC_INTRf_GET(r) ((((r).cdport_intr_mask[0]) >> 12) & 0xf)
#define CDPORT_INTR_MASKr_CDMAC_INTRf_SET(r,f) (r).cdport_intr_mask[0]=(((r).cdport_intr_mask[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define CDPORT_INTR_MASKr_TSC_ECC_1B_ERRf_GET(r) ((((r).cdport_intr_mask[0]) >> 16) & 0x7ff)
#define CDPORT_INTR_MASKr_TSC_ECC_1B_ERRf_SET(r,f) (r).cdport_intr_mask[0]=(((r).cdport_intr_mask[0] & ~((uint32_t)0x7ff << 16)) | ((((uint32_t)f) & 0x7ff) << 16))
#define CDPORT_INTR_MASKr_TSC_ECC_2B_ERRf_GET(r) bcmpmac_field32_get((r).cdport_intr_mask,27,37)
#define CDPORT_INTR_MASKr_TSC_ECC_2B_ERRf_SET(r,f) bcmpmac_field32_set((r).cdport_intr_mask,27,37,f)
#define CDPORT_INTR_MASKr_TSTS_INTERRUPT_STATUSf_GET(r) ((((r).cdport_intr_mask[1]) >> 6) & 0xf)
#define CDPORT_INTR_MASKr_TSTS_INTERRUPT_STATUSf_SET(r,f) (r).cdport_intr_mask[1]=(((r).cdport_intr_mask[1] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define CDPORT_INTR_MASKr_FDR_INTERRUPTf_GET(r) ((((r).cdport_intr_mask[1]) >> 10) & 0xf)
#define CDPORT_INTR_MASKr_FDR_INTERRUPTf_SET(r,f) (r).cdport_intr_mask[1]=(((r).cdport_intr_mask[1] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define CDPORT_INTR_MASKr_LP_PAGE_RDY_SW_AN_INTERRUPTf_GET(r) ((((r).cdport_intr_mask[1]) >> 14) & 0xf)
#define CDPORT_INTR_MASKr_LP_PAGE_RDY_SW_AN_INTERRUPTf_SET(r,f) (r).cdport_intr_mask[1]=(((r).cdport_intr_mask[1] & ~((uint32_t)0xf << 14)) | ((((uint32_t)f) & 0xf) << 14))
#define CDPORT_INTR_MASKr_AN_COMPLETED_SW_AN_INTERRUPTf_GET(r) ((((r).cdport_intr_mask[1]) >> 18) & 0xf)
#define CDPORT_INTR_MASKr_AN_COMPLETED_SW_AN_INTERRUPTf_SET(r,f) (r).cdport_intr_mask[1]=(((r).cdport_intr_mask[1] & ~((uint32_t)0xf << 18)) | ((((uint32_t)f) & 0xf) << 18))
#define CDPORT_INTR_MASKr_AN_GOOD_CHK_AN_INTERRUPTf_GET(r) ((((r).cdport_intr_mask[1]) >> 22) & 0xf)
#define CDPORT_INTR_MASKr_AN_GOOD_CHK_AN_INTERRUPTf_SET(r,f) (r).cdport_intr_mask[1]=(((r).cdport_intr_mask[1] & ~((uint32_t)0xf << 22)) | ((((uint32_t)f) & 0xf) << 22))
#define CDPORT_INTR_MASKr_RSVDf_GET(r) ((((r).cdport_intr_mask[1]) >> 26) & 0x1f)
#define CDPORT_INTR_MASKr_RSVDf_SET(r,f) (r).cdport_intr_mask[1]=(((r).cdport_intr_mask[1] & ~((uint32_t)0x1f << 26)) | ((((uint32_t)f) & 0x1f) << 26))
#define CDPORT_INTR_MASKr_PMD_INTRf_GET(r) ((((r).cdport_intr_mask[1]) >> 31) & 0x1)
#define CDPORT_INTR_MASKr_PMD_INTRf_SET(r,f) (r).cdport_intr_mask[1]=(((r).cdport_intr_mask[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CDPORT_INTR_MASK.
 */
#define READ_CDPORT_INTR_MASKr(pa,p,r) bcmpmac_read(pa,p,CDPORT_INTR_MASKr_OFFSET,0,CDPORT_INTR_MASKr_SIZE,(r._cdport_intr_mask))
#define WRITE_CDPORT_INTR_MASKr(pa,p,r) bcmpmac_write(pa,p,CDPORT_INTR_MASKr_OFFSET,0,CDPORT_INTR_MASKr_SIZE,&(r._cdport_intr_mask))

/*******************************************************************************
 * End of 'CDPORT_INTR_MASKr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_INTR_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     64
 */
#define CDPORT_INTR_STATUSr_OFFSET 0x00006c00

#define CDPORT_INTR_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CDPORT_INTR_STATUS.
 */
typedef union CDPORT_INTR_STATUSr_s {
    uint32_t v[2];
    uint32_t cdport_intr_status[2];
    uint32_t _cdport_intr_status;
} CDPORT_INTR_STATUSr_t;

#define CDPORT_INTR_STATUSr_CLR(r) sal_memset(&((r).cdport_intr_status[0]), 0, sizeof(CDPORT_INTR_STATUSr_t))
#define CDPORT_INTR_STATUSr_SET(r,i,d) (r).cdport_intr_status[i] = d
#define CDPORT_INTR_STATUSr_GET(r,i) (r).cdport_intr_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_INTR_STATUSr_LINK_DOWNf_GET(r) (((r).cdport_intr_status[0]) & 0xf)
#define CDPORT_INTR_STATUSr_LINK_DOWNf_SET(r,f) (r).cdport_intr_status[0]=(((r).cdport_intr_status[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define CDPORT_INTR_STATUSr_LINK_UPf_GET(r) ((((r).cdport_intr_status[0]) >> 4) & 0xf)
#define CDPORT_INTR_STATUSr_LINK_UPf_SET(r,f) (r).cdport_intr_status[0]=(((r).cdport_intr_status[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define CDPORT_INTR_STATUSr_FLOWCONTROL_REQ_FULLf_GET(r) ((((r).cdport_intr_status[0]) >> 8) & 0xf)
#define CDPORT_INTR_STATUSr_FLOWCONTROL_REQ_FULLf_SET(r,f) (r).cdport_intr_status[0]=(((r).cdport_intr_status[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define CDPORT_INTR_STATUSr_CDMAC_INTRf_GET(r) ((((r).cdport_intr_status[0]) >> 12) & 0xf)
#define CDPORT_INTR_STATUSr_CDMAC_INTRf_SET(r,f) (r).cdport_intr_status[0]=(((r).cdport_intr_status[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define CDPORT_INTR_STATUSr_TSC_ECC_1B_ERRf_GET(r) ((((r).cdport_intr_status[0]) >> 16) & 0x7ff)
#define CDPORT_INTR_STATUSr_TSC_ECC_1B_ERRf_SET(r,f) (r).cdport_intr_status[0]=(((r).cdport_intr_status[0] & ~((uint32_t)0x7ff << 16)) | ((((uint32_t)f) & 0x7ff) << 16))
#define CDPORT_INTR_STATUSr_TSC_ECC_2B_ERRf_GET(r) bcmpmac_field32_get((r).cdport_intr_status,27,37)
#define CDPORT_INTR_STATUSr_TSC_ECC_2B_ERRf_SET(r,f) bcmpmac_field32_set((r).cdport_intr_status,27,37,f)
#define CDPORT_INTR_STATUSr_TSTS_INTERRUPT_STATUSf_GET(r) ((((r).cdport_intr_status[1]) >> 6) & 0xf)
#define CDPORT_INTR_STATUSr_TSTS_INTERRUPT_STATUSf_SET(r,f) (r).cdport_intr_status[1]=(((r).cdport_intr_status[1] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define CDPORT_INTR_STATUSr_FDR_INTERRUPTf_GET(r) ((((r).cdport_intr_status[1]) >> 10) & 0xf)
#define CDPORT_INTR_STATUSr_FDR_INTERRUPTf_SET(r,f) (r).cdport_intr_status[1]=(((r).cdport_intr_status[1] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define CDPORT_INTR_STATUSr_LP_PAGE_RDY_SW_AN_INTERRUPTf_GET(r) ((((r).cdport_intr_status[1]) >> 14) & 0xf)
#define CDPORT_INTR_STATUSr_LP_PAGE_RDY_SW_AN_INTERRUPTf_SET(r,f) (r).cdport_intr_status[1]=(((r).cdport_intr_status[1] & ~((uint32_t)0xf << 14)) | ((((uint32_t)f) & 0xf) << 14))
#define CDPORT_INTR_STATUSr_AN_COMPLETED_SW_AN_INTERRUPTf_GET(r) ((((r).cdport_intr_status[1]) >> 18) & 0xf)
#define CDPORT_INTR_STATUSr_AN_COMPLETED_SW_AN_INTERRUPTf_SET(r,f) (r).cdport_intr_status[1]=(((r).cdport_intr_status[1] & ~((uint32_t)0xf << 18)) | ((((uint32_t)f) & 0xf) << 18))
#define CDPORT_INTR_STATUSr_AN_GOOD_CHK_AN_INTERRUPTf_GET(r) ((((r).cdport_intr_status[1]) >> 22) & 0xf)
#define CDPORT_INTR_STATUSr_AN_GOOD_CHK_AN_INTERRUPTf_SET(r,f) (r).cdport_intr_status[1]=(((r).cdport_intr_status[1] & ~((uint32_t)0xf << 22)) | ((((uint32_t)f) & 0xf) << 22))
#define CDPORT_INTR_STATUSr_RSVDf_GET(r) ((((r).cdport_intr_status[1]) >> 26) & 0x1f)
#define CDPORT_INTR_STATUSr_RSVDf_SET(r,f) (r).cdport_intr_status[1]=(((r).cdport_intr_status[1] & ~((uint32_t)0x1f << 26)) | ((((uint32_t)f) & 0x1f) << 26))
#define CDPORT_INTR_STATUSr_PMD_INTRf_GET(r) ((((r).cdport_intr_status[1]) >> 31) & 0x1)
#define CDPORT_INTR_STATUSr_PMD_INTRf_SET(r,f) (r).cdport_intr_status[1]=(((r).cdport_intr_status[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CDPORT_INTR_STATUS.
 */
#define READ_CDPORT_INTR_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDPORT_INTR_STATUSr_OFFSET,0,CDPORT_INTR_STATUSr_SIZE,(r._cdport_intr_status))
#define WRITE_CDPORT_INTR_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDPORT_INTR_STATUSr_OFFSET,0,CDPORT_INTR_STATUSr_SIZE,&(r._cdport_intr_status))

/*******************************************************************************
 * End of 'CDPORT_INTR_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_LAG_FAILOVER_CONFIG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_LAG_FAILOVER_CONFIGr_OFFSET 0x10000000

#define CDPORT_LAG_FAILOVER_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_LAG_FAILOVER_CONFIG.
 */
typedef union CDPORT_LAG_FAILOVER_CONFIGr_s {
    uint32_t v[1];
    uint32_t cdport_lag_failover_config[1];
    uint32_t _cdport_lag_failover_config;
} CDPORT_LAG_FAILOVER_CONFIGr_t;

#define CDPORT_LAG_FAILOVER_CONFIGr_CLR(r) (r).cdport_lag_failover_config[0] = 0
#define CDPORT_LAG_FAILOVER_CONFIGr_SET(r,d) (r).cdport_lag_failover_config[0] = d
#define CDPORT_LAG_FAILOVER_CONFIGr_GET(r) (r).cdport_lag_failover_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_GET(r) (((r).cdport_lag_failover_config[0]) & 0x1)
#define CDPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_SET(r,f) (r).cdport_lag_failover_config[0]=(((r).cdport_lag_failover_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CDPORT_LAG_FAILOVER_CONFIG.
 */
#define READ_CDPORT_LAG_FAILOVER_CONFIGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_LAG_FAILOVER_CONFIGr_OFFSET,0,CDPORT_LAG_FAILOVER_CONFIGr_SIZE,(r._cdport_lag_failover_config))
#define WRITE_CDPORT_LAG_FAILOVER_CONFIGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_LAG_FAILOVER_CONFIGr_OFFSET,0,CDPORT_LAG_FAILOVER_CONFIGr_SIZE,&(r._cdport_lag_failover_config))

/*******************************************************************************
 * End of 'CDPORT_LAG_FAILOVER_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_LED_CONTROL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_LED_CONTROLr_OFFSET 0x10001000

#define CDPORT_LED_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_LED_CONTROL.
 */
typedef union CDPORT_LED_CONTROLr_s {
    uint32_t v[1];
    uint32_t cdport_led_control[1];
    uint32_t _cdport_led_control;
} CDPORT_LED_CONTROLr_t;

#define CDPORT_LED_CONTROLr_CLR(r) (r).cdport_led_control[0] = 0
#define CDPORT_LED_CONTROLr_SET(r,d) (r).cdport_led_control[0] = d
#define CDPORT_LED_CONTROLr_GET(r) (r).cdport_led_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_LED_CONTROLr_LED_SPEED_MODEf_GET(r) (((r).cdport_led_control[0]) & 0x3)
#define CDPORT_LED_CONTROLr_LED_SPEED_MODEf_SET(r,f) (r).cdport_led_control[0]=(((r).cdport_led_control[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access CDPORT_LED_CONTROL.
 */
#define READ_CDPORT_LED_CONTROLr(pa,p,r) bcmpmac_read(pa,p,CDPORT_LED_CONTROLr_OFFSET,0,CDPORT_LED_CONTROLr_SIZE,(r._cdport_led_control))
#define WRITE_CDPORT_LED_CONTROLr(pa,p,r) bcmpmac_write(pa,p,CDPORT_LED_CONTROLr_OFFSET,0,CDPORT_LED_CONTROLr_SIZE,&(r._cdport_led_control))

/*******************************************************************************
 * End of 'CDPORT_LED_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_MAC_CONTROL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_MAC_CONTROLr_OFFSET 0x00002800

#define CDPORT_MAC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_MAC_CONTROL.
 */
typedef union CDPORT_MAC_CONTROLr_s {
    uint32_t v[1];
    uint32_t cdport_mac_control[1];
    uint32_t _cdport_mac_control;
} CDPORT_MAC_CONTROLr_t;

#define CDPORT_MAC_CONTROLr_CLR(r) (r).cdport_mac_control[0] = 0
#define CDPORT_MAC_CONTROLr_SET(r,d) (r).cdport_mac_control[0] = d
#define CDPORT_MAC_CONTROLr_GET(r) (r).cdport_mac_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_MAC_CONTROLr_CDMAC_RESETf_GET(r) (((r).cdport_mac_control[0]) & 0x1)
#define CDPORT_MAC_CONTROLr_CDMAC_RESETf_SET(r,f) (r).cdport_mac_control[0]=(((r).cdport_mac_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CDPORT_MAC_CONTROL.
 */
#define READ_CDPORT_MAC_CONTROLr(pa,p,r) bcmpmac_read(pa,p,CDPORT_MAC_CONTROLr_OFFSET,0,CDPORT_MAC_CONTROLr_SIZE,(r._cdport_mac_control))
#define WRITE_CDPORT_MAC_CONTROLr(pa,p,r) bcmpmac_write(pa,p,CDPORT_MAC_CONTROLr_OFFSET,0,CDPORT_MAC_CONTROLr_SIZE,&(r._cdport_mac_control))

/*******************************************************************************
 * End of 'CDPORT_MAC_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_MODE_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_MODE_REGr_OFFSET 0x00002400

#define CDPORT_MODE_REGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_MODE_REG.
 */
typedef union CDPORT_MODE_REGr_s {
    uint32_t v[1];
    uint32_t cdport_mode_reg[1];
    uint32_t _cdport_mode_reg;
} CDPORT_MODE_REGr_t;

#define CDPORT_MODE_REGr_CLR(r) (r).cdport_mode_reg[0] = 0
#define CDPORT_MODE_REGr_SET(r,d) (r).cdport_mode_reg[0] = d
#define CDPORT_MODE_REGr_GET(r) (r).cdport_mode_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_MODE_REGr_MAC_PORT_MODEf_GET(r) (((r).cdport_mode_reg[0]) & 0x7)
#define CDPORT_MODE_REGr_MAC_PORT_MODEf_SET(r,f) (r).cdport_mode_reg[0]=(((r).cdport_mode_reg[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define CDPORT_MODE_REGr_RSVDf_GET(r) ((((r).cdport_mode_reg[0]) >> 3) & 0x1)
#define CDPORT_MODE_REGr_RSVDf_SET(r,f) (r).cdport_mode_reg[0]=(((r).cdport_mode_reg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CDPORT_MODE_REG.
 */
#define READ_CDPORT_MODE_REGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_MODE_REGr_OFFSET,0,CDPORT_MODE_REGr_SIZE,(r._cdport_mode_reg))
#define WRITE_CDPORT_MODE_REGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_MODE_REGr_OFFSET,0,CDPORT_MODE_REGr_SIZE,&(r._cdport_mode_reg))

/*******************************************************************************
 * End of 'CDPORT_MODE_REGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_PM_VERSION_ID
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_PM_VERSION_IDr_OFFSET 0x00007000

#define CDPORT_PM_VERSION_IDr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_PM_VERSION_ID.
 */
typedef union CDPORT_PM_VERSION_IDr_s {
    uint32_t v[1];
    uint32_t cdport_pm_version_id[1];
    uint32_t _cdport_pm_version_id;
} CDPORT_PM_VERSION_IDr_t;

#define CDPORT_PM_VERSION_IDr_CLR(r) (r).cdport_pm_version_id[0] = 0
#define CDPORT_PM_VERSION_IDr_SET(r,d) (r).cdport_pm_version_id[0] = d
#define CDPORT_PM_VERSION_IDr_GET(r) (r).cdport_pm_version_id[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_PM_VERSION_IDr_PM_TYPEf_GET(r) (((r).cdport_pm_version_id[0]) & 0xf)
#define CDPORT_PM_VERSION_IDr_PM_TYPEf_SET(r,f) (r).cdport_pm_version_id[0]=(((r).cdport_pm_version_id[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define CDPORT_PM_VERSION_IDr_TECH_PROCESSf_GET(r) ((((r).cdport_pm_version_id[0]) >> 4) & 0x7)
#define CDPORT_PM_VERSION_IDr_TECH_PROCESSf_SET(r,f) (r).cdport_pm_version_id[0]=(((r).cdport_pm_version_id[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define CDPORT_PM_VERSION_IDr_REV_NUMBERf_GET(r) ((((r).cdport_pm_version_id[0]) >> 7) & 0x7)
#define CDPORT_PM_VERSION_IDr_REV_NUMBERf_SET(r,f) (r).cdport_pm_version_id[0]=(((r).cdport_pm_version_id[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define CDPORT_PM_VERSION_IDr_REV_LETTERf_GET(r) ((((r).cdport_pm_version_id[0]) >> 10) & 0x3)
#define CDPORT_PM_VERSION_IDr_REV_LETTERf_SET(r,f) (r).cdport_pm_version_id[0]=(((r).cdport_pm_version_id[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define CDPORT_PM_VERSION_IDr_RSVDf_GET(r) ((((r).cdport_pm_version_id[0]) >> 12) & 0xf)
#define CDPORT_PM_VERSION_IDr_RSVDf_SET(r,f) (r).cdport_pm_version_id[0]=(((r).cdport_pm_version_id[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access CDPORT_PM_VERSION_ID.
 */
#define READ_CDPORT_PM_VERSION_IDr(pa,p,r) bcmpmac_read(pa,p,CDPORT_PM_VERSION_IDr_OFFSET,0,CDPORT_PM_VERSION_IDr_SIZE,(r._cdport_pm_version_id))
#define WRITE_CDPORT_PM_VERSION_IDr(pa,p,r) bcmpmac_write(pa,p,CDPORT_PM_VERSION_IDr_OFFSET,0,CDPORT_PM_VERSION_IDr_SIZE,&(r._cdport_pm_version_id))

/*******************************************************************************
 * End of 'CDPORT_PM_VERSION_IDr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_PORT_INTR_ENABLE
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_PORT_INTR_ENABLEr_OFFSET 0x00005000

#define CDPORT_PORT_INTR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_PORT_INTR_ENABLE.
 */
typedef union CDPORT_PORT_INTR_ENABLEr_s {
    uint32_t v[1];
    uint32_t cdport_port_intr_enable[1];
    uint32_t _cdport_port_intr_enable;
} CDPORT_PORT_INTR_ENABLEr_t;

#define CDPORT_PORT_INTR_ENABLEr_CLR(r) (r).cdport_port_intr_enable[0] = 0
#define CDPORT_PORT_INTR_ENABLEr_SET(r,d) (r).cdport_port_intr_enable[0] = d
#define CDPORT_PORT_INTR_ENABLEr_GET(r) (r).cdport_port_intr_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_PORT_INTR_ENABLEr_LINK_DOWNf_GET(r) (((r).cdport_port_intr_enable[0]) & 0xf)
#define CDPORT_PORT_INTR_ENABLEr_LINK_DOWNf_SET(r,f) (r).cdport_port_intr_enable[0]=(((r).cdport_port_intr_enable[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define CDPORT_PORT_INTR_ENABLEr_LINK_UPf_GET(r) ((((r).cdport_port_intr_enable[0]) >> 4) & 0xf)
#define CDPORT_PORT_INTR_ENABLEr_LINK_UPf_SET(r,f) (r).cdport_port_intr_enable[0]=(((r).cdport_port_intr_enable[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define CDPORT_PORT_INTR_ENABLEr_FLOWCONTROL_REQ_FULLf_GET(r) ((((r).cdport_port_intr_enable[0]) >> 8) & 0xf)
#define CDPORT_PORT_INTR_ENABLEr_FLOWCONTROL_REQ_FULLf_SET(r,f) (r).cdport_port_intr_enable[0]=(((r).cdport_port_intr_enable[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))

/*
 * These macros can be used to access CDPORT_PORT_INTR_ENABLE.
 */
#define READ_CDPORT_PORT_INTR_ENABLEr(pa,p,r) bcmpmac_read(pa,p,CDPORT_PORT_INTR_ENABLEr_OFFSET,0,CDPORT_PORT_INTR_ENABLEr_SIZE,(r._cdport_port_intr_enable))
#define WRITE_CDPORT_PORT_INTR_ENABLEr(pa,p,r) bcmpmac_write(pa,p,CDPORT_PORT_INTR_ENABLEr_OFFSET,0,CDPORT_PORT_INTR_ENABLEr_SIZE,&(r._cdport_port_intr_enable))

/*******************************************************************************
 * End of 'CDPORT_PORT_INTR_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_PORT_INTR_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_PORT_INTR_STATUSr_OFFSET 0x00005400

#define CDPORT_PORT_INTR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_PORT_INTR_STATUS.
 */
typedef union CDPORT_PORT_INTR_STATUSr_s {
    uint32_t v[1];
    uint32_t cdport_port_intr_status[1];
    uint32_t _cdport_port_intr_status;
} CDPORT_PORT_INTR_STATUSr_t;

#define CDPORT_PORT_INTR_STATUSr_CLR(r) (r).cdport_port_intr_status[0] = 0
#define CDPORT_PORT_INTR_STATUSr_SET(r,d) (r).cdport_port_intr_status[0] = d
#define CDPORT_PORT_INTR_STATUSr_GET(r) (r).cdport_port_intr_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_PORT_INTR_STATUSr_FLOWCONTROL_REQ_FULLf_GET(r) (((r).cdport_port_intr_status[0]) & 0xf)
#define CDPORT_PORT_INTR_STATUSr_FLOWCONTROL_REQ_FULLf_SET(r,f) (r).cdport_port_intr_status[0]=(((r).cdport_port_intr_status[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CDPORT_PORT_INTR_STATUS.
 */
#define READ_CDPORT_PORT_INTR_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDPORT_PORT_INTR_STATUSr_OFFSET,0,CDPORT_PORT_INTR_STATUSr_SIZE,(r._cdport_port_intr_status))
#define WRITE_CDPORT_PORT_INTR_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDPORT_PORT_INTR_STATUSr_OFFSET,0,CDPORT_PORT_INTR_STATUSr_SIZE,&(r._cdport_port_intr_status))

/*******************************************************************************
 * End of 'CDPORT_PORT_INTR_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_PORT_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_PORT_STATUSr_OFFSET 0x00004800

#define CDPORT_PORT_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_PORT_STATUS.
 */
typedef union CDPORT_PORT_STATUSr_s {
    uint32_t v[1];
    uint32_t cdport_port_status[1];
    uint32_t _cdport_port_status;
} CDPORT_PORT_STATUSr_t;

#define CDPORT_PORT_STATUSr_CLR(r) (r).cdport_port_status[0] = 0
#define CDPORT_PORT_STATUSr_SET(r,d) (r).cdport_port_status[0] = d
#define CDPORT_PORT_STATUSr_GET(r) (r).cdport_port_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_PORT_STATUSr_PORT0_PORT_STATUS_LLf_GET(r) (((r).cdport_port_status[0]) & 0x1)
#define CDPORT_PORT_STATUSr_PORT0_PORT_STATUS_LLf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDPORT_PORT_STATUSr_PORT1_PORT_STATUS_LLf_GET(r) ((((r).cdport_port_status[0]) >> 1) & 0x1)
#define CDPORT_PORT_STATUSr_PORT1_PORT_STATUS_LLf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDPORT_PORT_STATUSr_PORT2_PORT_STATUS_LLf_GET(r) ((((r).cdport_port_status[0]) >> 2) & 0x1)
#define CDPORT_PORT_STATUSr_PORT2_PORT_STATUS_LLf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CDPORT_PORT_STATUSr_PORT3_PORT_STATUS_LLf_GET(r) ((((r).cdport_port_status[0]) >> 3) & 0x1)
#define CDPORT_PORT_STATUSr_PORT3_PORT_STATUS_LLf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CDPORT_PORT_STATUSr_PORT0_PORT_STATUS_LHf_GET(r) ((((r).cdport_port_status[0]) >> 4) & 0x1)
#define CDPORT_PORT_STATUSr_PORT0_PORT_STATUS_LHf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CDPORT_PORT_STATUSr_PORT1_PORT_STATUS_LHf_GET(r) ((((r).cdport_port_status[0]) >> 5) & 0x1)
#define CDPORT_PORT_STATUSr_PORT1_PORT_STATUS_LHf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CDPORT_PORT_STATUSr_PORT2_PORT_STATUS_LHf_GET(r) ((((r).cdport_port_status[0]) >> 6) & 0x1)
#define CDPORT_PORT_STATUSr_PORT2_PORT_STATUS_LHf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CDPORT_PORT_STATUSr_PORT3_PORT_STATUS_LHf_GET(r) ((((r).cdport_port_status[0]) >> 7) & 0x1)
#define CDPORT_PORT_STATUSr_PORT3_PORT_STATUS_LHf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CDPORT_PORT_STATUSr_PORT0_LIVE_PORT_STATUSf_GET(r) ((((r).cdport_port_status[0]) >> 8) & 0x1)
#define CDPORT_PORT_STATUSr_PORT0_LIVE_PORT_STATUSf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CDPORT_PORT_STATUSr_PORT1_LIVE_PORT_STATUSf_GET(r) ((((r).cdport_port_status[0]) >> 9) & 0x1)
#define CDPORT_PORT_STATUSr_PORT1_LIVE_PORT_STATUSf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CDPORT_PORT_STATUSr_PORT2_LIVE_PORT_STATUSf_GET(r) ((((r).cdport_port_status[0]) >> 10) & 0x1)
#define CDPORT_PORT_STATUSr_PORT2_LIVE_PORT_STATUSf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CDPORT_PORT_STATUSr_PORT3_LIVE_PORT_STATUSf_GET(r) ((((r).cdport_port_status[0]) >> 11) & 0x1)
#define CDPORT_PORT_STATUSr_PORT3_LIVE_PORT_STATUSf_SET(r,f) (r).cdport_port_status[0]=(((r).cdport_port_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access CDPORT_PORT_STATUS.
 */
#define READ_CDPORT_PORT_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDPORT_PORT_STATUSr_OFFSET,0,CDPORT_PORT_STATUSr_SIZE,(r._cdport_port_status))
#define WRITE_CDPORT_PORT_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDPORT_PORT_STATUSr_OFFSET,0,CDPORT_PORT_STATUSr_SIZE,&(r._cdport_port_status))

/*******************************************************************************
 * End of 'CDPORT_PORT_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_SBUS_CONTROL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_SBUS_CONTROLr_OFFSET 0x00004c00

#define CDPORT_SBUS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_SBUS_CONTROL.
 */
typedef union CDPORT_SBUS_CONTROLr_s {
    uint32_t v[1];
    uint32_t cdport_sbus_control[1];
    uint32_t _cdport_sbus_control;
} CDPORT_SBUS_CONTROLr_t;

#define CDPORT_SBUS_CONTROLr_CLR(r) (r).cdport_sbus_control[0] = 0
#define CDPORT_SBUS_CONTROLr_SET(r,d) (r).cdport_sbus_control[0] = d
#define CDPORT_SBUS_CONTROLr_GET(r) (r).cdport_sbus_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_SBUS_CONTROLr_SBUS_BCAST_BLOCK_IDf_GET(r) (((r).cdport_sbus_control[0]) & 0x7f)
#define CDPORT_SBUS_CONTROLr_SBUS_BCAST_BLOCK_IDf_SET(r,f) (r).cdport_sbus_control[0]=(((r).cdport_sbus_control[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define CDPORT_SBUS_CONTROLr_SBUS_CHAIN_LASTf_GET(r) ((((r).cdport_sbus_control[0]) >> 7) & 0x1)
#define CDPORT_SBUS_CONTROLr_SBUS_CHAIN_LASTf_SET(r,f) (r).cdport_sbus_control[0]=(((r).cdport_sbus_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access CDPORT_SBUS_CONTROL.
 */
#define READ_CDPORT_SBUS_CONTROLr(pa,p,r) bcmpmac_read(pa,p,CDPORT_SBUS_CONTROLr_OFFSET,0,CDPORT_SBUS_CONTROLr_SIZE,(r._cdport_sbus_control))
#define WRITE_CDPORT_SBUS_CONTROLr(pa,p,r) bcmpmac_write(pa,p,CDPORT_SBUS_CONTROLr_OFFSET,0,CDPORT_SBUS_CONTROLr_SIZE,&(r._cdport_sbus_control))

/*******************************************************************************
 * End of 'CDPORT_SBUS_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_SPARE0_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_SPARE0_REGr_OFFSET 0x10001400

#define CDPORT_SPARE0_REGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_SPARE0_REG.
 */
typedef union CDPORT_SPARE0_REGr_s {
    uint32_t v[1];
    uint32_t cdport_spare0_reg[1];
    uint32_t _cdport_spare0_reg;
} CDPORT_SPARE0_REGr_t;

#define CDPORT_SPARE0_REGr_CLR(r) (r).cdport_spare0_reg[0] = 0
#define CDPORT_SPARE0_REGr_SET(r,d) (r).cdport_spare0_reg[0] = d
#define CDPORT_SPARE0_REGr_GET(r) (r).cdport_spare0_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_SPARE0_REGr_RSVDf_GET(r) ((r).cdport_spare0_reg[0])
#define CDPORT_SPARE0_REGr_RSVDf_SET(r,f) (r).cdport_spare0_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access CDPORT_SPARE0_REG.
 */
#define READ_CDPORT_SPARE0_REGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_SPARE0_REGr_OFFSET,0,CDPORT_SPARE0_REGr_SIZE,(r._cdport_spare0_reg))
#define WRITE_CDPORT_SPARE0_REGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_SPARE0_REGr_OFFSET,0,CDPORT_SPARE0_REGr_SIZE,&(r._cdport_spare0_reg))

/*******************************************************************************
 * End of 'CDPORT_SPARE0_REGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_SPARE1_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_SPARE1_REGr_OFFSET 0x10001800

#define CDPORT_SPARE1_REGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_SPARE1_REG.
 */
typedef union CDPORT_SPARE1_REGr_s {
    uint32_t v[1];
    uint32_t cdport_spare1_reg[1];
    uint32_t _cdport_spare1_reg;
} CDPORT_SPARE1_REGr_t;

#define CDPORT_SPARE1_REGr_CLR(r) (r).cdport_spare1_reg[0] = 0
#define CDPORT_SPARE1_REGr_SET(r,d) (r).cdport_spare1_reg[0] = d
#define CDPORT_SPARE1_REGr_GET(r) (r).cdport_spare1_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_SPARE1_REGr_RSVDf_GET(r) ((r).cdport_spare1_reg[0])
#define CDPORT_SPARE1_REGr_RSVDf_SET(r,f) (r).cdport_spare1_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access CDPORT_SPARE1_REG.
 */
#define READ_CDPORT_SPARE1_REGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_SPARE1_REGr_OFFSET,0,CDPORT_SPARE1_REGr_SIZE,(r._cdport_spare1_reg))
#define WRITE_CDPORT_SPARE1_REGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_SPARE1_REGr_OFFSET,0,CDPORT_SPARE1_REGr_SIZE,&(r._cdport_spare1_reg))

/*******************************************************************************
 * End of 'CDPORT_SPARE1_REGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_SPARE2_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_SPARE2_REGr_OFFSET 0x10001c00

#define CDPORT_SPARE2_REGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_SPARE2_REG.
 */
typedef union CDPORT_SPARE2_REGr_s {
    uint32_t v[1];
    uint32_t cdport_spare2_reg[1];
    uint32_t _cdport_spare2_reg;
} CDPORT_SPARE2_REGr_t;

#define CDPORT_SPARE2_REGr_CLR(r) (r).cdport_spare2_reg[0] = 0
#define CDPORT_SPARE2_REGr_SET(r,d) (r).cdport_spare2_reg[0] = d
#define CDPORT_SPARE2_REGr_GET(r) (r).cdport_spare2_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_SPARE2_REGr_RSVDf_GET(r) ((r).cdport_spare2_reg[0])
#define CDPORT_SPARE2_REGr_RSVDf_SET(r,f) (r).cdport_spare2_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access CDPORT_SPARE2_REG.
 */
#define READ_CDPORT_SPARE2_REGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_SPARE2_REGr_OFFSET,0,CDPORT_SPARE2_REGr_SIZE,(r._cdport_spare2_reg))
#define WRITE_CDPORT_SPARE2_REGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_SPARE2_REGr_OFFSET,0,CDPORT_SPARE2_REGr_SIZE,&(r._cdport_spare2_reg))

/*******************************************************************************
 * End of 'CDPORT_SPARE2_REGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_SPARE3_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_SPARE3_REGr_OFFSET 0x10002000

#define CDPORT_SPARE3_REGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_SPARE3_REG.
 */
typedef union CDPORT_SPARE3_REGr_s {
    uint32_t v[1];
    uint32_t cdport_spare3_reg[1];
    uint32_t _cdport_spare3_reg;
} CDPORT_SPARE3_REGr_t;

#define CDPORT_SPARE3_REGr_CLR(r) (r).cdport_spare3_reg[0] = 0
#define CDPORT_SPARE3_REGr_SET(r,d) (r).cdport_spare3_reg[0] = d
#define CDPORT_SPARE3_REGr_GET(r) (r).cdport_spare3_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_SPARE3_REGr_RSVDf_GET(r) ((r).cdport_spare3_reg[0])
#define CDPORT_SPARE3_REGr_RSVDf_SET(r,f) (r).cdport_spare3_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access CDPORT_SPARE3_REG.
 */
#define READ_CDPORT_SPARE3_REGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_SPARE3_REGr_OFFSET,0,CDPORT_SPARE3_REGr_SIZE,(r._cdport_spare3_reg))
#define WRITE_CDPORT_SPARE3_REGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_SPARE3_REGr_OFFSET,0,CDPORT_SPARE3_REGr_SIZE,&(r._cdport_spare3_reg))

/*******************************************************************************
 * End of 'CDPORT_SPARE3_REGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_SW_FLOW_CONTROL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_SW_FLOW_CONTROLr_OFFSET 0x10000800

#define CDPORT_SW_FLOW_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_SW_FLOW_CONTROL.
 */
typedef union CDPORT_SW_FLOW_CONTROLr_s {
    uint32_t v[1];
    uint32_t cdport_sw_flow_control[1];
    uint32_t _cdport_sw_flow_control;
} CDPORT_SW_FLOW_CONTROLr_t;

#define CDPORT_SW_FLOW_CONTROLr_CLR(r) (r).cdport_sw_flow_control[0] = 0
#define CDPORT_SW_FLOW_CONTROLr_SET(r,d) (r).cdport_sw_flow_control[0] = d
#define CDPORT_SW_FLOW_CONTROLr_GET(r) (r).cdport_sw_flow_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_SW_FLOW_CONTROLr_FC_PAUSEf_GET(r) (((r).cdport_sw_flow_control[0]) & 0x1)
#define CDPORT_SW_FLOW_CONTROLr_FC_PAUSEf_SET(r,f) (r).cdport_sw_flow_control[0]=(((r).cdport_sw_flow_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDPORT_SW_FLOW_CONTROLr_FC_ENf_GET(r) ((((r).cdport_sw_flow_control[0]) >> 1) & 0x1)
#define CDPORT_SW_FLOW_CONTROLr_FC_ENf_SET(r,f) (r).cdport_sw_flow_control[0]=(((r).cdport_sw_flow_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CDPORT_SW_FLOW_CONTROL.
 */
#define READ_CDPORT_SW_FLOW_CONTROLr(pa,p,r) bcmpmac_read(pa,p,CDPORT_SW_FLOW_CONTROLr_OFFSET,0,CDPORT_SW_FLOW_CONTROLr_SIZE,(r._cdport_sw_flow_control))
#define WRITE_CDPORT_SW_FLOW_CONTROLr(pa,p,r) bcmpmac_write(pa,p,CDPORT_SW_FLOW_CONTROLr_OFFSET,0,CDPORT_SW_FLOW_CONTROLr_SIZE,&(r._cdport_sw_flow_control))

/*******************************************************************************
 * End of 'CDPORT_SW_FLOW_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_TSC_CLOCK_CONTROL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_TSC_CLOCK_CONTROLr_OFFSET 0x00007400

#define CDPORT_TSC_CLOCK_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_TSC_CLOCK_CONTROL.
 */
typedef union CDPORT_TSC_CLOCK_CONTROLr_s {
    uint32_t v[1];
    uint32_t cdport_tsc_clock_control[1];
    uint32_t _cdport_tsc_clock_control;
} CDPORT_TSC_CLOCK_CONTROLr_t;

#define CDPORT_TSC_CLOCK_CONTROLr_CLR(r) (r).cdport_tsc_clock_control[0] = 0
#define CDPORT_TSC_CLOCK_CONTROLr_SET(r,d) (r).cdport_tsc_clock_control[0] = d
#define CDPORT_TSC_CLOCK_CONTROLr_GET(r) (r).cdport_tsc_clock_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_TSC_CLOCK_CONTROLr_TSC_CLK_GATE_OFFf_GET(r) (((r).cdport_tsc_clock_control[0]) & 0x1)
#define CDPORT_TSC_CLOCK_CONTROLr_TSC_CLK_GATE_OFFf_SET(r,f) (r).cdport_tsc_clock_control[0]=(((r).cdport_tsc_clock_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CDPORT_TSC_CLOCK_CONTROL.
 */
#define READ_CDPORT_TSC_CLOCK_CONTROLr(pa,p,r) bcmpmac_read(pa,p,CDPORT_TSC_CLOCK_CONTROLr_OFFSET,0,CDPORT_TSC_CLOCK_CONTROLr_SIZE,(r._cdport_tsc_clock_control))
#define WRITE_CDPORT_TSC_CLOCK_CONTROLr(pa,p,r) bcmpmac_write(pa,p,CDPORT_TSC_CLOCK_CONTROLr_OFFSET,0,CDPORT_TSC_CLOCK_CONTROLr_SIZE,&(r._cdport_tsc_clock_control))

/*******************************************************************************
 * End of 'CDPORT_TSC_CLOCK_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_TSC_MEM_CTRL
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_TSC_MEM_CTRLr_OFFSET 0x00004400

#define CDPORT_TSC_MEM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_TSC_MEM_CTRL.
 */
typedef union CDPORT_TSC_MEM_CTRLr_s {
    uint32_t v[1];
    uint32_t cdport_tsc_mem_ctrl[1];
    uint32_t _cdport_tsc_mem_ctrl;
} CDPORT_TSC_MEM_CTRLr_t;

#define CDPORT_TSC_MEM_CTRLr_CLR(r) (r).cdport_tsc_mem_ctrl[0] = 0
#define CDPORT_TSC_MEM_CTRLr_SET(r,d) (r).cdport_tsc_mem_ctrl[0] = d
#define CDPORT_TSC_MEM_CTRLr_GET(r) (r).cdport_tsc_mem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_TSC_MEM_CTRLr_ACCESS_MODEf_GET(r) (((r).cdport_tsc_mem_ctrl[0]) & 0x1)
#define CDPORT_TSC_MEM_CTRLr_ACCESS_MODEf_SET(r,f) (r).cdport_tsc_mem_ctrl[0]=(((r).cdport_tsc_mem_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDPORT_TSC_MEM_CTRLr_RSVD3_1f_GET(r) ((((r).cdport_tsc_mem_ctrl[0]) >> 1) & 0x7)
#define CDPORT_TSC_MEM_CTRLr_RSVD3_1f_SET(r,f) (r).cdport_tsc_mem_ctrl[0]=(((r).cdport_tsc_mem_ctrl[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))

/*
 * These macros can be used to access CDPORT_TSC_MEM_CTRL.
 */
#define READ_CDPORT_TSC_MEM_CTRLr(pa,p,r) bcmpmac_read(pa,p,CDPORT_TSC_MEM_CTRLr_OFFSET,0,CDPORT_TSC_MEM_CTRLr_SIZE,(r._cdport_tsc_mem_ctrl))
#define WRITE_CDPORT_TSC_MEM_CTRLr(pa,p,r) bcmpmac_write(pa,p,CDPORT_TSC_MEM_CTRLr_OFFSET,0,CDPORT_TSC_MEM_CTRLr_SIZE,&(r._cdport_tsc_mem_ctrl))

/*******************************************************************************
 * End of 'CDPORT_TSC_MEM_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_TSC_PLL_LOCK_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_TSC_PLL_LOCK_STATUSr_OFFSET 0x00002c00

#define CDPORT_TSC_PLL_LOCK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_TSC_PLL_LOCK_STATUS.
 */
typedef union CDPORT_TSC_PLL_LOCK_STATUSr_s {
    uint32_t v[1];
    uint32_t cdport_tsc_pll_lock_status[1];
    uint32_t _cdport_tsc_pll_lock_status;
} CDPORT_TSC_PLL_LOCK_STATUSr_t;

#define CDPORT_TSC_PLL_LOCK_STATUSr_CLR(r) (r).cdport_tsc_pll_lock_status[0] = 0
#define CDPORT_TSC_PLL_LOCK_STATUSr_SET(r,d) (r).cdport_tsc_pll_lock_status[0] = d
#define CDPORT_TSC_PLL_LOCK_STATUSr_GET(r) (r).cdport_tsc_pll_lock_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_TSC_PLL_LOCK_STATUSr_PLL0_LOCK_STATUSf_GET(r) (((r).cdport_tsc_pll_lock_status[0]) & 0x1)
#define CDPORT_TSC_PLL_LOCK_STATUSr_PLL0_LOCK_STATUSf_SET(r,f) (r).cdport_tsc_pll_lock_status[0]=(((r).cdport_tsc_pll_lock_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDPORT_TSC_PLL_LOCK_STATUSr_PLL0_UNLOCKf_GET(r) ((((r).cdport_tsc_pll_lock_status[0]) >> 1) & 0x1)
#define CDPORT_TSC_PLL_LOCK_STATUSr_PLL0_UNLOCKf_SET(r,f) (r).cdport_tsc_pll_lock_status[0]=(((r).cdport_tsc_pll_lock_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CDPORT_TSC_PLL_LOCK_STATUS.
 */
#define READ_CDPORT_TSC_PLL_LOCK_STATUSr(pa,p,r) bcmpmac_read(pa,p,CDPORT_TSC_PLL_LOCK_STATUSr_OFFSET,0,CDPORT_TSC_PLL_LOCK_STATUSr_SIZE,(r._cdport_tsc_pll_lock_status))
#define WRITE_CDPORT_TSC_PLL_LOCK_STATUSr(pa,p,r) bcmpmac_write(pa,p,CDPORT_TSC_PLL_LOCK_STATUSr_OFFSET,0,CDPORT_TSC_PLL_LOCK_STATUSr_SIZE,&(r._cdport_tsc_pll_lock_status))

/*******************************************************************************
 * End of 'CDPORT_TSC_PLL_LOCK_STATUSr'
 */




/*******************************************************************************
 * MEMORY:  CDPORT_TSC_UCMEM_DATA
 * BLOCKS:   CDPORT
 * SIZE:     128
 */
#define CDPORT_TSC_UCMEM_DATAm_OFFSET 0x20000000

#define CDPORT_TSC_UCMEM_DATAm_MIN 0
#define CDPORT_TSC_UCMEM_DATAm_MAX 10239
#define CDPORT_TSC_UCMEM_DATAm_CMAX(u) 10239
#define CDPORT_TSC_UCMEM_DATAm_SIZE 16

/*
 * This structure should be used to declare and program CDPORT_TSC_UCMEM_DATA.
 */
typedef union CDPORT_TSC_UCMEM_DATAm_s {
    uint32_t v[4];
    uint32_t cdport_tsc_ucmem_data[4];
    uint32_t _cdport_tsc_ucmem_data;
} CDPORT_TSC_UCMEM_DATAm_t;

#define CDPORT_TSC_UCMEM_DATAm_CLR(r) sal_memset(&((r).cdport_tsc_ucmem_data[0]), 0, sizeof(CDPORT_TSC_UCMEM_DATAm_t))
#define CDPORT_TSC_UCMEM_DATAm_SET(r,i,d) (r).cdport_tsc_ucmem_data[i] = d
#define CDPORT_TSC_UCMEM_DATAm_GET(r,i) (r).cdport_tsc_ucmem_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_TSC_UCMEM_DATAm_UC_DATAf_GET(r,a) bcmpmac_field_get((r).cdport_tsc_ucmem_data,0,127,a)
#define CDPORT_TSC_UCMEM_DATAm_UC_DATAf_SET(r,a) bcmpmac_field_set((r).cdport_tsc_ucmem_data,0,127,a)
#define CDPORT_TSC_UCMEM_DATAm_TSC_REG_ADDRf_GET(r) ((r).cdport_tsc_ucmem_data[0])
#define CDPORT_TSC_UCMEM_DATAm_TSC_REG_ADDRf_SET(r,f) (r).cdport_tsc_ucmem_data[0]=((uint32_t)f)
#define CDPORT_TSC_UCMEM_DATAm_TSC_REG_DATA_MASKf_GET(r) (((r).cdport_tsc_ucmem_data[1]) & 0xffff)
#define CDPORT_TSC_UCMEM_DATAm_TSC_REG_DATA_MASKf_SET(r,f) (r).cdport_tsc_ucmem_data[1]=(((r).cdport_tsc_ucmem_data[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CDPORT_TSC_UCMEM_DATAm_TSC_REG_DATAf_GET(r) ((((r).cdport_tsc_ucmem_data[1]) >> 16) & 0xffff)
#define CDPORT_TSC_UCMEM_DATAm_TSC_REG_DATAf_SET(r,f) (r).cdport_tsc_ucmem_data[1]=(((r).cdport_tsc_ucmem_data[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define CDPORT_TSC_UCMEM_DATAm_TSC_REG_WRf_GET(r) (((r).cdport_tsc_ucmem_data[2]) & 0x1)
#define CDPORT_TSC_UCMEM_DATAm_TSC_REG_WRf_SET(r,f) (r).cdport_tsc_ucmem_data[2]=(((r).cdport_tsc_ucmem_data[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDPORT_TSC_UCMEM_DATAm_RSVDf_GET(r,a) bcmpmac_field_get((r).cdport_tsc_ucmem_data,65,127,a)
#define CDPORT_TSC_UCMEM_DATAm_RSVDf_SET(r,a) bcmpmac_field_set((r).cdport_tsc_ucmem_data,65,127,a)

/*
 * These macros can be used to access CDPORT_TSC_UCMEM_DATA.
 */
#define READ_CDPORT_TSC_UCMEM_DATAm(pa,p,i,m) bcmpmac_read(pa,p,CDPORT_TSC_UCMEM_DATAm_OFFSET,i,CDPORT_TSC_UCMEM_DATAm_SIZE,(m._cdport_tsc_ucmem_data))
#define WRITE_CDPORT_TSC_UCMEM_DATAm(pa,p,i,m) bcmpmac_write(pa,p,CDPORT_TSC_UCMEM_DATAm_OFFSET,i,CDPORT_TSC_UCMEM_DATAm_SIZE,&(m._cdport_tsc_ucmem_data))

/*******************************************************************************
 * End of 'CDPORT_TSC_UCMEM_DATAm'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_XGXS0_CTRL_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_XGXS0_CTRL_REGr_OFFSET 0x00003000

#define CDPORT_XGXS0_CTRL_REGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_XGXS0_CTRL_REG.
 */
typedef union CDPORT_XGXS0_CTRL_REGr_s {
    uint32_t v[1];
    uint32_t cdport_xgxs0_ctrl_reg[1];
    uint32_t _cdport_xgxs0_ctrl_reg;
} CDPORT_XGXS0_CTRL_REGr_t;

#define CDPORT_XGXS0_CTRL_REGr_CLR(r) (r).cdport_xgxs0_ctrl_reg[0] = 0
#define CDPORT_XGXS0_CTRL_REGr_SET(r,d) (r).cdport_xgxs0_ctrl_reg[0] = d
#define CDPORT_XGXS0_CTRL_REGr_GET(r) (r).cdport_xgxs0_ctrl_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_XGXS0_CTRL_REGr_TSC_RSTBf_GET(r) (((r).cdport_xgxs0_ctrl_reg[0]) & 0x1)
#define CDPORT_XGXS0_CTRL_REGr_TSC_RSTBf_SET(r,f) (r).cdport_xgxs0_ctrl_reg[0]=(((r).cdport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDPORT_XGXS0_CTRL_REGr_TSC_PWRDWNf_GET(r) ((((r).cdport_xgxs0_ctrl_reg[0]) >> 1) & 0x1)
#define CDPORT_XGXS0_CTRL_REGr_TSC_PWRDWNf_SET(r,f) (r).cdport_xgxs0_ctrl_reg[0]=(((r).cdport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CDPORT_XGXS0_CTRL_REGr_RSVDf_GET(r) ((((r).cdport_xgxs0_ctrl_reg[0]) >> 2) & 0x1)
#define CDPORT_XGXS0_CTRL_REGr_RSVDf_SET(r,f) (r).cdport_xgxs0_ctrl_reg[0]=(((r).cdport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CDPORT_XGXS0_CTRL_REG.
 */
#define READ_CDPORT_XGXS0_CTRL_REGr(pa,p,r) bcmpmac_read(pa,p,CDPORT_XGXS0_CTRL_REGr_OFFSET,0,CDPORT_XGXS0_CTRL_REGr_SIZE,(r._cdport_xgxs0_ctrl_reg))
#define WRITE_CDPORT_XGXS0_CTRL_REGr(pa,p,r) bcmpmac_write(pa,p,CDPORT_XGXS0_CTRL_REGr_OFFSET,0,CDPORT_XGXS0_CTRL_REGr_SIZE,&(r._cdport_xgxs0_ctrl_reg))

/*******************************************************************************
 * End of 'CDPORT_XGXS0_CTRL_REGr'
 */




/*******************************************************************************
 * REGISTER:  CDPORT_XGXS0_LN0_STATUS_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_XGXS0_LN0_STATUS_REGr_OFFSET 0x00003400

#define CDPORT_XGXS0_LN0_STATUS_REGr_SIZE 4

/* CDPORT_XGXS0_LN0_STATUS_REGr is element of CDPORT_XGXS0_STATUS_REG */

/*******************************************************************************
 * REGISTER:  CDPORT_XGXS0_LN1_STATUS_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_XGXS0_LN1_STATUS_REGr_OFFSET 0x00003800

#define CDPORT_XGXS0_LN1_STATUS_REGr_SIZE 4

/* CDPORT_XGXS0_LN1_STATUS_REGr is element of CDPORT_XGXS0_STATUS_REG */

/*******************************************************************************
 * REGISTER:  CDPORT_XGXS0_LN2_STATUS_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_XGXS0_LN2_STATUS_REGr_OFFSET 0x00003c00

#define CDPORT_XGXS0_LN2_STATUS_REGr_SIZE 4

/* CDPORT_XGXS0_LN2_STATUS_REGr is element of CDPORT_XGXS0_STATUS_REG */

/*******************************************************************************
 * REGISTER:  CDPORT_XGXS0_LN3_STATUS_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_XGXS0_LN3_STATUS_REGr_OFFSET 0x00004000

#define CDPORT_XGXS0_LN3_STATUS_REGr_SIZE 4

/* CDPORT_XGXS0_LN3_STATUS_REGr is element of CDPORT_XGXS0_STATUS_REG */

/*******************************************************************************
 * REGISTER:  CDPORT_XGXS0_STATUS_REG
 * BLOCKS:   CDPORT
 * SIZE:     32
 */
#define CDPORT_XGXS0_STATUS_REGr_OFFSET 0x00003400

#define CDPORT_XGXS0_STATUS_REGr_SIZE 4

/*
 * This structure should be used to declare and program CDPORT_XGXS0_STATUS_REG.
 */
typedef union CDPORT_XGXS0_STATUS_REGr_s {
    uint32_t v[1];
    uint32_t cdport_xgxs0_status_reg[1];
    uint32_t _cdport_xgxs0_status_reg;
} CDPORT_XGXS0_STATUS_REGr_t;

#define CDPORT_XGXS0_STATUS_REGr_CLR(r) (r).cdport_xgxs0_status_reg[0] = 0
#define CDPORT_XGXS0_STATUS_REGr_SET(r,d) (r).cdport_xgxs0_status_reg[0] = d
#define CDPORT_XGXS0_STATUS_REGr_GET(r) (r).cdport_xgxs0_status_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CDPORT_XGXS0_STATUS_REGr_LINK_STATUSf_GET(r) (((r).cdport_xgxs0_status_reg[0]) & 0x1)
#define CDPORT_XGXS0_STATUS_REGr_LINK_STATUSf_SET(r,f) (r).cdport_xgxs0_status_reg[0]=(((r).cdport_xgxs0_status_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CDPORT_XGXS0_STATUS_REGr_RSVDf_GET(r) ((((r).cdport_xgxs0_status_reg[0]) >> 1) & 0x3)
#define CDPORT_XGXS0_STATUS_REGr_RSVDf_SET(r,f) (r).cdport_xgxs0_status_reg[0]=(((r).cdport_xgxs0_status_reg[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))

/*
 * These macros can be used to access CDPORT_XGXS0_STATUS_REG.
 */
#define READ_CDPORT_XGXS0_STATUS_REGr(pa,p,i,r) bcmpmac_read(pa,p,CDPORT_XGXS0_STATUS_REGr_OFFSET,i,CDPORT_XGXS0_STATUS_REGr_SIZE,(r._cdport_xgxs0_status_reg))
#define WRITE_CDPORT_XGXS0_STATUS_REGr(pa,p,i,r) bcmpmac_write(pa,p,CDPORT_XGXS0_STATUS_REGr_OFFSET,i,CDPORT_XGXS0_STATUS_REGr_SIZE,&(r._cdport_xgxs0_status_reg))

/*******************************************************************************
 * End of 'CDPORT_XGXS0_STATUS_REGr'
 */




/*******************************************************************************
 * MEMORY:  RSFEC_SYMBOL_ERROR_MIB
 * BLOCKS:   CDPORT
 * SIZE:     128
 */
#define RSFEC_SYMBOL_ERROR_MIBm_OFFSET 0x20000000

#define RSFEC_SYMBOL_ERROR_MIBm_MIN 0
#define RSFEC_SYMBOL_ERROR_MIBm_MAX 7
#define RSFEC_SYMBOL_ERROR_MIBm_CMAX(u) 7
#define RSFEC_SYMBOL_ERROR_MIBm_SIZE 16

/*
 * This structure should be used to declare and program RSFEC_SYMBOL_ERROR_MIB.
 */
typedef union RSFEC_SYMBOL_ERROR_MIBm_s {
    uint32_t v[4];
    uint32_t rsfec_symbol_error_mib[4];
    uint32_t _rsfec_symbol_error_mib;
} RSFEC_SYMBOL_ERROR_MIBm_t;

#define RSFEC_SYMBOL_ERROR_MIBm_CLR(r) sal_memset(&((r).rsfec_symbol_error_mib[0]), 0, sizeof(RSFEC_SYMBOL_ERROR_MIBm_t))
#define RSFEC_SYMBOL_ERROR_MIBm_SET(r,i,d) (r).rsfec_symbol_error_mib[i] = d
#define RSFEC_SYMBOL_ERROR_MIBm_GET(r,i) (r).rsfec_symbol_error_mib[i]

/*
 * These macros can be used to access individual fields.
 */
#define RSFEC_SYMBOL_ERROR_MIBm_RSFEC_SYMBOL_ERROR_MIB_DATAf_GET(r,a) bcmpmac_field_get((r).rsfec_symbol_error_mib,0,127,a)
#define RSFEC_SYMBOL_ERROR_MIBm_RSFEC_SYMBOL_ERROR_MIB_DATAf_SET(r,a) bcmpmac_field_set((r).rsfec_symbol_error_mib,0,127,a)

/*
 * These macros can be used to access RSFEC_SYMBOL_ERROR_MIB.
 */
#define READ_RSFEC_SYMBOL_ERROR_MIBm(pa,p,i,m) bcmpmac_read(pa,p,RSFEC_SYMBOL_ERROR_MIBm_OFFSET,i,RSFEC_SYMBOL_ERROR_MIBm_SIZE,(m._rsfec_symbol_error_mib))
#define WRITE_RSFEC_SYMBOL_ERROR_MIBm(pa,p,i,m) bcmpmac_write(pa,p,RSFEC_SYMBOL_ERROR_MIBm_OFFSET,i,RSFEC_SYMBOL_ERROR_MIBm_SIZE,&(m._rsfec_symbol_error_mib))

/*******************************************************************************
 * End of 'RSFEC_SYMBOL_ERROR_MIBm'
 */




/*******************************************************************************
 * MEMORY:  RX_FDR_CONTROL
 * BLOCKS:   CDPORT
 * SIZE:     20
 */
#define RX_FDR_CONTROLm_OFFSET 0x20000000

#define RX_FDR_CONTROLm_MIN 0
#define RX_FDR_CONTROLm_MAX 3
#define RX_FDR_CONTROLm_CMAX(u) 3
#define RX_FDR_CONTROLm_SIZE 3

/*
 * This structure should be used to declare and program RX_FDR_CONTROL.
 */
typedef union RX_FDR_CONTROLm_s {
    uint32_t v[1];
    uint32_t rx_fdr_control[1];
    uint32_t _rx_fdr_control;
} RX_FDR_CONTROLm_t;

#define RX_FDR_CONTROLm_CLR(r) (r).rx_fdr_control[0] = 0
#define RX_FDR_CONTROLm_SET(r,d) (r).rx_fdr_control[0] = d
#define RX_FDR_CONTROLm_GET(r) (r).rx_fdr_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define RX_FDR_CONTROLm_S_VALUEf_GET(r) (((r).rx_fdr_control[0]) & 0x1)
#define RX_FDR_CONTROLm_S_VALUEf_SET(r,f) (r).rx_fdr_control[0]=(((r).rx_fdr_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define RX_FDR_CONTROLm_SYMERR_THRESHOLDf_GET(r) ((((r).rx_fdr_control[0]) >> 1) & 0xffff)
#define RX_FDR_CONTROLm_SYMERR_THRESHOLDf_SET(r,f) (r).rx_fdr_control[0]=(((r).rx_fdr_control[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define RX_FDR_CONTROLm_SYMERR_WINDOWf_GET(r) ((((r).rx_fdr_control[0]) >> 17) & 0x7)
#define RX_FDR_CONTROLm_SYMERR_WINDOWf_SET(r,f) (r).rx_fdr_control[0]=(((r).rx_fdr_control[0] & ~((uint32_t)0x7 << 17)) | ((((uint32_t)f) & 0x7) << 17))

/*
 * These macros can be used to access RX_FDR_CONTROL.
 */
#define READ_RX_FDR_CONTROLm(pa,p,i,m) bcmpmac_read(pa,p,RX_FDR_CONTROLm_OFFSET,i,RX_FDR_CONTROLm_SIZE,(m._rx_fdr_control))
#define WRITE_RX_FDR_CONTROLm(pa,p,i,m) bcmpmac_write(pa,p,RX_FDR_CONTROLm_OFFSET,i,RX_FDR_CONTROLm_SIZE,&(m._rx_fdr_control))

/*******************************************************************************
 * End of 'RX_FDR_CONTROLm'
 */




/*******************************************************************************
 * MEMORY:  RX_FDR_STATUS
 * BLOCKS:   CDPORT
 * SIZE:     424
 */
#define RX_FDR_STATUSm_OFFSET 0x20000000

#define RX_FDR_STATUSm_MIN 0
#define RX_FDR_STATUSm_MAX 3
#define RX_FDR_STATUSm_CMAX(u) 3
#define RX_FDR_STATUSm_SIZE 53

/*
 * This structure should be used to declare and program RX_FDR_STATUS.
 */
typedef union RX_FDR_STATUSm_s {
    uint32_t v[14];
    uint32_t rx_fdr_status[14];
    uint32_t _rx_fdr_status;
} RX_FDR_STATUSm_t;

#define RX_FDR_STATUSm_CLR(r) sal_memset(&((r).rx_fdr_status[0]), 0, sizeof(RX_FDR_STATUSm_t))
#define RX_FDR_STATUSm_SET(r,i,d) (r).rx_fdr_status[i] = d
#define RX_FDR_STATUSm_GET(r,i) (r).rx_fdr_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_FDR_STATUSm_S0f_GET(r) ((r).rx_fdr_status[0])
#define RX_FDR_STATUSm_S0f_SET(r,f) (r).rx_fdr_status[0]=((uint32_t)f)
#define RX_FDR_STATUSm_S1f_GET(r) ((r).rx_fdr_status[1])
#define RX_FDR_STATUSm_S1f_SET(r,f) (r).rx_fdr_status[1]=((uint32_t)f)
#define RX_FDR_STATUSm_S2f_GET(r) ((r).rx_fdr_status[2])
#define RX_FDR_STATUSm_S2f_SET(r,f) (r).rx_fdr_status[2]=((uint32_t)f)
#define RX_FDR_STATUSm_S3f_GET(r) ((r).rx_fdr_status[3])
#define RX_FDR_STATUSm_S3f_SET(r,f) (r).rx_fdr_status[3]=((uint32_t)f)
#define RX_FDR_STATUSm_S4f_GET(r) ((r).rx_fdr_status[4])
#define RX_FDR_STATUSm_S4f_SET(r,f) (r).rx_fdr_status[4]=((uint32_t)f)
#define RX_FDR_STATUSm_S5f_GET(r) ((r).rx_fdr_status[5])
#define RX_FDR_STATUSm_S5f_SET(r,f) (r).rx_fdr_status[5]=((uint32_t)f)
#define RX_FDR_STATUSm_S6f_GET(r) ((r).rx_fdr_status[6])
#define RX_FDR_STATUSm_S6f_SET(r,f) (r).rx_fdr_status[6]=((uint32_t)f)
#define RX_FDR_STATUSm_S7f_GET(r) ((r).rx_fdr_status[7])
#define RX_FDR_STATUSm_S7f_SET(r,f) (r).rx_fdr_status[7]=((uint32_t)f)
#define RX_FDR_STATUSm_SYM_ERRf_GET(r) ((r).rx_fdr_status[8])
#define RX_FDR_STATUSm_SYM_ERRf_SET(r,f) (r).rx_fdr_status[8]=((uint32_t)f)
#define RX_FDR_STATUSm_CWf_GET(r) ((r).rx_fdr_status[9])
#define RX_FDR_STATUSm_CWf_SET(r,f) (r).rx_fdr_status[9]=((uint32_t)f)
#define RX_FDR_STATUSm_UNCORR_CWf_GET(r) ((r).rx_fdr_status[10])
#define RX_FDR_STATUSm_UNCORR_CWf_SET(r,f) (r).rx_fdr_status[10]=((uint32_t)f)
#define RX_FDR_STATUSm_START_TIMEf_GET(r,a) bcmpmac_field_get((r).rx_fdr_status,352,387,a)
#define RX_FDR_STATUSm_START_TIMEf_SET(r,a) bcmpmac_field_set((r).rx_fdr_status,352,387,a)
#define RX_FDR_STATUSm_END_TIMEf_GET(r,a) bcmpmac_field_get((r).rx_fdr_status,388,423,a)
#define RX_FDR_STATUSm_END_TIMEf_SET(r,a) bcmpmac_field_set((r).rx_fdr_status,388,423,a)

/*
 * These macros can be used to access RX_FDR_STATUS.
 */
#define READ_RX_FDR_STATUSm(pa,p,i,m) bcmpmac_read(pa,p,RX_FDR_STATUSm_OFFSET,i,RX_FDR_STATUSm_SIZE,(m._rx_fdr_status))
#define WRITE_RX_FDR_STATUSm(pa,p,i,m) bcmpmac_write(pa,p,RX_FDR_STATUSm_OFFSET,i,RX_FDR_STATUSm_SIZE,&(m._rx_fdr_status))

/*******************************************************************************
 * End of 'RX_FDR_STATUSm'
 */




/*******************************************************************************
 * MEMORY:  RX_LKUP_1588_MEM_MPP0
 * BLOCKS:   CDPORT
 * SIZE:     80
 */
#define RX_LKUP_1588_MEM_MPP0m_OFFSET 0x20000000

#define RX_LKUP_1588_MEM_MPP0m_MIN 0
#define RX_LKUP_1588_MEM_MPP0m_MAX 79
#define RX_LKUP_1588_MEM_MPP0m_CMAX(u) 79
#define RX_LKUP_1588_MEM_MPP0m_SIZE 10

/*
 * This structure should be used to declare and program RX_LKUP_1588_MEM_MPP0.
 */
typedef union RX_LKUP_1588_MEM_MPP0m_s {
    uint32_t v[3];
    uint32_t rx_lkup_1588_mem_mpp0[3];
    uint32_t _rx_lkup_1588_mem_mpp0;
} RX_LKUP_1588_MEM_MPP0m_t;

#define RX_LKUP_1588_MEM_MPP0m_CLR(r) sal_memset(&((r).rx_lkup_1588_mem_mpp0[0]), 0, sizeof(RX_LKUP_1588_MEM_MPP0m_t))
#define RX_LKUP_1588_MEM_MPP0m_SET(r,i,d) (r).rx_lkup_1588_mem_mpp0[i] = d
#define RX_LKUP_1588_MEM_MPP0m_GET(r,i) (r).rx_lkup_1588_mem_mpp0[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_LKUP_1588_MEM_MPP0m_LKUP_1588_MEM_DATAf_GET(r,a) bcmpmac_field_get((r).rx_lkup_1588_mem_mpp0,0,79,a)
#define RX_LKUP_1588_MEM_MPP0m_LKUP_1588_MEM_DATAf_SET(r,a) bcmpmac_field_set((r).rx_lkup_1588_mem_mpp0,0,79,a)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_FRAC_NS_0f_GET(r) (((r).rx_lkup_1588_mem_mpp0[0]) & 0xf)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_FRAC_NS_0f_SET(r,f) (r).rx_lkup_1588_mem_mpp0[0]=(((r).rx_lkup_1588_mem_mpp0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_INT_NS_0f_GET(r) ((((r).rx_lkup_1588_mem_mpp0[0]) >> 4) & 0x7ff)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_INT_NS_0f_SET(r,f) (r).rx_lkup_1588_mem_mpp0[0]=(((r).rx_lkup_1588_mem_mpp0[0] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4))
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_VL_0f_GET(r) ((((r).rx_lkup_1588_mem_mpp0[0]) >> 15) & 0x1f)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_VL_0f_SET(r,f) (r).rx_lkup_1588_mem_mpp0[0]=(((r).rx_lkup_1588_mem_mpp0[0] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_FRAC_NS_1f_GET(r) ((((r).rx_lkup_1588_mem_mpp0[0]) >> 20) & 0xf)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_FRAC_NS_1f_SET(r,f) (r).rx_lkup_1588_mem_mpp0[0]=(((r).rx_lkup_1588_mem_mpp0[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_INT_NS_1f_GET(r) bcmpmac_field32_get((r).rx_lkup_1588_mem_mpp0,24,34)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_INT_NS_1f_SET(r,f) bcmpmac_field32_set((r).rx_lkup_1588_mem_mpp0,24,34,f)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_VL_1f_GET(r) ((((r).rx_lkup_1588_mem_mpp0[1]) >> 3) & 0x1f)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_VL_1f_SET(r,f) (r).rx_lkup_1588_mem_mpp0[1]=(((r).rx_lkup_1588_mem_mpp0[1] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_FRAC_NS_2f_GET(r) ((((r).rx_lkup_1588_mem_mpp0[1]) >> 8) & 0xf)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_FRAC_NS_2f_SET(r,f) (r).rx_lkup_1588_mem_mpp0[1]=(((r).rx_lkup_1588_mem_mpp0[1] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_INT_NS_2f_GET(r) ((((r).rx_lkup_1588_mem_mpp0[1]) >> 12) & 0x7ff)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_INT_NS_2f_SET(r,f) (r).rx_lkup_1588_mem_mpp0[1]=(((r).rx_lkup_1588_mem_mpp0[1] & ~((uint32_t)0x7ff << 12)) | ((((uint32_t)f) & 0x7ff) << 12))
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_VL_2f_GET(r) ((((r).rx_lkup_1588_mem_mpp0[1]) >> 23) & 0x1f)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_VL_2f_SET(r,f) (r).rx_lkup_1588_mem_mpp0[1]=(((r).rx_lkup_1588_mem_mpp0[1] & ~((uint32_t)0x1f << 23)) | ((((uint32_t)f) & 0x1f) << 23))
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_FRAC_NS_3f_GET(r) ((((r).rx_lkup_1588_mem_mpp0[1]) >> 28) & 0xf)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_FRAC_NS_3f_SET(r,f) (r).rx_lkup_1588_mem_mpp0[1]=(((r).rx_lkup_1588_mem_mpp0[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_INT_NS_3f_GET(r) (((r).rx_lkup_1588_mem_mpp0[2]) & 0x7ff)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_STEP_DELAY_INT_NS_3f_SET(r,f) (r).rx_lkup_1588_mem_mpp0[2]=(((r).rx_lkup_1588_mem_mpp0[2] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_VL_3f_GET(r) ((((r).rx_lkup_1588_mem_mpp0[2]) >> 11) & 0x1f)
#define RX_LKUP_1588_MEM_MPP0m_RX_MPP0_1588_VL_3f_SET(r,f) (r).rx_lkup_1588_mem_mpp0[2]=(((r).rx_lkup_1588_mem_mpp0[2] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access RX_LKUP_1588_MEM_MPP0.
 */
#define READ_RX_LKUP_1588_MEM_MPP0m(pa,p,i,m) bcmpmac_read(pa,p,RX_LKUP_1588_MEM_MPP0m_OFFSET,i,RX_LKUP_1588_MEM_MPP0m_SIZE,(m._rx_lkup_1588_mem_mpp0))
#define WRITE_RX_LKUP_1588_MEM_MPP0m(pa,p,i,m) bcmpmac_write(pa,p,RX_LKUP_1588_MEM_MPP0m_OFFSET,i,RX_LKUP_1588_MEM_MPP0m_SIZE,&(m._rx_lkup_1588_mem_mpp0))

/*******************************************************************************
 * End of 'RX_LKUP_1588_MEM_MPP0m'
 */




/*******************************************************************************
 * MEMORY:  RX_LKUP_1588_MEM_MPP1
 * BLOCKS:   CDPORT
 * SIZE:     80
 */
#define RX_LKUP_1588_MEM_MPP1m_OFFSET 0x20000000

#define RX_LKUP_1588_MEM_MPP1m_MIN 0
#define RX_LKUP_1588_MEM_MPP1m_MAX 79
#define RX_LKUP_1588_MEM_MPP1m_CMAX(u) 79
#define RX_LKUP_1588_MEM_MPP1m_SIZE 10

/*
 * This structure should be used to declare and program RX_LKUP_1588_MEM_MPP1.
 */
typedef union RX_LKUP_1588_MEM_MPP1m_s {
    uint32_t v[3];
    uint32_t rx_lkup_1588_mem_mpp1[3];
    uint32_t _rx_lkup_1588_mem_mpp1;
} RX_LKUP_1588_MEM_MPP1m_t;

#define RX_LKUP_1588_MEM_MPP1m_CLR(r) sal_memset(&((r).rx_lkup_1588_mem_mpp1[0]), 0, sizeof(RX_LKUP_1588_MEM_MPP1m_t))
#define RX_LKUP_1588_MEM_MPP1m_SET(r,i,d) (r).rx_lkup_1588_mem_mpp1[i] = d
#define RX_LKUP_1588_MEM_MPP1m_GET(r,i) (r).rx_lkup_1588_mem_mpp1[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_LKUP_1588_MEM_MPP1m_LKUP_1588_MEM_DATAf_GET(r,a) bcmpmac_field_get((r).rx_lkup_1588_mem_mpp1,0,79,a)
#define RX_LKUP_1588_MEM_MPP1m_LKUP_1588_MEM_DATAf_SET(r,a) bcmpmac_field_set((r).rx_lkup_1588_mem_mpp1,0,79,a)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_FRAC_NS_0f_GET(r) (((r).rx_lkup_1588_mem_mpp1[0]) & 0xf)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_FRAC_NS_0f_SET(r,f) (r).rx_lkup_1588_mem_mpp1[0]=(((r).rx_lkup_1588_mem_mpp1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_INT_NS_0f_GET(r) ((((r).rx_lkup_1588_mem_mpp1[0]) >> 4) & 0x7ff)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_INT_NS_0f_SET(r,f) (r).rx_lkup_1588_mem_mpp1[0]=(((r).rx_lkup_1588_mem_mpp1[0] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4))
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_VL_0f_GET(r) ((((r).rx_lkup_1588_mem_mpp1[0]) >> 15) & 0x1f)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_VL_0f_SET(r,f) (r).rx_lkup_1588_mem_mpp1[0]=(((r).rx_lkup_1588_mem_mpp1[0] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_FRAC_NS_1f_GET(r) ((((r).rx_lkup_1588_mem_mpp1[0]) >> 20) & 0xf)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_FRAC_NS_1f_SET(r,f) (r).rx_lkup_1588_mem_mpp1[0]=(((r).rx_lkup_1588_mem_mpp1[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_INT_NS_1f_GET(r) bcmpmac_field32_get((r).rx_lkup_1588_mem_mpp1,24,34)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_INT_NS_1f_SET(r,f) bcmpmac_field32_set((r).rx_lkup_1588_mem_mpp1,24,34,f)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_VL_1f_GET(r) ((((r).rx_lkup_1588_mem_mpp1[1]) >> 3) & 0x1f)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_VL_1f_SET(r,f) (r).rx_lkup_1588_mem_mpp1[1]=(((r).rx_lkup_1588_mem_mpp1[1] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_FRAC_NS_2f_GET(r) ((((r).rx_lkup_1588_mem_mpp1[1]) >> 8) & 0xf)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_FRAC_NS_2f_SET(r,f) (r).rx_lkup_1588_mem_mpp1[1]=(((r).rx_lkup_1588_mem_mpp1[1] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_INT_NS_2f_GET(r) ((((r).rx_lkup_1588_mem_mpp1[1]) >> 12) & 0x7ff)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_INT_NS_2f_SET(r,f) (r).rx_lkup_1588_mem_mpp1[1]=(((r).rx_lkup_1588_mem_mpp1[1] & ~((uint32_t)0x7ff << 12)) | ((((uint32_t)f) & 0x7ff) << 12))
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_VL_2f_GET(r) ((((r).rx_lkup_1588_mem_mpp1[1]) >> 23) & 0x1f)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_VL_2f_SET(r,f) (r).rx_lkup_1588_mem_mpp1[1]=(((r).rx_lkup_1588_mem_mpp1[1] & ~((uint32_t)0x1f << 23)) | ((((uint32_t)f) & 0x1f) << 23))
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_FRAC_NS_3f_GET(r) ((((r).rx_lkup_1588_mem_mpp1[1]) >> 28) & 0xf)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_FRAC_NS_3f_SET(r,f) (r).rx_lkup_1588_mem_mpp1[1]=(((r).rx_lkup_1588_mem_mpp1[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_INT_NS_3f_GET(r) (((r).rx_lkup_1588_mem_mpp1[2]) & 0x7ff)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_STEP_DELAY_INT_NS_3f_SET(r,f) (r).rx_lkup_1588_mem_mpp1[2]=(((r).rx_lkup_1588_mem_mpp1[2] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_VL_3f_GET(r) ((((r).rx_lkup_1588_mem_mpp1[2]) >> 11) & 0x1f)
#define RX_LKUP_1588_MEM_MPP1m_RX_MPP1_1588_VL_3f_SET(r,f) (r).rx_lkup_1588_mem_mpp1[2]=(((r).rx_lkup_1588_mem_mpp1[2] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access RX_LKUP_1588_MEM_MPP1.
 */
#define READ_RX_LKUP_1588_MEM_MPP1m(pa,p,i,m) bcmpmac_read(pa,p,RX_LKUP_1588_MEM_MPP1m_OFFSET,i,RX_LKUP_1588_MEM_MPP1m_SIZE,(m._rx_lkup_1588_mem_mpp1))
#define WRITE_RX_LKUP_1588_MEM_MPP1m(pa,p,i,m) bcmpmac_write(pa,p,RX_LKUP_1588_MEM_MPP1m_OFFSET,i,RX_LKUP_1588_MEM_MPP1m_SIZE,&(m._rx_lkup_1588_mem_mpp1))

/*******************************************************************************
 * End of 'RX_LKUP_1588_MEM_MPP1m'
 */




/*******************************************************************************
 * MEMORY:  SPEED_ID_TABLE
 * BLOCKS:   CDPORT
 * SIZE:     161
 */
#define SPEED_ID_TABLEm_OFFSET 0x20000000

#define SPEED_ID_TABLEm_MIN 0
#define SPEED_ID_TABLEm_MAX 63
#define SPEED_ID_TABLEm_CMAX(u) 63
#define SPEED_ID_TABLEm_SIZE 21

/*
 * This structure should be used to declare and program SPEED_ID_TABLE.
 */
typedef union SPEED_ID_TABLEm_s {
    uint32_t v[6];
    uint32_t speed_id_table[6];
    uint32_t _speed_id_table;
} SPEED_ID_TABLEm_t;

#define SPEED_ID_TABLEm_CLR(r) sal_memset(&((r).speed_id_table[0]), 0, sizeof(SPEED_ID_TABLEm_t))
#define SPEED_ID_TABLEm_SET(r,i,d) (r).speed_id_table[i] = d
#define SPEED_ID_TABLEm_GET(r,i) (r).speed_id_table[i]

/*
 * These macros can be used to access individual fields.
 */
#define SPEED_ID_TABLEm_SPEED_ID_DATAf_GET(r,a) bcmpmac_field_get((r).speed_id_table,0,160,a)
#define SPEED_ID_TABLEm_SPEED_ID_DATAf_SET(r,a) bcmpmac_field_set((r).speed_id_table,0,160,a)
#define SPEED_ID_TABLEm_AM_TABLE_INDEXf_GET(r) (((r).speed_id_table[0]) & 0x3f)
#define SPEED_ID_TABLEm_AM_TABLE_INDEXf_SET(r,f) (r).speed_id_table[0]=(((r).speed_id_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define SPEED_ID_TABLEm_FEC_ARCHf_GET(r) ((((r).speed_id_table[0]) >> 6) & 0x7)
#define SPEED_ID_TABLEm_FEC_ARCHf_SET(r,f) (r).speed_id_table[0]=(((r).speed_id_table[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define SPEED_ID_TABLEm_SYMBOL_INTERLEAVEf_GET(r) ((((r).speed_id_table[0]) >> 9) & 0x1)
#define SPEED_ID_TABLEm_SYMBOL_INTERLEAVEf_SET(r,f) (r).speed_id_table[0]=(((r).speed_id_table[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define SPEED_ID_TABLEm_TC_XOR_CONTROLf_GET(r) ((((r).speed_id_table[0]) >> 10) & 0x1)
#define SPEED_ID_TABLEm_TC_XOR_CONTROLf_SET(r,f) (r).speed_id_table[0]=(((r).speed_id_table[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define SPEED_ID_TABLEm_RS_FEC_SYNC_HEADER_MODEf_GET(r) ((((r).speed_id_table[0]) >> 11) & 0x3)
#define SPEED_ID_TABLEm_RS_FEC_SYNC_HEADER_MODEf_SET(r,f) (r).speed_id_table[0]=(((r).speed_id_table[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define SPEED_ID_TABLEm_RS_FEC_CWM_NIBBLE_MATCH_COUNTf_GET(r) ((((r).speed_id_table[0]) >> 13) & 0xf)
#define SPEED_ID_TABLEm_RS_FEC_CWM_NIBBLE_MATCH_COUNTf_SET(r,f) (r).speed_id_table[0]=(((r).speed_id_table[0] & ~((uint32_t)0xf << 13)) | ((((uint32_t)f) & 0xf) << 13))
#define SPEED_ID_TABLEm_BASE_R_FEC_SYNC_HEADER_MODEf_GET(r) ((((r).speed_id_table[0]) >> 17) & 0x3)
#define SPEED_ID_TABLEm_BASE_R_FEC_SYNC_HEADER_MODEf_SET(r,f) (r).speed_id_table[0]=(((r).speed_id_table[0] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define SPEED_ID_TABLEm_RS_FEC_SYMBOL_ERROR_WINDOW_MODEf_GET(r) ((((r).speed_id_table[0]) >> 19) & 0x3)
#define SPEED_ID_TABLEm_RS_FEC_SYMBOL_ERROR_WINDOW_MODEf_SET(r,f) (r).speed_id_table[0]=(((r).speed_id_table[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define SPEED_ID_TABLEm_RS_FEC_SYMBOL_ERROR_COUNT_THRESHOLDf_GET(r) bcmpmac_field32_get((r).speed_id_table,21,34)
#define SPEED_ID_TABLEm_RS_FEC_SYMBOL_ERROR_COUNT_THRESHOLDf_SET(r,f) bcmpmac_field32_set((r).speed_id_table,21,34,f)
#define SPEED_ID_TABLEm_DESKEW_FORWARDING_THRESHOLD_2XNf_GET(r) ((((r).speed_id_table[1]) >> 3) & 0xff)
#define SPEED_ID_TABLEm_DESKEW_FORWARDING_THRESHOLD_2XNf_SET(r,f) (r).speed_id_table[1]=(((r).speed_id_table[1] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define SPEED_ID_TABLEm_DESKEW_FORWARDING_THRESHOLD_1XNf_GET(r) ((((r).speed_id_table[1]) >> 11) & 0xff)
#define SPEED_ID_TABLEm_DESKEW_FORWARDING_THRESHOLD_1XNf_SET(r,f) (r).speed_id_table[1]=(((r).speed_id_table[1] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define SPEED_ID_TABLEm_BIT_MUX_MODEf_GET(r) ((((r).speed_id_table[1]) >> 19) & 0x3)
#define SPEED_ID_TABLEm_BIT_MUX_MODEf_SET(r,f) (r).speed_id_table[1]=(((r).speed_id_table[1] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define SPEED_ID_TABLEm_NUM_LANESf_GET(r) ((((r).speed_id_table[1]) >> 21) & 0x7)
#define SPEED_ID_TABLEm_NUM_LANESf_SET(r,f) (r).speed_id_table[1]=(((r).speed_id_table[1] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define SPEED_ID_TABLEm_DESKEW_WINDOW_WITHOUT_RS_FECf_GET(r) ((((r).speed_id_table[1]) >> 24) & 0xff)
#define SPEED_ID_TABLEm_DESKEW_WINDOW_WITHOUT_RS_FECf_SET(r,f) (r).speed_id_table[1]=(((r).speed_id_table[1] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define SPEED_ID_TABLEm_DESKEW_WINDOW_WITH_RS_FECf_GET(r) (((r).speed_id_table[2]) & 0xff)
#define SPEED_ID_TABLEm_DESKEW_WINDOW_WITH_RS_FECf_SET(r,f) (r).speed_id_table[2]=(((r).speed_id_table[2] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define SPEED_ID_TABLEm_BER_FSM_DISABLE_WITH_RS_FECf_GET(r) ((((r).speed_id_table[2]) >> 8) & 0x1)
#define SPEED_ID_TABLEm_BER_FSM_DISABLE_WITH_RS_FECf_SET(r,f) (r).speed_id_table[2]=(((r).speed_id_table[2] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define SPEED_ID_TABLEm_BER_FSM_DISABLE_WITHOUT_RS_FECf_GET(r) ((((r).speed_id_table[2]) >> 9) & 0x1)
#define SPEED_ID_TABLEm_BER_FSM_DISABLE_WITHOUT_RS_FECf_SET(r,f) (r).speed_id_table[2]=(((r).speed_id_table[2] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define SPEED_ID_TABLEm_BER_WINDOW_MODEf_GET(r) ((((r).speed_id_table[2]) >> 10) & 0x3)
#define SPEED_ID_TABLEm_BER_WINDOW_MODEf_SET(r,f) (r).speed_id_table[2]=(((r).speed_id_table[2] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define SPEED_ID_TABLEm_BER_TRIGGER_COUNTf_GET(r) ((((r).speed_id_table[2]) >> 12) & 0x1)
#define SPEED_ID_TABLEm_BER_TRIGGER_COUNTf_SET(r,f) (r).speed_id_table[2]=(((r).speed_id_table[2] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define SPEED_ID_TABLEm_CREDIT_QUOTIENTf_GET(r) ((((r).speed_id_table[2]) >> 13) & 0x7f)
#define SPEED_ID_TABLEm_CREDIT_QUOTIENTf_SET(r,f) (r).speed_id_table[2]=(((r).speed_id_table[2] & ~((uint32_t)0x7f << 13)) | ((((uint32_t)f) & 0x7f) << 13))
#define SPEED_ID_TABLEm_CREDIT_REMAINDERf_GET(r) ((((r).speed_id_table[2]) >> 20) & 0x7ff)
#define SPEED_ID_TABLEm_CREDIT_REMAINDERf_SET(r,f) (r).speed_id_table[2]=(((r).speed_id_table[2] & ~((uint32_t)0x7ff << 20)) | ((((uint32_t)f) & 0x7ff) << 20))
#define SPEED_ID_TABLEm_CREDIT_DIVISORf_GET(r) bcmpmac_field32_get((r).speed_id_table,95,105)
#define SPEED_ID_TABLEm_CREDIT_DIVISORf_SET(r,f) bcmpmac_field32_set((r).speed_id_table,95,105,f)
#define SPEED_ID_TABLEm_USE_CL49_BLOCK_SYNCf_GET(r) ((((r).speed_id_table[3]) >> 10) & 0x1)
#define SPEED_ID_TABLEm_USE_CL49_BLOCK_SYNCf_SET(r,f) (r).speed_id_table[3]=(((r).speed_id_table[3] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define SPEED_ID_TABLEm_SCR_MODEf_GET(r) ((((r).speed_id_table[3]) >> 11) & 0x3)
#define SPEED_ID_TABLEm_SCR_MODEf_SET(r,f) (r).speed_id_table[3]=(((r).speed_id_table[3] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define SPEED_ID_TABLEm_CODEC_MODEf_GET(r) ((((r).speed_id_table[3]) >> 13) & 0x3)
#define SPEED_ID_TABLEm_CODEC_MODEf_SET(r,f) (r).speed_id_table[3]=(((r).speed_id_table[3] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define SPEED_ID_TABLEm_TRAINING_ENf_GET(r) ((((r).speed_id_table[3]) >> 15) & 0x1)
#define SPEED_ID_TABLEm_TRAINING_ENf_SET(r,f) (r).speed_id_table[3]=(((r).speed_id_table[3] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define SPEED_ID_TABLEm_AN_TIMER_SELECTf_GET(r) ((((r).speed_id_table[3]) >> 16) & 0x1)
#define SPEED_ID_TABLEm_AN_TIMER_SELECTf_SET(r,f) (r).speed_id_table[3]=(((r).speed_id_table[3] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define SPEED_ID_TABLEm_PMD_PAM4_MODEf_GET(r) ((((r).speed_id_table[3]) >> 17) & 0x7)
#define SPEED_ID_TABLEm_PMD_PAM4_MODEf_SET(r,f) (r).speed_id_table[3]=(((r).speed_id_table[3] & ~((uint32_t)0x7 << 17)) | ((((uint32_t)f) & 0x7) << 17))
#define SPEED_ID_TABLEm_PMD_OSR_MODEf_GET(r) ((((r).speed_id_table[3]) >> 20) & 0xf)
#define SPEED_ID_TABLEm_PMD_OSR_MODEf_SET(r,f) (r).speed_id_table[3]=(((r).speed_id_table[3] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define SPEED_ID_TABLEm_T_PMA_WATERMARKf_GET(r) ((((r).speed_id_table[3]) >> 24) & 0xf)
#define SPEED_ID_TABLEm_T_PMA_WATERMARKf_SET(r,f) (r).speed_id_table[3]=(((r).speed_id_table[3] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define SPEED_ID_TABLEm_L_TPMA_WATERMARKf_GET(r) ((((r).speed_id_table[3]) >> 28) & 0x7)
#define SPEED_ID_TABLEm_L_TPMA_WATERMARKf_SET(r,f) (r).speed_id_table[3]=(((r).speed_id_table[3] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define SPEED_ID_TABLEm_LOOP_BLOCK_COUNT_FOR_TSf_GET(r) bcmpmac_field32_get((r).speed_id_table,127,134)
#define SPEED_ID_TABLEm_LOOP_BLOCK_COUNT_FOR_TSf_SET(r,f) bcmpmac_field32_set((r).speed_id_table,127,134,f)
#define SPEED_ID_TABLEm_LOOP_BIT_COUNT_FOR_TSf_GET(r) ((((r).speed_id_table[4]) >> 7) & 0x3fff)
#define SPEED_ID_TABLEm_LOOP_BIT_COUNT_FOR_TSf_SET(r,f) (r).speed_id_table[4]=(((r).speed_id_table[4] & ~((uint32_t)0x3fff << 7)) | ((((uint32_t)f) & 0x3fff) << 7))
#define SPEED_ID_TABLEm_AM_LOCK_FSM_MODEf_GET(r) ((((r).speed_id_table[4]) >> 21) & 0x1)
#define SPEED_ID_TABLEm_AM_LOCK_FSM_MODEf_SET(r,f) (r).speed_id_table[4]=(((r).speed_id_table[4] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define SPEED_ID_TABLEm_T_PMA_START_MODEf_GET(r) ((((r).speed_id_table[4]) >> 22) & 0x1)
#define SPEED_ID_TABLEm_T_PMA_START_MODEf_SET(r,f) (r).speed_id_table[4]=(((r).speed_id_table[4] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define SPEED_ID_TABLEm_HI_SER_ENABLEf_GET(r) ((((r).speed_id_table[4]) >> 23) & 0x1)
#define SPEED_ID_TABLEm_HI_SER_ENABLEf_SET(r,f) (r).speed_id_table[4]=(((r).speed_id_table[4] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define SPEED_ID_TABLEm_T_PMA_INPUT_WIDTH_MODEf_GET(r) ((((r).speed_id_table[4]) >> 24) & 0x3)
#define SPEED_ID_TABLEm_T_PMA_INPUT_WIDTH_MODEf_SET(r,f) (r).speed_id_table[4]=(((r).speed_id_table[4] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define SPEED_ID_TABLEm_T_PMA_OUTPUT_WIDTH_MODEf_GET(r) ((((r).speed_id_table[4]) >> 26) & 0x3)
#define SPEED_ID_TABLEm_T_PMA_OUTPUT_WIDTH_MODEf_SET(r,f) (r).speed_id_table[4]=(((r).speed_id_table[4] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define SPEED_ID_TABLEm_BIT_MUX_MODE_MODIFIERf_GET(r) ((((r).speed_id_table[4]) >> 28) & 0x1)
#define SPEED_ID_TABLEm_BIT_MUX_MODE_MODIFIERf_SET(r,f) (r).speed_id_table[4]=(((r).speed_id_table[4] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define SPEED_ID_TABLEm_NUM_LANES_MODIFIERf_GET(r) ((((r).speed_id_table[4]) >> 29) & 0x1)
#define SPEED_ID_TABLEm_NUM_LANES_MODIFIERf_SET(r,f) (r).speed_id_table[4]=(((r).speed_id_table[4] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define SPEED_ID_TABLEm_MAPPING_SELf_GET(r) ((((r).speed_id_table[4]) >> 30) & 0x1)
#define SPEED_ID_TABLEm_MAPPING_SELf_SET(r,f) (r).speed_id_table[4]=(((r).speed_id_table[4] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define SPEED_ID_TABLEm_RSVDf_GET(r) bcmpmac_field32_get((r).speed_id_table,159,160)
#define SPEED_ID_TABLEm_RSVDf_SET(r,f) bcmpmac_field32_set((r).speed_id_table,159,160,f)

/*
 * These macros can be used to access SPEED_ID_TABLE.
 */
#define READ_SPEED_ID_TABLEm(pa,p,i,m) bcmpmac_read(pa,p,SPEED_ID_TABLEm_OFFSET,i,SPEED_ID_TABLEm_SIZE,(m._speed_id_table))
#define WRITE_SPEED_ID_TABLEm(pa,p,i,m) bcmpmac_write(pa,p,SPEED_ID_TABLEm_OFFSET,i,SPEED_ID_TABLEm_SIZE,&(m._speed_id_table))

/*******************************************************************************
 * End of 'SPEED_ID_TABLEm'
 */




/*******************************************************************************
 * MEMORY:  SPEED_PRIORITY_MAP_TBL
 * BLOCKS:   CDPORT
 * SIZE:     288
 */
#define SPEED_PRIORITY_MAP_TBLm_OFFSET 0x20000000

#define SPEED_PRIORITY_MAP_TBLm_MIN 0
#define SPEED_PRIORITY_MAP_TBLm_MAX 0
#define SPEED_PRIORITY_MAP_TBLm_CMAX(u) 0
#define SPEED_PRIORITY_MAP_TBLm_SIZE 36

/*
 * This structure should be used to declare and program SPEED_PRIORITY_MAP_TBL.
 */
typedef union SPEED_PRIORITY_MAP_TBLm_s {
    uint32_t v[9];
    uint32_t speed_priority_map_tbl[9];
    uint32_t _speed_priority_map_tbl;
} SPEED_PRIORITY_MAP_TBLm_t;

#define SPEED_PRIORITY_MAP_TBLm_CLR(r) sal_memset(&((r).speed_priority_map_tbl[0]), 0, sizeof(SPEED_PRIORITY_MAP_TBLm_t))
#define SPEED_PRIORITY_MAP_TBLm_SET(r,i,d) (r).speed_priority_map_tbl[i] = d
#define SPEED_PRIORITY_MAP_TBLm_GET(r,i) (r).speed_priority_map_tbl[i]

/*
 * These macros can be used to access individual fields.
 */
#define SPEED_PRIORITY_MAP_TBLm_DATAf_GET(r,a) bcmpmac_field_get((r).speed_priority_map_tbl,0,287,a)
#define SPEED_PRIORITY_MAP_TBLm_DATAf_SET(r,a) bcmpmac_field_set((r).speed_priority_map_tbl,0,287,a)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_1f_GET(r) (((r).speed_priority_map_tbl[0]) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_1f_SET(r,f) (r).speed_priority_map_tbl[0]=(((r).speed_priority_map_tbl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_2f_GET(r) ((((r).speed_priority_map_tbl[0]) >> 6) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_2f_SET(r,f) (r).speed_priority_map_tbl[0]=(((r).speed_priority_map_tbl[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_3f_GET(r) ((((r).speed_priority_map_tbl[0]) >> 12) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_3f_SET(r,f) (r).speed_priority_map_tbl[0]=(((r).speed_priority_map_tbl[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_4f_GET(r) ((((r).speed_priority_map_tbl[0]) >> 18) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_4f_SET(r,f) (r).speed_priority_map_tbl[0]=(((r).speed_priority_map_tbl[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_5f_GET(r) ((((r).speed_priority_map_tbl[0]) >> 24) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_5f_SET(r,f) (r).speed_priority_map_tbl[0]=(((r).speed_priority_map_tbl[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_6f_GET(r) bcmpmac_field32_get((r).speed_priority_map_tbl,30,35)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_6f_SET(r,f) bcmpmac_field32_set((r).speed_priority_map_tbl,30,35,f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_7f_GET(r) ((((r).speed_priority_map_tbl[1]) >> 4) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_7f_SET(r,f) (r).speed_priority_map_tbl[1]=(((r).speed_priority_map_tbl[1] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_8f_GET(r) ((((r).speed_priority_map_tbl[1]) >> 10) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_8f_SET(r,f) (r).speed_priority_map_tbl[1]=(((r).speed_priority_map_tbl[1] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_9f_GET(r) ((((r).speed_priority_map_tbl[1]) >> 16) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_9f_SET(r,f) (r).speed_priority_map_tbl[1]=(((r).speed_priority_map_tbl[1] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_10f_GET(r) ((((r).speed_priority_map_tbl[1]) >> 22) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_10f_SET(r,f) (r).speed_priority_map_tbl[1]=(((r).speed_priority_map_tbl[1] & ~((uint32_t)0x3f << 22)) | ((((uint32_t)f) & 0x3f) << 22))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_11f_GET(r) bcmpmac_field32_get((r).speed_priority_map_tbl,60,65)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_11f_SET(r,f) bcmpmac_field32_set((r).speed_priority_map_tbl,60,65,f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_12f_GET(r) ((((r).speed_priority_map_tbl[2]) >> 2) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_12f_SET(r,f) (r).speed_priority_map_tbl[2]=(((r).speed_priority_map_tbl[2] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_13f_GET(r) ((((r).speed_priority_map_tbl[2]) >> 8) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_13f_SET(r,f) (r).speed_priority_map_tbl[2]=(((r).speed_priority_map_tbl[2] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_14f_GET(r) ((((r).speed_priority_map_tbl[2]) >> 14) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_14f_SET(r,f) (r).speed_priority_map_tbl[2]=(((r).speed_priority_map_tbl[2] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_15f_GET(r) ((((r).speed_priority_map_tbl[2]) >> 20) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_15f_SET(r,f) (r).speed_priority_map_tbl[2]=(((r).speed_priority_map_tbl[2] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_16f_GET(r) ((((r).speed_priority_map_tbl[2]) >> 26) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_16f_SET(r,f) (r).speed_priority_map_tbl[2]=(((r).speed_priority_map_tbl[2] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_17f_GET(r) (((r).speed_priority_map_tbl[3]) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_17f_SET(r,f) (r).speed_priority_map_tbl[3]=(((r).speed_priority_map_tbl[3] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_18f_GET(r) ((((r).speed_priority_map_tbl[3]) >> 6) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_18f_SET(r,f) (r).speed_priority_map_tbl[3]=(((r).speed_priority_map_tbl[3] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_19f_GET(r) ((((r).speed_priority_map_tbl[3]) >> 12) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_19f_SET(r,f) (r).speed_priority_map_tbl[3]=(((r).speed_priority_map_tbl[3] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_20f_GET(r) ((((r).speed_priority_map_tbl[3]) >> 18) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_20f_SET(r,f) (r).speed_priority_map_tbl[3]=(((r).speed_priority_map_tbl[3] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_21f_GET(r) ((((r).speed_priority_map_tbl[3]) >> 24) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_21f_SET(r,f) (r).speed_priority_map_tbl[3]=(((r).speed_priority_map_tbl[3] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_22f_GET(r) bcmpmac_field32_get((r).speed_priority_map_tbl,126,131)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_22f_SET(r,f) bcmpmac_field32_set((r).speed_priority_map_tbl,126,131,f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_23f_GET(r) ((((r).speed_priority_map_tbl[4]) >> 4) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_23f_SET(r,f) (r).speed_priority_map_tbl[4]=(((r).speed_priority_map_tbl[4] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_24f_GET(r) ((((r).speed_priority_map_tbl[4]) >> 10) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_24f_SET(r,f) (r).speed_priority_map_tbl[4]=(((r).speed_priority_map_tbl[4] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_25f_GET(r) ((((r).speed_priority_map_tbl[4]) >> 16) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_25f_SET(r,f) (r).speed_priority_map_tbl[4]=(((r).speed_priority_map_tbl[4] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_26f_GET(r) ((((r).speed_priority_map_tbl[4]) >> 22) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_26f_SET(r,f) (r).speed_priority_map_tbl[4]=(((r).speed_priority_map_tbl[4] & ~((uint32_t)0x3f << 22)) | ((((uint32_t)f) & 0x3f) << 22))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_27f_GET(r) bcmpmac_field32_get((r).speed_priority_map_tbl,156,161)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_27f_SET(r,f) bcmpmac_field32_set((r).speed_priority_map_tbl,156,161,f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_28f_GET(r) ((((r).speed_priority_map_tbl[5]) >> 2) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_28f_SET(r,f) (r).speed_priority_map_tbl[5]=(((r).speed_priority_map_tbl[5] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_29f_GET(r) ((((r).speed_priority_map_tbl[5]) >> 8) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_29f_SET(r,f) (r).speed_priority_map_tbl[5]=(((r).speed_priority_map_tbl[5] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_30f_GET(r) ((((r).speed_priority_map_tbl[5]) >> 14) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_30f_SET(r,f) (r).speed_priority_map_tbl[5]=(((r).speed_priority_map_tbl[5] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_31f_GET(r) ((((r).speed_priority_map_tbl[5]) >> 20) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_31f_SET(r,f) (r).speed_priority_map_tbl[5]=(((r).speed_priority_map_tbl[5] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_32f_GET(r) ((((r).speed_priority_map_tbl[5]) >> 26) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_32f_SET(r,f) (r).speed_priority_map_tbl[5]=(((r).speed_priority_map_tbl[5] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_33f_GET(r) (((r).speed_priority_map_tbl[6]) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_33f_SET(r,f) (r).speed_priority_map_tbl[6]=(((r).speed_priority_map_tbl[6] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_34f_GET(r) ((((r).speed_priority_map_tbl[6]) >> 6) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_34f_SET(r,f) (r).speed_priority_map_tbl[6]=(((r).speed_priority_map_tbl[6] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_35f_GET(r) ((((r).speed_priority_map_tbl[6]) >> 12) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_35f_SET(r,f) (r).speed_priority_map_tbl[6]=(((r).speed_priority_map_tbl[6] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_36f_GET(r) ((((r).speed_priority_map_tbl[6]) >> 18) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_36f_SET(r,f) (r).speed_priority_map_tbl[6]=(((r).speed_priority_map_tbl[6] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_37f_GET(r) ((((r).speed_priority_map_tbl[6]) >> 24) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_37f_SET(r,f) (r).speed_priority_map_tbl[6]=(((r).speed_priority_map_tbl[6] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_38f_GET(r) bcmpmac_field32_get((r).speed_priority_map_tbl,222,227)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_38f_SET(r,f) bcmpmac_field32_set((r).speed_priority_map_tbl,222,227,f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_39f_GET(r) ((((r).speed_priority_map_tbl[7]) >> 4) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_39f_SET(r,f) (r).speed_priority_map_tbl[7]=(((r).speed_priority_map_tbl[7] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_40f_GET(r) ((((r).speed_priority_map_tbl[7]) >> 10) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_40f_SET(r,f) (r).speed_priority_map_tbl[7]=(((r).speed_priority_map_tbl[7] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_41f_GET(r) ((((r).speed_priority_map_tbl[7]) >> 16) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_41f_SET(r,f) (r).speed_priority_map_tbl[7]=(((r).speed_priority_map_tbl[7] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_42f_GET(r) ((((r).speed_priority_map_tbl[7]) >> 22) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_42f_SET(r,f) (r).speed_priority_map_tbl[7]=(((r).speed_priority_map_tbl[7] & ~((uint32_t)0x3f << 22)) | ((((uint32_t)f) & 0x3f) << 22))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_43f_GET(r) bcmpmac_field32_get((r).speed_priority_map_tbl,252,257)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_43f_SET(r,f) bcmpmac_field32_set((r).speed_priority_map_tbl,252,257,f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_44f_GET(r) ((((r).speed_priority_map_tbl[8]) >> 2) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_44f_SET(r,f) (r).speed_priority_map_tbl[8]=(((r).speed_priority_map_tbl[8] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_45f_GET(r) ((((r).speed_priority_map_tbl[8]) >> 8) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_45f_SET(r,f) (r).speed_priority_map_tbl[8]=(((r).speed_priority_map_tbl[8] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_46f_GET(r) ((((r).speed_priority_map_tbl[8]) >> 14) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_46f_SET(r,f) (r).speed_priority_map_tbl[8]=(((r).speed_priority_map_tbl[8] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_47f_GET(r) ((((r).speed_priority_map_tbl[8]) >> 20) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_47f_SET(r,f) (r).speed_priority_map_tbl[8]=(((r).speed_priority_map_tbl[8] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_48f_GET(r) ((((r).speed_priority_map_tbl[8]) >> 26) & 0x3f)
#define SPEED_PRIORITY_MAP_TBLm_PRIORITY_48f_SET(r,f) (r).speed_priority_map_tbl[8]=(((r).speed_priority_map_tbl[8] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access SPEED_PRIORITY_MAP_TBL.
 */
#define READ_SPEED_PRIORITY_MAP_TBLm(pa,p,i,m) bcmpmac_read(pa,p,SPEED_PRIORITY_MAP_TBLm_OFFSET,i,SPEED_PRIORITY_MAP_TBLm_SIZE,(m._speed_priority_map_tbl))
#define WRITE_SPEED_PRIORITY_MAP_TBLm(pa,p,i,m) bcmpmac_write(pa,p,SPEED_PRIORITY_MAP_TBLm_OFFSET,i,SPEED_PRIORITY_MAP_TBLm_SIZE,&(m._speed_priority_map_tbl))

/*******************************************************************************
 * End of 'SPEED_PRIORITY_MAP_TBLm'
 */




/*******************************************************************************
 * MEMORY:  TX_LKUP_1588_MEM
 * BLOCKS:   CDPORT
 * SIZE:     81
 */
#define TX_LKUP_1588_MEMm_OFFSET 0x20000000

#define TX_LKUP_1588_MEMm_MIN 0
#define TX_LKUP_1588_MEMm_MAX 159
#define TX_LKUP_1588_MEMm_CMAX(u) 159
#define TX_LKUP_1588_MEMm_SIZE 11

/*
 * This structure should be used to declare and program TX_LKUP_1588_MEM.
 */
typedef union TX_LKUP_1588_MEMm_s {
    uint32_t v[3];
    uint32_t tx_lkup_1588_mem[3];
    uint32_t _tx_lkup_1588_mem;
} TX_LKUP_1588_MEMm_t;

#define TX_LKUP_1588_MEMm_CLR(r) sal_memset(&((r).tx_lkup_1588_mem[0]), 0, sizeof(TX_LKUP_1588_MEMm_t))
#define TX_LKUP_1588_MEMm_SET(r,i,d) (r).tx_lkup_1588_mem[i] = d
#define TX_LKUP_1588_MEMm_GET(r,i) (r).tx_lkup_1588_mem[i]

/*
 * These macros can be used to access individual fields.
 */
#define TX_LKUP_1588_MEMm_LKUP_1588_MEM_DATAf_GET(r,a) bcmpmac_field_get((r).tx_lkup_1588_mem,0,80,a)
#define TX_LKUP_1588_MEMm_LKUP_1588_MEM_DATAf_SET(r,a) bcmpmac_field_set((r).tx_lkup_1588_mem,0,80,a)
#define TX_LKUP_1588_MEMm_TX_1588_STEP_BIT_COUNT_0f_GET(r) (((r).tx_lkup_1588_mem[0]) & 0x3fff)
#define TX_LKUP_1588_MEMm_TX_1588_STEP_BIT_COUNT_0f_SET(r,f) (r).tx_lkup_1588_mem[0]=(((r).tx_lkup_1588_mem[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define TX_LKUP_1588_MEMm_TX_1588_LL_0f_GET(r) ((((r).tx_lkup_1588_mem[0]) >> 14) & 0x7)
#define TX_LKUP_1588_MEMm_TX_1588_LL_0f_SET(r,f) (r).tx_lkup_1588_mem[0]=(((r).tx_lkup_1588_mem[0] & ~((uint32_t)0x7 << 14)) | ((((uint32_t)f) & 0x7) << 14))
#define TX_LKUP_1588_MEMm_TX_1588_RESERVED_0f_GET(r) ((((r).tx_lkup_1588_mem[0]) >> 17) & 0x7)
#define TX_LKUP_1588_MEMm_TX_1588_RESERVED_0f_SET(r,f) (r).tx_lkup_1588_mem[0]=(((r).tx_lkup_1588_mem[0] & ~((uint32_t)0x7 << 17)) | ((((uint32_t)f) & 0x7) << 17))
#define TX_LKUP_1588_MEMm_TX_1588_STEP_BIT_COUNT_1f_GET(r) bcmpmac_field32_get((r).tx_lkup_1588_mem,20,33)
#define TX_LKUP_1588_MEMm_TX_1588_STEP_BIT_COUNT_1f_SET(r,f) bcmpmac_field32_set((r).tx_lkup_1588_mem,20,33,f)
#define TX_LKUP_1588_MEMm_TX_1588_LL_1f_GET(r) ((((r).tx_lkup_1588_mem[1]) >> 2) & 0x7)
#define TX_LKUP_1588_MEMm_TX_1588_LL_1f_SET(r,f) (r).tx_lkup_1588_mem[1]=(((r).tx_lkup_1588_mem[1] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define TX_LKUP_1588_MEMm_TX_1588_RESERVED_1f_GET(r) ((((r).tx_lkup_1588_mem[1]) >> 5) & 0x7)
#define TX_LKUP_1588_MEMm_TX_1588_RESERVED_1f_SET(r,f) (r).tx_lkup_1588_mem[1]=(((r).tx_lkup_1588_mem[1] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define TX_LKUP_1588_MEMm_TX_1588_STEP_BIT_COUNT_2f_GET(r) ((((r).tx_lkup_1588_mem[1]) >> 8) & 0x3fff)
#define TX_LKUP_1588_MEMm_TX_1588_STEP_BIT_COUNT_2f_SET(r,f) (r).tx_lkup_1588_mem[1]=(((r).tx_lkup_1588_mem[1] & ~((uint32_t)0x3fff << 8)) | ((((uint32_t)f) & 0x3fff) << 8))
#define TX_LKUP_1588_MEMm_TX_1588_LL_2f_GET(r) ((((r).tx_lkup_1588_mem[1]) >> 22) & 0x7)
#define TX_LKUP_1588_MEMm_TX_1588_LL_2f_SET(r,f) (r).tx_lkup_1588_mem[1]=(((r).tx_lkup_1588_mem[1] & ~((uint32_t)0x7 << 22)) | ((((uint32_t)f) & 0x7) << 22))
#define TX_LKUP_1588_MEMm_TX_1588_RESERVED_2f_GET(r) ((((r).tx_lkup_1588_mem[1]) >> 25) & 0x7)
#define TX_LKUP_1588_MEMm_TX_1588_RESERVED_2f_SET(r,f) (r).tx_lkup_1588_mem[1]=(((r).tx_lkup_1588_mem[1] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define TX_LKUP_1588_MEMm_TX_1588_STEP_BIT_COUNT_3f_GET(r) bcmpmac_field32_get((r).tx_lkup_1588_mem,60,73)
#define TX_LKUP_1588_MEMm_TX_1588_STEP_BIT_COUNT_3f_SET(r,f) bcmpmac_field32_set((r).tx_lkup_1588_mem,60,73,f)
#define TX_LKUP_1588_MEMm_TX_1588_LL_3f_GET(r) ((((r).tx_lkup_1588_mem[2]) >> 10) & 0x7)
#define TX_LKUP_1588_MEMm_TX_1588_LL_3f_SET(r,f) (r).tx_lkup_1588_mem[2]=(((r).tx_lkup_1588_mem[2] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define TX_LKUP_1588_MEMm_TX_1588_RESERVED_3f_GET(r) ((((r).tx_lkup_1588_mem[2]) >> 13) & 0x7)
#define TX_LKUP_1588_MEMm_TX_1588_RESERVED_3f_SET(r,f) (r).tx_lkup_1588_mem[2]=(((r).tx_lkup_1588_mem[2] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define TX_LKUP_1588_MEMm_RSVDf_GET(r) ((((r).tx_lkup_1588_mem[2]) >> 16) & 0x1)
#define TX_LKUP_1588_MEMm_RSVDf_SET(r,f) (r).tx_lkup_1588_mem[2]=(((r).tx_lkup_1588_mem[2] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access TX_LKUP_1588_MEM.
 */
#define READ_TX_LKUP_1588_MEMm(pa,p,i,m) bcmpmac_read(pa,p,TX_LKUP_1588_MEMm_OFFSET,i,TX_LKUP_1588_MEMm_SIZE,(m._tx_lkup_1588_mem))
#define WRITE_TX_LKUP_1588_MEMm(pa,p,i,m) bcmpmac_write(pa,p,TX_LKUP_1588_MEMm_OFFSET,i,TX_LKUP_1588_MEMm_SIZE,&(m._tx_lkup_1588_mem))

/*******************************************************************************
 * End of 'TX_LKUP_1588_MEMm'
 */




/*******************************************************************************
 * MEMORY:  TX_TWOSTEP_1588_TS
 * BLOCKS:   CDPORT
 * SIZE:     69
 */
#define TX_TWOSTEP_1588_TSm_OFFSET 0x20000000

#define TX_TWOSTEP_1588_TSm_MIN 0
#define TX_TWOSTEP_1588_TSm_MAX 3
#define TX_TWOSTEP_1588_TSm_CMAX(u) 3
#define TX_TWOSTEP_1588_TSm_SIZE 9

/*
 * This structure should be used to declare and program TX_TWOSTEP_1588_TS.
 */
typedef union TX_TWOSTEP_1588_TSm_s {
    uint32_t v[3];
    uint32_t tx_twostep_1588_ts[3];
    uint32_t _tx_twostep_1588_ts;
} TX_TWOSTEP_1588_TSm_t;

#define TX_TWOSTEP_1588_TSm_CLR(r) sal_memset(&((r).tx_twostep_1588_ts[0]), 0, sizeof(TX_TWOSTEP_1588_TSm_t))
#define TX_TWOSTEP_1588_TSm_SET(r,i,d) (r).tx_twostep_1588_ts[i] = d
#define TX_TWOSTEP_1588_TSm_GET(r,i) (r).tx_twostep_1588_ts[i]

/*
 * These macros can be used to access individual fields.
 */
#define TX_TWOSTEP_1588_TSm_TX_2STEP_1588_TIMESTAMPf_GET(r,a) bcmpmac_field_get((r).tx_twostep_1588_ts,0,51,a)
#define TX_TWOSTEP_1588_TSm_TX_2STEP_1588_TIMESTAMPf_SET(r,a) bcmpmac_field_set((r).tx_twostep_1588_ts,0,51,a)
#define TX_TWOSTEP_1588_TSm_TX_2STEP_1588_SEQIDf_GET(r) bcmpmac_field32_get((r).tx_twostep_1588_ts,52,67)
#define TX_TWOSTEP_1588_TSm_TX_2STEP_1588_SEQIDf_SET(r,f) bcmpmac_field32_set((r).tx_twostep_1588_ts,52,67,f)
#define TX_TWOSTEP_1588_TSm_TX_2STEP_1588_VLDf_GET(r) ((((r).tx_twostep_1588_ts[2]) >> 4) & 0x1)
#define TX_TWOSTEP_1588_TSm_TX_2STEP_1588_VLDf_SET(r,f) (r).tx_twostep_1588_ts[2]=(((r).tx_twostep_1588_ts[2] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access TX_TWOSTEP_1588_TS.
 */
#define READ_TX_TWOSTEP_1588_TSm(pa,p,i,m) bcmpmac_read(pa,p,TX_TWOSTEP_1588_TSm_OFFSET,i,TX_TWOSTEP_1588_TSm_SIZE,(m._tx_twostep_1588_ts))
#define WRITE_TX_TWOSTEP_1588_TSm(pa,p,i,m) bcmpmac_write(pa,p,TX_TWOSTEP_1588_TSm_OFFSET,i,TX_TWOSTEP_1588_TSm_SIZE,&(m._tx_twostep_1588_ts))

/*******************************************************************************
 * End of 'TX_TWOSTEP_1588_TSm'
 */




/*******************************************************************************
 * MEMORY:  UM_TABLE
 * BLOCKS:   CDPORT
 * SIZE:     52
 */
#define UM_TABLEm_OFFSET 0x20000000

#define UM_TABLEm_MIN 0
#define UM_TABLEm_MAX 63
#define UM_TABLEm_CMAX(u) 63
#define UM_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program UM_TABLE.
 */
typedef union UM_TABLEm_s {
    uint32_t v[2];
    uint32_t um_table[2];
    uint32_t _um_table;
} UM_TABLEm_t;

#define UM_TABLEm_CLR(r) sal_memset(&((r).um_table[0]), 0, sizeof(UM_TABLEm_t))
#define UM_TABLEm_SET(r,i,d) (r).um_table[i] = d
#define UM_TABLEm_GET(r,i) (r).um_table[i]

/*
 * These macros can be used to access individual fields.
 */
#define UM_TABLEm_UM_DATAf_GET(r,a) bcmpmac_field_get((r).um_table,0,51,a)
#define UM_TABLEm_UM_DATAf_SET(r,a) bcmpmac_field_set((r).um_table,0,51,a)
#define UM_TABLEm_UMf_GET(r) (((r).um_table[0]) & 0xffffff)
#define UM_TABLEm_UMf_SET(r,f) (r).um_table[0]=(((r).um_table[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define UM_TABLEm_CM_PADf_GET(r) ((((r).um_table[0]) >> 24) & 0xff)
#define UM_TABLEm_CM_PADf_SET(r,f) (r).um_table[0]=(((r).um_table[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define UM_TABLEm_UM_PADf_GET(r) (((r).um_table[1]) & 0xff)
#define UM_TABLEm_UM_PADf_SET(r,f) (r).um_table[1]=(((r).um_table[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define UM_TABLEm_CM_CONTROLf_GET(r) ((((r).um_table[1]) >> 8) & 0xff)
#define UM_TABLEm_CM_CONTROLf_SET(r,f) (r).um_table[1]=(((r).um_table[1] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define UM_TABLEm_RSVDf_GET(r) ((((r).um_table[1]) >> 16) & 0xf)
#define UM_TABLEm_RSVDf_SET(r,f) (r).um_table[1]=(((r).um_table[1] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))

/*
 * These macros can be used to access UM_TABLE.
 */
#define READ_UM_TABLEm(pa,p,i,m) bcmpmac_read(pa,p,UM_TABLEm_OFFSET,i,UM_TABLEm_SIZE,(m._um_table))
#define WRITE_UM_TABLEm(pa,p,i,m) bcmpmac_write(pa,p,UM_TABLEm_OFFSET,i,UM_TABLEm_SIZE,&(m._um_table))

/*******************************************************************************
 * End of 'UM_TABLEm'
 */




#endif /* BCM56996_A0_CDPORT_DEFS_H */
