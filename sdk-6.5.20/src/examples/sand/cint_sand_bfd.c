/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~BFD test~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/*
*
* 
* This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
* 
* Copyright 2007-2020 Broadcom Inc. All rights reserved.
* 
* File: cint_bfd.c
* Purpose: Example of using BFD APIs.
*
* Usage:
* 
* 
* 
* To run IPV4 test on JR2:
* BCM.0> cd $SDK/src/examples
* BCM.0> cint sand/utility/cint_sand_utils_global.c
* BCM.0> cint sand/utility/cint_sand_utils_vlan.c
* BCM.0> cint sand/utility/cint_sand_utils_oam.c
* BCM.0> cint sand/utility/cint_sand_utils_l3.c
* BCM.0> cint sand/utility/cint_sand_utils_mpls.c
* BCM.0> cint sand/utility/cint_sand_utils_oam.c
* BCM.0> cint sand/cint_ip_route.c
* BCM.0> cint sand/cint_sand_bfd.c
* BCM.0> cint
* bfd_local_discr = 0x300004;
* int rv;
* int unit = 0;
* int port1 = port_1;
* int port2 = port_2;
* int remote_port = -1;
* int is_extended_sip = 0;
* uint32 flags = BCM_BFD_ENDPOINT_IN_HW;
* int remote_port_fwd_strength = 0;
* rv = bfd_ipv4_run_with_defaults(unit, port1, port2, remote_port, is_extended_sip, flags, remote_port_fwd_strength, flags2);
*/

/** Global variables */

/**
* When set to "1" the MEPs will be created with RX statistics.
* RX packets are the packets that are received in the OAMP.
*/
int is_rx_statisitcs_enabled=0;
/**
* When set to "1" the MEPs will be created with TX statistics
* TX packets are the packets transmitted from the OAMP.
*/
int is_tx_statisitcs_enabled=0;
/**
* When set to "1" allocate 8k counters in database 5 for TX packets.
* When set to "2" allocate 8k counters in database 6 for RX packets.
* When set to "3" allocate 8k counters in database 5 for TX packets and 8k counters in database 6 for RX packets.
*/
int enable_oamp_counter_allocation=0;

/** Server mode: when set, endpoint is created on a different device */
int is_server = 0;

int port_1 = 13; /* physical port (signal generator)*/
int port_2 = 14;
int mpls_label = 100;

/* Globals - MAC addresses , ports & gports*/
int mpls_label_termination = 200;

int timeout_events_count_bfd = 0;
int timeout_multi_event_count_bfd=0;
int timein_multi_event_count_bfd=0;

int timeout_events_count_multi_bfd = 0;


int tunnel_id;

int pwe_ach=1; /* May be used by PWE router alert types in Jericho, set to 1 by default*/

/** Used for egress interface */
int next_hop_mac;

/** In case of JR2 only, we can decide not to set valid tx_gport */
int use_invalid_tx_gport=0;

/**
 * Trap code returned from creating a trap
 * for a non-accelerated endpoint
 */
int remote_gport_trap_code = 0;

/*enable bfd echo, 1- implementation without lem, 2 - implementation with lem*/
/** LEM implementation is Arad only! */
int bfd_echo=0;


/* context id initialization, will be retrieved from field_presel_fwd_layer_main */
bcm_field_context_t cint_bfd_echo_context_id_ipmf1 = BCM_FIELD_CONTEXT_ID_INVALID;
/* context priority */
bcm_field_presel_t  cint_bfd_echo_presel_id = 10;

/*enable bfd ipv4 single hop - not relevant for JR2*/
int single_hop_extended =0;

int fec_recycle = 0;
/** When set, a non-zero snoop strength is used for non-accelerated endpoints */
int use_trap_with_snoop = 0;

/* int_pri of bfd_ipv4 endpoint */
int int_pri = 0;

/** Created endpoint information */
oam__ep_info_s bfd_ep1;
oam__ep_info_s bfd_ep2;

/** BFD transmission period */
int bfd_tx_period = 100;


/** Inject BFD over IP PDUs from the OAMP to an MPLS outLIF (as
 *  opposed to L2 outLIF in the standard case). Jr2 and
 *  above only. */
int bfd_over_ip_transmit_into_mpls =0;

/* BFD IPv4 FLEX IPTOS */
/**
 * For Jericho2, no SOC property is needed
 * This can always be used for multi-hop.
 * For single-hop, only B0 and above.
 */
uint8 bfd_ipv4_flex_iptos = 0;

/**
 * When set, enables
 * "field group" feature
 * Not relevant for JR2
 */
int is_field_created = 0;

/* BFD local_discr */
uint32 bfd_local_discr = 0x30004;

/* When enabled the IPv4 SIP, generated by the OAMP, is
* configured by the user and replaced by the PRGE.
* Soc property bfd_extended_ipv4_src_ip must be enabled as well.
* Not relevant for JR2
*/
int bfd_extended_sip = 0;


/**
 * Destination: FEC
 * Note: there is no need to define
 * an actual FEC, but make sure that
 * you do not plan to use a FEC with
 * this number elsewhere
 */
uint32 my_bfd_dip_destination = 0xabcd;

bcm_bfd_endpoint_t ep_id_in_event = 0;

/*State change event count for BFD */
int state_change_events_count_bfd = 0;

/* Seamless BFD feature.
 * This tells whether the test is
 * currently being run on a seamless
 * bfd initiator endpoint */
uint8 is_s_bfd_init_ep = 0;
uint8 is_s_bfd_reflector = 0;

/* BFD MPLS PHP */
uint8 is_bfd_mpls_php_ep=0;

/**
* indicate the type is BFD MPLS CcCv 
* TX : OAMP will send packet with format BFDoUDPoIPV4oGACHoPWoETH. 
*      In order to get LSP encapsulation, tunnel should be created by users and set it to egress_if when creating endpoint
* RX : User needs to create mpls port to terminate pwe and cw and set it to gport field when creating endpoint
* The packet should follow below:
* 1,  IP-Header.DIP is equal to 127/8
* 2,  IP-Header.DIP is equal to 0::FFFF:7F00/104
* 3,  IP-Header.TTL|Hop-Count == 255
* 4,  IP-Header.Protocol is UDP (17)
* 5,  UDP-Header.Dst-Port is equal to Cfg-UDP-Dst-Port-BFD-One-Hop (3784)
* 6,  UDP-Header.Src-Port is inside Cfg-UDP-Src-Port-BFD-Range (49152 through 65535)
 */
uint8 is_bfd_mpls_tp_cccv=0;

/*indicate if creating both single and multi hop bfd endpoints.
  When set, each endpoint will be given a unique local discriminator.
  This allows bfd_ipv4_run_with_defaults() to be called twice*/
int is_single_and_multi_hop_bfd_coexit =0;

/**
 *  Used to save the trap code created as a global variable,
 *  so that value is accessible after the trap is created
 */
int last_trap_code_created = 0;

/*Enable LOC events as soon as the bfd endpoints are created */
int remote_meps_start_in_loc_enable = 0;

/* micro_bfd with Muticase DMAC */
uint8 is_mc_micro_bfd=0;

/* RX BFD MPLS with TTL 255 */
uint8 is_bfd_mpls_ttl255 = 0;

/* Store endpoint_id of the last timeout/timein event */
bcm_bfd_endpoint_t last_event_endpoint_id;


/* Used to "cluster" different endpoints with the same tx period, allowing to change the tx-period of multiple endpoints in one fell swoop.
   Only in Jer2.
   Only used in bfd_ipv4_example(). */
int period_cluster_id = 0;

/**
 * When this flag is set, a VXLAN FEC is created and used as the EP's egress_if.
 */
int use_vxlan_fec = 0;

/** ID of FEC created for this purpose */
bcm_if_t vxlan_roo_fec;

int verify_bfd_ep_id_in_event(bcm_bfd_endpoint_t expected_ep_id) {
    printf("Endpoint id in event = %d\n",ep_id_in_event);
    if ( expected_ep_id == ep_id_in_event ) {
        return BCM_E_NONE;
    } else {
        return BCM_E_FAIL;
    }
}

/**
 * Create a user defined trap that sends
 * packets to the specified gport
 * Useful for verifying non-accelerated BFD
 * endpoints - if a trap is created for each
 * endpoint, then a packet sent to a certain
 * endpoint should arrive with that endpoint's
 * trap ID at the CPU.
 */
int bfd_create_trap_from_gport(int unit, bcm_gport_t gport, int* trap_code) {
    bcm_error_t rv;
    bcm_rx_trap_config_t trap_config;

    rv = bcm_rx_trap_type_create(unit, 0, bcmRxTrapUserDefine, trap_code);
    if (rv != BCM_E_NONE) {
       printf("(%s) \n",bcm_errmsg(rv));
       return rv;
    }

    bcm_rx_trap_config_t_init(&trap_config);
    trap_config.flags = BCM_RX_TRAP_UPDATE_DEST | BCM_RX_TRAP_TRAP;
    trap_config.dest_port = gport;

    rv = bcm_rx_trap_set(unit, *trap_code, &trap_config);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n", bcm_errmsg(rv));
        return rv;
    }

    last_trap_code_created = *trap_code;
    printf("Trap created trap_code=%d \n", *trap_code);

    return rv;
}

/* creating l3 interface */
int l3_interface_init(int unit, int in_sysport, int out_sysport, int * _next_hop_mac_encap_id, int * _tunnel_id, int create_mpls_tunnel, int use_my_bfd_dip_destination,int is_muti_hop_mpls){
    int rv;
    int ing_intf_in;
    int ing_intf_out;
    int fec[2] = {0x0,0x0};
    int in_vlan;
    int out_vlan = 100;
    int vrf;
    int host;
    int encap_id[2]={0};
    int route;
    int mask; 
    int l3_eg_int;
    int trap_id;
    int recycle_port = 0;
    bcm_l3_intf_t intf_sbfd;
    bcm_mac_t mac_address  = {0x00, 0x0c, 0x00, 0x02, 0x00, 0x00};  /* my-MAC */
    bcm_mac_t internal_my_mac  = {0x00, 0x0c, 0x00, 0x02, 0x00, 0x22};  /* my-MAC used reflector 2nd process after recycle */
    bcm_mac_t next_hop_mac  = {0x00, 0x00, 0x00, 0x00, 0xcd, 0x1d}; /* next_hop_mac1 */
    bcm_mac_t next_hop_mac2  = {0x00, 0x00, 0x00, 0x00, 0xcd, 0x1d}; /* next_hop_mac2 */
    bcm_l3_route_t bfd_route;
    uint32 is_kbp_lookup;

    if(is_device_or_above(unit, JERICHO2))
    {
        in_vlan = 10;
        vrf = 1;
    }
    else
    {
        in_vlan = 1;
        vrf = 0;
    }

    mpls__egress_tunnel_utils_s mpls_tunnel_properties;
    if ((!is_s_bfd_reflector) && (!is_muti_hop_mpls) && (device_type==device_type_jericho)) {
            encap_id[0] = 0x1000;
            encap_id[1] = 0x4000;
    }
    if(is_s_bfd_reflector && !is_device_or_above(unit, JERICHO2)){
         bcm_l3_intf_t_init(&intf_sbfd);
         sal_memcpy(intf_sbfd.l3a_mac_addr, internal_my_mac, 6);
         intf_sbfd.l3a_vrf = vrf;
         intf_sbfd.l3a_vid = 101; /* must set to 101 since Dummy ARP lif match vid 101*/
         rv = bcm_l3_intf_create(unit, &intf_sbfd);
         if (rv != BCM_E_NONE) {
             printf("Error, bcm_l3_intf_create fail rv = %d \n",rv);
         }
    }

    /*** create ingress router interface ***/
    rv = vlan__open_vlan_per_mc(unit, in_vlan, 0x1);  
    if (rv != BCM_E_NONE) {
        printf("Error, open_vlan=%d, in unit %d \n", in_vlan, unit);
    }
    rv = bcm_vlan_gport_add(unit, in_vlan, in_sysport, 0);
    if (rv != BCM_E_NONE && rv != BCM_E_EXISTS) {
        printf("fail add port(0x%08x) to vlan(%d)\n", in_sysport, in_vlan);
      return rv;
    }


    create_l3_intf_s intf;
    /** Creating this RIF prevents VXLAN packets from being received */
    if(!use_vxlan_fec)
    {
        intf.vsi = in_vlan;
        intf.my_global_mac = mac_address;
        intf.my_lsb_mac = mac_address;
        intf.vrf_valid = 1;
        intf.vrf = vrf;
        intf.mtu_valid = 1;
        intf.mtu = 0;
        intf.mtu_forwarding = 0;

        rv = l3__intf_rif__create(unit, &intf);
        ing_intf_in = intf.rif;
        if (rv != BCM_E_NONE) {
            printf("Error, l3__intf_rif__create\n");
        }
    }

    /*** create egress router interface ***/
    rv = vlan__open_vlan_per_mc(unit, out_vlan, 0x1);
    if (rv != BCM_E_NONE) {
        printf("Error, open_vlan=%d, in unit %d \n", out_vlan, unit);
    }
    rv = bcm_vlan_gport_add(unit, out_vlan, out_sysport, 0);
    if (rv != BCM_E_NONE && rv != BCM_E_EXISTS) {
        printf("fail add port(0x%08x) to vlan(%d)\n", out_sysport, out_vlan);
      return rv;
    }

    intf.vsi = out_vlan;

    rv = l3__intf_rif__create(unit, &intf);
    ing_intf_out = intf.rif;
    if (rv != BCM_E_NONE) {
        printf("Error, l3__intf_rif__create\n");
    }

    /*** create egress object 1 ***/
    if (create_mpls_tunnel) {
        /*** Create tunnel ***/
        *_tunnel_id = 0;

        mpls_tunnel_properties.label_in = mpls_label_termination;
        mpls_tunnel_properties.label_out = 0;
        if (!is_device_or_above(unit, JERICHO2))
        {
        	mpls_tunnel_properties.next_pointer_intf = ing_intf_out;
        }

        printf("Trying to create tunnel initiator\n");
        rv = mpls__create_tunnel_initiator__set(unit, &mpls_tunnel_properties);
        if (rv != BCM_E_NONE) {
           printf("Error, in mpls__create_tunnel_initiator__set\n");
           return rv;
        }

        *_tunnel_id = mpls_tunnel_properties.tunnel_id;

        printf("tunnel_id (egress_interface):0x%08x \n", *_tunnel_id);

        l3_eg_int = *_tunnel_id;
    }
    else {
        l3_eg_int = ing_intf_out;
    }

    /*** Create egress object1 ***/
    create_l3_egress_s l3eg;
    l3eg.out_tunnel_or_rif = l3_eg_int;
    sal_memcpy(l3eg.next_hop_mac_addr, next_hop_mac, 6);
    l3eg.vlan   = out_vlan;
    l3eg.arp_encap_id = encap_id[0];
    l3eg.fec_id = fec[0]; 
    l3eg.allocation_flags = 0;
    l3eg.out_gport = out_sysport;

    rv = l3__egress__create(unit,&l3eg);
    if (rv != BCM_E_NONE) {
        printf("Error, in l3__egress__create  \n");
        print rv;
    }
    encap_id[0] = l3eg.arp_encap_id;
    fec[0] = l3eg.fec_id;

    if(verbose >= 1) {
        printf("created FEC-id =0x%08x, in unit %d \n", fec[0], unit);
        printf("next hop mac at encap-id %08x, in unit %d\n", encap_id[0], unit);
    }

    if (!create_mpls_tunnel) {
        *_tunnel_id = encap_id[0];
    }

    /*** add host ***/

    if (single_hop_extended || is_muti_hop_mpls) {
        rv = add_host(unit, 0x12345678, vrf, fec[0]); 
    } else {
        rv = add_host(unit, 0x7fffff03, vrf, fec[0]); 
    } 
    if (rv != BCM_E_NONE) {
        printf("Error, create egress object, in_sysport=%d, in unit %d \n", in_sysport, unit);
    }

    /*** create egress object 2***/
    /* We're allocating a lif. out_sysport unit should be first, and it's already first */
    create_l3_egress_s l3eg1;
    l3eg1.out_tunnel_or_rif = l3_eg_int;
    sal_memcpy(l3eg1.next_hop_mac_addr, next_hop_mac2, 6);
    l3eg1.vlan   = out_vlan;
    l3eg1.arp_encap_id = encap_id[1];
    l3eg1.fec_id = fec[1]; 
    l3eg1.allocation_flags = 0;
    l3eg1.out_gport = out_sysport;

    rv = l3__egress__create(unit,&l3eg1);
    if (rv != BCM_E_NONE) {
        printf("Error, in bcm_vlan_create with vlan %d continue \n", l3eg.vlan);
        print rv;
    }
    encap_id[1] = l3eg1.arp_encap_id;
    fec[1] = l3eg1.fec_id;    
    *_next_hop_mac_encap_id = encap_id[1];

    if(verbose >= 1) {
        printf("created FEC-id =0x%08x, in unit %d\n", fec[1], unit);
        printf("next hop mac at encap-id %08x, in unit %d\n", encap_id[1], unit);
    }

    /*** add route point to FEC2 ***/
    if (!bfd_echo) {
        if (single_hop_extended || is_muti_hop_mpls) {
              route = 0x12345600;
        }
        else{
            route = 0x7fffff00;
        }
        mask  = 0xfffffff0;
        bfd_route.l3a_subnet = route;
        bfd_route.l3a_ip_mask = mask;
        bfd_route.l3a_vrf = vrf;

        if (is_device_or_above(unit, JERICHO2))
        {
            is_kbp_lookup = *(dnxc_data_get(unit, "elk", "application", "ipv4", NULL)) && *(dnxc_data_get(unit, "elk", "application", "split_rpf", NULL));;
            if(is_kbp_lookup)
            {
                bfd_route.l3a_flags2 |= BCM_L3_FLAGS2_FWD_ONLY;
            }
        }
        rv = bcm_l3_route_get(unit, &bfd_route);
        if (rv == BCM_E_NONE)
        {
            printf("Attempting to add an entry that already exists. Adding replace flag.");
            bfd_route.l3a_flags = BCM_L3_REPLACE;
        }
        bfd_route.l3a_intf = fec[1];
        rv = bcm_l3_route_add(unit, &bfd_route);
        if (rv != BCM_E_NONE) {
            printf("Error, create egress object, in_sysport=%d in unit %d, \n", in_sysport, unit);
        } 
    }

    if(is_muti_hop_mpls) {
    
        recycle_port = soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "non_bfd_forwarding", 0);
        rv = bcm_vlan_gport_add(unit, 1, recycle_port, 0);
        if (rv != BCM_E_NONE && rv != BCM_E_EXISTS) {
            printf("fail add port(0x%08x) to vlan(%d)\n", in_sysport, in_vlan);
            return rv;
        }
        intf.vsi = 1;
        rv = l3__intf_rif__create(unit, &intf);
        if (rv != BCM_E_NONE) {
            printf("Error, l3__intf_rif__create failed\n");
        }
		
        create_l3_egress_s l3eg_recycle;
        l3eg_recycle.out_tunnel_or_rif = intf.rif;
        sal_memcpy(l3eg_recycle.next_hop_mac_addr, mac_address /*internal_my_mac*/, 6);
        l3eg_recycle.vlan   = 1;
        l3eg_recycle.arp_encap_id = 0;
        l3eg_recycle.fec_id = 0; 
        l3eg_recycle.allocation_flags = 0;
        l3eg_recycle.out_gport = recycle_port;
        rv = l3__egress__create(unit,&l3eg_recycle);
        if (rv != BCM_E_NONE) {
            printf("Error, in l3__egress__create with vlan %d continue \n", l3eg_recycle.vlan);
            print rv;
        }
        fec_recycle = l3eg_recycle.fec_id;    
    }
    return rv;
}

/* Add term entry to perform pop
*/
int
mpls_add_term_entry_ex(int unit, int term_label, uint32 next_prtcl, bcm_mpls_tunnel_switch_t *entry)
{
    int rv;

    bcm_mpls_tunnel_switch_t_init(entry);
    entry->action = BCM_MPLS_SWITCH_ACTION_POP;

    /*
     * Uniform: inherit TTL and EXP,
     * in general valid options:
     * both present (uniform) or none of them (Pipe)
     */
    if(!is_device_or_above(unit, JERICHO2))
    {
    	entry->flags |= BCM_MPLS_SWITCH_OUTER_TTL|BCM_MPLS_SWITCH_OUTER_EXP;
    }
    /*
     * Next protocol indication:
     * BCM_MPLS_SWITCH_NEXT_HEADER_IPV4 | BCM_MPLS_SWITCH_NEXT_HEADER_IPV6, or
     * BCM_MPLS_SWITCH_NEXT_HEADER_L2, or
     * 0 - unset(MPLS)
     */

    /** presumably device_type has been resolved at this stage */
    if (device_type<device_type_arad_plus) {
        entry->flags |= next_prtcl;
    }

    /* incomming label */
    if (soc_property_get(unit , "mpls_termination_label_index_enable",0)) {
        BCM_MPLS_INDEXED_LABEL_SET(&entry->label, term_label, 1);
    }
    else {
        entry->label = term_label;
    }

    entry->qos_map_id = 0; /* qos not rellevant for BFD */
    if(is_s_bfd_reflector && is_device_or_above(unit, JERICHO2)){
        entry->vpn = 1; /*    vrf = 1*/
    }
    rv = bcm_mpls_tunnel_switch_create(unit,entry);
    if (rv != BCM_E_NONE) {
        printf("Error, in bcm_mpls_tunnel_switch_create\n");
        return rv;
    }
    return rv;
}


int bfd_ipv4_example_init(int unit, int p1, int p2, int use_my_bfd_dip_destination) {
    int rv;

    port_1 = p1;
    port_2 = p2;

    rv = l3_interface_init(unit, port_1, port_2, &next_hop_mac, &tunnel_id, 0, use_my_bfd_dip_destination,0);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }


    if (bfd_over_ip_transmit_into_mpls) {
        /* Create MPLS, FEC objects*/

        bcm_mpls_egress_label_t label_array[2];
        bcm_mpls_egress_label_t_init(&label_array[0]);
        bcm_mpls_egress_label_t_init(&label_array[1]);
        label_array[0].label = 500;
        label_array[1].label = 501;
        label_array[0].flags = BCM_MPLS_EGRESS_LABEL_TTL_DECREMENT;
        label_array[1].flags = BCM_MPLS_EGRESS_LABEL_TTL_DECREMENT;
        label_array[0].l3_intf_id = next_hop_mac ;/* MPLS points to the "next hop mac*/
        label_array[1].l3_intf_id = next_hop_mac ;/* MPLS points to the "next hop mac*/
        BCM_IF_ERROR_RETURN(bcm_mpls_tunnel_initiator_create(unit, 0, 2, label_array));

        create_l3_egress_s mpls_bfd_fec;
        mpls_bfd_fec.out_tunnel_or_rif = label_array[0].tunnel_id ; /* output from above*/
        BCM_GPORT_SYSTEM_PORT_ID_SET(mpls_bfd_fec.out_gport, p1); 
        rv = l3__egress_only_fec__create(unit, &mpls_bfd_fec);
        if (rv != BCM_E_NONE) {
          printf("(%s) mpls_create_initiator_tunnels failed  \n",bcm_errmsg(rv));
          return rv;
        }
        /* fec from above call points to mpls "tunnel-id" which points to the ARP pointer.
           BFD endpoint's outlif will be the fec-id.*/
        next_hop_mac = mpls_bfd_fec.fec_id;

        /* egress_if will be set to a fec, so tx_gport should be INVALID*/
        use_invalid_tx_gport = 1;
    }

    return rv;
}



/**
* Create BFD over IPV4 endpoint. Following variations
* available:
* 1) Accelerated/non accelerated
* 2) Trapping incoming BFD frames to a configurable destination
* 3) IPv4 one hop/multi hop
*
* @param unit
* @param remote_gport: contains trap code, trap strength and snoop
*                      strength for non-accelerated endpoints; must
*                      be -1 for accelerated endpoints.
* @param flags: supported options:
*        BCM_BFD_ENDPOINT_MULTIHOP: multi hop/single hop
*        indication
*        BCM_BFD_ENDPOINT_IN_HW: accelerated in OAMP
*        indication
*        BCM_BFD_ENDPOINT_MICRO_BFD: Jericho only
* @param flags2: supported options:
*        BCM_BFD_ENDPOINT_FLAGS2_USE_MY_DIP_DESTINATION
*        Jericho2 and up, this option allows more DIPs
*        than the 16 entries in the table, and also
*        support ranges of DIPs by using masks.
* @return int
*/
int bfd_ipv4_example(int unit, bcm_gport_t remote_gport, uint32 flags, uint32 flags2) {
    int rv;
    bcm_bfd_endpoint_info_t bfd_endpoint_info = {0};
    bcm_bfd_endpoint_info_t bfd_endpoint_test_info = {0};
    int ret;
    bcm_if_t next_if;
    int is_multi_hop = (flags &BCM_BFD_ENDPOINT_MULTIHOP) !=0;
    int trap_code;
    bcm_l3_route_t l3rt;
    int use_my_bfd_dip_destination = ((flags2 & BCM_BFD_ENDPOINT_FLAGS2_USE_MY_DIP_DESTINATION) != 0);
    int bfd_my_dip_destination_read;
    int single_hop_with_random_dip = ((flags2 & BCM_BFD_ENDPOINT_FLAGS2_SINGLE_HOP_WITH_RANDOM_DIP) != 0);

    rv= oam__device_type_get(unit,&device_type);
    BCM_IF_ERROR_RETURN(rv);


    if ((is_server || use_trap_with_snoop) && device_type<device_type_arad_plus) {
      printf("Error: Server can be supported only by arad+ devices and above.\n");
      return BCM_E_PARAM;
    }

    /*
    * Adding BFDoIPV4 multi hop endpoint
    */

    /* If enabled, create data entry in EEDB that specifies the
    * configured IPv4 SIP and calculated checksum. */
    next_if = next_hop_mac;

    if (bfd_extended_sip)
    {
      bcm_l3_intf_t bfd_extended_l3_intf;
      bcm_l3_intf_t_init(&bfd_extended_l3_intf);

      bcm_tunnel_initiator_t tunnel;
      bcm_tunnel_initiator_t_init(&tunnel);
      tunnel.type = bcmTunnelTypeIpAnyIn4;
      tunnel.sip = 0x10203040;
      tunnel.aux_data = 0x11ae;
      tunnel.dip = 0;
      tunnel.l3_intf_id = next_hop_mac;

      rv = bcm_tunnel_initiator_create(unit, &bfd_extended_l3_intf, &tunnel);
      if (rv != BCM_E_NONE) {
          printf("(%s) \n",bcm_errmsg(rv));
          return rv;
      }

      next_if = bfd_extended_l3_intf.l3a_intf_id;
    }

    if(use_vxlan_fec)
    {
        /** VXLAN FEC params */
        next_if = vxlan_roo_fec;
        use_invalid_tx_gport = 1;
    }

    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_info);

    bfd_endpoint_info.type = bcmBFDTunnelTypeUdp;
    bfd_endpoint_info.flags = flags;

    /* if bfd_extended_sip is set, there is no need to use a SIP in the BFD endpoint */
    bfd_endpoint_info.src_ip_addr = bfd_extended_sip ? 0 : 0x30F0701;

    if (((bfd_endpoint_info.flags & BCM_BFD_ENDPOINT_IN_HW) !=0) && is_device_or_above(unit, JERICHO2))
    {
        if (use_invalid_tx_gport)
        {
            bfd_endpoint_info.tx_gport = BCM_GPORT_INVALID;
        }
        else
        {
            BCM_GPORT_SYSTEM_PORT_ID_SET(bfd_endpoint_info.tx_gport, port_1);
        }
    }

    /** Various bfd acceleration 
    * Case 1 - Standart non acc
    *   BCM_BFD_ENDPOINT_IN_HW flag is NOT set
    * Case 2 - Standart acc
    *   BCM_BFD_ENDPOINT_IN_HW flag is NOT set
    * Case 3 - Classified by OEM-2, but no OAMP entry
    *   BCM_BFD_ENDPOINT_IN_HW is set, Remote_gport != NULL                      (in case of JER1)
    *   BCM_BFD_ENDPOINT_IN_HW is set, Remote_gport != NULL and tx_gport == NULL (in case of JR2)
    * Case 4 - Classified by OEM-2 to "remote CPU", TX in OAMP
    *   BCM_BFD_ENDPOINT_IN_HW is set, Remote_gport != NULL and tx_gport != NULL
    */
    if (((bfd_endpoint_info.flags &BCM_BFD_ENDPOINT_IN_HW) !=0)  && \
        ((remote_gport==BCM_GPORT_INVALID) || ((bfd_endpoint_info.tx_gport!=BCM_GPORT_INVALID)  && is_device_or_above(unit, JERICHO2)) \
            || is_server || use_trap_with_snoop))
    {
        if (!is_device_or_above(unit, JERICHO2))
        {
            bcm_stk_sysport_gport_get(unit,port_1, &bfd_endpoint_info.tx_gport);
        }
        bfd_endpoint_info.loc_clear_threshold = 1;
        if ((flags & BCM_BFD_ENDPOINT_MULTIHOP) && !(flags2 & BCM_BFD_ENDPOINT_FLAGS2_SEAMLESS_BFD_INITIATOR)) {
            bfd_endpoint_info.ip_ttl = 200;
        }
        else if (bfd_over_ip_transmit_into_mpls) {
            /*BFD ipv4 into tunnel - use ttl 1*/
            bfd_endpoint_info.ip_ttl = 1; 
        } else {
            /* standard single hop/micro bfd case.*/
            bfd_endpoint_info.ip_ttl = 255;
        }

        if (bfd_ipv4_flex_iptos) {
            bfd_endpoint_info.ip_tos = bfd_ipv4_flex_iptos;
        }
        else
        {
            bfd_endpoint_info.ip_tos = 255;
        }
        bfd_endpoint_info.udp_src_port = 0xC001;
        bfd_endpoint_info.egress_if = next_if;
        bfd_endpoint_info.int_pri = 1;
        bfd_endpoint_info.bfd_period = bfd_tx_period;
        bfd_endpoint_info.bfd_period_cluster = period_cluster_id;
        if (is_multi_hop || device_type>=device_type_jericho) {
            /* dst IP address unavailable for Arad single hop.*/
            bfd_endpoint_info.dst_ip_addr = single_hop_with_random_dip ? 0: 0x7fffff03;
            if (device_type>=device_type_jericho && !is_multi_hop) {
                bfd_endpoint_info.ip_subnet_length = 16; /* have the OAMP verify the 16 MSBs of incoming BFD packets.*/
            }
        }
        if(is_device_or_above(unit, JERICHO2) && ((bfd_endpoint_info.flags & BCM_BFD_ECHO) != 0))
        {
            bfd_endpoint_info.ip_ttl = 200;
        }
        if (bfd_echo) {
            bfd_endpoint_info.flags |= BCM_BFD_ECHO;
            if (bfd_echo==2) {
                bfd_endpoint_info.udp_src_port = 0xffff;
                bfd_endpoint_info.src_ip_addr = 0x7fffff03;
                bfd_endpoint_info.ip_ttl = 254;
            }
        }
        else
        {
            bfd_endpoint_info.local_min_tx = 2;
            bfd_endpoint_info.local_min_rx = 0x1000; /* value in microseconds*/
            bfd_endpoint_info.local_state = 3;
            bfd_endpoint_info.local_flags = 0;
            bfd_endpoint_info.local_detect_mult = 208;
            bfd_endpoint_info.remote_detect_mult = 30;
            bfd_endpoint_info.remote_discr = 0x10002;
        }
        if (single_hop_extended || bfd_extended_sip) {
            bfd_endpoint_info.dst_ip_addr = 0x12345678;
        }

        if (is_server) {
            bfd_endpoint_info.flags |= BCM_BFD_ENDPOINT_HW_ACCELERATION_SET;
        }

        if (remote_meps_start_in_loc_enable) {
            bfd_endpoint_info.faults |= BCM_BFD_ENDPOINT_REMOTE_LOC;
            bfd_endpoint_info.local_min_rx = 1000000;
            bfd_endpoint_info.remote_detect_mult = 3;
        }
    }

    if(is_device_or_above(unit, JERICHO2))
    {
        if (is_rx_statisitcs_enabled)
        {
            flags2 |= BCM_BFD_ENDPOINT_FLAGS2_RX_STATISTICS;
        }

        if (is_tx_statisitcs_enabled)
        {
            flags2 |= BCM_BFD_ENDPOINT_FLAGS2_TX_STATISTICS;
        }
        if (single_hop_with_random_dip)
        {
            bfd_endpoint_info.egress_label.label = mpls_label;
        }
        
        bfd_endpoint_info.flags2 = flags2;

        /** Is my-BFD-DIP-Destination in use? */
        if(use_my_bfd_dip_destination)
        {
            /** Set My-BFD-DIP-Destination */
            rv = bcm_switch_control_set(unit, bcmSwitchBfdMyDipDestination, my_bfd_dip_destination);
            if (rv != BCM_E_NONE) {
                printf("(%s) \n",bcm_errmsg(rv));
                return rv;
            }

            rv = bcm_switch_control_get(unit, bcmSwitchBfdMyDipDestination, &bfd_my_dip_destination_read);
            if (rv != BCM_E_NONE) {
                printf("(%s) \n",bcm_errmsg(rv));
                return rv;
            }

            if(bfd_my_dip_destination_read != my_bfd_dip_destination)
            {
                printf("Setting BFD-My-DIP-destination failed, value read: 0x%08x, value written 0x%08x\n",
                        my_bfd_dip_destination, bfd_my_dip_destination_read);
                return BCM_E_INTERNAL;
            }

            /** Set up forwarding from the IP to the destination */
            bcm_l3_route_t_init(&l3rt);
            l3rt.l3a_subnet = bfd_endpoint_info.src_ip_addr;
            l3rt.l3a_ip_mask = 0xFFFFFFFF;
            l3rt.l3a_intf = my_bfd_dip_destination;
            l3rt.l3a_vrf = 1;
            l3rt.l3a_flags2 = BCM_L3_FLAGS2_SCALE_ROUTE;
            rv = bcm_l3_route_add(unit, &l3rt);
            if (rv != BCM_E_NONE) {
                printf("(%s) \n",bcm_errmsg(rv));
                return rv;
            }
        }
    }

    bfd_endpoint_info.local_discr = is_single_and_multi_hop_bfd_coexit ? (bfd_local_discr + single_hop_extended) : bfd_local_discr;
    bfd_endpoint_info.remote_gport = remote_gport;
    if (int_pri) {
        bfd_endpoint_info.int_pri = int_pri;
    }
    if (is_s_bfd_init_ep) {
        bfd_endpoint_info.flags2 |= BCM_BFD_ENDPOINT_FLAGS2_SEAMLESS_BFD_INITIATOR;
        /* Some number outside 49152 - 65535 range since 
         * SBFD does not have limitations on UDP src port range */
        bfd_endpoint_info.udp_src_port = 20020; 
        if ((bfd_endpoint_info.flags &BCM_BFD_ENDPOINT_IN_HW) !=0) {
            /* local_min_rx and local_min_echo needs to be zero */
            bfd_endpoint_info.local_min_rx = 0;
            bfd_endpoint_info.local_min_echo = 0;
            /* TTL should be set to 255 */
            bfd_endpoint_info.ip_ttl = 255;
            /* local_state set to UP */
            bfd_endpoint_info.local_state = 3;
            /* Local flag should have demand bit (bit 1) set 
             * P | F | C | A | D | M 
             * 0 | 0 | 0 | 0 | 1 | 0 
             */
            bfd_endpoint_info.local_flags = 0x2;
        }
    }

    if (is_s_bfd_reflector) {
        rv = sbfd_reflector_endpoint_create(unit, 0x30F0701, 0x10, 3);
        return rv;
    }
    printf("bcm_bfd_endpoint_create bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    printf("created endpoint with id %d\n", bfd_endpoint_info.id);

    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_test_info);
    printf("bcm_bfd_endpoint_get bfd_endpoint_test_info\n");
    rv = bcm_bfd_endpoint_get(unit, bfd_endpoint_info.id, &bfd_endpoint_test_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    /* Here mep_not_acc_info and mep_not_acc_test_info are compared */
    ret = cmp_structs(unit, &bfd_endpoint_info, &bfd_endpoint_test_info,bcmBFDTunnelTypeUdp) ;
    if (ret != 0) {
      printf("%d wrong fields in BFDoIPV4\n", ret);
    }

    printf("bcm_bfd_endpoint_destroy bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_destroy(unit, bfd_endpoint_info.id);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    printf("bcm_bfd_endpoint_create bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    bfd_ep1.id = bfd_endpoint_info.id;

    return rv;
}

    /**
    * 
    * 
    * @author sinai (03/09/2015)
    * 
    * @param unit 
    * @param port1 Port on which the endpoint resides
    * @param port2 
    * @param remote_port trap to a non default destination (may be 
    *                    -1)
    * @param is_extended_sip 
    * @param flags: supported options: 
    *        BCM_BFD_ENDPOINT_MULTIHOP: multi hop/single hop
    *        indication
    *        BCM_BFD_ENDPOINT_IN_HW: accelerated in OAMP 
    *        indication
    *        BCM_BFD_ENDPOINT_MICRO_BFD: Jericho only
    * @param remote_port_fwd_strength:
    *           Indicates the trap strength to be set in
    *           remote_gport trap variable. 0 to indicate default
    *           behavior of setting 7.
    * @param flags2: supported options:
    *        BCM_BFD_ENDPOINT_FLAGS2_USE_MY_DIP_DESTINATION:
    *        The DIP is forwarded to my-BFD-DIP destination instead
    *        of being added to the table of 16 BFD DIPs.
    * 
    * @return int 
    */
int bfd_ipv4_run_with_defaults(int unit, int port1, int port2,  int remote_port,  int is_extended_sip, uint32 flags, int remote_port_fwd_strength, int flags2) {
    bcm_error_t rv;
    bcm_mpls_tunnel_switch_t tunnel_switch;
    int tunnel_id;

    port_1 = port1;
    port_2 = port2;
    bcm_gport_t remote_gport;
    int trap_code;
    /*int is_single_hop , int is_acc, */

    if(use_vxlan_fec)
    {
        /** Create VXLAN FEC */
        vxlan_roo_example(unit, 0 /* is_ipv6 */, port_2, port_1, 1 /* add_routing_table_entry */);
        vxlan_roo_fec = ip_tunnel_basic_info.encap_native_fec_id[1];
    }

    if(is_extended_sip && (is_device_or_above(unit, JERICHO2) || soc_property_get(unit , "bfd_extended_ipv4_src_ip",1)))
    {
        bfd_extended_sip = 1;
    }

    rv = oam__device_type_get(unit, &device_type);
    if (rv < 0) {
      printf("Error checking whether the device is arad+.\n");
      print rv;
      return rv;
    }

    /* Using LEM/PMF to demultiplex BFD endpoints for:  BFD single hop or Micro BFD, when the soc property is on. */
    /* Mulit hop extended feature uses same program as single hop extended hence reusing the same variable */

    if ((!is_device_or_above(unit, JERICHO2))
       && ((flags & BCM_BFD_ENDPOINT_MULTIHOP)==0  || (flags & BCM_BFD_ENDPOINT_MICRO_BFD )!=0)
       && soc_property_get(unit, "bfd_ipv4_single_hop_extended", 1) || (soc_property_get(unit, "custom_feature_multi_hop_bfd_extra_dip_support", 0))
       && (device_type>=device_type_arad_plus)
       && ((!is_s_bfd_init_ep)&&(!is_s_bfd_reflector))) {
      single_hop_extended = 1;
    }

    if (!is_device_or_above(unit, JERICHO2)) {
        /** This SOC property no long exists in JR2 */

        /* Micro BFD may only be set with soc property and may not be set with multihop flags*/
        if ((flags & BCM_BFD_ENDPOINT_MICRO_BFD )!=0 && soc_property_get(unit, "bfd_ipv4_single_hop_extended", 1) ==0 ) {
          printf("Error: MICRO_BFD may only be configured with bfd_ipv4_single_hop_extended soc property.\n");
          print 34;
        }

        /** Not relevant for JR2 */
        rv = mpls__mpls_pipe_mode_exp_set(unit);
        if (rv != BCM_E_NONE) {
          printf("Error, in mpls__mpls_pipe_mode_exp_set\n");
          return rv;
        }
    }


    if (remote_port == -1) {
      remote_gport = BCM_GPORT_INVALID;
      if (is_device_or_above(unit, JERICHO2) && (flags & BCM_BFD_ENDPOINT_IN_HW) == 0)
      {
          rv = bcm_rx_trap_type_get(unit, 0, bcmRxTrapBfdOamDownMEP, &trap_code);
          if (rv != BCM_E_NONE) {
              printf("(%s) \n",bcm_errmsg(rv));
              return rv;
          }
          BCM_GPORT_TRAP_SET(remote_gport, trap_code, 7, 0);
      }
    }
    else {
      if (is_server || use_trap_with_snoop) {
          BCM_GPORT_TRAP_SET(remote_gport, remote_port, remote_port_fwd_strength?remote_port_fwd_strength:7, 3);
      }
      else {
          printf("Setting remote_gport to port 0x%08x with strength %d\n",
                  remote_port, remote_port_fwd_strength?remote_port_fwd_strength:7);
          BCM_GPORT_LOCAL_SET(remote_gport, remote_port);

          /* remote_gport field must be a trap */
          rv = bfd_create_trap_from_gport(unit, remote_gport, &trap_code);
          if (rv != BCM_E_NONE) {
              printf("Error bfd_create_trap_from_gport.\n");
              return rv;
          }
          BCM_GPORT_TRAP_SET(remote_gport, trap_code, remote_port_fwd_strength?remote_port_fwd_strength:7, 0);
          remote_gport_trap_code = trap_code;
      }
    }

    /* in case of single hop extended the PMF should do the classification*/
    if (single_hop_extended) {
        rv = bfd_ipv4_single_hop_field_action(unit);
        if (rv != BCM_E_NONE) {
          printf("Error bfd_ipv4_single_hop_field_trap_qualifier.\n");
          return rv;
        }
    }

    if(is_device_or_above(unit, JERICHO2) && (flags & BCM_BFD_ECHO))
    {
       bfd_echo = 1;
       rv = field_presel_fwd_layer_main(unit,cint_bfd_echo_presel_id, bcmFieldStageIngressPMF1, bcmFieldLayerTypeIp4, &cint_bfd_echo_context_id_ipmf1, "ipv4 hit");
       if (rv != BCM_E_NONE)
       {
           printf("Error (%d), in cint_field_always_hit_context_main Ingress\n", rv);
           return rv;
        }

        rv = cint_field_bfd_echo_main(unit, cint_bfd_echo_context_id_ipmf1, 0);
        if (rv != BCM_E_NONE) {
          printf("Error cint_field_bfd_echo_main.\n");
          return rv;
        }

        rv = cint_field_bfd_echo_entry_add(unit, 0x7fffff03, NULL, bfd_local_discr & 0xFFFF);
        if (rv != BCM_E_NONE) {
          printf("Error cint_field_bfd_echo_entry_add.\n");
          return rv;
        }
    }

    if (!single_hop_extended && soc_property_get(unit, "bfd_mask_flags_bitfield", 0)){
        /* In a case of second call, skip this part */
        if (!is_field_created) {
            /* Feature requires egress PMF changes, taken from the trap code*/
            int bfd_ip_trap_code;
            rv = bcm_rx_trap_type_get(unit,0, bcmRxTrapOamBfdIpv4,&bfd_ip_trap_code);
            BCM_IF_ERROR_RETURN(rv);

            rv = field_bfd_advanced_features(unit, bfd_ip_trap_code);
            BCM_IF_ERROR_RETURN(rv);
            is_field_created = 1;
        }
    }

    /* Single-hop bfd with random dip will Inject BFD over IP PDUs from the OAMP to an MPLS outLIF */
    if (flags2 & BCM_BFD_ENDPOINT_FLAGS2_SINGLE_HOP_WITH_RANDOM_DIP) {
        bfd_over_ip_transmit_into_mpls = 1;
    }

    int use_my_bfd_dip_destination =  ((flags2 & BCM_BFD_ENDPOINT_FLAGS2_USE_MY_DIP_DESTINATION) != 0);
    rv = bfd_ipv4_example_init(unit, port_1, port_2, use_my_bfd_dip_destination);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n",bcm_errmsg(rv));
        return rv;
    }
    printf("-------------init \n");


    rv = bfd_ipv4_example(unit, remote_gport, flags, flags2);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    if(bfd_over_ip_transmit_into_mpls && ((flags & BCM_BFD_ENDPOINT_MULTIHOP) || (flags2 & BCM_BFD_ENDPOINT_FLAGS2_SINGLE_HOP_WITH_RANDOM_DIP)))
    {
        /* add it for multi-hop BFDoIPoMPLS*/
        mpls_label = 212;
        rv = mpls_init(unit, &tunnel_switch, &tunnel_id,0,0,port_1, port_2);
        if (rv != BCM_E_NONE) {
            printf("(%s) \n",bcm_errmsg(rv));
            return rv;
        }
    }

    if (enable_oamp_counter_allocation)
    {
        /** Allocate counters for 1k MEPs with statistics enable, counter base is the first MEP. */
        /* last parameter eviction always 1 for BFD*/
        rv = cint_oam_oamp_statistics_main(unit, bfd_ep1.id, 1024, (enable_oamp_counter_allocation-1), 1);
        if (rv != BCM_E_NONE) {
            printf("(%s) \n",bcm_errmsg(rv));
            return rv;
        }
    }

    rv = register_events(unit);
    return rv;
}

int read_timeout_event_count_bfd(int expected_event_count) {
    printf("timeout_events_count_bfd=%d\n",timeout_events_count_bfd);

    if (timeout_events_count_bfd==expected_event_count) {
        return BCM_E_NONE;
    }
    else {
        return BCM_E_FAIL;
    }
}

int read_timeout_event_count_multi_bfd(int expected_event_count) {
    printf("timeout_events_count=%d\n",timeout_events_count_multi_bfd);

    if (timeout_events_count_multi_bfd==expected_event_count) {
        return BCM_E_NONE;
    }
    else {
        return BCM_E_FAIL;
    }
}


/* This is an example of using bcm_bfd_event_register api.
* A simple callback is created for CCM timeout event.
* After a mep and rmep are created, the callback is called
* whenever CCMTimeout event is generated.
*/
int cb_bfd(
int unit,
uint32 flags,
bcm_bfd_event_types_t event_types,
bcm_bfd_endpoint_t endpoint,
void *user_data)
{
    int event_i;
    int rv;
    print unit;
    print flags;
    ep_id_in_event = endpoint;
    for (event_i = 0; event_i < bcmBFDEventCount; event_i++) {

        if (BCM_BFD_EVENT_TYPE_GET(event_types, event_i)) {
            print event_i;
            rv = oam__device_type_get(unit, &device_type);
            if (rv < 0) {
                printf("Error checking whether the device is arad+.\n");
                print rv;
                return rv;
            }
            if (bcmBFDEventStateChange==event_i && device_type>=device_type_arad_plus ) {
                /* The event change interrupt does not convey information about the new flags/state/diags.
                   Instead it possible to get these through endpoint_get (in Arad+)*/
                bcm_bfd_endpoint_info_t ep_get;
                rv = bcm_bfd_endpoint_get(unit, endpoint, &ep_get);
                if (rv != BCM_E_NONE) {
                    printf("(%s) \n", bcm_errmsg(rv));
                    return rv;
                }
                state_change_events_count_bfd++;
                printf("Flags is : 0x%x\n state is \n", ep_get.remote_flags);
                print ep_get.remote_state;
                print "diag is:";
                print ep_get.remote_diag;

            }
        }
    }
    print endpoint;
    last_event_endpoint_id = endpoint;
    timeout_events_count_bfd++;
    if (flags & BCM_OAM_EVENT_FLAGS_MULTIPLE) {
        ++timeout_events_count_multi_bfd;
    }
    return BCM_E_NONE;
}

int register_events(int unit) {
    bcm_error_t rv;
    bcm_bfd_event_types_t e;

    BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimeout);
    rv = bcm_bfd_event_register(unit, e, cb_bfd, (void*)2);
    BCM_IF_ERROR_RETURN(rv);

    BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimein);
    rv = bcm_bfd_event_register(unit, e, cb_bfd, (void*) 1 );
    BCM_IF_ERROR_RETURN(rv);

    BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventStateChange);
    rv = bcm_bfd_event_register(unit, e, cb_bfd, (void*) 1 );
    BCM_IF_ERROR_RETURN(rv);

    return rv;
}

int cb_bfd_multi_count_event(
    int unit,
    uint32 flags,
    bcm_bfd_event_types_t event_types,
    bcm_bfd_endpoint_t endpoint,
    void *user_data)
{   
    int event_i;
    int rv;
    print unit;
    print flags;
    
    ep_id_in_event = endpoint;
    for (event_i = 0; event_i < bcmBFDEventCount; event_i++) {
        if (BCM_BFD_EVENT_TYPE_GET(event_types, event_i)) {
            print event_i;
            /* when multiple OAM events feature is enabled
               upper 16 bits in flags field will provide
               the count which will indicate how many times
               that event occured before it is being handed
               over to application through call back function
            */
            if(event_i == bcmBFDEventEndpointTimeout)
                timeout_multi_event_count_bfd += (flags >> 16);
            if(event_i == bcmBFDEventEndpointTimein)
                timein_multi_event_count_bfd += ( flags  >> 16);
        }
    }
    print endpoint;
    return BCM_E_NONE;
}
    
int read_multi_event_count_bfd(int expected_timeout_event_count, int expected_timein_event_count) {
    printf("timeout_events_count_bfd=%d\n",timeout_multi_event_count_bfd);
    printf("timein_events_count_bfd=%d\n" ,timein_multi_event_count_bfd);
    if ((timeout_multi_event_count_bfd==expected_timeout_event_count) && (timein_multi_event_count_bfd==expected_timein_event_count)) {
        return BCM_E_NONE;
    }
    else {
        printf("timeout_multi_event_count_bfd=%d\n",timeout_multi_event_count_bfd);
        printf("timein_multi_event_count_bfd=%d\n" ,timein_multi_event_count_bfd);
        return BCM_E_FAIL;
    }
}

int read_state_change_event_count_bfd(int expected_event_count) {
    printf("state_change_events_count_bfd=%d\n",state_change_events_count_bfd);

    if (state_change_events_count_bfd==expected_event_count) {
        return BCM_E_NONE;
    }
    else {
        return BCM_E_FAIL;
    }
}

int register_count_event(int unit) {
  bcm_error_t rv;
  bcm_bfd_event_types_t e;

  BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimeout);
  BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimein);
  rv = bcm_bfd_event_unregister(unit,e,cb_bfd );
  BCM_IF_ERROR_RETURN(rv);

  BCM_BFD_EVENT_TYPE_CLEAR_ALL(e);
  BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimeout);
  rv = bcm_bfd_event_register(unit, e, cb_bfd_multi_count_event, (void*)2);
  BCM_IF_ERROR_RETURN(rv);

  BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimein);
  rv = bcm_bfd_event_register(unit, e, cb_bfd_multi_count_event, (void*) 1 );
  BCM_IF_ERROR_RETURN(rv);

  return rv;
}

int unregister_events(int unit) {
    bcm_bfd_event_types_t e;

    BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimeout);
    BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimein);
    BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventStateChange);
    bcm_bfd_event_unregister(unit, e, cb_bfd);

    return BCM_E_NONE;
}

/*
* Creating vpls tunnel and termination
* is_pwe_gal is only applicable for Arad+,
* Jericho does not need GAL termination or adding CW (These are both done at the OAMP).
*/
int pwe_init(int unit, uint8 is_pwe_gal) {
    bcm_error_t rv;
    bcm_mpls_tunnel_switch_t tunnel_switch;

    if(is_device_or_above(unit, JERICHO2))
    {
        cint_vpls_basic_info.cw_present = 1;
        rv = vpls_mp_basic_main(unit, port_1, port_2);
        if (rv != BCM_E_NONE) {
            printf("(%s) \n",bcm_errmsg(rv));
            return rv;
        }
    }
    else
    {
        if (!is_pwe_gal && pwe_ach) {
          /*  in Jericho when a packet arrives with a GAL the MPLS termination mechanism knows to look for a CW. Hence in this case the LIF need not be configured with a CW. */
          pwe_cw = 1;
        }

        mpls_lsr_init(port_1,port_2, 0, next_hop_mac, mpls_label, mpls_label, 0, 0 ,0);
        rv = vswitch_vpls_run_with_defaults_dvapi(unit,port_1,port_2);
        if (rv != BCM_E_NONE) {
          printf("(%s) \n",bcm_errmsg(rv));
          return rv;
        }

        rv = mpls_add_term_entry_ex(unit, mpls_label, 0, &tunnel_switch);
        if (rv != BCM_E_NONE) {
          printf("(%s) \n",bcm_errmsg(rv));
          return rv;
        }
    }
    return rv;
}


/**
* Create PWE endpoint for the 4 different VCCV types.
*
* @author sinai (23/09/2014)
*
* @param unit
* @param vccv_type
*
* @return int
*/
int bfd_pwe_example(int unit , int vccv_type) {
    bcm_error_t rv;
    bcm_bfd_endpoint_info_t bfd_endpoint_info;
    bcm_bfd_endpoint_info_t bfd_endpoint_test_info;
    bcm_mpls_tunnel_switch_t tunnel_switch;
    int ret;
    int bfd_supported_flags;

    rv = oam__device_type_get(unit, &device_type);
    if (rv < 0) {
      printf("Error checking whether the device is arad+.\n");
      print rv;
      return rv;
    }

    if (soc_property_get(unit, "bfd_mask_flags_bitfield", 0)){
        /* Feature requires egress PMF changes, taken from the trap code*/
        int bfd_ip_trap_code;
        rv = bcm_rx_trap_type_get(unit,0, bcmRxTrapOamBfdPwe,&bfd_ip_trap_code);
        BCM_IF_ERROR_RETURN(rv);

        rv = field_bfd_advanced_features(unit, bfd_ip_trap_code);
        BCM_IF_ERROR_RETURN(rv);
    }

    rv = pwe_init(unit, 0);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    /*
    * Adding BFDoPWE with control word endpoint
    */
    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_info);

    if (vccv_type == 4) {
        bfd_endpoint_info.type = bcmBFDTunnelTypePweGal;
    } else if (vccv_type == 2) {
        bfd_endpoint_info.type = bcmBFDTunnelTypePweRouterAlert;
        if (pwe_ach) {
            /* For Router Alert Types the PWE-ACH label is optional. supported via flag.*/
            bfd_endpoint_info.flags |= BCM_BFD_ENDPOINT_PWE_ACH;
        }
    } else if (vccv_type == 3) {
        bfd_endpoint_info.type = bcmBFDTunnelTypePweTtl;
    } else {
        bfd_endpoint_info.type = bcmBFDTunnelTypePweControlWord;
    }

    if(is_device_or_above(unit, JERICHO2))
    {
        /** Outer encapsulation port  */
        bfd_endpoint_info.gport = cint_vpls_basic_info.mpls_port_id_ingress;
        bfd_endpoint_info.egress_if = cint_vpls_basic_info.core_arp_id;
        bfd_endpoint_info.label = 3000; /* PWE Label */
        bfd_endpoint_info.udp_src_port = 0;
        BCM_GPORT_SYSTEM_PORT_ID_SET(bfd_endpoint_info.tx_gport, port_1);
    }
    else
    {
        bfd_endpoint_info.gport = mpls_lsr_info_1.mpls_port_id; /*in lif: mpls_port->mpls_port_id */
        bfd_endpoint_info.egress_if = mpls_lsr_info_1.encap_id; /* out lif: mpls_port->encap_id */
        bfd_endpoint_info.egress_label.label = 2010; /* PWE Label */
        bfd_endpoint_info.udp_src_port = 0;
        bcm_stk_sysport_gport_get(unit,port_1, &bfd_endpoint_info.tx_gport);
    }

    bfd_endpoint_info.dst_ip_addr = 0;
    bfd_endpoint_info.src_ip_addr = 0;
    bfd_endpoint_info.ip_tos = 0;
    bfd_endpoint_info.ip_ttl = 0;
    bfd_endpoint_info.int_pri = 1;
    bfd_endpoint_info.local_min_tx = 2;
    bfd_endpoint_info.local_min_rx = 3;
    bfd_endpoint_info.bfd_period = 100;
    bfd_endpoint_info.local_detect_mult = 208;
    bfd_endpoint_info.local_state = 3;
    bfd_endpoint_info.flags |= BCM_BFD_ENDPOINT_IN_HW;
    bfd_endpoint_info.remote_discr = 0x10001;
    bfd_endpoint_info.remote_detect_mult = 30;
    bfd_endpoint_info.local_discr =  0x34;
    bfd_supported_flags = soc_property_get(unit, "bfd_supported_flags_bitfield",0);
    if(bfd_supported_flags == 0x38) {
        bfd_endpoint_info.local_flags = 0;
    } else {
        bfd_endpoint_info.local_flags = 2;
    }

    if(is_device_or_above(unit, JERICHO2))
    {
        if (is_rx_statisitcs_enabled)
        {
             bfd_endpoint_info.flags2 |= BCM_BFD_ENDPOINT_FLAGS2_RX_STATISTICS;
        }

        if (is_tx_statisitcs_enabled)
        {
             bfd_endpoint_info.flags2 |= BCM_BFD_ENDPOINT_FLAGS2_TX_STATISTICS;
        }
    }

    bfd_endpoint_info.egress_label.ttl = (vccv_type==3) ? 1 : 0xa;
    bfd_endpoint_info.egress_label.exp = 1;

    printf("bcm_bfd_endpoint_create bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    printf("created endpoint with id %d\n", bfd_endpoint_info.id);

    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_test_info);
    printf("bcm_bfd_endpoint_get bfd_endpoint_test_info\n");
    rv = bcm_bfd_endpoint_get(unit, bfd_endpoint_info.id, &bfd_endpoint_test_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    /* Here mep_not_acc_info and mep_not_acc_test_info should be compared */
    ret =cmp_structs(unit, &bfd_endpoint_info, &bfd_endpoint_test_info,bcmBFDTunnelTypePweControlWord ) ;
    if (ret != 0) {
      printf("%d wrong fields in BFDoPWE\n", ret);
    }

    printf("bcm_bfd_endpoint_destroy bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_destroy(unit, bfd_endpoint_info.id);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    printf("bcm_bfd_endpoint_create bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    bfd_ep1.gport = bfd_endpoint_info.gport;
    bfd_ep1.id = bfd_endpoint_info.id;

    return rv;
}

/**
* BFD over PWE, according to VCCV Type:
* Type 1: BFD over CW (ACH)  over PWE
* Type 2: PWE  over router alert
* Type 3: PWE TTL=1 (unsupported)
* Type 4: BFD over G-ACH over GAL over PWE.
*
* @author sinai (23/09/2014)
*
* @param unit
* @param port1
* @param port2
* @param vccv_type - must be 1,2,4
*
* @return int
*/
int bfd_pwe_run_with_defaults(int unit, int port1, int port2, int vccv_type) {
    bcm_error_t rv;

    port_1 = port1;
    port_2 = port2;

    rv = mpls__mpls_pipe_mode_exp_set(unit);
    if (rv != BCM_E_NONE) {
        printf("Error, in mpls__mpls_pipe_mode_exp_set\n");
        return rv;
    }

    rv = oam__device_type_get(unit, &device_type);
    if (rv < 0) {
        printf("Error checking whether the device is arad+.\n");
        print rv;
        return rv;
    }

    /* In QAX all 4 VCCV types are supported */
    if (device_type<device_type_qax) {
        if (device_type>=device_type_jericho) {
             /* In Jericho VCCV type 3 is not supported */
            if (vccv_type != 1 && vccv_type != 2 && vccv_type != 4) {
                printf("Only VCCV Types 1,2,4 supported\n");
                return 99;
            }
        } else if (device_type==device_type_arad_plus) {
            /* In Arad Plus VCCV types 2,3 are not supported */
            if (vccv_type != 1 &&  vccv_type != 4) {
                printf("Only VCCV Types 1,4 supported\n");
                return 99;
            }
        } else {
            if (vccv_type != 1) {
                /* In Arad only VCCV type 1 is supported */
                printf("Only VCCV Type 1 supported\n");
                return 99;
            }
        }
    }


    if (device_type==device_type_arad_plus && vccv_type == 4) {
        /* PWE GAL handled serparatly in Arad+*/
        rv =  bfd_pwe_gal_example(unit);
        if (rv != BCM_E_NONE) {
            printf("(%s) \n", bcm_errmsg(rv));
            return rv;
        }
    }

    rv =  bfd_pwe_example(unit, vccv_type);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n", bcm_errmsg(rv));
        return rv;
    }

    if (enable_oamp_counter_allocation)
    {
        /** Allocate counters for 1k MEPs with statistics enable, counter base is the first MEP. */
        /* last parameter eviction always 1 for BFD*/
        rv = cint_oam_oamp_statistics_main(unit, bfd_ep1.id, 1024, (enable_oamp_counter_allocation-1),1);
        if (rv != BCM_E_NONE) {
            printf("(%s) \n",bcm_errmsg(rv));
            return rv;
        }
    }

    rv = register_events(unit);
    return rv;
}

/* Example of using the default MEPs by rif profile */
int bfd_default_mep_over_rif_example(int unit, int port1, int port2)
{
    int rv;
    bcm_bfd_endpoint_info_t bfd_endpoint_info;
    create_l3_intf_s bfd_rif, non_bfd_rif;
    int trap_code;
    bcm_mac_t mac_address  = {0x00, 0x0c, 0x00, 0x02, 0x00, 0x00};  /* my-MAC */
    bcm_mac_t non_bfd_mac_address = {0x00, 0x0c, 0x00, 0x02, 0x00, 0x01};

    /**
     *  This field should have a value between 0 and 3,
     *  where 0 maps to BCM_BFD_ENDPOINT_DEFAULT0, 1
     *  maps to BCM_BFD_ENDPOINT_DEFAULT1, etc.
     */
    bfd_rif.oam_default_profile = 1;
    bfd_rif.vsi = 10;
    bfd_rif.my_global_mac = mac_address;
    bfd_rif.my_lsb_mac = mac_address;
    bfd_rif.vrf_valid = 1;
    bfd_rif.vrf = 0;
    bfd_rif.mtu_valid = 1;
    bfd_rif.mtu = 0;
    bfd_rif.mtu_forwarding = 0;

    rv = l3__intf_rif__create(unit, &bfd_rif);
    if (rv != BCM_E_NONE)
    {
        printf("Error, l3__intf_rif__create\n");
    }

    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_info);

    BCM_GPORT_LOCAL_SET(bfd_endpoint_info.remote_gport, port2);
    /* remote_gport field must be a trap */
    rv = bfd_create_trap_from_gport(unit, bfd_endpoint_info.remote_gport, &trap_code);
    if (rv != BCM_E_NONE)
    {
        printf("Error bfd_create_trap_from_gport.\n");
        return rv;
    }
    last_trap_code_created = trap_code;
    BCM_GPORT_TRAP_SET(bfd_endpoint_info.remote_gport, trap_code, 7, 0);


    bfd_endpoint_info.id = BCM_BFD_ENDPOINT_DEFAULT1;


    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE)
    {
        printf("Error, bcm_bfd_endpoint_create\n");
    }

    /**
     * Second RIF - no BFD endpoint
     * Packets send here will be dropped
     */
    non_bfd_rif.oam_default_profile = 3;
    non_bfd_rif.vsi = 20;
    non_bfd_rif.my_global_mac = non_bfd_mac_address;
    non_bfd_rif.my_lsb_mac = non_bfd_mac_address;
    non_bfd_rif.vrf_valid = 1;
    non_bfd_rif.vrf = 0;
    non_bfd_rif.mtu_valid = 1;
    non_bfd_rif.mtu = 0;
    non_bfd_rif.mtu_forwarding = 0;

    rv = l3__intf_rif__create(unit, &non_bfd_rif);
    if (rv != BCM_E_NONE)
    {
        printf("Error, l3__intf_rif__create\n");
    }

    return rv;
}

/* Example of using the default MEPs by lif profile */
int bfd_default_mep_over_lif_example(int unit, int port1, int port2)
{
    int rv;
    bcm_bfd_endpoint_info_t bfd_endpoint_info;
    int trap_code;

    cint_vpls_basic_info.cw_present = 1;
    rv = vpls_mp_basic_main(unit, port1, port2);
    if (rv != BCM_E_NONE)
    {
        printf("Error, in vpls_mp_basic_main\n");
        return rv;
    }

    rv = bcm_port_control_set(unit, cint_vpls_basic_info.mpls_port_id_ingress, bcmPortControlOamDefaultProfile, 2);
    if (rv != BCM_E_NONE)
    {
        printf("Error, bcm_port_control_set\n");
        return rv;
    }

    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_info);

    BCM_GPORT_LOCAL_SET(bfd_endpoint_info.remote_gport, port2);
    /* remote_gport field must be a trap */
    rv = bfd_create_trap_from_gport(unit, bfd_endpoint_info.remote_gport, &trap_code);
    if (rv != BCM_E_NONE)
    {
        printf("Error bfd_create_trap_from_gport.\n");
        return rv;
    }
    last_trap_code_created = trap_code;
    BCM_GPORT_TRAP_SET(bfd_endpoint_info.remote_gport, trap_code, 7, 0);

    bfd_endpoint_info.id = BCM_BFD_ENDPOINT_DEFAULT2;

    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE)
    {
        printf("Error, bcm_bfd_endpoint_create\n");
    }

    return rv;
}

/*
* Creating mpls tunnel and termination.
*/
int mpls_init(int unit, bcm_mpls_tunnel_switch_t *tunnel_switch, int *tunnel_id, int is_BFDCC, int is_muti_hop_mpls, int port1, int port2) {
    bcm_error_t rv;
    uint32 next_prcl;
    int create_mpls_tunnel;

    port_1 = port1;
    port_2 = port2;


    rv= oam__device_type_get(unit,&device_type);
    BCM_IF_ERROR_RETURN(rv);

    if (is_BFDCC) {
      create_mpls_tunnel = 1;
      next_prcl = 0;
    } else {
      create_mpls_tunnel = (is_muti_hop_mpls || is_bfd_mpls_tp_cccv)? 1 : 0;
      next_prcl = BCM_MPLS_SWITCH_NEXT_HEADER_IPV4|BCM_MPLS_SWITCH_NEXT_HEADER_IPV6;
    }

    rv = l3_interface_init(unit, port_1, port_2, &next_hop_mac, tunnel_id, create_mpls_tunnel, 0, is_muti_hop_mpls);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    rv = mpls_add_term_entry_ex(unit, mpls_label, next_prcl, tunnel_switch);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    if (is_BFDCC && (device_type <= device_type_arad_plus)) {
      /* In Jericho, GAL label is recognized by the special labels mechanism */
      rv = mpls_add_gal_entry(unit);
      if (rv != BCM_E_NONE) {
          printf("(%s) \n", bcm_errmsg(rv));
          return rv;
      }
    }


    return rv;
}

/**
* Create BFD over MPLS endpoint.
*
* @param unit
*  @return int
*/
int bfd_mpls_example(int unit, int is_muti_hop_mpls) {
    bcm_error_t rv;
    bcm_bfd_endpoint_info_t bfd_endpoint_info;
    bcm_bfd_endpoint_info_t bfd_endpoint_test_info;
    bcm_mpls_tunnel_switch_t tunnel_switch;
    int tunnel_id, ret;
    int bfd_supported_flags;

    rv = oam__device_type_get(unit, &device_type);
    if (rv < 0) {
        printf("Error checking whether the device is arad+.\n");
        print rv;
        return rv;
    }
    /* in case of mpls multi hop extended the PMF should do the classification*/
    if(is_muti_hop_mpls) {
        rv = bfd_ipv4_single_hop_field_action(unit);
        if (rv != BCM_E_NONE) {
          printf("Error bfd_ipv4_single_hop_field_trap_qualifier.\n");
          return rv;
        }
    }

    rv = mpls_init(unit, &tunnel_switch, &tunnel_id,0,is_muti_hop_mpls, port_1, port_2);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n",bcm_errmsg(rv));
        return rv;
    }
    /*
    * Adding BFDoMPLS endpoint
    */

    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_info);
    if(is_bfd_mpls_php_ep) {
        bfd_endpoint_info.type = bcmBFDTunnelTypeMplsPhp;
        rv = bfd_ipv4_single_hop_field_action(unit);
        if (rv != BCM_E_NONE) {
            printf("Error bfd_ipv4_single_hop_field_trap_qualifier.\n");
            return rv;
        }
    } else {
        bfd_endpoint_info.type = is_bfd_mpls_tp_cccv ? bcmBFDTunnelTypeMplsTpCcCv : bcmBFDTunnelTypeMpls;
    }
    if (device_type < device_type_jericho || is_bfd_mpls_ttl255) {
        bfd_endpoint_info.gport = tunnel_switch.tunnel_id; /* in lif - instead of your discriminator (Only in Arad). */
    }
    if(is_device_or_above(unit, JERICHO2))
    {
    	BCM_GPORT_SYSTEM_PORT_ID_SET(bfd_endpoint_info.tx_gport, port_1);
        bfd_endpoint_info.local_discr =  0x200004;
    }
    else
    {
    	bcm_stk_sysport_gport_get(unit,port_1, &bfd_endpoint_info.tx_gport );
        bfd_endpoint_info.local_discr =  0x20002;
    }
    bfd_endpoint_info.dst_ip_addr = is_muti_hop_mpls ? 0x12345678 : 0;
    bfd_endpoint_info.src_ip_addr = 0x30F0701;
    bfd_endpoint_info.ip_tos = 0xff;
    bfd_endpoint_info.ip_ttl = is_bfd_mpls_tp_cccv ? 255 : 1;
    bfd_endpoint_info.udp_src_port = 0xC001;
    bfd_endpoint_info.egress_if = tunnel_id; /* out lif */
    bfd_endpoint_info.int_pri = 1;
    bfd_endpoint_info.local_min_tx = 1;
    bfd_endpoint_info.local_min_rx = 3;
    bfd_endpoint_info.bfd_period = bfd_tx_period;
    bfd_endpoint_info.local_detect_mult = 0xd0;
    bfd_endpoint_info.local_state = 3;
    if(is_muti_hop_mpls){
        bfd_endpoint_info.flags |= BCM_BFD_ENDPOINT_IN_HW |BCM_BFD_ENDPOINT_MULTIHOP;
    }
    else {
        bfd_endpoint_info.flags = BCM_BFD_ENDPOINT_IN_HW;
    }
    bfd_endpoint_info.remote_discr = 0x10003;
    bfd_endpoint_info.remote_detect_mult = 30;
    bfd_endpoint_info.loc_clear_threshold =  1;
    bfd_supported_flags = soc_property_get(unit, "bfd_supported_flags_bitfield",0);
    if(bfd_supported_flags == 0x38) {
        bfd_endpoint_info.local_flags = 0;
    } else {
        bfd_endpoint_info.local_flags = 2;
    }
    if(is_device_or_above(unit, JERICHO2))
    {
        bfd_endpoint_info.label = mpls_label;
    }
    else
    {
        bfd_endpoint_info.egress_label.label = mpls_label;
    }
    bfd_endpoint_info.egress_label.ttl = 0xa;
    bfd_endpoint_info.egress_label.exp = 1;

    if (is_s_bfd_init_ep) {
        bfd_endpoint_info.flags2 |= BCM_BFD_ENDPOINT_FLAGS2_SEAMLESS_BFD_INITIATOR;
        /* Some number outside 49152 - 65535 range since
         * SBFD does not have limitations on UDP src port range */
        bfd_endpoint_info.udp_src_port = 20020;
        /* local_min_rx and local_min_echo needs to be zero */
        bfd_endpoint_info.local_min_rx = 0;
        bfd_endpoint_info.local_min_echo = 0;
        /* TTL should be set to 1 */
        bfd_endpoint_info.ip_ttl = 1;
        /* label TTL should be 255. */
        bfd_endpoint_info.egress_label.ttl = 255;
        /* local_state set to UP */
        bfd_endpoint_info.local_state = 3;
        /* Local flag should have demand bit (bit 1) set
         * P | F | C | A | D | M
         * 0 | 0 | 0 | 0 | 1 | 0
         */
        bfd_endpoint_info.local_flags = 0x2;
    }

    if (is_s_bfd_reflector) {
        rv = sbfd_reflector_endpoint_create(unit, 0x7F000001, 0x10, 3);
        return rv;
    }
    if(is_bfd_mpls_tp_cccv){
        /*terminate pwe and cw*/
        bcm_mpls_port_t mpls_port;
        bcm_gport_t gport_id;
        bcm_if_t ingress_encap_id = 0x3300;
        bcm_mpls_port_t_init(&mpls_port);
        
        mpls_port.flags |= BCM_MPLS_PORT_WITH_ID | BCM_MPLS_PORT_EGRESS_TUNNEL | BCM_MPLS_PORT_CONTROL_WORD;
        mpls_port.flags2 |= BCM_MPLS_PORT2_INGRESS_ONLY;
        if ((device_type >= device_type_jericho2))
        {
            mpls_port.flags2 |= BCM_MPLS_PORT2_CROSS_CONNECT;
        }
        BCM_GPORT_SUB_TYPE_LIF_SET(gport_id, 0, ingress_encap_id);
        BCM_GPORT_MPLS_PORT_ID_SET(mpls_port.mpls_port_id, gport_id);
        mpls_port.criteria = BCM_MPLS_PORT_MATCH_LABEL;
        mpls_port.match_label = 212;
        mpls_port.port = 0;

        rv = bcm_mpls_port_add(unit, 0, mpls_port);
        if (rv != BCM_E_NONE)
        {
            printf("Error, bcm_mpls_port_add %d\n", rv);
            return rv;
        }
        bfd_endpoint_info.gport = mpls_port.mpls_port_id; /*in lif: mpls_port->mpls_port_id */
    }
    printf("bcm_bfd_endpoint_create bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n",bcm_errmsg(rv));
        return rv;
    }
    bfd_ep1.id = bfd_endpoint_info.id;
    printf("created endpoint with id %d\n", bfd_endpoint_info.id);

    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_test_info);
    printf("bcm_bfd_endpoint_get bfd_endpoint_test_info\n");
    rv = bcm_bfd_endpoint_get(unit, bfd_endpoint_info.id, &bfd_endpoint_test_info);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n",bcm_errmsg(rv));
        return rv;
    }

    /* update --> change the min tx*/
    bfd_endpoint_info.local_min_tx = is_s_bfd_reflector ? 0:2;
    bfd_endpoint_info.src_ip_addr = is_s_bfd_reflector ? 0x7F000001 : 0x30F0701;
    if(is_muti_hop_mpls){
        bfd_endpoint_info.flags |= BCM_BFD_ENDPOINT_WITH_ID | BCM_BFD_ENDPOINT_UPDATE |BCM_BFD_ENDPOINT_MULTIHOP;
    }
    else {
        bfd_endpoint_info.flags |= BCM_BFD_ENDPOINT_WITH_ID | BCM_BFD_ENDPOINT_UPDATE;
    }
    printf("bcm_bfd_endpoint_get bfd_endpoint_test_info --> update\n");
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n",bcm_errmsg(rv));
        return rv;
    }

    bfd_endpoint_info.flags ^= BCM_BFD_ENDPOINT_WITH_ID | BCM_BFD_ENDPOINT_UPDATE;
    rv = bcm_bfd_endpoint_get(unit, bfd_endpoint_info.id, &bfd_endpoint_test_info);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n",bcm_errmsg(rv));
        return rv;
    }

    /* Here mep_not_acc_info and mep_not_acc_test_info should be compared */
    if(is_bfd_mpls_php_ep) {
        rv = cmp_structs(unit, &bfd_endpoint_info, &bfd_endpoint_test_info,bcmBFDTunnelTypeMplsPhp);
    } else {
        rv = cmp_structs(unit, &bfd_endpoint_info, &bfd_endpoint_test_info, is_bfd_mpls_tp_cccv ? bcmBFDTunnelTypeMplsTpCcCv : bcmBFDTunnelTypeMpls ) ;
    }
    if (rv!= 0) {
      printf("%d wrong fields in BFDoMPLS\n", rv);
    }

    if (!is_s_bfd_init_ep && !is_s_bfd_reflector && !is_bfd_mpls_tp_cccv) {
        mpls_label = 212;

        /* Create an additonal Endpoint on LIF defined by label 212.*/
        rv = mpls_init(unit, &tunnel_switch, &tunnel_id,0,is_muti_hop_mpls,port_1, port_2);
        if (rv != BCM_E_NONE) {
            printf("(%s) \n",bcm_errmsg(rv));
            return rv;
        }
        if (device_type < device_type_jericho || is_bfd_mpls_ttl255) {
            bfd_endpoint_info.gport = tunnel_switch.tunnel_id; /* in lif - instead of your discriminator - Arad only.*/
        }
        if(is_device_or_above(unit, JERICHO2))
        {
            BCM_GPORT_SYSTEM_PORT_ID_SET(bfd_endpoint_info.tx_gport, port_1);
            bfd_endpoint_info.local_discr =  0x200008;
        }
        else
        {
            bcm_stk_sysport_gport_get(unit,port_1, &bfd_endpoint_info.tx_gport );
            bfd_endpoint_info.local_discr =  0x20003;
        }

        bfd_endpoint_info.egress_if = tunnel_id; /* out lif */
        if(is_device_or_above(unit, JERICHO2))
        {
            bfd_endpoint_info.label = mpls_label;
        }
        else
        {
            bfd_endpoint_info.egress_label.label = mpls_label;
        }

        rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
        if (rv != BCM_E_NONE) {
            printf("(%s) \n",bcm_errmsg(rv));
            return rv;
        }
        bfd_ep2.id = bfd_endpoint_info.id;
    }

    return rv;
}


/**
* Create BFD over MPLS endpoint using the specified ports.
*
* @param unit
* @param port_1 - port for incoming packets
* @param port_2 - port for outgoing packets
* @param is_muti_hop_mpls:  It's used to support IPv4 BFD Multi-Hop over MPLS feature.
*    SOC : 
*    User has  to add  property "custom_feature_non_bfd_forwarding=$recycle_port" along with "tm_port_header_type_out_$recycle_port=ETH" soc property.
*    First pass:
*    o Packet will be forwarded as normal MPLS forwarding process.
*    o install a forwarding entry for "My IP" with destination of special recycle port.  
*    Second pass:
*    o After 1st pass, the MPLS label will be stripped. Packet type will be BFDoUDPoIPoEth.  
*    o then the processing is like Multi hop IP no_bfd_forwarding,  packet will hit flp program PROG_FLP_BFD_IPV4_SINGLE_HOP.
*
*  When is_bfd_mpls_tp_cccv is enabled, the type bcmBFDTunnelTypeMplsTpCcCv is supported.
*    o OAMP will transmit BFDoUDPoIPV4oGACHoPWoLSPxoETH packet. 
*    o The BFDoUDPoIPV4oGACHoPWoLSPxoETH packet can be processed by OAMP 
*  
* @return int
*/
int bfd_mpls_run_with_defaults(int unit, int port1, int port2,  int is_muti_hop_mpls) {
    bcm_error_t rv;

    port_1 = port1;
    port_2 = port2;

    rv = mpls__mpls_pipe_mode_exp_set(unit);
    if (rv != BCM_E_NONE) {
      printf("Error, in mpls__mpls_pipe_mode_exp_set\n");
      return rv;
    }


    if (soc_property_get(unit, "bfd_mask_flags_bitfield", 0)){
        /* Feature requires egress PMF changes, taken from the trap code*/
        int bfd_ip_trap_code;
        rv = bcm_rx_trap_type_get(unit,0, bcmRxTrapOamBfdMpls,&bfd_ip_trap_code);
        BCM_IF_ERROR_RETURN(rv);

        rv = field_bfd_advanced_features(unit, bfd_ip_trap_code);
        BCM_IF_ERROR_RETURN(rv);
    }

    rv =  bfd_mpls_example(unit,is_muti_hop_mpls);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    rv = register_events(unit);
    return rv;
}

/*
* Creates a BFD endpoint of type MPLS-TP (BFD-CC)
*/
int bfdCC_example(int unit,int use_user_defined_trap) {
    bcm_error_t rv;
    bcm_bfd_endpoint_info_t bfd_endpoint_info;
    bcm_mpls_tunnel_switch_t tunnel_switch;
    int tunnel_id, ret;
    int bfd_supported_flags;

    rv = oam__device_type_get(unit, &device_type);
    if (rv < 0) {
        printf("Error checking whether the device is arad+.\n");
        print rv;
        return rv;
    }

    tunnel_id = 99;

    rv = mpls_init(unit, &tunnel_switch, &tunnel_id,1,0,port_1, port_2);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n",bcm_errmsg(rv));
        return rv;
    }

    /*
    * Adding BFDoMPLS endpoint
    */

    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_info);

    bfd_endpoint_info.type = bcmBFDTunnelTypeMplsTpCc;
    bfd_endpoint_info.gport = tunnel_switch.tunnel_id; /* in lif - instead of your discriminator */
    bfd_endpoint_info.dst_ip_addr = 0;
    bfd_endpoint_info.src_ip_addr = 0;
    bfd_endpoint_info.ip_tos = 0;
    bfd_endpoint_info.ip_ttl = 0;
    bfd_endpoint_info.udp_src_port = 0;
    if (device_type == device_type_arad_plus) {
        /* In this case the OAMP only creates the GAL label. The MPLS label is added through the encapsulation bank.*/
        bfd_endpoint_info.egress_if = tunnel_id;
        /* Gal label properties*/
        bfd_endpoint_info.egress_label.ttl = 0x40;
        bfd_endpoint_info.egress_label.exp = 0;
        bfd_endpoint_info.egress_label.label =  gal_label;
    } else {
        /* In this case the OAMP creates the MPLS label as well as the GAL.*/
        bfd_endpoint_info.egress_if = next_hop_mac;
        /* MPLS label properties*/
        if(is_device_or_above(unit, JERICHO2))
        {
            bfd_endpoint_info.label =  mpls_label_termination;
        }
        else
        {
            bfd_endpoint_info.egress_label.label =  mpls_label_termination;
        }
        bfd_endpoint_info.egress_label.ttl = mpls_ttl;
        bfd_endpoint_info.egress_label.exp = mpls_exp;
    }

    bfd_endpoint_info.flags = BCM_BFD_ENDPOINT_IN_HW;

    /*Set the remote_gport to a user defined trap code.*/
    if (use_user_defined_trap) {
        int trap_code;
        bcm_rx_trap_config_t trap_cpu;
        rv =  bcm_rx_trap_type_create(unit, 0, bcmRxTrapUserDefine, &trap_code);
        if (rv != BCM_E_NONE) {
           printf("(%s) \n",bcm_errmsg(rv));
           return rv;
        }
        bcm_rx_trap_config_t_init(&trap_cpu);
        trap_cpu.flags = BCM_RX_TRAP_UPDATE_DEST | BCM_RX_TRAP_TRAP;
        trap_cpu.dest_port = port_2;
        rv = bcm_rx_trap_set(unit, trap_code, &trap_cpu);
        if (rv != BCM_E_NONE) {
            printf("(%s) \n", bcm_errmsg(rv));
            return rv;
        }
        printf("Trap created trap_code=%d \n",trap_code);
        BCM_GPORT_TRAP_SET(bfd_endpoint_info.remote_gport, trap_code, 7, 0); /*Taken from default values*/
    } else {
        /* set TX fields*/
        bfd_endpoint_info.int_pri = 5;
        bfd_endpoint_info.local_discr =  0x30004;
        bfd_endpoint_info.remote_discr = 0x10002;
        bfd_supported_flags = soc_property_get(unit, "bfd_supported_flags_bitfield",0);
        if(bfd_supported_flags == 0x38) {
            bfd_endpoint_info.local_flags = 0x10;
        } else {
            bfd_endpoint_info.local_flags = 0x12;
        }
        bfd_endpoint_info.local_state = 3;
        bfd_endpoint_info.local_min_tx = 0xa;
        bfd_endpoint_info.local_min_echo = 0xbadf00d;
        bfd_endpoint_info.local_min_rx = 0xa;
        bfd_endpoint_info.bfd_period = 100;
        bfd_endpoint_info.local_detect_mult = 208;
        bfd_endpoint_info.remote_detect_mult = 30;
        if(!is_device_or_above(unit, JERICHO2))
        {
            bcm_stk_sysport_gport_get(unit,port_1, &bfd_endpoint_info.tx_gport);
        }
    }

    if(is_device_or_above(unit, JERICHO2))
    {
        BCM_GPORT_SYSTEM_PORT_ID_SET(bfd_endpoint_info.tx_gport, port_1);
    }

    printf("bcm_bfd_endpoint_create bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n",bcm_errmsg(rv));
        return rv;
    }
    printf("created endpoint with id %d\n", bfd_endpoint_info.id);

    if (!use_user_defined_trap) {
        /* endpoint replace: change the local flags.*/
        bfd_endpoint_info.flags |= BCM_BFD_ENDPOINT_WITH_ID | BCM_BFD_ENDPOINT_UPDATE;
        bfd_supported_flags = soc_property_get(unit, "bfd_supported_flags_bitfield",0);
        if(bfd_supported_flags == 0x38) {
            bfd_endpoint_info.local_flags = 0x0;
        } else {
            bfd_endpoint_info.local_flags = 0x2;
        }
        printf("bcm_bfd_endpoint_replace: changing the local_flags\n");
        rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
        if (rv != BCM_E_NONE) {
            printf("(%s) \n", bcm_errmsg(rv));
            return rv;
        }
    }

    return rv;
}

/*
* Creates a BFD endpoint of type MPLS-TP (BFD-CC)
* port1 will be used for packet transmission
* port2 will be used for packet reception
* (or the user defined trap, if use_user_defined_trap=TRUE)
*/
int bfd_cc_run_with_defaults(int unit, int port1, int port2, int use_user_defined_trap ) {
    bcm_error_t rv;

    port_1 = port1;
    port_2 = port2;

    rv = mpls__mpls_pipe_mode_exp_set(unit);
    if (rv != BCM_E_NONE) {
      printf("Error, in mpls__mpls_pipe_mode_exp_set\n");
      return rv;
    }

    rv = bfdCC_example(unit, use_user_defined_trap);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    rv = register_events(unit);
    return rv;
}


/*
* function compares endpoint_info_t created with bfd_mpls_endpoint_info_create() and a struct returned from bfd_endpoint_info_get().
*  type may be bcmBFDTunnelTypePweControlWord,  bcmBFDTunnelTypeMpls or bcmBFDTunnelTypeUdp
*  function returns 0 upon success, number of wrong fields upon failure.
*/
int cmp_structs(int unit, bcm_bfd_endpoint_info_t* endpoint_create,bcm_bfd_endpoint_info_t* endpoint_get, int type  ){
    int rv =0;
    uint32 create_flags, get_flags;
    create_flags = endpoint_create->flags;
    get_flags = endpoint_get->flags;
    if(is_device_or_above(unit, JERICHO2))
    {
        if((endpoint_create->type == bcmBFDTunnelTypeMplsTpCc) ||
           (endpoint_create->type == bcmBFDTunnelTypePweGal) ||
           (endpoint_create->type == bcmBFDTunnelTypePweControlWord) ||
           (endpoint_create->type == bcmBFDTunnelTypePweRouterAlert) ||
           (endpoint_create->type == bcmBFDTunnelTypePweTtl))
        {
            /** This flag is added for these types */
            create_flags |= BCM_BFD_ENDPOINT_PWE_ACH;
            get_flags |= BCM_BFD_ENDPOINT_PWE_ACH;
        }
    }
    if (create_flags != get_flags) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - flags fields are different.\n");
      printf("Create flags: 0x%08X\nGet flags: 0x%08X\n", create_flags, get_flags);
      ++rv;
    }
    if (endpoint_create->id != endpoint_get->id ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - id fields are different.\n");
      ++rv;
    }
    if (endpoint_create->type != endpoint_get->type ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - type fields are different.\n");
      ++rv;
    }
    if(!is_device_or_above(unit, JERICHO2))
    {
        if (endpoint_create->gport != endpoint_get->gport ) {
          printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - gport fields do not match.\n Expected %d, got %d.\n",
                    endpoint_create->gport, endpoint_get->gport);
          ++rv;
        }
    }
    else
    {
        /**
         * In JR2, gport is ignored if the incoming packet is classified by discriminator.
         * Also, the gport's prefix (upper 16 bits) is changed before saving it.
         */
        if((endpoint_create->type != bcmBFDTunnelTypeUdp) && (endpoint_create->type != bcmBFDTunnelTypeMpls) &&
           ((endpoint_create->gport & 0xFFFF) != (endpoint_get->gport & 0xFFFF)))
        {
            printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - gport fields do not match.\n Expected %d, got %d.\n",
                      endpoint_create->gport, endpoint_get->gport);
        }
    }
    if((!is_device_or_above(unit, JERICHO2) || ((endpoint_create->flags & BCM_BFD_ENDPOINT_IN_HW)==0)) &&
     (endpoint_create->remote_gport != endpoint_get->remote_gport )) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - remote_gport fields do not match.\n");
      ++rv;
    }

    if (endpoint_create->src_ip_addr != endpoint_get->src_ip_addr ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - src_ip_addr fields do not match. Expected %d, got %d\n",
                endpoint_create->src_ip_addr, endpoint_get->src_ip_addr );
      ++rv;
    }
    if (!is_device_or_above(unit, JERICHO2) ||
       (((bcmBFDTunnelTypeUdp == endpoint_create->type)
         && ((endpoint_create->flags & BCM_BFD_ENDPOINT_MULTIHOP) != 0))
        || (bcmBFDTunnelTypeMpls == endpoint_create->type)))
    {
        if (endpoint_create->ip_tos != endpoint_get->ip_tos ) {
          printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - ip_tos fields do not match.\n");
          ++rv;
        }
        if (endpoint_create->ip_ttl != endpoint_get->ip_ttl ) {
          printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - ip_ttl fields do not match.\n");
         ++rv;
        }
    }
    /** In JR2, udp_src_port is ignored for PWE types */
    if ((!is_device_or_above(unit, JERICHO2) ||
       (bcmBFDTunnelTypeUdp == endpoint_create->type) ||
       (bcmBFDTunnelTypeMpls == endpoint_create->type)) &&
       (endpoint_create->udp_src_port != endpoint_get->udp_src_port) ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - udp_src_port fields do not match.\n");
     ++rv;
    }
    if (endpoint_create->egress_if !=endpoint_get->egress_if ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - egress_if fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->int_pri != endpoint_get->int_pri ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - int_pri fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->local_discr != endpoint_get->local_discr ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_discr fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->local_min_tx != endpoint_get->local_min_tx ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_min_tx fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->bfd_period - endpoint_get->bfd_period > 10) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - bfd_period fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->local_min_rx != endpoint_get->local_min_rx ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_min_rx fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->local_detect_mult != endpoint_get->local_detect_mult ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_detect_mult fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->local_state !=endpoint_get->local_state ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_state fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->remote_discr != endpoint_get->remote_discr) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - remote_discr fields do not match.Expected %d, got %d\n",
              endpoint_create->remote_discr, endpoint_get->remote_discr);
      ++rv;
    }
    if (endpoint_create->local_diag != endpoint_get->local_diag) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_diag fields do not match.\n");
      ++rv;
    }
    if ((type == bcmBFDTunnelTypeUdp && ((endpoint_create->flags & BCM_BFD_ENDPOINT_MULTIHOP)==0)) && !is_device_or_above(unit, JERICHO2)) { /*ip single hop - dest ip should be zero.*/
       if (endpoint_get->dst_ip_addr != 0 ) {
          printf("Error, BFDoIPV4: dst_ip_addr field in endpoint_info_t field returned from endpoint_info_get non zero on single hop ip encapsulation. Dest addr is %d\n",endpoint_get->dst_ip_addr);
          ++rv;
      }
    }
    else{ /* in other cases dest_addresses must match*/
      if (endpoint_get->dst_ip_addr != endpoint_create->dst_ip_addr ) {
          printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - dst_ip_addr fields do not match.\n");
          ++rv;
      }
    }
    return rv;
}

int mc_da_termination_example(int unit, int in_vlan){
    int rv;
    int station_id;
    bcm_l2_station_t station;
    bcm_mac_t mutliple_mac = {0x01, 0x00, 0x5e, 0x90, 0x00, 0x01};
    bcm_mac_t mac_mask = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    bcm_l2_station_t_init(&station);
    sal_memcpy(station.dst_mac, mutliple_mac, 6);
    sal_memcpy(station.dst_mac_mask, mac_mask, 6);
    station.flags = (is_device_or_above(unit, JERICHO2)) ? 0: BCM_L2_STATION_IPV4;
    station.vlan = in_vlan;
    station.vlan_mask = 0xffff;
    rv = bcm_l2_station_add(unit, &station_id, &station);
    if (rv != BCM_E_NONE) {
        printf("Error, in bcm_l2_station_add\n");
        return rv;
    }

    return BCM_E_NONE;
}


/* This function create UserDefined trap with CPU destination
 * And create ep=0(your discriminator 'o) that will that will be trapped
 */
int bfd_your_discriminator_null(int unit) {

    bcm_error_t rv;
    bcm_bfd_endpoint_info_t bfd_endpoint_info;
    int trap_code;

     /* Create trap to CPU */
     rv = bfd_create_trap_from_gport(unit, 0, &trap_code);

    /* Create ep 0 */
    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_info);

    bfd_endpoint_info.type = bcmBFDTunnelTypeUdp;
    bfd_endpoint_info.gport = BCM_GPORT_INVALID;
    bfd_endpoint_info.dst_ip_addr = 0;
    bfd_endpoint_info.src_ip_addr = 0;
    bfd_endpoint_info.ip_tos = 0;
    bfd_endpoint_info.ip_ttl = 0;
    bfd_endpoint_info.udp_src_port = 0;
    bfd_endpoint_info.flags = 0;
    bfd_endpoint_info.local_discr =  0x0;

    BCM_GPORT_TRAP_SET(bfd_endpoint_info.remote_gport, trap_code, 7, 0); /*Taken from default values*/
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);

    return rv;
}

