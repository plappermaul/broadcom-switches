/* 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
*/
/*
 * File:        cint_counter_engine_ingress_ext_stat.c
 * Purpose:     Example of configuring internal counter engine, when the source is Ingress_ext_stat
 * Supported devices for this cint: QAX and QUX only.
 *
 * Description: 
 *  For QAX device, there is an option to use two ingress external statistics pointers in the counter processor.
 *  This way, the user can have two additional objects (generated by IPMF) that can counted in the internal counter processor.
 *  The counter engine is connected to ingress TM. so the command is generated by the ITM. 
 *  But instead of counting TM objects, it takes the ingress external statistics pointer.
 *  Ingress TM pointer-0, overriden by external statistic pointer-0.
 *  Ingress TM pointer-1, overriden by external statistic pointer-1. 

 * Scenario description:
 * 1. Configure counter engine with engine_source=bcmStatCounterSourceIngressExtStat, command-id=0 or 1.
 * 2. generate by PMF, external stat pointer (0 or 1), based on the In-Port.
 * 3. Send traffic.
 * 4. read the counter value of the engine.
 *
 * How to run the test?
 *  1. call counter_engine_ingress_ext_stat_config - configure the counter engine.
 *  2. call ingress_ext_stat_add - generate external statistic pointer in IPMF.
 *  3. call bcm_port_force_forward_set(0,in_port,out_port,1) - force forward the traffic from in port to out port.
 *  4. Send traffic from bcm shell: tx 1 psrc=13
 *  5. call counter_engine_ingress_ext_stat_read_and_check - read the counter from the relevant engine and check its value.
 */



/* Brief: 
 *  Configure counter engine with source bcmStatCounterSourceIngressExtStat.
 *  Counter set size=0, FWD/DROP
 */
int counter_engine_ingress_ext_stat_config(
    int unit, 
    int engine_id, 
    int command_id, 
    int pointer_range_start,
    int pointer_range_end)
{
    int rv;
    bcm_stat_counter_engine_t engine;
    bcm_stat_counter_config_t cfg, cfg_get;
    bcm_color_t colors[4] = { bcmColorGreen, bcmColorYellow, bcmColorRed, bcmColorBlack };
    int drop_fwd[2] = { 1, 0 };
    int index1, index2;

    rv = BCM_E_NONE;
    engine.engine_id = engine_id;
    
    cfg.source.core_id = 0;
    cfg.source.engine_source = bcmStatCounterSourceIngressExtStat;
    cfg.source.command_id = command_id;
    cfg.source.num_voqs_per_entry = 1;
    cfg.source.pointer_range.start = pointer_range_start;
    cfg.source.pointer_range.end = pointer_range_end;
    
    cfg.format.format_type = bcmStatCounterFormatPacketsAndBytes;
    /* configure FWD/DROP counter set */
    cfg.format.counter_set_mapping.counter_set_size= 2;
    cfg.format.counter_set_mapping.num_of_mapping_entries=8;
    for ( index1  = 0; index1 < 2; index1++) {
        for (index2 = 0; index2 < 4; index2++) {
            cfg.format.counter_set_mapping.entry_mapping[index1 * 4 + index2].entry.color = colors[index2];
            cfg.format.counter_set_mapping.entry_mapping[index1 * 4 + index2].entry.is_forward_not_drop = drop_fwd[index1];
            cfg.format.counter_set_mapping.entry_mapping[index1 * 4 + index2].offset = (drop_fwd[index1] == 1) ? 0 : 1;
        }
    }


    rv = bcm_stat_counter_config_set(unit, &engine, &cfg);
    if (BCM_E_NONE != rv) 
    {
        printf("bcm_stat_counter_config_set failed\n"); 
        return rv;
    }   
    rv = bcm_stat_counter_config_get(unit, &engine, &cfg_get);
    if (BCM_E_NONE != rv) 
    {
        printf("bcm_stat_counter_config_set failed\n"); 
        return rv;
    }   
    if(sal_memcmp(&cfg, &cfg_get, sizeof(cfg)))
    {
        printf("Error: set and get bcm_stat_counter_config_t is not the same\n");
        printf("bcm_stat_counter_config_t set API: \n");
        printf("================================== \n");
        print cfg;
        printf("bcm_stat_counter_config_t get API: \n");
        printf("================================== \n");
        print cfg_get;
        return BCM_E_FAIL;
    }
    
    printf("\n engine_id %d, command_id %d configured sucessfuly \n\n",engine_id, command_id); 
    return BCM_E_NONE;
}

/* Brief: 
 *  Configure ingress pmf action, which generate external statistic pointer with the in pot value.
 *  Qualifier - In_port.
 */
int ingress_ext_stat_acl_add(int unit, bcm_field_group_t group, int group_priority, bcm_port_t in_port, int command_id)
{
  int result=0;
  int auxRes;
  bcm_field_qset_t qset;
  bcm_field_aset_t aset;
  bcm_field_entry_t ent;
  bcm_field_stat_t stats[2];
  int statId;
  int counter_proc;
  int action ;
  char *proc_name ;

  proc_name = "ingress_ext_stat_add" ;
  printf("%s(): Enter. group %d group_priority %d\r\n",proc_name,group,group_priority) ; 
    
  BCM_FIELD_QSET_INIT(qset);
  BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyStageIngress);
  BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyInPort);

  BCM_FIELD_ASET_INIT(aset);
  if(command_id == 0)
  {
      BCM_FIELD_ASET_ADD(aset, bcmFieldActionStatisticPtr0);
  }
  else if (command_id == 1)
  {
      BCM_FIELD_ASET_ADD(aset, bcmFieldActionStatisticPtr1);      
  }
  else
  {
      printf("command_id=%d, invalid value. \n", command_id);
      return BCM_E_PARAM;     
  }
      
  /*
   *  Create the group and set is actions.  This is two distinct API calls due
   *  to historical reasons.  On petra, the action set call is obligatory, and
   *  a group must have at least one action in its action set before any entry
   *  can be created in the group.
   */
  result = bcm_field_group_create_id(unit, qset, group_priority, group);
  if (BCM_E_NONE != result) {
    printf("bcm_field_group_create_id failed\n"); 
    return result;
  }
  result = bcm_field_group_action_set(unit, group, aset);
  if (BCM_E_NONE != result) {
    printf("bcm_field_group_action_set failed \n");
    auxRes = bcm_field_group_destroy(unit, group);
    return result;
  }

  /*
   *  Add an entry to the group (could add many entries).
   */

  result = bcm_field_entry_create(unit, group, &ent);
  if (BCM_E_NONE != result) 
  {
      printf("bcm_field_entry_create failed \n");
      auxRes = bcm_field_group_destroy(unit, group);
      return result;
  }
  /* certain Broadcom NICs */
  result = bcm_field_qualify_InPort(unit, ent, in_port, -1);
  if (BCM_E_NONE != result) 
  {
      printf("bcm_field_qualify_InPort failed \n");
      auxRes = bcm_field_entry_destroy(unit, ent);
      auxRes = bcm_field_group_destroy(unit, group);
      return result;
  }

  action = command_id == 0 ? bcmFieldActionStatisticPtr0 : bcmFieldActionStatisticPtr1;
  printf("%s(): Call bcm_field_action_add(ent %d action %d in_port %d)\r\n",proc_name,ent,action, in_port) ; 

  result = bcm_field_action_add(unit, ent, action, in_port, 0);
  if (BCM_E_NONE != result) 
  {
      printf("bcm_field_action_add failed \n");
      auxRes = bcm_field_entry_destroy(unit, ent);
      auxRes = bcm_field_group_destroy(unit, group);
      return result;
  }

  /*
   *  Commit the entire group to hardware.  
   */
  result = bcm_field_group_install(unit, group);
  if (BCM_E_NONE != result) 
  {
      printf("bcm_field_group_install failed\n");
      auxRes = bcm_field_entry_destroy(unit, ent);
      auxRes = bcm_field_stat_destroy(unit, statId);
      auxRes = bcm_field_group_destroy(unit, group);
      return result;
  }
  printf("%s(): Exit OK. group %d group_priority %d\r\n",proc_name,group,group_priority) ; 
  return BCM_E_NONE;
}

/* Brief: 
 *  read the counter value from the engine and compare it to expected value
 */
int counter_engine_ingress_ext_stat_read_and_check(
    int unit,
    int engine_id,
    int command_id,
    int counter_pointer,
    int counter_set_offset,
    uint32 expect_packets)
{
    int rv;
    int stat_id;
    uint32 get_val;
    bcm_field_stat_t stat;
    BCM_FIELD_STAT_ID_SET(&stat_id, engine_id, counter_pointer); 
    if (counter_set_offset == 0)
    {
        stat = bcmFieldStatOffset0Packets;
    }
    else if (counter_set_offset == 1)
    {
        stat = bcmFieldStatOffset1Packets;
    }
    else
    {
        printf("counter_set_offset=%d. Allowed 0 or 1 for this engine configuration.\n", counter_set_offset);
        return BCM_E_PARAM;
    }
    rv = bcm_field_stat_get32(unit, stat_id, stat, &get_val);
    if (BCM_E_NONE != rv) 
    {
        printf("bcm_field_stat_get32 failed\n");
    }
    printf("\n read packet value %d. From: engine_id %d, command_id %d counter_pointer=%d offset=%d\n",
        get_val, engine_id, command_id, counter_pointer, counter_set_offset);
    if (expect_packets != get_val)
    {
        printf("Error: Expected %d packets, recieved %d packets\n", expect_packets, get_val);
        return BCM_E_FAIL;
    }
    return BCM_E_NONE;
}
	
