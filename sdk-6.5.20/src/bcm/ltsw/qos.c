/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
#include <bcm/types.h>
#include <bcm/error.h>
#include <bcm/qos.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/qos.h>
#include <bcm_int/ltsw/qos_int.h>
#include <bcm_int/ltsw/mbcm/qos.h>

#include <bsl/bsl.h>
#include <sal/sal_types.h>
#include <sal/sal_mutex.h>
#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_QOS

/*!
 * \brief QoS information data structure.
 */
typedef struct qos_info_s {

    /*! QoS module is initialized. */
    bool inited;

    /*! QoS module lock. */
    sal_mutex_t mutex;

} qos_info_t;

/*
 * Static global variable to hold QoS info.
 */
static qos_info_t qos_info[BCM_MAX_NUM_UNITS] = {{0}};

/* QoS info. */
#define QOS_INFO(unit) \
    (&qos_info[unit])

/* Check if QoS module is initialized. */
#define QOS_INIT_CHECK(unit) \
    do { \
        qos_info_t *qos = QOS_INFO(unit); \
        if (qos->inited == false) { \
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT); \
        } \
    } while(0)

/* Take QoS lock. */
#define QOS_LOCK(unit) \
    sal_mutex_take(QOS_INFO(unit)->mutex, SAL_MUTEX_FOREVER)

/* Give QoS lock. */
#define QOS_UNLOCK(unit) \
    sal_mutex_give(QOS_INFO(unit)->mutex)

/******************************************************************************
 * Private functions
 */



/******************************************************************************
 * Public functions
 */

int
bcm_ltsw_qos_detach(int unit)
{
    bool locked = false;
    SHR_FUNC_ENTER(unit);

    /* If not initialized, return success. */
    if (QOS_INFO(unit)->inited == false) {
        SHR_EXIT();
    }

    QOS_INFO(unit)->inited = false;

    QOS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_detach(unit));

    QOS_UNLOCK(unit);
    locked = false;

    if (QOS_INFO(unit)->mutex) {
        sal_mutex_destroy(QOS_INFO(unit)->mutex);
        QOS_INFO(unit)->mutex = NULL;
    }

exit:
    if (locked) {
        QOS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
bcm_ltsw_qos_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (QOS_INFO(unit)->inited) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_qos_detach(unit));
    }

    if (QOS_INFO(unit)->mutex == NULL) {
        QOS_INFO(unit)->mutex = sal_mutex_create("QoS mutex");
        SHR_NULL_CHECK(QOS_INFO(unit)->mutex, SHR_E_MEMORY);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_init(unit));
    QOS_INFO(unit)->inited = true;
exit:
    SHR_FUNC_EXIT();
}

int
bcm_ltsw_qos_map_create(int unit, uint32_t flags, int *map_id)
{
    bool locked = false;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    if (!flags || map_id == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    QOS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_map_create(unit, flags, map_id));
exit:
    if (locked) {
        QOS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
bcm_ltsw_qos_map_destroy(int unit, int map_id)
{
    bool locked = false;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    QOS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_map_destroy(unit, map_id));
exit:
    if (locked) {
        QOS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
bcm_ltsw_qos_map_add(int unit, uint32_t flags, bcm_qos_map_t *map, int map_id)
{
    bool locked = false;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);

    QOS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_map_add(unit, flags, map, map_id));
exit:
    if (locked) {
        QOS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
bcm_ltsw_qos_map_delete(int unit, uint32_t flags, bcm_qos_map_t *map,
                        int map_id)
{
    bool locked = false;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);

    QOS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_map_delete(unit, flags, map, map_id));
exit:
    if (locked) {
        QOS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
bcm_ltsw_qos_map_multi_get(int unit, uint32_t flags, int map_id, int array_size,
                           bcm_qos_map_t *array, int *array_count)
{
    bool locked = false;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    SHR_NULL_CHECK(array_count, SHR_E_PARAM);
    /* Zero means querying the count of map entries. */
    if (array_size != 0) {
        SHR_NULL_CHECK(array, SHR_E_PARAM);
    }

    QOS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_map_multi_get(unit,
                                     flags,
                                     map_id,
                                     array_size,
                                     array,
                                     array_count));
exit:
    if (locked) {
        QOS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
bcm_ltsw_qos_multi_get(int unit, int array_size, int *map_ids_array,
                       int *flags_array, int *array_count)
{
    bool locked = false;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    SHR_NULL_CHECK(array_count, SHR_E_PARAM);
    /* Zero means querying the count of maps. */
    if (array_size != 0) {
        SHR_NULL_CHECK(map_ids_array, SHR_E_PARAM);
        SHR_NULL_CHECK(flags_array, SHR_E_PARAM);
    }

    QOS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_multi_get(unit,
                                 array_size,
                                 map_ids_array,
                                 flags_array,
                                 array_count));
exit:
    if (locked) {
        QOS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
bcm_ltsw_qos_port_map_set(int unit, bcm_gport_t port, int ing_map, int egr_map)
{
    bool locked = false;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    QOS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_port_map_set(unit,
                                    port,
                                    ing_map,
                                    egr_map));
exit:
    if (locked) {
        QOS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
bcm_ltsw_qos_port_map_type_get(int unit, bcm_gport_t port, uint32 flags,
                               int *map_id)
{
    bool locked = false;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    SHR_NULL_CHECK(map_id, SHR_E_PARAM);

    QOS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_port_map_type_get(unit,
                                         port,
                                         flags,
                                         map_id));
exit:
    if (locked) {
        QOS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
bcm_ltsw_qos_port_vlan_map_set(int unit, bcm_port_t port, bcm_vlan_t vid,
                               int ing_map, int egr_map)
{
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_port_vlan_map_set(unit, port, vid, ing_map, egr_map));
exit:
    SHR_FUNC_EXIT();
}

int
bcm_ltsw_qos_port_vlan_map_get(int unit, bcm_port_t port, bcm_vlan_t vid,
                               int *ing_map, int *egr_map)
{
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_port_vlan_map_get(unit, port, vid, ing_map, egr_map));
exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_qos_map_id_resolve(int unit, int map_id,
                             bcmi_ltsw_qos_map_type_t *type, int *ptr)
{
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_map_id_resolve(unit, map_id, type, ptr));
exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_qos_map_id_construct(int unit, int ptr, bcmi_ltsw_qos_map_type_t type,
                               int *map_id)
{
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    SHR_NULL_CHECK(map_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_map_id_construct(unit, ptr, type, map_id));
exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_qos_default_ptr_get(int unit, bcmi_ltsw_qos_map_type_t type, int *ptr)
{
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    SHR_NULL_CHECK(ptr, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_default_ptr_get(unit, type, ptr));
exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_qos_dummy_ptr_get(int unit, bcmi_ltsw_qos_map_type_t type, int *ptr)
{
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    SHR_NULL_CHECK(ptr, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_dummy_ptr_get(unit, type, ptr));
exit:
    SHR_FUNC_EXIT();
}

void
bcmi_ltsw_qos_sw_dump(int unit)
{
    if (!QOS_INFO(unit)->inited) {
        LOG_CLI((BSL_META_U(unit,
                            "\nQoS module isn't initialized: Unit %d\n"),
                            unit));
        return;
    }

    mbcm_ltsw_qos_sw_dump(unit);
}

int
bcmi_ltsw_qos_port_egr_l2_map_set(int unit, bcm_port_t port, int src)
{
    int rv;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);

    QOS_LOCK(unit);
    rv = mbcm_ltsw_qos_port_egr_l2_map_set(unit, port, src);
    QOS_UNLOCK(unit);

    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_qos_port_egr_l2_map_get(int unit, bcm_port_t port, int *src)
{
    int rv;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    SHR_NULL_CHECK(src, SHR_E_PARAM);

    QOS_LOCK(unit);
    rv = mbcm_ltsw_qos_port_egr_l2_map_get(unit, port, src);
    QOS_UNLOCK(unit);

    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_qos_port_attach(int unit, bcm_port_t port)
{
    int rv;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);

    QOS_LOCK(unit);
    rv = mbcm_ltsw_qos_port_attach(unit, port);
    QOS_UNLOCK(unit);

    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_qos_port_detach(int unit, bcm_port_t port)
{
    int rv;
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);

    QOS_LOCK(unit);
    rv = mbcm_ltsw_qos_port_detach(unit, port);
    QOS_UNLOCK(unit);

    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_qos_vxlan_flags_map_ptr_get(int unit, int g_ena, int bum_ena,
                                      int *ptr)
{
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);
    SHR_NULL_CHECK(ptr, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_vxlan_flags_map_ptr_get(unit, g_ena, bum_ena, ptr));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Specify QoS switch control behaviors.
 *
 * \param [in] unit Unit number.
 * \param [in] control The desired configuration parameter to modify.
 * \param [in] value The value with which to set the parameter.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
int
bcmi_ltsw_qos_control_set(
    int unit,
    bcmi_ltsw_qos_control_t control,
    uint32_t value)
{
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);

    QOS_LOCK(unit);
    SHR_IF_ERR_CONT
        (mbcm_ltsw_qos_control_set(unit, control, value));
    QOS_UNLOCK(unit);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve QoS switch control behaviors.
 *
 * \param [in] unit Unit number.
 * \param [in] control The desired configuration parameter to retrieve.
 * \param [out] value Pointer to where the retrieved value will be written.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
int
bcmi_ltsw_qos_control_get(
    int unit,
    bcmi_ltsw_qos_control_t control,
    uint32_t *value)
{
    SHR_FUNC_ENTER(unit);

    QOS_INIT_CHECK(unit);

    SHR_NULL_CHECK(value, SHR_E_PARAM);

    QOS_LOCK(unit);
    SHR_IF_ERR_CONT
        (mbcm_ltsw_qos_control_get(unit, control, value));
    QOS_UNLOCK(unit);

exit:
    SHR_FUNC_EXIT();
}
