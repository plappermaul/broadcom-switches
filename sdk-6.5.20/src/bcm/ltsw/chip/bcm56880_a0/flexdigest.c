/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>

#include <bcm_int/ltsw/mbcm/flexdigest.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/chip/bcmgene_feature.h>
#include <bcm_int/ltsw/chip/bcm56880_a0/bcmgene.h>

#include <shr/shr_debug.h>
#include <shr/shr_bitop.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_FLEXDIGEST

/******************************************************************************
 * Private functions
 */


static bcmgene_desc_t *bcm56880_a0_flexdigest_gene[BCM_MAX_NUM_UNITS];

static uint16_t *bcm56880_a0_fd_action_mask_profile[BCM_MAX_NUM_UNITS];

/*!
 * \brief Allocate a flex digest lookup mask profile identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] mask Flex digest lookup mask.
 * \param [out] mask_profile_id Flex digest lookup mask profile identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_lkup_action_mask_profile_id_alloc(
    int unit,
    uint16_t mask,
    int *mask_profile_id)
{
    uint16_t *mask_profile_table = bcm56880_a0_fd_action_mask_profile[unit];
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_FLEXDIGEST_LKUP_POLICY_MASK;
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;
    int rv;
    int profile_index;
    bool profile_exists = false;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_allocate(unit, ph, &mask, 0, 1,
                                          &profile_index);
    if (rv != SHR_E_EXISTS) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }
    if (rv == SHR_E_EXISTS) {
        profile_exists = true;
    }
    if (!profile_exists) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_targeting(unit, gene,
                                        BCMGENE_FLEXDIGEST_F_LKUP,
                                        BCMGENE_FLEXDIGEST_SUB_F_LKUP_MASK_PROFILE,
                                        &hndl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_handle_create(&hndl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_key(&hndl, 0, profile_index));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_field(&hndl, 0, 0, mask));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_INSERT));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_commit(&hndl));
        mask_profile_table[profile_index] = mask;
    }
    if (mask_profile_id) {
        *mask_profile_id = profile_index;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recycle a flex digest lookup mask profile identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] mask_profile_id Flex digest lookup mask profile identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_lkup_action_mask_profile_id_free(
    int unit,
    int mask_profile_id)
{
    uint16_t *mask_profile_table = bcm56880_a0_fd_action_mask_profile[unit];
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_FLEXDIGEST_LKUP_POLICY_MASK;
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;
    int rv;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_free(unit, ph, mask_profile_id);
    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_targeting(unit, gene,
                                        BCMGENE_FLEXDIGEST_F_LKUP,
                                        BCMGENE_FLEXDIGEST_SUB_F_LKUP_MASK_PROFILE,
                                        &hndl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_handle_create(&hndl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_key(&hndl, 0, mask_profile_id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_DELETE));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_commit(&hndl));

        mask_profile_table[mask_profile_id] = 0;
    } else {
        if (rv != SHR_E_BUSY) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare profile set of flex digest lookup mask profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] entries DLB quality map profile.
 * \param [in] entries_per_set Number of entries in the profile set.
 * \param [in] index Entry index of profile table.
 * \param [out] cmp Result of comparison.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_lkup_action_mask_profile_cmp_cb(
    int unit,
    void *entries,
    int entries_per_set,
    int index,
    int *cmp)
{
    uint16_t *mask_profile_table = bcm56880_a0_fd_action_mask_profile[unit];
    uint16_t mask_profile;

    SHR_FUNC_ENTER(unit);

    if (!mask_profile_table) {
        SHR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

    if (!entries || (entries_per_set != 1) || !cmp) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    mask_profile = *(uint16_t *)entries;

    *cmp = (mask_profile == mask_profile_table[index]) ? 0 : 1;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the flex digest lookup mask profile.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_lkup_action_mask_profile_init(int unit, int warm)
{
    uint16_t *mask_profile_table = bcm56880_a0_fd_action_mask_profile[unit];
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_FLEXDIGEST_LKUP_POLICY_MASK;
    int entry_min, entry_max, entry_cnt;

    SHR_FUNC_ENTER(unit);

    if (bcmi_ltsw_profile_register_check(unit, ph)) {
        SHR_EXIT();
    }

    entry_min = 0;
    entry_max = 31;
    entry_cnt = entry_max - entry_min  + 1;
    if (mask_profile_table == NULL) {
        SHR_ALLOC(mask_profile_table, entry_cnt * sizeof(uint16_t),
                  "bcmFlexDigestLkupActionMaskProfile");
        SHR_NULL_CHECK(mask_profile_table, SHR_E_MEMORY);
        sal_memset(mask_profile_table, 0, entry_cnt * sizeof(uint16_t));
    }
    bcm56880_a0_fd_action_mask_profile[unit] = mask_profile_table;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit, &ph, &entry_min, &entry_max, 1, NULL,
                                    fd_lkup_action_mask_profile_cmp_cb));

    /* Reserve first profile for default value zero. */
    if (warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit, ph, 1, 0, 1));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (fd_lkup_action_mask_profile_id_alloc(unit, 0, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover flex digest lookup mask profile during WarmBoot.
 *
 * \param [in] hndl The GENE handle.
 * \param [in] user_data The user data.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_lkup_action_mask_profile_wb_recover_profile_cb(
    bcmgene_handle_t *hndl,
    void *user_data)
{
    uint16_t *mask_profile_table = (uint16_t *)user_data;
    uint64_t value;
    int mask_profile_id = 0;
    int blk, offset;

    SHR_FUNC_ENTER(hndl ? hndl->unit : BSL_UNIT_UNKNOWN);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_key(hndl, 0, &value));
    mask_profile_id = value;

    blk = 0;
    offset = 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_field(hndl, blk, offset, &value));
    mask_profile_table[mask_profile_id] = value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover flex digest lookup mask profile reference count during WarmBoot.
 *
 * \param [in] hndl The GENE handle.
 * \param [in] user_data The user data.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_lkup_action_mask_profile_wb_recover_profile_ref_count_cb(
    bcmgene_handle_t *hndl,
    void *user_data)
{
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_FLEXDIGEST_LKUP_POLICY_MASK;
    int blk, offset;
    int profile_index, default_zero_profile_index = 0;
    uint32_t i, depth = 0;
    uint64_t *value = NULL;

    SHR_FUNC_ENTER(hndl ? hndl->unit : BSL_UNIT_UNKNOWN);

    blk = 5;
    offset = bcmFlexDigestActionExtractBinSetACmds0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_field_array(hndl, blk, offset,
                                             0, NULL, 0, &depth));
    SHR_ALLOC(value, sizeof(uint64_t) * depth,
              "bcmFlexDigestActionArrayBinSetA");
    SHR_NULL_CHECK(value, SHR_E_MEMORY);
    sal_memset(value, 0, sizeof(uint64_t) * depth);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_field_array(hndl, blk, offset,
                                             0, value, depth, &depth));
    for (i = 0; i < depth; i++) {
        profile_index = value[i];
        if (profile_index == default_zero_profile_index) {
            continue;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(hndl->unit, ph, 1,
                                                  profile_index, 1));
    }
    SHR_FREE(value);

    blk = 7;
    offset = bcmFlexDigestActionExtractBinSetBCmds0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_field_array(hndl, blk, offset,
                                             0, NULL, 0, &depth));
    SHR_ALLOC(value, sizeof(uint64_t) * depth,
              "bcmFlexDigestActionArrayBinSetB");
    SHR_NULL_CHECK(value, SHR_E_MEMORY);
    sal_memset(value, 0, sizeof(uint64_t) * depth);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_field_array(hndl, blk, offset,
                                             0, value, depth, &depth));
    for (i = 0; i < depth; i++) {
        profile_index = value[i];
        if (profile_index == default_zero_profile_index) {
            continue;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(hndl->unit, ph, 1,
                                                  profile_index, 1));
    }
    SHR_FREE(value);

exit:
    if (SHR_FUNC_ERR()) {
        SHR_FREE(value);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover flex digest lookup mask profile during WarmBoot.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_lkup_action_mask_profile_wb_recover(int unit)
{
    uint16_t *mask_profile_table = bcm56880_a0_fd_action_mask_profile[unit];
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_LKUP,
                                    BCMGENE_FLEXDIGEST_SUB_F_LKUP_MASK_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_callback(&hndl,
            fd_lkup_action_mask_profile_wb_recover_profile_cb));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_traverse(&hndl, mask_profile_table));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_callback(&hndl, NULL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_LKUP,
                                    BCMGENE_FLEXDIGEST_SUB_F_LKUP_POLICY,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_callback(&hndl,
            fd_lkup_action_mask_profile_wb_recover_profile_ref_count_cb));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_traverse(&hndl, NULL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_callback(&hndl, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-initialize the flex digest lookup mask profile.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_lkup_action_mask_profile_deinit(int unit)
{
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_FLEXDIGEST_LKUP_POLICY_MASK;

    SHR_FUNC_ENTER(unit);

    if (!bcmi_ltsw_profile_register_check(unit, ph)) {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_unregister(unit, ph));

    SHR_FREE(bcm56880_a0_fd_action_mask_profile[unit]);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief validate the action.
 *
 * \param [in] unit Unit Number.
 * \param [in] action The entry action.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_lkup_action_validate(
    int unit,
    bcm_flexdigest_action_t action)
{
    SHR_FUNC_ENTER(unit);

    switch (action) {
    case bcmFlexDigestActionExtractBinSetACmds0:
    case bcmFlexDigestActionExtractBinSetACmds1:
    case bcmFlexDigestActionExtractBinSetACmds2:
    case bcmFlexDigestActionExtractBinSetACmds3:
    case bcmFlexDigestActionExtractBinSetACmds4:
    case bcmFlexDigestActionExtractBinSetACmds5:
    case bcmFlexDigestActionExtractBinSetACmds6:
    case bcmFlexDigestActionExtractBinSetACmds7:
    case bcmFlexDigestActionExtractBinSetACmds8:
    case bcmFlexDigestActionExtractBinSetACmds9:
    case bcmFlexDigestActionExtractBinSetACmds10:
    case bcmFlexDigestActionExtractBinSetACmds11:
    case bcmFlexDigestActionExtractBinSetACmds12:
    case bcmFlexDigestActionExtractBinSetACmds13:
    case bcmFlexDigestActionExtractBinSetACmds14:
    case bcmFlexDigestActionExtractBinSetACmds15:
    case bcmFlexDigestActionExtractBinSetBCmds0:
    case bcmFlexDigestActionExtractBinSetBCmds1:
    case bcmFlexDigestActionExtractBinSetBCmds2:
    case bcmFlexDigestActionExtractBinSetBCmds3:
    case bcmFlexDigestActionExtractBinSetBCmds4:
    case bcmFlexDigestActionExtractBinSetBCmds5:
    case bcmFlexDigestActionExtractBinSetBCmds6:
    case bcmFlexDigestActionExtractBinSetBCmds7:
    case bcmFlexDigestActionExtractBinSetBCmds8:
    case bcmFlexDigestActionExtractBinSetBCmds9:
    case bcmFlexDigestActionExtractBinSetBCmds10:
    case bcmFlexDigestActionExtractBinSetBCmds11:
    case bcmFlexDigestActionExtractBinSetBCmds12:
    case bcmFlexDigestActionExtractBinSetBCmds13:
    case bcmFlexDigestActionExtractBinSetBCmds14:
    case bcmFlexDigestActionExtractBinSetBCmds15:
    case bcmFlexDigestActionExtractBinSetCCmds0:
    case bcmFlexDigestActionExtractBinSetCCmds1:
    case bcmFlexDigestActionExtractBinSetCCmds2:
    case bcmFlexDigestActionExtractBinSetCCmds3:
    case bcmFlexDigestActionExtractBinSetCCmds4:
    case bcmFlexDigestActionExtractBinSetCCmds5:
    case bcmFlexDigestActionExtractBinSetCCmds6:
    case bcmFlexDigestActionExtractBinSetCCmds7:
    case bcmFlexDigestActionExtractBinSetCCmds8:
    case bcmFlexDigestActionExtractBinSetCCmds9:
    case bcmFlexDigestActionExtractBinSetCCmds10:
    case bcmFlexDigestActionExtractBinSetCCmds11:
    case bcmFlexDigestActionExtractBinSetCCmds12:
    case bcmFlexDigestActionExtractBinSetCCmds13:
    case bcmFlexDigestActionExtractBinSetCCmds14:
    case bcmFlexDigestActionExtractBinSetCCmds15:
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief validate the action configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] action The entry action.
 * \param [in] param0 The entry action parameter 0.
 * \param [in] param1 The entry action parameter 1.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_lkup_action_check(
    int unit,
    bcm_flexdigest_action_t action,
    uint16_t param0,
    uint16_t param1)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;
    int blk, offset;
    int idx;
    int action_base;

    SHR_FUNC_ENTER(unit);

    if (!gene) {
        SHR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (fd_lkup_action_validate(unit, action));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_LKUP,
                                    BCMGENE_FLEXDIGEST_SUB_F_LKUP_POLICY,
                                    &hndl));

    switch (action) {
    case bcmFlexDigestActionExtractBinSetACmds0:
    case bcmFlexDigestActionExtractBinSetACmds1:
    case bcmFlexDigestActionExtractBinSetACmds2:
    case bcmFlexDigestActionExtractBinSetACmds3:
    case bcmFlexDigestActionExtractBinSetACmds4:
    case bcmFlexDigestActionExtractBinSetACmds5:
    case bcmFlexDigestActionExtractBinSetACmds6:
    case bcmFlexDigestActionExtractBinSetACmds7:
    case bcmFlexDigestActionExtractBinSetACmds8:
    case bcmFlexDigestActionExtractBinSetACmds9:
    case bcmFlexDigestActionExtractBinSetACmds10:
    case bcmFlexDigestActionExtractBinSetACmds11:
    case bcmFlexDigestActionExtractBinSetACmds12:
    case bcmFlexDigestActionExtractBinSetACmds13:
    case bcmFlexDigestActionExtractBinSetACmds14:
    case bcmFlexDigestActionExtractBinSetACmds15:
        action_base = bcmFlexDigestActionExtractBinSetACmds0;
        idx = action - action_base;
        if (param0 == 0) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        blk = 4;
        offset = action_base;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_validate_field_array(&hndl,
                                                   blk, offset, idx, param0));
        break;
    case bcmFlexDigestActionExtractBinSetBCmds0:
    case bcmFlexDigestActionExtractBinSetBCmds1:
    case bcmFlexDigestActionExtractBinSetBCmds2:
    case bcmFlexDigestActionExtractBinSetBCmds3:
    case bcmFlexDigestActionExtractBinSetBCmds4:
    case bcmFlexDigestActionExtractBinSetBCmds5:
    case bcmFlexDigestActionExtractBinSetBCmds6:
    case bcmFlexDigestActionExtractBinSetBCmds7:
    case bcmFlexDigestActionExtractBinSetBCmds8:
    case bcmFlexDigestActionExtractBinSetBCmds9:
    case bcmFlexDigestActionExtractBinSetBCmds10:
    case bcmFlexDigestActionExtractBinSetBCmds11:
    case bcmFlexDigestActionExtractBinSetBCmds12:
    case bcmFlexDigestActionExtractBinSetBCmds13:
    case bcmFlexDigestActionExtractBinSetBCmds14:
    case bcmFlexDigestActionExtractBinSetBCmds15:
        action_base = bcmFlexDigestActionExtractBinSetBCmds0;
        idx = action - action_base;
        if (param0 == 0) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        blk = 6;
        offset = action_base;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_validate_field_array(&hndl,
                                                   blk, offset, idx, param0));
        break;
    case bcmFlexDigestActionExtractBinSetCCmds0:
    case bcmFlexDigestActionExtractBinSetCCmds1:
    case bcmFlexDigestActionExtractBinSetCCmds2:
    case bcmFlexDigestActionExtractBinSetCCmds3:
    case bcmFlexDigestActionExtractBinSetCCmds4:
    case bcmFlexDigestActionExtractBinSetCCmds5:
    case bcmFlexDigestActionExtractBinSetCCmds6:
    case bcmFlexDigestActionExtractBinSetCCmds7:
    case bcmFlexDigestActionExtractBinSetCCmds8:
    case bcmFlexDigestActionExtractBinSetCCmds9:
    case bcmFlexDigestActionExtractBinSetCCmds10:
    case bcmFlexDigestActionExtractBinSetCCmds11:
    case bcmFlexDigestActionExtractBinSetCCmds12:
    case bcmFlexDigestActionExtractBinSetCCmds13:
    case bcmFlexDigestActionExtractBinSetCCmds14:
    case bcmFlexDigestActionExtractBinSetCCmds15:
        action_base = bcmFlexDigestActionExtractBinSetCCmds0;
        idx = action - action_base;
        blk = 8;
        offset = action_base;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_validate_tag(&hndl, blk, offset));
        if (param0 & ~1u) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        if (param1 & ~1u) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief The callback function for adding flexdigest action.
 *
 * \param [in] hndl The GENE handle.
 * \param [in] user_data The user data.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_lkup_action_add_cb(
    bcmgene_handle_t *hndl,
    void *user_data)
{
    int rv;
    int param0, idx;
    uint64_t value = 0;
    bcmgene_field_data_t *fd = (bcmgene_field_data_t *)user_data;
    bcmgene_field_desc_t *fld = NULL;

    SHR_FUNC_ENTER(hndl ? hndl->unit : BSL_UNIT_UNKNOWN);
    SHR_NULL_CHECK(fd, SHR_E_PARAM);

    fld = fd->fld;
    param0 = COMPILER_64_HI(fd->value[0]);
    idx = COMPILER_64_LO(fd->value[0]);
    rv = bcmlt_entry_field_get(hndl->handle, fld->field, &value);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }
    if (param0) {
        value &= ~(0x1 << idx);
    } else {
        value |=  (0x1 << idx);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(hndl->handle, fld->field, value));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover software information during WarmBoot.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_init_wb_recover(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (fd_lkup_action_mask_profile_wb_recover(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear flex digest module LT tables.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
fd_init_clear_hw(int unit)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_clear(unit, gene));

exit:
    SHR_FUNC_EXIT();
}


static int
bcm56880_a0_ltsw_flexdigest_db_init(
    int unit,
    int warm)
{
    bcmgene_desc_t *gene = NULL;

    SHR_FUNC_ENTER(unit);

    gene = bcm56880_a0_gene_extractor(unit, "FlexDigest");

    if (!gene) {
        SHR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

    bcm56880_a0_flexdigest_gene[unit] = gene;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_db_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (fd_lkup_action_mask_profile_deinit(unit));

    if (bcm56880_a0_flexdigest_gene[unit]) {
        bcm56880_a0_flexdigest_gene[unit] = NULL;
    }
    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_init(
    int unit,
    int warm)
{
    SHR_FUNC_ENTER(unit);

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (fd_init_clear_hw(unit));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (fd_lkup_action_mask_profile_init(unit, warm));

    if (warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (fd_init_wb_recover(unit));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_feature_get(
    int unit,
    uint32_t functionality,
    uint32_t *features)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_sub_feature_get(unit, gene, functionality, features));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_info_get(
    int unit,
    bcmint_flexdigest_info_t info,
    int *value)
{
    uint64_t min, max;
    int num_of_entries, num_of_group;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(value, SHR_E_PARAM);

    switch (info) {
    case bcmiFlexDigestInfoNormSeedProfileIdCount:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, FLEX_DIGEST_NORM_PROFILE_SEEDs,
                                           FLEX_DIGEST_NORM_PROFILE_SEED_IDs,
                                           &min, &max));
        *value = max - min + 1;
        break;
    case bcmiFlexDigestInfoNormProfileIdCount:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, FLEX_DIGEST_NORM_PROFILEs,
                                           FLEX_DIGEST_NORM_PROFILE_IDs,
                                           &min, &max));
        *value = max - min + 1;
        break;
    case bcmiFlexDigestInfoHashProfileIdCount:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, FLEX_DIGEST_HASH_PROFILEs,
                                           FLEX_DIGEST_HASH_PROFILE_IDs,
                                           &min, &max));
        *value = max - min + 1;
        break;
    case bcmiFlexDigestInfoNumGroups:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, FLEX_DIGEST_LKUPs,
                                           GROUP_PRIORITYs,
                                           &min, &max));
        *value = max - min + 1;
        break;
    case bcmiFlexDigestInfoNumMatchIds:
    case bcmiFlexDigestInfoNumEntries:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, FLEX_DIGEST_LKUPs,
                                           GROUP_PRIORITYs,
                                           &min, &max));
        num_of_group = max - min + 1;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, FLEX_DIGEST_LKUPs,
                                           FLEX_DIGEST_LKUP_IDs,
                                           &min, &max));
        num_of_entries = max - min + 1;
        *value = num_of_group * num_of_entries;
        break;
    case bcmiFlexDigestInfoGroupPrioMax:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, FLEX_DIGEST_LKUPs,
                                           GROUP_PRIORITYs,
                                           &min, &max));
        *value = max & 0xffffffff;
        break;
    case bcmiFlexDigestInfoEntryPrioMax:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, FLEX_DIGEST_LKUPs,
                                           ENTRY_PRIORITYs,
                                           &min, &max));
        *value = max & 0xffffffff;
        break;
    case bcmiFlexDigestInfoQualifierMaxPerEntry:
        *value = 19;
        break;
    case bcmiFlexDigestInfoActionMaxPerEntry:
        *value = 48;
        break;
    case bcmiFlexDigestInfoMatchWidth:
        *value = 48;
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_validate_lkup_match(
    int unit,
    bcm_flexdigest_match_t match)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    if (!gene) {
        SHR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_LKUP,
                                    BCMGENE_FLEXDIGEST_SUB_F_LKUP_MATCH_ID,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_validate_tag(&hndl, 1, match));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_validate_lkup_match_conflict(
    int unit,
    bcm_flexdigest_match_t new_match,
    bcm_flexdigest_match_t old_match)
{
    SHR_FUNC_ENTER(unit);

    SHR_EXIT();
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_validate_lkup_action(
    int unit,
    bcm_flexdigest_action_t action)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (fd_lkup_action_validate(unit, action));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_validate_lkup_action_params(
    int unit,
    bcm_flexdigest_action_t action,
    uint16_t param0,
    uint16_t param1)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (fd_lkup_action_check(unit, action, param0, param1));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_validate_lkup_qualifier(
    int unit,
    bcm_flexdigest_qualify_t qualifier,
    uint16_t data,
    uint16_t mask)
{
    SHR_FUNC_ENTER(unit);

    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_validate_lkup_group_qset(
    int unit,
    bcm_flexdigest_qset_t qset)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;
    int i;

    SHR_FUNC_ENTER(unit);

    if (!gene) {
        SHR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_LKUP,
                                    BCMGENE_FLEXDIGEST_SUB_F_LKUP_PRESEL,
                                    &hndl));
    for (i = 0; i < bcmFlexDigestQualifyCount; i++) {
        if (BCM_FLEXDIGEST_QSET_TEST(qset, i)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56880_a0_gene_validate_tag(&hndl, 0, i));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_validate_hash_profile(
    int unit,
    int hash_profile_id,
    bcm_flexdigest_hash_profile_control_t type,
    int value)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
    case bcmFlexDigestHashProfileControlPreProcessBinA:
    case bcmFlexDigestHashProfileControlPreProcessBinB:
    case bcmFlexDigestHashProfileControlPreProcessBinC:
    case bcmFlexDigestHashProfileControlXorSaltBinA:
    case bcmFlexDigestHashProfileControlXorSaltBinB:
    case bcmFlexDigestHashProfileControlXorSaltBinC:
        if (value < 0 || value > 1) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        break;
    case bcmFlexDigestHashProfileControlBinA0FunctionSelection:
    case bcmFlexDigestHashProfileControlBinA1FunctionSelection:
    case bcmFlexDigestHashProfileControlBinB0FunctionSelection:
    case bcmFlexDigestHashProfileControlBinB1FunctionSelection:
    case bcmFlexDigestHashProfileControlBinC0FunctionSelection:
    case bcmFlexDigestHashProfileControlBinC1FunctionSelection:
        if (value < 0 ||
            value > BCM_FLEXDIGEST_HASH_FUNCTION_KOOPMAN_HI) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_norm_seed_profile_create(
    int unit,
    int seed_profile_id)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_NORM,
                                    BCMGENE_FLEXDIGEST_SUB_F_NORM_SEED_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, seed_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_INSERT));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_norm_seed_profile_destroy(
    int unit,
    int seed_profile_id)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_NORM,
                                    BCMGENE_FLEXDIGEST_SUB_F_NORM_SEED_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, seed_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_DELETE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_norm_seed_profile_set(
    int unit,
    int seed_profile_id,
    bcm_flexdigest_norm_seed_control_t type,
    int value)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_NORM,
                                    BCMGENE_FLEXDIGEST_SUB_F_NORM_SEED_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, seed_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_field(&hndl, 0, type, value & 0xffffffff));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_UPDATE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_norm_seed_profile_get(
    int unit,
    int seed_profile_id,
    bcm_flexdigest_norm_seed_control_t type,
    int *value)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;
    uint64_t value_tmp;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_NORM,
                                    BCMGENE_FLEXDIGEST_SUB_F_NORM_SEED_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, seed_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_field(&hndl, 0, type, &value_tmp));

    *value = value_tmp & 0xffffffff;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_done(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_norm_seed_profile_configured(
    int unit,
    int seed_profile_id)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_NORM,
                                    BCMGENE_FLEXDIGEST_SUB_F_NORM_SEED_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, seed_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_done(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_norm_profile_create(
    int unit,
    int norm_profile_id)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_NORM,
                                    BCMGENE_FLEXDIGEST_SUB_F_NORM_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, norm_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_INSERT));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_norm_profile_destroy(
    int unit,
    int norm_profile_id)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_NORM,
                                    BCMGENE_FLEXDIGEST_SUB_F_NORM_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, norm_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_DELETE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_norm_profile_set(
    int unit,
    int norm_profile_id,
    bcm_flexdigest_norm_profile_control_t type,
    int value)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_NORM,
                                    BCMGENE_FLEXDIGEST_SUB_F_NORM_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, norm_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_field(&hndl, 0, type, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_UPDATE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_norm_profile_get(
    int unit,
    int norm_profile_id,
    bcm_flexdigest_norm_profile_control_t type,
    int *value)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;
    uint64_t value_tmp;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_NORM,
                                    BCMGENE_FLEXDIGEST_SUB_F_NORM_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, norm_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_field(&hndl, 0, type, &value_tmp));

    *value = value_tmp;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_done(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_norm_profile_configured(
    int unit,
    int norm_profile_id)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_NORM,
                                    BCMGENE_FLEXDIGEST_SUB_F_NORM_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, norm_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_done(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_allocate(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t *hndl = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_ALLOC(hndl, sizeof(bcmgene_handle_t), "bcmGeneHandle");
    if (!hndl) {
        SHR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }
    sal_memset(hndl, 0, sizeof(bcmgene_handle_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_LKUP,
                                    BCMGENE_FLEXDIGEST_SUB_F_LKUP_ENTRY,
                                    hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(hndl, 0, einfo->id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(hndl, 1, einfo->group_prio));

    einfo->handle = hndl;

exit:
    if (SHR_FUNC_ERR()) {
        SHR_FREE(hndl);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_free(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo)
{
    bcmgene_handle_t *hndl = NULL;

    SHR_FUNC_ENTER(unit);

    hndl = (bcmgene_handle_t *)einfo->handle;
    if (hndl) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_handle_destroy(hndl));
        SHR_FREE(hndl);
        einfo->handle = NULL;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_pri_set(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo,
    int prio)
{
    bcmgene_handle_t *hndl = NULL;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    hndl = (bcmgene_handle_t *)einfo->handle;

    SHR_NULL_CHECK(hndl, SHR_E_INTERNAL);

    value = prio;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_field(hndl, 0, 0, value));
    LOG_DEBUG(BSL_LOG_MODULE,
            (BSL_META_U(unit,
                        "FD(unit %d) Priority set: %"PRIu64"\n"),
             unit, value));

exit:
    if (SHR_FUNC_ERR()) {
        (void)bcm56880_a0_ltsw_flexdigest_lkup_entry_free(unit, einfo);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_match_add(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo,
    bcm_flexdigest_match_t match)
{
    bcmgene_handle_t *hndl = NULL;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    hndl = (bcmgene_handle_t *)einfo->handle;

    SHR_NULL_CHECK(hndl, SHR_E_INTERNAL);

    value = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_field(hndl, 1, match, value));
    LOG_DEBUG(BSL_LOG_MODULE,
            (BSL_META_U(unit,
                        "FD(unit %d) MatchId add: %"PRIu64"\n"),
             unit, value));

exit:
    if (SHR_FUNC_ERR()) {
        (void)bcm56880_a0_ltsw_flexdigest_lkup_entry_free(unit, einfo);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_qualifier_add(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo,
    bcm_flexdigest_qualify_t qualifier,
    uint16_t data,
    uint16_t mask)
{
    bcmgene_handle_t *hndl = NULL;
    int blk, offset;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    hndl = (bcmgene_handle_t *)einfo->handle;

    SHR_NULL_CHECK(hndl, SHR_E_INTERNAL);

    blk = 2;
    offset = qualifier;
    value = data;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_field(hndl, 2, offset, value));
    LOG_DEBUG(BSL_LOG_MODULE,
            (BSL_META_U(unit,
                        "FD(unit %d) Qualifier [%"PRId32",%"PRId32"] "
                        "add data: %"PRIu64"\n"),
             unit, blk, offset, value));
    blk = 3;
    offset = qualifier;
    value = mask;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_field(hndl, blk, offset, value));
    LOG_DEBUG(BSL_LOG_MODULE,
            (BSL_META_U(unit,
                        "FD(unit %d) Qualifier [%"PRId32",%"PRId32"] "
                        "add mask: %"PRIu64"\n"),
             unit, blk, offset, value));

exit:
    if (SHR_FUNC_ERR()) {
        (void)bcm56880_a0_ltsw_flexdigest_lkup_entry_free(unit, einfo);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_action_add(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo,
    bcm_flexdigest_action_t action,
    uint16_t param0,
    uint16_t param1)
{
    bcmgene_handle_t *hndl = NULL;
    uint64_t value;
    int blk, offset;
    int idx, mask_profile_id;
    int action_base;

    SHR_FUNC_ENTER(unit);

    hndl = (bcmgene_handle_t *)einfo->handle;

    SHR_NULL_CHECK(hndl, SHR_E_INTERNAL);

    switch (action) {
    case bcmFlexDigestActionExtractBinSetACmds0:
    case bcmFlexDigestActionExtractBinSetACmds1:
    case bcmFlexDigestActionExtractBinSetACmds2:
    case bcmFlexDigestActionExtractBinSetACmds3:
    case bcmFlexDigestActionExtractBinSetACmds4:
    case bcmFlexDigestActionExtractBinSetACmds5:
    case bcmFlexDigestActionExtractBinSetACmds6:
    case bcmFlexDigestActionExtractBinSetACmds7:
    case bcmFlexDigestActionExtractBinSetACmds8:
    case bcmFlexDigestActionExtractBinSetACmds9:
    case bcmFlexDigestActionExtractBinSetACmds10:
    case bcmFlexDigestActionExtractBinSetACmds11:
    case bcmFlexDigestActionExtractBinSetACmds12:
    case bcmFlexDigestActionExtractBinSetACmds13:
    case bcmFlexDigestActionExtractBinSetACmds14:
    case bcmFlexDigestActionExtractBinSetACmds15:
        action_base = bcmFlexDigestActionExtractBinSetACmds0;
        idx = action - action_base;

        blk = 4;
        offset = action_base;
        value = param0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_field_array(hndl, blk, offset,
                                               idx, &value, 1));
        LOG_DEBUG(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                            "FD(unit %d) Action %"PRId32" data add: "
                            "[%"PRId32"]->%"PRIu64"\n"),
                 unit, blk, idx, value));

        SHR_IF_ERR_VERBOSE_EXIT
            (fd_lkup_action_mask_profile_id_alloc(unit, param1,
                                                  &mask_profile_id));
        blk = 5;
        offset = action_base;
        value = mask_profile_id;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_field_array(hndl, blk, offset,
                                               idx, &value, 1));
        LOG_DEBUG(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                            "FD(unit %d) Action %"PRId32" mask add: "
                            "[%"PRId32"]->%"PRIu64"\n"),
                 unit, blk, idx, value));

        break;
    case bcmFlexDigestActionExtractBinSetBCmds0:
    case bcmFlexDigestActionExtractBinSetBCmds1:
    case bcmFlexDigestActionExtractBinSetBCmds2:
    case bcmFlexDigestActionExtractBinSetBCmds3:
    case bcmFlexDigestActionExtractBinSetBCmds4:
    case bcmFlexDigestActionExtractBinSetBCmds5:
    case bcmFlexDigestActionExtractBinSetBCmds6:
    case bcmFlexDigestActionExtractBinSetBCmds7:
    case bcmFlexDigestActionExtractBinSetBCmds8:
    case bcmFlexDigestActionExtractBinSetBCmds9:
    case bcmFlexDigestActionExtractBinSetBCmds10:
    case bcmFlexDigestActionExtractBinSetBCmds11:
    case bcmFlexDigestActionExtractBinSetBCmds12:
    case bcmFlexDigestActionExtractBinSetBCmds13:
    case bcmFlexDigestActionExtractBinSetBCmds14:
    case bcmFlexDigestActionExtractBinSetBCmds15:
        action_base = bcmFlexDigestActionExtractBinSetBCmds0;
        idx = action - action_base;

        blk = 6;
        offset = action_base;
        value = param0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_field_array(hndl, blk, offset,
                                               idx, &value, 1));
        LOG_DEBUG(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                            "FD(unit %d) Action %"PRId32" data add: "
                            "[%"PRId32"]->%"PRIu64"\n"),
                 unit, blk, idx, value));

        SHR_IF_ERR_VERBOSE_EXIT
            (fd_lkup_action_mask_profile_id_alloc(unit, param1,
                                                  &mask_profile_id));
        blk = 7;
        offset = action_base;
        value = mask_profile_id;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_field_array(hndl, blk, offset,
                                               idx, &value, 1));
        LOG_DEBUG(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                            "FD(unit %d) Action %"PRId32" mask add: "
                            "[%"PRId32"]->%"PRIu64"\n"),
                 unit, blk, idx, value));
        break;
    case bcmFlexDigestActionExtractBinSetCCmds0:
    case bcmFlexDigestActionExtractBinSetCCmds1:
    case bcmFlexDigestActionExtractBinSetCCmds2:
    case bcmFlexDigestActionExtractBinSetCCmds3:
    case bcmFlexDigestActionExtractBinSetCCmds4:
    case bcmFlexDigestActionExtractBinSetCCmds5:
    case bcmFlexDigestActionExtractBinSetCCmds6:
    case bcmFlexDigestActionExtractBinSetCCmds7:
    case bcmFlexDigestActionExtractBinSetCCmds8:
    case bcmFlexDigestActionExtractBinSetCCmds9:
    case bcmFlexDigestActionExtractBinSetCCmds10:
    case bcmFlexDigestActionExtractBinSetCCmds11:
    case bcmFlexDigestActionExtractBinSetCCmds12:
    case bcmFlexDigestActionExtractBinSetCCmds13:
    case bcmFlexDigestActionExtractBinSetCCmds14:
    case bcmFlexDigestActionExtractBinSetCCmds15:
        action_base = bcmFlexDigestActionExtractBinSetCCmds0;
        idx = action - action_base;
        param0 = param0 & param1;
        param0 = param0 & 0x1;
        blk = 8;
        offset = action_base;

        COMPILER_64_SET(value, param0, idx);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_callback(hndl, fd_lkup_action_add_cb));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_flags(hndl, BCMGENE_F_HANDLE_CALLBACK));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_field(hndl, blk, offset, value));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_flags(hndl, 0));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56880_a0_gene_fill_callback(hndl, NULL));
        LOG_DEBUG(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                            "FD(unit %d) Action [%"PRId32",%"PRId32"] add: "
                            "param0 %"PRId32"-> param1 %"PRId32"\n"),
                 unit, blk, offset, param0, param1));
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    if (SHR_FUNC_ERR()) {
        (void)bcm56880_a0_ltsw_flexdigest_lkup_entry_free(unit, einfo);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_mask_profile_restore(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo)
{
    bcmgene_handle_t *hndl = NULL;
    int blk, offset;
    int idx, mask_profile_id;
    uint64_t value;
    bcm_flexdigest_action_t action;
    uint32_t count = 0;
    int action_base;


    SHR_FUNC_ENTER(unit);

    hndl = (bcmgene_handle_t *)einfo->handle;

    SHR_NULL_CHECK(hndl, SHR_E_INTERNAL);

    for (action = 0; action < bcmFlexDigestActionCount; action++) {
        switch (action) {
        case bcmFlexDigestActionExtractBinSetACmds0:
        case bcmFlexDigestActionExtractBinSetACmds1:
        case bcmFlexDigestActionExtractBinSetACmds2:
        case bcmFlexDigestActionExtractBinSetACmds3:
        case bcmFlexDigestActionExtractBinSetACmds4:
        case bcmFlexDigestActionExtractBinSetACmds5:
        case bcmFlexDigestActionExtractBinSetACmds6:
        case bcmFlexDigestActionExtractBinSetACmds7:
        case bcmFlexDigestActionExtractBinSetACmds8:
        case bcmFlexDigestActionExtractBinSetACmds9:
        case bcmFlexDigestActionExtractBinSetACmds10:
        case bcmFlexDigestActionExtractBinSetACmds11:
        case bcmFlexDigestActionExtractBinSetACmds12:
        case bcmFlexDigestActionExtractBinSetACmds13:
        case bcmFlexDigestActionExtractBinSetACmds14:
        case bcmFlexDigestActionExtractBinSetACmds15:
            action_base = bcmFlexDigestActionExtractBinSetACmds0;
            idx = action - action_base;
            blk = 5;
            offset = action_base;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56880_a0_gene_lookup_field_array(hndl, blk, offset,
                                                     idx, &value, 1, &count));
            mask_profile_id = value;
            if (mask_profile_id == 0) {
                break;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (fd_lkup_action_mask_profile_id_free(unit,
                                                     mask_profile_id));
            break;
        case bcmFlexDigestActionExtractBinSetBCmds0:
        case bcmFlexDigestActionExtractBinSetBCmds1:
        case bcmFlexDigestActionExtractBinSetBCmds2:
        case bcmFlexDigestActionExtractBinSetBCmds3:
        case bcmFlexDigestActionExtractBinSetBCmds4:
        case bcmFlexDigestActionExtractBinSetBCmds5:
        case bcmFlexDigestActionExtractBinSetBCmds6:
        case bcmFlexDigestActionExtractBinSetBCmds7:
        case bcmFlexDigestActionExtractBinSetBCmds8:
        case bcmFlexDigestActionExtractBinSetBCmds9:
        case bcmFlexDigestActionExtractBinSetBCmds10:
        case bcmFlexDigestActionExtractBinSetBCmds11:
        case bcmFlexDigestActionExtractBinSetBCmds12:
        case bcmFlexDigestActionExtractBinSetBCmds13:
        case bcmFlexDigestActionExtractBinSetBCmds14:
        case bcmFlexDigestActionExtractBinSetBCmds15:
            action_base = bcmFlexDigestActionExtractBinSetBCmds0;
            idx = action - action_base;
            blk = 7;
            offset = action_base;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56880_a0_gene_lookup_field_array(hndl, blk, offset,
                                                     idx, &value, 1, &count));
            mask_profile_id = value;
            if (mask_profile_id == 0) {
                break;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (fd_lkup_action_mask_profile_id_free(unit,
                                                     mask_profile_id));
            break;
        default:
            break;
        }
    }

exit:
    if (SHR_FUNC_ERR()) {
        (void)bcm56880_a0_ltsw_flexdigest_lkup_entry_free(unit, einfo);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_insert(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo)
{
    bcmgene_handle_t *hndl = NULL;

    SHR_FUNC_ENTER(unit);

    hndl = (bcmgene_handle_t *)einfo->handle;

    SHR_NULL_CHECK(hndl, SHR_E_INTERNAL);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(hndl, BCMLT_OPCODE_INSERT));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(hndl));

exit:
    (void)bcm56880_a0_ltsw_flexdigest_lkup_entry_free(unit, einfo);
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_update(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo)
{
    bcmgene_handle_t *hndl = NULL;

    SHR_FUNC_ENTER(unit);

    hndl = (bcmgene_handle_t *)einfo->handle;

    SHR_NULL_CHECK(hndl, SHR_E_INTERNAL);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(hndl, BCMLT_OPCODE_UPDATE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(hndl));

exit:
    (void)bcm56880_a0_ltsw_flexdigest_lkup_entry_free(unit, einfo);
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_lookup(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo)
{
    bcmgene_handle_t *hndl = NULL;

    SHR_FUNC_ENTER(unit);

    hndl = (bcmgene_handle_t *)einfo->handle;

    SHR_NULL_CHECK(hndl, SHR_E_INTERNAL);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup(hndl));

exit:
    if (SHR_FUNC_ERR()) {
        (void)bcm56880_a0_ltsw_flexdigest_lkup_entry_free(unit, einfo);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_delete(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo)
{
    bcmgene_handle_t *hndl = NULL;

    SHR_FUNC_ENTER(unit);

    hndl = (bcmgene_handle_t *)einfo->handle;

    SHR_NULL_CHECK(hndl, SHR_E_INTERNAL);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(hndl, BCMLT_OPCODE_DELETE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(hndl));

exit:
    (void)bcm56880_a0_ltsw_flexdigest_lkup_entry_free(unit, einfo);
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_entry_unset(
    int unit,
    bcmint_flexdigest_entry_info_t *einfo)
{
    bcmgene_handle_t *hndl = NULL;

    SHR_FUNC_ENTER(unit);

    hndl = (bcmgene_handle_t *)einfo->handle;

    SHR_NULL_CHECK(hndl, SHR_E_INTERNAL);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_unset(hndl));

exit:
    if (SHR_FUNC_ERR()) {
        (void)bcm56880_a0_ltsw_flexdigest_lkup_entry_free(unit, einfo);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_lkup_group_update_presel(
    int unit,
    bcm_flexdigest_qset_t qset)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;
    int i;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_LKUP,
                                    BCMGENE_FLEXDIGEST_SUB_F_LKUP_PRESEL,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    for (i = 0; i < bcmFlexDigestQualifyCount; i++) {
        if (BCM_FLEXDIGEST_QSET_TEST(qset, i)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56880_a0_gene_fill_field(&hndl, 0, i, 1));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56880_a0_gene_fill_flags(&hndl, BCMGENE_F_HANDLE_GRACEFUL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56880_a0_gene_fill_field(&hndl, 0, i, 0));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_edit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_hash_profile_create(
    int unit,
    int hash_profile_id)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_HASH,
                                    BCMGENE_FLEXDIGEST_SUB_F_HASH_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, hash_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_INSERT));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_hash_profile_destroy(
    int unit,
    int hash_profile_id)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_HASH,
                                    BCMGENE_FLEXDIGEST_SUB_F_HASH_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, hash_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_DELETE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_hash_profile_set(
    int unit,
    int hash_profile_id,
    bcm_flexdigest_hash_profile_control_t type,
    int value)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_HASH,
                                    BCMGENE_FLEXDIGEST_SUB_F_HASH_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, hash_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_field(&hndl, 0, type, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_UPDATE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_commit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_hash_profile_get(
    int unit,
    int hash_profile_id,
    bcm_flexdigest_hash_profile_control_t type,
    int *value)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;
    uint64_t value_tmp;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_HASH,
                                    BCMGENE_FLEXDIGEST_SUB_F_HASH_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, hash_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_field(&hndl, 0, type, &value_tmp));

    *value = value_tmp;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_done(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_hash_profile_configured(
    int unit,
    int hash_profile_id)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_HASH,
                                    BCMGENE_FLEXDIGEST_SUB_F_HASH_PROFILE,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_key(&hndl, 0, hash_profile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_done(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_hash_salt_set(
    int unit,
    bcm_flexdigest_hash_bin_set_t bin_set,
    int array_size,
    uint16_t *salt_array)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;
    int i;
    uint64_t *value = NULL;

    SHR_FUNC_ENTER(unit);

    if (array_size > 0) {
        SHR_ALLOC(value, sizeof(uint64_t) * array_size, "bcmGeneValueArray");
        SHR_NULL_CHECK(value, SHR_E_MEMORY);
        sal_memset(value, 0, sizeof(uint64_t) * array_size);
    }
    for (i = 0; i < array_size; i++) {
        value[i] = salt_array[i];
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_HASH,
                                    BCMGENE_FLEXDIGEST_SUB_F_HASH_SALT,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_fill_field_array(&hndl, 0, bin_set,
                                           0, value, array_size));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_edit(&hndl));

exit:
    if (value) {
        SHR_FREE(value);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_flexdigest_hash_salt_get(
    int unit,
    bcm_flexdigest_hash_bin_set_t bin_set,
    int array_size,
    uint16_t *salt_array,
    int *count)
{
    bcmgene_desc_t *gene = bcm56880_a0_flexdigest_gene[unit];
    bcmgene_handle_t hndl;
    int i;
    uint64_t *value = NULL;
    uint32_t depth = 0;

    SHR_FUNC_ENTER(unit);

    if (array_size > 0) {
        SHR_ALLOC(value, sizeof(uint64_t) * array_size, "bcmGeneValueArray");
        SHR_NULL_CHECK(value, SHR_E_MEMORY);
        sal_memset(value, 0, sizeof(uint64_t) * array_size);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_FLEXDIGEST_F_HASH,
                                    BCMGENE_FLEXDIGEST_SUB_F_HASH_SALT,
                                    &hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup(&hndl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_field_array(&hndl, 0, bin_set,
                                             0, value, array_size,
                                             &depth));
    for (i = 0; i < array_size; i++) {
        salt_array[i] = value[i];
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_gene_lookup_done(&hndl));

    *count = depth;

exit:
    if (value) {
        SHR_FREE(value);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Flexdigest driver function variable for bcm56880_a0 device.
 */
static mbcm_ltsw_flexdigest_drv_t bcm56880_a0_ltsw_flexdigest_drv = {
    .flexdigest_db_init = bcm56880_a0_ltsw_flexdigest_db_init,
    .flexdigest_db_deinit = bcm56880_a0_ltsw_flexdigest_db_deinit,
    .flexdigest_init = bcm56880_a0_ltsw_flexdigest_init,
    .flexdigest_deinit = bcm56880_a0_ltsw_flexdigest_deinit,
    .flexdigest_feature_get = bcm56880_a0_ltsw_flexdigest_feature_get,
    .flexdigest_info_get = bcm56880_a0_ltsw_flexdigest_info_get,
    .flexdigest_validate_lkup_match = bcm56880_a0_ltsw_flexdigest_validate_lkup_match,
    .flexdigest_validate_lkup_match_conflict = bcm56880_a0_ltsw_flexdigest_validate_lkup_match_conflict,
    .flexdigest_validate_lkup_action = bcm56880_a0_ltsw_flexdigest_validate_lkup_action,
    .flexdigest_validate_lkup_action_params = bcm56880_a0_ltsw_flexdigest_validate_lkup_action_params,
    .flexdigest_validate_lkup_qualifier = bcm56880_a0_ltsw_flexdigest_validate_lkup_qualifier,
    .flexdigest_validate_lkup_group_qset = bcm56880_a0_ltsw_flexdigest_validate_lkup_group_qset,
    .flexdigest_validate_hash_profile = bcm56880_a0_ltsw_flexdigest_validate_hash_profile,
    .flexdigest_norm_seed_profile_create = bcm56880_a0_ltsw_flexdigest_norm_seed_profile_create,
    .flexdigest_norm_seed_profile_destroy = bcm56880_a0_ltsw_flexdigest_norm_seed_profile_destroy,
    .flexdigest_norm_seed_profile_set = bcm56880_a0_ltsw_flexdigest_norm_seed_profile_set,
    .flexdigest_norm_seed_profile_get = bcm56880_a0_ltsw_flexdigest_norm_seed_profile_get,
    .flexdigest_norm_seed_profile_configured = bcm56880_a0_ltsw_flexdigest_norm_seed_profile_configured,
    .flexdigest_norm_profile_create = bcm56880_a0_ltsw_flexdigest_norm_profile_create,
    .flexdigest_norm_profile_destroy = bcm56880_a0_ltsw_flexdigest_norm_profile_destroy,
    .flexdigest_norm_profile_set = bcm56880_a0_ltsw_flexdigest_norm_profile_set,
    .flexdigest_norm_profile_get = bcm56880_a0_ltsw_flexdigest_norm_profile_get,
    .flexdigest_norm_profile_configured = bcm56880_a0_ltsw_flexdigest_norm_profile_configured,
    .flexdigest_lkup_entry_allocate = bcm56880_a0_ltsw_flexdigest_lkup_entry_allocate,
    .flexdigest_lkup_entry_free = bcm56880_a0_ltsw_flexdigest_lkup_entry_free,
    .flexdigest_lkup_entry_pri_set = bcm56880_a0_ltsw_flexdigest_lkup_entry_pri_set,
    .flexdigest_lkup_entry_match_add = bcm56880_a0_ltsw_flexdigest_lkup_entry_match_add,
    .flexdigest_lkup_entry_qualifier_add = bcm56880_a0_ltsw_flexdigest_lkup_entry_qualifier_add,
    .flexdigest_lkup_entry_action_add = bcm56880_a0_ltsw_flexdigest_lkup_entry_action_add,
    .flexdigest_lkup_entry_mask_profile_restore = bcm56880_a0_ltsw_flexdigest_lkup_entry_mask_profile_restore,
    .flexdigest_lkup_entry_insert = bcm56880_a0_ltsw_flexdigest_lkup_entry_insert,
    .flexdigest_lkup_entry_update = bcm56880_a0_ltsw_flexdigest_lkup_entry_update,
    .flexdigest_lkup_entry_lookup = bcm56880_a0_ltsw_flexdigest_lkup_entry_lookup,
    .flexdigest_lkup_entry_delete = bcm56880_a0_ltsw_flexdigest_lkup_entry_delete,
    .flexdigest_lkup_entry_unset = bcm56880_a0_ltsw_flexdigest_lkup_entry_unset,
    .flexdigest_lkup_group_update_presel = bcm56880_a0_ltsw_flexdigest_lkup_group_update_presel,
    .flexdigest_hash_profile_create = bcm56880_a0_ltsw_flexdigest_hash_profile_create,
    .flexdigest_hash_profile_destroy = bcm56880_a0_ltsw_flexdigest_hash_profile_destroy,
    .flexdigest_hash_profile_set = bcm56880_a0_ltsw_flexdigest_hash_profile_set,
    .flexdigest_hash_profile_get = bcm56880_a0_ltsw_flexdigest_hash_profile_get,
    .flexdigest_hash_profile_configured = bcm56880_a0_ltsw_flexdigest_hash_profile_configured,
    .flexdigest_hash_salt_set = bcm56880_a0_ltsw_flexdigest_hash_salt_set,
    .flexdigest_hash_salt_get = bcm56880_a0_ltsw_flexdigest_hash_salt_get
};

/******************************************************************************
 * Public functions
 */

int
bcm56880_a0_ltsw_flexdigest_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexdigest_drv_set(unit, &bcm56880_a0_ltsw_flexdigest_drv));

exit:
    SHR_FUNC_EXIT();
}

