/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/mbcm/l3_aacl.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/chip/bcmgene_feature.h>
#include <bcm_int/ltsw/chip/bcm56880_a0/bcmgene.h>

#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_L3

/******************************************************************************
 * Private functions
 */


static bcmgene_desc_t *bcm56880_a0_l3_aacl_gene[BCM_MAX_NUM_UNITS];

/*!
 * \brief Initialize L3 AACL database.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l3_aacl_db_init(int unit)
{
    bcmgene_desc_t *gene = NULL;

    SHR_FUNC_ENTER(unit);

    gene = bcm56880_a0_gene_extractor(unit, "AACL");

    if (!gene) {
        SHR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

    bcm56880_a0_l3_aacl_gene[unit] = gene;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Deinit L3 AACL database.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l3_aacl_db_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (bcm56880_a0_l3_aacl_gene[unit]) {
        bcm56880_a0_l3_aacl_gene[unit] = NULL;
    }
    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear L3 AACL LT tables.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
l3_aacl_clear_hw(int unit)
{
    bcmgene_desc_t *gene = bcm56880_a0_l3_aacl_gene[unit];

    SHR_FUNC_ENTER(unit);

    if (gene) {
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_clear(unit, gene));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief sub-function for initializing L3 AACL.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l3_aacl_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (l3_aacl_db_init(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief sub-function for deinit L3 AACL.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l3_aacl_deinit(int unit)
{
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    if (!warm) {
        SHR_IF_ERR_EXIT
            (l3_aacl_clear_hw(unit));
    }

    SHR_IF_ERR_EXIT
        (l3_aacl_db_deinit(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sub-feature by AACL flags.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags AACL flags. See BCM_L3_AACL_FLAGS_xxx.
 * \param [out] sub_f Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l3_aacl_sub_f_get(int unit, uint32_t flags, uint32_t *sub_f)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(sub_f, SHR_E_INTERNAL);

    if (flags & BCM_L3_AACL_FLAGS_IP6) {
        if (flags & BCM_L3_AACL_FLAGS_IP_SRC) {
            *sub_f = BCMGENE_L3_AACL_SUB_F_IPv6_SRC;
        } else {
            *sub_f = BCMGENE_L3_AACL_SUB_F_IPv6_DST;
        }
    } else {
        if (flags & BCM_L3_AACL_FLAGS_IP_SRC) {
            *sub_f = BCMGENE_L3_AACL_SUB_F_IPv4_SRC;
        } else {
            *sub_f = BCMGENE_L3_AACL_SUB_F_IPv4_DST;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get AACL flags by sub-feature.
 *
 * \param [in] unit Unit Number.
 * \param [in] sub_f Unit Number.
 * \param [out] flags AACL flags. See BCM_L3_AACL_FLAGS_xxx.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l3_aacl_flags_get(int unit, uint32_t sub_f, uint32_t *flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(flags, SHR_E_INTERNAL);

    *flags = 0;

    if (sub_f == BCMGENE_L3_AACL_SUB_F_IPv4_SRC) {
        *flags |= BCM_L3_AACL_FLAGS_IP_SRC;
    } else if (sub_f == BCMGENE_L3_AACL_SUB_F_IPv6_DST) {
        *flags |= BCM_L3_AACL_FLAGS_IP6;
    } else if (sub_f == BCMGENE_L3_AACL_SUB_F_IPv6_SRC) {
        *flags |= BCM_L3_AACL_FLAGS_IP6;
        *flags |= BCM_L3_AACL_FLAGS_IP_SRC;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validation for L3 AACL feature.
 *
 * \param [in] unit Unit Number.
 * \param [in] aacl Pointer to bcm_l3_aacl_t struct which contains fields related to compression table.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_INIT No initialization.
 * \retval SHR_E_UNAVAIL Feature not supported.
 */
static int
l3_aacl_validate(int unit, bcm_l3_aacl_t *aacl)
{
    bcmgene_desc_t *gene = bcm56880_a0_l3_aacl_gene[unit];
    uint32_t sub_f;
    uint64_t value;
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(gene, SHR_E_UNAVAIL);
    SHR_NULL_CHECK(aacl, SHR_E_PARAM);

    SHR_IF_ERR_EXIT
        (l3_aacl_sub_f_get(unit, aacl->flags, &sub_f));

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_L3_AACL_F_COMPRESSION_VALIDATE,
                                    sub_f, &hndl));
    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_lookup(&hndl));
    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_lookup_field(&hndl, 0, 0, &value));

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_lookup_done(&hndl));

    if (value) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else {
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Fill L3 AACL keys into Gene handler.
 *
 * \param [in] hndl The Gene handle.
 * \param [in] aacl Pointer to bcm_l3_aacl_t struct which contains fields related to compression table.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l3_aacl_fill_key(
    bcmgene_handle_t *hndl,
    bcm_l3_aacl_t *aacl)
{
    int index = 0, unit = hndl->unit;
    uint64_t ip6[2], ip6_mask[2], value;
    uint8_t ip6_zero[BCM_IP6_ADDRLEN] = {0};

    SHR_FUNC_ENTER(unit);

    if (aacl->flags & BCM_L3_AACL_FLAGS_IP6) {
        if (!bcmi_ltsw_property_get(unit, BCMI_CPN_IPV6_LPM_128B_ENABLE, 1) &&
            (bcm_ip6_mask_length(aacl->ip6_mask) > 64)) {
            SHR_IF_ERR_EXIT
                (bcm56880_a0_gene_error_return(hndl, SHR_E_RESOURCE));
        }
        if (bcm_ip6_mask_length(aacl->ip6_mask) == 0 &&
            sal_memcmp(aacl->ip6, ip6_zero, BCM_IP6_ADDRLEN) != 0) {
            SHR_IF_ERR_EXIT
                (bcm56880_a0_gene_error_return(hndl, SHR_E_PARAM));
        }

        bcmi_ltsw_util_ip6_to_uint64(ip6, &aacl->ip6);
        bcmi_ltsw_util_ip6_to_uint64(ip6_mask, &aacl->ip6_mask);
        value = ip6[0] & ip6_mask[0];
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_fill_key(hndl, index++, value));
        value = ip6_mask[0];
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_fill_key(hndl, index++, value));
        value = ip6[1] & ip6_mask[1];
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_fill_key(hndl, index++, value));
        value = ip6_mask[1];
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_fill_key(hndl, index++, value));
    } else {
        value = aacl->ip & aacl->ip_mask;
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_fill_key(hndl, index++, value));
        value = aacl->ip_mask;
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_fill_key(hndl, index++, value));
    }
    if (aacl->l4_port_mask) {
        value = aacl->l4_port & aacl->l4_port_mask;
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_fill_key(hndl, index++, value));
        value = aacl->l4_port_mask;
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_fill_key(hndl, index++, value));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief L3 AACL traverse call back function.
 *
 * \param [in] hndl The Gene handle.
 * \param [in] user_data User data.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l3_aacl_traverse_cb(
    bcmgene_handle_t *hndl,
    void *user_data)
{
    int index = 0;
    uint64_t ip6[2], ip6_mask[2], value;
    uint32_t flags;
    bcm_l3_aacl_t aacl;
    struct {
        bcm_l3_aacl_traverse_cb trav_fn;
        void *user_data;
    } *ud = user_data;

    SHR_FUNC_ENTER(hndl ? hndl->unit : BSL_UNIT_UNKNOWN);

    SHR_NULL_CHECK(ud, SHR_E_INTERNAL);

    if (ud->trav_fn) {
        sal_memset(&aacl, 0, sizeof(aacl));
        SHR_IF_ERR_EXIT
            (l3_aacl_flags_get(hndl->unit, hndl->tbl->sub_f, &flags));

        if (flags & BCM_L3_AACL_FLAGS_IP6) {
            SHR_IF_ERR_EXIT
                (bcm56880_a0_gene_lookup_key(hndl, index++, &ip6[0]));
            SHR_IF_ERR_EXIT
                (bcm56880_a0_gene_lookup_key(hndl, index++, &ip6_mask[0]));
            SHR_IF_ERR_EXIT
                (bcm56880_a0_gene_lookup_key(hndl, index++, &ip6[1]));
            SHR_IF_ERR_EXIT
                (bcm56880_a0_gene_lookup_key(hndl, index++, &ip6_mask[1]));
            bcmi_ltsw_util_uint64_to_ip6(&(aacl.ip6), ip6);
            bcmi_ltsw_util_uint64_to_ip6(&(aacl.ip6_mask), ip6_mask);
        } else {
            SHR_IF_ERR_EXIT
                (bcm56880_a0_gene_lookup_key(hndl, index++, &value));
            aacl.ip = value & 0xffffffff;
            SHR_IF_ERR_EXIT
                (bcm56880_a0_gene_lookup_key(hndl, index++, &value));
            aacl.ip_mask = value & 0xffffffff;
        }
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_lookup_key(hndl, index++, &value));
        aacl.l4_port = value & 0xffffffff;
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_lookup_key(hndl, index++, &value));
        aacl.l4_port_mask = value & 0xffffffff;
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_lookup_field(hndl, 0, 0, &value));
        aacl.class_id = value & 0xffffffff;

        aacl.flags = flags;
        SHR_IF_ERR_EXIT
            (ud->trav_fn(hndl->unit, &aacl, ud->user_data));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief L3 AACL traverse function.
 *
 * \param [in] hndl The Gene handle.
 * \param [in] user_data User data.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l3_aacl_traverse(
    bcmgene_handle_t *hndl,
    void *user_data)
{
    SHR_FUNC_ENTER(hndl ? hndl->unit : BSL_UNIT_UNKNOWN);

    SHR_NULL_CHECK(user_data, SHR_E_INTERNAL);

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_fill_callback(hndl, l3_aacl_traverse_cb));
    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_traverse(hndl, user_data));

exit:
    SHR_FUNC_EXIT();
}


static int
bcm56880_a0_ltsw_l3_aacl_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (l3_aacl_init(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l3_aacl_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (l3_aacl_deinit(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l3_aacl_validate(
    int unit,
    bcm_l3_aacl_t *aacl,
    bool strict)
{
    SHR_FUNC_ENTER(unit);

    if (aacl && strict) {
        SHR_IF_ERR_EXIT
            (l3_aacl_validate(unit, aacl));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l3_aacl_add(
    int unit,
    uint32_t options,
    bcm_l3_aacl_t *aacl)
{
    bcmgene_desc_t *gene = bcm56880_a0_l3_aacl_gene[unit];
    uint32_t sub_f;
    int opcode;
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(gene, SHR_E_UNAVAIL);
    SHR_NULL_CHECK(aacl, SHR_E_PARAM);

    SHR_IF_ERR_EXIT
        (l3_aacl_sub_f_get(unit, aacl->flags, &sub_f));

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_L3_AACL_F_COMPRESSION, sub_f,
                                    &hndl));
    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));

    SHR_IF_ERR_EXIT
        (l3_aacl_fill_key(&hndl, aacl));

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_fill_field(&hndl, 0, 0, aacl->class_id));

    if (options & BCM_L3_AACL_OPTIONS_REPLACE) {
        opcode = BCMLT_OPCODE_UPDATE;
    } else {
        opcode = BCMLT_OPCODE_INSERT;
    }
    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_fill_opcode(&hndl, opcode));
    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_commit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l3_aacl_delete(
    int unit,
    bcm_l3_aacl_t *aacl)
{
    bcmgene_desc_t *gene = bcm56880_a0_l3_aacl_gene[unit];
    uint32_t sub_f;
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(gene, SHR_E_UNAVAIL);
    SHR_NULL_CHECK(aacl, SHR_E_PARAM);

    SHR_IF_ERR_EXIT
        (l3_aacl_sub_f_get(unit, aacl->flags, &sub_f));

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_L3_AACL_F_COMPRESSION, sub_f,
                                    &hndl));
    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));

    SHR_IF_ERR_EXIT
        (l3_aacl_fill_key(&hndl, aacl));

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_fill_opcode(&hndl, BCMLT_OPCODE_DELETE));
    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_commit(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l3_aacl_delete_all(
    int unit,
    bcm_l3_aacl_t *aacl)
{
    bcmgene_desc_t *gene = bcm56880_a0_l3_aacl_gene[unit];
    uint32_t sub_f;
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(gene, SHR_E_UNAVAIL);

    if (aacl == NULL) {
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_clear(unit, gene));
    } else {
        SHR_IF_ERR_EXIT
            (l3_aacl_sub_f_get(unit, aacl->flags, &sub_f));

        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_targeting(unit, gene,
                                        BCMGENE_L3_AACL_F_COMPRESSION, sub_f,
                                        &hndl));
        SHR_IF_ERR_EXIT
            (bcm56880_a0_gene_clear_handle(&hndl));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l3_aacl_find(
    int unit,
    bcm_l3_aacl_t *aacl)
{
    bcmgene_desc_t *gene = bcm56880_a0_l3_aacl_gene[unit];
    uint32_t sub_f;
    uint64_t value;
    bcmgene_handle_t hndl;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(gene, SHR_E_UNAVAIL);
    SHR_NULL_CHECK(aacl, SHR_E_PARAM);

    SHR_IF_ERR_EXIT
        (l3_aacl_sub_f_get(unit, aacl->flags, &sub_f));

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_L3_AACL_F_COMPRESSION, sub_f,
                                    &hndl));
    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_handle_create(&hndl));

    SHR_IF_ERR_EXIT
        (l3_aacl_fill_key(&hndl, aacl));

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_lookup(&hndl));
    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_lookup_field(&hndl, 0, 0, &value));

    aacl->class_id = value & 0xffffffff;

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_lookup_done(&hndl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l3_aacl_traverse(
    int unit,
    bcm_l3_aacl_traverse_cb trav_fn,
    void *user_data)
{
    bcmgene_desc_t *gene = bcm56880_a0_l3_aacl_gene[unit];
    struct {
        bcm_l3_aacl_traverse_cb trav_fn;
        void *user_data;
    } ud;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(gene, SHR_E_UNAVAIL);

    ud.trav_fn = trav_fn;
    ud.user_data = user_data;

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_func_traverse(unit, gene,
                                        BCMGENE_L3_AACL_F_COMPRESSION,
                                        l3_aacl_traverse, &ud));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l3_aacl_matched_traverse(
    int unit,
    uint32_t flags,
    bcm_l3_aacl_traverse_cb trav_fn,
    void *user_data)
{
    bcmgene_desc_t *gene = bcm56880_a0_l3_aacl_gene[unit];
    uint32_t sub_f;
    bcmgene_handle_t hndl;
    struct {
        bcm_l3_aacl_traverse_cb trav_fn;
        void *user_data;
    } ud;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(gene, SHR_E_UNAVAIL);

    ud.trav_fn = trav_fn;
    ud.user_data = user_data;

    SHR_IF_ERR_EXIT
        (l3_aacl_sub_f_get(unit, flags, &sub_f));

    SHR_IF_ERR_EXIT
        (bcm56880_a0_gene_targeting(unit, gene,
                                    BCMGENE_L3_AACL_F_COMPRESSION,
                                    sub_f,
                                    &hndl));
    SHR_IF_ERR_EXIT
        (l3_aacl_traverse(&hndl, &ud));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief L3_aacl driver function variable for bcm56880_a0 device.
 */
static mbcm_ltsw_l3_aacl_drv_t bcm56880_a0_ltsw_l3_aacl_drv = {
    .l3_aacl_init = bcm56880_a0_ltsw_l3_aacl_init,
    .l3_aacl_deinit = bcm56880_a0_ltsw_l3_aacl_deinit,
    .l3_aacl_validate = bcm56880_a0_ltsw_l3_aacl_validate,
    .l3_aacl_add = bcm56880_a0_ltsw_l3_aacl_add,
    .l3_aacl_delete = bcm56880_a0_ltsw_l3_aacl_delete,
    .l3_aacl_delete_all = bcm56880_a0_ltsw_l3_aacl_delete_all,
    .l3_aacl_find = bcm56880_a0_ltsw_l3_aacl_find,
    .l3_aacl_traverse = bcm56880_a0_ltsw_l3_aacl_traverse,
    .l3_aacl_matched_traverse = bcm56880_a0_ltsw_l3_aacl_matched_traverse
};

/******************************************************************************
 * Public functions
 */

int
bcm56880_a0_ltsw_l3_aacl_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_l3_aacl_drv_set(unit, &bcm56880_a0_ltsw_l3_aacl_drv));

exit:
    SHR_FUNC_EXIT();
}

