/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/flexctr.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/mbcm/l2.h>
#include <bcm_int/ltsw/xfs/l2.h>
#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/flexctr.h>
#include <bcm_int/ltsw/chip/bcm56880_a0/variant_dispatch.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_L2

/******************************************************************************
 * Private functions
 */

static int
bcm56880_a0_ltsw_l2_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_init(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_detach(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_addr_add(
    int unit,
    bcm_l2_addr_t *l2addr)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_add(unit, l2addr));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_addr_get(
    int unit,
    bcm_mac_t mac,
    bcm_vlan_t vid,
    bcm_l2_addr_t *l2addr)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_get(unit, mac, vid, l2addr));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_addr_delete(
    int unit,
    bcm_mac_t mac,
    bcm_vlan_t vid)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_delete(unit, mac, vid));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_addr_replace(
    int unit,
    bcmint_l2_replace_t *rep_st)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_replace(unit, rep_st));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_addr_traverse(
    int unit,
    bcm_l2_traverse_cb trav_fn,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_traverse(unit, trav_fn, user_data));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_addr_del_by_tuple(
    int unit,
    bcmint_l2_tuple_ctrl_t *tuple_ctrl)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_addr_del_by_tuple(unit, tuple_ctrl));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_station_size_get(
    int unit,
    uint32_t *tbl_sz)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_station_size_get(unit, tbl_sz));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_age(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_age(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_station_add(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_station_add(unit, station, flags));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_station_get(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_station_get(unit, station, flags));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_station_delete(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_station_delete(unit, station, flags));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_force_vlan_set(
    int unit,
    bcm_port_t port,
    bcm_vlan_t vlan,
    uint32_t flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_force_vlan_set(unit, port, vlan, flags));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_learn_set(
    int unit,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_learn_set(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_learn_get(
    int unit,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_learn_get(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_station_vlan_update(
    int unit,
    int vid,
    int flags,
    bcmi_ltsw_l2_station_vlan_t *vlan_info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_station_vlan_update(unit, vid, flags, vlan_info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_size_get(
    int unit,
    int *size)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_size_get(unit, size));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_count_get(
    int unit,
    int *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_count_get(unit, count));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_view_vlan_update(
    int unit,
    bcmi_ltsw_l2_view_vlan_info_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_view_vlan_update(unit, info));

exit:
    SHR_FUNC_EXIT();
}

static void
bcm56880_a0_ltsw_l2_sw_dump(int unit)
{
    xfs_ltsw_l2_sw_dump(unit);
}

static int
bcm56880_a0_ltsw_l2_virtual_info_update(
    int unit,
    bcmi_ltsw_l2_virtual_info_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_l2_virtual_info_update(unit, info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_hitbit_detach(
    int unit,
    bcmint_l2_flexctr_info_t *info)
{
    uint32_t counter_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    bcmi_ltsw_flexctr_hit_ctrl_t ctrl;
    bcmi_ltsw_flexctr_mode_t mode = bcmiFlexctrModeGlobal;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(info, SHR_E_PARAM);

    sal_memset(&ctrl, 0, sizeof(bcmi_ltsw_flexctr_hit_ctrl_t));
    ctrl.stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
    ctrl.tbl_name = L2_HOST_TABLEs;
    ctrl.dst_grp_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    ctrl.src_grp_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_mode_get(unit, 0, &mode));
    if (mode == bcmiFlexctrModePipeUnique) {
        ctrl.global = true;
    }

    /* Delete CTR_ING_EFLEX_HITBIT_CONTROL LT. */
    (void)bcmi_ltsw_flexctr_hit_control_update(unit, &ctrl);

    ctrl.tbl_name = L2_HOST_NARROW_TABLEs;
    (void)bcmi_ltsw_flexctr_hit_control_update(unit, &ctrl);

    /* Destroy flexctr group action first. */
    counter_id = info->dst_grp_id;
    if (counter_id != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
        /*
         * Skip error since flexctr action might be destroyed during
         * flexctr deinit.
         */
        (void)bcm_ltsw_flexctr_group_action_destroy(unit, counter_id);
        info->dst_grp_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }

    counter_id = info->src_grp_id;
    if (counter_id != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
        (void)bcm_ltsw_flexctr_group_action_destroy(unit, counter_id);
        info->src_grp_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }

    /* Destroy flexctr actions. */
    counter_id = info->uft_dst_id;
    if (counter_id != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
        (void)bcm_ltsw_flexctr_action_destroy(unit, counter_id);
        info->uft_dst_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }

    counter_id = info->uft_src_id;
    if (counter_id != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
        (void)bcm_ltsw_flexctr_action_destroy(unit, counter_id);
        info->uft_src_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }

    counter_id = info->dst_id;
    if (counter_id != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
        (void)bcm_ltsw_flexctr_action_destroy(unit, counter_id);
        info->dst_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }

    counter_id = info->src_id;
    if (counter_id != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
        (void)bcm_ltsw_flexctr_action_destroy(unit, counter_id);
        info->src_id = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_l2_hitbit_init(
    int unit,
    bcmint_l2_flexctr_info_t *info)
{
    bcm_flexctr_action_t action = {0};
    bcm_flexctr_index_operation_t *index_op = NULL;
    bcm_flexctr_value_operation_t *value_a_op = NULL;
    bcm_flexctr_trigger_t *trigger = NULL;
    uint32_t uft_dst_id, dst_id, uft_src_id, src_id;
    uint32_t dst_grp_id, src_grp_id;
    bcm_flexctr_group_action_t grp_action = {0};
    int options = 0;
    bcmi_ltsw_flexctr_hit_ctrl_t ctrl;
    bcmint_l2_flexctr_info_t *flexctr_info = NULL;
    bcmi_ltsw_flexctr_mode_t mode = bcmiFlexctrModeGlobal;

    SHR_FUNC_ENTER(unit);

    flexctr_info = info;
    SHR_NULL_CHECK(flexctr_info, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_mode_get(unit, 0, &mode));

    /* UFT dest hit action. */
    action.flags |= BCM_FLEXCTR_ACTION_FLAGS_TRIGGER;
    action.source = bcmiFlexctrSourceL2Dst;
    action.hint = 0;
    action.mode = bcmFlexctrCounterModeWide;
    action.drop_count_mode = bcmFlexctrDropCountModeAll;
    action.index_num = 16384; /* 2 pools * 8K counters. */
    if (mode == bcmiFlexctrModePipeUnique) {
        /* Need to create a global action in pipe unique mode. */
        action.flags |= BCM_FLEXCTR_ACTION_FLAGS_GLOBAL;
    }

    /* UFT_HIT_INDEX [23:19]+[15:6]. */
    /*
     * The UFT_HIT_INDEX format:
     *      [1:0] ENTRY_NUMBER_ETILE Entry index in Bucket.
     *            Used when TABLE_ID is IFTA90_E2T_##_B#.
     *      [15:2] BUCKET_NUMBER_ETILE Bucket index in Table ID.
     *             Used when TABLE_ID is IFTA90_E2T_##_B#.
     *      [18:16] Reserved.
     *      [23:19] TABLE_ID Table ID, unique in vertical column.
     *              Encodings are:
     *                  0 = IFTA90_E2T_00_B0.
     *                  1 = IFTA90_E2T_00_B1.
     *                  2 = IFTA90_E2T_01_B0.
     *                  3 = IFTA90_E2T_01_B1.
     *                  4 = IFTA90_E2T_02_B0.
     *                  5 = IFTA90_E2T_02_B1.
     *                  6 = IFTA90_E2T_03_B0.
     *                  7 = IFTA90_E2T_03_B1.
     *                  ...
     *
     * The UFT_HIT_INDEX is carried by two 16-bit objects on the pipeline
     * bus, and they are jointed to a flex ctr index for flex ctr SF.
     * The joint formulation:
     *      Obj0 = UFT_HIT_INDEX[15:0].
     *      Index[0] = ((Obj0 >> 6) & ((1 << 10)-1)).
     *      Obj1 = UFT_HIT_INDEX[31:16].
     *      Index[1] = (Obj1 & ((1 << 8)-1)) << 7.
     *      Index = Index[1] | Index[0].
     * The reason why we left-shift Index[1] by 7 is UFT_HIT_INDEX[18:16] are
     * reserved and useless for flex ctr, so it will be overrided by upper bits
     * of Index[0].
     */
    index_op = &action.index_operation;
    index_op->object[0] = bcmFlexctrObjectIngL2DstLookupHitIndex0;
    index_op->mask_size[0] = 10;
    index_op->shift[0] = 6;
    index_op->object[1] = bcmFlexctrObjectIngL2DstLookupHitIndex1;
    index_op->mask_size[1] = 8;
    index_op->shift[1] = 7;

    /* UFT_HIT_INDEX [5:0]. */
    /*
     * One flex ctr entry has 64 bits, so we select the lower 6 bits of
     * UFT_HIT_INDEX to locate which bit of the entry should be updated.
     * Flex counter update value would be generated as below:
     *      Obj0 = UFT_HIT_INDEX[15:0].
     *      Value0 = (Obj0 >> 0) & ((1 << 6) - 1)).
     *      Value1 = (0 & ((1 << 1) - 1)) << 0 = 0.
     *      Value = (Value1 | Value0) = Value0.
     *      New_counter = UPDATE_TYPE(old_counter, Value). UPDATE_TYPE is set bit.
     */
    value_a_op = &action.operation_a;
    value_a_op->select = bcmFlexctrValueSelectCounterValue;
    value_a_op->object[0] = bcmFlexctrObjectIngL2DstLookupHitIndex0;
    value_a_op->mask_size[0] = 6;
    value_a_op->shift[0] = 0;
    value_a_op->object[1] = bcmFlexctrObjectConstZero;
    value_a_op->mask_size[1] = 1;
    value_a_op->shift[1] = 0;
    value_a_op->type = bcmFlexctrValueOperationTypeSetBit;

    /* UFT trigger UFT_HIT_INDEX [24:24]. */
    /*
     * Bit 24 of UFT_HIT_INDEX is used for flex ctr trigger.
     *      Obj0 = UFT_HIT_INDEX [31:16].
     *      Trigger = ((Obj0 & object_value_mask) == object_value_start).
     *      Non-trigger = ((Obj0 & object_value_mask) == object_value_stop).
     */
    trigger = &action.trigger;
    trigger->trigger_type = bcmFlexctrTriggerTypeCondition;
    trigger->object = bcmFlexctrObjectIngL2DstLookupHitIndex1;
    trigger->object_value_start = 0x100;
    trigger->object_value_stop = 0x0;
    trigger->object_value_mask = 0x100;

    options = BCMI_LTSW_FLEXCTR_OPTIONS_INTERNAL;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_action_create(unit, options, &action, &uft_dst_id));
    flexctr_info->uft_dst_id = uft_dst_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_trigger_enable_set(unit, uft_dst_id, TRUE));

    /* UFT src hit action. */
    action.flags |= BCM_FLEXCTR_ACTION_FLAGS_TRIGGER;
    action.source = bcmiFlexctrSourceL2Src;
    action.hint = 0;
    action.mode = bcmFlexctrCounterModeWide;
    action.drop_count_mode = bcmFlexctrDropCountModeAll;
    action.index_num = 16384; /* 2 pools * 8K counters. */
    if (mode == bcmiFlexctrModePipeUnique) {
        /* Need to create a global action in pipe unique mode. */
        action.flags |= BCM_FLEXCTR_ACTION_FLAGS_GLOBAL;
    }

    /* UFT_HIT_INDEX [23:19]+[15:6]. */
    index_op = &action.index_operation;
    index_op->object[0] = bcmFlexctrObjectIngL2SrcLookupHitIndex0;
    index_op->mask_size[0] = 10;
    index_op->shift[0] = 6;
    index_op->object[1] = bcmFlexctrObjectIngL2SrcLookupHitIndex1;
    index_op->mask_size[1] = 8;
    index_op->shift[1] = 7;

    /* UFT_HIT_INDEX [5:0]. */
    value_a_op = &action.operation_a;
    value_a_op->select = bcmFlexctrValueSelectCounterValue;
    value_a_op->object[0] = bcmFlexctrObjectIngL2SrcLookupHitIndex0;
    value_a_op->mask_size[0] = 6;
    value_a_op->shift[0] = 0;
    value_a_op->object[1] = bcmFlexctrObjectConstZero;
    value_a_op->mask_size[1] = 1;
    value_a_op->shift[1] = 0;
    value_a_op->type = bcmFlexctrValueOperationTypeSetBit;

    /* UFT trigger UFT_HIT_INDEX [24:24]. */
    trigger = &action.trigger;
    trigger->trigger_type = bcmFlexctrTriggerTypeCondition;
    trigger->object = bcmFlexctrObjectIngL2SrcLookupHitIndex1;
    trigger->object_value_start = 0x100;
    trigger->object_value_stop = 0;
    trigger->object_value_mask = 0x100;

    /* Src hit action must be adjacent of dst hit action. */
    options = BCM_FLEXCTR_OPTIONS_WITH_ID | BCMI_LTSW_FLEXCTR_OPTIONS_INTERNAL;
    uft_src_id = uft_dst_id + 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_action_create(unit, options, &action, &uft_src_id));
    flexctr_info->uft_src_id = uft_src_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_trigger_enable_set(unit, uft_src_id, TRUE));

    /* non-UFT dst hit action. */
    action.flags |= BCM_FLEXCTR_ACTION_FLAGS_TRIGGER;
    action.source = bcmiFlexctrSourceL2Dst;
    action.hint = 1;
    action.mode = bcmFlexctrCounterModeWide;
    action.drop_count_mode = bcmFlexctrDropCountModeAll;
    action.index_num = 1; /* 14 tables * 16K entries */
    if (mode == bcmiFlexctrModePipeUnique) {
        /* Need to create a global action in pipe unique mode. */
        action.flags |= BCM_FLEXCTR_ACTION_FLAGS_GLOBAL;
    }

    /* NON_UFT_HIT_INDEX [23:19]+[15:6]. */
    /*
     * The NON_UFT_HIT_INDEX format:
     *      [1:0] ENTRY_NUMBER Entry index in Bucket.
     *      [15:2] BUCKET_NUMBER Bucket index in Table ID.
     *      [18:16] Reserved.
     *      [23:19] TABLE_ID Table ID, unique in vertical column.
     *              Encodings are:
     *                  ...
     *                  6 = IFTA80_E2T_00_B0.
     *                  7 = IFTA80_E2T_00_B1.
     *                  8 = IFTA80_E2T_01_B0.
     *                  9 = IFTA80_E2T_01_B1.
     *                  10 = IFTA80_E2T_02_B0.
     *                  11 = IFTA80_E2T_02_B1.
     *                  12 = IFTA80_E2T_03_B0.
     *                  13 = IFTA80_E2T_03_B1.
     *
     * The NON_UFT_HIT_INDEX is carried by two 16-bit objects on the pipeline
     * bus, and they are jointed to a flex ctr index for flex ctr SF.
     * The joint formulation:
     *      Obj0 = NON_UFT_HIT_INDEX[15:0].
     *      Index[0] = ((Obj0 >> 6) & ((1 << 10)-1)).
     *      Obj1 = NON_UFT_HIT_INDEX[31:16].
     *      Index[1] = (Obj1 & ((1 << 8)-1)) << 7.
     *      Index = Index[1] | Index[0].
     * The reason why we left-shift Index[1] by 7 is NON_UFT_HIT_INDEX[18:16] are
     * reserved and useless for flex ctr, so it will be overrided by upper bits
     * of Index[0].
     */
    index_op = &action.index_operation;
    index_op->object[0] = bcmFlexctrObjectIngL2DstLookupHitIndex0;
    index_op->mask_size[0] = 10;
    index_op->shift[0] = 6;
    index_op->object[1] = bcmFlexctrObjectIngL2DstLookupHitIndex1;
    index_op->mask_size[1] = 8;
    index_op->shift[1] = 7;
    /*
     * WAR for non-UFT flex ctr action creation.
     * Since the flex ctr pools of non-UFT case have been created during
     * UFT case creation, just need to pass index_num=1 here.
     */

    /* NON_UFT_HIT_INDEX [5:0]. */
    /*
     * One flex ctr entry has 64 bits, so we select the lower 6 bits of
     * NON_UFT_HIT_INDEX to locate which bit of the entry should be updated.
     * Flex counter update value would be generated as below:
     *      Obj0 = NON_UFT_HIT_INDEX[15:0].
     *      Value0 = (Obj0 >> 0) & ((1 << 6) - 1)).
     *      Value1 = (0 & ((1 << 1) - 1)) << 0 = 0.
     *      Value = (Value1 | Value0) = Value0.
     *      New_counter = UPDATE_TYPE(old_counter, Value). UPDATE_TYPE is set bit.
     */
    value_a_op = &action.operation_a;
    value_a_op->select = bcmFlexctrValueSelectCounterValue;
    value_a_op->object[0] = bcmFlexctrObjectIngL2DstLookupHitIndex0;
    value_a_op->mask_size[0] = 6;
    value_a_op->shift[0] = 0;
    value_a_op->object[1] = bcmFlexctrObjectConstZero;
    value_a_op->mask_size[1] = 1;
    value_a_op->shift[1] = 0;
    value_a_op->type = bcmFlexctrValueOperationTypeSetBit;

    /* non-UFT trigger NON_UFT_HIT_INDEX [24:24]. */
    /*
     * Bit 24 of NON_UFT_HIT_INDEX is used for flex ctr trigger.
     *      Obj0 = NON_UFT_HIT_INDEX [31:16].
     *      Trigger = ((Obj0 & object_value_mask) == object_value_start).
     *      Non-trigger = ((Obj0 & object_value_mask) == object_value_stop).
     */
    trigger = &action.trigger;
    trigger->trigger_type = bcmFlexctrTriggerTypeCondition;
    trigger->object = bcmFlexctrObjectIngL2DstLookupHitIndex1;
    trigger->object_value_start = 0;
    trigger->object_value_stop = 0x100;
    trigger->object_value_mask = 0x100;

    options = BCMI_LTSW_FLEXCTR_OPTIONS_INTERNAL;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_action_create(unit, options, &action, &dst_id));
    flexctr_info->dst_id = dst_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_trigger_enable_set(unit, dst_id, TRUE));

    /* non-UFT src hit action. */
    action.flags |= BCM_FLEXCTR_ACTION_FLAGS_TRIGGER;
    action.source = bcmiFlexctrSourceL2Src;
    action.hint = 1;
    action.mode = bcmFlexctrCounterModeWide;
    action.drop_count_mode = bcmFlexctrDropCountModeAll;
    action.index_num = 1; /* 14 tables * 16K entries */
    if (mode == bcmiFlexctrModePipeUnique) {
        /* Need to create a global action in pipe unique mode. */
        action.flags |= BCM_FLEXCTR_ACTION_FLAGS_GLOBAL;
    }

    /* NON_UFT_HIT_INDEX [23:19]+[13:6]. */
    index_op = &action.index_operation;
    index_op->object[0] = bcmFlexctrObjectIngL2SrcLookupHitIndex0;
    index_op->mask_size[0] = 10;
    index_op->shift[0] = 6;
    index_op->object[1] = bcmFlexctrObjectIngL2SrcLookupHitIndex1;
    index_op->mask_size[1] = 8;
    index_op->shift[1] = 7;

    /* NON_UFT_HIT_INDEX [5:0]. */
    value_a_op = &action.operation_a;
    value_a_op->select = bcmFlexctrValueSelectCounterValue;
    value_a_op->object[0] = bcmFlexctrObjectIngL2SrcLookupHitIndex0;
    value_a_op->mask_size[0] = 6;
    value_a_op->shift[0] = 0;
    value_a_op->object[1] = bcmFlexctrObjectConstZero;
    value_a_op->mask_size[1] = 1;
    value_a_op->shift[1] = 0;
    value_a_op->type = bcmFlexctrValueOperationTypeSetBit;

    /* non-UFT trigger NON_UFT_HIT_INDEX [24:24]. */
    trigger = &action.trigger;
    trigger->trigger_type = bcmFlexctrTriggerTypeCondition;
    trigger->object = bcmFlexctrObjectIngL2SrcLookupHitIndex1;
    trigger->object_value_start = 0x0;
    trigger->object_value_stop = 0x100;
    trigger->object_value_mask = 0x100;

    options = BCMI_LTSW_FLEXCTR_OPTIONS_INTERNAL;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_action_create(unit, options, &action, &src_id));
    flexctr_info->src_id = src_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_trigger_enable_set(unit, src_id, TRUE));

    /* Dst group action. */
    grp_action.source = bcmiFlexctrSourceL2Dst;
    grp_action.stat_counter_id[0] = uft_dst_id;
    grp_action.stat_counter_id[1] = dst_id;
    grp_action.action_num = 2;
    if (mode == bcmiFlexctrModePipeUnique) {
        /* Need to create a global group action in pipe unique mode. */
        grp_action.flags |= BCM_FLEXCTR_GROUP_ACTION_FLAGS_GLOBAL;
    }

    options = BCMI_LTSW_FLEXCTR_OPTIONS_INTERNAL;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_group_action_create(unit, options,
                                              &grp_action, &dst_grp_id));
    flexctr_info->dst_grp_id = dst_grp_id;

    /* Src group action. */
    grp_action.source = bcmiFlexctrSourceL2Src;
    grp_action.stat_counter_id[0] = uft_src_id;
    grp_action.stat_counter_id[1] = src_id;
    grp_action.action_num = 2;
    if (mode == bcmiFlexctrModePipeUnique) {
        /* Need to create a global group action in pipe unique mode. */
        grp_action.flags |= BCM_FLEXCTR_GROUP_ACTION_FLAGS_GLOBAL;
    }

    options = BCMI_LTSW_FLEXCTR_OPTIONS_INTERNAL;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexctr_group_action_create(unit, options,
                                              &grp_action, &src_grp_id));
    flexctr_info->src_grp_id = src_grp_id;

    sal_memset(&ctrl, 0, sizeof(bcmi_ltsw_flexctr_hit_ctrl_t));
    ctrl.stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
    ctrl.tbl_name = L2_HOST_TABLEs;
    ctrl.dst_grp_id = dst_grp_id;
    ctrl.src_grp_id = src_grp_id;
    if (mode == bcmiFlexctrModePipeUnique) {
        ctrl.global = true;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_hit_control_update(unit, &ctrl));

    ctrl.tbl_name = L2_HOST_NARROW_TABLEs;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_hit_control_update(unit, &ctrl));

exit:
    if (SHR_FUNC_ERR()) {
        (void)bcm56880_a0_ltsw_l2_hitbit_detach(unit, flexctr_info);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief L2 driver function variable for bcm56880_a0 device.
 */
static mbcm_ltsw_l2_drv_t bcm56880_a0_ltsw_l2_drv = {
    .l2_init = bcm56880_a0_ltsw_l2_init,
    .l2_detach = bcm56880_a0_ltsw_l2_detach,
    .l2_addr_add = bcm56880_a0_ltsw_l2_addr_add,
    .l2_addr_get = bcm56880_a0_ltsw_l2_addr_get,
    .l2_addr_delete = bcm56880_a0_ltsw_l2_addr_delete,
    .l2_addr_replace = bcm56880_a0_ltsw_l2_addr_replace,
    .l2_addr_traverse = bcm56880_a0_ltsw_l2_addr_traverse,
    .l2_addr_del_by_tuple = bcm56880_a0_ltsw_l2_addr_del_by_tuple,
    .l2_station_size_get = bcm56880_a0_ltsw_l2_station_size_get,
    .l2_age = bcm56880_a0_ltsw_l2_age,
    .l2_station_add = bcm56880_a0_ltsw_l2_station_add,
    .l2_station_get = bcm56880_a0_ltsw_l2_station_get,
    .l2_station_delete = bcm56880_a0_ltsw_l2_station_delete,
    .l2_force_vlan_set = bcm56880_a0_ltsw_l2_force_vlan_set,
    .l2_learn_set = bcm56880_a0_ltsw_l2_learn_set,
    .l2_learn_get = bcm56880_a0_ltsw_l2_learn_get,
    .l2_station_vlan_update = bcm56880_a0_ltsw_l2_station_vlan_update,
    .l2_size_get = bcm56880_a0_ltsw_l2_size_get,
    .l2_count_get = bcm56880_a0_ltsw_l2_count_get,
    .l2_view_vlan_update = bcm56880_a0_ltsw_l2_view_vlan_update,
    .l2_sw_dump = bcm56880_a0_ltsw_l2_sw_dump,
    .l2_virtual_info_update = bcm56880_a0_ltsw_l2_virtual_info_update,
    .l2_hitbit_detach = bcm56880_a0_ltsw_l2_hitbit_detach,
    .l2_hitbit_init = bcm56880_a0_ltsw_l2_hitbit_init
};

/******************************************************************************
 * Public functions
 */

int
bcm56880_a0_ltsw_l2_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_l2_drv_set(unit, &bcm56880_a0_ltsw_l2_drv));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56880_a0_ltsw_variant_drv_attach(unit, BCM56880_A0_LTSW_VARIANT_L2));

exit:
    SHR_FUNC_EXIT();
}

