/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/common/family.h>

#include <bcm_int/ltsw/mbcm/dev.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/lt_intf.h>

#include <sal/sal_libc.h>
#include <shr/shr_debug.h>
#include <bcmlt/bcmlt.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_COMMON

/******************************************************************************
 * Private functions
 */


/*!
 * \brief Get maximum modid from LT.
 *
 * \param [in] unit Unit Number.
 * \param [out] max_modid Maximum modid.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_dev_max_modid_get(int unit, int *max_modid)
{
    uint64_t min = 0;
    uint64_t max = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       ING_SYSTEM_PORT_TABLEs,
                                       SYSTEM_SOURCEs,
                                       &min,
                                       &max));
    /*
     * The index width for ING_SYSTEM_PORT_TABLE is 12 bits,
     * the lower 8 bits is for port id, so the modid has 4 bits.
     */
     *max_modid = (max >> 8) & 0xffffffff;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get physical device level controls.
 *
 * \param [in]   unit         Unit number.
 * \param [out]  core_frequency  Core clock frequency.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
ltsw_dev_config_get(int unit, int *core_frequency)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *sym_val = NULL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_CONFIGs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, CORE_CLK_FREQs,
                                      &sym_val));

    if (sal_strcasecmp(sym_val, CLK_1250MHZs) == 0) {
        /* Clock frequency 1250Mhz. */
        *core_frequency = 1250;
    } else if (sal_strcasecmp(sym_val, CLK_1175MHZs) == 0) {
        /* Clock frequency 1175Mhz. */
        *core_frequency = 1175;
    } else if (sal_strcasecmp(sym_val, CLK_1100MHZs) == 0) {
        /* Clock frequency 1100Mhz. */
        *core_frequency = 1100;
    } else if (sal_strcasecmp(sym_val, CLK_1025MHZs) == 0) {
        /* Clock frequency 1025Mhz. */
        *core_frequency = 1025;
    } else if (sal_strcasecmp(sym_val, CLK_950MHZs) == 0) {
        /* Clock frequency 950Mhz. */
        *core_frequency = 950;
    } else {
        /* Clock frequency 1350Mhz. */
        *core_frequency = 1350;
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse port bitmap information.
 *
 * \param [in] unit Unit Number.
 * \param [in] pbmp Port bitmap .
 * \param [out] port_num Number of ports.
 * \param [out] port_max Maximum port.
 *
 * \retval None
 */
static void
dev_port_bmp_parse(int unit, bcm_pbmp_t *pbmp, int *port_num, int *port_max)
{
    int port = 0;
    int num_port = 0;
    int max_port = 0;

    BCM_PBMP_ITER(*pbmp, port) {
        num_port++;
        if (port > max_port) {
            max_port = port;
        }
    }

    *port_num = num_port;
    *port_max = max_port;

    return;
}

/*!
 * \brief Get the information of physical ports.
 *
 * \param [in] unit Unit Number.
 * \param [out] port_num Number of physical ports.
 * \param [out] port_max Maximum physical port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dev_phys_port_get(int unit, int *port_num, int *port_max)
{
    bcm_pbmp_t pbmp;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_dev_phys_pbmp(unit, &pbmp));

    dev_port_bmp_parse(unit, &pbmp, port_num, port_max);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the information of logical ports.
 *
 * \param [in] unit Unit Number.
 * \param [out] port_num Number of logical ports.
 * \param [out] port_max Maximum logical port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dev_logic_port_get(int unit, int *port_num, int *port_max)
{
    bcm_pbmp_t pbmp;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_dev_logic_pbmp(unit, &pbmp));

    dev_port_bmp_parse(unit, &pbmp, port_num, port_max);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse pipe bitmap information.
 *
 * \param [in] unit Unit Number.
 * \param [in] pipe_bmp Pipe bitmap.
 * \param [out] port_num Number of pipes.
 * \param [out] port_max Maximum pipe.
 *
 * \retval None
 */
static void
dev_pipe_bmp_parse(int unit, uint32_t pipe_bmp, int *pipe_num, int *pipe_max)
{
    int i = 0;
    int num_pipe = 0;
    int max_pipe = 0;

    while (pipe_bmp) {
        if (pipe_bmp & 1) {
            num_pipe++;
            max_pipe = i;
        }
        pipe_bmp >>= 1;
        i++;
    }

    *pipe_num = num_pipe;
    *pipe_max = max_pipe;

    return;
}

/*!
 * \brief Get the information of pipes.
 *
 * \param [in] unit Unit Number.
 * \param [out] pipe_num Number of pipes.
 * \param [out] pipe_max Maximum pipe.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dev_pipe_get(int unit, int *pipe_num, int *pipe_max)
{
    uint32_t pipes = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_dev_pipe_bmp(unit, &pipes));

    dev_pipe_bmp_parse(unit, pipes, pipe_num, pipe_max);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the information of PP pipes.
 *
 * \param [in] unit Unit Number.
 * \param [out] pipe_num Number of PP pipes.
 * \param [out] pipe_max Maximum PP pipe.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dev_pp_pipe_get(int unit, int *pipe_num, int *pipe_max)
{
    uint32_t pipes = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_dev_pp_pipe_bmp(unit, &pipes));

    dev_pipe_bmp_parse(unit, pipes, pipe_num, pipe_max);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief check if the given PP pipe is valid.
 *
 * \param [in] unit Unit Number.
 * \param [in] pipe PP pipe.
 *
 * \retval false or true.
 */
static bool
dev_pp_pipe_valid(int unit, int pipe)
{
    uint32_t valid_pipes = 0;

    if ((pipe < 0) || (pipe > bcmi_ltsw_dev_pp_pipe_max(unit))) {
        return false;
    }

    if (SHR_FAILURE(bcmi_ltsw_dev_pp_pipe_bmp(unit, &valid_pipes))) {
        return false;
    }

    if (!(valid_pipes & (1 << pipe))) {
        return false;
    }

    return true;
}

/*!
 * \brief check if the given logical port is valid.
 *
 * \param [in] unit Unit Number.
 * \param [in] pipe Logical port.
 *
 * \retval false or true.
 */
static bool
dev_logic_port_valid(int unit, int port)
{
    bcm_pbmp_t valid_ports;

    if ((port < 0) || (port > bcmi_ltsw_dev_logic_port_max(unit))) {
        return false;
    }

    if (SHR_FAILURE(bcmi_ltsw_dev_logic_pbmp(unit, &valid_ports))) {
        return false;
    }

    if (!BCM_PBMP_MEMBER(valid_ports, port)) {
        return false;
    }

    return true;
}


static int
bcm56880_a0_ltsw_dev_info_init(
    int unit,
    bcmint_dev_info_t *dev_info)
{
    int max_modid;
    int core_frequency = 1350;
    SHR_FUNC_ENTER(unit);

    /* Get maximum modid from LT. */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_dev_max_modid_get(unit, &max_modid));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_dev_config_get(unit, &core_frequency));

    dev_info->cmic_port = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (dev_phys_port_get(unit,
                           &(dev_info->phys_port_num),
                           &(dev_info->phys_port_max)));

    SHR_IF_ERR_VERBOSE_EXIT
        (dev_logic_port_get(unit,
                            &(dev_info->logic_port_num),
                            &(dev_info->logic_port_max)));

    SHR_IF_ERR_VERBOSE_EXIT
        (dev_pipe_get(unit,
                      &(dev_info->pipe_num),
                      &(dev_info->pipe_max)));

    SHR_IF_ERR_VERBOSE_EXIT
        (dev_pp_pipe_get(unit,
                         &(dev_info->pp_pipe_num),
                         &(dev_info->pp_pipe_max)));

    dev_info->port_addr_max = 255;
    dev_info->modid_max = max_modid;
    
    dev_info->modid_count = 1;
    dev_info->modport_max = dev_info->modid_count == 1 ? 255 : 127;
    dev_info->modport_max_first = dev_info->modid_count == 1 ? -1 : 63;
    dev_info->family = BCM_FAMILY_TRIDENT;
    dev_info->core_frequency = core_frequency;
    dev_info->packet_buffer_num = 2;

    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_dev_logic_port_pp_pipe(
    int unit,
    bcm_port_t port,
    int *pipe)
{
    SHR_FUNC_ENTER(unit);

    *pipe = -1;

    if (!dev_logic_port_valid(unit, port)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    *pipe = port / 40;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_dev_logic_port_pp_pipe_port(
    int unit,
    bcm_port_t port,
    int *pp_port)
{
    SHR_FUNC_ENTER(unit);

    *pp_port = -1;

    if (!dev_logic_port_valid(unit, port)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    *pp_port = port % 40;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_dev_pp_pipe_port_logic_port(
    int unit,
    int pipe,
    int pp_port,
    bcm_port_t *port)
{
    SHR_FUNC_ENTER(unit);

    *port = -1;

    if (!dev_pp_pipe_valid(unit, pipe)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if ((pp_port < 0) || (pp_port >= 40)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    *port = pipe * 40 + pp_port;

    if (!dev_logic_port_valid(unit, *port)) {
        *port = -1;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_dev_pp_pipe_logic_pbmp(
    int unit,
    int pipe,
    bcm_pbmp_t *pbmp)
{
    int p, pe;
    bcm_pbmp_t valid_pbmp;

    SHR_FUNC_ENTER(unit);

    if (!dev_pp_pipe_valid(unit, pipe)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_dev_logic_pbmp(unit, &valid_pbmp));

    BCM_PBMP_CLEAR(*pbmp);
    for (p = pipe * 40, pe = (pipe + 1) * 40; p < pe; p ++) {
        if (BCM_PBMP_MEMBER(valid_pbmp, p)) {
            BCM_PBMP_PORT_ADD(*pbmp, p);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Dev driver function variable for bcm56880_a0 device.
 */
static mbcm_ltsw_dev_drv_t bcm56880_a0_ltsw_dev_drv = {
    .dev_info_init = bcm56880_a0_ltsw_dev_info_init,
    .dev_logic_port_pp_pipe = bcm56880_a0_ltsw_dev_logic_port_pp_pipe,
    .dev_logic_port_pp_pipe_port = bcm56880_a0_ltsw_dev_logic_port_pp_pipe_port,
    .dev_pp_pipe_port_logic_port = bcm56880_a0_ltsw_dev_pp_pipe_port_logic_port,
    .dev_pp_pipe_logic_pbmp = bcm56880_a0_ltsw_dev_pp_pipe_logic_pbmp
};

/******************************************************************************
 * Public functions
 */

int
bcm56880_a0_ltsw_dev_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dev_drv_set(unit, &bcm56880_a0_ltsw_dev_drv));

exit:
    SHR_FUNC_EXIT();
}

