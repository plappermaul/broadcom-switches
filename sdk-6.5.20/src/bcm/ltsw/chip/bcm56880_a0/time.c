/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/port.h>
#include <bcm_int/ltsw_dispatch.h>

#include <bcm_int/ltsw/mbcm/time.h>
#include <bcm_int/ltsw/xfs/time.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/lt_intf.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_TIME

/******************************************************************************
 * Private functions
 */


/*
 * Function:
 *      bcm56880_time_synce_clock_source_freq_cal
 * Purpose:
 *      Internal function to set syncE clock source squelch option.
 * Parameters:
 *      unit        - (IN)  Unit number.
 *      div         - (IN)  Divisor setting.
 *      clk_src_cfg - (OUT) SyncE clock source config.
 *      freq        - (OUT) SyncE Frequency.
 * Returns:
 *      BCM_E_xxx
 */
static int
bcm56880_time_synce_div_to_freq(
    int unit,
    bcm_time_synce_divisor_setting_t *div,
    bcm_time_synce_clock_source_config_t *clk_src_cfg,
    int *freq)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(clk_src_cfg, SHR_E_PARAM);
    SHR_NULL_CHECK(div, SHR_E_PARAM);

    if (clk_src_cfg->input_src == bcmTimeSynceInputSourceTypePort) {
        clk_src_cfg->port = div->index;
    } else if(clk_src_cfg->input_src == bcmTimeSynceInputSourceTypePLL) {
        clk_src_cfg->pll_index = div->index;
    } else {
        return BCM_E_PARAM;
    }

    if (div->stage0_mode == bcmTimeSynceModeSDMFracDiv &&
        div->stage0_sdm_whole == 20 &&
        div->stage0_sdm_frac == 160) {
        /* 10G/40G */
        *freq = bcmTimeSyncE25MHz;
    } else if (div->stage0_mode == bcmTimeSynceModeSDMFracDiv &&
               div->stage0_sdm_whole == 51 &&
               div->stage0_sdm_frac == 144) {
        /* 20G/100G */
        *freq = bcmTimeSyncE25MHz;
    } else if (div->stage0_mode == bcmTimeSynceModeSDMFracDiv &&
               div->stage0_sdm_whole == 53 &&
               div->stage0_sdm_frac == 32) {
        /* 50G PAM4 */
        *freq = bcmTimeSyncE25MHz;
    } else if (div->stage0_mode == bcmTimeSynceModeBypass &&
               div->stage1_div == bcmTimeSynceStage1Div11) {
        *freq = bcmTimeSyncE46MHz;
    } else if (div->stage0_mode == bcmTimeSynceModeBypass &&
               div->stage1_div == bcmTimeSynceStage1Div1) {
        *freq = bcmTimeSyncE515MHz;
    } else {
        return BCM_E_NONE;
    }

exit:

    SHR_FUNC_EXIT();
}

/*
 * Function:
 *      bcm56880_time_synce_clock_source_freq_cal
 * Purpose:
 *      Internal function to set syncE clock source squelch option.
 * Parameters:
 *      unit      - (IN)  Unit number.
 *      clk_src   - (IN)  Clock source type (Primary, Secondary).
 *      freq      - (IN)  SyncE frequency.
 *      div       - (OUT) Divisor setting.
 * Returns:
 *      BCM_E_xxx
 */
static int
bcm56880_time_synce_freq_to_div(
    int unit,
    bcm_time_synce_clock_source_config_t *clk_src_cfg,
    bcm_time_synce_frequency_t freq,
    bcm_time_synce_divisor_setting_t *div)
{
    bcm_port_resource_t resource;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(clk_src_cfg, SHR_E_PARAM);
    SHR_NULL_CHECK(div, SHR_E_PARAM);

    div->input_src = clk_src_cfg->input_src;
    if (div->input_src == bcmTimeSynceInputSourceTypePort) {
        div->index = clk_src_cfg->port;
    } else if(div->input_src == bcmTimeSynceInputSourceTypePLL) {
        div->index = clk_src_cfg->pll_index;
    } else {
        return BCM_E_PARAM;
    }

    switch(freq) {
        /* Blackhawk Serdes SDM SyncE Modes. */
        case bcmTimeSyncE25MHz:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_port_resource_speed_get(
                    unit, clk_src_cfg->port, &resource));
            /*
             *   output_freq = (rx_clk) * stage0_sdm * stage1_div
             *   rx_clk      = (VCO/20)
             *   stage0_sdm  = (stage0_sdm_whole) + (stage0_sdm_frac)/256
             *   stage1_div  = 1
             *   (0 <= stage0_sdm_whole <= 255,
             *    0 <= stage0_sdm_frac  <= 255,
             *    stage1_div is always locked to bypass in SDM mode.
             *    Div7,Div11 is not allowed.)
             *
             *   For example,
             *       stage0_sdm_whole = 20
             *       stage0_sdm_frac  = 160
             *       stage0_sdm = 20 + 160/256 = 20.625
             *
             *  Port speed |VCO     |VCO/20   |div val|stage0 |output freq
             *             |(Ghz)   |(Mhz)    |       |       |(MHz)
             *     10G/40G |20.625  |515.625  |20.625 |2'b10  |25
             *    20G/100G |25.78125|1289.0625|51.5625|2'b10  |25
             *         50G |26.5625 |1328.125 |53.125 |2'b10  |25
             */
            switch(resource.speed) {
                case 100000:
                case 400000:
                    /* 10G/40G, 20.625 (FRACTIONAL_DIVISOR == 5280). */
                    div->stage0_mode      = bcmTimeSynceModeSDMFracDiv;
                    div->stage0_sdm_whole = 20;
                    /* 0.625 * 256 = 160 */
                    div->stage0_sdm_frac  = 160;
                    break;
                case 200000:
                case 1000000:
                    /* 20G/100G, 51.5625 (FRACTIONAL_DIVISOR == 13200). */
                    div->stage0_mode      = bcmTimeSynceModeSDMFracDiv;
                    div->stage0_sdm_whole = 51;
                    /* 0.5625 * 256 = 144 */
                    div->stage0_sdm_frac  = 144;
                    break;
                case 500000:
                    /* 50G PAM4, 53.125 (FRACTIONAL_DIVISOR == 13600). */
                    div->stage0_mode      = bcmTimeSynceModeSDMFracDiv;
                    div->stage0_sdm_whole = 53;
                    /* 0.125 * 256 = 32 */
                    div->stage0_sdm_frac  = 32;
                    break;
                default:
                    return BCM_E_UNAVAIL;
            }
            break;
        /*
         *  Blackhawk Serdes Legacy SyncE Modes.
         *
         *  Port speed |DIV1     |DIV7      |DIV11    |stage0 |output freq
         *             |(Mhz)    |(Mhz)     |(Mhz)    |       |(MHz)
         *     10G/40G |515.625  |73.66     |46.875   |2'b00  |25
         *    20G/100G |1289.0625|184.15179 |117.1875 |2'b00  |25
         *         50G |1328.125 |189.73214 |120.73864|2'b00  |25
         */
        case bcmTimeSyncE46MHz:
            div->stage0_mode      = bcmTimeSynceModeBypass;
            div->stage0_sdm_whole = 0;
            div->stage0_sdm_frac  = 0;
            div->stage1_div       = bcmTimeSynceStage1Div11;
            break;
        case bcmTimeSyncE515MHz:
            div->stage0_mode      = bcmTimeSynceModeBypass;
            div->stage0_sdm_whole = 0;
            div->stage0_sdm_frac  = 0;
            div->stage1_div       = bcmTimeSynceStage1Div1;
            break;
        default:
            return BCM_E_UNAVAIL;
    }

exit:

    SHR_FUNC_EXIT();
}


static int
bcm56880_a0_ltsw_time_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (xfs_ltsw_time_init(unit));

    /* Init the device to 48b mode because PM8x50 only supports this mode. */
    SHR_IF_ERR_EXIT
        (xfs_ltsw_time_switch_control_set(unit,
                                          bcmSwitchTimesyncEgressTimestampingMode,
                                          bcmTimesyncTimestampingMode48bit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_time_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_time_deinit(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_time_synce_clock_set(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    bcm_time_synce_divisor_setting_t *divisor)
{
    if (divisor == NULL) {
        return SHR_E_PARAM;
    } else if (divisor->input_src == bcmTimeSynceInputSourceTypePort) {
        return xfs_ltsw_time_synce_clock_set(unit, clk_src, divisor);
    } else if (divisor->input_src == bcmTimeSynceInputSourceTypePLL) {
        return SHR_E_UNAVAIL;
    } else {
        return SHR_E_PARAM;
    }
}

static int
bcm56880_a0_ltsw_time_synce_clock_get(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    bcm_time_synce_divisor_setting_t *divisor)
{
    if (divisor == NULL) {
        return SHR_E_PARAM;
    } else if (divisor->input_src == bcmTimeSynceInputSourceTypePort) {
        return xfs_ltsw_time_synce_clock_get(unit, clk_src, divisor);
    } else if (divisor->input_src == bcmTimeSynceInputSourceTypePLL) {
        return SHR_E_UNAVAIL;
    } else {
        return SHR_E_PARAM;
    }
}

static int
bcm56880_a0_ltsw_time_synce_clock_source_control_set(
    int unit,
    bcm_time_synce_clock_source_config_t *clk_src_config,
    bcm_time_synce_clock_source_control_t control,
    int value)
{
    bcm_time_synce_divisor_setting_t div_in;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(clk_src_config, SHR_E_PARAM);

    switch (control) {
        case bcmTimeSynceClockSourceControlSquelch:
            SHR_IF_ERR_VERBOSE_EXIT(
                xfs_ltsw_time_synce_clock_source_control_set(
                    unit, clk_src_config, control, value));
            break;
        case bcmTimeSynceClockSourceControlFrequency:
            (void)bcm_time_synce_divisor_setting_t_init(&div_in);
            /* Calculate divisor from frequency. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56880_time_synce_freq_to_div(
                    unit, clk_src_config, value, &div_in));
            /* Write to hardware. */
            SHR_IF_ERR_EXIT
                (xfs_ltsw_time_synce_clock_set(
                    unit, clk_src_config->clk_src, &div_in));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
   }
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_time_synce_clock_source_control_get(
    int unit,
    bcm_time_synce_clock_source_config_t *clk_src_config,
    bcm_time_synce_clock_source_control_t control,
    int *value)
{
    bcm_time_synce_divisor_setting_t div_in;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(clk_src_config, SHR_E_PARAM);

    switch (control) {
        case bcmTimeSynceClockSourceControlSquelch:
            SHR_IF_ERR_VERBOSE_EXIT(
                xfs_ltsw_time_synce_clock_source_control_get
                    (unit, clk_src_config, control, value));
            break;
        case bcmTimeSynceClockSourceControlFrequency:
            (void)bcm_time_synce_divisor_setting_t_init(&div_in);
            /* Read from hardware. */
            SHR_IF_ERR_EXIT
                (xfs_ltsw_time_synce_clock_get
                    (unit, clk_src_config->clk_src, &div_in));
            /* Calculate divisor from frequency. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56880_time_synce_div_to_freq
                    (unit, &div_in, clk_src_config, value));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
   }
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_time_tod_set(
    int unit,
    uint32 stages,
    bcm_time_tod_t *tod)
{
    SHR_FUNC_ENTER(unit);

    if (stages &
        (BCM_TIME_STAGE_ALL | BCM_TIME_STAGE_EGRESS | BCM_TIME_STAGE_MMU)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_time_tod_set(unit, stages, tod));
    } else {
        return SHR_E_UNAVAIL;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_time_tod_get(
    int unit,
    uint32 stages,
    bcm_time_tod_t *tod)
{
    SHR_FUNC_ENTER(unit);

    if (stages &
        (BCM_TIME_STAGE_ALL | BCM_TIME_STAGE_EGRESS | BCM_TIME_STAGE_MMU)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_time_tod_get(unit, stages, tod));
    } else {
        return SHR_E_UNAVAIL;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_time_port_timesync_config_set(
    int unit,
    bcm_port_t port,
    int config_count,
    bcm_port_timesync_config_t *config_array)
{
    int cnt;
    bcm_port_timesync_config_t *ts_config;
    SHR_FUNC_ENTER(unit);

    if ((config_count > 0) && (NULL != config_array)) {
        /* Set timesync profiles */
        for (cnt = 0; cnt < config_count; cnt++) {
            ts_config = (bcm_port_timesync_config_t *) (config_array + cnt);
            if (ts_config != NULL && ts_config->flags & BCM_PORT_TIMESYNC_MPLS) {
                /* TD4 doesn't support BCM_PORT_TIMESYNC_MPLS. */
                return SHR_E_UNAVAIL;
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_time_port_timesync_config_set(unit, port, config_count, config_array));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_time_port_timesync_config_get(
    int unit,
    bcm_port_t port,
    int config_count,
    bcm_port_timesync_config_t *config_array,
    int *array_count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_time_port_timesync_config_get(unit, port, config_count, config_array, array_count));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_time_switch_control_set(
    int unit,
    bcm_switch_control_t type,
    int arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (xfs_ltsw_time_switch_control_set(unit, type, arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_time_switch_control_get(
    int unit,
    bcm_switch_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (xfs_ltsw_time_switch_control_get(unit, type, arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_time_switch_control_port_set(
    int unit,
    bcm_port_t port,
    bcm_switch_control_t type,
    int arg)
{
    if (type == bcmSwitchTimesyncEgressTimestampingMode) {
        if (arg == bcmTimesyncTimestampingMode48bit) {
            return SHR_E_NONE;
        } else {
            return SHR_E_UNAVAIL;
        }
    } else {
        return SHR_E_PARAM;
    }
}

static int
bcm56880_a0_ltsw_time_switch_control_port_get(
    int unit,
    bcm_port_t port,
    bcm_switch_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(arg, SHR_E_PARAM);

    if (type == bcmSwitchTimesyncEgressTimestampingMode) {
        *arg = bcmTimesyncTimestampingMode48bit;
        return SHR_E_NONE;
    } else {
        return SHR_E_PARAM;
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Time driver function variable for bcm56880_a0 device.
 */
static mbcm_ltsw_time_drv_t bcm56880_a0_ltsw_time_drv = {
    .time_init = bcm56880_a0_ltsw_time_init,
    .time_deinit = bcm56880_a0_ltsw_time_deinit,
    .time_synce_clock_set = bcm56880_a0_ltsw_time_synce_clock_set,
    .time_synce_clock_get = bcm56880_a0_ltsw_time_synce_clock_get,
    .time_synce_clock_source_control_set = bcm56880_a0_ltsw_time_synce_clock_source_control_set,
    .time_synce_clock_source_control_get = bcm56880_a0_ltsw_time_synce_clock_source_control_get,
    .time_tod_set = bcm56880_a0_ltsw_time_tod_set,
    .time_tod_get = bcm56880_a0_ltsw_time_tod_get,
    .time_port_timesync_config_set = bcm56880_a0_ltsw_time_port_timesync_config_set,
    .time_port_timesync_config_get = bcm56880_a0_ltsw_time_port_timesync_config_get,
    .time_switch_control_set = bcm56880_a0_ltsw_time_switch_control_set,
    .time_switch_control_get = bcm56880_a0_ltsw_time_switch_control_get,
    .time_switch_control_port_set = bcm56880_a0_ltsw_time_switch_control_port_set,
    .time_switch_control_port_get = bcm56880_a0_ltsw_time_switch_control_port_get
};

/******************************************************************************
 * Public functions
 */

int
bcm56880_a0_ltsw_time_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_time_drv_set(unit, &bcm56880_a0_ltsw_time_drv));

exit:
    SHR_FUNC_EXIT();
}

