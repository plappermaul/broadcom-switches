/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/ltsw/mbcm/trunk.h>
#include <bcm_int/ltsw/xgs/trunk.h>

#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_TRUNK

/******************************************************************************
 * Private functions
 */


#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/profile_mgmt.h>

#include <bcmltd/chip/bcmltd_str.h>

#define TRUNK_LB_CONTROL_UC_FLOW 0x100
#define TRUNK_LB_CONTROL_NUC_FLOW 0x200
#define TRUNK_HASH_CONTROL 0x400

/* Non-unicast trunk block mask hash controls. */
/* Use destination MAC or IP address. */
#define TRUNK_HASH_CONTROL_NUC_DST 0x0010
/* Use source MAC or IP address. */
#define TRUNK_HASH_CONTROL_NUC_SRC 0x0020
/* Use module ID and port. */
#define TRUNK_HASH_CONTROL_NUC_MODPORT  0x0040
/* Use enhanced (aka. RTAG7) hashing algorithm. */
#define TRUNK_HASH_CONTROL_NUC_ENHANCE  0x0100
/* The maximum number of member */
#define TRUNK_UC_MEMBER_CNT  64

typedef struct trunk_flexctr_cfg_s {
    /* Operation of flexctr fields: 0 = set, 1 = get. */
    bool op;
#define TRUNK_FLXCTR_OP_SET   0
#define TRUNK_FLXCTR_OP_GET   1

    /* Flags indicate which flexctr field to be operated. */
    uint8_t flags;
#define TRUNK_FLXCTR_F_ACTION     (1 << 0)
#define TRUNK_FLXCTR_F_INDEX      (1 << 1)

    /* Flex counter action. */
    uint32_t action;

    /* Distinct flex counter index. */
    uint32_t index;
} trunk_flexctr_cfg_t;

typedef struct trunk_flex_action_profile_s {
    /*! Action. */
    uint32_t action;
} trunk_flex_action_profile_t;

/*!
 * \brief Psc decode to HW rtag and load balance mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] psc Port Selection Criteria.
 * \param [out] lb_mode Load Balance Mode.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_psc_decode(
    int unit,
    int psc,
    const char **lb_mode)
{
    const char *local_lb_mode = NULL;

    SHR_FUNC_ENTER(unit);

    switch (psc) {
        case BCM_TRUNK_PSC_RANDOMIZED:
            local_lb_mode = RANDOMs;
            break;
        case BCM_TRUNK_PSC_PORTINDEX:
        case BCM_TRUNK_PSC_PORTFLOW:
            local_lb_mode = REG_HASHs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (lb_mode) {
        *lb_mode = local_lb_mode;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Psc encode from HW rtag and load balance mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] lb_mode Load Balance Mode.
 * \param [out] psc Port Selection Criteria.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_psc_encode(
    int unit,
    const char *lb_mode,
    int *psc)
{
    const char *local_lb_mode = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(psc, SHR_E_PARAM);

    if (lb_mode == NULL) {
        local_lb_mode = REG_HASHs;
    } else {
        local_lb_mode = lb_mode;
    }

    if (sal_strcmp(local_lb_mode, REG_HASHs) == 0) {
        *psc = BCM_TRUNK_PSC_PORTFLOW;
    } else if (sal_strcmp(local_lb_mode, RANDOMs) == 0) {
        *psc = BCM_TRUNK_PSC_RANDOMIZED;
    } else {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare two psc values and return the result.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_type Trunk Type.
 * \param [in] psc0 First Port Selection Criteria.
 * \param [in] psc1 Second Port Selection Criteria.
 * \param [in] exact Exact match.
 * \param [out] result TRUE/False: Same or Not.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_psc_compare(
    int unit,
    int psc0,
    int psc1,
    int exact,
    bool *result)
{
    const char *lb_mode = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(result, SHR_E_PARAM);

    *result = false;

    if (psc0 == psc1) {
        *result = true;
    } else {
        if (exact) {
            SHR_EXIT();
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (trunk_psc_decode(unit, psc0, &lb_mode));

        SHR_IF_ERR_VERBOSE_EXIT
            (trunk_psc_encode(unit, lb_mode, &psc0));

        SHR_IF_ERR_VERBOSE_EXIT
            (trunk_psc_decode(unit, psc1, &lb_mode));

        SHR_IF_ERR_VERBOSE_EXIT
            (trunk_psc_encode(unit, lb_mode, &psc1));

        if (psc0 == psc1) {
            *result = true;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Psc decode to HW rtag and load balance mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] psc Port Selection Criteria.
 * \param [out] rtag Rtag7 Load Balance Mode.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_failover_psc_decode(
    int unit,
    int psc,
    const char **rtag)
{
    const char *local_rtag;

    SHR_FUNC_ENTER(unit);

    switch (psc) {
        case BCM_TRUNK_PSC_PORTFLOW:
            local_rtag = LB_HASHs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (rtag) {
        *rtag = local_rtag;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Psc encode from HW rtag and load balance mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] rtag Rtag7 Load Balance Mode.
 * \param [out] psc Port Selection Criteria.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_failover_psc_encode(
    int unit,
    const char *rtag,
    int *psc)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(rtag, SHR_E_PARAM);
    SHR_NULL_CHECK(psc, SHR_E_PARAM);

    if (sal_strcmp(rtag, LB_HASHs) == 0) {
        *psc = BCM_TRUNK_PSC_PORTFLOW;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
trunk_failover_flags_extract(
    int unit,
    uint32_t flags,
    bcmint_trunk_type_t t_type,
    uint32_t *fail_flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(fail_flags, SHR_E_PARAM);

    *fail_flags = 0;

    if (flags & BCM_TRUNK_FLAG_FAILOVER_NEXT) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_NEXT;
    } else if (flags & BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL;
    } else if (flags & BCM_TRUNK_FLAG_FAILOVER_ALL) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_ALL;
    } else if (flags & BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
trunk_failover_set(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_gport_t fail_port,
    int psc,
    int ftp_count,
    bcm_gport_t *ftp)
{
    int rv;
    uint64_t value;
    const char *rtag, *pre_rtag;
    int pre_lt_count, i, dunit;
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    if (t_type != bcmintTrunkTypeFrontPanel) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FAILOVERs, &lte_hdl));

    value = BCM_GPORT_MODPORT_PORT_GET(fail_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    if (ftp_count == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_lag_failover_enable_set(unit, fail_port, FALSE));

        rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL);

        if (SHR_SUCCESS(rv) || rv == SHR_E_NOT_FOUND) {
            SHR_EXIT();
        } else {
            SHR_ERR_EXIT(rv);
        }
    }

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (trunk_failover_psc_decode(unit, psc, &rtag));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(lte_hdl, RTAGs, &pre_rtag));

        if (sal_strcmp(pre_rtag, rtag) != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(lte_hdl, RTAGs, rtag));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, FAILOVER_CNTs, &value));
        pre_lt_count = value & 0xffffffff;

        for (i = 0; i < ftp_count; i++) {
            value = BCM_GPORT_MODPORT_PORT_GET(ftp[i]);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_MODPORTs,
                                             i, &value, 1));
        }

        if (pre_lt_count != ftp_count) {
            value = ftp_count;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, FAILOVER_CNTs, value));
        }

        if (pre_lt_count > 0 && ftp_count < pre_lt_count) {
            for (i = ftp_count; i < pre_lt_count; i++) {
                value = 0;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_MODPORTs,
                                                 i, &value, 1));
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    } else if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (trunk_failover_psc_decode(unit, psc, &rtag));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(lte_hdl, RTAGs, rtag));

        pre_lt_count = 0;
        for (i = 0; i < ftp_count; i++) {
            value = BCM_GPORT_MODPORT_PORT_GET(ftp[i]);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_MODPORTs,
                                             i, &value, 1));
        }

        if (pre_lt_count != ftp_count) {
            value = ftp_count;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, FAILOVER_CNTs, value));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_lag_failover_enable_set(unit, fail_port, TRUE));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the front panel trunk parameters before setting the trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_params_validate_fp(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member)
{
    int i;

    SHR_FUNC_ENTER(unit);

    /* Validate the PSC value */
    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_psc_decode(unit, trunk_info->psc, NULL));

    /* Validate the member flags */
    for (i = 0; i < member_count; i++) {
        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            if (member_array[i].flags & BCM_TRUNK_MEMBER_INGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_UNICAST_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_IPMC_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_L2MC_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_BCAST_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_DLF_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_IPMC_EGRESS_DISABLE) {
            if (trunk_info->ipmc_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_L2MC_EGRESS_DISABLE) {
            if (trunk_info->mc_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_BCAST_EGRESS_DISABLE) {
            if (trunk_info->dlf_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_DLF_EGRESS_DISABLE) {
            if (trunk_info->dlf_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
    }

    /* Validate the trunk information */
    if (member_count > 0 && trunk_info->dlf_index >= member_count) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk port attributes.
 *
 * \param [in] unit Unit Number.
 * \param [in] modid Module Number.
 * \param [in] port Port Number.
 * \param [in] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_update_fp_port_attr(
    int unit,
    bcm_module_t modid,
    bcm_port_t port,
    bcmint_trunk_id_t t_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value = 0;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Update SYSTEM_PORT_TYPE for specific modid + port */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SYSTEMs, &lte_hdl));

    value += port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_SYSTEM_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    if (t_id == BCM_TRUNK_INVALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(lte_hdl, SYSTEM_PORT_TYPEs,
                                          NORMAL_PORTs));

        value = 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(lte_hdl, SYSTEM_PORT_TYPEs,
                                          TRUNK_PORTs));

        value = t_id;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a front panel trunk with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_destroy_fp_group(
    int unit,
    bcmint_trunk_id_t t_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FASTs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_NOT_FOUND);

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a front panel trunk member attributes
 * with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_destroy_fp_port_attr(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    int i, member_count;
    int modid, port;
    bcmint_trunk_member_t *member_array;

    SHR_FUNC_ENTER(unit);

    member_count = t_priv->t_info->member_count;
    member_array = t_priv->member_array;

    for (i = 0; i < member_count; i++) {
        modid = BCM_GPORT_MODPORT_MODID_GET(member_array[i].gport);
        port = BCM_GPORT_MODPORT_PORT_GET(member_array[i].gport);

        SHR_IF_ERR_VERBOSE_EXIT
            (trunk_update_fp_port_attr(unit, modid, port,
                                       BCM_TRUNK_INVALID));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Find a specific front panel trunk with member gport.
 *
 * \param [in] unit Unit Number.
 * \param [in] gport Generic Port Number.
 * \param [out] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_find_fp(
    int unit,
    bcm_gport_t gport,
    bcmint_trunk_id_t *t_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value = 0;
    int dunit;
    const char *sys_port_type = NORMAL_PORTs;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Update SYSTEM_PORT_TYPE for specific modid + port */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SYSTEMs, &lte_hdl));

    value += BCM_GPORT_MODPORT_PORT_GET(gport);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_SYSTEM_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(lte_hdl, SYSTEM_PORT_TYPEs,
                                      &sys_port_type));

    if (sal_strcmp(sys_port_type, TRUNK_PORTs) == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, TRUNK_IDs, &value));
        *t_id = value & 0xffffffff;
    } else {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}


/*!
 * \brief Update the front panel trunk group configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_update_fp_group(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int i, dunit;
    const char *lb_mode = NULL;
    uint64_t value;
    int member_cnt;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FASTs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));

    if (member_count <= 0) {
        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL),
             SHR_E_NOT_FOUND);
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_psc_decode(unit,
                          trunk_info->psc,
                          &lb_mode));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(lte_hdl, LB_MODEs, lb_mode));

    member_cnt = 0;

    for (i = 0; i < member_count; i++) {
        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_UNICAST_EGRESS_DISABLE) {
            continue;
        }

        value = BCM_GPORT_MODPORT_PORT_GET(member_array[i].gport);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(lte_hdl, UC_MEMBER_MODPORTs,
                                         member_cnt, &value, 1));

        member_cnt++;
    }

    if ((member_cnt >= 0) && (member_cnt < t_priv->t_info->member_count)) {
        for (i = member_cnt; i < t_priv->t_info->member_count; i++) {
            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, UC_MEMBER_MODPORTs,
                                             i, &value, 1));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, UC_MEMBER_CNTs,
                               member_cnt));
    member_cnt = 0;

    for (i = 0; i < member_count; i++) {
        if (trunk_info->dlf_index != BCM_TRUNK_UNSPEC_INDEX &&
            trunk_info->dlf_index != i) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_IPMC_EGRESS_DISABLE) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_L2MC_EGRESS_DISABLE) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_BCAST_EGRESS_DISABLE) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_DLF_EGRESS_DISABLE) {
            continue;
        }

        value = BCM_GPORT_MODPORT_PORT_GET(member_array[i].gport);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(lte_hdl, NONUC_MEMBER_MODPORTs,
                                         member_cnt, &value, 1));

        member_cnt++;
    }

    if ((member_cnt >= 0) && (member_cnt < t_priv->t_info->member_count)) {
        for (i = member_cnt; i < t_priv->t_info->member_count; i++) {
            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, NONUC_MEMBER_MODPORTs,
                                             i, &value, 1));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, NONUC_MEMBER_CNTs,
                               member_cnt));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk member configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_update_fp_member(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    int i, modid, port;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < member_count; i++) {
        modid = BCM_GPORT_MODPORT_MODID_GET(member_array[i].gport);
        port = BCM_GPORT_MODPORT_PORT_GET(member_array[i].gport);

        if (member_array[i].flags & BCM_TRUNK_MEMBER_INGRESS_DISABLE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (trunk_update_fp_port_attr(unit, modid, port,
                                           BCM_TRUNK_INVALID));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (trunk_update_fp_port_attr(unit, modid, port, t_id));
        }
    }

    for (i = 0; i < t_update->num_leaving; i++) {
        modid = BCM_GPORT_MODPORT_MODID_GET(t_update->leaving_members[i]);
        port = BCM_GPORT_MODPORT_PORT_GET(t_update->leaving_members[i]);

        SHR_IF_ERR_VERBOSE_EXIT
            (trunk_update_fp_port_attr(unit, modid, port,
                                       BCM_TRUNK_INVALID));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert front panel trunk member array to bitmap.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] nports_fp Max port number per trunk group.
 * \param [out] out_pbmp Trunk group member bitmap.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_bitmap_get(int unit,
                 bcmint_trunk_id_t t_id,
                 int nports_fp,
                 bcm_pbmp_t *out_pbmp)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value;
    uint32_t i, count = 0;
    uint64_t port_array[TRUNK_UC_MEMBER_CNT] = {0};
    uint32_t rt_num = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FASTs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_NOT_FOUND);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, UC_MEMBER_CNTs, &value));
    count = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_get(lte_hdl, UC_MEMBER_MODPORTs,
                                     0, port_array, nports_fp, &rt_num));

    if (count > 0) {
        for (i = 0; i < count; i++) {
            BCM_PBMP_PORT_ADD(*out_pbmp, port_array[i]);
        }
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief set port type to normal port.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_clear_port_system(int unit)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit, rv;
    uint64_t value;
    const char *sym_value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SYSTEMs, &lte_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, lte_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(lte_hdl, SYSTEM_PORT_TYPEs,
                                          &sym_value));

        if (sal_strcmp(sym_value, TRUNK_PORTs) == 0) {
            sym_value = NORMAL_PORTs;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(lte_hdl, SYSTEM_PORT_TYPEs,
                                              sym_value));

            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL));
        }
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear front panel trunk configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] tbl_name LT name.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_clear(int unit, const char *tbl_name)
{
    SHR_FUNC_ENTER(unit);

    /* Clear TRUNK FAST table. */
    if (sal_strcmp(tbl_name, TRUNK_FASTs) == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TRUNK_FASTs));
    }

    /* Clear TRUNK_FAILOVER table. */
    if (sal_strcmp(tbl_name, TRUNK_FAILOVERs) == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TRUNK_FAILOVERs));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
trunk_hash_control_set(int unit,
                       uint32_t type,
                       uint32_t arg)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint32_t opcode;
    bcmlt_entry_info_t   e_info;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_CONTROLs, &lte_hdl));

    SHR_IF_ERR_CONT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_info_get(lte_hdl, &e_info));

    opcode = (e_info.status == SHR_E_NONE) ?
             BCMLT_OPCODE_UPDATE : BCMLT_OPCODE_INSERT;

    switch (type) {
        case TRUNK_HASH_CONTROL:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl,
                                       NONUC_HASH_USE_DSTs,
                                       arg & TRUNK_HASH_CONTROL_NUC_DST ?
                                       1 : 0));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl,
                                       NONUC_HASH_USE_SRCs,
                                       arg & TRUNK_HASH_CONTROL_NUC_SRC ?
                                       1 : 0));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl,
                                       NONUC_HASH_USE_SRC_PORTs,
                                       arg & TRUNK_HASH_CONTROL_NUC_MODPORT ?
                                       1 : 0));

            SHR_IF_ERR_VERBOSE_EXIT
                 (bcmlt_entry_field_add(lte_hdl,
                                        NONUC_HASH_USE_LB_HASHs,
                                        arg & TRUNK_HASH_CONTROL_NUC_ENHANCE ?
                                        1 : 0));
            break;
        case TRUNK_LB_CONTROL_UC_FLOW:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl,
                                       LB_HASH_USE_FLOW_UCs,
                                       arg));
            break;
        case TRUNK_LB_CONTROL_NUC_FLOW:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl,
                                       LB_HASH_USE_FLOW_NONUCs,
                                       arg));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(lte_hdl, opcode,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_NOT_FOUND);

    if (SHR_FUNC_VAL_IS(SHR_E_NOT_FOUND)) {
        SHR_VERBOSE_EXIT(SHR_E_NONE);
    }
exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

static int
trunk_hash_control_get(int unit,
                       uint32_t type,
                       uint32_t *arg)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value = 0;
    bcmlt_entry_info_t   e_info;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_CONTROLs, &lte_hdl));

    SHR_IF_ERR_CONT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_info_get(lte_hdl, &e_info));

    if (e_info.status != SHR_E_NONE) {
        *arg = (uint32_t)value;
        SHR_VERBOSE_EXIT(SHR_E_NONE);
    }

    switch (type) {
        case TRUNK_HASH_CONTROL:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl,
                                       NONUC_HASH_USE_DSTs,
                                       &value));

            *arg |= (value ? TRUNK_HASH_CONTROL_NUC_DST : 0);

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl,
                                       NONUC_HASH_USE_SRCs,
                                       &value));

            *arg |= (value ? TRUNK_HASH_CONTROL_NUC_SRC : 0);

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl,
                                       NONUC_HASH_USE_SRC_PORTs,
                                       &value));

            *arg |= (value ? TRUNK_HASH_CONTROL_NUC_MODPORT : 0);

            SHR_IF_ERR_VERBOSE_EXIT
                 (bcmlt_entry_field_get(lte_hdl,
                                        NONUC_HASH_USE_LB_HASHs,
                                        &value));

            *arg |= (value ? TRUNK_HASH_CONTROL_NUC_ENHANCE : 0);
            break;
        case TRUNK_LB_CONTROL_UC_FLOW:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl,
                                       LB_HASH_USE_FLOW_UCs,
                                       &value));
            *arg = (uint32_t)value;
            break;
        case TRUNK_LB_CONTROL_NUC_FLOW:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl,
                                       LB_HASH_USE_FLOW_NONUCs,
                                       &value));
            *arg = (uint32_t)value;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

static int
trunk_flex_action_profile_entry_get(int unit,
                                    int profile_idx,
                                    trunk_flex_action_profile_t *prof_entry)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
                              TRUNK_CTR_ING_EFLEX_ACTIONs,
                              &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh,
                               TRUNK_CTR_ING_EFLEX_ACTION_IDs,
                               profile_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit,
                              eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, ACTIONs, &data));
    prof_entry->action = (uint32_t)data;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
trunk_flex_action_profile_entry_set(int unit,
                                    int profile_idx,
                                    trunk_flex_action_profile_t *prof_entry)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
                              TRUNK_CTR_ING_EFLEX_ACTIONs,
                              &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh,
                               TRUNK_CTR_ING_EFLEX_ACTION_IDs,
                               profile_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh,
                               ACTIONs,
                               (uint64_t)prof_entry->action));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
trunk_flex_action_profile_entry_del(int unit, int profile_idx)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_CTR_ING_EFLEX_ACTIONs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh,
                               TRUNK_CTR_ING_EFLEX_ACTION_IDs,
                               profile_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit,
                              eh,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
trunk_flex_action_profile_add(int unit,
                              trunk_flex_action_profile_t *entry,
                              int *index)
{
    int rv;
    int profile_idx;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    rv = bcmi_ltsw_profile_index_allocate(unit,
                                          BCMI_LTSW_PROFILE_TRUNK_CTR_ING_EFLEX_ACTION,
                                          entry, 0, 1, index);
    if (rv == SHR_E_EXISTS) {
        /* the same profile already exists */
        SHR_EXIT();
    }

    if (rv == SHR_E_FULL) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }

    if (SHR_FAILURE(rv)) {
       SHR_ERR_EXIT(rv);
    }

    profile_idx = *index;

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_flex_action_profile_entry_set(unit, profile_idx, entry));

exit:
    SHR_FUNC_EXIT();
}

static int
trunk_flex_action_profile_get(int unit,
                              int index,
                              trunk_flex_action_profile_t *prof_entry)
{
    int profile_idx;

    SHR_FUNC_ENTER(unit);
    profile_idx = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_flex_action_profile_entry_get(unit,
                                             profile_idx,
                                             prof_entry));
exit:
    SHR_FUNC_EXIT();
}

static int
trunk_flex_action_profile_delete(int unit, int index)
{
    int rv;
    int profile_idx;

    SHR_FUNC_ENTER(unit);

    profile_idx = index;

    rv = bcmi_ltsw_profile_index_free(unit,
                                      BCMI_LTSW_PROFILE_TRUNK_CTR_ING_EFLEX_ACTION,
                                      index);

    if (rv == SHR_E_BUSY) {
        /* profile entry is still inused */
       SHR_EXIT();
    }

    if (rv != SHR_E_NONE) {
        SHR_ERR_EXIT(rv);
    }

    /* empty the profile entry */
    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_flex_action_profile_entry_del(unit, profile_idx));

exit:
    SHR_FUNC_EXIT();
}

static int
trunk_flexctr_op(
    int unit,
    bcm_trunk_t tid,
    trunk_flexctr_cfg_t *fc)
{
    int dunit = 0;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    trunk_flex_action_profile_t action_profile;
    bcmlt_opcode_t opcode;
    int index;
    uint64_t val;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FASTs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TRUNK_IDs, tid));

    if (fc->op == TRUNK_FLXCTR_OP_SET) {
        if (fc->flags & TRUNK_FLXCTR_F_ACTION) {
            action_profile.action = fc->action;
            if (fc->action) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (trunk_flex_action_profile_add(unit,
                                                   &action_profile,
                                                   &index));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(eh,
                                           TRUNK_CTR_ING_EFLEX_ACTION_IDs,
                                           index));
            } else {
                /* Get the old action and delete it. */
                opcode = BCMLT_OPCODE_LOOKUP;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_lt_entry_commit(unit,
                                          eh,
                                          opcode,
                                          BCMLT_PRIORITY_NORMAL));

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(eh,
                                           TRUNK_CTR_ING_EFLEX_ACTION_IDs,
                                           &val));
                index = (int)val;
                SHR_IF_ERR_VERBOSE_EXIT
                    (trunk_flex_action_profile_delete(unit, index));
                /* Assign zero to action for disable action */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(eh, TRUNK_CTR_ING_EFLEX_ACTION_IDs, 0));
            }
        }

        if (fc->flags & TRUNK_FLXCTR_F_INDEX) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(eh,
                                       CTR_ING_EFLEX_OBJECTs,
                                       fc->index));
        }

        opcode = BCMLT_OPCODE_UPDATE;
    } else if (fc->op == TRUNK_FLXCTR_OP_GET) {
        opcode = BCMLT_OPCODE_LOOKUP;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit,
                              eh,
                              opcode,
                              BCMLT_PRIORITY_NORMAL));

    if (fc->op == TRUNK_FLXCTR_OP_GET) {
        if (fc->flags & TRUNK_FLXCTR_F_ACTION) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(eh,
                                       TRUNK_CTR_ING_EFLEX_ACTION_IDs,
                                       &val));
            index = (int)val;
            SHR_IF_ERR_VERBOSE_EXIT
                (trunk_flex_action_profile_get(unit, index, &action_profile));
            fc->action = action_profile.action;
        }

        if (fc->flags & TRUNK_FLXCTR_F_INDEX) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(eh, CTR_EGR_EFLEX_OBJECTs, &val));
            fc->index = val;
        }
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

static int
trunk_flexctr_object_set(
    int unit,
    bcm_trunk_t tid,
    uint16_t value)
{
    int dunit = 0;
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FASTs, &lte_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, tid));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl,
                               CTR_ING_EFLEX_OBJECTs,
                               value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, lte_hdl,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
    }
    SHR_FUNC_EXIT();
}

static int
trunk_flexctr_object_get(
    int unit,
    bcm_trunk_t tid,
    uint16_t *value)
{
    int dunit = 0;
    uint64_t flex_ctr_object = 0;
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FASTs, &lte_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, tid));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, lte_hdl,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl,
                               CTR_ING_EFLEX_OBJECTs,
                               &flex_ctr_object));
    *value = (uint16_t)flex_ctr_object;

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
    }
    SHR_FUNC_EXIT();
}

static int
trunk_flex_action_profile_entry_hash_cb(
    int unit,
    void *entries,
    int entries_per_set,
    uint32_t *hash)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    if (entries_per_set != 1) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    *hash = shr_crc32(0,
                      entries,
                      sizeof(trunk_flex_action_profile_t));

exit:
    SHR_FUNC_EXIT();
}

static int
trunk_flex_action_profile_entry_cmp_cb(
    int unit,
    void *entries,
    int entries_per_set,
    int profile_idx,
    int *cmp_result)
{
    trunk_flex_action_profile_t prof_entry;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(cmp_result, SHR_E_PARAM);

    if (entries_per_set != 1) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    sal_memset(&prof_entry, 0, sizeof(prof_entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_flex_action_profile_get(unit, profile_idx, &prof_entry));

    *cmp_result = sal_memcmp(entries, &prof_entry, sizeof(prof_entry));

exit:
    SHR_FUNC_EXIT();
}


static int
bcm56990_a0_ltsw_trunk_pub_info_get(
    int unit,
    bcmint_trunk_pub_info_t *t_pub)
{
    uint64_t min, max;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(t_pub, SHR_E_MEMORY);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNK_FASTs, TRUNK_IDs,
                                       &min, &max));
    t_pub->ngroups_fp = (int)max + 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNK_FASTs, UC_MEMBER_CNTs,
                                       &min, &max));
    t_pub->nports_fp = (int)max;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNK_FAILOVERs, FAILOVER_CNTs,
                                       &min, &max));
    t_pub->nftports_fp = (int)max;

    t_pub->ngroups_fabric = 0;
    t_pub->nports_fabric = -1;
    t_pub->nftports_fabric = -1;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_psc_compare(
    int unit,
    bcmint_trunk_type_t t_type,
    int psc0,
    int psc1,
    int exact,
    bool *result)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_psc_compare(unit, psc0, psc1, exact, result));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_init(int unit)
{
    bcmi_ltsw_profile_hdl_t profile_hdl;
    int ent_idx_min, ent_idx_max;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    /* TRUNK_CTR_ING_EFLEX_ACTION profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TRUNK_CTR_ING_EFLEX_ACTIONs,
                                       TRUNK_CTR_ING_EFLEX_ACTION_IDs,
                                       &idx_min,
                                       &idx_max));

    /* Register profile. */
    profile_hdl = BCMI_LTSW_PROFILE_TRUNK_CTR_ING_EFLEX_ACTION;
    if (bcmi_ltsw_profile_register_check(unit, profile_hdl)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_unregister(unit, profile_hdl));
    }

    /* Reserve profile 0 for non-flex counter use. */
    ent_idx_min = (int)idx_min + 1;
    ent_idx_max = (int)idx_max;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit,
                                    &profile_hdl,
                                    &ent_idx_min,
                                    &ent_idx_max,
                                    1,
                                    trunk_flex_action_profile_entry_hash_cb,
                                    trunk_flex_action_profile_entry_cmp_cb));

exit:
    if (SHR_FUNC_ERR()) {
        profile_hdl = BCMI_LTSW_PROFILE_TRUNK_CTR_ING_EFLEX_ACTION;
        (void)bcmi_ltsw_profile_unregister(unit, profile_hdl);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TRUNK_CTR_ING_EFLEX_ACTIONs));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_clear(unit, TRUNK_FASTs));

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_clear(unit, TRUNK_FAILOVERs));

    /* Clear PORT_SYSTEM table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_clear_port_system(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_create(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_priv_info_t *t_priv)
{
    SHR_FUNC_ENTER(unit);

    t_priv->t_info->psc = BCM_TRUNK_PSC_PORTFLOW;

    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_params_validate(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member)
{
    SHR_FUNC_ENTER(unit);

    if (t_type != bcmintTrunkTypeFrontPanel) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_params_validate_fp(unit, t_id, trunk_info,
                                  member_count, member_array,
                                  op, member));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_priv_info_t *t_priv,
    bcm_trunk_info_t *trunk_info,
    int member_max,
    bcm_trunk_member_t *member_array,
    int *member_count)
{
    /*
     * To adapt the top level framework,
     * simply return SHR_E_NONE.
     */
    return SHR_E_NONE;
}

static int
bcm56990_a0_ltsw_trunk_find(
    int unit,
    bcm_gport_t gport,
    bcmint_trunk_id_t *t_id,
    bcmint_trunk_type_t *t_type)
{
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(t_id, SHR_E_PARAM);
    SHR_NULL_CHECK(t_type, SHR_E_PARAM);

    rv = trunk_find_fp(unit, gport, t_id);
    if (SHR_SUCCESS(rv)) {
        *t_type = bcmintTrunkTypeFrontPanel;
        SHR_EXIT();
    } else if (rv != SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(rv);
    }

    SHR_ERR_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_find_virtual(
    int unit,
    bcm_gport_t gport,
    int *vp_lag_vp)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56990_a0_ltsw_trunk_notify(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type)
{
    /*
     * To adapt the top level framework,
     * simply return SHR_E_NONE.
     */
    return SHR_E_NONE;
}

static int
bcm56990_a0_ltsw_trunk_failover_flags_extract(
    int unit,
    uint32_t flags,
    bcmint_trunk_type_t t_type,
    uint32_t *fail_flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_failover_flags_extract(unit, flags, t_type, fail_flags));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_failover_psc_validate(
    int unit,
    bcmint_trunk_type_t t_type,
    int psc)
{
    SHR_FUNC_ENTER(unit);

    switch (t_type) {
        case bcmintTrunkTypeFrontPanel:
            if (psc != BCM_TRUNK_PSC_PORTFLOW) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_failover_set(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_gport_t fail_port,
    int psc,
    int ftp_count,
    bcm_gport_t *ftp)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_failover_set(unit, t_id, t_type,
                            fail_port, psc, ftp_count, ftp));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_failover_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_gport_t fail_port,
    int *psc,
    int ftp_max,
    bcm_gport_t *ftp,
    int *ftp_count)
{
    uint32_t cnt;
    uint64_t value;
    const char *rtag;
    int lt_count, i, modport, dunit;
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    if (t_type != bcmintTrunkTypeFrontPanel) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (ftp_max < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (ftp_count) {
        *ftp_count = 0;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FAILOVERs, &lte_hdl));

    value = BCM_GPORT_MODPORT_PORT_GET(fail_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    if (psc) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(lte_hdl, RTAGs, &rtag));

        SHR_IF_ERR_VERBOSE_EXIT
            (trunk_failover_psc_encode(unit, rtag, psc));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, FAILOVER_CNTs, &value));
    lt_count = value & 0xffffffff;

    if ((lt_count > ftp_max) && (ftp_max > 0)) {
        lt_count = ftp_max;
    }

    if (ftp_count) {
        *ftp_count = lt_count;
    }

    if (ftp_max == 0) {
        SHR_EXIT();
    }

    for (i = 0; i < lt_count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(lte_hdl, FAILOVER_MODPORTs,
                                        i, &value, 1, &cnt));
        modport = value & 0xffffffff;

        BCM_GPORT_MODPORT_SET(ftp[i], 0, modport);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_failover_update(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    int psc,
    uint32_t fail_flags,
    bcm_gport_t fail_port,
    int ftp_max,
    int member_count,
    bcm_trunk_member_t *member_array)
{
    int i, j;
    int next, hw_count;
    bcm_gport_t *ftp = NULL;

    SHR_FUNC_ENTER(unit);

    if (t_type != bcmintTrunkTypeFrontPanel) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    for (i = 0; i < member_count; i++) {
        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            continue;
        }
        if (member_array[i].gport == fail_port) {
            break;
        }
    }

    if ((0 != member_count) && (i == member_count)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    if (member_count == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56990_a0_ltsw_trunk_failover_set(unit, t_id, t_type,
                                         fail_port, psc, 0, NULL));
        SHR_EXIT();
    }

    if (fail_flags) {
        switch (fail_flags) {
            case BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL:
                next = TRUE;
                break;
            case BCM_TRUNK_FLAG_FAILOVER_NEXT:
                next = TRUE;
                break;
            case BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL:
                next = FALSE;
                break;
            case BCM_TRUNK_FLAG_FAILOVER_ALL:
                next = FALSE;
                break;
            default:
                SHR_ERR_EXIT(SHR_E_PARAM);
        }

        SHR_ALLOC(ftp, sizeof(bcm_gport_t) * member_count, "bcmTrunkGport");
        SHR_NULL_CHECK(ftp, SHR_E_MEMORY);

        hw_count = 0;
        for (j = ((i + 1) % member_count);
             j != i;
             j = ((j + 1) % member_count)) {
            if (member_array[j].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }

            if (hw_count == ftp_max) {
                break;
            }

            ftp[hw_count++] = member_array[j].gport;

            if (next) {
                break;
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56990_a0_ltsw_trunk_failover_set(unit, t_id, t_type,
                                         fail_port, psc, hw_count, ftp));
        SHR_FREE(ftp);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
trunk_update_fp_failover(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    int i;
    bcm_gport_t fail_port;
    uint32_t fail_flags;
    bcmint_trunk_info_t *t_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56990_a0_ltsw_trunk_failover_flags_extract(
                            unit, trunk_info->flags,
                            bcmintTrunkTypeFrontPanel,
                            &fail_flags));

    if (fail_flags != 0 || member_count == 0) {
        for (i = 0; i < t_priv->t_info->member_count; i++) {
            fail_port = t_priv->member_array[i].gport;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56990_a0_ltsw_trunk_failover_update(unit, t_id,
                                                bcmintTrunkTypeFrontPanel,
                                                0, 0, fail_port, 0, 0, NULL));
        }
    }

    if (fail_flags != 0) {
        for (i = 0; i < member_count; i++) {
            fail_port = member_array[i].gport;
            if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56990_a0_ltsw_trunk_failover_update(unit, t_id,
                                                bcmintTrunkTypeFrontPanel,
                                                trunk_info->psc, fail_flags,
                                                fail_port, t_update->ftp_max,
                                                member_count, member_array));
        }
    } else {
        t_info = t_priv->t_info;
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_ltsw_trunk_failover_flags_extract(unit, t_info->flags,
                                                   bcmintTrunkTypeFrontPanel,
                                                   &fail_flags));
        if (fail_flags != 0) {
            trunk_info->flags |= fail_flags;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a front panel trunk failover with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
trunk_destroy_fp_failover(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    int i, member_count;
    bcmint_trunk_member_t *member_array;
    bcmint_trunk_info_t *t_info;
    uint32_t fail_flags;
    bcm_gport_t fail_port;

    SHR_FUNC_ENTER(unit);

    t_info = t_priv->t_info;
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_trunk_failover_flags_extract(unit, t_info->flags,
                                               bcmintTrunkTypeFrontPanel,
                                               &fail_flags));
    if (fail_flags != 0) {
        member_count = t_priv->t_info->member_count;
        member_array = t_priv->member_array;

        for (i = 0; i < member_count; i++) {
            fail_port = member_array[i].gport;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_lag_failover_enable_set(unit, fail_port, 0));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56990_a0_ltsw_trunk_failover_update(unit, t_id,
                                                        bcmintTrunkTypeFrontPanel,
                                                        0, 0, fail_port, 0, 0, NULL));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_destroy(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_priv_info_t *t_priv)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_destroy_fp_port_attr(unit, t_id, t_priv));

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_destroy_fp_group(unit, t_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_destroy_fp_failover(unit, t_id, t_priv));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_update(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    SHR_FUNC_ENTER(unit);

    /* Configure static load balancing */
    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_update_fp_group(unit, t_id, trunk_info,
                               member_count, member_array,
                               t_priv, t_update));

    /* Update source trunk map configuration */
    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_update_fp_member(unit, t_id, trunk_info,
                                member_count, member_array,
                                t_priv, t_update));

    /* Harware trunk failover */
    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_update_fp_failover(unit, t_id, trunk_info,
                                  member_count, member_array,
                                  t_priv, t_update));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_override_set(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_override_type_t o_type,
    int o_index,
    int enable)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56990_a0_ltsw_trunk_override_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_override_type_t o_type,
    int o_index,
    int *enable)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56990_a0_ltsw_trunk_member_status_set(
    int unit,
    bcm_port_t port,
    int status)
{
    SHR_FUNC_ENTER(unit);

    SHR_ERR_EXIT(SHR_E_UNAVAIL);

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_member_status_get(
    int unit,
    bcm_port_t port,
    int *status)
{
    SHR_FUNC_ENTER(unit);

    SHR_ERR_EXIT(SHR_E_UNAVAIL);

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_bitmap_expand(
    int unit,
    bcmint_trunk_pub_info_t *t_pub,
    bcm_pbmp_t *pbmp)
{
    int rv = SHR_E_NONE;
    bcmint_trunk_id_t t_id;
    bcm_pbmp_t out_pbmp;
    bcm_pbmp_t tpbm;
    bcm_pbmp_t in_pbmp;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(pbmp, SHR_E_PARAM);
    BCM_PBMP_CLEAR(out_pbmp);
    BCM_PBMP_ASSIGN(in_pbmp, *pbmp);

    for (t_id = 0; t_id < t_pub->ngroups_fp; t_id++) {
        rv = trunk_bitmap_get(unit,
                              t_id,
                              t_pub->nports_fp,
                              &out_pbmp);
        if (SHR_SUCCESS(rv)) {
            BCM_PBMP_ASSIGN(tpbm, in_pbmp);
            BCM_PBMP_AND(tpbm, out_pbmp);
            if (BCM_PBMP_NOT_NULL(tpbm)) {
                BCM_PBMP_OR(*pbmp, out_pbmp);
            }
        } else {
            continue;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_mcast_join(
    int unit,
    bcm_trunk_t t_id,
    bcm_vlan_t vid,
    bcm_mac_t mac)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56990_a0_ltsw_trunk_find_dlb_id(
    int unit,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    int *dlb_id)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56990_a0_ltsw_trunk_vp_lag_member_update(
    int unit,
    int vp_lag_vp,
    bcm_gport_t gport)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56990_a0_ltsw_trunk_vp_lag_vp_learn_get(
    int unit,
    int vp_lag_vp,
    uint32_t *flags)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56990_a0_ltsw_trunk_vp_lag_vp_learn_set(
    int unit,
    int vp_lag_vp,
    uint32_t flags)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56990_a0_ltsw_trunk_sc_hash_control_set(
    int unit,
    uint32_t arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_hash_control_set(unit,
                                TRUNK_HASH_CONTROL,
                                arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_sc_hash_control_get(
    int unit,
    uint32_t *arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_hash_control_get(unit,
                                TRUNK_HASH_CONTROL,
                                arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_sc_lb_control_unicast_set(
    int unit,
    uint32_t arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_hash_control_set(unit,
                                TRUNK_LB_CONTROL_UC_FLOW,
                                arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_sc_lb_control_unicast_get(
    int unit,
    uint32_t *arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_hash_control_get(unit,
                                TRUNK_LB_CONTROL_UC_FLOW,
                                arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_sc_lb_control_nonunicast_set(
    int unit,
    uint32_t arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_hash_control_set(unit,
                                TRUNK_LB_CONTROL_NUC_FLOW,
                                arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_sc_lb_control_nonunicast_get(
    int unit,
    uint32_t *arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_hash_control_get(unit,
                                TRUNK_LB_CONTROL_NUC_FLOW,
                                arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_flexctr_attach(
    int unit,
    bcm_trunk_t tid,
    bcmi_ltsw_flexctr_counter_info_t *info)
{
    trunk_flexctr_cfg_t flexctr;

    SHR_FUNC_ENTER(unit);

    sal_memset(&flexctr, 0, sizeof(trunk_flexctr_cfg_t));
    flexctr.op = TRUNK_FLXCTR_OP_SET;
    flexctr.flags = TRUNK_FLXCTR_F_ACTION;
    flexctr.action = info->action_index;

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_flexctr_op(unit, tid, &flexctr));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_flexctr_detach(
    int unit,
    bcm_trunk_t tid)
{
    trunk_flexctr_cfg_t flexctr;

    SHR_FUNC_ENTER(unit);

    sal_memset(&flexctr, 0, sizeof(trunk_flexctr_cfg_t));
    flexctr.op = TRUNK_FLXCTR_OP_SET;
    flexctr.flags = TRUNK_FLXCTR_F_ACTION;
    flexctr.action = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_flexctr_op(unit, tid, &flexctr));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_flexctr_info_get(
    int unit,
    bcm_trunk_t tid,
    bcmi_ltsw_flexctr_counter_info_t *info)
{
    int dunit;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    uint64_t val;
    trunk_flex_action_profile_t action_profile;

    SHR_FUNC_ENTER(unit);

    if (info->direction != BCMI_LTSW_FLEXCTR_DIR_INGRESS) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FASTs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TRUNK_IDs, tid));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit,
                              eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh,
                               TRUNK_CTR_ING_EFLEX_ACTION_IDs,
                               &val));

    if (val == 0) {
        info->action_index = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (trunk_flex_action_profile_get(unit, val, &action_profile));
        info->action_index = action_profile.action;
    }
    info->stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
    info->table_name = TRUNK_FASTs;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_flexctr_object_set(
    int unit,
    bcm_trunk_t tid,
    uint16_t value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_flexctr_object_set(unit, tid, value));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_trunk_flexctr_object_get(
    int unit,
    bcm_trunk_t tid,
    uint16_t *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (trunk_flexctr_object_get(unit, tid, value));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Trunk driver function variable for bcm56990_a0 device.
 */
static mbcm_ltsw_trunk_drv_t bcm56990_a0_ltsw_trunk_drv = {
    .trunk_pub_info_get = bcm56990_a0_ltsw_trunk_pub_info_get,
    .trunk_psc_compare = bcm56990_a0_ltsw_trunk_psc_compare,
    .trunk_init = bcm56990_a0_ltsw_trunk_init,
    .trunk_detach = bcm56990_a0_ltsw_trunk_detach,
    .trunk_clear = bcm56990_a0_ltsw_trunk_clear,
    .trunk_create = bcm56990_a0_ltsw_trunk_create,
    .trunk_params_validate = bcm56990_a0_ltsw_trunk_params_validate,
    .trunk_get = bcm56990_a0_ltsw_trunk_get,
    .trunk_update = bcm56990_a0_ltsw_trunk_update,
    .trunk_destroy = bcm56990_a0_ltsw_trunk_destroy,
    .trunk_find = bcm56990_a0_ltsw_trunk_find,
    .trunk_find_virtual = bcm56990_a0_ltsw_trunk_find_virtual,
    .trunk_notify = bcm56990_a0_ltsw_trunk_notify,
    .trunk_failover_flags_extract = bcm56990_a0_ltsw_trunk_failover_flags_extract,
    .trunk_failover_psc_validate = bcm56990_a0_ltsw_trunk_failover_psc_validate,
    .trunk_failover_set = bcm56990_a0_ltsw_trunk_failover_set,
    .trunk_failover_get = bcm56990_a0_ltsw_trunk_failover_get,
    .trunk_failover_update = bcm56990_a0_ltsw_trunk_failover_update,
    .trunk_override_set = bcm56990_a0_ltsw_trunk_override_set,
    .trunk_override_get = bcm56990_a0_ltsw_trunk_override_get,
    .trunk_member_status_set = bcm56990_a0_ltsw_trunk_member_status_set,
    .trunk_member_status_get = bcm56990_a0_ltsw_trunk_member_status_get,
    .trunk_bitmap_expand = bcm56990_a0_ltsw_trunk_bitmap_expand,
    .trunk_mcast_join = bcm56990_a0_ltsw_trunk_mcast_join,
    .trunk_find_dlb_id = bcm56990_a0_ltsw_trunk_find_dlb_id,
    .trunk_vp_lag_member_update = bcm56990_a0_ltsw_trunk_vp_lag_member_update,
    .trunk_vp_lag_vp_learn_get = bcm56990_a0_ltsw_trunk_vp_lag_vp_learn_get,
    .trunk_vp_lag_vp_learn_set = bcm56990_a0_ltsw_trunk_vp_lag_vp_learn_set,
    .trunk_sc_hash_control_set = bcm56990_a0_ltsw_trunk_sc_hash_control_set,
    .trunk_sc_hash_control_get = bcm56990_a0_ltsw_trunk_sc_hash_control_get,
    .trunk_sc_lb_control_unicast_set = bcm56990_a0_ltsw_trunk_sc_lb_control_unicast_set,
    .trunk_sc_lb_control_unicast_get = bcm56990_a0_ltsw_trunk_sc_lb_control_unicast_get,
    .trunk_sc_lb_control_nonunicast_set = bcm56990_a0_ltsw_trunk_sc_lb_control_nonunicast_set,
    .trunk_sc_lb_control_nonunicast_get = bcm56990_a0_ltsw_trunk_sc_lb_control_nonunicast_get,
    .trunk_flexctr_attach = bcm56990_a0_ltsw_trunk_flexctr_attach,
    .trunk_flexctr_detach = bcm56990_a0_ltsw_trunk_flexctr_detach,
    .trunk_flexctr_info_get = bcm56990_a0_ltsw_trunk_flexctr_info_get,
    .trunk_flexctr_object_set = bcm56990_a0_ltsw_trunk_flexctr_object_set,
    .trunk_flexctr_object_get = bcm56990_a0_ltsw_trunk_flexctr_object_get
};

/******************************************************************************
 * Public functions
 */

int
bcm56990_a0_ltsw_trunk_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_trunk_drv_set(unit, &bcm56990_a0_ltsw_trunk_drv));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Attach functions for other members.
 */
#define BCM56990_A0_DRV_ATTACH_ENTRY(_dn,_vn,_pf,_pd,_r0) \
int _vn##_ltsw_trunk_drv_attach(int unit) \
{ \
    SHR_FUNC_ENTER(unit); \
    SHR_IF_ERR_VERBOSE_EXIT \
        (mbcm_ltsw_trunk_drv_set(unit, &bcm56990_a0_ltsw_trunk_drv)); \
exit: \
    SHR_FUNC_EXIT(); \
}
#include "sub_devlist.h"
