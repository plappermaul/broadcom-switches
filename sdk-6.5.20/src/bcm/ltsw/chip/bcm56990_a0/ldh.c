/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm/latency_monitor.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/mbcm/ldh.h>
#include <bcm_int/ltsw/xgs/ldh.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/flexctr.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_LATENCY_MONITOR

/*! Number of monitor instance. */
#define LDH_MONITOR_INSTANCE_NUM 4

/*!
 * \brief Ingress and egress port bitmap info of monitor.
 */
typedef struct ldh_bitmap_info_s {

    /*! Source port bitmap */
    bcm_pbmp_t src_pbmp[LDH_MONITOR_INSTANCE_NUM];

    /*! Destination port bitmap */
    bcm_pbmp_t dest_pbmp[LDH_MONITOR_INSTANCE_NUM];

} ldh_bitmap_info_t;

static ldh_bitmap_info_t *bcm56990_a0_ltsw_ldh_mon_pbmp[BCM_MAX_NUM_UNITS];

/******************************************************************************
 * Private functions
 */

static int
bcm56990_a0_ltsw_ldh_init(int unit)
{
    int warm = bcmi_warmboot_get(unit);
    ldh_bitmap_info_t *pbmp_info = bcm56990_a0_ltsw_ldh_mon_pbmp[unit];
    bcm_pbmp_t pbm, *src_pbm, *dest_pbm;
    int mon_id, port_idx;
    bool enable = false;

    SHR_FUNC_ENTER(unit);

    if (!pbmp_info) {
        SHR_ALLOC(pbmp_info, sizeof(ldh_bitmap_info_t), "bcm56990LdhPbmpInfo");
        SHR_NULL_CHECK(pbmp_info, SHR_E_MEMORY);
        sal_memset(pbmp_info, 0, sizeof(ldh_bitmap_info_t));
        bcm56990_a0_ltsw_ldh_mon_pbmp[unit] = pbmp_info;
    }

    if (warm) {
        /* Restore the software database from HW */
        SHR_IF_ERR_EXIT
            (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_ALL, &pbm));
        for (mon_id = 0; mon_id < LDH_MONITOR_INSTANCE_NUM; mon_id++) {
            src_pbm = &pbmp_info->src_pbmp[mon_id];
            dest_pbm = &pbmp_info->dest_pbmp[mon_id];
            BCM_PBMP_ITER(pbm, port_idx) {
                SHR_IF_ERR_EXIT
                    (xgs_ltsw_ldh_monitor_port_enable_get(unit, port_idx,
                                                          true, mon_id,
                                                          &enable));
                if (enable) {
                    BCM_PBMP_PORT_ADD(*src_pbm, port_idx);
                }
                SHR_IF_ERR_EXIT
                    (xgs_ltsw_ldh_monitor_port_enable_get(unit, port_idx,
                                                          false, mon_id,
                                                          &enable));
                if (enable) {
                    BCM_PBMP_PORT_ADD(*dest_pbm, port_idx);
                }
            }
        }
    } else {
        /* Clear Monitor configurations in HW and software database */
        SHR_IF_ERR_EXIT
            (xgs_ltsw_ldh_monitor_table_clear(unit));
        for (mon_id = 0; mon_id < LDH_MONITOR_INSTANCE_NUM; mon_id++) {
            src_pbm = &pbmp_info->src_pbmp[mon_id];
            dest_pbm = &pbmp_info->dest_pbmp[mon_id];
            BCM_PBMP_CLEAR(*src_pbm);
            BCM_PBMP_CLEAR(*dest_pbm);
        }
    }
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_ldh_detach(int unit)
{
    ldh_bitmap_info_t *pbmp_info = bcm56990_a0_ltsw_ldh_mon_pbmp[unit];

    SHR_FUNC_ENTER(unit);

    if (pbmp_info == NULL) {
        SHR_EXIT();
    }
    SHR_FREE(pbmp_info);
    bcm56990_a0_ltsw_ldh_mon_pbmp[unit] = NULL;
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_ldh_monitor_enable(
    int unit,
    uint8_t monitor_id,
    uint8_t enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_ldh_monitor_enable(unit, monitor_id, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_ldh_monitor_config_set(
    int unit,
    uint8_t monitor_id,
    bcm_latency_monitor_config_t *config)
{
    ldh_bitmap_info_t *pbmp_info = bcm56990_a0_ltsw_ldh_mon_pbmp[unit];
    bcm_pbmp_t pbm, *src_pbm, *dest_pbm, temp_pbmp;
    int port_idx;

    SHR_FUNC_ENTER(unit);

    if (pbmp_info == NULL) {
        SHR_EXIT();
    }
    src_pbm = &pbmp_info->src_pbmp[monitor_id];
    dest_pbm = &pbmp_info->dest_pbmp[monitor_id];

    SHR_IF_ERR_EXIT
        (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_ALL, &pbm));

    /* Get the changed bitmap and configure accordingly */
    BCM_PBMP_ASSIGN(temp_pbmp, config->src_pbmp);
    BCM_PBMP_XOR(temp_pbmp, *src_pbm);
    BCM_PBMP_ITER(temp_pbmp, port_idx) {
        if (BCM_PBMP_MEMBER(config->src_pbmp, port_idx)) {
            SHR_IF_ERR_EXIT
                (xgs_ltsw_ldh_monitor_port_enable_set(unit, port_idx,
                                                      true, monitor_id,
                                                      true));
        } else {
            SHR_IF_ERR_EXIT
                (xgs_ltsw_ldh_monitor_port_enable_set(unit, port_idx,
                                                      true, monitor_id,
                                                      false));
        }
    }
    BCM_PBMP_ASSIGN(*src_pbm, config->src_pbmp);

    BCM_PBMP_ASSIGN(temp_pbmp, config->dest_pbmp);
    BCM_PBMP_XOR(temp_pbmp, *dest_pbm);
    BCM_PBMP_ITER(temp_pbmp, port_idx) {
        if (BCM_PBMP_MEMBER(config->dest_pbmp, port_idx)) {
            SHR_IF_ERR_EXIT
                (xgs_ltsw_ldh_monitor_port_enable_set(unit, port_idx,
                                                      false, monitor_id,
                                                      true));
        } else {
            SHR_IF_ERR_EXIT
                (xgs_ltsw_ldh_monitor_port_enable_set(unit, port_idx,
                                                      false, monitor_id,
                                                      false));
        }
    }
    BCM_PBMP_ASSIGN(*dest_pbm, config->dest_pbmp);

    SHR_IF_ERR_EXIT
        (xgs_ltsw_ldh_monitor_count_mode_set(unit, monitor_id,
                                             config->count_mode));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_ldh_monitor_config_get(
    int unit,
    uint8_t monitor_id,
    bcm_latency_monitor_config_t *config)
{
    ldh_bitmap_info_t *pbmp_info = bcm56990_a0_ltsw_ldh_mon_pbmp[unit];
    bcm_pbmp_t *src_pbm, *dest_pbm;

    SHR_FUNC_ENTER(unit);

    if (pbmp_info == NULL) {
        SHR_EXIT();
    }
    src_pbm = &pbmp_info->src_pbmp[monitor_id];
    dest_pbm = &pbmp_info->dest_pbmp[monitor_id];

    SHR_IF_ERR_EXIT
        (xgs_ltsw_ldh_monitor_count_mode_get(unit, monitor_id,
                                             &config->count_mode));
    /* Get from software database. */
    BCM_PBMP_ASSIGN(config->src_pbmp,*src_pbm);
    BCM_PBMP_ASSIGN(config->dest_pbmp,*dest_pbm);
    config->mode = bcmLatencyMonitorFlexCtrMode;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_ldh_monitor_stat_attach(
    int unit,
    uint8_t monitor_id,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t info = {0};
    uint32_t ctr_act = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (xgs_ltsw_ldh_monitor_count_action_get(unit, monitor_id,
                                               &ctr_act));
    if (ctr_act) {
        SHR_ERR_EXIT(SHR_E_EXISTS);
    }

    SHR_IF_ERR_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit,
                                               stat_counter_id,
                                               &info));

    SHR_IF_ERR_EXIT
        (bcmi_ltsw_flexctr_attach_counter_id_status_update(unit,
                                                           stat_counter_id));

    SHR_IF_ERR_CONT
        (xgs_ltsw_ldh_monitor_count_action_set(unit, monitor_id,
                                               info.action_index));

    if (SHR_FUNC_ERR()) {
        (void)bcmi_ltsw_flexctr_detach_counter_id_status_update(
                unit, stat_counter_id);
        SHR_EXIT();
    }
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_ldh_monitor_stat_id_get(
    int unit,
    uint8_t monitor_id,
    uint32_t *stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t info = {0};
    uint32_t ctr_act = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (xgs_ltsw_ldh_monitor_count_action_get(unit, monitor_id,
                                               &ctr_act));
    if (ctr_act == 0) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }
    info.action_index = ctr_act;
    info.direction = BCMI_LTSW_FLEXCTR_DIR_EGRESS;
    info.source = bcmFlexctrSourceLatencyMonitor;
    info.table_name = MON_LDH_CONTROLs;
    info.stage = BCMI_LTSW_FLEXCTR_STAGE_EGR_CTR;

    SHR_IF_ERR_EXIT
        (bcmi_ltsw_flexctr_counter_id_get(unit, &info, stat_counter_id));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_ldh_monitor_stat_detach(
    int unit,
    uint8_t monitor_id)
{
    uint32_t stat_counter_id;
    bcmi_ltsw_flexctr_counter_info_t info = {0};

    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (bcm56990_a0_ltsw_ldh_monitor_stat_id_get(unit, monitor_id,
                                                  &stat_counter_id));

    SHR_IF_ERR_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit,
                                               stat_counter_id,
                                               &info));

    SHR_IF_ERR_EXIT
        (xgs_ltsw_ldh_monitor_count_action_set(unit, monitor_id,
                                               0));
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                           stat_counter_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_ldh_monitor_id_check(
    int unit,
    uint8_t monitor_id)
{
    SHR_FUNC_ENTER(unit);
    if (monitor_id < 0 || monitor_id >= LDH_MONITOR_INSTANCE_NUM) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_ldh_monitor_config_check(
    int unit,
    uint8_t monitor_id,
    bcm_latency_monitor_config_t *config)
{
    bcm_pbmp_t src_pbmp, dest_pbmp, pbm;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(config, SHR_E_PARAM);

    if (monitor_id < 0 || monitor_id >= LDH_MONITOR_INSTANCE_NUM) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (config->mode != bcmLatencyMonitorFlexCtrMode) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((config->count_mode < bcmLatencyMonitorCutThrough) ||
        (config->count_mode > bcmLatencyMonitorCountAll)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Check if src_pbmp and dest_pbmp are valid. */
       SHR_IF_ERR_EXIT
           (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_ALL, &pbm));
       BCM_PBMP_ASSIGN(src_pbmp, pbm);
       BCM_PBMP_ASSIGN(dest_pbmp, pbm);
       BCM_PBMP_AND(src_pbmp, config->src_pbmp);
       BCM_PBMP_AND(dest_pbmp, config->dest_pbmp);
       if(!(BCM_PBMP_EQ(src_pbmp, config->src_pbmp) && BCM_PBMP_EQ(dest_pbmp, config->dest_pbmp))) {
           SHR_ERR_EXIT(SHR_E_PARAM);
       }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Ldh driver function variable for bcm56990_a0 device.
 */
static mbcm_ltsw_ldh_drv_t bcm56990_a0_ltsw_ldh_drv = {
    .ldh_init = bcm56990_a0_ltsw_ldh_init,
    .ldh_detach = bcm56990_a0_ltsw_ldh_detach,
    .ldh_monitor_enable = bcm56990_a0_ltsw_ldh_monitor_enable,
    .ldh_monitor_config_set = bcm56990_a0_ltsw_ldh_monitor_config_set,
    .ldh_monitor_config_get = bcm56990_a0_ltsw_ldh_monitor_config_get,
    .ldh_monitor_stat_attach = bcm56990_a0_ltsw_ldh_monitor_stat_attach,
    .ldh_monitor_stat_id_get = bcm56990_a0_ltsw_ldh_monitor_stat_id_get,
    .ldh_monitor_stat_detach = bcm56990_a0_ltsw_ldh_monitor_stat_detach,
    .ldh_monitor_id_check = bcm56990_a0_ltsw_ldh_monitor_id_check,
    .ldh_monitor_config_check = bcm56990_a0_ltsw_ldh_monitor_config_check
};

/******************************************************************************
 * Public functions
 */

int
bcm56990_a0_ltsw_ldh_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_ldh_drv_set(unit, &bcm56990_a0_ltsw_ldh_drv));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Attach functions for other members.
 */
#define BCM56990_A0_DRV_ATTACH_ENTRY(_dn,_vn,_pf,_pd,_r0) \
int _vn##_ltsw_ldh_drv_attach(int unit) \
{ \
    SHR_FUNC_ENTER(unit); \
    SHR_IF_ERR_VERBOSE_EXIT \
        (mbcm_ltsw_ldh_drv_set(unit, &bcm56990_a0_ltsw_ldh_drv)); \
exit: \
    SHR_FUNC_EXIT(); \
}
#include "sub_devlist.h"
