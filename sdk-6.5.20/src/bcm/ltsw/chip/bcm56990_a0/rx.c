/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm/rx.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/mbcm/rx.h>

#include <bcm_int/ltsw/cosq.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/switch.h>
#include <shr/shr_debug.h>
#include <shr/shr_bitop.h>
#include <sal/sal_libc.h>
#include <sal/sal_mutex.h>
#include <bcmlt/bcmlt.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_RX

/******************************************************************************
 * Private functions
 */


#define PRIORITY_MAX_VALUE 0x80

#define UNICAST_SWITCHED 2

#define NONUNICAST_SWITCHED 3

#define RESERVED ""

/*
 * Only CMC0 is used for BCM RX hence we can have
 * CMICX_N_DMA_CHAN number of maximum rx channels
 */
#define CMICX_N_DMA_CHAN 8
#define MAX_CMC 2

/*
 * Drop Event definitions which are available for copy to cpu usage.
 */
typedef struct rx_cos_reason_s {
    /* mapping to KEY field. */
    char *key;

    /* mapping to MASK field. */
    char *mask;

    /* packet reason for forward to CPU. */
    bcm_rx_reason_t reason;
} rx_cos_reason_t;

static rx_cos_reason_t rx_cos_reason_map[] =
{
    /*bit  { key,         mask,              reason } */
    /*7*/  {AMT_CONTROLs, AMT_CONTROL_MASKs, bcmRxReasonTunnelControl},
    /*8*/  {BFD_ERRORs, BFD_ERROR_MASKs, bcmRxReasonBfd},
    /*9*/  {BFD_SLOWPATHs, BFD_SLOWPATH_MASKs, bcmRxReasonBfdSlowpath},
    /*10*/ {CBSM_PREVENTEDs, CBSM_PREVENTED_MASKs, bcmRxReasonClassBasedMove},
    /*11*/ {DLB_MONITORs, DLB_MONITOR_MASKs, bcmRxReasonDLBMonitor},
    /*12*/ {L2_DST_LOOKUP_FAILUREs, L2_DST_LOOKUP_FAILURE_MASKs, bcmRxReasonL2DestMiss},
    /*13*/ {DOS_ATTACKs, DOS_ATTACK_MASKs, bcmRxReasonDosAttack},
    /*14*/ {ETRAP_MONITORs, ETRAP_MONITOR_MASKs, bcmRxReasonETrapMonitor},
    /*15*/ {FP_INGs, FP_ING_MASKs, bcmRxReasonFilterMatch},
    /*16*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*17*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*18*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*19*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*20*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*21*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*22*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*23*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*24*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*25*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*26*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*27*/ {ICMP_REDIRECTs, ICMP_REDIRECT_MASKs, bcmRxReasonIcmpRedirect},
    /*28*/ {IEEE1588_UNKNOWN_VERSIONs,
            IEEE1588_UNKNOWN_VERSION_MASKs,
            bcmRxReasonTimesyncUnknownVersion},
    /* 22:INSTRUMENT_OFFSET unsupported */
    /*29*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*30*/ {INBAND_TELEMETRY_HOP_LIMITs,
            INBAND_TELEMETRY_HOP_LIMIT_MASKs,
            bcmRxReasonIntHopLimit},
    /*31*/ {INBAND_TELEMETRY_TURN_AROUNDs,
            INBAND_TELEMETRY_TURN_AROUND_MASKs,
            bcmRxReasonIntTurnAround},
    /*32*/ {IP_MC_L3_IIF_MISMATCHs,
            IP_MC_L3_IIF_MISMATCH_MASKs,
            bcmRxReasonIpmcInterfaceMismatch},
    /*33*/ {IP_MC_MISSs, IP_MC_MISS_MASKs, bcmRxReasonIpMcastMiss},
    /*34*/ {IP_OPTIONS_PKTs, IP_OPTIONS_PKT_MASKs, bcmRxReasonL3Slowpath},
    /*35*/ {L2s, L2_MASKs, bcmRxReasonL2Cpu},
    /* 29:L2GRE_SIP_MISS unsupported */
    /*36*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /* 30:L2GRE_VPNID_MISS unsupported */
    /*37*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*38*/ {L2_MOVEs, L2_MOVE_MASKs, bcmRxReasonL2Move},
    /*39*/ {L3_DST_MISSs, L3_DST_MISS_MASKs, bcmRxReasonL3DestMiss},
    /*40*/ {L3_HDR_ERRs, L3_HDR_ERR_MASKs, bcmRxReasonL3HeaderError},
    /*41*/ {L3_SRC_MISSs, L3_SRC_MISS_MASKs, bcmRxReasonL3SourceMiss},
    /*42*/ {L3_SRC_MOVEs, L3_SRC_MOVE_MASKs, bcmRxReasonL3SourceMove},
    /*43*/ {L3_MTU_CHECK_FAILs, L3_MTU_CHECK_FAIL_MASKs, bcmRxReasonL3MtuFail},
    /*44*/ {MAC_IP_BIND_LOOKUP_MISS_DROPs,
            MAC_IP_BIND_LOOKUP_MISS_DROP_MASKs,
            bcmRxReasonL3AddrBindFail},
    /*45*/ {MARTIAN_ADDRs, MARTIAN_ADDR_MASKs, bcmRxReasonMartianAddr},
    /*46*/ {MC_ID_ERRORs, MC_ID_ERROR_MASKs, bcmRxReasonMcastIdxError},
    /*47*/ {L2_MC_MISSs, L2_MC_MISS_MASKs, bcmRxReasonMcastMiss},
    /*48*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*49*/ {MPLS_ALERT_LABEL_EXPOSEDs,
            MPLS_ALERT_LABEL_EXPOSED_MASKs,
            bcmRxReasonMplsRouterAlertLabel},
    /*50*/ {MPLS_ILLEGAL_RESERVED_LABELs,
            MPLS_ILLEGAL_RESERVED_LABEL_MASKs,
            bcmRxReasonMplsIllegalReservedLabel},
    /*51*/ {MPLS_INVALID_ACTIONs,
            MPLS_INVALID_ACTION_MASKs,
            bcmRxReasonMplsInvalidAction},
    /*52*/ {MPLS_INVALID_PAYLOADs,
            MPLS_INVALID_PAYLOAD_MASKs,
            bcmRxReasonMplsInvalidPayload},
    /*53*/ {MPLS_LABEL_MISSs, MPLS_LABEL_MISS_MASKs, bcmRxReasonMplsLabelMiss},
    /*54*/ {RESERVED, RESERVED, bcmRxReasonInvalid}, /* bcmRxReasonMplsSequenceNumber */
    /*55*/ {MPLS_TTL_CHECK_FAILs,
            MPLS_TTL_CHECK_FAIL_MASKs,
            bcmRxReasonMplsTtl},
    /*56*/ {MPLS_UNKNOWN_ACH_TYPEs,
            MPLS_UNKNOWN_ACH_TYPE_MASKs,
            bcmRxReasonMplsUnknownAch}, /* bcmRxReasonMplsUnknownAch */
    /*57*/ {L2_MY_STATION_HITs, L2_MY_STATION_HIT_MASKs, bcmRxReasonStation},
    /*58*/ {NHOPs, NHOP_MASKs, bcmRxReasonNhop},
    /*59*/ {RESERVED, RESERVED, bcmRxReasonInvalid}, /* bcmRxReasonOAMError */
    /*60*/ {RESERVED, RESERVED, bcmRxReasonInvalid}, /* bcmRxReasonOAMSlowpath */
    /*61*/ {PKT_TRACEs,
            PKT_TRACE_MASKs,
#if 1
            bcmRxReasonReserved0,
#endif
           },
    /*62*/ {PARITY_ERRORs, PARITY_ERROR_MASKs, bcmRxReasonParityError},
    /*63*/ {PBT_NONUC_PKTs, PBT_NONUC_PKT_MASKs, bcmRxReasonL2NonUnicastMiss},
    /*64*/ {ARP_PROTOCOLs, ARP_PROTOCOL_MASKs, bcmRxReasonArp},
    /*65*/ {BPDU_PROTOCOLs, BPDU_PROTOCOL_MASKs, bcmRxReasonBpdu},
    /*66*/ {DHCP_PROTOCOLs, DHCP_PROTOCOL_MASKs, bcmRxReasonDhcp},
    /*67*/ {IGMP_PROTOCOLs, IGMP_PROTOCOL_MASKs, bcmRxReasonIgmp},
    /*68*/ {IPMC_RSVD_PROTOCOLs, IPMC_RSVD_PROTOCOL_MASKs, bcmRxReasonIpmcReserved},
    /*69*/ {L2_PROTOs, L2_PROTO_MASKs, bcmRxReasonL2Marked},
    /*70*/ {MMRP_PROTOCOLs, MMRP_PROTOCOL_MASKs, bcmRxReasonMmrp},
    /*71*/ {SRP_PROTOCOLs, SRP_PROTOCOL_MASKs, bcmRxReasonSrp},
    /*72*/ {PVLAN_MISMATCHs, PVLAN_MISMATCH_MASKs, bcmRxReasonSharedVlanMismatch},
    /*73*/ {SFLOW_EGR_SAMPLEs, SFLOW_EGR_SAMPLE_MASKs, bcmRxReasonSampleDest},
    /*74*/ {SFLOW_FLEX_SAMPLEs, SFLOW_FLEX_SAMPLE_MASKs, bcmRxReasonSampleSourceFlex},
    /*75*/ {SFLOW_ING_SAMPLEs, SFLOW_ING_SAMPLE_MASKs, bcmRxReasonSampleSource},
    /*76*/ {L2_SRC_LOOKUP_FAILUREs,
            L2_SRC_LOOKUP_FAILURE_MASKs,
            bcmRxReasonL2SourceMiss},
    /*77*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*78*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*79*/ {TIME_SYNCs, TIME_SYNC_MASKs, bcmRxReasonTimeSync},
    /*80*/ {TTL_1s, TTL_1_MASKs, bcmRxReasonTtl1},
    /*81*/ {ECN_TNL_DECAPs, ECN_TNL_DECAP_MASKs, bcmRxReasonTunnelDecapEcnError},
    /*82*/ {TNL_ERRs, TNL_ERR_MASKs, bcmRxReasonTunnelError},
    /*83*/ {RESERVED, RESERVED, bcmRxReasonInvalid},
    /*84*/ {URPF_FAILs, URPF_FAIL_MASKs, bcmRxReasonUrpfFail},
    /*85*/ {UNKNOWN_VLANs, UNKNOWN_VLAN_MASKs, bcmRxReasonUnknownVlan},
    /*86*/ {VFPs, VFP_MASKs,bcmRxReasonVlanFilterMatch},
    /*87*/ {RESERVED, RESERVED, bcmRxReasonInvalid}, /* bcmRxReasonVxlanVpnIdMiss */
    /*88*/ {VLAN_XLATE_MISSs, VLAN_XLATE_MISS_MASKs, bcmRxReasonVlanTranslate},
};

/*
 * \brief Populate TM_COS_QUEUE_CPU_MAP entry.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] TM_COS_QUEUE_CPU_MAP structure.
 * \param [bool] key_only Only populate key.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
rx_cosq_mapping_entry_populate(int unit,
                               bcmlt_entry_handle_t eh,
                               bcm_rx_cosq_mapping_t *mapping,
                               bool key_only)
{
    uint32_t key_table_len, key_idx, key_num = 0;
    bcm_rx_reason_t reason_enum;
    bcm_rx_reasons_t reasons_remain;
    uint8 sw_pkt_type_key = 0;
    uint8 sw_pkt_type_mask = 0;
    char *pkt_type = NOT_SWITCHEDs;
    bool mirr = false;

    SHR_FUNC_ENTER(unit);

    key_table_len = COUNTOF(rx_cos_reason_map);
    reasons_remain = mapping->reasons_mask;

    LOG_VERBOSE(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                            "RX COS reason table size=%d\n"),
                 key_table_len));

    for (key_idx = 0; key_idx < key_table_len; key_idx++) {
        reason_enum = rx_cos_reason_map[key_idx].reason;

        if (reason_enum == bcmRxReasonInvalid) {
            continue;
        }

        /* set reason key */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eh,
                                   rx_cos_reason_map[key_idx].key,
                                   BCM_RX_REASON_GET(mapping->reasons,
                                                     reason_enum) ? 1 : 0));
        /* set reason mask */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eh,
                                   rx_cos_reason_map[key_idx].mask,
                                   BCM_RX_REASON_GET(mapping->reasons_mask,
                                                     reason_enum) ? 1 : 0));

        if (BCM_RX_REASON_GET(mapping->reasons_mask, reason_enum)) {
            BCM_RX_REASON_CLEAR(reasons_remain, reason_enum);
        }

        key_num++;

        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit,
                                "RX COS reason[%d]: key=%s value=%d "
                                "mask=%s value=%d\n"),
                     key_idx,
                     rx_cos_reason_map[key_idx].key,
                     BCM_RX_REASON_GET(mapping->reasons,
                                       reason_enum) ? 1 : 0,
                     rx_cos_reason_map[key_idx].mask,
                     BCM_RX_REASON_GET(mapping->reasons_mask,
                                       reason_enum) ? 1 : 0));
    }

    /* check whether there are reasons unsupported */
    if (!BCM_RX_REASON_IS_NULL(reasons_remain)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Handle priority when int_prio_mask != 0 */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh,
                               INT_PRIs,
                               mapping->int_prio & 0xf));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh,
                               INT_PRI_MASKs,
                               mapping->int_prio_mask & 0xf));
    key_num++;
    LOG_VERBOSE(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                            "RX COS reason: key=%s value=%d "
                            "mask=%s value=%d\n"),
                 INT_PRIs, mapping->int_prio & 0xf,
                 INT_PRI_MASKs, mapping->int_prio_mask & 0xf));

    /* Program the packet type */
    if (mapping->packet_type & BCM_RX_COSQ_PACKET_TYPE_NON_UNICAST) {
        sw_pkt_type_key |= 1;
    }
    if (mapping->packet_type & BCM_RX_COSQ_PACKET_TYPE_SWITCHED) {
        sw_pkt_type_key |= 2;
    }
    if (mapping->packet_type_mask & BCM_RX_COSQ_PACKET_TYPE_NON_UNICAST) {
        sw_pkt_type_mask |= 1;
    }
    if (mapping->packet_type_mask & BCM_RX_COSQ_PACKET_TYPE_SWITCHED) {
        sw_pkt_type_mask |= 2;
    }
    sw_pkt_type_key &= sw_pkt_type_mask;

    if ((sw_pkt_type_mask == 0x1) ||
        ((sw_pkt_type_mask != 0) && (sw_pkt_type_key == 0x1))) {
        /* Hw doesn't support these cases */
        return SHR_E_PARAM;
    }

    if (sw_pkt_type_key == UNICAST_SWITCHED) {
        pkt_type = UNICAST_SWITCHEDs;
    } else if (sw_pkt_type_key == NONUNICAST_SWITCHED) {
        pkt_type = NON_UNICAST_SWITCHEDs;
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(eh,
                                      SWITCHED_PKT_TYPEs,
                                      pkt_type));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh,
                               SWITCHED_PKT_TYPE_MASKs,
                               sw_pkt_type_mask));
    key_num++;
    LOG_VERBOSE(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                            "RX COS reason: key=%s value=%s "
                            "mask=%s value=0x%x\n"),
                 SWITCHED_PKT_TYPEs, pkt_type,
                 SWITCHED_PKT_TYPE_MASKs, sw_pkt_type_mask));

    if (mapping->packet_type_mask & BCM_RX_COSQ_PACKET_TYPE_MIRROR) {
        mirr = true;
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh,
                               MIRRORs,
                               mirr));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh,
                               MIRROR_MASKs,
                               mirr));
    key_num++;
    LOG_VERBOSE(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                            "RX COS reason: key=%s value=%d "
                            "mask=%s value=%d\n"),
                 MIRRORs, mirr,
                 MIRROR_MASKs,
                 mirr));

    LOG_VERBOSE(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                            "RX COS reason key num=%d\n"),
                 key_num));

    if (!key_only) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eh,
                                   ENTRY_PRIORITYs,
                                   mapping->priority));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eh,
                                   TRUNCATE_CPU_COPYs,
                                   (mapping->flags &
                                    BCM_RX_COPYTOCPU_TRUNCATE) ? 1 : 0));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eh, COSs, mapping->cosq));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eh, CPU_Q_HI_PRIs, 0));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eh, STRENGTHs, 0x7f));
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Parse TM_COS_QUEUE_CPU_MAP entry.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] TM_COS_QUEUE_CPU_MAP structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
rx_cosq_mapping_entry_parse(int unit,
                            bcmlt_entry_handle_t eh,
                            bcm_rx_cosq_mapping_t *mapping)
{
    uint64_t data = 0LL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eh, ENTRY_PRIORITYs, &data));
    mapping->priority = data;

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eh, TRUNCATE_CPU_COPYs, &data));
    mapping->flags = (data == 1) ? BCM_RX_COPYTOCPU_TRUNCATE : 0;

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eh, COSs, &data));
    mapping->cosq = data;

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief handle a cos mapping.
 *
 * \param [in] unit Unit number
 * \param [in] opcode operation code
 * \param [in] mapping rx cosq mapping info.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
rx_cosq_mapping_handle(int unit,
                       bcmlt_opcode_t opcode,
                       bcm_rx_cosq_mapping_t *mapping)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    const char *tbl_name;
    bool key_only;
    int dunit;
    const char *opc[5] = {"NONE", "INSERT", "LOOKUP", "DEL", "UPDATE"};

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    tbl_name = TM_COS_Q_CPU_MAPs;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, tbl_name, &eh));

    LOG_VERBOSE(BSL_LOG_MODULE,
                (BSL_META_U(unit,
                            "RX COS handle opc %s\n"),
                 opc[opcode]));

    switch (opcode) {
        case BCMLT_OPCODE_INSERT:
        case BCMLT_OPCODE_UPDATE:
            key_only = false;
            break;
        case BCMLT_OPCODE_LOOKUP:
        case BCMLT_OPCODE_DELETE:
            key_only = true;
            break;
        default:
            SHR_IF_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (rx_cosq_mapping_entry_populate(unit, eh, mapping, key_only));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh, opcode, BCMLT_PRIORITY_NORMAL));

    if (opcode == BCMLT_OPCODE_LOOKUP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (rx_cosq_mapping_entry_parse(unit, eh, mapping));
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}


static int
bcm56990_a0_ltsw_rx_cosq_mapping_extended_add(
    int unit,
    uint32 options,
    bcm_rx_cosq_mapping_t *rx_cosq_mapping)
{
    bcmlt_opcode_t op;
    int port;
    int cpu_cos_number;

    SHR_FUNC_ENTER(unit);

    port = bcmi_ltsw_port_cpu(unit);
    cpu_cos_number = bcmi_ltsw_cosq_port_num_cos(unit, port);

    /* Verify COSQ */
    if (rx_cosq_mapping->cosq >= cpu_cos_number) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Verify the priority */
    if (rx_cosq_mapping->priority < 0 ||
        rx_cosq_mapping->priority > PRIORITY_MAX_VALUE) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    op = (options & BCM_RX_COSQ_MAPPING_OPTIONS_REPLACE) ? BCMLT_OPCODE_UPDATE :
                                                           BCMLT_OPCODE_INSERT;

    SHR_IF_ERR_VERBOSE_EXIT
        (rx_cosq_mapping_handle(unit,
                                op,
                                rx_cosq_mapping));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_rx_cosq_mapping_extended_delete(
    int unit,
    bcm_rx_cosq_mapping_t *rx_cosq_mapping)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (rx_cosq_mapping_handle(unit,
                                BCMLT_OPCODE_DELETE,
                                rx_cosq_mapping));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_rx_cosq_mapping_extended_delete_all(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TM_COS_Q_CPU_MAPs));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_rx_cosq_mapping_extended_get(
    int unit,
    bcm_rx_cosq_mapping_t *rx_cosq_mapping)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (rx_cosq_mapping_handle(unit,
                                BCMLT_OPCODE_LOOKUP,
                                rx_cosq_mapping));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_rx_queue_channel_get(
    int unit,
    bcm_cos_queue_t queue_id,
    bcm_rx_chan_t *chan_id)
{
    int channel_id;
    bool enable = false;
    int rv = SHR_E_NONE;
    bcmi_ltsw_cosq_device_info_t device_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    if (queue_id < 0 || queue_id >= device_info.num_cpu_queue) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    *chan_id = -1;

    for (channel_id = 0; channel_id < (MAX_CMC *CMICX_N_DMA_CHAN); channel_id++) {
        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_ltsw_rx_queue_channel_get(unit, queue_id, channel_id, &enable),
             SHR_E_NOT_FOUND);

        if (enable) {
            if (*chan_id == -1) {
                *chan_id = channel_id;
            } else {
                LOG_WARN(BSL_LOG_MODULE,
                    (BSL_META_U(unit,
                                "rx_queue_channel_get: Warning: "
                                "Multiple channels assigned to the "
                                "COS 0x%x for unit %d\n"),
                                queue_id, unit));
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
            }
        }
    }

    rv = ((*chan_id == -1)? SHR_E_NOT_FOUND : SHR_E_NONE);
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_rx_queue_channel_set(
    int unit,
    bcm_cos_queue_t queue_id,
    bcm_rx_chan_t chan_id)
{
    bcmi_ltsw_cosq_device_info_t device_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    if (-1 == chan_id) {
        if (-1 == queue_id) {
            /* May not disable all queues */
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    } else if ((chan_id < 0) || (chan_id >= (MAX_CMC * CMICX_N_DMA_CHAN))) {
        /* Verify the chan id */
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    } else if (queue_id >= device_info.num_cpu_queue) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (chan_id < CMICX_N_DMA_CHAN) {
        /*
         * This function does two things:
         * 1. Tests whether the corresponding COS_BMP bit is set or not.
         * 2. Tests whether the queue corresponding to given cos is
         *     mapped to correct L0 or not.
         *
         * L0.0 is associated with CMC0 CH1(Rx) (pci)
         * L0.1 is associated with CMC0 CH2(Rx) (pci)
         * L0.2 is associated with CMC0 CH3(Rx) (pci)
         * L0.3 is associated with CMC0 CH4(Rx) (pci)
         * L0.4 is associated with CMC0 CH5(Rx) (pci)
         * L0.5 is associated with CMC0 CH6(Rx) (pci)
         * L0.6 is associated with CMC0 CH7(Rx) (pci)
         * L0.7 is associated with CMC1 CHx(Rx) (uc0)
         * L0.8 is associated with CMC1 CHx(Rx) (uC1)
         * L0.11 is reserved
         */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_rx_queue_channel_set_test(unit, queue_id, chan_id));
    } else {
        if (queue_id < 0) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_rx_queue_channel_set(unit, queue_id, chan_id, TRUE));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_rx_init(int unit)
{
    return SHR_E_NONE;
}

static int
bcm56990_a0_ltsw_rx_detach(int unit)
{
    int warm = bcmi_warmboot_get(unit);

    if (!warm) {
        (void)bcmi_lt_clear(unit, TM_COS_Q_CPU_MAPs);
    }

    return SHR_E_NONE;
}

/*!
 * \brief Rx driver function variable for bcm56990_a0 device.
 */
static mbcm_ltsw_rx_drv_t bcm56990_a0_ltsw_rx_drv = {
    .rx_cosq_mapping_extended_add = bcm56990_a0_ltsw_rx_cosq_mapping_extended_add,
    .rx_cosq_mapping_extended_delete = bcm56990_a0_ltsw_rx_cosq_mapping_extended_delete,
    .rx_cosq_mapping_extended_delete_all = bcm56990_a0_ltsw_rx_cosq_mapping_extended_delete_all,
    .rx_cosq_mapping_extended_get = bcm56990_a0_ltsw_rx_cosq_mapping_extended_get,
    .rx_queue_channel_get = bcm56990_a0_ltsw_rx_queue_channel_get,
    .rx_queue_channel_set = bcm56990_a0_ltsw_rx_queue_channel_set,
    .rx_init = bcm56990_a0_ltsw_rx_init,
    .rx_detach = bcm56990_a0_ltsw_rx_detach,
};

/******************************************************************************
 * Public functions
 */

int
bcm56990_a0_ltsw_rx_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_rx_drv_set(unit, &bcm56990_a0_ltsw_rx_drv));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Attach functions for other members.
 */
#define BCM56990_A0_DRV_ATTACH_ENTRY(_dn,_vn,_pf,_pd,_r0) \
int _vn##_ltsw_rx_drv_attach(int unit) \
{ \
    SHR_FUNC_ENTER(unit); \
    SHR_IF_ERR_VERBOSE_EXIT \
        (mbcm_ltsw_rx_drv_set(unit, &bcm56990_a0_ltsw_rx_drv)); \
exit: \
    SHR_FUNC_EXIT(); \
}
#include "sub_devlist.h"
