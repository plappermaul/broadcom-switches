/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/ltsw/mbcm/mpls.h>
#include <bcm_int/ltsw/xgs/mpls.h>
#include "sub_dispatch.h"

#include <shr/shr_bitop.h>
#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_MPLS

/******************************************************************************
 * Private functions
 */

static int
bcm56990_a0_ltsw_mpls_sw_dump(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_sw_dump(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_init(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_detach(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_switch_add(
    int unit,
    bcm_mpls_tunnel_switch_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_switch_add(unit, info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_switch_delete(
    int unit,
    bcm_mpls_tunnel_switch_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_switch_delete(unit, info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_switch_get(
    int unit,
    bcm_mpls_tunnel_switch_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_switch_get(unit, info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_switch_traverse(
    int unit,
    bcm_mpls_tunnel_switch_traverse_cb cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_switch_traverse(unit, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_switch_delete_all(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_switch_delete_all(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_initiator_clear(
    int unit,
    bcm_if_t intf)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_initiator_clear(unit, intf));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_initiator_clear_all(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_initiator_clear_all(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_initiator_get(
    int unit,
    bcm_if_t intf,
    int label_max,
    bcm_mpls_egress_label_t *label_array,
    int *label_count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_initiator_get(unit, intf, label_max, label_array, label_count));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_initiator_set(
    int unit,
    bcm_if_t intf,
    int num_labels,
    bcm_mpls_egress_label_t *label_array)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_initiator_set(unit, intf, num_labels, label_array));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_global_label_range_set(
    int unit,
    int range_num,
    int range_min,
    int label_val)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_global_label_range_set(unit, range_num, range_min, label_val));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_global_label_range_get(
    int unit,
    int range_num,
    int *min_label,
    int *max_label)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_global_label_range_get(unit, range_num, min_label, max_label));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_dst_mac_profile_add(
    int unit,
    uint64_t mac,
    int *index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_dst_mac_profile_add(unit, mac, index));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_dst_mac_profile_del(
    int unit,
    int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_dst_mac_profile_del(unit, index));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_tnl_dst_mac_profile_get(
    int unit,
    int index,
    uint64_t *mac)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_tnl_dst_mac_profile_get(unit, index, mac));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_label_flexctr_attach(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t port,
    bcmi_ltsw_flexctr_counter_info_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_label_flexctr_attach(unit, label, port, info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_label_flexctr_detach(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t port)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_label_flexctr_detach(unit, label, port));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_label_flexctr_info_get(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t port,
    bcmi_ltsw_flexctr_counter_info_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_label_flexctr_info_get(unit, label, port, info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_label_flexctr_object_set(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t port,
    uint32_t value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_label_flexctr_object_set(unit, label, port, value));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_mpls_label_flexctr_object_get(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t port,
    uint32_t *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_label_flexctr_object_get(unit, label, port, value));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Mpls driver function variable for bcm56990_a0 device.
 */
static mbcm_ltsw_mpls_drv_t bcm56990_a0_ltsw_mpls_drv = {
    .mpls_sw_dump = bcm56990_a0_ltsw_mpls_sw_dump,
    .mpls_init = bcm56990_a0_ltsw_mpls_init,
    .mpls_detach = bcm56990_a0_ltsw_mpls_detach,
    .mpls_tnl_switch_add = bcm56990_a0_ltsw_mpls_tnl_switch_add,
    .mpls_tnl_switch_delete = bcm56990_a0_ltsw_mpls_tnl_switch_delete,
    .mpls_tnl_switch_get = bcm56990_a0_ltsw_mpls_tnl_switch_get,
    .mpls_tnl_switch_traverse = bcm56990_a0_ltsw_mpls_tnl_switch_traverse,
    .mpls_tnl_switch_delete_all = bcm56990_a0_ltsw_mpls_tnl_switch_delete_all,
    .mpls_tnl_initiator_clear = bcm56990_a0_ltsw_mpls_tnl_initiator_clear,
    .mpls_tnl_initiator_clear_all = bcm56990_a0_ltsw_mpls_tnl_initiator_clear_all,
    .mpls_tnl_initiator_get = bcm56990_a0_ltsw_mpls_tnl_initiator_get,
    .mpls_tnl_initiator_set = bcm56990_a0_ltsw_mpls_tnl_initiator_set,
    .mpls_global_label_range_set = bcm56990_a0_ltsw_mpls_global_label_range_set,
    .mpls_global_label_range_get = bcm56990_a0_ltsw_mpls_global_label_range_get,
    .mpls_tnl_dst_mac_profile_add = bcm56990_a0_ltsw_mpls_tnl_dst_mac_profile_add,
    .mpls_tnl_dst_mac_profile_del = bcm56990_a0_ltsw_mpls_tnl_dst_mac_profile_del,
    .mpls_tnl_dst_mac_profile_get = bcm56990_a0_ltsw_mpls_tnl_dst_mac_profile_get,
    .mpls_label_flexctr_attach = bcm56990_a0_ltsw_mpls_label_flexctr_attach,
    .mpls_label_flexctr_detach = bcm56990_a0_ltsw_mpls_label_flexctr_detach,
    .mpls_label_flexctr_info_get = bcm56990_a0_ltsw_mpls_label_flexctr_info_get,
    .mpls_label_flexctr_object_set = bcm56990_a0_ltsw_mpls_label_flexctr_object_set,
    .mpls_label_flexctr_object_get = bcm56990_a0_ltsw_mpls_label_flexctr_object_get,
};

/******************************************************************************
 * Public functions
 */

int
bcm56990_a0_ltsw_mpls_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_mpls_drv_set(unit, &bcm56990_a0_ltsw_mpls_drv));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56990_a0_sub_drv_attach(unit, &bcm56990_a0_ltsw_mpls_drv,
                                    BCM56990_A0_SUB_DRV_BCM56990_Ax,
                                    BCM56990_A0_SUB_MOD_MPLS));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Attach functions for other members.
 */
#define BCM56990_A0_DRV_ATTACH_ENTRY(_dn,_vn,_pf,_pd,_r0) \
int _vn##_ltsw_mpls_drv_attach(int unit) \
{ \
    SHR_FUNC_ENTER(unit); \
    SHR_IF_ERR_VERBOSE_EXIT \
        (mbcm_ltsw_mpls_drv_set(unit, &bcm56990_a0_ltsw_mpls_drv)); \
    SHR_IF_ERR_VERBOSE_EXIT \
        (bcm56990_a0_sub_drv_attach(unit, &bcm56990_a0_ltsw_mpls_drv, \
                                    BCM56990_A0_SUB_DRV_BCM5699x, \
                                    BCM56990_A0_SUB_MOD_MPLS)); \
exit: \
    SHR_FUNC_EXIT(); \
}
#include "sub_devlist.h"
