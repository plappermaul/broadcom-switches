/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */


#include <bsl/bsl.h>
#include <shr/shr_debug.h>

#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/vlan.h>
#include <bcm_int/ltsw/cosq.h>
#include <bcm_int/ltsw/stat.h>
#include <bcm_int/ltsw/mirror.h>
#include <bcm_int/ltsw/rate.h>
#include <bcm_int/ltsw/link.h>
#include <bcm_int/ltsw/mbcm/port.h>
#include <bcm_int/ltsw/xgs/port.h>
#include <bcm_int/ltsw/stg.h>
#include <bcm_int/ltsw/port_int.h>
#include <bcm_int/ltsw/field.h>
#include "sub_dispatch.h"

#include <bcmlt/bcmlt.h>
#include <bcmltd/chip/bcmltd_str.h>



/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_PORT

#define MAX_NUM_PORT        272
#define MAX_NUM_FP_PM       64
#define MAX_NUM_FP_PHY      256

#define PORT_RATE_MIN_KBPS  32                  /* from arch */
#define PORT_RATE_MAX_KBPS  400*1000*1000       /* from max speed */
#define PORT_RATE_MIN_PPS   2                   /* from arch */
#define PORT_RATE_MAX_PPS   595238095           /* max speed / min pkt */
#define PORT_BURST_MIN_KBIT 2                   /* from arch */
#define PORT_BURST_MAX_KBIT 8*128*1024          /* from arch */
#define PORT_BURST_MIN_PKT  1                   /* from arch */
#define PORT_BURST_MAX_PKT  2146959             /* from arch 524.288*4095 */

static const ltsw_port_map_t bcm56990_a0_fixed_port_map[] = {
    /* CPU */
    {0,     0, 0,   BCMI_LTSW_PORT_TYPE_CPU},
    /* LB */
    {33,    1, 259, BCMI_LTSW_PORT_TYPE_LB},
    {67,    3, 260, BCMI_LTSW_PORT_TYPE_LB},
    {101,   5, 261, BCMI_LTSW_PORT_TYPE_LB},
    {135,   7, 262, BCMI_LTSW_PORT_TYPE_LB},
    {169,   9, 263, BCMI_LTSW_PORT_TYPE_LB},
    {203,  11, 264, BCMI_LTSW_PORT_TYPE_LB},
    {237,  13, 265, BCMI_LTSW_PORT_TYPE_LB},
    {271,  15, 266, BCMI_LTSW_PORT_TYPE_LB},
    /* MGMT */
    {50,    2, 258, BCMI_LTSW_PORT_TYPE_MA | BCMI_LTSW_PORT_TYPE_XL, FLEXIBLE | NO_REMAP},
    {152,   8, 257, BCMI_LTSW_PORT_TYPE_MA | BCMI_LTSW_PORT_TYPE_XL, FLEXIBLE | NO_REMAP},
    /* spare */
    {84,    4, 267, BCMI_LTSW_PORT_TYPE_SPARE},
    {118,   6, 268, BCMI_LTSW_PORT_TYPE_SPARE},
    {186,   10,269, BCMI_LTSW_PORT_TYPE_SPARE},
    {220,   12,270, BCMI_LTSW_PORT_TYPE_SPARE},
    {254,   14,271, BCMI_LTSW_PORT_TYPE_SPARE},
    {0},
};

#define BCM56990_A0_FDR_CW_S_ERR_MASK    (PC_FDR_CW_S0_ERR|PC_FDR_CW_S1_ERR|PC_FDR_CW_S2_ERR|    \
                                           PC_FDR_CW_S3_ERR|PC_FDR_CW_S4_ERR|PC_FDR_CW_S5_ERR|    \
                                           PC_FDR_CW_S6_ERR|PC_FDR_CW_S7_ERR)

#define BCM56990_A0_MAX_AN_ABILITY 20

/*! TH4 force speed abilities and their VCO rates. */
const ltsw_port_fs_ability_table_entry_t_t bcm56990_a0_fs_ability_table[] =
{
    /* port_speed, num_lanes, FEC type, VCO rate */
    {40000,   2,    bcmPortPhyFecNone,          ltswPortVCO20P625G },
    {10000,   1,    bcmPortPhyFecNone,          ltswPortVCO25P781G },
    {40000,   4,    bcmPortPhyFecNone,          ltswPortVCO25P781G },
    {25000,   1,    bcmPortPhyFecNone,          ltswPortVCO25P781G },
    {25000,   1,    bcmPortPhyFecRsFec,         ltswPortVCO25P781G },
    {50000,   1,    bcmPortPhyFecRsFec,         ltswPortVCO25P781G },
    {50000,   2,    bcmPortPhyFecNone,          ltswPortVCO25P781G },
    {50000,   2,    bcmPortPhyFecRsFec,         ltswPortVCO25P781G },
    {100000,  2,    bcmPortPhyFecNone,          ltswPortVCO25P781G },
    {100000,  2,    bcmPortPhyFecRsFec,         ltswPortVCO25P781G },
    {100000,  4,    bcmPortPhyFecNone,          ltswPortVCO25P781G },
    {100000,  4,    bcmPortPhyFecRsFec,         ltswPortVCO25P781G },
    {200000,  4,    bcmPortPhyFecNone,          ltswPortVCO25P781G },
    {50000,   1,    bcmPortPhyFecRs544,         ltswPortVCO26P562G },
    {50000,   1,    bcmPortPhyFecRs272,         ltswPortVCO26P562G },
    {50000,   2,    bcmPortPhyFecRs544,         ltswPortVCO26P562G },
    {100000,  2,    bcmPortPhyFecRs544,         ltswPortVCO26P562G },
    {100000,  2,    bcmPortPhyFecRs272,         ltswPortVCO26P562G },
    {100000,  4,    bcmPortPhyFecRs544,         ltswPortVCO26P562G },
    {200000,  4,    bcmPortPhyFecRs544,         ltswPortVCO26P562G },
    {200000,  4,    bcmPortPhyFecRs544_2xN,     ltswPortVCO26P562G },
    {200000,  4,    bcmPortPhyFecRs272,         ltswPortVCO26P562G },
    {200000,  4,    bcmPortPhyFecRs272_2xN,     ltswPortVCO26P562G },
    {200000,  8,    bcmPortPhyFecRs544_2xN,     ltswPortVCO26P562G },
    {400000,  8,    bcmPortPhyFecRs544_2xN,     ltswPortVCO26P562G },
    {400000,  8,    bcmPortPhyFecRs272_2xN,     ltswPortVCO26P562G }
};

/*! A comprehensive list of TH4 AN abilities
 * and their VCO rates. */
const ltsw_port_an_ability_table_entry_t bcm56990_a0_an_ability_table[] =
{
    /*! Speed, number of lanes, FEC type, AN mode, VCO rate. */
    {40000,   2,    bcmPortPhyFecNone,      bcmPortAnModeCL73BAM,   ltswPortVCO20P625G},
    {10000,   1,    bcmPortPhyFecNone,      bcmPortAnModeCL73,      ltswPortVCO25P781G},
    {40000,   4,    bcmPortPhyFecNone,      bcmPortAnModeCL73,      ltswPortVCO25P781G},
    {25000,   1,    bcmPortPhyFecNone,      bcmPortAnModeCL73,      ltswPortVCO25P781G},
    {25000,   1,    bcmPortPhyFecRsFec,     bcmPortAnModeCL73,      ltswPortVCO25P781G},
    {25000,   1,    bcmPortPhyFecNone,      bcmPortAnModeCL73MSA,   ltswPortVCO25P781G},
    {25000,   1,    bcmPortPhyFecRsFec,     bcmPortAnModeCL73MSA,   ltswPortVCO25P781G},
    {25000,   1,    bcmPortPhyFecNone,      bcmPortAnModeCL73BAM,   ltswPortVCO25P781G},
    {25000,   1,    bcmPortPhyFecRsFec,     bcmPortAnModeCL73BAM,   ltswPortVCO25P781G},
    {50000,   1,    bcmPortPhyFecRsFec,     bcmPortAnModeCL73BAM,   ltswPortVCO25P781G},
    {50000,   2,    bcmPortPhyFecNone,      bcmPortAnModeCL73MSA,   ltswPortVCO25P781G},
    {50000,   2,    bcmPortPhyFecRsFec,     bcmPortAnModeCL73MSA,   ltswPortVCO25P781G},
    {50000,   2,    bcmPortPhyFecNone,      bcmPortAnModeCL73BAM,   ltswPortVCO25P781G},
    {50000,   2,    bcmPortPhyFecRsFec,     bcmPortAnModeCL73BAM,   ltswPortVCO25P781G},
    {100000,  2,    bcmPortPhyFecNone,      bcmPortAnModeCL73BAM,   ltswPortVCO25P781G},
    {100000,  2,    bcmPortPhyFecRsFec,     bcmPortAnModeCL73BAM,   ltswPortVCO25P781G},
    {100000,  4,    bcmPortPhyFecNone,      bcmPortAnModeCL73BAM,   ltswPortVCO25P781G},
    {100000,  4,    bcmPortPhyFecRsFec,     bcmPortAnModeCL73,      ltswPortVCO25P781G},
    {200000,  4,    bcmPortPhyFecNone,      bcmPortAnModeCL73BAM,   ltswPortVCO25P781G},
    {50000,   1,    bcmPortPhyFecRs544,     bcmPortAnModeCL73,      ltswPortVCO26P562G},
    {50000,   1,    bcmPortPhyFecRs272,     bcmPortAnModeCL73MSA,   ltswPortVCO26P562G},
    {50000,   2,    bcmPortPhyFecRs544,     bcmPortAnModeCL73BAM,   ltswPortVCO26P562G},
    {100000,  2,    bcmPortPhyFecRs544,     bcmPortAnModeCL73,      ltswPortVCO26P562G},
    {100000,  2,    bcmPortPhyFecRs272,     bcmPortAnModeCL73MSA,   ltswPortVCO26P562G},
    {100000,  4,    bcmPortPhyFecRs544,     bcmPortAnModeCL73BAM,   ltswPortVCO26P562G},
    {200000,  4,    bcmPortPhyFecRs544_2xN, bcmPortAnModeCL73,      ltswPortVCO26P562G},
    {200000,  4,    bcmPortPhyFecRs544,     bcmPortAnModeCL73BAM,   ltswPortVCO26P562G},
    {200000,  4,    bcmPortPhyFecRs272_2xN, bcmPortAnModeCL73MSA,   ltswPortVCO26P562G},
    {400000,  8,    bcmPortPhyFecRs544_2xN, bcmPortAnModeCL73MSA,   ltswPortVCO26P562G}
};

/******************************************************************************
 * Private functions
 */
/*!
 * \brief Get subsidiary ports.
 *
 * \param [in] unit Unit number.
 * \param [in] port Port.
 * \param [in] pbmp Bitmap of subsidiary ports.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_subsidiary_ports_get(int unit, bcm_port_t port,
                                           bcm_pbmp_t *pbmp)
{
    int p, pport, pport_min, pport_max;

    SHR_FUNC_ENTER(unit);

    /* only for flexible ports */
    if ((PORT(unit, port).flags & (FLEXIBLE | NO_REMAP)) != FLEXIBLE) {
        SHR_ERR_EXIT(SHR_E_PORT);
    }

    pport_min = PORT(unit, port).pport;
    /* only 0,2 in a PM has subsidiary ports, note pport start from 1 */
    if (!(pport_min % 2)) {
        SHR_ERR_EXIT(SHR_E_PORT);
    }
    pport_max = (pport_min + 3) & (~3);

    BCM_PBMP_CLEAR(*pbmp);
    PORT_FP_ITER(unit, p) {
        pport = PORT(unit, p).pport;
        if ((pport >= pport_min) && (pport <= pport_max)) {
            BCM_PBMP_PORT_ADD(*pbmp, p);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Lookup port and lanes in fixed_port_map.
 *
 * \param [in] port Port.
 *
 * \return index of matched entry, or -1 if not found.
 */
static int
fixed_port_lkp(int port)
{
    const ltsw_port_map_t *pm = NULL;

    for (pm = bcm56990_a0_fixed_port_map; pm->ptype; pm ++) {
        if (pm->lport == port) {
            return (pm - bcm56990_a0_fixed_port_map);
        }
    }

    return -1;
}

/*!
 * \brief Init BCM56990 specific information for a port.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_info_init_per_port(int unit, int port)
{
    int id;

    id  = fixed_port_lkp(port);
    if (id < 0) {
        /* common port */
        PORT(unit, port).port_type = BCMI_LTSW_PORT_TYPE_CD;
        PORT(unit, port).flags |= (FLEXIBLE | CT_VALID);
    } else {
        /* fixed port */
        PORT(unit, port).pport = bcm56990_a0_fixed_port_map[id].pport;
        PORT(unit, port).port_type = bcm56990_a0_fixed_port_map[id].ptype;
        PORT(unit, port).flags = bcm56990_a0_fixed_port_map[id].flags;
    }

    return SHR_E_NONE;
}

/*!
 * \brief Init BCM56990 specific information.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_info_init(int unit)
{
    int port, pport, pipe, pipe_num;
    ltsw_port_profile_info_t *pinfo;
    ltsw_pc_profile_info_t *pc_info;
    const ltsw_port_map_t *pm = NULL;
    bool mode;

    SHR_FUNC_ENTER(unit);

    for (port = 0; port < MAX_NUM_PORT; port ++) {
        PORT(unit, port).port_type = BCMI_LTSW_PORT_TYPE_CD;
        PORT(unit, port).flags = (FLEXIBLE | CT_VALID);
    }

    for (pport = 1; pport <= MAX_NUM_FP_PHY; pport ++) {
        ltsw_port_info[unit]->phy_port[pport].flags = FLEXIBLE;
    }

    for (pm = bcm56990_a0_fixed_port_map; pm->ptype; pm ++) {
        port = pm->lport;
        PORT(unit, port).pport = pm->pport;
        PORT(unit, port).port_type = pm->ptype;
        PORT(unit, port).flags = pm->flags;
        pport = pm->pport;
        if (pport >= 0) {
            ltsw_port_info[unit]->phy_port[pport].flags = pm->flags;
        }
    }
    ltsw_port_info[unit]->min_lanes_per_pport = 2;
    ltsw_port_info[unit]->max_frame_size = 9416;

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_port_info_init(unit));

    pinfo = xgs_ltsw_port_profile_port_pkt_ctrl(unit);
    pinfo->entry_idx_min = 0;
    pinfo->entry_idx_max = 63;
    pinfo->entries_per_set = 1;

    pipe_num = bcmi_ltsw_dev_max_pp_pipe_num(unit);
    if (pipe_num > MAX_INST_NUM_LPORT_TAB) {
        return SHR_E_CONFIG;
    }
    (void)xgs_ltsw_port_system_profile_opermode_get(unit, &mode);
    for (pipe = 0; pipe < pipe_num; pipe++) {
        pinfo = xgs_ltsw_port_system_profile(unit, pipe);
        pinfo->entry_idx_min = 0;
        pinfo->entry_idx_max = 67;
        pinfo->entries_per_set = 1;
        if (mode) {
            pinfo->inst = pipe;
        } else {
            pinfo->inst = 0;
        }
    }

    pc_info = PROFILE_PC_AUTONEG(unit);
    pc_info->entry_idx_min = 0;
    pc_info->entry_idx_max = 255;
    pc_info->entries_per_set = 1;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Deinit BCM56990 specific information.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_info_deinit(int unit)
{
    return SHR_E_NONE;
}

/*!
 * \brief Initialize profile LTs for all ports.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_profile_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_port_profile_init(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_pc_profile_init(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-initialize profile LTs for all ports.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_profile_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_pc_profile_deinit(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_port_profile_deinit(unit));

exit:
    SHR_FUNC_EXIT();

}

/*!
 * \brief Initialize profile LTs for one port.
 *
 * \param [in] unit Unit number.
 * \param [in] port Port number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_profile_init_per_port(int unit, int port)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_port_profile_init_per_port(unit, port));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_pc_profile_id_init_per_port(unit, port));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-initialize profile LTs for one port.
 *
 * \param [in] unit Unit number.
 * \param [in] port Port number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_profile_deinit_per_port(int unit, int port)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_port_profile_deinit_per_port(unit, port));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_pc_profile_id_init_per_port(unit, port));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize basic port pipeline configuration for a port.
 *
 * \param [in] unit Unit number.
 * \param [in] port Port number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_service_init_per_port(int unit, bcm_port_t port)
{
    ltsw_port_tab_field_t *fields = NULL;
    int fields_num_max, fields_num;

    SHR_FUNC_ENTER(unit);

    fields_num_max = 32;
    fields_num = 0;
    SHR_ALLOC(fields,
        sizeof(ltsw_port_tab_field_t) * fields_num_max, "fields");
    SHR_NULL_CHECK(fields, SHR_E_MEMORY);
    sal_memset(fields, 0, sizeof(ltsw_port_tab_field_t) * fields_num_max);
    /* PORT_TYPE */
    fields[fields_num].type = BCMI_PT_PORT_TYPE;
    if (IS_ETH_PORT(unit, port)) {
        fields[fields_num].data.n = XGS_PORT_TYPE_ETHERNET;
    } else if (IS_LB_PORT(unit, port)) {
        fields[fields_num].data.n = XGS_PORT_TYPE_LOOPBACK;
    } else {
        fields[fields_num].data.n = XGS_PORT_TYPE_ETHERNET;
    }
    fields_num++;

    /* Default vlan id(pvid) for port. PORT_VID */
    fields[fields_num].type = BCMI_PT_ING_OVID;
    fields[fields_num].data.n = BCM_VLAN_DEFAULT;
    fields_num++;

    /* EN_EFILTER */
    fields[fields_num].type = BCMI_PT_EGR_VLAN_MEMBERSHIP_CHECK;
    fields[fields_num].data.n = 1;
    fields_num++;

    /* TRUST_INCOMING_VID */
    fields[fields_num].type = BCMI_PT_TRUST_INCOMING_VID;
    fields[fields_num].data.n = 1;
    fields_num++;

    /* Set the CML to PVP_CML_SWITCH by default (hw learn and forward) */
    fields[fields_num].type = BCMI_PT_MAC_LEARN;
    fields[fields_num].data.n = 1;
    fields_num++;

    fields[fields_num].type = BCMI_PT_MAC_MOVE;
    fields[fields_num].data.n = 1;
    fields_num++;

    fields[fields_num].type = BCMI_PT_V4L3;
    fields[fields_num].data.n = 1;
    fields_num++;

    fields[fields_num].type = BCMI_PT_V6L3;
    fields[fields_num].data.n = 1;
    fields_num++;

    fields[fields_num].type = BCMI_PT_V4IPMC;
    fields[fields_num].data.n = 1;
    fields_num++;

    fields[fields_num].type = BCMI_PT_V6IPMC;
    fields[fields_num].data.n = 1;
    fields_num++;

    fields[fields_num].type = BCMI_PT_IPMC_USE_L3_IIF;
    fields[fields_num].data.n = 1;
    fields_num++;

    fields[fields_num].type = BCMI_PT_MPLS;
    fields[fields_num].data.n = 1;
    fields_num++;

    fields[fields_num].type = BCMI_PT_TRUST_PHB_EGR_PORT_L2_OTAG;
    fields[fields_num].data.n = 1;
    fields_num++;

    /* Sourc system port. SRC_SYS_PORT_ID, is already mapped as key,
     * so no need to add it here */

    if (fields_num > fields_num_max) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_tab_multi_set(unit, port, fields, fields_num));

exit:
    SHR_FREE(fields);
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-initialize basic port pipeline configuration for a port.
 *
 * \param [in] unit Unit number.
 * \param [in] port Port number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_service_deinit_per_port(int unit, bcm_port_t port)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_port_service_deinit_per_port(unit, port));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize basic port pipeline configuration.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_service_init(int unit)
{
    int port;

    SHR_FUNC_ENTER(unit);

    PORT_ALL_ITER(unit, port) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56990_a0_ltsw_port_service_init_per_port(unit, port));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-initialize basic port pipeline configuration.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_port_service_deinit(int unit)
{
    int port;

    SHR_FUNC_ENTER(unit);

    PORT_ALL_ITER(unit, port) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56990_a0_ltsw_port_service_deinit_per_port(unit, port));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate egress shaper settings for.
 *
 * \param [in] unit Unit number.
 * \param [in] port Port number.
 * \param [in] bandwidth Port bandwidth in kbps or pps. 0 means shaper is disabled.
 * \param [in] burst Maximum burst size in kbits or packets.
 * \param [in] mode Byte mode or packet mode.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
bcm56990_a0_ltsw_port_egr_shaper_validate(int unit, bcm_port_t port,
                                          uint32_t bandwidth, uint32_t burst,
                                          bcmi_ltsw_port_shaper_mode_t mode)
{
    if ((bandwidth == 0) || (burst == 0)) {
        return SHR_E_NONE;
    } else if (mode == SHAPER_MODE_BYTE) {
        if ((bandwidth < PORT_RATE_MIN_KBPS) || (bandwidth > PORT_RATE_MAX_KBPS)
            || (burst < PORT_BURST_MIN_KBIT) || (burst > PORT_BURST_MAX_KBIT)) {
            return SHR_E_PARAM;
        } else {
            return SHR_E_NONE;
        }
    } else if (mode == SHAPER_MODE_PKT) {
        if ((bandwidth < PORT_RATE_MIN_PPS) || (bandwidth > PORT_RATE_MAX_PPS)
            || (burst < PORT_BURST_MIN_PKT) || (burst > PORT_BURST_MAX_PKT)) {
            return SHR_E_PARAM;
        } else {
            return SHR_E_NONE;
        }
    } else {
        return SHR_E_PARAM;
    }
}

/*!
 * \brief Validate port class settings for TH4.
 *
 * \param [in] unit Unit number.
 * \param [in] port Port Number.
 * \param [in] class Classification type.
 * \param [in] class_id Class ID of the port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
bcm56990_a0_ltsw_port_class_validate(int unit, bcm_port_t *port,
                                     bcm_port_class_t class, uint32_t class_id)
{
    SHR_FUNC_ENTER(unit);

    switch (class) {
       default:
            SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_ltsw_port_gport_validate(unit, *port, port));
            break;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_an_ability_table_vco_get(uint32 speed, uint32 num_lanes, bcm_port_phy_fec_t fec_type,
                                         bcm_port_autoneg_mode_t an_mode,
                                         ltsw_port_vco_type_t* vco)
{
    int i, entry_num;

    entry_num = sizeof(bcm56990_a0_an_ability_table) /sizeof(ltsw_port_an_ability_table_entry_t);

    *vco = ltswPortVCOInvalid;
    for (i = 0; i < entry_num; i++) {
        if (bcm56990_a0_an_ability_table[i].speed == speed &&
            bcm56990_a0_an_ability_table[i].num_lanes == num_lanes &&
            bcm56990_a0_an_ability_table[i].fec_type == fec_type &&
            bcm56990_a0_an_ability_table[i].an_mode == an_mode)
        {
            *vco = bcm56990_a0_an_ability_table[i].vco;
            break;
        }
    }

    return SHR_E_NONE;
}

static int
bcm56990_a0_fs_ability_table_vco_get(uint32 speed, uint32 num_lanes, bcm_port_phy_fec_t fec_type,
                                         ltsw_port_vco_type_t* vco)
{
    int i, entry_num;

    entry_num = sizeof(bcm56990_a0_fs_ability_table)/sizeof(ltsw_port_fs_ability_table_entry_t_t);

    *vco = ltswPortVCOInvalid;
    for (i = 0; i < entry_num; i++) {
        if (bcm56990_a0_fs_ability_table[i].speed == speed &&
            bcm56990_a0_fs_ability_table[i].num_lanes == num_lanes &&
            bcm56990_a0_fs_ability_table[i].fec_type == fec_type)
        {
            *vco = bcm56990_a0_fs_ability_table[i].vco;
            break;
        }
    }

    return SHR_E_NONE;
}

static int
bcm56990_a0_manage_port_vco_get(int unit, int port,
                            const bcm_port_resource_t* speed_resource,
                            ltsw_port_vco_type_t* vco_rate)
{
    int custom_speed_vco;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_custom_speed_vco_get(unit, port, &custom_speed_vco));
    switch (speed_resource->speed) {
        case 10:
        case 100:
        case 1000:
            if (custom_speed_vco == ltswSpeed1gAt12p5g) {
                *vco_rate = ltswPortVCO12P5;
            } else {
                *vco_rate = ltswPortVCO10P3125;
            }
            break;
        case 2500:
            if (custom_speed_vco == ltswSpeed2p5gAt12p5g) {
                *vco_rate = ltswPortVCO12P5;
            } else {
                *vco_rate = ltswPortVCO10P3125;
            }
            break;
        case 10000:
            *vco_rate = ltswPortVCO10P3125;
            break;
        case 40000:
            *vco_rate = ltswPortVCO10P3125;
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Validate if the new ports can be allocated in the PM.
 *
 * \param [in] unit           Unit number.
 * \param [in] current_ports  Current ports bmp in the PM.
 * \param [in] nport          Number of elements in array resource.
 * \param [in] resource       Port resource configuration array.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
int
bcm56990_a0_ltsw_flexport_pm_validate(int unit, bcm_pbmp_t *current_ports, int nport, ltsw_flexport_port_cfg_t **port_cfg_array)
{
    uint32_t remain_ports_lane_bmp, new_ports_lane_bmp;
    bcm_pbmp_t remain_ports;
    bcm_port_t port;
    uint32_t lane_mask;
    uint32_t rs544_bmp, rs272_bmp;
    int i, j, an, an_ability_num;
    bcm_port_speed_ability_t an_ability[BCM56990_A0_MAX_AN_ABILITY];
    bcm_port_resource_t speed_resource;
    int current_tvco, current_ovco, pll_num, current_vco;
    uint32_t vco_lane_bmp;
    ltsw_port_vco_type_t vco;
    ltsw_port_vco_type_t required_vco = ltswPortVCOInvalid;
    int pm_id, pm_type;
    int vco_is_free = 0;
    int vco_20g_index = -1;
    uint32_t current_rs544_bmp = 0;
    uint32_t current_rs272_bmp = 0;
    bcm_pbmp_t reset_ports;

    SHR_FUNC_ENTER(unit);

    pm_id = port_cfg_array[0]->pmid;
    for (i = 0; i < nport; i++) {
        if (pm_id != port_cfg_array[i]->pmid) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_pm_type_get(unit, pm_id, &pm_type));

    if (pm_type == ltswPmTypePm4x10) {
        LOG_ERROR(BSL_LS_BCM_PORT,
            (BSL_META_U(unit, "Management port doesn`t support flexport.\n")));
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Get current tvco and ovco */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_vco_get(unit, pm_id, &pll_num, &current_tvco, &current_ovco));

    if (pll_num != 1) {
        LOG_ERROR(BSL_LS_BCM_PORT,
            (BSL_META_U(unit, "PLL get fail.\n")));
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_FAIL);
    }

    current_vco = current_tvco;

    BCM_PBMP_ASSIGN(remain_ports, *current_ports);
    remain_ports_lane_bmp = 0;
    new_ports_lane_bmp = 0;

    for (i = 0; i < nport; i++) {
        /*If op is FLEXPORT_OP_DETACH, the logic port will be removed*/
        if(port_cfg_array[i]->op & FLEXPORT_OP_DETACH) {
            /*Set up bmp for the remaining ports*/
            BCM_PBMP_PORT_REMOVE(remain_ports, port_cfg_array[i]->lport);
        } else {
            /*Set up the lane bmp for the new ports*/
            lane_mask = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_pport_lane_mask_get(unit, port_cfg_array[i]->pport,
                                                 port_cfg_array[i]->lanes, &lane_mask));
            new_ports_lane_bmp |= lane_mask;
        }
    }

    /*Set up the lane bmp for the remaining ports*/
    BCM_PBMP_ITER(remain_ports, port) {
       lane_mask = 0;
       SHR_IF_ERR_VERBOSE_EXIT
           (bcmint_ltsw_port_lane_mask_get(unit, port, &lane_mask));
       remain_ports_lane_bmp |= lane_mask;
    }

    /*Validate lane overlap*/
    if ((remain_ports_lane_bmp & new_ports_lane_bmp) != 0) {
        LOG_ERROR(BSL_LS_BCM_PORT,
            (BSL_META_U(unit, "The new ports take over the lane of remaining ports overlap lane: 0x%x\n"),
                        remain_ports_lane_bmp & new_ports_lane_bmp));
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /*Set up the rs544_bmp, rs272_bmp, tvco_lane_bmp*/
    rs544_bmp = 0;
    rs272_bmp = 0;
    vco_lane_bmp = 0;
    BCM_PBMP_ITER(remain_ports, port) {
        /*Check the AN enable*/
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_ltsw_port_autoneg_get(unit, port, &an));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_ltsw_port_lane_mask_get(unit, port, &lane_mask));
        if (an) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_port_autoneg_ability_advert_get(unit, port, BCM56990_A0_MAX_AN_ABILITY,
                                                          an_ability, &an_ability_num));

            for (i = 0; i < an_ability_num; i++) {
                /*Set up fec bmp*/
                if (an_ability[i].fec_type == bcmPortPhyFecRs272 ||
                    an_ability[i].fec_type == bcmPortPhyFecRs272_2xN) {
                    rs272_bmp |= lane_mask;
                }

                if (an_ability[i].fec_type == bcmPortPhyFecRs544 ||
                    an_ability[i].fec_type == bcmPortPhyFecRs544_2xN) {
                    rs544_bmp |= lane_mask;
                }

                /*set up vco bmp*/
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm56990_a0_an_ability_table_vco_get(an_ability[i].speed, an_ability[i].resolved_num_lanes,
                                                          an_ability[i].fec_type, an_ability[i].an_mode, &vco));

                /* 40G (4-Lanes) and 10G (1-Lane) support either 20.625G or 25.781G VCO */
                if ((an_ability[i].speed == 10000 && an_ability[i].resolved_num_lanes == 1)
                    || (an_ability[i].speed == 40000 && an_ability[i].resolved_num_lanes == 4)) {
                    if (current_vco == ltswPortVCO20P625G) {
                        vco = ltswPortVCO20P625G;
                    }
                }

                if (vco == current_vco) {
                    vco_lane_bmp |= lane_mask;
                } else {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }
            }
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_port_resource_get(unit, port, &speed_resource));
            /*Set up fec bmp*/
            if (speed_resource.fec_type == bcmPortPhyFecRs272 ||
                speed_resource.fec_type == bcmPortPhyFecRs272_2xN) {
                rs272_bmp |= lane_mask;
            }

            if (speed_resource.fec_type == bcmPortPhyFecRs544 ||
                speed_resource.fec_type == bcmPortPhyFecRs544_2xN) {
                rs544_bmp |= lane_mask;
            }

            /*set up vco bmp*/
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56990_a0_fs_ability_table_vco_get(speed_resource.speed, speed_resource.lanes,
                                                      speed_resource.fec_type, &vco));
            /* 40G (4-Lanes) and 10G (1-Lane) support either 20.625G or 25.781G VCO */
            if ((speed_resource.speed == 10000 && speed_resource.lanes == 1)
                || (speed_resource.speed == 40000 && speed_resource.lanes == 4)) {
                if (current_vco == ltswPortVCO20P625G) {
                    vco = ltswPortVCO20P625G;
                }
            }

            if (vco == current_vco) {
                vco_lane_bmp |= lane_mask;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        }
    }

    /*Add the lane mask of new ports to rs272_bmp and rs544_bmp*/
    for (i = 0 ; i < nport; i++) {
        if (!(port_cfg_array[i]->op & FLEXPORT_OP_DETACH)) {
            lane_mask = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_pport_lane_mask_get(unit, port_cfg_array[i]->pport,
                                                 port_cfg_array[i]->lanes, &lane_mask));

            if (port_cfg_array[i]->fec == bcmPortPhyFecRs272 ||
                port_cfg_array[i]->fec == bcmPortPhyFecRs272_2xN) {
                rs272_bmp |= lane_mask;
            }

            if (port_cfg_array[i]->fec == bcmPortPhyFecRs544 ||
                port_cfg_array[i]->fec == bcmPortPhyFecRs544_2xN) {
                rs544_bmp |= lane_mask;
            }
        }
    }

    /*FEC validation*/
    if ((rs544_bmp & 0xf) && (rs272_bmp & 0xf)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
            (BSL_META_U(unit, "Can not accommodate FEC settings on MPP0.\n")));
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if ((rs544_bmp & 0xf0) && (rs272_bmp & 0xf0)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
            (BSL_META_U(unit, "Can not accommodate FEC settings on MPP1.\n")));
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Set PC_RESET flag for FEC type change between RS272 and RS544.
     * RS272 and RS544 can't be accommodated in one MPP.
     * Delete the old ports which FEC type is RS272 and FEC type of other ports in one MPP are RS544, or
     * Old port FEC type is RS544 and FEC type of other port in one MPP are RS272.
     */
    BCM_PBMP_CLEAR(reset_ports);
    for (i = 0; i < nport; i++) {
        if (port_cfg_array[i]->op & FLEXPORT_OP_DETACH) {
            lane_mask = 0;
            port = port_cfg_array[i]->lport;
            /*Check the AN enable*/
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_port_autoneg_get(unit, port, &an));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_port_lane_mask_get(unit, port, &lane_mask));

            if (an) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmint_ltsw_port_autoneg_ability_advert_get(unit, port, BCM56990_A0_MAX_AN_ABILITY,
                                                            an_ability, &an_ability_num));
                for (j = 0; j < an_ability_num; j++) {
                    /*Set up fec bmp*/
                    if (an_ability[j].fec_type == bcmPortPhyFecRs272 ||
                        an_ability[j].fec_type == bcmPortPhyFecRs272_2xN) {
                        current_rs272_bmp |= lane_mask;
                    }

                    if (an_ability[j].fec_type == bcmPortPhyFecRs544 ||
                        an_ability[j].fec_type == bcmPortPhyFecRs544_2xN) {
                        current_rs544_bmp |= lane_mask;
                    }
                }
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmint_ltsw_port_resource_get(unit, port, &speed_resource));
                /*Set up fec bmp*/
                if (speed_resource.fec_type == bcmPortPhyFecRs272 ||
                    speed_resource.fec_type == bcmPortPhyFecRs272_2xN) {
                    current_rs272_bmp |= lane_mask;
                }

                if (speed_resource.fec_type == bcmPortPhyFecRs544 ||
                    speed_resource.fec_type == bcmPortPhyFecRs544_2xN) {
                    current_rs544_bmp |= lane_mask;
                }
            }

            if (((current_rs272_bmp & 0xf) && ((rs544_bmp & (~lane_mask)) & 0xf))||
                ((current_rs272_bmp & 0xf0) && ((rs544_bmp & (~lane_mask)) & 0xf0))||
                ((current_rs544_bmp & 0xf) && ((rs272_bmp & (~lane_mask)) & 0xf)) ||
                ((current_rs544_bmp & 0xf0) && ((rs272_bmp & (~lane_mask)) & 0xf0))) {
                if (port_cfg_array[i]->op & FLEXPORT_OP_FEC) {
                    port_cfg_array[i]->op |= FLEXPORT_OP_PC_RESET;
                    BCM_PBMP_PORT_ADD(reset_ports, port);
                }
            }
        } else {
            if (BCM_PBMP_MEMBER(reset_ports, port_cfg_array[i]->lport)) {
                if (port_cfg_array[i]->op & FLEXPORT_OP_FEC) {
                    port_cfg_array[i]->op |= FLEXPORT_OP_PC_RESET;
                }
            }
        }
    }

    /*VCO validation*/

    /*Current vco free status check*/
    if (vco_lane_bmp == 0) {
        vco_is_free = 1;
    }

    /* Point out the index of 40G (2-Lanes) or 20G (1-Lane) */
    for (i = 0; i < nport; i++) {
        if (!(port_cfg_array[i]->op & FLEXPORT_OP_DETACH)) {
            if ((port_cfg_array[i]->speed == 20000 && port_cfg_array[i]->lanes == 1)
                || (port_cfg_array[i]->speed == 40000 && port_cfg_array[i]->lanes == 2)) {
                if (vco_20g_index == -1) {
                    vco_20g_index = i;
                    break;
                }
            }
        }
    }

    for (i = 0; i < nport; i++) {
        /*If op is FLEXPORT_OP_DETACH, the logic port will be removed*/
        if(!(port_cfg_array[i]->op & FLEXPORT_OP_DETACH)) {
            /*Get the required vco*/
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56990_a0_fs_ability_table_vco_get(port_cfg_array[i]->speed, port_cfg_array[i]->lanes,
                                                      port_cfg_array[i]->fec, &vco));
            if (vco == ltswPortVCOInvalid) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit, "port %d: speed[%d] lane[%d] fec[%d]is not supported.\n"),
                        port_cfg_array[i]->lport, port_cfg_array[i]->speed, port_cfg_array[i]->lanes, port_cfg_array[i]->fec));
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_CONFIG);
            }

            if ((port_cfg_array[i]->speed == 10000 && port_cfg_array[i]->lanes == 1)
                || (port_cfg_array[i]->speed == 40000 && port_cfg_array[i]->lanes == 4)) {
                if (!vco_is_free && current_vco == ltswPortVCO20P625G) {
                    vco = ltswPortVCO20P625G;
                } else if (vco_20g_index != -1) {
                    vco = ltswPortVCO20P625G;
                } else {
                    vco = ltswPortVCO25P781G;
                }
            }

            if (required_vco == ltswPortVCOInvalid) {
                required_vco = vco;
            }

            if (required_vco != vco) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit, "required vco number is more than 1.\n")));
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        }
    }

    /* Required VCO is invalid means flexport opearation is delete */
    if (required_vco == ltswPortVCOInvalid) {
        SHR_EXIT();
    }

    if (vco_is_free) {
        /* Speical case: If insert 40G(2-Lanes) and 40G(4-Lanes)/10G(1-Lane) meanwhile,
           40G(2-Lanes) should be added first to make VCO work at 20.625G */
        if (vco_20g_index != -1) {
            port_cfg_array[vco_20g_index]->op |= FLEXPORT_OP_ATTACH_FIRST;
        }
        /* if current vco is free, it might change to another vco, so reset all port */
        for (i = 0; i < nport; i++) {
            if (!(port_cfg_array[i]->flags & FLEXPORT_FLG_NO_REMAP)) {
                port_cfg_array[i]->op |= FLEXPORT_OP_PC_RESET;
            }
        }
        SHR_EXIT();
    } else {
        if (required_vco != current_vco) {
            /*The required VCO can`t be accommodated, validation failed*/
            LOG_ERROR(BSL_LS_BCM_PORT,
                (BSL_META_U(unit, "Can not accommodate the request VCO.\n request [VCO %d].\n"),
                    required_vco));
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        } else {
            SHR_EXIT();
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate if the new speed can be allocated in the PM.
 *
 * \param [in] unit           Unit number.
 * \param [in] resource       Port resource configuration array.
 * \param [out]affect_ports   The affected ports bmp.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
int
bcm56990_a0_ltsw_port_speed_config_validate(int unit, bcm_port_resource_t *resource, bcm_pbmp_t *affect_ports)
{
    bcm_pbmp_t port_pbmp;
    bcm_port_speed_ability_t an_ability[BCM56990_A0_MAX_AN_ABILITY];
    bcm_port_resource_t speed_resource;
    bcm_port_t port;
    ltsw_port_vco_type_t vco;
    int current_vco, ovco, pll_num, tvco;
    uint32_t rs544_bmp = 0, rs272_bmp = 0, lane_mask = 0;
    int i, pm_id, an, an_ability_num, pm_type;
    uint32_t num_lane;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(port_pbmp);
    BCM_PBMP_CLEAR(*affect_ports);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_pm_id_get(unit, resource->port, &pm_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_pm_ports_get(unit, pm_id, &port_pbmp));
    BCM_PBMP_PORT_REMOVE(port_pbmp, resource->port);

    /*lane check*/
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_num_lane_get(unit, resource->port, &num_lane));
    if (num_lane != resource->lanes) {
        LOG_ERROR(BSL_LS_BCM_PORT,
            (BSL_META_U(unit, "Invalid lane number request on exising logical port.\n")));
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /*get the pm_type*/
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_pm_type_get(unit, pm_id, &pm_type));
    /*get the current tvco and ovco*/
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_vco_get(unit, pm_id, &pll_num, &tvco, &ovco));
    if (pll_num > 1) {
        LOG_ERROR(BSL_LS_BCM_PORT,
            (BSL_META_U(unit, "PLL get fail.\n")));
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_FAIL);
    }

    current_vco = tvco;

    /*Validate the speed for the manegement port*/
    if (pm_type == ltswPmTypePm4x10) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56990_a0_manage_port_vco_get(unit, resource->port, resource, &vco));
        if (vco != current_vco) {
            /*Only resource->port in PM core, return SHR_E_NONE*/
            if (BCM_PBMP_IS_NULL(port_pbmp)) {
                SHR_EXIT();
            } else {
                LOG_ERROR(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit, "VCO change is required for management port.\n")));
                BCM_PBMP_ASSIGN(*affect_ports, port_pbmp);
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        } else {
            SHR_EXIT();
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_lane_mask_get(unit, resource->port, &lane_mask));
    if (resource->fec_type ==bcmPortPhyFecRs272 ||
        resource->fec_type == bcmPortPhyFecRs272_2xN) {
        rs272_bmp |= lane_mask;
    }

    if (resource->fec_type ==bcmPortPhyFecRs544 ||
        resource->fec_type == bcmPortPhyFecRs544_2xN) {
        rs544_bmp |= lane_mask;
    }

    BCM_PBMP_ITER(port_pbmp, port) {
        /*Check the AN enable*/
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_ltsw_port_autoneg_get(unit, port, &an));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_ltsw_port_lane_mask_get(unit, port, &lane_mask));
        if (an) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_port_autoneg_ability_advert_get(unit, port, BCM56990_A0_MAX_AN_ABILITY,
                                                          an_ability, &an_ability_num));

            for (i = 0; i < an_ability_num; i++) {
                /*Set up fec bmp*/
                if (an_ability[i].fec_type == bcmPortPhyFecRs272 ||
                    an_ability[i].fec_type == bcmPortPhyFecRs272_2xN) {
                    rs272_bmp |= lane_mask;
                }

                if (an_ability[i].fec_type == bcmPortPhyFecRs544 ||
                    an_ability[i].fec_type == bcmPortPhyFecRs544_2xN) {
                    rs544_bmp |= lane_mask;
                }
            }
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_port_resource_get(unit, port, &speed_resource));
            /*Set up fec bmp*/
            if (speed_resource.fec_type == bcmPortPhyFecRs272 ||
                speed_resource.fec_type == bcmPortPhyFecRs272_2xN) {
                rs272_bmp |= lane_mask;
            }

            if (speed_resource.fec_type == bcmPortPhyFecRs544 ||
                speed_resource.fec_type == bcmPortPhyFecRs544_2xN) {
                rs544_bmp |= lane_mask;
            }
        }

        if ((lane_mask & 0xf) && (rs544_bmp & 0xf) && (rs272_bmp & 0xf)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                (BSL_META_U(unit, "Can not accommodate FEC settings on MPP0. Conflict with port %d\n"), port));
            BCM_PBMP_PORT_ADD(*affect_ports, port);
        }

        if ((lane_mask & 0xf0) && (rs544_bmp & 0xf0) && (rs272_bmp & 0xf0)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                (BSL_META_U(unit, "Can not accommodate FEC settings on MPP1. Conflict with port %d\n"), port));
            BCM_PBMP_PORT_ADD(*affect_ports, port);
        }
    }

    /*FEC check*/
    if(BCM_PBMP_NOT_NULL(*affect_ports)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /*VCO check*/
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56990_a0_fs_ability_table_vco_get(resource->speed, resource->lanes,
                                              resource->fec_type, &vco));

    if (vco == ltswPortVCOInvalid) {
        LOG_ERROR(BSL_LS_BCM_PORT,
            (BSL_META_U(unit, "port %d: speed[%d] lane[%d] fec[%d]is not supported.\n"),
             resource->port, resource->speed,resource->lanes, resource->fec_type));
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_CONFIG);
    }

    if ((resource->speed == 10000 && resource->lanes == 1)
        || (resource->speed == 40000 && resource->lanes == 4)) {
        if (current_vco == ltswPortVCO20P625G) {
            vco = ltswPortVCO20P625G;
        }
    }


    if (vco == current_vco) {
        /*No VCO change is required*/
        SHR_EXIT();
    } else {
        /*Only resource->port in PM core, return SHR_E_NONE*/
        if (BCM_PBMP_IS_NULL(port_pbmp)) {
            SHR_EXIT();
        } else {
            /*Speed change is not allowed, return the affected ports*/
            BCM_PBMP_ASSIGN(*affect_ports, port_pbmp);
            LOG_ERROR(BSL_LS_BCM_PORT,
                (BSL_META_U(unit, "Can not accommodate the request VCO.\n request [VCO %d].\n"),vco));
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_pm_port_rearrange(int unit, int nport, ltsw_flexport_port_cfg_t **port_cfg_array)
{
    int i;
    ltsw_flexport_port_cfg_t *po, *psrc, *pdst, tmp;

    SHR_FUNC_ENTER(unit);

    for (i = nport - 1, psrc = NULL; i >= 0; i--) {
        po = port_cfg_array[i];
        if (po->op & FLEXPORT_OP_DETACH) {
            break;
        }

        if (po->op & FLEXPORT_OP_ATTACH_FIRST) {
            psrc = po;
        }
    }

    if (psrc) {
        pdst = port_cfg_array[i+1];
        if (pdst != psrc) {
            sal_memcpy(&tmp, psrc, sizeof(tmp));
            sal_memcpy(psrc, pdst, sizeof(tmp));
            sal_memcpy(pdst, &tmp, sizeof(tmp));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Rearrange the sequence of operations.
 *
 * \param [in] unit Unit number.
 * \param [in] resource Flexport internal resource.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_flexport_rearrange(int unit,
                                    ltsw_flexport_resource_t *resource)
{
    int i, num_pm = resource->num_pm;
    ltsw_flexport_pm_cfg_t *pm;

    SHR_FUNC_ENTER(unit);

    for (i = 0, pm = resource->pm; i < num_pm; i ++, pm ++) {
        if (!pm->valid) {
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm56990_a0_ltsw_pm_port_rearrange(unit, pm->num_op, pm->operation));
    }

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Check that given lane mask of a logical port belongs to which half of PM.
 * Only 2 logical ports per half of PM(4 lanes).
 *
 * \param [in] unit Unit number.
 * \param [in] lane_mask Lane mask.
 * \param [in] lport Logical port.
 * \param [in] pm_half_r_inc 1: logical port uses a part of lanes 0-3, 2: uses all of lanes 0-3.
 * \param [in] pm_half_l_inc 1: logical port uses a part of lanes 4-7, 2: uses all of lanes 4-7.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_flexport_half_pm_lane_num_get(int unit,
                                               uint32_t lane_mask,
                                               bcm_port_t lport,
                                               int *pm_half_r_inc,
                                               int *pm_half_l_inc)
{
    SHR_FUNC_ENTER(unit);

    *pm_half_r_inc = 0;
    *pm_half_l_inc = 0;
    if ((lane_mask & 0xf) && (lane_mask & 0xf0)) {
        if ((lane_mask & 0xff) != 0xff) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "Invalid lane mask[0x%x] of lport[%d].\n"),
                       lane_mask, lport));
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
        }
        *pm_half_r_inc = 2;
        *pm_half_l_inc = 2;
    } else if (lane_mask & 0xf) {
        if ((lane_mask & 0xf) == 0xf) {
            *pm_half_r_inc = 2;
        } else {
            *pm_half_r_inc = 1;
        }
    } else if (lane_mask & 0xf0) {
        if ((lane_mask & 0xf0) == 0xf0) {
            *pm_half_l_inc = 2;
        } else {
            *pm_half_l_inc = 1;
        }
    } else {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,
                              "Invalid lane mask[0x%x] of lport[%d].\n"),
                   lane_mask, lport));
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Users can only flex to port configuration that have 4 logical ports per PM
 *  or 2 logical ports per half of PM (4 Serdes lanes).
 *
 * \param [in] unit Unit number.
 * \param [in] resource Flexport internal resource.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_flexport_lane_num_per_pm_validate(int unit,
                                                   ltsw_flexport_resource_t *resource)
{
    int i, j, lport_num;
    ltsw_flexport_port_cfg_t *po;
    int num_pm = ltsw_port_info[unit]->pm_num_max;
    ltsw_flexport_pm_cfg_t *pm;
    bcm_pbmp_t old_pbm, current_pbm;
    bcm_port_t lport;
    uint32_t lane_mask;
    int pm_half_l, pm_half_r, pm_r, pm_l;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < num_pm; i++) {
        pm = resource->pm + i;
        if (pm->valid == 0) {
            continue;
        }
        pm_half_l = 0;
        pm_half_r = 0;
        BCM_PBMP_ASSIGN(old_pbm, pm->pbm);
        BCM_PBMP_ITER(old_pbm, lport) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_port_lane_mask_get(unit, lport, &lane_mask));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56990_a0_ltsw_flexport_half_pm_lane_num_get(unit,
                                                                lane_mask,
                                                                lport,
                                                                &pm_r,
                                                                &pm_l));
            pm_half_l += pm_l;
            pm_half_r += pm_r;
        }
        BCM_PBMP_ASSIGN(current_pbm, pm->pbm);
        for (j = 0; j < pm->num_op; j++) {
            po = pm->operation[j];
            lport = po->lport;
            if (po->op & FLEXPORT_OP_DETACH) {
                BCM_PBMP_PORT_REMOVE(current_pbm, lport);

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmint_ltsw_port_lane_mask_get(unit, lport, &lane_mask));

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm56990_a0_ltsw_flexport_half_pm_lane_num_get(unit,
                                                                    lane_mask,
                                                                    lport,
                                                                    &pm_r,
                                                                    &pm_l));
                pm_half_l -= pm_l;
                pm_half_r -= pm_r;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmint_ltsw_pport_lane_mask_get(unit, po->pport,
                                                     po->lanes, &lane_mask));
                if (BCM_PBMP_MEMBER(current_pbm, lport) == 0) {
                    BCM_PBMP_PORT_ADD(current_pbm, lport);
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcm56990_a0_ltsw_flexport_half_pm_lane_num_get(unit,
                                                                        lane_mask,
                                                                        lport,
                                                                        &pm_r,
                                                                        &pm_l));
                    pm_half_l += pm_l;
                    pm_half_r += pm_r;
                }
            }
        }
        BCM_PBMP_COUNT(current_pbm, lport_num);
        if (lport_num > 4) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "lport number in PM[%d]"
                                  " is larger than 4.\n"), i));
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        if (pm_half_r > 2 || pm_half_l > 2) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "User can only flex to port configuration "
                                  "that 2 logical ports per half of PM[%d].\n"),
                       i));
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        if (pm_half_r < 0 || pm_half_l < 0) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "User can not flex to port configuration "
                                  "that number of logical ports per half of PM[%d] < 0.\n"),
                       i));
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check that given lane setting is valid for physical port.
 *
 * \param [in] unit Unit number.
 * \param [in] resource Flexport internal resource.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_flexport_lane_validate(int unit,
                                        ltsw_flexport_resource_t *resource)
{
    int i, num_op = resource->num_op, pport, lanes;
    ltsw_flexport_port_cfg_t *po;

    SHR_FUNC_ENTER(unit);

    for (i = 0, po = resource->operation; i < num_op; i ++, po ++) {
        if (po->op & FLEXPORT_OP_DETACH) {
            continue;
        }
        pport = po->pport;
        lanes = po->lanes;

        /* legal number of lanes */
        if ((lanes != 1) && (lanes != 2) && (lanes != 4) && (lanes != 8)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit, "Invalid number of lanes %d\n"),
                       lanes));
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        /* lane alignment and not across pm */
        if (((pport - 1) * 2) % lanes != 0) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "Invalid number of lanes %d for "
                                  "physical port %d\n"),
                       lanes, pport));
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check that given speed is valid for the number of serdes lanes.
 *
 * \param [in] unit Unit number.
 * \param [in] resource Flexport internal resource.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_flexport_speed_validate(int unit,
                                         ltsw_flexport_resource_t *resource)
{
    int i, num_op = resource->num_op, core_clk, speed, speed_max;
    ltsw_flexport_port_cfg_t *po;

    SHR_FUNC_ENTER(unit);

    core_clk = bcmi_ltsw_dev_core_clk_freq(unit);
    speed_max = (core_clk < 1325) ? 200000 : 400000;

    for (i = 0, po = resource->operation; i < num_op; i ++, po ++) {
        if (po->op & FLEXPORT_OP_DETACH) {
            continue;
        }
        speed = po->speed;
        if (speed > speed_max) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "Core clk %dMHz doesn't support "
                                  "%dG port\n"),
                       core_clk, speed / 1000));
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check that given encap is valid for port.
 *
 * \param [in] unit Unit number.
 * \param [in] resource Flexport internal resource.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_flexport_encap_validate(int unit,
                                         ltsw_flexport_resource_t *resource)
{
    int i, num_op = resource->num_op, encap;
    ltsw_flexport_port_cfg_t *po;

    SHR_FUNC_ENTER(unit);

    for (i = 0, po = resource->operation; i < num_op; i ++, po ++) {
        if (po->op & FLEXPORT_OP_DETACH) {
            continue;
        }

        encap = po->encap;

        if (encap != BCM_PORT_ENCAP_IEEE) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "Invalid encap mode %d on port %d\n"),
                       encap, po->lport));
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check flexport input parameters and port status are valid.
 *
 * \param [in] unit Unit number.
 * \param [in] resource Flexport internal resource.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_flexport_input_validate(int unit,
                                         ltsw_flexport_resource_t *resource)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_flexport_operation_order_validate(unit, resource));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_flexport_port_eligible_validate(unit, resource));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_flexport_port_status_validate(unit, resource));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56990_a0_ltsw_flexport_lane_validate(unit, resource));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56990_a0_ltsw_flexport_speed_validate(unit, resource));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56990_a0_ltsw_flexport_encap_validate(unit, resource));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_flexport_pipe_validate(unit, resource));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_flexport_lane_config_validate(unit, resource));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_flexport_link_training_validate(unit, resource));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check device has enough resource to complete all operations.
 *
 * \param [in] unit Unit number.
 * \param [in] resource Flexport internal resource.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_flexport_resource_validate(int unit,
                                            ltsw_flexport_resource_t *resource)
{
    int i;
    ltsw_flexport_pm_cfg_t *pm;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56990_a0_ltsw_flexport_lane_num_per_pm_validate(unit, resource));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_flexport_linkscan_validate(unit, resource));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_flexport_port_mapping_validate(unit, resource));

    for (i = 0, pm = resource->pm; i <= MAX_NUM_FP_PM; i ++, pm ++) {
        if (pm->valid) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56990_a0_ltsw_flexport_pm_validate
                    (unit, &pm->pbm, pm->num_op, pm->operation));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56990_a0_ltsw_flexport_rearrange(unit, resource));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Attach ports to the BCM layer and initialize them to the default state.
 *
 * \param [in] unit Unit number.
 * \param [in] resource Flexport internal resource.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_flexport_resource_attach(int unit,
                                          ltsw_flexport_resource_t *resource)
{
    int i, num_op = resource->num_op, port;
    ltsw_flexport_port_cfg_t *po = NULL;
    bcm_mac_t mac = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    SHR_FUNC_ENTER(unit);

    for (i = 0, po = resource->operation; i < num_op; i ++, po ++) {
        if (po->op & FLEXPORT_OP_DETACH) {
            continue;
        }

        port = po->lport;

        if (po->op & (FLEXPORT_OP_ADD | FLEXPORT_OP_REMAP | FLEXPORT_OP_SPEED)) {
            /* port info init */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_port_software_init_per_port(unit, port));
        }
        if (po->op & (FLEXPORT_OP_ADD | FLEXPORT_OP_REMAP)) {
            /* port init */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56990_a0_ltsw_port_profile_init_per_port(unit, port));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56990_a0_ltsw_port_service_init_per_port(unit, port));
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_ltsw_port_misc_init_per_port(unit, port));
            /* ipmc */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_ipmc_egress_port_set(unit, port, mac, 0, 0, 0));
            /* stg */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_stg_port_attach(unit, port));

            /* vlan */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_vlan_port_attach(unit, port));
            /* reset operation */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_vlan_port_egress_default_action_delete(unit, port));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_vlan_port_default_action_delete(unit, port));

            /* cosq */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_cosq_port_attach(unit, port));

            /* field */

            /* mirror */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_mirror_port_attach(unit, port));

        }

        if (po->op & (FLEXPORT_OP_ADD | FLEXPORT_OP_REMAP | FLEXPORT_OP_LANES |
                      FLEXPORT_OP_PC_RESET)) {
            /* link */
            SHR_IF_ERR_EXIT
                (bcmi_ltsw_link_port_control_attach(unit, port));

            /* pm init */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_port_pm_init_per_port(unit, port));

            /* stat */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_stat_port_attach(unit, port));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Detach ports from the BCM layer.
 *
 * \param [in] unit Unit number.
 * \param [in] resource Flexport internal resource.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_flexport_resource_detach(int unit,
                                          ltsw_flexport_resource_t *resource)
{
    int i, num_op = resource->num_op, port;
    ltsw_flexport_port_cfg_t *po = NULL;
    bcm_mac_t mac = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    SHR_FUNC_ENTER(unit);

    for (i = 0, po = resource->operation; i < num_op; i ++, po ++) {
        if (!(po->op & FLEXPORT_OP_DETACH)) {
            continue;
        }

        port = po->lport;

        if (po->op & (FLEXPORT_OP_DEL | FLEXPORT_OP_REMAP | FLEXPORT_OP_LANES |
                      FLEXPORT_OP_PC_RESET)) {
            /* link */
            SHR_IF_ERR_EXIT
                (bcmi_ltsw_link_port_control_detach(unit, port));

            /* stat */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_stat_port_detach(unit, port));
        }
        if (po->op & (FLEXPORT_OP_DEL | FLEXPORT_OP_REMAP)) {
            /* ipmc */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_ipmc_egress_port_set(unit, port, mac, 0, 0, 0));

            /* mirror */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_mirror_port_detach(unit, port));

            /* field */

            /* cosq */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_cosq_port_detach(unit, port));

            /* vlan */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_vlan_port_detach(unit, port));
            /* reset operation */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_vlan_port_egress_default_action_delete(unit, port));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_vlan_port_default_action_delete(unit, port));

            /* stg */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_stg_port_detach(unit, port));

            /* port deinit */
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_ltsw_port_misc_deinit_per_port(unit, port));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56990_a0_ltsw_port_profile_deinit_per_port(unit, port));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56990_a0_ltsw_port_service_deinit_per_port(unit, port));
        }

        if (po->op & (FLEXPORT_OP_DEL | FLEXPORT_OP_REMAP | FLEXPORT_OP_SPEED )) {
            /* port info deinit */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_ltsw_port_software_deinit_per_port(unit, port));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_pm_port_init_adjust(int unit, int nport,
                                     ltsw_flexport_port_cfg_t *ltsw_port_resource,
                                     int original_tvco)
{
    ltsw_flexport_port_cfg_t* operation[MAX_PORT_PER_PM] = {NULL};
    bcm_pbmp_t current_pbm;
    int i;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(current_pbm);

    for (i = 0; i < nport; i++) {
        operation[i] = &ltsw_port_resource[i];
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56990_a0_ltsw_flexport_pm_validate(unit, &current_pbm, nport, operation));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56990_a0_ltsw_pm_port_rearrange(unit, nport, operation));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the port resource status to dependent modules after flex operation.
 *
 * \param [in] unit Unit number.
 * \param [in] resource Flexport internal resource.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56990_a0_ltsw_flexport_resource_status_update(int unit,
                                                 ltsw_flexport_resource_t *resource)
{
    int i, num_op = resource->num_op;
    bcm_pbmp_t add_pbm, del_pbm;
    ltsw_flexport_port_cfg_t *po = NULL;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(add_pbm);
    BCM_PBMP_CLEAR(del_pbm);
    for (i = 0, po = resource->operation; i < num_op; i ++, po ++) {
        if (po->op & (FLEXPORT_OP_ADD | FLEXPORT_OP_DEL | FLEXPORT_OP_REMAP)) {
            if (po->op & FLEXPORT_OP_DETACH) {
                BCM_PBMP_PORT_ADD(del_pbm, po->lport);
            } else {
                BCM_PBMP_PORT_ADD(add_pbm, po->lport);
            }
        }
    }
    /* to be replaced by module functions */
    SHR_ERR_EXIT(
        bcmi_ltsw_field_flex_port_update(unit, del_pbm, add_pbm));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_port_fdr_config_set(int unit, bcm_port_t port, bcm_port_fdr_config_t *fdr_config)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_fdr_config_set(unit, port, fdr_config));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_port_fdr_config_get(int unit, bcm_port_t port, bcm_port_fdr_config_t *fdr_config)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_fdr_config_get(unit, port, fdr_config));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_port_fdr_stats_get(int unit, bcm_port_t port, bcm_port_fdr_stats_t *fdr_stats)
{
    uint32_t field_bmp;

    SHR_FUNC_ENTER(unit);

    field_bmp = BCM56990_A0_FDR_CW_S_ERR_MASK;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_fdr_stats_get(unit, port, field_bmp, fdr_stats));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_port_fdr_callback_register(int unit, bcm_port_fdr_handler_t f, void* user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_fdr_callback_register(unit, f, user_data));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_port_fdr_callback_unregister(int unit, bcm_port_fdr_handler_t f, void* user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_ltsw_port_fdr_callback_unregister(unit, f, user_data));

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Port driver function variable for bcm56990_a0 device.
 */
static mbcm_ltsw_port_drv_t bcm56990_a0_ltsw_port_drv = {
    .port_info_init                         = bcm56990_a0_ltsw_port_info_init,
    .port_info_init_per_port                = bcm56990_a0_ltsw_port_info_init_per_port,
    .port_info_deinit                       = bcm56990_a0_ltsw_port_info_deinit,
    .port_info_recover                      = xgs_ltsw_port_info_recover,
    .port_misc_init                         = xgs_ltsw_port_misc_init,
    .port_misc_deinit                       = xgs_ltsw_port_misc_deinit,
    .port_profile_init                      = bcm56990_a0_ltsw_port_profile_init,
    .port_profile_deinit                    = bcm56990_a0_ltsw_port_profile_deinit,
    .port_profile_port_pkt_ctrl_add         = xgs_ltsw_port_profile_port_pkt_ctrl_add,
    .port_profile_port_pkt_ctrl_get         = xgs_ltsw_port_profile_port_pkt_ctrl_get,
    .port_profile_port_pkt_ctrl_delete      = xgs_ltsw_port_profile_port_pkt_ctrl_delete,
    .port_profile_port_pkt_ctrl_recover     = xgs_ltsw_port_profile_port_pkt_ctrl_recover,
    .port_profile_port_pkt_ctrl_update      = xgs_ltsw_port_profile_port_pkt_ctrl_update,
    .port_profile_port_pkt_ctrl_field_get   = xgs_ltsw_port_profile_port_pkt_ctrl_field_get,
    .port_tabs_info_get                     = xgs_ltsw_port_tabs_info_get,
    .port_tabs_op_get                       = xgs_ltsw_port_tabs_op_get,
    .port_tabs_para_get                     = xgs_ltsw_port_tabs_para_get,
    .port_tpid_set                          = xgs_ltsw_port_tpid_set,
    .port_tpid_add                          = xgs_ltsw_port_tpid_add,
    .port_tpid_get                          = xgs_ltsw_port_tpid_get,
    .port_tpid_get_all                      = xgs_ltsw_port_tpid_get_all,
    .port_tpid_delete                       = xgs_ltsw_port_tpid_delete,
    .port_tpid_delete_all                   = xgs_ltsw_port_tpid_delete_all,
    .port_service_init                      = bcm56990_a0_ltsw_port_service_init,
    .port_service_deinit                    = bcm56990_a0_ltsw_port_service_deinit,
    .port_control_get                       = xgs_ltsw_port_control_get,
    .port_control_set                       = xgs_ltsw_port_control_set,
    .port_subsidiary_ports_get              = bcm56990_a0_ltsw_port_subsidiary_ports_get,
    .port_learn_set                         = xgs_ltsw_port_learn_set,
    .port_learn_get                         = xgs_ltsw_port_learn_get,
    .port_l3_enable_set                     = xgs_ltsw_port_l3_enable_set,
    .port_l3_enable_get                     = xgs_ltsw_port_l3_enable_get,
    .port_l3_mtu_set                        = xgs_ltsw_port_l3_mtu_set,
    .port_l3_mtu_get                        = xgs_ltsw_port_l3_mtu_get,
    .port_ipmc_modify_set                   = xgs_ltsw_port_ipmc_modify_set,
    .port_ipmc_modify_get                   = xgs_ltsw_port_ipmc_modify_get,
    .port_queue_count_get                   = xgs_ltsw_port_queue_count_get,
    .port_stat_attach                       = xgs_ltsw_port_stat_attach,
    .port_stat_detach                       = xgs_ltsw_port_stat_detach,
    .port_flood_block_set                   = xgs_ltsw_port_flood_block_set,
    .port_flood_block_get                   = xgs_ltsw_port_flood_block_get,
    .port_bpdu_enable_set                   = xgs_ltsw_port_bpdu_enable_set,
    .port_bpdu_enable_get                   = xgs_ltsw_port_bpdu_enable_get,
    .port_ing_vlan_action_get               = xgs_ltsw_port_ing_vlan_action_get,
    .port_ing_vlan_action_set               = xgs_ltsw_port_ing_vlan_action_set,
    .port_egr_vlan_action_get               = xgs_ltsw_port_egr_vlan_action_get,
    .port_egr_vlan_action_set               = xgs_ltsw_port_egr_vlan_action_set,
    .port_force_vlan_set                    = xgs_ltsw_port_force_vlan_set,
    .port_force_vlan_get                    = xgs_ltsw_port_force_vlan_get,
    .port_vlan_member_set                   = xgs_ltsw_port_vlan_member_set,
    .port_vlan_member_get                   = xgs_ltsw_port_vlan_member_get,
    .port_untagged_vlan_get                 = xgs_ltsw_port_untagged_vlan_get,
    .port_untagged_vlan_set                 = xgs_ltsw_port_untagged_vlan_set,
    .port_untagged_priority_get             = xgs_ltsw_port_untagged_priority_get,
    .port_untagged_priority_set             = xgs_ltsw_port_untagged_priority_set,
    .port_tgid_set                          = xgs_ltsw_port_tgid_set,
    .port_tgid_get                          = xgs_ltsw_port_tgid_get,
    .port_profile_lport_tab_update          = xgs_ltsw_port_profile_lport_tab_update,
    .port_dscp_phb_map_mode_set             = xgs_ltsw_port_dscp_phb_map_mode_set,
    .port_dscp_phb_map_mode_get             = xgs_ltsw_port_dscp_phb_map_mode_get,
    .port_egr_shaper_set                    = xgs_ltsw_port_egr_shaper_set,
    .port_egr_shaper_get                    = xgs_ltsw_port_egr_shaper_get,
    .port_egr_shaper_validate               = bcm56990_a0_ltsw_port_egr_shaper_validate,
    .port_class_validate                    = bcm56990_a0_ltsw_port_class_validate,
    .port_class_get                         = xgs_ltsw_port_class_get,
    .port_class_set                         = xgs_ltsw_port_class_set,
    .port_discard_set                       = xgs_ltsw_port_discard_set,
    .port_discard_get                       = xgs_ltsw_port_discard_get,
    .port_egress_set                        = xgs_ltsw_port_egress_set,
    .port_egress_get                        = xgs_ltsw_port_egress_get,
    .flexport_input_validate                = bcm56990_a0_ltsw_flexport_input_validate,
    .flexport_resource_validate             = bcm56990_a0_ltsw_flexport_resource_validate,
    .flexport_resource_attach               = bcm56990_a0_ltsw_flexport_resource_attach,
    .flexport_resource_detach               = bcm56990_a0_ltsw_flexport_resource_detach,
    .flexport_resource_status_update        = bcm56990_a0_ltsw_flexport_resource_status_update,
    .pm_port_init_adjust                    = bcm56990_a0_ltsw_pm_port_init_adjust,
    .port_speed_config_validate             = bcm56990_a0_ltsw_port_speed_config_validate,
    .port_fdr_config_set                    = bcm56990_a0_ltsw_port_fdr_config_set,
    .port_fdr_config_get                    = bcm56990_a0_ltsw_port_fdr_config_get,
    .port_fdr_stats_get                     = bcm56990_a0_ltsw_port_fdr_stats_get,
    .port_fdr_callback_register             = bcm56990_a0_ltsw_port_fdr_callback_register,
    .port_fdr_callback_unregister           = bcm56990_a0_ltsw_port_fdr_callback_unregister,
    .port_sample_rate_set                   = xgs_ltsw_port_sample_rate_set,
    .port_sample_rate_get                   = xgs_ltsw_port_sample_rate_get,
};

/******************************************************************************
 * Public functions
 */

int
bcm56990_a0_ltsw_port_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_port_drv_set(unit, &bcm56990_a0_ltsw_port_drv));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Attach functions for other members.
 */
#define BCM56990_A0_DRV_ATTACH_ENTRY(_dn,_vn,_pf,_pd,_r0) \
int _vn##_ltsw_port_drv_attach(int unit) \
{ \
    SHR_FUNC_ENTER(unit); \
    SHR_IF_ERR_VERBOSE_EXIT \
        (mbcm_ltsw_port_drv_set(unit, &bcm56990_a0_ltsw_port_drv)); \
    SHR_IF_ERR_VERBOSE_EXIT \
        (bcm56990_a0_sub_drv_attach(unit, &bcm56990_a0_ltsw_port_drv, \
                                    BCM56990_A0_SUB_DRV_##_dn, \
                                    BCM56990_A0_SUB_MOD_PORT)); \
exit: \
    SHR_FUNC_EXIT(); \
}
#include "sub_devlist.h"
