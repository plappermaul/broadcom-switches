/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm/cosq.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/mbcm/mod.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/cosq.h>
#include <bcm_int/ltsw/cosq_int.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/mirror.h>

#include <shr/shr_bitop.h>
#include <sal/sal_types.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>
#include <bcmlt/bcmlt.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_COSQ

/*!
 * \brief Cosq mirror-on-drop config structure.
 */
typedef struct cosq_mod_config_s {

    /*! Profile used bitmap. */
    SHR_BITDCL *profile_bmp;

    /*! Profile number. */
    uint32_t profile_num;

    /*! Dest ID number. */
    uint32_t dest_id_num;

} cosq_mod_config_t;

/*!
 * \brief Cosq mirror-on-drop dest profile structure.
 */
typedef struct cosq_mod_dest_profile_s {

    /*! Local port id. */
    bcm_port_t port;

    /*! Queue id. */
    int cosq;

} cosq_mod_dest_profile_t;

/******************************************************************************
 * Private functions
 */


/* Cosq mod config global structure. */
static cosq_mod_config_t cosq_mod_cfg[BCM_MAX_NUM_UNITS];

/* Cosq mod config. */
#define MOD_CFG(uint) (&cosq_mod_cfg[unit])

/* Cosq mod profile number. */
#define MOD_PROFILE_NUM(unit) \
            (MOD_CFG(unit)->profile_num)

/* Cosq mod profile used bitmap. */
#define MOD_PROF_BMP(unit) \
            (MOD_CFG(unit)->profile_bmp)

/* Set Cosq mod profile used bitmap. */
#define MOD_PROF_BMP_USED_SET(unit, id) \
            (SHR_BITSET(MOD_PROF_BMP(unit), id))

/* Get Cosq mod profile used bitmap. */
#define MOD_PROF_BMP_USED_GET(unit, id) \
            (SHR_BITGET(MOD_PROF_BMP(unit), id))

/* Clear Cosq mod profile used bitmap. */
#define MOD_PROF_BMP_USED_CLR(unit, id) \
            (SHR_BITCLR(MOD_PROF_BMP(unit), id))

/* Cosq mod dest ID number. */
#define MOD_DEST_ID_NUM(unit) \
            (MOD_CFG(unit)->dest_id_num)

/* ITM number per device */
#define ITMS_PER_DEV            2

/*!
 * \brief Set mod control configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] config Cosq mod control configuration structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_control_set(int unit, bcm_cosq_mod_control_t *control)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {RESERVED_LIMIT_CELLSs, 0, 0, {0}},
        /*1*/ {OPERATIONAL_STATEs, 0, 0, {0}},
    };
    bcmi_ltsw_cosq_device_info_t info;
    uint32_t valid_flags;
    SHR_FUNC_ENTER(unit);

    /* No flags are set. */
    if (!(control->valid_flags & (BCM_COSQ_MOD_CONTROL_POOL_LIMIT_VALID))) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    valid_flags = control->valid_flags
                  & (~(BCM_COSQ_MOD_CONTROL_POOL_LIMIT_VALID));
    /* Invalid flag is set. */
    if (valid_flags != 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Get MMU cell size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &info));

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    if (control->valid_flags & BCM_COSQ_MOD_CONTROL_POOL_LIMIT_VALID) {
        field[0].u.val = (control->pool_limit + (info.mmu_cell_size - 1)) /
                          info.mmu_cell_size;
        field[0].flags = BCMI_LT_FIELD_F_SET;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit,
                           TM_MIRROR_ON_DROP_CONTROLs,
                           &lt_entry,
                           NULL));

    field[0].flags = 0;
    field[1].flags = BCMI_LT_FIELD_F_GET | BCMI_LT_FIELD_F_SYMBOL;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           TM_MIRROR_ON_DROP_CONTROLs,
                           &lt_entry,
                           NULL,
                           NULL));

    /* Incorrect cell limit. */
    if (sal_strcasecmp(field[1].u.sym_val,
                       INCORRECT_RESERVED_CELLS_LIMITs) == 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mod control configuration.
 *
 * \param [in] unit Unit Number.
 * \param [out] config Cosq mod control configuration structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_control_get(int unit, bcm_cosq_mod_control_t *control)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {RESERVED_LIMIT_CELLSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {OPERATIONAL_STATEs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    bcmi_ltsw_cosq_device_info_t info;
    SHR_FUNC_ENTER(unit);

    /* Get MMU cell size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &info));

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[1].flags |= BCMI_LT_FIELD_F_SYMBOL;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           TM_MIRROR_ON_DROP_CONTROLs,
                           &lt_entry,
                           NULL,
                           NULL));

    /* Incorrect cell limit. */
    if (sal_strcasecmp(field[1].u.sym_val,
                       INCORRECT_RESERVED_CELLS_LIMITs) == 0) {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    control->pool_limit = field[0].u.val * info.mmu_cell_size;
    control->valid_flags |= BCM_COSQ_MOD_CONTROL_POOL_LIMIT_VALID;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Allocate a mod profile id.
 *
 * \param [in] unit Unit Number.
 * \param [out] id Profile id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_profile_id_alloc(int unit, int *id)
{
    int i, size;
    cosq_mod_config_t *mod_cfg = MOD_CFG(unit);
    SHR_BITDCL *bitmap = NULL;
    SHR_FUNC_ENTER(unit);

    bitmap = mod_cfg->profile_bmp;
    size = MOD_PROFILE_NUM(unit);
    SHR_NULL_CHECK(bitmap, SHR_E_INIT);

    for (i = 0; i < size; i++) {
        if (!SHR_BITGET(bitmap, i)) {
            break;
        }
    }

    if (i >= size) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }
    *id = i;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Hold a mod profile id.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Profile id.
 */
static void
cosq_mod_profile_id_hold(int unit, int id)
{
    if (id >= MOD_PROFILE_NUM(unit)) {
        return;
    }
    MOD_PROF_BMP_USED_SET(unit, id);
    return;
}

/*!
 * \brief Free a mod profile id.
 *
 * \param [in] unit Unit Number.
 * \param [out] id Profile id.
 */
static void
cosq_mod_profile_id_free(int unit, int id)
{
    if (id >= MOD_PROFILE_NUM(unit)) {
        return;
    }
    MOD_PROF_BMP_USED_CLR(unit, id);
    return;
}

/*!
 * \brief Create a mod profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] options Options flags.
 * \param [out] profile_id Profile id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_profile_create(int unit, uint32_t options, int *profile_id)
{
    int id;
    SHR_FUNC_ENTER(unit);

    if (options & BCM_COSQ_MOD_PROFILE_OPTIONS_WITH_ID) {
        id = *profile_id;
        if (id < 0 || id >= MOD_PROFILE_NUM(unit)) {
            SHR_ERR_EXIT(SHR_E_BADID);
        }

        if (MOD_PROF_BMP_USED_GET(unit, id)) {
            SHR_ERR_EXIT(SHR_E_EXISTS);
        }

        /* Mark profile id is used. */
        cosq_mod_profile_id_hold(unit, id);
    } else {
        /* Allocate mod profile id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_mod_profile_id_alloc(unit, &id));

        /* Mark profile id is used. */
        cosq_mod_profile_id_hold(unit, id);
        *profile_id = id;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a mod profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id Profile id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_profile_destroy(int unit, int profile_id)
{
    SHR_FUNC_ENTER(unit);

    if (profile_id < 0 || profile_id >= MOD_PROFILE_NUM(unit)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (!MOD_PROF_BMP_USED_GET(unit, profile_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* Free mod profile id. */
    cosq_mod_profile_id_free(unit, profile_id);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set a mod profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id Profile id.
 * \param [in] profile Mod profile structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_profile_set(int unit, int profile_id, bcm_cosq_mod_profile_t *profile)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_MIRROR_ON_DROP_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {PERCENTAGE_0_25s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {PERCENTAGE_25_50s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {PERCENTAGE_50_75s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {PERCENTAGE_75_100s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {MIRROR_ON_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    SHR_FUNC_ENTER(unit);

    if (profile_id < 0 || profile_id >= MOD_PROFILE_NUM(unit)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (!MOD_PROF_BMP_USED_GET(unit, profile_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = profile_id;
    field[1].u.val = profile->percent_0_25;
    field[2].u.val = profile->percent_25_50;
    field[3].u.val = profile->percent_50_75;
    field[4].u.val = profile->percent_75_100;
    field[5].u.val = (profile->enable == 0) ? 0 : 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit,
                           TM_MIRROR_ON_DROP_PROFILEs,
                           &lt_entry,
                           NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get a mod profile for given profile id.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id Profile id.
 * \param [out] profile Mod profile structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_profile_get(int unit, int profile_id, bcm_cosq_mod_profile_t *profile)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_MIRROR_ON_DROP_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {PERCENTAGE_0_25s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {PERCENTAGE_25_50s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {PERCENTAGE_50_75s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {PERCENTAGE_75_100s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {MIRROR_ON_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    SHR_FUNC_ENTER(unit);

    if (profile_id < 0 || profile_id >= MOD_PROFILE_NUM(unit)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (!MOD_PROF_BMP_USED_GET(unit, profile_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = profile_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           TM_MIRROR_ON_DROP_PROFILEs,
                           &lt_entry,
                           NULL,
                           NULL));

    profile->percent_0_25   = field[1].u.val;
    profile->percent_25_50  = field[2].u.val;
    profile->percent_50_75  = field[3].u.val;
    profile->percent_75_100 = field[4].u.val;
    profile->enable = field[5].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Add an MOD dest profile.
 *
 * This function is used to add an entry into LT TM_MIRROR_ON_DROP_DESTINATIONs.
 *
 * \param [in]  unit                    Unit Number.
 * \param [in]  profile                 Profile data.
 * \param [out] profile_idx           Profile index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_entry_add(int unit, cosq_mod_dest_profile_t *profile,
                        int profile_idx)
{
    bcmi_lt_entry_t lt_entry;

    /* LT TM_MIRROR_ON_DROP_DESTINATION */
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_MIRROR_ON_DROP_DESTINATION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {TM_MC_Q_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = profile_idx;
    field[1].u.val = profile->port;
    field[2].u.val = profile->cosq;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit,
                           TM_MIRROR_ON_DROP_DESTINATIONs,
                           &lt_entry,
                           NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get info of a mod destination profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_idx           Profile index.
 * \param [out]  profile              Profile data.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_entry_get(int unit, int profile_idx,
                        cosq_mod_dest_profile_t *profile)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_MIRROR_ON_DROP_DESTINATION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {PORT_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {TM_MC_Q_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = profile_idx;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           TM_MIRROR_ON_DROP_DESTINATIONs,
                           &lt_entry,
                           NULL,
                           NULL));

    profile->port = field[1].u.val;
    profile->cosq = field[2].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete mod destination.
 *
 * \param [in] unit Unit Number.
 * \param [in] mod_dest_id mod dest id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_entry_delete(int unit, int profile_idx)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_MIRROR_ON_DROP_DESTINATION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = profile_idx;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              TM_MIRROR_ON_DROP_DESTINATIONs,
                              &lt_entry,
                              NULL));
exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Add a MOD dest profile.
 *
 * This function is used to add an entry into LT TM_MIRROR_ON_DROP_DESTINATIONs.
 *
 * \param [in]  unit                    Unit Number.
 * \param [in]  profile                 Profile data.
 * \param [out] profile_idx           Profile index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_profile_add(int unit, cosq_mod_dest_profile_t *profile,
                          int *profile_idx)
{
    int rv = SHR_E_NONE;
    int entries_per_set = 1;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_allocate(unit, BCMI_LTSW_PROFILE_COSQ_MOD_DEST,
                                          profile, 0,
                                          entries_per_set, profile_idx);
    /* Get an existing entry and return the profile index directly */
    if (rv == SHR_E_EXISTS) {
        SHR_EXIT();
    }

    if (rv == SHR_E_FULL) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }

    SHR_IF_ERR_VERBOSE_EXIT(rv);

    /* Add an entry into LT */
    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_entry_add(unit, profile, *profile_idx));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Get info of a mod destination profile.
 *
 * This function is used to get a entry from LT TM_MIRROR_ON_DROP_DESTINATIONs.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_idx           Profile index.
 * \param [out]  profile              Profile data.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */

static int
cosq_mod_dest_profile_get(int unit, int profile_idx,
                          cosq_mod_dest_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_entry_get(unit, profile_idx, profile));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Delete a MOD dest profile.
 *
 * This function is used to delete a entry from LT TM_MIRROR_ON_DROP_DESTINATIONs.
 *
 * \param [in]  unit                 Unit Number.
 * \param [in] profile_idx        Profile entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_profile_delete(int unit, int profile_idx)
{
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_free(unit, BCMI_LTSW_PROFILE_COSQ_MOD_DEST,
                                      profile_idx);
    if (rv == SHR_E_BUSY) {
        /* Profile index is still used by others and return directly */
        SHR_EXIT();
    }

    if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    /* Delete the entry from LT */
    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_entry_delete(unit, profile_idx));

exit:

    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash of MOD dest profile set.
 *
 * \param [in] unit Unit number.
 * \param [in] entries First profile entry in the set.
 * \param [in] entries_per_set Number of profile entries in the set.
 * \param [out] hash Hash value.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_profile_hash_cb(int unit, void *entries,
                              int entries_per_set, uint32_t *hash)
{
    int size = entries_per_set * sizeof(cosq_mod_dest_profile_t);
    *hash = shr_crc32(0, entries, size);
    return SHR_E_NONE;
}

/*!
 * \brief Compare profile set for MOD dest profile.
 *
 * Compare if given MOD dest profile entries equals to
 * the entries in LT.
 *
 * \param [in] unit Unit number.
 * \param [in] entries First profile entry in the set.
 * \param [in] entries_per_set Number of profile entries in the set.
 * \param [in] index Profile table index to be compared.
 * \param [out] cmp 0 if equal, otherwise not equal.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_profile_cmp_cb(int unit, void *entries,
                             int entries_per_set, int index, int *cmp)
{
    cosq_mod_dest_profile_t profile;

    SHR_FUNC_ENTER(unit);

    if (entries_per_set != 1) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    sal_memset(&profile, 0, sizeof(cosq_mod_dest_profile_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_entry_get(unit, index, &profile));

    *cmp = sal_memcmp(entries, (void *)&profile,
                      sizeof(cosq_mod_dest_profile_t));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Register MOD dest profile.
 *
 * This function is used to register LT TM_MIRROR_ON_DROP_DESTINATIONs.
 *
 * \param [in]  unit                 Unit Number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_profile_register(int unit)
{
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_COSQ_MOD_DEST;
    int ent_idx_min = 0;
    int ent_idx_max = 0;

    SHR_FUNC_ENTER(unit);

    ent_idx_min = 0;
    ent_idx_max = (int)MOD_DEST_ID_NUM(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit, &profile_hdl,
                                    &ent_idx_min, &ent_idx_max, 1,
                                    cosq_mod_dest_profile_hash_cb,
                                    cosq_mod_dest_profile_cmp_cb));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover MOD dest profile information.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_profile_info_recover(int unit, int profile_idx)
{
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_COSQ_MOD_DEST;
    cosq_mod_dest_profile_t profile;
    int entries_per_set = 1;
    uint32_t ref_count = 0;
    int index;

    SHR_FUNC_ENTER(unit);

    sal_memset(&profile, 0, sizeof(cosq_mod_dest_profile_t));

    index = profile_idx * entries_per_set;

    /* Update profile hash on the first usage.  */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_get(unit, profile_hdl, index,
                                         &ref_count));

    if (ref_count == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_mod_dest_entry_get(unit, profile_idx, &profile));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_hash_update(unit, profile_hdl, &profile,
                                           entries_per_set, index));

    }

    /* Increment reference count. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_increase(unit, profile_hdl,
                                              entries_per_set, index, 1));
exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Recover MOD dest profile from MOD profile table after wb.
 *
 * This function is used to Recover hash and reference count of
 * LT TM_MIRROR_ON_DROP_DESTINATIONs profile.
 *
 * \param [in]  unit                 Unit Number.
 * \param [in] index                 Entry index of profile table.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_profile_recover(int unit)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv, dunit, profile_idx;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MIRROR_ON_DROP_PROFILEs, &entry_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, TM_MIRROR_ON_DROP_DESTINATION_IDs,
                                   &data));

        profile_idx = data;

        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_mod_dest_profile_info_recover(unit, profile_idx));
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_free(entry_hdl));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize MOD dest profile information.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_profile_init(int unit)
{
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_COSQ_MOD_DEST;
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit, profile_hdl), SHR_E_NOT_FOUND);

    /* Register profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_profile_register(unit));

    if(!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TM_MIRROR_ON_DROP_DESTINATIONs));

    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_mod_dest_profile_recover(unit));
    }

exit:
    SHR_FUNC_EXIT();

}


/*!
 * \brief De-initialize MOD dest profile information.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_profile_deinit(int unit)
{
    int rv = SHR_E_NONE;
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_COSQ_MOD_DEST;

    SHR_FUNC_ENTER(unit);

    /* unregister in case the profile exists */
    rv = bcmi_ltsw_profile_unregister(unit, profile_hdl);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    /* clear profile table */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TM_MIRROR_ON_DROP_DESTINATIONs));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add mod destination id to profile table.
 *
 * \param [in] unit Unit Number.
 * \param [in] mod_dest mod destination include mod profile id and mod destination id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_id_set(int unit, bcmi_ltsw_cosq_mod_dest_t *mod_dest)
{
    bcmi_lt_entry_t lt_entry;

    /* For LT TM_MIRROR_ON_DROP_PROFILE */
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_MIRROR_ON_DROP_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TM_MIRROR_ON_DROP_DESTINATION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = mod_dest->mod_profile_id;
    field[1].u.val = mod_dest->mod_dest_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit,
                           TM_MIRROR_ON_DROP_PROFILEs,
                           &lt_entry,
                           NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mod destination id related to a mod port/queue pair.
 *
 * \param [in] unit Unit Number.
 * \param [in|out] mod_dest: (in) Mod destination port/queue pair; (out) Mod destination id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_dest_id_get_by_port_queue(int unit,
                                   bcmi_ltsw_cosq_mod_dest_t *mod_dest)
{
    int i, size;
    bcm_port_t port, local_port;
    int cosq, mcq;
    int rv = SHR_E_NONE;
    bcmi_lt_entry_t lt_entry;

    /* LT TM_MIRROR_ON_DROP_DESTINATION */
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_MIRROR_ON_DROP_DESTINATION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {PORT_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {TM_MC_Q_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    bcmi_ltsw_cosq_port_map_info_t info;

    SHR_FUNC_ENTER(unit);

    /* Get UC/MC queue number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_port_map_info_get(unit, mod_dest->port, &info));

    /* Only mc queue is used for TM Mirror-on-drop. */
    if ((mod_dest->cosq < info.num_uc_q) ||
        (mod_dest->cosq >= (info.num_uc_q + info.num_mc_q))) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Get local port from Mirror gport. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_mirror_local_port_get(unit,
                                         mod_dest->port,
                                         NULL,
                                         &local_port));

    size = MOD_DEST_ID_NUM(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < size; i++) {
        field[0].u.val = i;
        rv = bcmi_lt_entry_get(unit,
                               TM_MIRROR_ON_DROP_DESTINATIONs,
                               &lt_entry,
                               NULL, NULL);

        if (rv != SHR_E_NONE) {
            continue;
        }

        port = field[1].u.val;
        cosq = field[2].u.val;
        mcq = cosq + info.num_uc_q;

        if ((port == local_port) && (mcq == mod_dest->cosq)){
            mod_dest->mod_dest_id = i;
            break;
        }
    }

    if (i >= size) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check whether system has MOD dest created.
 *
 * \param [in] unit Unit Number.
 * \param [out] empty Whether system has has MOD dest created: TRUE for no MOD dest created.
 *
 * \retval SHR_E_NONE on success, SHR_E_NOT_FOUND for empty, and error code otherwise.
 */
static int
cosq_mod_dest_empty_check(int unit, bool *empty)
{
    uint64_t index = 0;
    cosq_mod_dest_profile_t profile;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    *empty = TRUE;

    for (index = 0; index < MOD_DEST_ID_NUM(unit); index++) {
        sal_memset(&profile, 0, sizeof(cosq_mod_dest_profile_t));
        rv = cosq_mod_dest_entry_get(unit, index, &profile);
        if (rv == SHR_E_NONE) {
            *empty = FALSE;
            goto exit;
        } else if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add mod encap profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] mod_dest mod destination include mod mirror instance id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_mirror_instance_id_add(int unit,
                                bcmi_ltsw_cosq_mod_dest_t *mod_dest)
{
    bool empty;
    int rv = SHR_E_NONE;
    bcmi_lt_entry_t lt_entry;
    /* LT TM_MIRROR_ON_DROP_ENCAP_PROFILE */
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_MIRROR_ON_DROP_ENCAP_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    rv = cosq_mod_dest_empty_check(unit, &empty);
    if ((rv != SHR_E_NONE) && (rv != SHR_E_NOT_FOUND)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    /* Only add mirror instance id when add first mod dest id */
    if (empty == FALSE) {
        goto exit;
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = 0; /* Only one LT entry for TH4 */
    field[1].u.val = mod_dest->instance_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit,
                           TM_MIRROR_ON_DROP_ENCAP_PROFILEs,
                           &lt_entry,
                           NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete mod encap profile..
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_mirror_instance_id_delete(int unit)
{
    bool empty;
    int rv = SHR_E_NONE;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_MIRROR_ON_DROP_ENCAP_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    rv = cosq_mod_dest_empty_check(unit, &empty);
    if ((rv != SHR_E_NONE) && (rv != SHR_E_NOT_FOUND)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    /* Do nothing if not all mod dest id were already deleted */
    if (empty == FALSE) {
        goto exit;
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              TM_MIRROR_ON_DROP_ENCAP_PROFILEs,
                              &lt_entry,
                              NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mirror instance id.
 *
 * \param [in] unit Unit Number.
 * \param [out] instance_id Mirror instance id. -1 if not found.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */

static int
cosq_mod_mirror_instance_id_get(int unit, int *instance_id)
{
    bcmi_lt_entry_t lt_entry;
    /* LT TM_MIRROR_ON_DROP_ENCAP_PROFILE */
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_MIRROR_ON_DROP_ENCAP_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    *instance_id = -1;

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           TM_MIRROR_ON_DROP_ENCAP_PROFILEs,
                           &lt_entry,
                           NULL,
                           NULL));

    *instance_id = field[1].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mod dest queue statistics.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Statistics object id.
 * \param [in] stat Cosq mod Statistics type.
 * \param [out] value Statistics value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_stat_dest_queue_counter_get(int unit,
                                     bcm_cosq_object_id_t *id,
                                     bcm_cosq_mod_stat_t stat,
                                     uint64_t *value)
{
    bcmi_ltsw_cosq_mod_dest_t mod_dest;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BUFFER_POOLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TM_MIRROR_ON_DROP_DESTINATION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {CELL_USAGEs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    mod_dest.port = id->port;
    mod_dest.cosq= id->cosq;
    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_id_get_by_port_queue(unit, &mod_dest));

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = id->buffer;
    field[1].u.val = mod_dest.mod_dest_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           CTR_TM_MIRROR_ON_DROP_DESTINATION_USAGEs,
                           &lt_entry,
                           NULL, NULL));

    *value = field[2].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mod pool statistics.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Statistics object id.
 * \param [in] stat Cosq mod Statistics type.
 * \param [out] value Statistics value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_stat_pool_counter_get(int unit, bcm_cosq_object_id_t *id,
                               bcm_cosq_mod_stat_t stat,
                               uint64_t *value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BUFFER_POOLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {NULL, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = id->buffer;

    if (stat == bcmCosqModStatPoolBytesCurrent) {
        field[1].fld_name = CELL_USAGEs;
    } else if (stat == bcmCosqModStatDroppedPackets) {
        field[1].fld_name = DROP_PKTs;
    } else if (stat == bcmCosqModStatEnqueuedPackets) {
        field[1].fld_name = QUEUE_PKTs;
    } else if (stat == bcmCosqModStatPoolBytesPeak) {
        field[1].fld_name = HIGH_WATERMARK_CELL_USAGEs;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           CTR_TM_MIRROR_ON_DROP_BUFFER_POOLs,
                           &lt_entry,
                           NULL, NULL));

    *value = field[1].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set mod pool statistics counter.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Statistics object id.
 * \param [in] stat Cosq mod Statistics type
 * \param [in] value Statistics value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_stat_pool_counter_set(int unit, bcm_cosq_object_id_t *id,
                               bcm_cosq_mod_stat_t stat,
                               uint64_t value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BUFFER_POOLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {NULL, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = id->buffer;
    field[1].u.val = value;

    if (stat == bcmCosqModStatDroppedPackets) {
        field[1].fld_name = DROP_PKTs;
    } else if (stat == bcmCosqModStatEnqueuedPackets) {
        field[1].fld_name = QUEUE_PKTs;
    } else if (stat == bcmCosqModStatPoolBytesPeak) {
        field[1].fld_name = HIGH_WATERMARK_CELL_USAGEs;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit,
                           CTR_TM_MIRROR_ON_DROP_BUFFER_POOLs,
                           &lt_entry,
                           NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mod statistics couner.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Statistics object id.
 * \param [in] stat Cosq mod Statistics type.
 * \param [out] value Statistics value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_stat_get(int unit, bcm_cosq_object_id_t *id,
                  bcm_cosq_mod_stat_t stat,
                  uint64_t *value)
{
    bcmi_ltsw_cosq_device_info_t info;

    SHR_FUNC_ENTER(unit);

    /* Get MMU cell size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &info));

    switch (stat) {
        case bcmCosqModStatDestQueueBytesCurrent:
            SHR_IF_ERR_VERBOSE_EXIT
                (cosq_mod_stat_dest_queue_counter_get(unit, id, stat, value));
            *value = *value * info.mmu_cell_size;
            break;
        case bcmCosqModStatPoolBytesCurrent:
        case bcmCosqModStatPoolBytesPeak:
        case bcmCosqModStatEnqueuedPackets:
        case bcmCosqModStatDroppedPackets:
            SHR_IF_ERR_VERBOSE_EXIT
                (cosq_mod_stat_pool_counter_get(unit, id, stat, value));
            if( (stat == bcmCosqModStatPoolBytesCurrent) ||
                (stat == bcmCosqModStatPoolBytesPeak) ) {
                *value = *value * info.mmu_cell_size;
            }
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set mod statistics counter.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Statistics object id.
 * \param [in] stat Cosq mod Statistics type
 * \param [in] value Statistics value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_stat_set(int unit, bcm_cosq_object_id_t *id, bcm_cosq_mod_stat_t stat,
                  uint64_t value)
{
    bcmi_ltsw_cosq_device_info_t info;

    SHR_FUNC_ENTER(unit);

    /* Get MMU cell size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &info));

    switch (stat) {
        case bcmCosqModStatPoolBytesCurrent:
        case bcmCosqModStatDestQueueBytesCurrent:
            /* Read-only LT. */
            SHR_ERR_EXIT(SHR_E_PARAM);

        case bcmCosqModStatPoolBytesPeak:
        case bcmCosqModStatEnqueuedPackets:
        case bcmCosqModStatDroppedPackets:
            if(stat == bcmCosqModStatPoolBytesPeak) {
                value = (value + (info.mmu_cell_size - 1)) /
                         info.mmu_cell_size;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (cosq_mod_stat_pool_counter_set(unit, id, stat, value));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init mod pool related statistics counters.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_stat_pool_counter_init(int unit)
{
    int itm;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BUFFER_POOLs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    /* Clean up MOD pool related statistics counters. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, CTR_TM_MIRROR_ON_DROP_BUFFER_POOLs));

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    for (itm = 0; itm < ITMS_PER_DEV; itm++) {
        field[0].u.val = itm;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_insert(unit,
                                  CTR_TM_MIRROR_ON_DROP_BUFFER_POOLs,
                                  &lt_entry,
                                  NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init mod dest queue related statistics counters.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_stat_dest_queue_counter_init(int unit)
{
    int itm, mod_dest_id;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BUFFER_POOLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TM_MIRROR_ON_DROP_DESTINATION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    /* Clean up MOD dest queue related statistics counters. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, CTR_TM_MIRROR_ON_DROP_DESTINATION_USAGEs));

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    for (itm = 0; itm < ITMS_PER_DEV; itm++) {
        field[0].u.val = itm;
        for (mod_dest_id = 0; mod_dest_id < MOD_DEST_ID_NUM(unit); mod_dest_id++) {
            field[1].u.val = mod_dest_id;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_insert(unit,
                                      CTR_TM_MIRROR_ON_DROP_DESTINATION_USAGEs,
                                      &lt_entry,
                                      NULL));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init mod statistics counter.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_stat_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_stat_pool_counter_init(unit));


    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_stat_dest_queue_counter_init(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init Cosq mod sub-module.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
cosq_mod_init(int unit)
{
    int warm = bcmi_warmboot_get(unit);
    cosq_mod_config_t *mod_cfg;
    void *ptr = NULL;
    uint32_t alloc_size, req_size;
    uint64_t min = 0;
    uint64_t max = 0;
    SHR_FUNC_ENTER(unit);

    mod_cfg = &cosq_mod_cfg[unit];

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TM_MIRROR_ON_DROP_PROFILEs,
                                       TM_MIRROR_ON_DROP_PROFILE_IDs,
                                       &min,
                                       &max));
    mod_cfg->profile_num = (uint32_t)max + 1;

    /* Allocate HA memory for mod profile. */
    req_size = SHR_BITALLOCSIZE(mod_cfg->profile_num);
    alloc_size = req_size;
    ptr = bcmi_ltsw_ha_mem_alloc(unit,
                                 BCMI_HA_COMP_ID_COSQ,
                                 BCMINT_COSQ_MOD_PROFILE_BMP_SUB_COMP_ID,
                                 "bcmCosqModProfBmp",
                                 &alloc_size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT
        ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);
    if (!warm) {
        sal_memset(ptr, 0, alloc_size);
    }
    mod_cfg->profile_bmp = ptr;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TM_MIRROR_ON_DROP_DESTINATIONs,
                                       TM_MIRROR_ON_DROP_DESTINATION_IDs,
                                       &min,
                                       &max));
    mod_cfg->dest_id_num = (uint32_t)max + 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_profile_init(unit));

    if (!warm) {
        /* Insert MOD statistics counter. */
        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_mod_stat_init(unit));
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (!warm) {
            if (ptr != NULL) {
                (void)bcmi_ltsw_ha_mem_free(unit, mod_cfg->profile_bmp);
                mod_cfg->profile_bmp = NULL;
            }
        }
    }
    SHR_FUNC_EXIT();
}


static int
bcm56990_a0_ltsw_cosq_mod_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_init(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_profile_deinit(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_control_set(
    int unit,
    bcm_cosq_mod_control_t *control)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_control_set(unit, control));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_control_get(
    int unit,
    bcm_cosq_mod_control_t *control)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_control_get(unit, control));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_profile_create(
    int unit,
    uint32_t options,
    int *profile_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_profile_create(unit, options, profile_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_profile_destroy(
    int unit,
    int profile_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_profile_destroy(unit, profile_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_profile_set(
    int unit,
    int profile_id,
    bcm_cosq_mod_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_profile_set(unit, profile_id, profile));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_profile_get(
    int unit,
    int profile_id,
    bcm_cosq_mod_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_profile_get(unit, profile_id, profile));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_dest_add(
    int unit,
    bcmi_ltsw_cosq_mod_dest_t *mod_dest)
{
    int mod_dest_id;
    cosq_mod_dest_profile_t profile;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_mirror_instance_id_add(unit, mod_dest));

    profile.port = mod_dest->port;
    profile.cosq = mod_dest->cosq;
    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_profile_add(unit, &profile, &mod_dest_id));
    mod_dest->mod_dest_id = mod_dest_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_id_set(unit, mod_dest));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_dest_delete(
    int unit,
    bcmi_ltsw_cosq_mod_dest_t *mod_dest)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_profile_delete(unit, mod_dest->mod_dest_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_mirror_instance_id_delete(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_dest_get(
    int unit,
    bcmi_ltsw_cosq_mod_dest_t *mod_dest)
{
    cosq_mod_dest_profile_t profile;

    SHR_FUNC_ENTER(unit);

    sal_memset(&profile, 0, sizeof(cosq_mod_dest_profile_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_dest_profile_get(unit, mod_dest->mod_dest_id, &profile));
    mod_dest->port = profile.port;
    mod_dest->cosq = profile.cosq;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_instance_id_get(
    int unit,
    int *instance_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_mirror_instance_id_get(unit, instance_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_stat_get(
    int unit,
    bcm_cosq_object_id_t *id,
    bcm_cosq_mod_stat_t stat,
    uint64_t *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_stat_get(unit, id, stat, value));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56990_a0_ltsw_cosq_mod_stat_set(
    int unit,
    bcm_cosq_object_id_t *id,
    bcm_cosq_mod_stat_t stat,
    uint64_t value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mod_stat_set(unit, id, stat, value));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Cosq_mod driver function variable for bcm56990_a0 device.
 */
static mbcm_ltsw_cosq_mod_drv_t bcm56990_a0_ltsw_cosq_mod_drv = {
    .cosq_mod_init = bcm56990_a0_ltsw_cosq_mod_init,
    .cosq_mod_detach = bcm56990_a0_ltsw_cosq_mod_detach,
    .cosq_mod_control_set = bcm56990_a0_ltsw_cosq_mod_control_set,
    .cosq_mod_control_get = bcm56990_a0_ltsw_cosq_mod_control_get,
    .cosq_mod_profile_create = bcm56990_a0_ltsw_cosq_mod_profile_create,
    .cosq_mod_profile_destroy = bcm56990_a0_ltsw_cosq_mod_profile_destroy,
    .cosq_mod_profile_set = bcm56990_a0_ltsw_cosq_mod_profile_set,
    .cosq_mod_profile_get = bcm56990_a0_ltsw_cosq_mod_profile_get,
    .cosq_mod_dest_add = bcm56990_a0_ltsw_cosq_mod_dest_add,
    .cosq_mod_dest_delete = bcm56990_a0_ltsw_cosq_mod_dest_delete,
    .cosq_mod_dest_get = bcm56990_a0_ltsw_cosq_mod_dest_get,
    .cosq_mod_instance_id_get = bcm56990_a0_ltsw_cosq_mod_instance_id_get,
    .cosq_mod_stat_get = bcm56990_a0_ltsw_cosq_mod_stat_get,
    .cosq_mod_stat_set = bcm56990_a0_ltsw_cosq_mod_stat_set
};

/******************************************************************************
 * Public functions
 */

int
bcm56990_a0_ltsw_cosq_mod_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_cosq_mod_drv_set(unit, &bcm56990_a0_ltsw_cosq_mod_drv));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Attach functions for other members.
 */
#define BCM56990_A0_DRV_ATTACH_ENTRY(_dn,_vn,_pf,_pd,_r0) \
int _vn##_ltsw_cosq_mod_drv_attach(int unit) \
{ \
    SHR_FUNC_ENTER(unit); \
    SHR_IF_ERR_VERBOSE_EXIT \
        (mbcm_ltsw_cosq_mod_drv_set(unit, &bcm56990_a0_ltsw_cosq_mod_drv)); \
exit: \
    SHR_FUNC_EXIT(); \
}
#include "sub_devlist.h"
