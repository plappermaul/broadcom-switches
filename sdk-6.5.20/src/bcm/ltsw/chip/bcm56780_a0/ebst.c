/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>

#include <bcm_int/ltsw/mbcm/ebst.h>

#include <bcm_int/ltsw/tm/ebst.h>
#include <bcm_int/ltsw/cosq.h>
#include <bcm_int/ltsw/cosq_thd.h>
#include <bcm_int/ltsw/port.h>
#include <shr/shr_debug.h>
#include <sal/sal_libc.h>
#include <sal/sal_mutex.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_COSQ

/******************************************************************************
 * Private functions
 */

#define NUM_GP_QUEUES               12    /* GPs includingLB/mgmt has 12 Queues */
#define MMU_NUM_POOL                4

/*
 * \brief Check port type.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  port          PORT ID.
 *
 * \retval TRUE               Port is cpu port.
 * \retval FALSE              Port is non cpu port.
 */
static int
is_cpu_port(int unit, bcm_port_t lport)
{
    return bcmi_ltsw_port_is_type(unit, lport,  BCMI_LTSW_PORT_TYPE_CPU);
}

/*
 * \brief EBST index resolve function.
 *
 * \param [in]   unit         Unit number.
 * \param [in]   gport        GPORT ID.
 * \param [in]   cosq         COS queue.
 * \param [in]   bid          BST stat ID to identify the COSQ resource/object.
 * \param [out]  local_port   local_port.
 * \param [out]  start_index  start index.
 * \param [out]  end_index    end index.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_ebst_index_resolve(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq,
                        bcm_bst_stat_id_t bid, bcm_port_t *local_port,
                        int *start_index, int *end_index)
{
    bcmi_ltsw_cosq_port_map_info_t port_info;
    int cos;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_localport_resolve(unit, gport, local_port));

    switch (bid) {
        case bcmBstStatIdEgrPortPoolSharedUcast:
            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_cosq_gport_port_resolve(unit, gport,
                                                       local_port,
                                                       &cos));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_cosq_port_map_info_get(unit, *local_port,
                                                      &port_info));

                if (cosq == BCM_COS_INVALID) {
                    cos = BCM_COS_INVALID;
                } else {
                    if (cosq >= port_info.num_uc_q) {
                        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                    }
                    cos = cosq;
                }
            }

            if(cos == BCM_COS_INVALID) {
                *start_index = 0;
                *end_index   = MMU_NUM_POOL - 1;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_cosq_thd_egress_pool_get(unit, *local_port, cos,
                                               bcmCosqControlUCEgressPool,
                                               start_index));
                *end_index = *start_index;
            }

            break;
        case bcmBstStatIdEgrPortPoolSharedMcast:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_cosq_port_map_info_get(unit, *local_port,
                                                  &port_info));

            if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_cosq_gport_port_resolve(unit, gport,
                                                       local_port,
                                                       &cos));
                cos = cos + port_info.num_uc_q;
            } else {
                if (cosq == BCM_COS_INVALID) {
                    cos = BCM_COS_INVALID;
                } else {
                    if (cosq < port_info.num_uc_q) {
                        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                    }
                    cos = cosq;
                }
            }

            if (cos == BCM_COS_INVALID) {
                *start_index = 0;
                *end_index   = MMU_NUM_POOL - 1;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_cosq_thd_egress_pool_get(unit, *local_port, cos,
                                                        bcmCosqControlMCEgressPool,
                                                        start_index));
                *end_index = *start_index;
            }

            break;
        case bcmBstStatIdUcast:
            if (is_cpu_port(unit, *local_port)) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_cosq_gport_port_resolve(unit, gport,
                                                       local_port,
                                                       start_index));
                *end_index = *start_index;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_cosq_port_map_info_get(unit, *local_port,
                                                      &port_info));

                if (cosq == BCM_COS_INVALID) {
                    *start_index = 0;
                    *end_index = port_info.num_uc_q - 1;
                } else {
                    if (cosq >= port_info.num_uc_q) {
                        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                    }
                    *end_index = *start_index = cosq;
                }
            }
            break;
        case bcmBstStatIdMcast:
            if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_cosq_gport_port_resolve(unit, gport,
                                                       local_port,
                                                       start_index));
                *end_index = *start_index;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_cosq_port_map_info_get(unit, *local_port,
                                                      &port_info));
                if (cosq == BCM_COS_INVALID) {
                    *start_index = 0;
                    *end_index = port_info.num_mc_q - 1;
                } else {
                    if (cosq < port_info.num_uc_q) {
                        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                    }
                    *end_index = *start_index = cosq - port_info.num_uc_q;
                }
            }
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Validate input parameters for input BST.
 *
 * \param [in]   unit         Unit number.
 * \param [in]   gport        GPORT ID.
 * \param [in]   cosq         COS queue.
 * \param [in]   bid          BST stat ID to identify the COSQ resource/object.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_ebst_bid_gport_cosq_param_check(int unit, bcm_cosq_object_id_t *object_id,
                                     bcm_bst_stat_id_t bid)
{
    bcmi_ltsw_cosq_port_map_info_t port_info;
    int port;
    bcm_gport_t gport = object_id->port;
    bcm_cos_queue_t cosq = object_id->cosq;

    SHR_FUNC_ENTER(unit);

    if (cosq < BCM_COS_INVALID) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_localport_resolve(unit, gport, &port));

    if (is_cpu_port(unit, port)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        /* Passed cosq is multicast. Cannot be used for unicast Bids */
        if ((bid == bcmBstStatIdUcast) ||
            (bid == bcmBstStatIdEgrPortPoolSharedUcast)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    } else if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        /* Passed cosq is unicast. Cannot be used for multicast Bids */
        if ((bid == bcmBstStatIdMcast) ||
            (bid == bcmBstStatIdEgrPortPoolSharedMcast)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    } else if (BCM_GPORT_IS_SCHEDULER(gport)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    } else {
        if (gport == -1) {
            SHR_EXIT();
        }
        /* GPORT is of local port type */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_cosq_port_map_info_get(unit, port, &port_info));

        if (cosq == BCM_COS_INVALID) {
            SHR_EXIT();
        }

        if (cosq >= NUM_GP_QUEUES) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        if (cosq < port_info.num_uc_q) {
            /* Passed cosq is unicast. Cannot be used for multicast Bids */
            if ((bid == bcmBstStatIdMcast) ||
                (bid == bcmBstStatIdEgrPortPoolSharedMcast)) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        } else {
            /* Passed cosq is multicast. Cannot be used for unicast Bids */
             if ((bid == bcmBstStatIdUcast) ||
                 (bid == bcmBstStatIdEgrPortPoolSharedUcast)) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Validate input bid for input EBST.
 *
 * \param [in]   unit         Unit number.
 * \param [in]   bid          BST stat ID to identify the COSQ resource/object.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_ebst_bid_check(int unit, bcm_bst_stat_id_t bid)
{
    SHR_FUNC_ENTER(unit);

    /* Parameter check */
    if (bid != bcmBstStatIdUcast &&
        bid != bcmBstStatIdMcast &&
        bid != bcmBstStatIdEgrPortPoolSharedUcast &&
        bid != bcmBstStatIdEgrPortPoolSharedMcast) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}


static int
bcm56780_a0_ltsw_cosq_ebst_threshold_profile_get(
    int unit,
    bcm_cosq_object_id_t *object_id,
    bcm_bst_stat_id_t bid,
    bcm_cosq_ebst_threshold_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_ebst_bid_check(unit, bid));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_threshold_profile_get(unit, object_id, bid, profile));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_ebst_threshold_profile_set(
    int unit,
    bcm_cosq_object_id_t *object_id,
    bcm_bst_stat_id_t bid,
    bcm_cosq_ebst_threshold_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_ebst_bid_check(unit, bid));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_threshold_profile_set(unit, object_id, bid, profile));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_ebst_control_get(
    int unit,
    bcm_cosq_ebst_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_control_get(unit, type, arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_ebst_control_set(
    int unit,
    bcm_cosq_ebst_control_t type,
    int arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_control_set(unit, type, arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_ebst_monitor_get(
    int unit,
    bcm_cosq_object_id_t *object_id,
    bcm_bst_stat_id_t bid,
    bcm_cosq_ebst_monitor_t *monitor)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_ebst_bid_check(unit, bid));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_monitor_get(unit, object_id, bid, monitor));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_ebst_monitor_set(
    int unit,
    bcm_cosq_object_id_t *object_id,
    bcm_bst_stat_id_t bid,
    bcm_cosq_ebst_monitor_t *monitor)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_ebst_bid_check(unit, bid));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_monitor_set(unit, object_id, bid, monitor));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_ebst_data_stat_info_get(
    int unit,
    bcm_cosq_object_id_t *object_id,
    bcm_cosq_ebst_data_stat_info_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_data_stat_info_get(unit, object_id, info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_ebst_data_get(
    int unit,
    bcm_cosq_object_id_t *object_id,
    bcm_bst_stat_id_t bid,
    int array_size,
    bcm_cosq_ebst_data_entry_t *entry_array,
    int *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_ebst_bid_check(unit, bid));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_data_get(unit, object_id, bid, array_size,
                                      entry_array, count));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_ebst_enable_set(
    int unit,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_enable_set(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_ebst_enable_get(
    int unit,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_enable_get(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_ebst_init(int unit)
{
    static tm_ltsw_ebst_chip_driver_t bcm56780_a0_ebst_drv_cb = {
        .cosq_ebst_index_resolve = cosq_ebst_index_resolve,
        .cosq_ebst_bid_gport_cosq_param_check = cosq_ebst_bid_gport_cosq_param_check,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (tm_ltsw_ebst_chip_driver_register(unit, &bcm56780_a0_ebst_drv_cb));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_init(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_ebst_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ebst_detach(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Cosq_ebst driver function variable for bcm56780_a0 device.
 */
static mbcm_ltsw_cosq_ebst_drv_t bcm56780_a0_ltsw_cosq_ebst_drv = {
    .cosq_ebst_threshold_profile_get = bcm56780_a0_ltsw_cosq_ebst_threshold_profile_get,
    .cosq_ebst_threshold_profile_set = bcm56780_a0_ltsw_cosq_ebst_threshold_profile_set,
    .cosq_ebst_control_get = bcm56780_a0_ltsw_cosq_ebst_control_get,
    .cosq_ebst_control_set = bcm56780_a0_ltsw_cosq_ebst_control_set,
    .cosq_ebst_monitor_get = bcm56780_a0_ltsw_cosq_ebst_monitor_get,
    .cosq_ebst_monitor_set = bcm56780_a0_ltsw_cosq_ebst_monitor_set,
    .cosq_ebst_data_stat_info_get = bcm56780_a0_ltsw_cosq_ebst_data_stat_info_get,
    .cosq_ebst_data_get = bcm56780_a0_ltsw_cosq_ebst_data_get,
    .cosq_ebst_enable_set = bcm56780_a0_ltsw_cosq_ebst_enable_set,
    .cosq_ebst_enable_get = bcm56780_a0_ltsw_cosq_ebst_enable_get,
    .cosq_ebst_init = bcm56780_a0_ltsw_cosq_ebst_init,
    .cosq_ebst_detach = bcm56780_a0_ltsw_cosq_ebst_detach
};

/******************************************************************************
 * Public functions
 */

int
bcm56780_a0_ltsw_cosq_ebst_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_cosq_ebst_drv_set(unit, &bcm56780_a0_ltsw_cosq_ebst_drv));

exit:
    SHR_FUNC_EXIT();
}

