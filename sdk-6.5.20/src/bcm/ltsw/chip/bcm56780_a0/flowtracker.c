/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/ltsw/mbcm/flowtracker.h>
#include <bcm_int/ltsw/xfs/flowtracker.h>

#include <shr/shr_bitop.h>
#include <shr/shr_debug.h>
#include <bcm/flexctr.h>
#include <bcm_int/ltsw/flexctr.h>
#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/flowtracker_int.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_FLOWTRACKER

/******************************************************************************
 * Private functions
 */

static int
bcm56780_a0_ltsw_flowtracker_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_detach(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_init(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_hash_config_set(
    int unit,
    bcm_flowtracker_elephant_hash_table_t hash_table,
    int instance_num,
    int bank_num,
    bcm_flowtracker_elephant_hash_type_t hash_type,
    int right_rotate_bits)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_hash_config_set(unit, hash_table, instance_num, bank_num, hash_type, right_rotate_bits));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_hash_config_get(
    int unit,
    bcm_flowtracker_elephant_hash_table_t hash_table,
    int instance_num,
    int bank_num,
    bcm_flowtracker_elephant_hash_type_t *hash_type,
    int *right_rotate_bits)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_hash_config_get(unit, hash_table, instance_num, bank_num, hash_type, right_rotate_bits));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_control_set(
    int unit,
    bcm_flowtracker_elephant_control_t type,
    int arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_control_set(unit, type, arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_control_get(
    int unit,
    bcm_flowtracker_elephant_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_control_get(unit, type, arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_stats_set(
    int unit,
    bcm_flowtracker_elephant_stats_t *stats)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_stats_set(unit, stats));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_elephant_stats_get(
    int unit,
    bcm_flowtracker_elephant_stats_t *stats)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_flowtracker_elephant_stats_get(unit, stats));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_default_grp_supported(
    int unit,
    bool *supported)
{
    *supported = false;
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flowtracker_group_tracking_params_validate(
    int unit,
    bcm_flowtracker_group_t id,
    int num_tracking_params,
    bcm_flowtracker_tracking_param_info_t *list_of_tracking_params)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_group_export_triggers_validate(
    int unit,
    bcm_flowtracker_group_t id,
    bcm_flowtracker_export_trigger_info_t *export_trigger_info)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_group_actions_validate(
    int unit,
    bcm_flowtracker_group_t id,
    uint32 flags,
    uint8_t hw_learn_en,
    int num_actions,
    bcm_flowtracker_group_action_info_t *action_list)
{
    int i;
    bool actn_valid = false;
    SHR_FUNC_ENTER(unit);

    if (hw_learn_en == FT_HW_LEARN_ENABLE_WO_EAPP) {
        for (i = 0; i < num_actions; i++) {
            actn_valid = false;
            switch (action_list[i].action) {
                case bcmFlowtrackerGroupActionOpaqueObject:
                case bcmFlowtrackerGroupActionFlexCtrAssign:
                case bcmFlowtrackerGroupActionIfaInsert:
                case bcmFlowtrackerGroupActionIfaDelete:
                case bcmFlowtrackerGroupActionVxlanGbpEnable:
                case bcmFlowtrackerGroupActionINTResidenceTimeEnable:
                case bcmFlowtrackerGroupActionCopyToCpu:
                case bcmFlowtrackerGroupActionDrop:
                case bcmFlowtrackerGroupActionDropCancel:
                case bcmFlowtrackerGroupActionRedirectPort:
                case bcmFlowtrackerGroupActionRedirectIpmc:
                case bcmFlowtrackerGroupActionRedirectMcast:
                case bcmFlowtrackerGroupActionL3Switch:
                case bcmFlowtrackerGroupActionRedirectCancel:
                case bcmFlowtrackerGroupActionDestinationType:
                case bcmFlowtrackerGroupActionFlexStateAssign:
                case bcmFlowtrackerGroupActionMirrorIndex:
                    actn_valid = true;
                    break;
                default:
                    break;
            }
            if (actn_valid == false) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    SHR_EXIT();
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_flowtracker_flex_ctr_pkt_byte_reserve(
    int unit,
    int max_flows,
    uint8_t hw_learn_en,
    uint32_t *flex_ctr_stat_id,
    uint32_t *flex_ctr_lt_id)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_flex_ctr_hit_bit_reserve(
    int unit,
    int hitbit_type,
    int max_flows,
    uint8_t hw_learn_en,
    uint32_t *flex_ctr_stat_id,
    uint32_t *flex_ctr_lt_id)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_hw_learn_max_flows_per_pipe_get(
    int unit,
    uint8_t uft_mode,
    uint32_t *max_flows_per_pipe)
{
    if (uft_mode == 10) {
        /* 4 tiles are assigned to EM_FT. So 16 K per tile = 64K totally */
        *max_flows_per_pipe = 64 * 1024;
    } else {
        /* 2 tiles are assigned to EM_FT. So 16 K per tile = 32K totally */
        *max_flows_per_pipe = 32 * 1024;
    }
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flowtracker_hw_learn_global_enable_reg_field_name_get(
    int unit,
    char **reg_str,
    char **field_str)
{
    *reg_str = R_FT_CONFIGs;
    *field_str = FT_ENABLEs;
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flowtracker_flex_ctr_action_group(
    int unit,
    uint32_t main_ctr_stat_id,
    uint32_t hitbit_ctr_stat_id,
    uint32_t *group_action_stat_id,
    uint32_t *group_action_hw_idx)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_sw_learn_max_flows_per_pipe_get(
    int unit,
    uint32_t *max_flows_per_pipe)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_flowtracker_hw_learn_is_supported_uft_mode(
    int unit,
    uint8_t uft_mode,
    bool *supported)
{
    if (uft_mode == 8 || uft_mode == 9 || uft_mode == 11) {
        *supported = false;
    } else {
        *supported = true;
    }
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flowtracker_sw_learn_is_supported_uft_mode(
    int unit,
    uint8_t uft_mode,
    bool *supported)
{
    return SHR_E_UNAVAIL;
}

/*!
 * \brief Flowtracker driver function variable for bcm56780_a0 device.
 */
static mbcm_ltsw_flowtracker_drv_t bcm56780_a0_ltsw_flowtracker_drv = {
    .flowtracker_detach = bcm56780_a0_ltsw_flowtracker_detach,
    .flowtracker_init = bcm56780_a0_ltsw_flowtracker_init,
    .flowtracker_elephant_hash_config_set = bcm56780_a0_ltsw_flowtracker_elephant_hash_config_set,
    .flowtracker_elephant_hash_config_get = bcm56780_a0_ltsw_flowtracker_elephant_hash_config_get,
    .flowtracker_elephant_control_set = bcm56780_a0_ltsw_flowtracker_elephant_control_set,
    .flowtracker_elephant_control_get = bcm56780_a0_ltsw_flowtracker_elephant_control_get,
    .flowtracker_elephant_stats_set = bcm56780_a0_ltsw_flowtracker_elephant_stats_set,
    .flowtracker_elephant_stats_get = bcm56780_a0_ltsw_flowtracker_elephant_stats_get,
    .flowtracker_default_grp_supported = bcm56780_a0_ltsw_flowtracker_default_grp_supported,
    .flowtracker_group_tracking_params_validate = bcm56780_a0_ltsw_flowtracker_group_tracking_params_validate,
    .flowtracker_group_export_triggers_validate = bcm56780_a0_ltsw_flowtracker_group_export_triggers_validate,
    .flowtracker_group_actions_validate = bcm56780_a0_ltsw_flowtracker_group_actions_validate,
    .flowtracker_flex_ctr_pkt_byte_reserve = bcm56780_a0_ltsw_flowtracker_flex_ctr_pkt_byte_reserve,
    .flowtracker_flex_ctr_hit_bit_reserve = bcm56780_a0_ltsw_flowtracker_flex_ctr_hit_bit_reserve,
    .flowtracker_hw_learn_max_flows_per_pipe_get = bcm56780_a0_ltsw_flowtracker_hw_learn_max_flows_per_pipe_get,
    .flowtracker_hw_learn_global_enable_reg_field_name_get = bcm56780_a0_ltsw_flowtracker_hw_learn_global_enable_reg_field_name_get,
    .flowtracker_flex_ctr_action_group = bcm56780_a0_ltsw_flowtracker_flex_ctr_action_group,
    .flowtracker_sw_learn_max_flows_per_pipe_get = bcm56780_a0_ltsw_flowtracker_sw_learn_max_flows_per_pipe_get,
    .flowtracker_hw_learn_is_supported_uft_mode = bcm56780_a0_ltsw_flowtracker_hw_learn_is_supported_uft_mode,
    .flowtracker_sw_learn_is_supported_uft_mode = bcm56780_a0_ltsw_flowtracker_sw_learn_is_supported_uft_mode
};

/******************************************************************************
 * Public functions
 */

int
bcm56780_a0_ltsw_flowtracker_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flowtracker_drv_set(unit, &bcm56780_a0_ltsw_flowtracker_drv));

exit:
    SHR_FUNC_EXIT();
}

