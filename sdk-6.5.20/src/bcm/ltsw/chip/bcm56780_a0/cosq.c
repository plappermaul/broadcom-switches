/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>

#include <bcm_int/ltsw/mbcm/cosq.h>
#include <bcm_int/ltsw/chip/bcm56780_a0/variant_dispatch.h>

#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/cosq.h>
#include <bcm_int/ltsw/tm/cosq.h>
#include <bcm_int/ltsw/cosq_int.h>
#include <bcm_int/ltsw/cosq_thd.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/stack.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bsl/bsl.h>
#include <sal/sal_libc.h>
#include <shr/shr_debug.h>
#include <bcmlt/bcmlt.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_COSQ

/******************************************************************************
 * Private functions
 */


#define NUM_CPU_MCAST_QUEUE     48  /* CPU port has 48 MC Queues */
#define NUM_GP_QUEUES           12  /* GPs includingLB/mgmt has 12 Queues */
#define NUM_SCHEDULER_PER_PORT  12
#define MAX_NUM_PG_PROFILE      8
#define QSCHED_MIN_WEIGHT       0
#define QSCHED_MAX_WEIGHT       127

#define TM_LTSW_ASF_MODE_SAF    0
#define TM_LTSW_ASF_MODE_CT     1
#define MAX_TM_CUT_THROUGH_CLASS 8
#define PORT_ASF_SPEED_CLASS_VALIDATE(class) \
        if(!(((class) >= 0 && (class) < MAX_TM_CUT_THROUGH_CLASS))) \
            return SHR_E_PARAM;

#define ITMS_PER_DEV            1
#define MAX_NUM_SCHED_PROFILE   8
#define COSQ_NUM_INT_PRI        16
#define MMU_RQE_QUEUE_NUM       9

#define MIN(x, y) (((x) < (y)) ? (x) : (y))
#define MAX(x, y) (((x) > (y)) ? (x) : (y))

#define COSQ_NUM_WRED_RESOLUTION_TABLE 4
#define COSQ_WRED_CELL_FIELD_MAX 0xfffff

#define TM_UNICAST_VIEW_PROFILE_ID 0
/* UNICAST VIEW STRENGTH */
#define PORT_UC_COS_STRENGTH   4
#define PORT_MC_COS_STRENGTH   4
#define PORT_RQE_COS_STRENGTH  3
#define PORT_CPU_COS_STRENGTH  3

#define CPU_RQE_COS_STRENGTH   4
#define CPU_COS_STRENGTH       4

#define IFP_UC_COS_STRENGTH    1
#define IFP_MC_COS_STRENGTH    1
#define IFP_RQE_COS_STRENGTH   1
#define IFP_CPU_COS_STRENGTH   1

#define DEST_UC_COS_STRENGTH   2
#define DEST_MC_COS_STRENGTH   2
#define DEST_RQE_COS_STRENGTH  2
#define DEST_CPU_COS_STRENGTH  2

#define TM_NON_UNICAST_VIEW_PROFILE_ID 1
/* NON UNICAST VIEW STRENGTH */
#define PORT_UC_COS_STRENGTH1   3
#define PORT_MC_COS_STRENGTH1   3
#define PORT_RQE_COS_STRENGTH1  3
#define PORT_CPU_COS_STRENGTH1  3

#define CPU_RQE_COS_STRENGTH1   4
#define CPU_COS_STRENGTH1       4

#define IFP_UC_COS_STRENGTH1    1
#define IFP_MC_COS_STRENGTH1    1
#define IFP_RQE_COS_STRENGTH1   1
#define IFP_CPU_COS_STRENGTH1   1

#define DEST_UC_COS_STRENGTH1   2
#define DEST_MC_COS_STRENGTH1   2
#define DEST_RQE_COS_STRENGTH1  2
#define DEST_CPU_COS_STRENGTH1  2

#define TM_IFP_VIEW_PROFILE_ID 2
/* IFP VIEW STRENGTH */
#define PORT_UC_COS_STRENGTH2   1
#define PORT_MC_COS_STRENGTH2   1
#define PORT_RQE_COS_STRENGTH2  1
#define PORT_CPU_COS_STRENGTH2  1

#define CPU_RQE_COS_STRENGTH2   2
#define CPU_COS_STRENGTH2       2

#define IFP_UC_COS_STRENGTH2    4
#define IFP_MC_COS_STRENGTH2    4
#define IFP_RQE_COS_STRENGTH2   4
#define IFP_CPU_COS_STRENGTH2   4

#define DEST_UC_COS_STRENGTH2   3
#define DEST_MC_COS_STRENGTH2   3
#define DEST_RQE_COS_STRENGTH2  3
#define DEST_CPU_COS_STRENGTH2  3

#define TM_DST_FP_VIEW_PROFILE_ID 3
/* DST_FP VIEW STRENGTH */
#define PORT_UC_COS_STRENGTH3   1
#define PORT_MC_COS_STRENGTH3   1
#define PORT_RQE_COS_STRENGTH3  1
#define PORT_CPU_COS_STRENGTH3  1

#define CPU_RQE_COS_STRENGTH3   2
#define CPU_COS_STRENGTH3       2

#define IFP_UC_COS_STRENGTH3    3
#define IFP_MC_COS_STRENGTH3    3
#define IFP_RQE_COS_STRENGTH3   3
#define IFP_CPU_COS_STRENGTH3   3

#define DEST_UC_COS_STRENGTH3   4
#define DEST_MC_COS_STRENGTH3   4
#define DEST_RQE_COS_STRENGTH3  4
#define DEST_CPU_COS_STRENGTH3  4

/*
 * cosq table control structure
 */
typedef struct cosq_ctrl_s {

    /* cosq map database pointer. */
    const bcmint_cosq_map_db_t *cosq_db;

} cosq_ctrl_t;

static cosq_ctrl_t cosq_ctrl[BCM_MAX_NUM_UNITS] = {{ 0 }};

/* COSQ map database. */
#define COSQ_MAP_DB(unit) \
            (cosq_ctrl[unit].cosq_db)

/* COSQ map string database. */
#define COSQ_MAP_STR_DB(unit, hdl) \
            (&(COSQ_MAP_DB(unit)->str_db[hdl]))

/* COSQ map string info. */
#define COSQ_MAP_STR_INFO(unit, hdl) \
            (COSQ_MAP_STR_DB(unit, hdl)->info)

/* COSQ map string number. */
#define COSQ_MAP_STR_NUM(unit, hdl) \
            (COSQ_MAP_STR_DB(unit, hdl)->num)

/* WRED resolution table */
static int *cosq_wred_resolution_tbl[BCM_MAX_NUM_UNITS];

typedef struct cosq_node_s {
    /* Node gport. */
    bcm_gport_t gport;

    /* Parent node gport. */
    bcm_gport_t parent_gport;

    /* Child node number. */
    int numq;

    /* Node level. */
    int level;

    /* Node index. */
    int index;

    /* Node in use. */
    int in_use;

    /* Node cos. */
    int cos;

    /* int strict_priority_p; L0->L1. */
    int fc_is_uc_only;
} cosq_node_t;

typedef struct cosq_port_info_s {
    cosq_node_t *ucast;
    cosq_node_t *mcast;
    cosq_node_t *sched;
} cosq_port_info_t;

typedef struct cosq_cpu_port_info_s {
    cosq_node_t *mcast;
    cosq_node_t *sched;
} cosq_cpu_port_info_t;

typedef struct mmu_info_s {
    /* FALSE: No GPORT tree exists */
    int gport_tree_created;
    cosq_cpu_port_info_t *ltsw_cosq_cpu_port_info;
    cosq_port_info_t *ltsw_cosq_port_info;
} mmu_info_t;

/* MMU info */
static mmu_info_t      *ltsw_mmu_info[BCM_MAX_NUM_UNITS];

#define LTSW_MMU_INFO(u) ltsw_mmu_info[(u)]

typedef struct cosq_lt_convert_s {
    uint32_t        val;
    const char      *sym_val;
} cosq_lt_convert_t;

/*
 * \brief Convert HW drop probability to percent value.
 */
static cosq_lt_convert_t cosq_drop_prob_to_percent[] =
{
    {0,   TM_WRED_DROP_PERCENTAGE_0s},
    {1,   TM_WRED_DROP_PERCENTAGE_1s},
    {2,   TM_WRED_DROP_PERCENTAGE_2s},
    {3,   TM_WRED_DROP_PERCENTAGE_3s},
    {4,   TM_WRED_DROP_PERCENTAGE_4s},
    {5,   TM_WRED_DROP_PERCENTAGE_5s},
    {6,   TM_WRED_DROP_PERCENTAGE_6s},
    {7,   TM_WRED_DROP_PERCENTAGE_7s},
    {8,   TM_WRED_DROP_PERCENTAGE_8s},
    {9,   TM_WRED_DROP_PERCENTAGE_9s},
    {10,  TM_WRED_DROP_PERCENTAGE_10s},
    {25,  TM_WRED_DROP_PERCENTAGE_25s},
    {50,  TM_WRED_DROP_PERCENTAGE_50s},
    {75,  TM_WRED_DROP_PERCENTAGE_75s},
    {100, TM_WRED_DROP_PERCENTAGE_100s},
};

/*
 * \brief Convert TIME DOMAIN.
 */
static cosq_lt_convert_t cosq_wred_time_domain[] =
{
    {0 ,  TIME_DOMAIN_0_5_USs},
    {1 ,  TIME_DOMAIN_1_USs  },
    {2 ,  TIME_DOMAIN_1_5_USs},
    {3 ,  TIME_DOMAIN_2_USs  },
    {4 ,  TIME_DOMAIN_2_5_USs},
    {5 ,  TIME_DOMAIN_3_USs  },
    {6 ,  TIME_DOMAIN_3_5_USs},
    {7 ,  TIME_DOMAIN_4_USs  },
    {8 ,  TIME_DOMAIN_4_5_USs},
    {9 ,  TIME_DOMAIN_5_USs  },
    {10,  TIME_DOMAIN_5_5_USs},
    {11,  TIME_DOMAIN_6_USs  },
    {12,  TIME_DOMAIN_6_5_USs},
    {13,  TIME_DOMAIN_7_USs  },
    {14,  TIME_DOMAIN_7_5_USs},
    {15,  TIME_DOMAIN_8_USs  },
    {16,  TIME_DOMAIN_8_5_USs},
    {17,  TIME_DOMAIN_9_USs  },
    {18,  TIME_DOMAIN_9_5_USs},
    {19,  TIME_DOMAIN_10_USs  },
    {20,  TIME_DOMAIN_10_5_USs},
    {21,  TIME_DOMAIN_11_USs  },
    {22,  TIME_DOMAIN_11_5_USs},
    {23,  TIME_DOMAIN_12_USs  },
    {24,  TIME_DOMAIN_12_5_USs},
    {25,  TIME_DOMAIN_13_USs  },
    {26,  TIME_DOMAIN_13_5_USs},
    {27,  TIME_DOMAIN_14_USs  },
    {28,  TIME_DOMAIN_14_5_USs},
    {29,  TIME_DOMAIN_15_USs  },
    {30,  TIME_DOMAIN_15_5_USs},
    {31,  TIME_DOMAIN_16_USs  },
    {32,  TIME_DOMAIN_16_5_USs},
    {33,  TIME_DOMAIN_17_USs  },
    {34,  TIME_DOMAIN_17_5_USs},
    {35,  TIME_DOMAIN_18_USs  },
    {36,  TIME_DOMAIN_18_5_USs},
    {37,  TIME_DOMAIN_19_USs  },
    {38,  TIME_DOMAIN_19_5_USs},
    {39,  TIME_DOMAIN_20_USs  },
    {40,  TIME_DOMAIN_20_5_USs},
    {41,  TIME_DOMAIN_21_USs  },
    {42,  TIME_DOMAIN_21_5_USs},
    {43,  TIME_DOMAIN_22_USs  },
    {44,  TIME_DOMAIN_22_5_USs},
    {45,  TIME_DOMAIN_23_USs  },
    {46,  TIME_DOMAIN_23_5_USs},
    {47,  TIME_DOMAIN_24_USs  },
    {48,  TIME_DOMAIN_24_5_USs},
    {49,  TIME_DOMAIN_25_USs  },
    {50,  TIME_DOMAIN_25_5_USs},
    {51,  TIME_DOMAIN_26_USs  },
    {52,  TIME_DOMAIN_26_5_USs},
    {53,  TIME_DOMAIN_27_USs  },
    {54,  TIME_DOMAIN_27_5_USs},
    {55,  TIME_DOMAIN_28_USs  },
    {56,  TIME_DOMAIN_28_5_USs},
    {57,  TIME_DOMAIN_29_USs  },
    {58,  TIME_DOMAIN_29_5_USs},
    {59,  TIME_DOMAIN_30_USs  },
    {60,  TIME_DOMAIN_30_5_USs},
    {61,  TIME_DOMAIN_31_USs  },
    {62,  TIME_DOMAIN_31_5_USs},
    {63,  TIME_DOMAIN_32_USs  },
};

typedef enum port_asf_speed_encoding_e {
    PORT_SPEED_ID_RESERVED = 0,
    PORT_SPEED_ID_10G,
    PORT_SPEED_ID_25G,
    PORT_SPEED_ID_40G,
    PORT_SPEED_ID_50G,
    PORT_SPEED_ID_100G,
    PORT_SPEED_ID_200G,
    PORT_SPEED_ID_400G,
    PORT_SPEED_ID_ERROR
} port_asf_speed_encoding_t;

/*
 * \brief Convert TM_CUT_THROUGH_CLASS_T.
 */
static cosq_lt_convert_t tm_cut_through_class[] =
{
    {PORT_SPEED_ID_RESERVED ,  SAF_MODEs},
    {PORT_SPEED_ID_10G ,   CUT_THROUGH_CLASS_10Gs},
    {PORT_SPEED_ID_25G ,   CUT_THROUGH_CLASS_25Gs},
    {PORT_SPEED_ID_40G ,   CUT_THROUGH_CLASS_40Gs},
    {PORT_SPEED_ID_50G ,   CUT_THROUGH_CLASS_50Gs},
    {PORT_SPEED_ID_100G ,  CUT_THROUGH_CLASS_100Gs},
    {PORT_SPEED_ID_200G ,  CUT_THROUGH_CLASS_200Gs},
    {PORT_SPEED_ID_400G ,  CUT_THROUGH_CLASS_400Gs},
};

/*
 * \brief Convert HW drop probability to percent value
 *
 * \param [in]  percent      percent.
 *
 * \retval rate              rate.
 */
static const char*
cosq_info_int_to_char(int val, cosq_lt_convert_t *array, int nfields)
{
    int i;

    for (i = (nfields - 1); i >= 0; i--) {
      if (val >= array[i].val) {
          break;
      }
    }

    return array[i].sym_val;
}

/*
 * \brief Convert HW drop probability to percent value
 *
 * \param [in]  rate      rate.
 *
 * \retval percent        percent.
 */
static int
cosq_info_char_to_int(const char *field, cosq_lt_convert_t *array, int nfields)
{
    int val = 0;
    int i;

    for (i = 0; i < nfields; i++) {
        if (sal_strcasecmp(field, array[i].sym_val) == 0) {
            val = array[i].val;
            break;
        }
    }

    return val;
}

/*
 * \brief Convert HW drop probability to percent value
 *
 * \param [in]  percent      percent.
 *
 * \retval rate              rate.
 */
static const char*
cosq_wred_percent_to_drop_prob(int percent)
{
    int nfields;

    nfields = COUNTOF(cosq_drop_prob_to_percent);

    return cosq_info_int_to_char(percent, cosq_drop_prob_to_percent, nfields);
}

/*
 * \brief Convert HW drop probability to percent value
 *
 * \param [in]  rate      rate.
 *
 * \retval percent        percent.
 */
static int
cosq_wred_drop_prob_to_percent(const char *rate)
{
    int nfields;

    nfields = COUNTOF(cosq_drop_prob_to_percent);

    return cosq_info_char_to_int(rate, cosq_drop_prob_to_percent, nfields);
}

/*
 * \brief Convert us to time domain
 *
 * \param [in]  us           us.
 *
 * \retval time_domain       time_domain.
 */
static const char*
cosq_wred_us_to_time_domain(int us)
{
    int nfields;

    nfields = COUNTOF(cosq_wred_time_domain);

    return cosq_info_int_to_char(us, cosq_wred_time_domain, nfields);
}

/*
 * \brief Convert time domain to us
 *
 * \param [in]  time_domain      time_domain.
 *
 * \retval us        us.
 */
static int
cosq_wred_time_domain_to_us(const char *time_domain)
{
    int nfields;

    nfields = COUNTOF(cosq_wred_time_domain);

    return cosq_info_char_to_int(time_domain, cosq_wred_time_domain, nfields);
}

/*
 * \brief Convert ct mode to class
 *
 * \param [in]  ct_mode      ct_mode.
 *
 * \retval ct_class        ct_class.
 */
static int
port_ct_mode_to_class(const char *ct_mode)
{
    int nfields;

    nfields = COUNTOF(tm_cut_through_class);

    return cosq_info_char_to_int(ct_mode, tm_cut_through_class, nfields);
}

/*
 * \brief Get scheduler node type in symbol
 *
 * \param [in] unit      Unit Number.
 * \param [in] node_type node type.
 * \param [out] sym_val  node type in symbol.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
cosq_sched_node_type_get(int unit,
                         int node_type,
                         const char **sym_val)
{
    *sym_val = node_type == 0 ? L0_SCHED_NODEs :
               (node_type == 1 ? L1_SCHED_NODE_UCs : L1_SCHED_NODE_MCs);

    return SHR_E_NONE;
}

/*
 * \brief Get scheduler mode in symbol
 *
 * \param [in] unit      Unit Number.
 * \param [in/out] sched_mode sched mode.
 * \param [in/out] sym_val  node type in symbol.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
cosq_sched_mode_get(int unit,
                    int *sched_mode,
                    const char **sym_val,
                    bool get_sym)
{
    if (get_sym) {
        *sym_val = (*sched_mode == 0) ? SPs : RRs;
    } else {
        if (sal_strcasecmp(*sym_val, SPs) == 0) {
            *sched_mode = LTSW_SCHED_MODE_STRICT;
        } else if (sal_strcasecmp(*sym_val, RRs) == 0) {
            *sched_mode = LTSW_SCHED_MODE_WRR;
        } else {
            *sched_mode = LTSW_SCHED_MODE_WRR;
        }
    }

    return SHR_E_NONE;
}

/*
 * \brief Check port type.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  port          PORT ID.
 *
 * \retval TRUE               Port is cpu port.
 * \retval FALSE              Port is non cpu port.
 */
static int
is_cpu_port(int unit, bcm_port_t lport)
{
    return bcmi_ltsw_port_is_type(unit, lport,  BCMI_LTSW_PORT_TYPE_CPU);
}

/*
 * \brief Check port type.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  port          PORT ID.
 *
 * \retval TRUE               Port is lb port.
 * \retval FALSE              Port is non lb port.
 */
static int
is_lb_port(int unit, bcm_port_t lport)
{
    return bcmi_ltsw_port_is_type(unit, lport,  BCMI_LTSW_PORT_TYPE_LB);
}

/*
 * \brief Check port type.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  port          PORT ID.
 *
 * \retval TRUE               Port is mgmt port.
 * \retval FALSE              Port is non mgmt port.
 */
static int
is_mgmt_port(int unit, bcm_port_t lport)
{
    return bcmi_ltsw_port_is_type(unit, lport,  BCMI_LTSW_PORT_TYPE_MGMT);
}

/*
 * \brief Check input queue is unicast or not.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  queue_num     Queue id.
 * \param [in]  mc_q_mode     Multcast queue mode.
 *
 * \retval TRUE               queue is unicast queue.
 * \retval FALSE              queue is multcast queue.
 */
static int
queue_is_unicast(int unit, int queue_num)
{
    int mc_q_mode;
    int num_ucq;

    (void)tm_ltsw_cosq_mcq_mode_get(unit, &mc_q_mode);

    num_ucq = (mc_q_mode == 0) ? 12 : (mc_q_mode == 1) ? 10 :
              (mc_q_mode == 2) ? 8  : (mc_q_mode == 3) ? 6 : 8;
    if (queue_num < num_ucq) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * \brief Retrieve CPU port schedule or mcast node base pointer.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  gport         GPORT ID.
 * \param [out] node_base     Node base pointer.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_cpu_node_base_get(int unit, bcm_gport_t gport,
                       cosq_node_t **node_base)
{
    cosq_cpu_port_info_t *cpu_port_info = NULL;

    SHR_FUNC_ENTER(unit);

    cpu_port_info = LTSW_MMU_INFO(unit)->ltsw_cosq_cpu_port_info;

    if (cpu_port_info == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        *node_base = cpu_port_info->mcast;
    } else if (BCM_GPORT_IS_SCHEDULER(gport)) { /* scheduler */
        *node_base = cpu_port_info->sched;
    }else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Retrieve port schedule or mcast or ucast node base pointer.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  gport         GPORT ID.
 * \param [in]  local_port    logic port ID.
 * \param [out] node_base     Node base pointer.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_port_node_base_get(int unit, bcm_gport_t gport, bcm_port_t local_port,
                        cosq_node_t **node_base)
{
    cosq_port_info_t *port_info = NULL;

    SHR_FUNC_ENTER(unit);

    port_info = &LTSW_MMU_INFO(unit)->ltsw_cosq_port_info[local_port];
    if (port_info == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        *node_base = port_info->ucast;
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        *node_base = port_info->mcast;
    } else if (BCM_GPORT_IS_SCHEDULER(gport)) { /* scheduler */
        *node_base = port_info->sched;
    }else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Retrieve port cos node.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  local_port    logic port ID.
 * \param [in]  cos           cos.
 * \param [out] node          Node pointer.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_port_node_get(int unit, bcm_port_t local_port, int cos,
                   cosq_node_t **node)
{
    int idx, max_idx;
    cosq_node_t *node_info = NULL;

    SHR_FUNC_ENTER(unit);

    if (is_cpu_port(unit, local_port)) {
        node_info = LTSW_MMU_INFO(unit)->ltsw_cosq_cpu_port_info->mcast;
        max_idx = NUM_CPU_MCAST_QUEUE;
    } else {
        node_info = LTSW_MMU_INFO(unit)->ltsw_cosq_port_info[local_port].sched;
        max_idx = NUM_GP_QUEUES;
    }

    if (node_info == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    for (idx = 0; idx < max_idx; idx++) {
        if (cos == node_info[idx].index) {
            if (node != NULL) {
                *node = &node_info[idx];
                SHR_EXIT();
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Create ltsw_mmu_info[unit]->ltsw_cosq_cpu_port_info.
 *
 * \param [in]  unit          Unit number.
 */
static void
cosq_cpu_port_info_create(int unit)
{
    int num_mcast_queue;
    cosq_cpu_port_info_t *port_info;

    num_mcast_queue = NUM_CPU_MCAST_QUEUE;

    ltsw_mmu_info[unit]->ltsw_cosq_cpu_port_info =
                         (cosq_cpu_port_info_t*)(ltsw_mmu_info[unit] + 1);

    port_info = ltsw_mmu_info[unit]->ltsw_cosq_cpu_port_info;

    port_info->mcast = (cosq_node_t*)(port_info + 1);

    port_info->sched = (cosq_node_t*)(&port_info->mcast[num_mcast_queue]);
}

/*
 * \brief Create ltsw_mmu_info[unit]->ltsw_cosq_port_info.
 *
 * \param [in]  unit          Unit number.
 */
static void
cosq_port_info_create(int unit)
{
    int port;
    int max_port, num_ucast_queue, num_mcast_queue, num_sched, num_cpu_sched;
    cosq_cpu_port_info_t *cpu_port_info;
    cosq_port_info_t *port_info;

    max_port = bcmi_ltsw_dev_logic_port_num(unit);
    num_ucast_queue = NUM_GP_QUEUES;
    num_mcast_queue = NUM_GP_QUEUES;
    num_sched = NUM_GP_QUEUES;
    num_cpu_sched = NUM_GP_QUEUES;

    cpu_port_info = ltsw_mmu_info[unit]->ltsw_cosq_cpu_port_info;

    ltsw_mmu_info[unit]->ltsw_cosq_port_info =
        (cosq_port_info_t*)(&cpu_port_info->sched[num_cpu_sched]);

    port_info = ltsw_mmu_info[unit]->ltsw_cosq_port_info;

    port_info[0].ucast = (cosq_node_t*)(&port_info[max_port]);

    port_info[0].mcast = (cosq_node_t*)
                         (&port_info[0].ucast[num_ucast_queue]);

    port_info[0].sched = (cosq_node_t*)
                         (&port_info[0].mcast[num_mcast_queue]);

    for (port = 1; port < max_port; port++) {
        port_info[port].ucast = (cosq_node_t*)
                                (&port_info[port - 1].sched[num_sched]);
        port_info[port].mcast = (cosq_node_t*)
                                (&port_info[port].ucast[num_ucast_queue]);
        port_info[port].sched = (cosq_node_t*)
                                (&port_info[port].mcast[num_mcast_queue]);
    }
}

/*
 * \brief Free ltsw_mmu_info[unit].
 *
 * \param [in]  unit          Unit number.
 */
static void
cosq_mmu_info_destroy(int unit)
{
    SHR_FREE(ltsw_mmu_info[unit]);
}

/*
 * \brief Calculate alloc size for ltsw_mmu_info[unit].
 *
 * \param [in]  unit          Unit number.
 *
 * \retval ltsw_mmu_info[unit] size.
 */
static int
cosq_mmu_info_alloc_size_get(int unit)
{
    int mmu_info_size;
    int port_info_size;
    int cpu_info_size;

    mmu_info_size = sizeof(mmu_info_t);

    port_info_size = (sizeof(cosq_port_info_t)
                      + sizeof(cosq_node_t) * NUM_GP_QUEUES
                      + sizeof(cosq_node_t) * NUM_GP_QUEUES
                      + sizeof(cosq_node_t) * NUM_GP_QUEUES)
                      * bcmi_ltsw_dev_logic_port_num(unit);

    cpu_info_size = sizeof(cosq_cpu_port_info_t) +
                    sizeof(cosq_node_t) * NUM_CPU_MCAST_QUEUE +
                    sizeof(cosq_node_t) * NUM_GP_QUEUES;

    return (mmu_info_size + port_info_size + cpu_info_size);
}

/*
 * \brief Alloc a continuous memory for ltsw_mmu_info and distribute to its member.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_mmu_info_create(int unit)
{
    int alloc_size;

    SHR_FUNC_ENTER(unit);

    /* Create MMU Port Information structure */
    SHR_FREE(ltsw_mmu_info[unit]);

    alloc_size = cosq_mmu_info_alloc_size_get(unit);

    SHR_ALLOC(ltsw_mmu_info[unit],
              alloc_size, "ltswcosqCpuPortInfo");

    SHR_NULL_CHECK(ltsw_mmu_info[unit], SHR_E_MEMORY);

    sal_memset(ltsw_mmu_info[unit], 0, alloc_size);

    LTSW_MMU_INFO(unit)->gport_tree_created = FALSE;

    cosq_cpu_port_info_create(unit);

    cosq_port_info_create(unit);

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Validate input parameters of gport_attach or gport_detach.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  input_gport   GPORT ID.
 * \param [in]  parent_gport  GPORT ID.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_gport_attach_params_validate(int unit, bcm_gport_t input_gport,
                                  bcm_gport_t parent_gport)
{
    bcm_port_t input_port;
    bcm_port_t parent_port;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_gport_port_resolve(unit, input_gport, &input_port, NULL));

    if (!is_cpu_port(unit, input_port)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_gport_port_resolve(unit, parent_gport, &parent_port, NULL));

    if (!is_cpu_port(unit, parent_port)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
    }

    /* Post Default tree created, expected Input Gport is of MC Gport
     * and expected Parent Gport is new L0 Parent
     */
    if ((!BCM_GPORT_IS_SCHEDULER(parent_gport)) ||
        (!BCM_GPORT_IS_MCAST_QUEUE_GROUP(input_gport))) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Return a schedule node gport.
 *
 * \param [in]  port          port number.
 * \param [in]  hw_index      hw index.
 * \param [out] gport         sched node gport.
 */
static void
cosq_gport_sched_gport_set(int port, int index, bcm_gport_t *gport)
{
    uint32_t sched_encap;

    sched_encap = (index << 16) | port;
    BCM_GPORT_SCHEDULER_SET(*gport, sched_encap);
}

/*
 * \brief Set node.
 *
 * \param [in]  node          cos node point.
 * \param [in]  gport         node gport.
 * \param [in]  parent_gport  parent node gport.
 * \param [in]  numq          child num.
 * \param [in]  level         node level.
 * \param [in]  hw_index      hw index.
 * \param [in]  cos           node cos.
 * \param [in]  in_use        in use.
 */
static void
cosq_gport_node_set(cosq_node_t *node, bcm_gport_t gport,
                    bcm_gport_t parent_gport, int numq, int index,
                    int level, int cos, int in_use)
{
    node->gport               = gport;
    node->parent_gport        = parent_gport;
    node->index               = index;
    node->numq                = numq;
    node->level               = level;
    node->cos                 = cos;
    node->in_use              = in_use;
}

/*
 * \brief Create non CPU port ucast node.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  local_port    port ID.
 * \param [in]  node          hierarchical tree node.
 * \param [in]  parent_gport  GPORT ID.
 * \param [in]  index         index.
 * \param [out] ucast_node    ucast node.
 */
static void
cosq_ucast_node_create(int unit, int local_port,
                       int cos,
                       bcm_gport_t parent_gport,
                       int index,
                       cosq_node_t *ucast_node)
{
    bcm_gport_t gport;

    BCM_GPORT_UCAST_QUEUE_GROUP_SYSQID_SET(gport, local_port, index);
    cosq_gport_node_set(ucast_node, gport, parent_gport, 1, index,
                        LTSW_COSQ_NODE_LVL_UC, cos, true);

    LOG_INFO(BSL_LOG_MODULE,
        (BSL_META_U(unit,
        "UCAST add_attach port %d id %d gport %d index %d\n"),
        local_port, index, gport, index));
}

/*
 * \brief Create non CPU port mcast node.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  local_port    port ID.
 * \param [in]  node          hierarchical tree node.
 * \param [in]  parent_gport  GPORT ID.
 * \param [in]  index         index.
 * \param [out] mcast_node    mcast node.
 */
static void
cosq_mcast_node_create(int unit, int local_port,
                       int cos,
                       bcm_gport_t parent_gport,
                       int index,
                       cosq_node_t *mcast_node)
{
    bcm_gport_t gport;

    BCM_GPORT_MCAST_QUEUE_GROUP_SYSQID_SET(gport, local_port, index);
    cosq_gport_node_set(mcast_node, gport, parent_gport, 1, index,
                               LTSW_COSQ_NODE_LVL_MC, cos, true);

    LOG_INFO(BSL_LOG_MODULE,
        (BSL_META_U(unit,
        "MCAST add_attach port %d id %d gport %d index %d\n"),
        local_port, index, gport, index));
}

/*
 * \brief Create non CPU port sched node.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  local_port    port ID.
 * \param [in]  node          hierarchical tree node.
 * \param [in]  parent_gport  GPORT ID.
 * \param [in]  id            id.
 * \param [out] sched_node    sched node.
 */
static void
cosq_sched_node_create(int unit, int local_port,
                       int numq,
                       bcm_gport_t gport,
                       int index,
                       cosq_node_t *sched_node)
{
    bcm_gport_t parent_gport;
    int modid;
    bool in_use = false;

    if (numq > 0) {
        in_use = true;
    }

    (void)bcm_ltsw_stk_my_modid_get(unit, &modid);

    BCM_GPORT_MODPORT_SET(parent_gport, modid, local_port);

    cosq_gport_node_set(sched_node, gport, parent_gport, numq, index,
                        LTSW_COSQ_NODE_LVL_L0, index, in_use);

    LOG_INFO(BSL_LOG_MODULE,
             (BSL_META_U(unit,
             "SCHED add_attach port %d numq %d gport %d sched.numq %d\n"),
             local_port, index, gport, numq));
}

/*
 * \brief Get CPU port sched node child node number.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  index         index.
 * \param [out] numq          Number queue.
 */
static int
cosq_cpu_sched_node_numq_get(int unit, int index, int *numq)
{
    int id, parent_index;
    int count = 0;

    SHR_FUNC_ENTER(unit);

    for (id = 0; id < NUM_CPU_MCAST_QUEUE; id++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_cpu_parent_get(unit, id, LTSW_COSQ_NODE_LVL_MC,
                                         &parent_index));
        if (parent_index == index) {
            count++;
        }
    }

    *numq = count;

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Create CPU port mcast node.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  local_port    port ID.
 * \param [in]  node          hierarchical tree node.
 * \param [in]  parent_gport  GPORT ID.
 * \param [in]  index         index.
 * \param [out] mcast_node    mcast node.
 */
static void
cosq_cpu_mcast_node_create(int unit, int local_port,
                           int parent_index,
                           bcm_gport_t parent_gport,
                           int index,
                           cosq_node_t *mcast_node)
{
    bcm_gport_t gport;
    int numq;

    BCM_GPORT_MCAST_QUEUE_GROUP_SYSQID_SET(gport, local_port, index);

    numq = (parent_gport == BCM_GPORT_INVALID) ? 0 : 1;

    cosq_gport_node_set(mcast_node, gport, parent_gport, numq, index,
                        LTSW_COSQ_NODE_LVL_MC, parent_index, 1);
    LOG_INFO(BSL_LOG_MODULE,
         (BSL_META_U(unit,
                     "cpu_port_info[%d] mcast gport=%x parent_gport=%x index=%d\n"),
          index, gport, parent_gport, index));
}

/*
 * \brief Create CPU port sched node.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  local_port    port ID.
 * \param [in]  node          hierarchical tree node.
 * \param [in]  parent_gport  GPORT ID.
 * \param [in]  index         index.
 * \param [out] sched_node    sched node.
 */
static void
cosq_cpu_sched_node_create(int unit, int local_port,
                           bcm_gport_t parent_gport,
                           int index,
                           cosq_node_t *sched_node)
{
    bcm_gport_t gport;
    int numq = 0;

    cosq_gport_sched_gport_set(local_port, index, &gport);

    (void)cosq_cpu_sched_node_numq_get(unit, index, &numq);

    cosq_gport_node_set(sched_node, gport, parent_gport, numq, index,
                        LTSW_COSQ_NODE_LVL_L0,
                        index, 1);
    LOG_INFO(BSL_LOG_MODULE,
         (BSL_META_U(unit,
                     "cpu_port_info[%d] sched gport=%x parent_gport=%x\n"),
          index, gport, parent_gport));
}

/*
 * \brief Destroy port tree
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [out] port_info Port info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
cosq_gport_port_tree_destroy(
    int unit,
    bcm_port_t port,
    cosq_port_info_t *port_info)
{
    int id, idx;
    int num_ucq;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, NULL));

    for (idx = 0; idx < NUM_SCHEDULER_PER_PORT; idx++) {
        cosq_gport_node_set(&port_info->sched[idx],
                            0, 0, 0, -1, 0, -1, 0);

        if (queue_is_unicast(unit, idx)) {
            cosq_gport_node_set(&port_info->ucast[idx],
                                0, 0, 0, -1, 0, -1, 0);
        } else {
            id = idx - num_ucq;
            cosq_gport_node_set(&port_info->mcast[id],
                                0, 0, 0, -1, 0, -1, 0);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Create port tree
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [out] port_info Port info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
cosq_gport_port_tree_create(
    int unit,
    bcm_port_t port,
    cosq_port_info_t *port_info)
{
    int id = 0, node_id, num_child;
    int profile_id;
    int num_node;
    bcm_gport_t gport = 0, child_parent_gport1 = 0, child_parent_gport2 = 0;
    tm_ltsw_cosq_scheduler_profile_q_info_t profile;
    int rv = SHR_E_NONE;
    int l0_hw_index = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_port_tree_destroy(unit, port, port_info));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_port_scheduler_profile_get(unit, port, &profile_id));

    for (node_id = 0; node_id < NUM_GP_QUEUES; node_id++) {
        rv = tm_ltsw_schedule_profile_queue_info_get(unit, profile_id, node_id,
                                                     &profile);

        num_node = profile.num_mcq + profile.num_ucq;

        if (rv == SHR_E_NOT_FOUND) {
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT(rv);

        if (num_node == 2) {
            /*
             * Any L0 node can have a maximum up to two L1 node
             * Two consecutive L0 nodes cannot have two L1 nodes.
             * L0.0 Node can have only one child L1.0
             * Use greedy algorithm, if a L0 node have two child nodes,
             * then it's previous node should have no child node.
             * an example:
             * If cos 0 have two child node, L0.1 should be used for cos 0.
             * And If cos 1 have two child node too, L0.3 should be used for cos 1.
             */
            cosq_gport_sched_gport_set(port, l0_hw_index,
                                       &gport);
            num_child = 0;
            cosq_sched_node_create(unit, port, num_child,
                                   gport,
                                   -1,
                                   &port_info->sched[l0_hw_index]);

            cosq_gport_sched_gport_set(port, l0_hw_index + 1,
                                       &child_parent_gport2);
            num_child = num_node;
            cosq_sched_node_create(unit, port, num_child,
                                   child_parent_gport2,
                                   node_id,
                                   &port_info->sched[l0_hw_index + 1]);

            l0_hw_index += 2;
        } else if (num_node == 1) {
            cosq_gport_sched_gport_set(port, l0_hw_index,
                                       &child_parent_gport1);
            num_child = num_node;
            cosq_sched_node_create(unit, port, num_child,
                                   child_parent_gport1,
                                   node_id,
                                   &port_info->sched[l0_hw_index]);
            l0_hw_index += 1;
        } else if (num_node == 0) {
            continue;
        }
        if (num_node == 2) {
            if (profile.num_ucq == 2) {
                id = profile.ucq_id[0];
                cosq_ucast_node_create(unit, port, node_id,
                                       child_parent_gport2, id,
                                       &port_info->ucast[id]);
                id = profile.ucq_id[1];
                cosq_ucast_node_create(unit, port, node_id,
                                       child_parent_gport2, id,
                                       &port_info->ucast[id]);
            } else {
                id = profile.ucq_id[0];
                cosq_ucast_node_create(unit, port, node_id,
                                       child_parent_gport2, id,
                                       &port_info->ucast[id]);

                id = profile.mcq_id;
                cosq_mcast_node_create(unit, port, node_id,
                                       child_parent_gport2, id,
                                       &port_info->mcast[id]);
            }
        } else {
            if (profile.num_ucq == 1) {
                id = profile.ucq_id[0];
                cosq_ucast_node_create(unit, port, node_id,
                                       child_parent_gport1, id,
                                       &port_info->ucast[id]);
            }
            if (profile.num_mcq == 1) {
                id = profile.mcq_id;
                cosq_mcast_node_create(unit, port, node_id,
                                       child_parent_gport1, id,
                                       &port_info->mcast[id]);
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Create cpu port tree
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [out] port_info Port info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
cosq_gport_cpu_port_tree_create(
    int unit,
    bcm_port_t port,
    cosq_cpu_port_info_t *port_info)
{
    int idx, parent_index;
    bcm_gport_t parent_gport;

    SHR_FUNC_ENTER(unit);

    for (idx = 0; idx < NUM_SCHEDULER_PER_PORT; idx++) {
        cosq_cpu_sched_node_create(unit, port, port, idx,
                                   &port_info->sched[idx]);
    }

    for (idx = 0; idx < NUM_CPU_MCAST_QUEUE; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_cpu_parent_get(unit, idx, LTSW_COSQ_NODE_LVL_MC,
                                         &parent_index));
        if (parent_index == -1) {
            parent_gport = BCM_GPORT_INVALID;
        } else {
            cosq_gport_sched_gport_set(port, parent_index,
                                       &parent_gport);
        }

        cosq_cpu_mcast_node_create(unit, port, parent_index,
                                   parent_gport, idx,
                                   &port_info->mcast[idx]);
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Walks through the valid CPU port COSQ GPORTs and calls
 *        the user supplied callback function for each entry.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  trav_fn       Callback function.
 * \param [out] user_data     User data to be passed to callback function.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_gport_cpu_traverse(int unit, bcm_cosq_gport_traverse_cb cb,
                        void *user_data)
{
    cosq_cpu_port_info_t *cpu_port_info = NULL;
    bcm_gport_t gport;
    bcm_module_t my_modid, modid_out;
    bcm_port_t port, port_out;
    int id, rv;
    int num_mcast_queue, num_sched;

    SHR_FUNC_ENTER(unit);

    cpu_port_info = LTSW_MMU_INFO(unit)->ltsw_cosq_cpu_port_info;
    port = bcmi_ltsw_port_cpu(unit);
    num_mcast_queue = NUM_CPU_MCAST_QUEUE;
    num_sched = NUM_GP_QUEUES;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_stk_my_modid_get(unit, &my_modid));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_stk_modmap_map(unit, BCM_STK_MODMAP_GET,
                                 my_modid, port, &modid_out, &port_out));

    BCM_GPORT_MODPORT_SET(gport, modid_out, port_out);

    for (id = 0; id < num_mcast_queue; id++) {
        if (cpu_port_info->mcast[id].in_use == 0) {
            continue;
        }
        rv = cb(unit, gport, cpu_port_info->mcast[id].numq,
                BCM_COSQ_GPORT_MCAST_QUEUE_GROUP,
                cpu_port_info->mcast[id].gport, user_data);

        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }

        rv = SHR_E_NONE;
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    for (id = 0; id < num_sched; id++) {
        if (cpu_port_info->sched[id].in_use == 0) {
            continue;
        }
        rv = cb(unit, gport, cpu_port_info->sched[id].numq,
                BCM_COSQ_GPORT_SCHEDULER,
                cpu_port_info->sched[id].gport, user_data);

        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }

        rv = SHR_E_NONE;
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Walks through the valid COSQ GPORTs belong to a port and calls
 *        the user supplied callback function for each entry.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  port          Port number.
 * \param [in]  trav_fn       Callback function.
 * \param [out] user_data     User data to be passed to callback function.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_gport_port_traverse(int unit, int port, bcm_cosq_gport_traverse_cb cb,
                         void *user_data)
{
    cosq_port_info_t *port_info = NULL;
    bcm_gport_t gport;
    bcm_module_t my_modid, modid_out;
    bcm_port_t port_out;
    int id, rv;
    int num_ucast_queue, num_mcast_queue, num_sched;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucast_queue, &num_mcast_queue));

    num_sched = NUM_GP_QUEUES;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_stk_my_modid_get(unit, &my_modid));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_stk_modmap_map(unit, BCM_STK_MODMAP_GET,
                                  my_modid, port, &modid_out, &port_out));

    BCM_GPORT_MODPORT_SET(gport, modid_out, port_out);

    port_info = &LTSW_MMU_INFO(unit)->ltsw_cosq_port_info[port];

    for (id = 0; id < num_ucast_queue; id++) {
        if (port_info->ucast[id].numq == 0) {
            continue;
        }

        rv = cb(unit, gport, port_info->ucast[id].numq,
                BCM_COSQ_GPORT_UCAST_QUEUE_GROUP,
                port_info->ucast[id].gport, user_data);

        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }

        rv = SHR_E_NONE;
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }
    for (id = 0; id < num_mcast_queue; id++) {
        if (port_info->mcast[id].numq == 0) {
            continue;
        }

        rv = cb(unit, gport, port_info->mcast[id].numq,
                BCM_COSQ_GPORT_MCAST_QUEUE_GROUP,
                port_info->mcast[id].gport, user_data);

        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }

        rv = SHR_E_NONE;
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    for (id = 0; id < num_sched; id++) {
        if (port_info->sched[id].numq == 0) {
            continue;
        }

        rv = cb(unit, gport, port_info->sched[id].numq,
                BCM_COSQ_GPORT_SCHEDULER,
                port_info->sched[id].gport, user_data);

        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }

        rv = SHR_E_NONE;
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Walks through the valid port COSQ GPORTs and calls
 *        the user supplied callback function for each entry.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  trav_fn       Callback function.
 * \param [out] user_data     User data to be passed to callback function.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_gport_traverse(int unit, bcm_cosq_gport_traverse_cb cb,
                    void *user_data)
{
    bcm_pbmp_t pbmp;
    bcm_port_t port;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(pbmp);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_PORT, &pbmp));

    BCM_PBMP_ITER(pbmp, port) {
        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_gport_port_traverse(unit, port, cb, user_data));
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Get node structure for the specified GPORT.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  gport         GPORT identifier.
 * \param [out] node          node structure for the specified GPORT.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_gport_node_get(int unit, bcm_gport_t gport, cosq_node_t **node)
{
    cosq_node_t *node_base = NULL;
    int index, local_port;

    SHR_FUNC_ENTER(unit);

    if (LTSW_MMU_INFO(unit) == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_gport_port_resolve(unit, gport, &local_port, &index));
    if (is_cpu_port(unit, local_port)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_cpu_node_base_get(unit, gport, &node_base));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_port_node_base_get(unit, gport, local_port, &node_base));
    }

    if (node_base == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    }

    if (node != NULL) {
        *node = &node_base[index];
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Update node and parent node.
 *
 * \param [in]  unit          Unit number.
 * \param [out] node          Node.
 * \param [out] parent_node   Parent node.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_gport_cpu_node_parent_update(int unit, cosq_node_t **node,
                                  cosq_node_t **parent_node)
{
    cosq_node_t *old_parent_node;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_node_get(unit, (*node)->parent_gport,
                                    &old_parent_node));

    old_parent_node->numq--;
    (*node)->parent_gport = (*parent_node)->gport;
    (*node)->cos = (*parent_node)->cos;
    (*parent_node)->numq++;

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Create a cosq gport structure for CPU Port.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_gport_cpu_tree_create(int unit)
{
    cosq_cpu_port_info_t *cpu_port_info;
    int port;

    SHR_FUNC_ENTER(unit);

    cpu_port_info = LTSW_MMU_INFO(unit)->ltsw_cosq_cpu_port_info;
    port = bcmi_ltsw_port_cpu(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_cpu_port_tree_create(unit, port, cpu_port_info));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Create a cosq gport structure for non CPU Ports.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_gport_tree_create(int unit)
{
    cosq_port_info_t *port_info;
    bcm_pbmp_t pbmp;
    int port;
    uint32_t port_type;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(pbmp);

    port_type = BCMI_LTSW_PORT_TYPE_PORT | BCMI_LTSW_PORT_TYPE_MGMT |
                BCMI_LTSW_PORT_TYPE_LB;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, port_type, &pbmp));

    BCM_PBMP_ITER(pbmp, port) {
        port_info = &LTSW_MMU_INFO(unit)->ltsw_cosq_port_info[port];
        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_gport_port_tree_create(unit, port, port_info));
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Resolve gport with cosq node and local port id.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  gport         Port number or GPORT identifier.
 * \param [in]  cosq          COS queue number.
 * \param [in]  node          node.
 * \param [in]  local_port    Local port id.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_gport_resolve(int unit, bcm_port_t gport, int cosq,
                   cosq_node_t **node, bcm_port_t *local_port)
{
    int modid, trunk_id, id;

    SHR_FUNC_ENTER(unit);

    if (BCM_GPORT_IS_SCHEDULER(gport) ||
        BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) ||
        BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_cosq_gport_port_resolve(unit, gport, local_port, NULL));

        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_gport_node_get(unit, gport, node));
    } else {
        if (BCM_GPORT_IS_SET(gport)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_gport_resolve(unit, gport, &modid, local_port,
                                              &trunk_id, &id));
        } else {
            *local_port = gport;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_validate(unit, *local_port, local_port));

        if ((cosq < 0) ||
            (cosq >= bcmi_ltsw_cosq_port_num_cos(unit, *local_port))) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_port_node_get(unit, *local_port, cosq, node));
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Convert mode to sched mode.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  mode          mode.
 * \param [in]  weight        weight.
 * \param [out] sched_mode    sched mode.
 * \param [out] lwts          weight.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_sched_mode_convert(int unit, int mode, int weight,
                        int *sched_mode, int *lwts)
{
    SHR_FUNC_ENTER(unit);

    if ((weight < QSCHED_MIN_WEIGHT) ||
        (weight > QSCHED_MAX_WEIGHT)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    switch(mode) {
        case BCM_COSQ_STRICT:
            *sched_mode = LTSW_SCHED_MODE_STRICT;
            *lwts = 0;
            break;
        case BCM_COSQ_ROUND_ROBIN:
            *sched_mode = LTSW_SCHED_MODE_WRR;
            *lwts = 1;
            break;
        case BCM_COSQ_WEIGHTED_ROUND_ROBIN:
            *sched_mode = LTSW_SCHED_MODE_WRR;
            *lwts = weight;
            break;
        case BCM_COSQ_DEFICIT_ROUND_ROBIN:
            *sched_mode = LTSW_SCHED_MODE_WERR;
            *lwts = weight;
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Weight = 0 corresponds to Strict Mode */
    if (*lwts == 0) {
        *sched_mode = LTSW_SCHED_MODE_STRICT;
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Set node scheduling mode and weight.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  gport         Port number or GPORT identifier.
 * \param [in]  cosq          COS queue number.
 * \param [in]  mode          scheduling mode.
 * \param [in]  weight        weight.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_sched_set(int unit, bcm_port_t gport, bcm_cos_queue_t cosq,
               int mode, int weight)
{
    bcm_port_t local_port;
    int lwts;
    int sched_mode;
    cosq_node_t *node = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_resolve(unit, gport, cosq, &node, &local_port));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_sched_mode_convert(unit, mode, weight, &sched_mode, &lwts));

    if (node->in_use == 0) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_sched_set(unit, local_port, node->index,
                                node->level, sched_mode, lwts));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Get node scheduling mode and weight.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  gport         Port number or GPORT identifier.
 * \param [in]  cosq          COS queue number.
 * \param [out] mode          scheduling mode.
 * \param [out] weight        weight.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_sched_get(int unit, bcm_port_t gport, bcm_cos_queue_t cosq,
               int *mode, int *weight)
{
    bcm_port_t local_port;
    int sched_mode, lwts;
    cosq_node_t *node = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_resolve(unit, gport, cosq, &node, &local_port));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_sched_get(unit, local_port, node->index, node->level,
                                &sched_mode, &lwts));

    if (mode != NULL) {
        switch(sched_mode) {
            case LTSW_SCHED_MODE_STRICT:
                *mode = BCM_COSQ_STRICT;
                break;
            case LTSW_SCHED_MODE_WRR:
                *mode = BCM_COSQ_WEIGHTED_ROUND_ROBIN;
                break;
            case LTSW_SCHED_MODE_WERR:
                *mode = BCM_COSQ_DEFICIT_ROUND_ROBIN;
                break;
            default:
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
        }
    }

    if (weight != NULL) {
        *weight = lwts;
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Create a cosq gport structure for all Ports.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_gport_default_config(int unit)
{
    SHR_FUNC_ENTER(unit);

    LTSW_MMU_INFO(unit)->gport_tree_created = FALSE;

    SHR_IF_ERR_EXIT
        (cosq_gport_tree_create(unit));

    SHR_IF_ERR_EXIT
        (cosq_gport_cpu_tree_create(unit));

    LTSW_MMU_INFO(unit)->gport_tree_created = TRUE;

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Displays CPU port cosq information maintained by software.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHE_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_cpu_port_info_dump(int unit)
{
    cosq_cpu_port_info_t *cpu_port_info;
    int local_port;
    int index;
    int sched_mode;
    int weight = 0;
    int parent_id = 0;
    cosq_node_t *node = NULL;
    char *sched_modes[] = {"SP", "WRR", "WERR"};

    SHR_FUNC_ENTER(unit);

    cpu_port_info = LTSW_MMU_INFO(unit)->ltsw_cosq_cpu_port_info;
    local_port = bcmi_ltsw_port_cpu(unit);

    LOG_CLI((BSL_META_U(unit,
                        "=== CPU PORT ===\n")));

    LOG_CLI((BSL_META_U(unit,
                        "L0 Nodes\n")));

    for (index = 0; index < NUM_GP_QUEUES; index++) {
        /* Node */
        node = &cpu_port_info->sched[index];

        (void)tm_ltsw_cosq_sched_get(unit, local_port, node->index, node->level,
                                     &sched_mode, &weight);

        LOG_CLI((BSL_META_U(unit,
                            "    LO.%d: GPORT=0x%x MODE=%s WT=%d\n"),
                             index, node->gport,
                             sched_modes[sched_mode], weight));
    }

    LOG_CLI((BSL_META_U(unit,
                        "\nMC Queues\n")));

    for (index = 0; index < NUM_CPU_MCAST_QUEUE; index++) {
        /* MC Queue */
        node = &cpu_port_info->mcast[index];

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_cosq_gport_port_resolve(unit, node->parent_gport, NULL,
                                               &parent_id));

        (void)tm_ltsw_cosq_sched_get(unit, local_port, node->index, node->level,
                                     &sched_mode, &weight);

        LOG_CLI((BSL_META_U(unit,
                            "    MC.%d: GPORT=0x%x MODE=%s WT=%d"
                            " PARENT=L0.%d\n"),
                             index, node->gport,
                             sched_modes[sched_mode], weight,
                             parent_id));
    }

    LOG_CLI((BSL_META_U(unit,
                        "=========== \n")));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Displays non CPU port cosq information maintained by software.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHE_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_port_info_dump(int unit)
{
    cosq_port_info_t *port_info;
    cosq_node_t *node;
    int index, empty, port, parent_id;
    bcm_pbmp_t pbmp;
    int sched_mode = 0;
    int weight = 0;
    int num_ucq, num_mcq;
    char *sched_modes[] = {"SP", "WRR", "WERR"};

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(pbmp);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_PORT, &pbmp));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));

    BCM_PBMP_ITER(pbmp, port) {
        port_info = &LTSW_MMU_INFO(unit)->ltsw_cosq_port_info[port];

        empty = TRUE;
        for (index = 0; index < NUM_GP_QUEUES; index++) {
            if (port_info->sched[index].numq > 0) {
                empty = FALSE;
                break;
            }
        }

        if (empty == TRUE) {
            continue;
        }

        LOG_CLI((BSL_META_U(unit,
                            "=== PORT %d\n"), port));

        for (index = 0; index < NUM_GP_QUEUES; index++) {
            /* Node */
            node = &port_info->sched[index];

            if (node->in_use == 0) {
                continue;
            }

            (void)tm_ltsw_cosq_sched_get(unit, port, node->index, node->level,
                                         &sched_mode, &weight);

            LOG_CLI((BSL_META_U(unit,
                                "LO.%d: GPORT=0x%x MODE=%s WT=%d, COS=%d\n"),
                                 index, node->gport,
                                 sched_modes[sched_mode],
                                 weight, node->cos));
        }

        for (index = 0; index < num_ucq; index++) {
            /* UC Queue */
            node = &port_info->ucast[index];

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_cosq_gport_port_resolve(unit, node->parent_gport,
                                                   NULL, &parent_id));

            (void)tm_ltsw_cosq_sched_get(unit, port, node->index, node->level,
                                         &sched_mode, &weight);

            LOG_CLI((BSL_META_U(unit,
                            "UC.%d: GPORT=0x%x MODE=%s WT=%d PARENT=%d\n"),
                             index, node->gport,
                             sched_modes[sched_mode], weight,
                             parent_id));
        }

        for (index = 0; index < num_mcq; index++) {
            /* MC Queue */
            node = &port_info->mcast[index];

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_cosq_gport_port_resolve(unit, node->parent_gport,
                                                   NULL, &parent_id));

            (void)tm_ltsw_cosq_sched_get(unit, port, node->index, node->level,
                                         &sched_mode, &weight);

            LOG_CLI((BSL_META_U(unit,
                            "MC.%d: GPORT=0x%x MODE=%s WT=%d PARENT=%d\n"),
                             index, node->gport,
                             sched_modes[sched_mode], weight,
                             parent_id));
        }

        LOG_CLI((BSL_META_U(unit,
                            "=========== \n")));
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief check wred profile is needed update.
 *
 * \param [in]  flags                 flags.
 *
 * \retval TRUE         need profile.
 * \retval FALSE        no need profile.
 */
static bool
cosq_wred_need_profile(uint32_t flags)
{
    if (flags & (BCM_COSQ_DISCARD_COLOR_ALL |
                 BCM_COSQ_DISCARD_TCP |
                 BCM_COSQ_DISCARD_NONTCP |
                 BCM_COSQ_DISCARD_ECT_MARKED |
                 BCM_COSQ_DISCARD_RESPONSIVE_DROP |
                 BCM_COSQ_DISCARD_NON_RESPONSIVE_DROP)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * \brief Initialize the LT TM_WRED_CNG_NOTIFICATION_PROFILE.
 *
 * This function is used to initialize the LT TM_WRED_CNG_NOTIFICATION_PROFILE
 *
 * \param [in]  unit                 Unit Number.
 * \param [in]  vd                   Default CNG information.
 *
 * \retval SHR_E_NONE                No errors.
 * \retval !SHR_E_NONE               Failure.
 */
static int
cosq_wred_cng_profile_init(int unit)
{
    int idx;
    uint32_t ha_alloc_size, ha_req_size;
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    ha_req_size = sizeof(int) * COSQ_NUM_WRED_RESOLUTION_TABLE;
    ha_alloc_size = ha_req_size;

    cosq_wred_resolution_tbl[unit] = (int *)bcmi_ltsw_ha_mem_alloc
                                                (unit, BCMI_HA_COMP_ID_COSQ,
                                                 BCMINT_COSQ_WRED_SUB_COMP_ID,
                                                 "bcmCosqWred",
                                                 &ha_alloc_size);
    SHR_NULL_CHECK(cosq_wred_resolution_tbl[unit], SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    if (!warm) {
        for (idx = 0; idx < COSQ_NUM_WRED_RESOLUTION_TABLE; idx++) {
            if (idx == 0) {
                cosq_wred_resolution_tbl[unit][idx] = 1;
                 SHR_IF_ERR_VERBOSE_EXIT
                    (tm_ltsw_cosq_wred_cng_profile_reset(unit, idx));
            } else {
                cosq_wred_resolution_tbl[unit][idx] = 0;
            }
        }
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (!warm && cosq_wred_resolution_tbl[unit]) {
            (void)bcmi_ltsw_ha_mem_free(unit, cosq_wred_resolution_tbl[unit]);
            cosq_wred_resolution_tbl[unit] = NULL;
        }
    }

    SHR_FUNC_EXIT();
}

/*
 * \brief cosq wred default config create.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_wred_default_config(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (cosq_wred_cng_profile_init(unit));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Setup profile with flags.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  gport         gport.
 * \param [in]  cosq          cosq.
 * \param [in]  flags         flags.
 * \param [out] profile       profile.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_cos_map_profile_fill(int unit, int lport, bcm_gport_t gport, bcm_cos_queue_t cosq,
                          uint32_t flags, tm_ltsw_cosq_cos_map_profile_t *profile)
{
    cosq_node_t *node = NULL;
    bcm_cos_queue_t hw_cosq;
    int num_ucq, num_mcq;
    int local_port;

    SHR_FUNC_ENTER(unit);

    if (gport != -1) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_cosq_localport_resolve(unit, gport, &local_port));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));

    switch (flags) {
        case BCM_COSQ_GPORT_UCAST_QUEUE_GROUP:
            if (gport == -1) {
                hw_cosq = cosq;
            } else {
                if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }
                SHR_IF_ERR_VERBOSE_EXIT
                    (cosq_gport_node_get(unit, gport, &node));

                hw_cosq = node->index;
            }
            hw_cosq %= num_ucq;
            profile->uc_cos = hw_cosq;
            break;
        case BCM_COSQ_GPORT_MCAST_QUEUE_GROUP:
            if (gport == -1) {
                hw_cosq = cosq;
                if (is_cpu_port(unit, lport)) {
                    profile->cpu_cos = hw_cosq;
                } else {
                    if (num_mcq != 0) {
                        hw_cosq %= num_mcq;
                        profile->mc_cos = hw_cosq;
                    }
                }
            } else {
                if (!BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }
                SHR_IF_ERR_VERBOSE_EXIT
                    (cosq_gport_node_get(unit, gport, &node));

                hw_cosq = node->index;
                if (is_cpu_port(unit, local_port)) {
                    profile->cpu_cos = hw_cosq;
                } else {
                    if (num_mcq != 0) {
                        hw_cosq %= num_mcq;
                        profile->mc_cos = hw_cosq;
                    }
                }
            }

            break;
        case (BCM_COSQ_GPORT_UCAST_QUEUE_GROUP |
              BCM_COSQ_GPORT_MCAST_QUEUE_GROUP):
            if (gport == -1) {
                hw_cosq = cosq;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            if (is_cpu_port(unit, lport)) {
                profile->uc_cos = MIN(hw_cosq, num_ucq - 1);
                profile->cpu_cos = hw_cosq;
            } else {
                profile->uc_cos = MIN(hw_cosq, num_ucq - 1);
                if (num_mcq != 0) {
                    profile->mc_cos = MIN(hw_cosq, num_mcq ? num_mcq - 1 : 0);
                }
            }

            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Set COS queue for the specified priority of an ingress port.
 *
 * \param [in]  unit                  Unit number.
 * \param [in]  ing_port              ingress port.
 * \param [in]  priority              priority value to map.
 * \param [in]  flags                 BCM_COSQ_GPORT_XXX_QUEUE_GROUP.
 * \param [in]  gport                 queue group GPORT identifier.
 * \param [in]  cosq                  COS queue number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_cos_mapping_set(int unit, bcm_port_t local_port, bcm_cos_t priority,
                     uint32_t flags, bcm_gport_t gport, bcm_cos_queue_t cosq)
{
    tm_ltsw_cosq_cos_map_profile_t cos_map_entries[COSQ_NUM_INT_PRI] = {{0}};
    int old_index, new_index;

    SHR_FUNC_ENTER(unit);

    if ((priority < 0) || (priority >= COSQ_NUM_INT_PRI)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if ((cosq < 0) ||
        (cosq >= bcmi_ltsw_cosq_port_num_cos(unit, local_port))) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_get(unit, local_port, BCMI_PT_PORT_COS_QUEUE_MAP_ID,
                                &old_index));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_cos_map_profile_get(unit, old_index * COSQ_NUM_INT_PRI,
                                          &cos_map_entries[0]));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_cos_map_profile_fill(unit, local_port, gport, cosq, flags,
                                   &cos_map_entries[priority]));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_cos_map_profile_delete(unit, old_index * COSQ_NUM_INT_PRI));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_cos_map_profile_add(unit, cos_map_entries, &new_index));

    new_index /= COSQ_NUM_INT_PRI;

    LOG_INFO(BSL_LOG_MODULE,
             (BSL_META_U(unit,
                         "cosq_cos_mapping_set: u=%d p=%d id =%d, oid=%d "
                         "priority =%d, cosq=%d\n"),
                         unit, local_port, new_index, old_index,
                         priority, cosq));

    SHR_IF_ERR_CONT
        (bcmi_ltsw_port_tab_set(unit, local_port,
                                BCMI_PT_PORT_COS_QUEUE_MAP_ID,
                                new_index));

    if (SHR_FUNC_ERR()) {
        LOG_ERROR(BSL_LOG_MODULE,
                 (BSL_META_U(unit,
                             "cosq_cos_mapping_set: u=%d p=%d id =%d, oid=%d\n"),
                             unit, local_port, new_index,old_index));
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_cos_map_profile_delete(unit, new_index * COSQ_NUM_INT_PRI));
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Get COS queue for the specified priority of an ingress port.
 *
 * \param [in]  unit                  Unit number.
 * \param [in]  ing_port              ingress port.
 * \param [in]  priority              priority value to map.
 * \param [in]  flags                 BCM_COSQ_GPORT_XXX_QUEUE_GROUP.
 * \param [out] gport                 queue group GPORT identifier.
 * \param [out] cosq                  COS queue number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_cos_mapping_get(int unit, bcm_port_t local_port, bcm_cos_t priority,
                     uint32_t flags, bcm_gport_t *gport, bcm_cos_queue_t *cosq)
{
    cosq_node_t *node = NULL;
    tm_ltsw_cosq_cos_map_profile_t cos_map_entries[COSQ_NUM_INT_PRI] = {{0}};
    cosq_cpu_port_info_t *cpu_port_info =
                                 LTSW_MMU_INFO(unit)->ltsw_cosq_cpu_port_info;
    cosq_port_info_t *port_info =
                             &LTSW_MMU_INFO(unit)->ltsw_cosq_port_info[local_port];
    int profile_idx;
    tm_ltsw_cosq_cos_map_profile_t profile;
    bcm_cos_queue_t hw_cosq = BCM_COS_INVALID, node_cosq = BCM_COS_INVALID;
    int ii;
    int num_ucq, num_mcq, numq;

    SHR_FUNC_ENTER(unit);

    if ((priority < 0) || (priority >= COSQ_NUM_INT_PRI)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if ((flags != BCM_COSQ_GPORT_UCAST_QUEUE_GROUP) &&
        (flags != BCM_COSQ_GPORT_MCAST_QUEUE_GROUP) &&
        (flags != BCM_COSQ_GPORT_ELEPHANT_UCAST_QUEUE_GROUP)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (gport) {
        *gport = BCM_GPORT_INVALID;
    }

    *cosq = BCM_COS_INVALID;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_get(unit, local_port, BCMI_PT_PORT_COS_QUEUE_MAP_ID,
                                &profile_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_cos_map_profile_get(unit, profile_idx * COSQ_NUM_INT_PRI,
                                          &cos_map_entries[0]));

    profile = cos_map_entries[priority];

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));

    switch (flags) {
        case BCM_COSQ_GPORT_UCAST_QUEUE_GROUP:
            hw_cosq = profile.uc_cos;

            if ((is_cpu_port(unit, local_port) == FALSE) && (gport)) {
                for (ii = 0; ii < num_ucq; ii++) {
                    node = &port_info->ucast[ii];
                    if (!node) {
                        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
                    }
                    node_cosq = (node->index % num_ucq);
                    if (node_cosq == hw_cosq) {
                        *gport = node->gport;
                        *cosq = hw_cosq;
                        break;
                    }
                }
            } else {
                *cosq = hw_cosq;
            }

            break;
        case BCM_COSQ_GPORT_MCAST_QUEUE_GROUP:
            if (is_cpu_port(unit, local_port)) {
                hw_cosq = profile.cpu_cos;
            } else {
                hw_cosq = profile.mc_cos;
            }

            if (gport) {
                if (is_cpu_port(unit, local_port)) {
                    numq = bcmi_ltsw_cosq_port_num_cos(unit, local_port);
                } else {
                    numq = num_mcq;
                }
                for (ii = 0; ii < numq; ii++) {
                    if (is_cpu_port(unit, local_port)) {
                        node = &cpu_port_info->mcast[ii];
                    } else {
                        node = &port_info->mcast[ii];
                    }
                    if (!node) {
                        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
                    }
                    node_cosq = node->index % numq;
                    if (node_cosq == hw_cosq) {
                        *gport = node->gport;
                        *cosq = hw_cosq;
                        break;
                    }
                }
            } else {
                *cosq = hw_cosq;
            }

            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (((gport &&
        (*gport == BCM_GPORT_INVALID) && (*cosq == BCM_COS_INVALID))) ||
        (*cosq == BCM_COS_INVALID)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief cosq cos mapping default config create.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_cos_map_default_config(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (tm_ltsw_cosq_cos_map_profile_init(unit, NUM_GP_QUEUES));

    SHR_IF_ERR_EXIT
        (tm_ltsw_cosq_ifp_cos_map_profile_init(unit));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Setup profile.
 *
 * \param [in]  unit             Unit number.
 * \param [in]  count            count.
 * \param [in]  priority_array   priority_array.
 * \param [in]  cosq_array       cosq_array.
 * \param [out] cos_map_entries  cos_map_entries.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 *
 * \note :
 *       Only support below mapping.
 *       When count = 64
 *       Prio Array Index Map
 *            Array Index [15-0]  : Maps Prio[15-0] to UC cos[15-0]
 *            Array Index [31-16] : Maps Prio[15-0] to MC cos[15-0]
 *            Array Index [47-32] : Maps Prio[15-0] to RQE cos[15-0]
 *            Array Index [63-48] : Maps Prio[15-0] to CPU cos[15-0]
 */
static int
cosq_ifp_cos_map_profile_fill(int unit,
                              int count,
                              bcm_cos_t *priority_array,
                              bcm_cos_queue_t *cosq_array,
                              tm_ltsw_cosq_cos_map_profile_t *cos_map_entries)
{
    int i;
    int ent_per_set = COSQ_NUM_INT_PRI;
    int num_ucq, num_mcq;
    bcmi_ltsw_cosq_device_info_t device_info = {0};

    SHR_FUNC_ENTER(unit);

    if (count != (ent_per_set * 4)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    if (NULL == priority_array || NULL == cosq_array) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));

    for (i = 0; i < count; i++) {
        if (priority_array[i] < ent_per_set) {
            if (i < ent_per_set) {
                if ((cosq_array[i] < 0) ||
                    (cosq_array[i] >= num_ucq)) {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }
                cos_map_entries[priority_array[i]].uc_cos = cosq_array[i];
            } else if (i < (ent_per_set * 2)) {
                if (num_mcq != 0) {
                    if ((cosq_array[i] < 0) ||
                        (cosq_array[i] >= num_mcq)) {
                        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                    }
                    cos_map_entries[priority_array[i]].mc_cos = cosq_array[i];
                } else {
                    cos_map_entries[priority_array[i]].mc_cos = -1;
                }
            } else if (i < (ent_per_set * 3)) {
                if (num_mcq != 0) {
                    if ((cosq_array[i] < 0) ||
                        (cosq_array[i] >= device_info.num_rqe_queue)) {
                        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                    }
                    cos_map_entries[priority_array[i]].rqe_cos = cosq_array[i];
                } else {
                    cos_map_entries[priority_array[i]].rqe_cos = -1;
                }
            } else {
                if ((cosq_array[i] < 0) ||
                    (cosq_array[i] >= device_info.num_cpu_queue)) {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }
                cos_map_entries[priority_array[i]].cpu_cos = cosq_array[i];
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Set the mapping from port, classifier, and multiple internal priorities
 *        to multiple COS queues in a queue group.
 *
 * \param [in]   unit                Unit number.
 * \param [in]   classifier_id       Classifier ID.
 * \param [in]   count               Number of elements in priority_array and cosq_array.
 * \param [in]   priority_array      Array of internal priorities.
 * \param [in]   cosq_array          Array of COS queues.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_field_classifier_map_set(int unit,
                              int classifier_id,
                              int count,
                              bcm_cos_t *priority_array,
                              bcm_cos_queue_t *cosq_array)
{
    int rv;
    int index, new_index;
    tm_ltsw_cosq_cos_map_profile_t cos_map_entries[COSQ_NUM_INT_PRI] = {{0}};
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_IFP_COS_MAP;
    uint32_t ref_count = 0;

    SHR_FUNC_ENTER(unit);

    /* Input parameter check. */
    if (!BCMINT_COSQ_CLASSIFIER_IS_FIELD(classifier_id)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    index = BCMINT_COSQ_CLASSIFIER_FIELD_GET(classifier_id);

    if (index == 0) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_ifp_cos_map_profile_fill(unit, count, priority_array,
                                       cosq_array, &cos_map_entries[0]));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_get(unit, profile_hdl,
                                         index * COSQ_NUM_INT_PRI, &ref_count));

    if (ref_count != 0) {
        rv = tm_ltsw_cosq_ifp_cos_map_profile_delete(unit, index * COSQ_NUM_INT_PRI);

        /*
         * If rv = SOC_E_NONE means that there exists a
         * mapping for given classifier_id which is now
         * successfully deleted and we can overwrite.
         * rv = SOC_E_NOT_FOUND means there was no mapping
         * for given classifier_id and we can create a new mapping
         * Otherwise there is something else wrong and we return
         * the error value returned by soc_profile_mem_delete()
         */
        if ((rv != SHR_E_NONE) && (rv != SHR_E_NOT_FOUND)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ifp_cos_map_profile_add(unit, cos_map_entries, &new_index));

    /*
     * If we get (index == new_index / max_entries) means we have
     * a successful mapping operation.
     * But if they are not equal which means there already exists
     * a similar mapping associated with other classifier_id hence
     * we return BCM_E_EXISTS.
     */
    new_index /= COSQ_NUM_INT_PRI;
    if (new_index != index) {
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_ifp_cos_map_profile_delete(unit, new_index * COSQ_NUM_INT_PRI));
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_EXISTS);
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Get internal priority to ingress field processor CoS queue
 *        override mapping information.
 *
 * \param [in]   unit                Unit number.
 * \param [in]   classifier_id       Classifier ID.
 * \param [in]   array_max           Size of priority_array and cosq_array.
 * \param [in]   priority_array      Array of internal priorities.
 * \param [out]  cosq_array          Array of COS queues.
 * \param [out]  array_count         Size of cosq_array.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 *
 * \note Only supported array_max = 64
 *       When count = 64
 *       Prio Array Index Map
 *            Array Index [15-0]  : Maps Prio[15-0] to UC cos[15-0]
 *            Array Index [31-16] : Maps Prio[15-0] to MC cos[15-0]
 *            Array Index [47-32] : Maps Prio[15-0] to RQE cos[15-0]
 *            Array Index [63-48] : Maps Prio[15-0] to CPU cos[15-0]
 */
static int
cosq_field_classifier_map_get(int unit,
                              int classifier_id,
                              int array_max,
                              bcm_cos_t *priority_array,
                              bcm_cos_queue_t *cosq_array,
                              int *array_count)
{
    int ent_per_set = COSQ_NUM_INT_PRI;
    int i, index;
    tm_ltsw_cosq_cos_map_profile_t cos_map_entries[COSQ_NUM_INT_PRI] = {{0}};

    SHR_FUNC_ENTER(unit);

    /* Input parameter check. */
    if (NULL == priority_array || NULL == cosq_array || NULL == array_count) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (array_max != (ent_per_set * 4)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Get profile table entry set base index. */
    index = BCMINT_COSQ_CLASSIFIER_FIELD_GET(classifier_id);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ifp_cos_map_profile_get(unit, index * COSQ_NUM_INT_PRI,
                                              &cos_map_entries[0]));

    *array_count = ent_per_set * 4;

    /* Copy values into API OUT parameters. */
    for (i = 0; i < *array_count; i++) {
        if (priority_array[i % COSQ_NUM_INT_PRI] >= COSQ_NUM_INT_PRI) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        if (i < ent_per_set) {
            cosq_array[i] = cos_map_entries[priority_array[i]].uc_cos;
        } else if (i < (ent_per_set * 2)) {
            cosq_array[i] = cos_map_entries[priority_array[i]].mc_cos;
        } else if (i < (ent_per_set * 3)) {
            cosq_array[i] = cos_map_entries[priority_array[i]].rqe_cos;
        } else {
            cosq_array[i] = cos_map_entries[priority_array[i]].cpu_cos;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Set the mapping from classifier
 *        to multiple COS queues in a queue group.
 *
 * \param [in]   unit                Unit number.
 * \param [in]   classifier_id       Classifier ID.
 * \param [in]   count               Number of elements in cosq_array.
 * \param [in]   priority_array      Array of internal priorities.
 * \param [in]   cosq_array          Array of COS queues.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_field_hi_classifier_map_set(int unit,
                                 int classifier_id,
                                 int count,
                                 bcm_cos_t *priority_array,
                                 bcm_cos_queue_t *cosq_array)
{
    int index;
    tm_ltsw_cosq_cos_map_profile_t cos_map_entries;
    int num_ucq, num_mcq;
    bcmi_ltsw_cosq_device_info_t device_info = {0};

    SHR_FUNC_ENTER(unit);

    if ((NULL == cosq_array) ||
        (priority_array != NULL) ||
        (count != 4)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Input parameter check. */
    if (!BCMINT_COSQ_CLASSIFIER_IS_FIELD_HI(classifier_id)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));

    if ((cosq_array[0] < 0) ||
        (cosq_array[0] >= num_ucq)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }
    if ((cosq_array[1] < 0) ||
        (cosq_array[1] >= num_mcq)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }
    if ((cosq_array[2] < 0) ||
        (cosq_array[2] >= device_info.num_rqe_queue)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }
    if ((cosq_array[3] < 0) ||
        (cosq_array[3] >= device_info.num_cpu_queue)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    cos_map_entries.uc_cos = cosq_array[0];
    cos_map_entries.mc_cos = cosq_array[1];
    cos_map_entries.rqe_cos = cosq_array[2];
    cos_map_entries.cpu_cos = cosq_array[3];

    index = BCMINT_COSQ_CLASSIFIER_FIELD_HI_GET(classifier_id);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ifp_cos_map_hi_profile_set(unit, index, &cos_map_entries));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Get ingress field processor CoS queue
 *        override mapping information.
 *
 * \param [in]   unit                Unit number.
 * \param [in]   classifier_id       Classifier ID.
 * \param [in]   array_max           Size of cosq_array.
 * \param [in]   priority_array      Array of internal priorities.
 * \param [out]  cosq_array          Array of COS queues.
 * \param [out]  array_count         Size of cosq_array.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 *
 * \note Only supported array_max = 4
 *       When count = 1
 *       Prio Array Index Map
 *            Array Index [0] : UC cos
 *            Array Index [1] : MC cos
 *            Array Index [2] : RQE cos
 *            Array Index [3] : CPU cos
 */
static int
cosq_field_hi_classifier_map_get(int unit,
                                 int classifier_id,
                                 int array_max,
                                 bcm_cos_t *priority_array,
                                 bcm_cos_queue_t *cosq_array,
                                 int *array_count)
{
    int index;
    tm_ltsw_cosq_cos_map_profile_t cos_map_entries;

    SHR_FUNC_ENTER(unit);

    /* Input parameter check. */
    if (NULL != priority_array || NULL == cosq_array || NULL == array_count) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    *array_count = 4;

    if (array_max != 4) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Get profile table entry set base index. */
    index = BCMINT_COSQ_CLASSIFIER_FIELD_HI_GET(classifier_id);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_ifp_cos_map_hi_profile_get(unit, index, &cos_map_entries));

    /* Copy values into API OUT parameters. */
    cosq_array[0] = cos_map_entries.uc_cos;
    cosq_array[1] = cos_map_entries.mc_cos;
    cosq_array[2] = cos_map_entries.rqe_cos;
    cosq_array[3] = cos_map_entries.cpu_cos;

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Return speed encoding given a speed in MB/S.
 *
 * \param [in]  speed        speed in MB/s.
 *
 * \retval SHE_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
port_asf_speed_encoding_get(int speed) {
    switch(speed) {
        case 10000:
            return PORT_SPEED_ID_10G;
        case 25000:
            return PORT_SPEED_ID_25G;
        case 40000:
            return PORT_SPEED_ID_40G;
        case 50000:
            return PORT_SPEED_ID_50G;
        case 100000:
        case 160000:
            return PORT_SPEED_ID_100G;
        case 200000:
            return PORT_SPEED_ID_200G;
        case 400000:
            return PORT_SPEED_ID_400G;
        default:
            return PORT_SPEED_ID_ERROR;
    }
}

/*
 * \brief Return speed encoding given a speed in MB/S.
 *
 * \param [in]  speed        speed in MB/s.
 *
 * \retval SHE_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
port_asf_speed_get (int speed_encode) {
    switch(speed_encode) {
        case PORT_SPEED_ID_10G:
            return 10000;
        case PORT_SPEED_ID_25G:
            return 25000;
        case PORT_SPEED_ID_40G:
            return 40000;
        case PORT_SPEED_ID_50G:
            return 50000;
        case PORT_SPEED_ID_100G:
            return 100000;
        case PORT_SPEED_ID_200G:
            return 200000;
        case PORT_SPEED_ID_400G:
            return 400000;
        default:
            return -1;
    }
}

/*
 * \brief Get the max and min src speed (encoding) given a dst port speed.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  port_speed    dst port speed.
 * \param [in]  mode          forwarding mode.
 * \param [out] min_sp        min src speed encoding.
 * \param [out] max_sp        max src speed encoding.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
port_asf_speed_limits_get(
    int unit,
    int port_speed,
    int max_speed,
    int mode,
    int *min_sp,
    int *max_sp)
{
    if(TM_LTSW_ASF_MODE_SAF != mode) {
        *min_sp = port_asf_speed_encoding_get(port_speed);
        *max_sp = port_asf_speed_encoding_get(max_speed);
        PORT_ASF_SPEED_CLASS_VALIDATE(*min_sp);
        PORT_ASF_SPEED_CLASS_VALIDATE(*max_sp);
    } else {
        *min_sp = -1;
        *max_sp = -1;
    }

    return SHR_E_NONE;
}

/*
 * \brief cosq strength profile init.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_strength_profile_init(int unit)
{
    tm_ltsw_cosq_strength_profile_t profile = {0};
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    if (warm) {
        SHR_EXIT();
    }

    profile.strength_profile_id = TM_UNICAST_VIEW_PROFILE_ID;
    profile.uc_cos_strength = PORT_UC_COS_STRENGTH;
    profile.mc_cos_strength = PORT_MC_COS_STRENGTH;
    profile.rqe_cos_strength = PORT_RQE_COS_STRENGTH;
    profile.cpu_cos_strength = PORT_CPU_COS_STRENGTH;
    SHR_IF_ERR_EXIT
        (tm_ltsw_port_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_UNICAST_VIEW_PROFILE_ID;
    profile.uc_cos_strength = IFP_UC_COS_STRENGTH;
    profile.mc_cos_strength = IFP_MC_COS_STRENGTH;
    profile.rqe_cos_strength = IFP_RQE_COS_STRENGTH;
    profile.cpu_cos_strength = IFP_CPU_COS_STRENGTH;
    SHR_IF_ERR_EXIT
        (tm_ltsw_ifp_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_UNICAST_VIEW_PROFILE_ID;
    profile.uc_cos_strength = DEST_UC_COS_STRENGTH;
    profile.mc_cos_strength = DEST_MC_COS_STRENGTH;
    profile.rqe_cos_strength = DEST_RQE_COS_STRENGTH;
    profile.cpu_cos_strength = DEST_CPU_COS_STRENGTH;
    SHR_IF_ERR_EXIT
        (tm_ltsw_destination_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_UNICAST_VIEW_PROFILE_ID;
    profile.rqe_cos_strength = CPU_RQE_COS_STRENGTH;
    profile.cpu_cos_strength = CPU_COS_STRENGTH;
    SHR_IF_ERR_EXIT
        (tm_ltsw_cpu_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_NON_UNICAST_VIEW_PROFILE_ID;
    profile.uc_cos_strength = PORT_UC_COS_STRENGTH1;
    profile.mc_cos_strength = PORT_MC_COS_STRENGTH1;
    profile.rqe_cos_strength = PORT_RQE_COS_STRENGTH1;
    profile.cpu_cos_strength = PORT_CPU_COS_STRENGTH1;
    SHR_IF_ERR_EXIT
        (tm_ltsw_port_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_NON_UNICAST_VIEW_PROFILE_ID;
    profile.uc_cos_strength = IFP_UC_COS_STRENGTH1;
    profile.mc_cos_strength = IFP_MC_COS_STRENGTH1;
    profile.rqe_cos_strength = IFP_RQE_COS_STRENGTH1;
    profile.cpu_cos_strength = IFP_CPU_COS_STRENGTH1;
    SHR_IF_ERR_EXIT
        (tm_ltsw_ifp_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_NON_UNICAST_VIEW_PROFILE_ID;
    profile.uc_cos_strength = DEST_UC_COS_STRENGTH1;
    profile.mc_cos_strength = DEST_MC_COS_STRENGTH1;
    profile.rqe_cos_strength = DEST_RQE_COS_STRENGTH1;
    profile.cpu_cos_strength = DEST_CPU_COS_STRENGTH1;
    SHR_IF_ERR_EXIT
        (tm_ltsw_destination_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_NON_UNICAST_VIEW_PROFILE_ID;
    profile.rqe_cos_strength = CPU_RQE_COS_STRENGTH1;
    profile.cpu_cos_strength = CPU_COS_STRENGTH1;
    SHR_IF_ERR_EXIT
        (tm_ltsw_cpu_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_IFP_VIEW_PROFILE_ID;
    profile.uc_cos_strength = PORT_UC_COS_STRENGTH2;
    profile.mc_cos_strength = PORT_MC_COS_STRENGTH2;
    profile.rqe_cos_strength = PORT_RQE_COS_STRENGTH2;
    profile.cpu_cos_strength = PORT_CPU_COS_STRENGTH2;
    SHR_IF_ERR_EXIT
        (tm_ltsw_port_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_IFP_VIEW_PROFILE_ID;
    profile.uc_cos_strength = IFP_UC_COS_STRENGTH2;
    profile.mc_cos_strength = IFP_MC_COS_STRENGTH2;
    profile.rqe_cos_strength = IFP_RQE_COS_STRENGTH2;
    profile.cpu_cos_strength = IFP_CPU_COS_STRENGTH2;
    SHR_IF_ERR_EXIT
        (tm_ltsw_ifp_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_IFP_VIEW_PROFILE_ID;
    profile.uc_cos_strength = DEST_UC_COS_STRENGTH2;
    profile.mc_cos_strength = DEST_MC_COS_STRENGTH2;
    profile.rqe_cos_strength = DEST_RQE_COS_STRENGTH2;
    profile.cpu_cos_strength = DEST_CPU_COS_STRENGTH2;
    SHR_IF_ERR_EXIT
        (tm_ltsw_destination_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_IFP_VIEW_PROFILE_ID;
    profile.rqe_cos_strength = CPU_RQE_COS_STRENGTH2;
    profile.cpu_cos_strength = CPU_COS_STRENGTH2;
    SHR_IF_ERR_EXIT
        (tm_ltsw_cpu_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_DST_FP_VIEW_PROFILE_ID;
    profile.uc_cos_strength = PORT_UC_COS_STRENGTH3;
    profile.mc_cos_strength = PORT_MC_COS_STRENGTH3;
    profile.rqe_cos_strength = PORT_RQE_COS_STRENGTH3;
    profile.cpu_cos_strength = PORT_CPU_COS_STRENGTH3;
    SHR_IF_ERR_EXIT
        (tm_ltsw_port_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_DST_FP_VIEW_PROFILE_ID;
    profile.uc_cos_strength = IFP_UC_COS_STRENGTH3;
    profile.mc_cos_strength = IFP_MC_COS_STRENGTH3;
    profile.rqe_cos_strength = IFP_RQE_COS_STRENGTH3;
    profile.cpu_cos_strength = IFP_CPU_COS_STRENGTH3;
    SHR_IF_ERR_EXIT
        (tm_ltsw_ifp_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_DST_FP_VIEW_PROFILE_ID;
    profile.uc_cos_strength = DEST_UC_COS_STRENGTH3;
    profile.mc_cos_strength = DEST_MC_COS_STRENGTH3;
    profile.rqe_cos_strength = DEST_RQE_COS_STRENGTH3;
    profile.cpu_cos_strength = DEST_CPU_COS_STRENGTH3;
    SHR_IF_ERR_EXIT
        (tm_ltsw_destination_cosq_strength_profile_init(unit, &profile));

    profile.strength_profile_id = TM_DST_FP_VIEW_PROFILE_ID;
    profile.rqe_cos_strength = CPU_RQE_COS_STRENGTH3;
    profile.cpu_cos_strength = CPU_COS_STRENGTH3;
    SHR_IF_ERR_EXIT
        (tm_ltsw_cpu_cosq_strength_profile_init(unit, &profile));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief tm queue assignment profile init.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_queue_assignment_profile_init(int unit)
{
    tm_ltsw_q_assignment_profile_t profile = {0};
    bcmint_cosq_assignment_info_t info = {0};
    int i, size;
    const bcmint_cosq_str_map_t *info_id_map = NULL;
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    if (warm) {
        SHR_EXIT();
    }

    info_id_map = COSQ_MAP_STR_INFO(unit, BCMINT_TM_Q_ASSIGNMENT_INFO_ID_T);
    if (info_id_map == NULL) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    size = COSQ_MAP_STR_NUM(unit, BCMINT_TM_Q_ASSIGNMENT_INFO_ID_T);

    for (i = 0; i < size; i++) {
        SHR_IF_ERR_EXIT
            (mbcm_ltsw_cosq_queue_assignment_info_get(
                unit, info_id_map[i].str, &info));

        profile.tm_q_assignment_profile_id = info.tm_q_assignment_profile_id[0];
        profile.port_cos_q_strength_profile_id = info_id_map[i].profile_id;
        profile.fp_ing_cos_q_strength_profile_id = info_id_map[i].profile_id;
        profile.base_fp_ing_cos_q_map_id = info_id_map[i].base_index;
        profile.tm_cos_q_cpu_strength_profile_id = info_id_map[i].profile_id;
        profile.fp_destination_cos_q_strength_profile_id = info_id_map[i].profile_id;
        profile.mc_cos_mirror = info_id_map[i].mc_cos_mirror;

        SHR_IF_ERR_EXIT
            (tm_ltsw_queue_assignment_profile_init(unit, &profile));
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief cosq mc_cos_mirror set.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  enable        enable.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_mc_cos_mirror_set(int unit, int enable)
{
    tm_ltsw_q_assignment_profile_t profile = {0};
    bcmint_cosq_assignment_info_t info = {0};
    int i, size;
    const bcmint_cosq_str_map_t *info_id_map = NULL;

    SHR_FUNC_ENTER(unit);


    info_id_map = COSQ_MAP_STR_INFO(unit, BCMINT_TM_Q_ASSIGNMENT_INFO_ID_T);
    if (info_id_map == NULL) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    size = COSQ_MAP_STR_NUM(unit, BCMINT_TM_Q_ASSIGNMENT_INFO_ID_T);

    for (i = 0; i < size; i++) {
        SHR_IF_ERR_EXIT
            (mbcm_ltsw_cosq_queue_assignment_info_get(
                unit, info_id_map[i].str, &info));
        if (info_id_map[i].mc_cos_mirror) {
            profile.tm_q_assignment_profile_id = info.tm_q_assignment_profile_id[0];
            profile.mc_cos_mirror = enable;

            SHR_IF_ERR_EXIT
                (tm_ltsw_mc_cos_mirror_set(unit, &profile));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief cosq mc_cos_mirror get.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  enable        enable.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_mc_cos_mirror_get(int unit, int *enable)
{
    tm_ltsw_q_assignment_profile_t profile = {0};
    bcmint_cosq_assignment_info_t info = {0};
    int i, size;
    const bcmint_cosq_str_map_t *info_id_map = NULL;

    SHR_FUNC_ENTER(unit);


    info_id_map = COSQ_MAP_STR_INFO(unit, BCMINT_TM_Q_ASSIGNMENT_INFO_ID_T);
    if (info_id_map == NULL) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    size = COSQ_MAP_STR_NUM(unit, BCMINT_TM_Q_ASSIGNMENT_INFO_ID_T);

    *enable = 0;

    for (i = 0; i < size; i++) {
        SHR_IF_ERR_EXIT
            (mbcm_ltsw_cosq_queue_assignment_info_get(
                unit, info_id_map[i].str, &info));
        if (info_id_map[i].mc_cos_mirror) {
            profile.tm_q_assignment_profile_id = info.tm_q_assignment_profile_id[0];

            SHR_IF_ERR_EXIT
                (tm_ltsw_mc_cos_mirror_get(unit, &profile));

            *enable = profile.mc_cos_mirror;
            break;
        }
    }

exit:
    SHR_FUNC_EXIT();
}


static int
bcm56780_a0_ltsw_cosq_init(int unit)
{
    static tm_ltsw_cosq_chip_driver_t bcm56780_a0_cosq_drv_cb = {
        .cosq_sched_node_type_get = cosq_sched_node_type_get,
        .cosq_sched_mode_get = cosq_sched_mode_get,
        .cosq_wred_percent_to_drop_prob = cosq_wred_percent_to_drop_prob,
        .cosq_wred_drop_prob_to_percent = cosq_wred_drop_prob_to_percent,
        .cosq_wred_us_to_time_domain = cosq_wred_us_to_time_domain,
        .cosq_wred_time_domain_to_us = cosq_wred_time_domain_to_us,
        .port_ct_mode_to_class = port_ct_mode_to_class,
    };
    cosq_ctrl_t *cosqc = &cosq_ctrl[unit];

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (tm_ltsw_cosq_chip_driver_register(unit, &bcm56780_a0_cosq_drv_cb));

    SHR_IF_ERR_EXIT
        (tm_ltsw_cosq_hierarchy_init(unit));

    SHR_IF_ERR_EXIT
        (tm_ltsw_cosq_init(unit));

    SHR_IF_ERR_EXIT
        (cosq_mmu_info_create(unit));

    SHR_IF_ERR_EXIT
        (cosq_gport_default_config(unit));

    SHR_IF_ERR_EXIT
        (cosq_wred_default_config(unit));

    SHR_IF_ERR_EXIT
        (cosq_cos_map_default_config(unit));

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_cosq_map_db_init(unit, &cosqc->cosq_db));

    SHR_IF_ERR_EXIT
        (cosq_strength_profile_init(unit));

    SHR_IF_ERR_EXIT
        (cosq_queue_assignment_profile_init(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    cosq_mmu_info_destroy(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_detach(unit));

    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_ifp_cos_map_hi_clear(unit));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_chip_driver_deregister(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_gport_port_resolve(
    int unit,
    bcm_gport_t gport,
    bcm_gport_t *port,
    int *id)
{
    bcm_port_t port_out;
    int encap_id;
    int num_ucq, num_mcq;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        port_out = BCM_GPORT_UCAST_QUEUE_GROUP_SYSPORTID_GET(gport);
        encap_id = BCM_GPORT_UCAST_QUEUE_GROUP_QID_GET(gport);
        if (encap_id >= num_ucq) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
        }
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        port_out = BCM_GPORT_MCAST_QUEUE_GROUP_SYSPORTID_GET(gport);
        encap_id = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
        if ((!is_cpu_port(unit, port_out) &&
            (encap_id >= num_mcq)) ||
            (is_cpu_port(unit, port_out) &&
            (encap_id >= NUM_CPU_MCAST_QUEUE))) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
        }
    } else if (BCM_GPORT_IS_SCHEDULER(gport)) {
        port_out = BCM_GPORT_SCHEDULER_GET(gport) & 0xff;
        encap_id = (BCM_GPORT_SCHEDULER_GET(gport) >> 16) & 0x3ff;
        if (encap_id >= NUM_GP_QUEUES) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port_out, &port_out));

    if (port != NULL) {
        *port = port_out;
    }

    if (id != NULL) {
        *id = encap_id;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_itm_validate(
    int unit,
    int port,
    int *itm)
{
    SHR_FUNC_ENTER(unit);

    if ((*itm >= 1) || ((*itm < 0) && (*itm != BCM_COSQ_BUFFER_ID_INVALID))) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    /* Only one ITM available. */
    if (*itm == BCM_COSQ_BUFFER_ID_INVALID) {
        *itm = 0;
    }
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_sw_dump(int unit)
{
    int ii;

    LOG_CLI((BSL_META_U(unit,
                        "\nSW Information COSQ - Unit %d\n"), unit));

    (void)cosq_cpu_port_info_dump(unit);

    (void)cosq_port_info_dump(unit);

    (void)tm_ltsw_cosq_time_domain_dump(unit);

    for (ii = 0; ii < COSQ_NUM_WRED_RESOLUTION_TABLE; ii++) {
        LOG_CLI((BSL_META_U(unit,
                            "\nWRED_RESOLUTION[%d] - refcnt %d\n"), ii,
                            cosq_wred_resolution_tbl[unit][ii]));
    }

    LOG_CLI((BSL_META_U(unit,
                        "=========== \n")));

    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_cosq_bucket_set(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    uint32_t min_quantum,
    uint32_t max_quantum,
    bool burst_size_auto,
    uint32_t kbits_burst_min,
    uint32_t kbits_burst_max,
    uint32_t flags)
{
    bcm_port_t local_port;
    int sched_mode;
    cosq_node_t *node = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_resolve(unit, gport, cosq, &node, &local_port));

    sched_mode = (flags & BCM_COSQ_BW_PACKET_MODE) ? 1 : 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_shaper_node_set(unit, local_port, node->index,
                                      node->level, sched_mode, min_quantum,
                                      max_quantum, burst_size_auto,
                                      kbits_burst_min, kbits_burst_max));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_bucket_get(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    uint32_t *min_quantum,
    uint32_t *max_quantum,
    bool burst_size_auto,
    uint32_t *kbits_burst_min,
    uint32_t *kbits_burst_max,
    uint32_t *flags)
{
    bcm_port_t local_port;
    int sched_mode;
    int rv;
    uint32_t min_bandwidth, max_bandwidth, min_burst, max_burst;
    cosq_node_t *node = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_resolve(unit, gport, cosq, &node, &local_port));

    rv = tm_ltsw_cosq_shaper_node_get(unit, local_port, node->index,
                                      node->level, &sched_mode,
                                      &min_bandwidth, &max_bandwidth,
                                      burst_size_auto, &min_burst,
                                      &max_burst);

    if (rv == SHR_E_NOT_FOUND) {
        sched_mode = 0;
        min_bandwidth = 0;
        max_bandwidth = 0;
        min_burst = 0;
        max_burst = 0;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (min_quantum != NULL) {
        *min_quantum = min_bandwidth;
    }

    if (max_quantum != NULL) {
        *max_quantum = max_bandwidth;
    }

    if (kbits_burst_min != NULL) {
        *kbits_burst_min = min_burst;
    }

    if (kbits_burst_max != NULL) {
        *kbits_burst_max = max_burst;
    }

    if (flags != NULL) {
        *flags = (sched_mode == 1) ? BCM_COSQ_BW_PACKET_MODE : 0;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_detach(
    int unit,
    bcm_port_t port)
{
    cosq_port_info_t *port_info;
    int old_index = 0;

    SHR_FUNC_ENTER(unit);

    if (is_cpu_port(unit, port) || is_lb_port(unit, port) ||
        is_mgmt_port(unit, port)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    LOG_INFO(BSL_LOG_MODULE,
             (BSL_META_U(unit,
              "bcmi_ltsw_cosq_port_detach port %d\n"), port));

    /*
     * When update guarantee of PG/UC/MC via API, the shared limit is adjusted
     * accordingly. So MUST reset the gurarntee to the default value before
     * deleting the port to recover the shared limit.
     */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_thd_port_guarantee_reset(unit, port));

    /* Decrease the reference of COS_MAP_PROFILE */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_get(unit, port, BCMI_PT_PORT_COS_QUEUE_MAP_ID,
                                &old_index));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_cos_map_profile_delete(unit, old_index * COSQ_NUM_INT_PRI));

    /* Destroy cosq gport tree on port */
    port_info = &LTSW_MMU_INFO(unit)->ltsw_cosq_port_info[port];

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_port_tree_destroy(unit, port, port_info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_attach(
    int unit,
    bcm_port_t port)
{
    cosq_port_info_t *port_info;
    int default_mode = BCM_COSQ_WEIGHTED_ROUND_ROBIN, default_weight = 1;
    int i, num_ucq, num_mcq;

    SHR_FUNC_ENTER(unit);

    if (is_cpu_port(unit, port) || is_lb_port(unit, port) ||
        is_mgmt_port(unit, port)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    LOG_INFO(BSL_LOG_MODULE,
             (BSL_META_U(unit,
              "bcmi_ltsw_cosq_port_attach port %d\n"), port));

    port_info = &LTSW_MMU_INFO(unit)->ltsw_cosq_port_info[port];

    /* Increase the reference of default COS_MAP_PROFILE */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit, port, BCMI_PT_PORT_COS_QUEUE_MAP_ID, 0));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_increase(unit, BCMI_LTSW_PROFILE_COS_MAP,
                                              COSQ_NUM_INT_PRI, 0, 1));

    /* set scheduler profile 0 to port */
    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_port_scheduler_profile_set(unit, port, 0));

    /* Create gport tree */
    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_port_tree_create(unit, port, port_info));

    /* Set Default Scheduler Configuration on the ports */
    for (i = 0; i < NUM_GP_QUEUES; i++) {
        if (port_info->sched[i].in_use == 0 || port_info->sched[i].numq == 0) {
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_cosq_gport_sched_set(unit, port_info->sched[i].gport,
                -1, default_mode, default_weight));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));

    for (i = 0; i < num_ucq; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_cosq_gport_sched_set(unit, port_info->ucast[i].gport,
                -1, default_mode, default_weight));
    }

    for (i = 0; i < num_mcq; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_cosq_gport_sched_set(unit, port_info->mcast[i].gport,
                -1, default_mode, default_weight));
    }

    /* Set MMU threshold and scheduler profiles to profile 0
     * Customer can change the profile after flexport sequence is done */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_cosq_port_profile_set(unit, port,
                       bcmCosqProfilePGProperties, 0));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_cosq_port_profile_set(unit, port,
                       bcmCosqProfileIntPriToPGMap, 0));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_cosq_port_profile_set(unit, port,
                       bcmCosqProfilePFCAndQueueHierarchy, 0));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_mc_cos_mirror_set(
    int unit,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mc_cos_mirror_set(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_mc_cos_mirror_get(
    int unit,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_mc_cos_mirror_get(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_sched_node_child_get(
    int unit,
    bcm_gport_t sched_gport,
    int *num_uc_child,
    int *uc_queue,
    int *num_mc_child,
    int *mc_queue)
{
    cosq_cpu_port_info_t *cpu_port_info;
    cosq_port_info_t *port_info;
    int local_port, id;
    int num_mc, num_uc;
    int num_ucq, num_mcq;

    SHR_FUNC_ENTER(unit);

    if (!BCM_GPORT_IS_SCHEDULER(sched_gport)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if ((num_uc_child == NULL) || (uc_queue == NULL) ||
        (num_mc_child == NULL) || (mc_queue == NULL)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_cosq_localport_resolve(unit, sched_gport, &local_port));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));

    if (!is_cpu_port(unit, local_port)) {
        port_info = &LTSW_MMU_INFO(unit)->ltsw_cosq_port_info[local_port];
        num_uc = 0;
        num_mc = 0;
        for (id = 0; id < num_ucq; id++) {
            if (port_info->ucast[id].numq == 0) {
                continue;
            }
            if (port_info->ucast[id].parent_gport == sched_gport) {
                uc_queue[num_uc] = port_info->ucast[id].index;
                num_uc++;
            }
        }
        for (id = 0; id < num_mcq; id++) {
            if (port_info->mcast[id].numq == 0) {
                continue;
            }
            if (port_info->mcast[id].parent_gport == sched_gport) {
                    mc_queue[num_mc] = port_info->mcast[id].index;
                num_mc++;
            }
        }
    } else {
        /* CPU port */
        num_uc = -1;
        num_mc = 0;
        cpu_port_info = LTSW_MMU_INFO(unit)->ltsw_cosq_cpu_port_info;
        for (id = 0; id < NUM_CPU_MCAST_QUEUE; id++) {
            if (cpu_port_info->mcast[id].numq == 0) {
                continue;
            }
            if (cpu_port_info->mcast[id].parent_gport == sched_gport) {
                mc_queue[num_mc] = cpu_port_info->mcast[id].index;
                num_mc++;
            }
        }
    }

    *num_mc_child = num_mc;
    *num_uc_child = num_uc;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_gport_get(
    int unit,
    bcm_gport_t gport,
    bcm_gport_t *port,
    int *numq,
    uint32_t *flags)
{
    cosq_node_t *node = NULL;
    int modid, trunk_id, id;
    bcm_port_t local_port;

    SHR_FUNC_ENTER(unit);

    if (port == NULL || numq == NULL || flags == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if ((BCM_GPORT_IS_SCHEDULER(gport)) ||
         BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) ||
         BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_gport_node_get(unit, gport, &node));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_cosq_gport_port_resolve(unit, gport, &local_port, NULL));

        *numq = node->numq;
        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
            *flags = BCM_COSQ_GPORT_UCAST_QUEUE_GROUP;
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
            *flags = BCM_COSQ_GPORT_MCAST_QUEUE_GROUP;
        } else if (BCM_GPORT_IS_SCHEDULER(gport)) {
            *flags = BCM_COSQ_GPORT_SCHEDULER;
        } else {
            *flags = 0;
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_resolve(unit, gport, &modid, &local_port,
                                          &trunk_id, &id));
        *flags = 0;
        *numq = NUM_GP_QUEUES;
    }

    *port = local_port;

    LOG_INFO(BSL_LOG_MODULE,
        (BSL_META_U(unit,
        "port=0x%x numq=%d flags=0x%x\n"),
        *port, *numq, *flags));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_gport_child_get(
    int unit,
    bcm_gport_t in_gport,
    bcm_cos_queue_t cosq,
    bcm_gport_t *out_gport)
{
    cosq_node_t *tmp_node = NULL;
    bcm_port_t local_port = -1;
    cosq_cpu_port_info_t *cpu_port_info = NULL;
    cosq_port_info_t *port_info = NULL;
    int index = -1;
    int num_ucq, num_mcq;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(out_gport, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_localport_resolve(unit, in_gport, &local_port));

    if (is_cpu_port(unit, local_port)) {
        if ((cosq < 0) ||
            (cosq >= bcmi_ltsw_cosq_port_num_cos(unit, local_port))) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        cpu_port_info = LTSW_MMU_INFO(unit)->ltsw_cosq_cpu_port_info;

        SHR_NULL_CHECK(cpu_port_info, SHR_E_INIT);

        if (BCM_GPORT_IS_SCHEDULER(in_gport)) {
            for (index = 0; index < NUM_CPU_MCAST_QUEUE; index++) {
                if (cpu_port_info->mcast[index].parent_gport == in_gport) {
                    if (cosq == cpu_port_info->mcast[index].index) {
                        tmp_node = &cpu_port_info->mcast[index];
                        *out_gport = tmp_node->gport;
                        SHR_EXIT();
                    }
                }
            }
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        if (!tmp_node) {
            SHR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
        }
    } else { /* Non-CPU port */
        port_info = &LTSW_MMU_INFO(unit)->ltsw_cosq_port_info[local_port];
        SHR_NULL_CHECK(port_info, SHR_E_INIT);

        if ((cosq < 0) || (cosq >= NUM_GP_QUEUES)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));

        if (BCM_GPORT_IS_SCHEDULER(in_gport)) {
            for (index = 0; index < num_ucq; index++) {
                if (port_info->ucast[index].parent_gport == in_gport) {
                    if (cosq == port_info->ucast[index].cos) {
                        tmp_node = &port_info->ucast[index];
                        *out_gport = tmp_node->gport;
                        SHR_EXIT();
                    }
                }
            }

            for (index = 0; index < num_mcq; index++) {
                if (port_info->mcast[index].parent_gport == in_gport) {
                    if (cosq == port_info->mcast[index].cos) {
                        tmp_node = &port_info->mcast[index];
                        *out_gport = tmp_node->gport;
                        SHR_EXIT();
                    }
                }
            }
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        if (!tmp_node) {
            SHR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_gport_attach(
    int unit,
    bcm_gport_t input_gport,
    bcm_gport_t parent_gport,
    bcm_cos_queue_t cosq)
{
    cosq_node_t *input_node = NULL;
    cosq_node_t *parent_node = NULL;
    int channel_id = 0;

    SHR_FUNC_ENTER(unit);

    LOG_INFO(BSL_LOG_MODULE,
        (BSL_META_U(unit,
        "bcm_ltsw_cosq_gport_attach: unit=%d parent_gport=0x%x "
        "input_gport=0x%x cosq=%d\n"),
        unit, parent_gport, input_gport, cosq));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_attach_params_validate(unit, input_gport, parent_gport));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_node_get(unit, input_gport, &input_node));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_node_get(unit, parent_gport, &parent_node));

    /* Return SHR_E_EXISTS when queue to be attached is
       already attached to the given gport */
    if ((LTSW_MMU_INFO(unit)->gport_tree_created == TRUE) &&
        (input_node->parent_gport == parent_gport)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_EXISTS);
    }

    if ((cosq != -1) && (input_node->index != cosq)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_cpu_parent_set(unit, input_node->index,
                                     LTSW_COSQ_NODE_LVL_MC,
                                     parent_node->index));

    if ((parent_node->cos >= 0) && (parent_node->cos < 7)) {
        /*
         * L0.0 is associated with CMC0 CH1(Rx) (pci)
         * L0.1 is associated with CMC0 CH2(Rx) (pci)
         * L0.2 is associated with CMC0 CH3(Rx) (pci)
         * L0.3 is associated with CMC0 CH4(Rx) (pci)
         * L0.4 is associated with CMC0 CH5(Rx) (pci)
         * L0.5 is associated with CMC0 CH6(Rx) (pci)
         * L0.6 is associated with CMC0 CH7(Rx) (pci)
         * L0.11 is reserved
         */
        channel_id = parent_node->cos +1;

        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_rx_queue_channel_set(unit, input_node->index,
                                               channel_id, TRUE));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_cpu_node_parent_update(unit, &input_node, &parent_node));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_gport_detach(
    int unit,
    bcm_gport_t input_gport,
    bcm_gport_t parent_gport,
    bcm_cos_queue_t cosq)
{
    cosq_node_t *input_node = NULL;
    cosq_node_t *parent_node = NULL;
    cosq_node_t *new_parent_node = NULL;
    int sched_num, parent_index, channel_id = 0;

    SHR_FUNC_ENTER(unit);

    LOG_INFO(BSL_LOG_MODULE,
             (BSL_META_U(unit,
                         "bcm_ltsw_cosq_gport_detach: unit=%d input_gport=0x%x "
                         "parent_gport=0x%x cosq=%d\n"),
              unit, input_gport, parent_gport, cosq));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_attach_params_validate(unit, input_gport, parent_gport));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_node_get(unit, input_gport, &input_node));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_node_get(unit, parent_gport, &parent_node));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_cpu_parent_get(unit, input_node->index,
                                     LTSW_COSQ_NODE_LVL_MC,
                                     &parent_index));
    /* Return SHR_E_PARAM when queue to be detached is
       not attached to the given gport */
    if ((input_node->parent_gport != parent_gport) ||
        (parent_index != parent_node->index)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Reset parent to L0.11 */
    sched_num = NUM_GP_QUEUES;
    new_parent_node = &(LTSW_MMU_INFO(unit)->ltsw_cosq_cpu_port_info->
                        sched[(sched_num - 1)]);

    if ((parent_node->cos >= 0) && (parent_node->cos < 7)) {
        /*
         * L0.0 is associated with CMC0 CH1(Rx) (pci)
         * L0.1 is associated with CMC0 CH2(Rx) (pci)
         * L0.2 is associated with CMC0 CH3(Rx) (pci)
         * L0.3 is associated with CMC0 CH4(Rx) (pci)
         * L0.4 is associated with CMC0 CH5(Rx) (pci)
         * L0.5 is associated with CMC0 CH6(Rx) (pci)
         * L0.6 is associated with CMC0 CH7(Rx) (pci)
         * L0.11 is reserved
         */
        channel_id = parent_node->cos +1;

        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_rx_queue_channel_set(unit, input_node->index,
                                               channel_id, FALSE));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_cpu_parent_set(unit, input_node->index,
                                     LTSW_COSQ_NODE_LVL_MC,
                                     new_parent_node->index));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_cpu_node_parent_update(unit, &input_node, &new_parent_node));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_gport_attach_get(
    int unit,
    bcm_gport_t sched_gport,
    bcm_gport_t *input_gport,
    bcm_cos_queue_t *cosq)
{
    cosq_node_t *node = NULL;
    int local_port;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(input_gport, SHR_E_PARAM);
    SHR_NULL_CHECK(cosq, SHR_E_PARAM);

    if (sched_gport == BCM_GPORT_INVALID) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
    }

    if (!(BCM_GPORT_IS_SET(sched_gport) ||
          BCM_GPORT_IS_SCHEDULER(sched_gport) ||
          BCM_GPORT_IS_UCAST_QUEUE_GROUP(sched_gport) ||
          BCM_GPORT_IS_MCAST_QUEUE_GROUP(sched_gport))) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_node_get(unit, sched_gport, &node));
    if (node == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_localport_resolve(unit, sched_gport, &local_port));

    if (is_cpu_port(unit, local_port)) {
        *cosq = node->index;
    } else {
        *cosq = node->cos;
    }
    *input_gport = node->parent_gport;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_gport_traverse(
    int unit,
    bcm_cosq_gport_traverse_cb cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    if (LTSW_MMU_INFO(unit)->gport_tree_created == FALSE) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_EXISTS);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_traverse(unit, cb, user_data));

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_cpu_traverse(unit, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_sched_weight_max_get(
    int unit,
    int mode,
    int *weight_max)
{
    SHR_FUNC_ENTER(unit);

    switch (mode) {
        case BCM_COSQ_STRICT:
            *weight_max = BCM_COSQ_WEIGHT_STRICT;
            break;
        case BCM_COSQ_ROUND_ROBIN:
        case BCM_COSQ_WEIGHTED_ROUND_ROBIN:
        case BCM_COSQ_DEFICIT_ROUND_ROBIN:
            *weight_max = QSCHED_MAX_WEIGHT;
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_schedq_mapping_set(
    int unit,
    int profile_index,
    int size,
    bcm_cosq_mapping_t *cosq_mapping_arr)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_schedq_mapping_set(unit, profile_index, size,
                                         cosq_mapping_arr));

    LTSW_MMU_INFO(unit)->gport_tree_created = FALSE;

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_tree_create(unit));

    LTSW_MMU_INFO(unit)->gport_tree_created = TRUE;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_schedq_mapping_get(
    int unit,
    int profile_index,
    int array_max,
    bcm_cosq_mapping_t *cosq_mapping_arr,
    int *size)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_schedq_mapping_get(unit, profile_index, array_max,
                                         cosq_mapping_arr, size));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_scheduler_profile_set(
    int unit,
    bcm_port_t port,
    int profile_id)
{
    cosq_port_info_t *port_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_port_scheduler_profile_set(unit, port, profile_id));

    port_info = &LTSW_MMU_INFO(unit)->ltsw_cosq_port_info[port];

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_gport_port_tree_create(unit, port, port_info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_scheduler_profile_get(
    int unit,
    bcm_port_t port,
    int *profile_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_port_scheduler_profile_get(unit, port, profile_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_sched_set(
    int unit,
    bcm_port_t gport,
    bcm_cos_queue_t cosq,
    int mode,
    int weight)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_sched_set(unit, gport, cosq, mode, weight));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_sched_get(
    int unit,
    bcm_port_t gport,
    bcm_cos_queue_t cosq,
    int *mode,
    int *weight)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_sched_get(unit, gport, cosq, mode, weight));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_cosq_profile_max_num_get(
    int unit,
    bcm_cosq_profile_type_t profile_type,
    int *max_num)
{
    SHR_FUNC_ENTER(unit);

    switch (profile_type) {
        case bcmCosqProfilePFCAndQueueHierarchy:
            *max_num = MAX_NUM_SCHED_PROFILE;

            break;
        case bcmCosqProfilePGProperties:
        case bcmCosqProfileIntPriToPGMap:
            *max_num = MAX_NUM_PG_PROFILE;

            break;
        case bcmCosqProfileOobfcEgressQueueMap:
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_sched_config_set(
    int unit,
    bcm_pbmp_t pbm,
    int mode,
    int weight_arr_size,
    int *weights)
{
    bcm_port_t port;
    int num_weights, i;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_ITER(pbm, port) {
        if ((weight_arr_size > bcmi_ltsw_cosq_port_num_cos(unit, port)) ||
            (weights == NULL)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        } else {
            num_weights = weight_arr_size;
        }

        for (i = 0; i < num_weights; i++) {
            SHR_IF_ERR_EXIT_EXCEPT_IF
                (cosq_sched_set(unit, port, i, mode, weights[i]),
                 SHR_E_NOT_FOUND);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_sched_config_get(
    int unit,
    bcm_pbmp_t pbm,
    int weight_arr_size,
    int *weights,
    int *weight_arr_count,
    int *mode)
{
    bcm_port_t port;
    int num_weights, i;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_ITER(pbm, port) {
        if ((mode == NULL) ||
            (weights == NULL) ||
            (weight_arr_count == NULL)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        if (weight_arr_size > bcmi_ltsw_cosq_port_num_cos(unit, port)) {
            num_weights = bcmi_ltsw_cosq_port_num_cos(unit, port);
        } else {
            num_weights = weight_arr_size;
        }
        *weight_arr_count = num_weights;

        for (i = 0; i < num_weights; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (cosq_sched_get(unit, port, i, mode, &weights[i]));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_discard_set(
    int unit,
    uint32_t flags)
{
    bcm_pbmp_t pbmp;
    bcm_port_t port;
    tm_ltsw_cosq_wred_config_t wred_config = {0};

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(pbmp);

    if (flags & ~(BCM_COSQ_DISCARD_DEVICE |
                  BCM_COSQ_DISCARD_NONTCP |
                  BCM_COSQ_DISCARD_COLOR_ALL |
                  BCM_COSQ_DISCARD_PORT |
                  BCM_COSQ_DISCARD_TCP |
                  BCM_COSQ_DISCARD_COLOR_GREEN |
                  BCM_COSQ_DISCARD_COLOR_YELLOW |
                  BCM_COSQ_DISCARD_COLOR_RED |
                  BCM_COSQ_DISCARD_CAP_AVERAGE |
                  BCM_COSQ_DISCARD_ENABLE |
                  BCM_COSQ_DISCARD_MARK_CONGESTION)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    flags &= ~(BCM_COSQ_DISCARD_NONTCP | BCM_COSQ_DISCARD_COLOR_ALL);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_PORT, &pbmp));

    wred_config.flags = flags | BCM_COSQ_DISCARD_PORT;
    wred_config.min_thresh = 0;
    wred_config.max_thresh = 0;
    wred_config.drop_probability = 0;
    wred_config.gain = 0;
    wred_config.refresh_time = 1;
    wred_config.profile_id = 0;
    wred_config.need_profile = cosq_wred_need_profile(wred_config.flags);
    wred_config.ignore_enable_flags = FALSE;

    BCM_PBMP_ITER(pbmp, port) {
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_wred_set(unit, port, 0, wred_config));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_discard_get(
    int unit,
    uint32_t *flags)
{
    bcm_pbmp_t pbmp;
    bcm_port_t port;
    tm_ltsw_cosq_wred_config_t wred_config;
    int rv;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(pbmp);

    if (*flags & ~(BCM_COSQ_DISCARD_DEVICE |
                  BCM_COSQ_DISCARD_NONTCP |
                  BCM_COSQ_DISCARD_COLOR_ALL |
                  BCM_COSQ_DISCARD_PORT |
                  BCM_COSQ_DISCARD_TCP |
                  BCM_COSQ_DISCARD_COLOR_GREEN |
                  BCM_COSQ_DISCARD_COLOR_YELLOW |
                  BCM_COSQ_DISCARD_COLOR_RED |
                  BCM_COSQ_DISCARD_CAP_AVERAGE |
                  BCM_COSQ_DISCARD_ENABLE |
                  BCM_COSQ_DISCARD_MARK_CONGESTION)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_PORT, &pbmp));

    sal_memset(&wred_config, 0, sizeof(tm_ltsw_cosq_wred_config_t));
    wred_config.flags = *flags | BCM_COSQ_DISCARD_PORT;
    *flags = 0;

    BCM_PBMP_ITER(pbmp, port) {
        rv = tm_ltsw_cosq_wred_get(unit, port, 0, &wred_config);
        if (rv == SHR_E_NONE) {
            *flags = wred_config.flags;
            *flags = *flags & (~BCM_COSQ_DISCARD_PORT);
            SHR_EXIT();
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_gport_discard_set(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    bcm_cosq_gport_discard_t *discard)
{
    uint32_t min_thresh, max_thresh;
    int modid, trunk_id, id;
    int cell_size, cell_field_max;
    bcm_port_t local_port = -1;
    tm_ltsw_cosq_wred_config_t wred_config = {0};
    int num_ucq;
    bcmi_ltsw_cosq_device_info_t device_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, NULL));

    /* Time Domain */
    /* the reasonable range of refresh_time  is from 1 to 64 */
    if (discard == NULL ||
        discard->gain < 0 || discard->gain > 15 ||
        discard->drop_probability < 0 || discard->drop_probability > 100 ||
        discard->refresh_time <= 0 || discard->refresh_time > 64 ||
        (discard->min_thresh > discard->max_thresh) ||
        (discard->min_thresh < 0) ||
        ((cosq < -1) || (cosq >= num_ucq))) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (device_info.mmu_cell_size != 0) {
        cell_size = device_info.mmu_cell_size;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_FAIL);
    }

    cell_field_max = COSQ_WRED_CELL_FIELD_MAX;

    min_thresh = discard->min_thresh;
    max_thresh = discard->max_thresh;
    if (discard->flags & BCM_COSQ_DISCARD_BYTES) {
        /* Convert bytes to cells */
        min_thresh += (cell_size - 1);
        min_thresh /= cell_size;

        max_thresh += (cell_size - 1);
        max_thresh /= cell_size;

        if ((min_thresh > cell_field_max) ||
            (max_thresh > cell_field_max)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    } else if (discard->flags & BCM_COSQ_DISCARD_PACKETS) {
        /* Packet mode not supported */
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    } else {
        /* Lower layer function will update thresh when these flags are
         * configured, this interface only allow such opration when
         * BCM_COSQ_DISCARD_BYTES is also configured.
         */
        if (discard->flags & (BCM_COSQ_DISCARD_COLOR_ALL |
            BCM_COSQ_DISCARD_TCP |
            BCM_COSQ_DISCARD_NONTCP |
            BCM_COSQ_DISCARD_ECT_MARKED |
            BCM_COSQ_DISCARD_RESPONSIVE_DROP |
            BCM_COSQ_DISCARD_NON_RESPONSIVE_DROP)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

    if (BCM_GPORT_IS_SET(gport)) {
        if (BCM_GPORT_IS_SCHEDULER(gport) ||
            BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_cosq_gport_port_resolve(unit, gport, &local_port, NULL));
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_gport_resolve(unit, gport, &modid, &local_port,
                                              &trunk_id, &id));
        }
    } else {
        local_port = gport;
    }

    if (is_cpu_port(unit,local_port) || is_lb_port(unit,local_port)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
    }

    wred_config.flags = discard->flags;
    wred_config.min_thresh = min_thresh;
    wred_config.max_thresh = max_thresh;
    wred_config.drop_probability = discard->drop_probability;
    wred_config.gain = discard->gain;
    wred_config.refresh_time = discard->refresh_time;
    wred_config.profile_id = discard->profile_id;
    wred_config.need_profile = cosq_wred_need_profile(wred_config.flags);
    wred_config.ignore_enable_flags = FALSE;

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_wred_set(unit, local_port, cosq, wred_config));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_gport_discard_get(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    bcm_cosq_gport_discard_t *discard)
{
    bcm_port_t local_port = -1;
    tm_ltsw_cosq_wred_config_t wred_config;
    int modid, trunk_id, id;
    int num_ucq;
    bcmi_ltsw_cosq_device_info_t device_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, NULL));

    if ((discard == NULL) ||
        (discard->flags & BCM_COSQ_DISCARD_PACKETS) ||
        ((cosq < -1) || (cosq >= num_ucq))) {
        /* Packet mode not supported */
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (BCM_GPORT_IS_SET(gport)) {
        if (BCM_GPORT_IS_SCHEDULER(gport) ||
            BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_cosq_gport_port_resolve(unit, gport, &local_port, NULL));
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_gport_resolve(unit, gport, &modid, &local_port,
                                              &trunk_id, &id));
        }
    } else {
        local_port = gport;
    }

    if (is_cpu_port(unit,local_port) || is_lb_port(unit,local_port)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
    }
    sal_memset(&wred_config, 0, sizeof(tm_ltsw_cosq_wred_config_t));
    wred_config.flags = discard->flags;

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_wred_get(unit, local_port,
                                 cosq == -1 ? 0 : cosq, &wred_config));

    discard->flags = wred_config.flags;
    /* Convert number of cells to number of bytes */
    discard->min_thresh = wred_config.min_thresh * device_info.mmu_cell_size;
    discard->max_thresh = wred_config.max_thresh * device_info.mmu_cell_size;
    discard->drop_probability = wred_config.drop_probability;
    discard->gain = wred_config.gain;
    discard->refresh_time = wred_config.refresh_time;
    discard->profile_id = wred_config.profile_id;
    discard->use_queue_group = wred_config.use_queue_group;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_discard_profile_create(
    int unit,
    int *profile_id)
{
    int i;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < COSQ_NUM_WRED_RESOLUTION_TABLE; i ++) {
        if (cosq_wred_resolution_tbl[unit][i] == 0) {
            /* hw reset value */
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_wred_cng_profile_reset(unit, i));
            cosq_wred_resolution_tbl[unit][i] = 1;
            *profile_id = i;
            SHR_EXIT();
        }
    }

    SHR_ERR_EXIT(SHR_E_RESOURCE);

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_discard_profile_destroy(
    int unit,
    int profile_id)
{
    SHR_FUNC_ENTER(unit);

    if ((profile_id < 0) || (profile_id >= COSQ_NUM_WRED_RESOLUTION_TABLE)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (cosq_wred_resolution_tbl[unit][profile_id] == 0) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    }

    /* hw reset value */
    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_wred_cng_profile_reset(unit, profile_id));
    cosq_wred_resolution_tbl[unit][profile_id] = 0;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_discard_profile_update(
    int unit,
    int profile_id,
    bcm_cosq_discard_rule_t *rule)
{
    tm_ltsw_cosq_wred_cng_profile_t profile;

    SHR_FUNC_ENTER(unit);

    if ((profile_id < 0) || (profile_id >= COSQ_NUM_WRED_RESOLUTION_TABLE)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (cosq_wred_resolution_tbl[unit][profile_id] == 0) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    switch (rule->egress_pool_congestion_state) {
        case BCM_COSQ_DISCARD_CONGESTION_LOW:
            profile.sp = 0;
            break;
        case BCM_COSQ_DISCARD_CONGESTION_MEDIUM:
            profile.sp = 1;
            break;
        case BCM_COSQ_DISCARD_CONGESTION_HIGH:
            profile.sp = 2;
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    switch (rule->queue_min_congestion_state) {
        case BCM_COSQ_DISCARD_CONGESTION_LOW:
            profile.q_min = 0;
            break;
        case BCM_COSQ_DISCARD_CONGESTION_HIGH:
            profile.q_min = 1;
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    switch (rule->action) {
        case BCM_COSQ_DISCARD_ACTION_WRED_DROP:
            profile.q_avg = 0;
            profile.action = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_wred_cng_profile_set(unit, profile_id, profile));
            profile.q_avg = 1;
            profile.action = 1;
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_wred_cng_profile_set(unit, profile_id, profile));
            break;
        case BCM_COSQ_DISCARD_ACTION_FORCE_DROP:
            profile.action = 1;
            profile.q_avg = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_wred_cng_profile_set(unit, profile_id, profile));
            profile.q_avg = 1;
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_wred_cng_profile_set(unit, profile_id, profile));
            break;
        case BCM_COSQ_DISCARD_ACTION_FORCE_NO_DROP:
            profile.action = 0;
            profile.q_avg = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_wred_cng_profile_set(unit, profile_id, profile));
            profile.q_avg = 1;
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_wred_cng_profile_set(unit, profile_id, profile));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_discard_profile_get(
    int unit,
    int profile_id,
    int max,
    bcm_cosq_discard_rule_t *rule_array,
    int *rule_count)
{
    tm_ltsw_cosq_wred_cng_profile_t profile;
    uint32_t action, sp, qmin, i = 0;
    uint32_t sp_map[3] = {
        BCM_COSQ_DISCARD_CONGESTION_LOW,
        BCM_COSQ_DISCARD_CONGESTION_MEDIUM,
        BCM_COSQ_DISCARD_CONGESTION_HIGH,
    };
    uint32_t qmin_map[2] = {
        BCM_COSQ_DISCARD_CONGESTION_LOW,
        BCM_COSQ_DISCARD_CONGESTION_HIGH,
    };
    uint32_t action_map[4] = {
        BCM_COSQ_DISCARD_ACTION_FORCE_NO_DROP,
        -1,
        BCM_COSQ_DISCARD_ACTION_WRED_DROP,
        BCM_COSQ_DISCARD_ACTION_FORCE_DROP,
    };

    SHR_FUNC_ENTER(unit);

    if ((!rule_count) ||
        (profile_id < 0) || (profile_id >= COSQ_NUM_WRED_RESOLUTION_TABLE)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    *rule_count = 3 * 2;

    if (!rule_array) {
        SHR_EXIT();
    }

    sal_memset(&profile, 0, sizeof(tm_ltsw_cosq_wred_cng_profile_t));
    for (sp = 0; sp < 3; sp++) {
        for (qmin = 0; qmin < 2; qmin++) {
            if (i < max) {
                profile.q_avg = 0;
                profile.q_min = qmin;
                profile.sp = sp;
                SHR_IF_ERR_VERBOSE_EXIT
                    (tm_ltsw_cosq_wred_cng_profile_get(unit, profile_id, &profile));
                action = profile.action;
                profile.q_avg = 1;
                SHR_IF_ERR_VERBOSE_EXIT
                    (tm_ltsw_cosq_wred_cng_profile_get(unit, profile_id, &profile));
                action = (profile.action << 1) | action;
                rule_array[i].egress_pool_congestion_state = sp_map[sp];
                rule_array[i].queue_min_congestion_state = qmin_map[qmin];
                rule_array[i].action = action_map[action];
                i ++;
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_cos_mapping_set(
    int unit,
    bcm_port_t local_port,
    bcm_cos_t priority,
    uint32_t flags,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_cos_mapping_set(unit, local_port, priority, flags, gport, cosq));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_cos_mapping_get(
    int unit,
    bcm_port_t local_port,
    bcm_cos_t priority,
    uint32_t flags,
    bcm_gport_t *gport,
    bcm_cos_queue_t *cosq)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_cos_mapping_get(unit, local_port, priority, flags, gport, cosq));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_shaper_config_get(
    int unit,
    int *refresh_time,
    int *itu_mode,
    int *shaper)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_shaper_config_get(unit, refresh_time, itu_mode, shaper));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_field_classifier_id_create(
    int unit,
    int *classifier_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_field_classifier_id_create(unit, classifier_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_field_classifier_id_destroy(
    int unit,
    int classifier_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_field_classifier_id_destroy(unit, classifier_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_field_classifier_map_set(
    int unit,
    int classifier_id,
    int count,
    bcm_cos_t *priority_array,
    bcm_cos_queue_t *cosq_array)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
       (cosq_field_classifier_map_set(unit, classifier_id, count,
                                      priority_array, cosq_array));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_field_classifier_map_get(
    int unit,
    int classifier_id,
    int array_max,
    bcm_cos_t *priority_array,
    bcm_cos_queue_t *cosq_array,
    int *array_count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
       (cosq_field_classifier_map_get(unit, classifier_id, array_max,
                                      priority_array, cosq_array, array_count));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_field_classifier_map_clear(
    int unit,
    int classifier_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_field_classifier_map_clear(unit, classifier_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_field_hi_classifier_id_create(
    int unit,
    int *classifier_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_field_hi_classifier_id_create(unit, classifier_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_field_hi_classifier_id_destroy(
    int unit,
    int classifier_id)
{
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_cosq_field_hi_classifier_map_set(
    int unit,
    int classifier_id,
    int count,
    bcm_cos_t *priority_array,
    bcm_cos_queue_t *cosq_array)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
       (cosq_field_hi_classifier_map_set(unit, classifier_id, count,
                                         priority_array, cosq_array));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_field_hi_classifier_map_get(
    int unit,
    int classifier_id,
    int array_max,
    bcm_cos_t *priority_array,
    bcm_cos_queue_t *cosq_array,
    int *array_count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
       (cosq_field_hi_classifier_map_get(unit, classifier_id, array_max,
                                         priority_array, cosq_array, array_count));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_field_hi_classifier_map_clear(
    int unit,
    int classifier_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_field_hi_classifier_id_destroy(unit, classifier_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_num_queue_get(
    int unit,
    int *num_ucq,
    int *num_mcq)
{
    int mc_q_mode;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_mcq_mode_get(unit, &mc_q_mode));

    if (num_ucq != NULL) {
        *num_ucq = (mc_q_mode == 0) ? 12 : (mc_q_mode == 1) ? 10 :
                   (mc_q_mode == 2) ? 8  : (mc_q_mode == 3) ? 6 : 8;
    }

    if (num_mcq != NULL) {
        *num_mcq = (mc_q_mode == 0) ? 0 : (mc_q_mode == 1) ? 2 :
                   (mc_q_mode == 2) ? 4 : (mc_q_mode == 3) ? 6 : 4;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_map_info_get(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_cosq_port_map_info_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_port_map_info_get(unit, port, info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_device_info_get(
    int unit,
    bcmi_ltsw_cosq_device_info_t *info)
{
    bcmi_ltsw_cosq_device_info_t mmu_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_device_info_get(unit, &mmu_info));

    mmu_info.num_itm = ITMS_PER_DEV;
    mmu_info.num_sched_profile = MAX_NUM_SCHED_PROFILE;
    mmu_info.num_int_pri = COSQ_NUM_INT_PRI;
    mmu_info.num_rqe_queue = MMU_RQE_QUEUE_NUM;
    mmu_info.num_sched_node = NUM_SCHEDULER_PER_PORT;

    *info = mmu_info;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_ct_mode_set(
    int unit,
    bcm_port_t port,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_port_ct_mode_set(unit, port, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_ct_mode_get(
    int unit,
    bcm_port_t port,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_port_ct_mode_get(unit, port, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_asf_config_dump(
    int unit,
    bcm_port_t port,
    int port_speed)
{
    int src_class = 0;
    int min_sp = 0, max_sp = 0;
    int rxp, txp;
    int mode;
    int min_speed, max_speed;
    tm_ltsw_cut_through_port_info_t info;

    SHR_FUNC_ENTER(unit);

    if (bcmi_ltsw_port_is_type(unit, port, BCMI_LTSW_PORT_TYPE_CPU |
                                           BCMI_LTSW_PORT_TYPE_LB |
                                           BCMI_LTSW_PORT_TYPE_MGMT)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_port_ct_mode_get(unit, port, &mode));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_tm_cut_through_port_info_get(unit, port, &info));

    SHR_IF_ERR_VERBOSE_EXIT
        (port_asf_speed_limits_get(unit, port_speed, info.src_port_max_speed,
                                   mode, &min_sp, &max_sp));

    min_speed = port_asf_speed_get(min_sp);
    max_speed = port_asf_speed_get(max_sp);

    LOG_CLI((BSL_META_U(unit,
                        "%-5s %-3d %-3d %-6d %-6d %-3d   "),
                        bcmi_ltsw_port_name(unit, port), mode, info.cut_through_class,
                        min_speed, max_speed, info.fifo_thd_cells));

    for (src_class = 0; src_class < MAX_TM_CUT_THROUGH_CLASS; src_class++) {
        LOG_CLI((BSL_META_U(unit,
                            "%-3d "),
                            info.egr_xmit_start_count_bytes[src_class]));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_port_pause_get(unit, port, &txp, &rxp));
    LOG_CLI((BSL_META_U(unit,
                        " %-3d %-3d \n"),
                        info.max_credit_cells,
                        rxp));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_port_asf_config_show(
    int unit,
    bcm_port_t port,
    int port_speed)
{
#define STRING_LEN 5
#define ASF_MODE_NUM 2

    char mode_str[ASF_MODE_NUM][STRING_LEN] = {"SAF", "CT"};
    char speed_str[MAX_TM_CUT_THROUGH_CLASS][STRING_LEN] = {
                              "SAF", "10G", "25G", "40G",
                              "50G", "100G", "200G", "400G"};
    int mode = TM_LTSW_ASF_MODE_SAF;
    int min_speed, max_speed;
    tm_ltsw_cut_through_port_info_t info;

    SHR_FUNC_ENTER(unit);

    if (bcmi_ltsw_port_is_type(unit, port, BCMI_LTSW_PORT_TYPE_CPU |
                                           BCMI_LTSW_PORT_TYPE_LB |
                                           BCMI_LTSW_PORT_TYPE_MGMT)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_port_ct_mode_get(unit, port, &mode));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_tm_cut_through_port_info_get(unit, port, &info));

    LOG_CLI((BSL_META_U(unit,
                        "%-5s     %-11s      "),
                        bcmi_ltsw_port_name(unit, port),
                        mode_str[mode]));

    if (TM_LTSW_ASF_MODE_SAF == mode) {
        LOG_CLI((BSL_META_U(unit, "    .. NA ..\n")));
    } else if (TM_LTSW_ASF_MODE_CT == mode) {
        SHR_IF_ERR_VERBOSE_EXIT
            (port_asf_speed_limits_get(unit, port_speed, info.src_port_max_speed,
                                       mode, &min_speed, &max_speed));
        LOG_CLI((BSL_META_U(unit,
                            "%s / %s\n"), speed_str[max_speed],
                            speed_str[min_speed]));
    }
#undef STRING_LEN
#undef ASF_MODE_NUM

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_rx_queue_channel_get(
    int unit,
    bcm_cos_queue_t queue_id,
    bcm_rx_chan_t chan_id,
    bool *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_rx_queue_channel_get(unit, queue_id, chan_id, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_rx_queue_channel_set(
    int unit,
    bcm_cos_queue_t queue_id,
    bcm_rx_chan_t chan_id,
    bool enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_rx_queue_channel_set(unit, queue_id, chan_id, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_rx_queue_channel_set_test(
    int unit,
    bcm_cos_queue_t queue_id,
    bcm_rx_chan_t chan_id)
{
    cosq_cpu_port_info_t *cpu_port_info =
                                 LTSW_MMU_INFO(unit)->ltsw_cosq_cpu_port_info;
    bcm_gport_t cpu_l0_gport = -1;
    bcm_gport_t parent_gport = -1;
    bool enable = false;

    SHR_FUNC_ENTER(unit);

    if ((chan_id <= 0) || (chan_id >= 8)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (cpu_port_info == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    if ((chan_id > 0) && (chan_id < 8 ))  {
        cpu_l0_gport = cpu_port_info->sched[chan_id - 1].gport;
    }

    if (queue_id < 0) { /* All COS Queues */
        for (queue_id = 0; queue_id < NUM_CPU_MCAST_QUEUE; queue_id++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_cosq_rx_queue_channel_get(unit, queue_id, chan_id, &enable));

            if (enable) {
                /* find the parent gport of this queue if parent gport is
                 * not equal to l0 gport for this channel return error */
                parent_gport = cpu_port_info->mcast[queue_id].parent_gport;
                if (parent_gport != cpu_l0_gport) {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }
            }
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_rx_queue_channel_get(unit, queue_id, chan_id, &enable));

        if (enable) {
            /* find the parent gport of this queue if parent gport is not
             * equal to l0 gport for this channel return error */
            parent_gport = cpu_port_info->mcast[queue_id].parent_gport;
            if (parent_gport != cpu_l0_gport) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_gport_traverse_by_port(
    int unit,
    bcm_gport_t port,
    bcm_cosq_gport_traverse_cb cb,
    void *user_data)
{
    int modid, local_port, trunk_id, id;

    SHR_FUNC_ENTER(unit);

    if (LTSW_MMU_INFO(unit) == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_resolve(unit, port, &modid, &local_port,
                                      &trunk_id, &id));
    if (is_cpu_port(unit, local_port)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_gport_cpu_traverse(unit, cb, user_data));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (cosq_gport_port_traverse(unit, local_port, cb, user_data));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Cosq driver function variable for bcm56780_a0 device.
 */
static mbcm_ltsw_cosq_drv_t bcm56780_a0_ltsw_cosq_drv = {
    .cosq_init = bcm56780_a0_ltsw_cosq_init,
    .cosq_detach = bcm56780_a0_ltsw_cosq_detach,
    .cosq_gport_port_resolve = bcm56780_a0_ltsw_cosq_gport_port_resolve,
    .cosq_port_itm_validate = bcm56780_a0_ltsw_cosq_port_itm_validate,
    .cosq_sw_dump = bcm56780_a0_ltsw_cosq_sw_dump,
    .cosq_bucket_set = bcm56780_a0_ltsw_cosq_bucket_set,
    .cosq_bucket_get = bcm56780_a0_ltsw_cosq_bucket_get,
    .cosq_port_detach = bcm56780_a0_ltsw_cosq_port_detach,
    .cosq_port_attach = bcm56780_a0_ltsw_cosq_port_attach,
    .cosq_mc_cos_mirror_set = bcm56780_a0_ltsw_cosq_mc_cos_mirror_set,
    .cosq_mc_cos_mirror_get = bcm56780_a0_ltsw_cosq_mc_cos_mirror_get,
    .cosq_sched_node_child_get = bcm56780_a0_ltsw_cosq_sched_node_child_get,
    .cosq_gport_get = bcm56780_a0_ltsw_cosq_gport_get,
    .cosq_gport_child_get = bcm56780_a0_ltsw_cosq_gport_child_get,
    .cosq_gport_attach = bcm56780_a0_ltsw_cosq_gport_attach,
    .cosq_gport_detach = bcm56780_a0_ltsw_cosq_gport_detach,
    .cosq_gport_attach_get = bcm56780_a0_ltsw_cosq_gport_attach_get,
    .cosq_gport_traverse = bcm56780_a0_ltsw_cosq_gport_traverse,
    .cosq_sched_weight_max_get = bcm56780_a0_ltsw_cosq_sched_weight_max_get,
    .cosq_schedq_mapping_set = bcm56780_a0_ltsw_cosq_schedq_mapping_set,
    .cosq_schedq_mapping_get = bcm56780_a0_ltsw_cosq_schedq_mapping_get,
    .cosq_port_scheduler_profile_set = bcm56780_a0_ltsw_cosq_port_scheduler_profile_set,
    .cosq_port_scheduler_profile_get = bcm56780_a0_ltsw_cosq_port_scheduler_profile_get,
    .cosq_sched_set = bcm56780_a0_ltsw_cosq_sched_set,
    .cosq_sched_get = bcm56780_a0_ltsw_cosq_sched_get,
    .cosq_cosq_profile_max_num_get = bcm56780_a0_ltsw_cosq_cosq_profile_max_num_get,
    .cosq_port_sched_config_set = bcm56780_a0_ltsw_cosq_port_sched_config_set,
    .cosq_port_sched_config_get = bcm56780_a0_ltsw_cosq_port_sched_config_get,
    .cosq_discard_set = bcm56780_a0_ltsw_cosq_discard_set,
    .cosq_discard_get = bcm56780_a0_ltsw_cosq_discard_get,
    .cosq_gport_discard_set = bcm56780_a0_ltsw_cosq_gport_discard_set,
    .cosq_gport_discard_get = bcm56780_a0_ltsw_cosq_gport_discard_get,
    .cosq_discard_profile_create = bcm56780_a0_ltsw_cosq_discard_profile_create,
    .cosq_discard_profile_destroy = bcm56780_a0_ltsw_cosq_discard_profile_destroy,
    .cosq_discard_profile_update = bcm56780_a0_ltsw_cosq_discard_profile_update,
    .cosq_discard_profile_get = bcm56780_a0_ltsw_cosq_discard_profile_get,
    .cosq_cos_mapping_set = bcm56780_a0_ltsw_cosq_cos_mapping_set,
    .cosq_cos_mapping_get = bcm56780_a0_ltsw_cosq_cos_mapping_get,
    .cosq_shaper_config_get = bcm56780_a0_ltsw_cosq_shaper_config_get,
    .cosq_field_classifier_id_create = bcm56780_a0_ltsw_cosq_field_classifier_id_create,
    .cosq_field_classifier_id_destroy = bcm56780_a0_ltsw_cosq_field_classifier_id_destroy,
    .cosq_field_classifier_map_set = bcm56780_a0_ltsw_cosq_field_classifier_map_set,
    .cosq_field_classifier_map_get = bcm56780_a0_ltsw_cosq_field_classifier_map_get,
    .cosq_field_classifier_map_clear = bcm56780_a0_ltsw_cosq_field_classifier_map_clear,
    .cosq_field_hi_classifier_id_create = bcm56780_a0_ltsw_cosq_field_hi_classifier_id_create,
    .cosq_field_hi_classifier_id_destroy = bcm56780_a0_ltsw_cosq_field_hi_classifier_id_destroy,
    .cosq_field_hi_classifier_map_set = bcm56780_a0_ltsw_cosq_field_hi_classifier_map_set,
    .cosq_field_hi_classifier_map_get = bcm56780_a0_ltsw_cosq_field_hi_classifier_map_get,
    .cosq_field_hi_classifier_map_clear = bcm56780_a0_ltsw_cosq_field_hi_classifier_map_clear,
    .cosq_num_queue_get = bcm56780_a0_ltsw_cosq_num_queue_get,
    .cosq_port_map_info_get = bcm56780_a0_ltsw_cosq_port_map_info_get,
    .cosq_device_info_get = bcm56780_a0_ltsw_cosq_device_info_get,
    .cosq_port_ct_mode_set = bcm56780_a0_ltsw_cosq_port_ct_mode_set,
    .cosq_port_ct_mode_get = bcm56780_a0_ltsw_cosq_port_ct_mode_get,
    .cosq_port_asf_config_dump = bcm56780_a0_ltsw_cosq_port_asf_config_dump,
    .cosq_port_asf_config_show = bcm56780_a0_ltsw_cosq_port_asf_config_show,
    .cosq_rx_queue_channel_get = bcm56780_a0_ltsw_cosq_rx_queue_channel_get,
    .cosq_rx_queue_channel_set = bcm56780_a0_ltsw_cosq_rx_queue_channel_set,
    .cosq_rx_queue_channel_set_test = bcm56780_a0_ltsw_cosq_rx_queue_channel_set_test,
    .cosq_gport_traverse_by_port = bcm56780_a0_ltsw_cosq_gport_traverse_by_port
};

/******************************************************************************
 * Public functions
 */

int
bcm56780_a0_ltsw_cosq_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_cosq_drv_set(unit, &bcm56780_a0_ltsw_cosq_drv));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56780_a0_ltsw_variant_drv_attach(unit, BCM56780_A0_LTSW_VARIANT_COSQ));

exit:
    SHR_FUNC_EXIT();
}

