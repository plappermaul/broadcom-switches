/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>

#include <bcm_int/ltsw/mbcm/cosq_thd.h>

#include <bcm_int/ltsw/tm/cosq_thd.h>
#include <bcm_int/ltsw/cosq_thd.h>
#include <bcm_int/ltsw/cosq.h>
#include <bcm_int/ltsw/cosq_int.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/ecn.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <sal/sal_libc.h>
#include <shr/shr_debug.h>
#include <bcmlt/bcmlt.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_COSQ

/******************************************************************************
 * Private functions
 */


#define MMU_BYTES_PER_CELL          318
#define ITMS_PER_DEV                1
#define NUM_CPU_MCAST_QUEUE         48
#define MIN(x, y) (((x) < (y)) ? (x) : (y))

static int *cpu_q_min_limit[BCM_MAX_NUM_UNITS];
static int *cpu_q_shared_limit[BCM_MAX_NUM_UNITS];
static int *cpu_q_limit_dynamic[BCM_MAX_NUM_UNITS];
static int *cpu_q_limit_enable[BCM_MAX_NUM_UNITS];
static int *cpu_q_color_limit_enable[BCM_MAX_NUM_UNITS];

typedef struct cosq_thd_lt_convert_s {
    uint32_t        val;
    const char      *sym_val;
} cosq_thd_lt_convert_t;

/*
 * \brief Convert int to char
 *
 * \param [in]  percent      percent.
 *
 * \retval rate              rate.
 */
static const char*
cosq_thd_int_to_char(int val, cosq_thd_lt_convert_t *array, int nfields)
{
    int i;

    for (i = (nfields - 1); i >= 0; i--) {
      if (val == array[i].val) {
          break;
      }
    }

    return array[i].sym_val;
}

/*
 * \brief Convert char to int
 *
 * \param [in]  rate      rate.
 *
 * \retval percent        percent.
 */
static int
cosq_thd_char_to_int(const char *field, cosq_thd_lt_convert_t *array, int nfields)
{
    int val = 0;
    int i;

    for (i = 0; i < nfields; i++) {
        if (sal_strcasecmp(field, array[i].sym_val) == 0) {
            val = array[i].val;
            break;
        }
    }

    return val;
}

/*
 * \brief Convert int to alpha value.
 */
static cosq_thd_lt_convert_t cosq_int_to_alpha[] =
{
    {bcmCosqControlDropLimitAlpha_1_128,   ALPHA_1_128s},
    {bcmCosqControlDropLimitAlpha_1_64,    ALPHA_1_64s},
    {bcmCosqControlDropLimitAlpha_1_32,    ALPHA_1_32s},
    {bcmCosqControlDropLimitAlpha_1_16,    ALPHA_1_16s},
    {bcmCosqControlDropLimitAlpha_1_8,     ALPHA_1_8s},
    {bcmCosqControlDropLimitAlpha_1_4,     ALPHA_1_4s},
    {bcmCosqControlDropLimitAlpha_1_2,     ALPHA_1_2s},
    {bcmCosqControlDropLimitAlpha_1,       ALPHA_1s},
    {bcmCosqControlDropLimitAlpha_2,       ALPHA_2s},
    {bcmCosqControlDropLimitAlpha_4,       ALPHA_4s},
    {bcmCosqControlDropLimitAlpha_8,       ALPHA_8s},
};

/*
 * \brief Convert int to alpha value
 *
 * \param [in]  alpha         alpha.
 *
 * \retval alpha              alpha.
 */
static const char*
cosq_thd_int_to_alpha(int alpha)
{
    int nfields;

    nfields = sizeof(cosq_int_to_alpha) / sizeof(cosq_int_to_alpha[0]);

    return cosq_thd_int_to_char(alpha, cosq_int_to_alpha, nfields);
}

/*
 * \brief Convert alpha value to int
 *
 * \param [in]  alpha      alpha.
 *
 * \retval alpha           alpha.
 */
static int
cosq_thd_alpha_to_int(const char *alpha)
{
    int nfields;

    nfields = sizeof(cosq_int_to_alpha) / sizeof(cosq_int_to_alpha[0]);

    return cosq_thd_char_to_int(alpha, cosq_int_to_alpha, nfields);
}

/*
 * \brief Convert int to percent value.
 */
static cosq_thd_lt_convert_t cosq_int_to_percent[] =
{
    {0,   PERCENTAGE_1000s},
    {1,   PERCENTAGE_125s},
    {2,   PERCENTAGE_250s},
    {3,   PERCENTAGE_375s},
    {4,   PERCENTAGE_500s},
    {5,   PERCENTAGE_675s},
    {6,   PERCENTAGE_750s},
    {7,   PERCENTAGE_875s},
};

/*
 * \brief Convert int to percent value
 *
 * \param [in]  percent      percent.
 *
 * \retval percent           percent.
 */
static const char*
cosq_thd_int_to_percent(int percent)
{
    int nfields;

    nfields = sizeof(cosq_int_to_percent) / sizeof(cosq_int_to_percent[0]);

    return cosq_thd_int_to_char(percent, cosq_int_to_percent, nfields);
}

/*
 * \brief Convert percent value to int
 *
 * \param [in]  percent   percent.
 *
 * \retval percent        percent.
 */
static int
cosq_thd_percent_to_int(const char *percent)
{
    int nfields;

    nfields = sizeof(cosq_int_to_percent) / sizeof(cosq_int_to_percent[0]);

    return cosq_thd_char_to_int(percent, cosq_int_to_percent, nfields);
}

/*
 * \brief convert byte to cell.
 *
 * \param [in]  bytes         bytes.
 *
 * \retval cells.
 */
static int
cosq_thd_byte_to_cell(uint32_t bytes)
{
    return (bytes + (MMU_BYTES_PER_CELL - 1))/MMU_BYTES_PER_CELL;
}

/*
 * \brief convert cell to byte.
 *
 * \param [in]  cells         cells.
 *
 * \retval bytes.
 */
static int
cosq_thd_cell_to_byte(uint32_t cells)
{
    return cells * MMU_BYTES_PER_CELL;
}

/*
 * \brief  To get enable/disable status on Rx of packets on the specified CPU cosq.
 *
 * \param [in]   unit              Unit number.
 * \param [in]   cosq              CPU Cosq ID.
 * \param [out]  cpu_cosq_config   tm_ltsw_cosq_cpu_cosq_config_t.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
cosq_thd_cpu_cosq_enable_get(
    int unit,
    bcm_cos_queue_t cosq,
    int *enable)
{
    tm_ltsw_cosq_cpu_cosq_config_t cpu_cosq_config;
    int hw_enable = 0;

    SHR_FUNC_ENTER(unit);

    if ((cosq < 0) || (cosq >= NUM_CPU_MCAST_QUEUE)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(enable, SHR_E_PARAM);

    hw_enable = 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_cpu_cosq_enable_get(unit, cosq, &cpu_cosq_config));

    if ((cpu_cosq_config.q_limit_enable != 0) &&
        (cpu_cosq_config.q_limit_dynamic == 0) &&
        (cpu_cosq_config.q_min_limit == 0) &&
        (cpu_cosq_config.q_shared_limit == 0)) {
        hw_enable = 0;
    }

    *enable = hw_enable;

exit:
    SHR_FUNC_EXIT();
}


static int
bcm56780_a0_ltsw_cosq_thd_init(int unit)
{
    int idx;
    uint32_t ha_alloc_size, ha_req_size;
    int warm = bcmi_warmboot_get(unit);

    static tm_ltsw_cosq_thd_chip_driver_t bcm56780_a0_cosq_thd_drv_cb = {
        .cosq_thd_int_to_alpha = cosq_thd_int_to_alpha,
        .cosq_thd_alpha_to_int = cosq_thd_alpha_to_int,
        .cosq_thd_int_to_percent = cosq_thd_int_to_percent,
        .cosq_thd_percent_to_int = cosq_thd_percent_to_int,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_chip_driver_register(unit, &bcm56780_a0_cosq_thd_drv_cb));

    ha_req_size = sizeof(int) * NUM_CPU_MCAST_QUEUE;
    ha_alloc_size = ha_req_size;

    cpu_q_min_limit[unit] = (int *)bcmi_ltsw_ha_mem_alloc
                                       (unit, BCMI_HA_COMP_ID_COSQ,
                                        BCMINT_COSQ_CPU_LIMIT_SUB_COMP_ID,
                                        "bcmCosqCpuQMin",
                                        &ha_alloc_size);
    SHR_NULL_CHECK(cpu_q_min_limit[unit], SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    cpu_q_shared_limit[unit] = (int *)bcmi_ltsw_ha_mem_alloc
                                          (unit, BCMI_HA_COMP_ID_COSQ,
                                           BCMINT_COSQ_CPU_SHARED_LIMIT_SUB_COMP_ID,
                                           "bcmCosqCpuQShared",
                                           &ha_alloc_size);
    SHR_NULL_CHECK(cpu_q_shared_limit[unit], SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    cpu_q_limit_dynamic[unit] = (int *)bcmi_ltsw_ha_mem_alloc
                                           (unit, BCMI_HA_COMP_ID_COSQ,
                                            BCMINT_COSQ_CPU_DYNAMIC_SUB_COMP_ID,
                                            "bcmCosqCpuQDynamic",
                                            &ha_alloc_size);
    SHR_NULL_CHECK(cpu_q_limit_dynamic[unit], SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    cpu_q_limit_enable[unit] = (int *)bcmi_ltsw_ha_mem_alloc
                                          (unit, BCMI_HA_COMP_ID_COSQ,
                                           BCMINT_COSQ_CPU_LIMIT_ENABLE_SUB_COMP_ID,
                                           "bcmCosqCpuQLimitEn",
                                           &ha_alloc_size);
    SHR_NULL_CHECK(cpu_q_limit_enable[unit], SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    cpu_q_color_limit_enable[unit] = (int *)bcmi_ltsw_ha_mem_alloc
                                                (unit, BCMI_HA_COMP_ID_COSQ,
                                                 BCMINT_COSQ_CPU_COLOR_LIMIT_SUB_COMP_ID,
                                                 "bcmCosqCpuQColorLimitEn",
                                                 &ha_alloc_size);
    SHR_NULL_CHECK(cpu_q_color_limit_enable[unit], SHR_E_MEMORY);

    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    if (!warm) {
        for (idx = 0; idx < NUM_CPU_MCAST_QUEUE; idx++) {
            cpu_q_min_limit[unit][idx] = 0;
            cpu_q_shared_limit[unit][idx] = 0;
            cpu_q_limit_dynamic[unit][idx] = 0;
            cpu_q_limit_enable[unit][idx] = 0;
            cpu_q_color_limit_enable[unit][idx] = 0;
        }
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (cpu_q_min_limit[unit]) {
            (void)bcmi_ltsw_ha_mem_free(unit, cpu_q_min_limit[unit]);
            cpu_q_min_limit[unit] = NULL;
        }
        if (cpu_q_shared_limit[unit]) {
            (void)bcmi_ltsw_ha_mem_free(unit, cpu_q_shared_limit[unit]);
            cpu_q_shared_limit[unit] = NULL;
        }
        if (cpu_q_limit_dynamic[unit]) {
            (void)bcmi_ltsw_ha_mem_free(unit, cpu_q_limit_dynamic[unit]);
            cpu_q_limit_dynamic[unit] = NULL;
        }
        if (cpu_q_limit_enable[unit]) {
            (void)bcmi_ltsw_ha_mem_free(unit, cpu_q_limit_enable[unit]);
            cpu_q_limit_enable[unit] = NULL;
        }
        if (cpu_q_color_limit_enable[unit]) {
            (void)bcmi_ltsw_ha_mem_free(unit, cpu_q_color_limit_enable[unit]);
            cpu_q_color_limit_enable[unit] = NULL;
        }
    }

    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_detach(int unit)
{
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_cosq_thd_dynamic_get(
    int unit,
    bcm_cosq_control_t type,
    bcm_cosq_dynamic_setting_type_t *dynamic)
{
    switch (type) {
        case bcmCosqControlEgressPool:
        case bcmCosqControlUCEgressPool:
        case bcmCosqControlMCEgressPool:
            *dynamic = bcmCosqDynamicTypeConditional;
            break;
        case bcmCosqControlIngressPool:
        case bcmCosqControlIngressHeadroomPool:
            *dynamic = bcmCosqDynamicTypeFixed;
            break;
        case bcmCosqControlBandwidthBurstMax:
        case bcmCosqControlBandwidthBurstMin:
        case bcmCosqControlEgressPoolLimitBytes:
        case bcmCosqControlEgressPoolYellowLimitBytes:
        case bcmCosqControlEgressPoolRedLimitBytes:
        case bcmCosqControlEgressPoolLimitEnable:
        case bcmCosqControlEgressPoolSharedLimitBytes:
        case bcmCosqControlEgressPoolResumeLimitBytes:
        case bcmCosqControlEgressPoolYellowSharedLimitBytes:
        case bcmCosqControlEgressPoolYellowResumeLimitBytes:
        case bcmCosqControlEgressPoolRedSharedLimitBytes:
        case bcmCosqControlEgressPoolRedResumeLimitBytes:
        case bcmCosqControlEgressUCQueueSharedLimitBytes:
        case bcmCosqControlEgressMCQueueSharedLimitBytes:
        case bcmCosqControlEgressUCQueueResumeOffsetBytes:
        case bcmCosqControlEgressMCQueueResumeOffsetBytes:
        case bcmCosqControlEgressUCQueueMinLimitBytes:
        case bcmCosqControlEgressMCQueueMinLimitBytes:
        case bcmCosqControlEgressPoolHighCongestionLimitBytes:
        case bcmCosqControlEgressPoolLowCongestionLimitBytes:
        case bcmCosqControlIngressPortPGSharedLimitBytes:
        case bcmCosqControlIngressPortPGMinLimitBytes:
        case bcmCosqControlIngressPortPoolMinLimitBytes:
        case bcmCosqControlIngressPortPoolSharedLimitBytes:
        case bcmCosqControlIngressPortPGHeadroomLimitBytes:
        case bcmCosqControlIngressPortPGResetFloorBytes:
        case bcmCosqControlIngressPortPGResetOffsetBytes:
        case bcmCosqControlIngressPortPoolResumeLimitBytes:
        case bcmCosqControlDropLimitAlpha:
        case bcmCosqControlIngressPortPGSharedDynamicEnable:
        case bcmCosqControlEgressUCSharedDynamicEnable:
        case bcmCosqControlEgressMCSharedDynamicEnable:
        case bcmCosqControlEgressPortPoolYellowLimitBytes:
        case bcmCosqControlEgressPortPoolRedLimitBytes:
        case bcmCosqControlEgressPortPoolSharedLimitBytes:
        case bcmCosqControlEgressPortPoolSharedResumeBytes:
        case bcmCosqControlEgressPortPoolYellowResumeBytes:
        case bcmCosqControlEgressPortPoolRedResumeBytes:
        case bcmCosqControlEgressUCQueueLimitEnable:
        case bcmCosqControlEgressMCQueueLimitEnable:
        case bcmCosqControlIngressPoolLimitBytes:
        case bcmCosqControlIngressPoolResetOffsetLimitBytes:
        case bcmCosqControlIngressHeadroomPoolLimitBytes:
        case bcmCosqControlEgressUCQueueGroupMinEnable:
        case bcmCosqControlEgressMCQueueGroupMinEnable:
        case bcmCosqControlEgressUCQueueGroupMinLimitBytes:
        case bcmCosqControlEgressMCQueueGroupMinLimitBytes:
        case bcmCosqControlEgressUCQueueColorLimitDynamicEnable:
        case bcmCosqControlEgressMCQueueColorLimitDynamicEnable:
        case bcmCosqControlEgressUCQueueColorLimitEnable:
        case bcmCosqControlEgressMCQueueColorLimitEnable:
        case bcmCosqControlEgressUCQueueRedLimit:
        case bcmCosqControlEgressUCQueueYellowLimit:
        case bcmCosqControlEgressMCQueueRedLimit:
        case bcmCosqControlEgressMCQueueYellowLimit:
            *dynamic = bcmCosqDynamicTypeFlexible;
            break;
        default:
            return SHR_E_UNAVAIL;
    }

    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_cosq_thd_port_guarantee_reset(
    int unit,
    bcm_port_t port)
{
    int idx, numq;
    int num_ucq, num_mcq;
    int pg_guarantee, uc_guarantee, mc_guarantee;
    bcmi_ltsw_cosq_device_info_t device_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    /* priority group */
    for (idx = 0; idx < device_info.num_pg; idx++) {
        pg_guarantee = 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_thd_ing_port_pg_set(
                unit, port, idx, bcmCosqControlIngressPortPGMinLimitBytes,
                pg_guarantee));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));
    /* UC */
    for (idx = 0; idx < num_ucq; idx++) {
        uc_guarantee = 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_thd_egr_queue_set(
                unit, port, idx, bcmCosqControlEgressUCQueueMinLimitBytes,
                uc_guarantee));
    }

    /* MC */
    numq = num_ucq + num_mcq;
    for (idx = num_ucq; idx < numq; idx++) {
        mc_guarantee = 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_thd_egr_queue_set(
                unit, port, idx, bcmCosqControlEgressMCQueueMinLimitBytes,
                mc_guarantee));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_control_set(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    bcm_cosq_buffer_id_t buffer,
    bcm_cosq_control_t type,
    int arg)
{
    bcmi_ltsw_cosq_device_info_t device_info = {0};

    SHR_FUNC_ENTER(unit);

    if ((arg < 0) &&
        (type != bcmCosqControlLatencyEcnInstantThreshold)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    LOG_INFO(BSL_LOG_MODULE,
        (BSL_META_U(unit,
            "gport %d cosq %d buffer %d type %d arg %d\n"),
            gport, cosq, buffer, type, arg));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    switch (type) {
        case bcmCosqControlBandwidthBurstMax:
        case bcmCosqControlBandwidthBurstMin:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_bandwidth_burst_set(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlEgressPool:
        case bcmCosqControlUCEgressPool:
        case bcmCosqControlMCEgressPool:
            if (arg < 0 || (arg >= device_info.num_service_pool)) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }

            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_egr_spid_set(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlEgressPoolLimitBytes:
        case bcmCosqControlEgressPoolYellowLimitBytes:
        case bcmCosqControlEgressPoolRedLimitBytes:
        case bcmCosqControlEgressPoolLimitEnable:
        case bcmCosqControlEgressUCQueueSharedLimitBytes:
        case bcmCosqControlEgressMCQueueSharedLimitBytes:
        case bcmCosqControlEgressUCQueueResumeOffsetBytes:
        case bcmCosqControlEgressMCQueueResumeOffsetBytes:
        case bcmCosqControlEgressUCQueueMinLimitBytes:
        case bcmCosqControlEgressMCQueueMinLimitBytes:
        case bcmCosqControlEgressUCSharedDynamicEnable:
        case bcmCosqControlEgressMCSharedDynamicEnable:
        case bcmCosqControlEgressUCQueueLimitEnable:
        case bcmCosqControlEgressMCQueueLimitEnable:
        case bcmCosqControlEgressUCQueueColorLimitDynamicEnable:
        case bcmCosqControlEgressMCQueueColorLimitDynamicEnable:
        case bcmCosqControlEgressUCQueueColorLimitEnable:
        case bcmCosqControlEgressMCQueueColorLimitEnable:
        case bcmCosqControlEgressUCQueueRedLimit:
        case bcmCosqControlEgressUCQueueYellowLimit:
        case bcmCosqControlEgressMCQueueRedLimit:
        case bcmCosqControlEgressMCQueueYellowLimit:
        case bcmCosqControlEgressUCQueueGroupMinEnable:
        case bcmCosqControlEgressMCQueueGroupMinEnable:
        case bcmCosqControlEgressUCQueueGroupMinLimitBytes:
        case bcmCosqControlEgressMCQueueGroupMinLimitBytes:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_egr_queue_set(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlEgressPoolSharedLimitBytes:
        case bcmCosqControlEgressPoolResumeLimitBytes:
        case bcmCosqControlEgressPoolYellowSharedLimitBytes:
        case bcmCosqControlEgressPoolYellowResumeLimitBytes:
        case bcmCosqControlEgressPoolRedSharedLimitBytes:
        case bcmCosqControlEgressPoolRedResumeLimitBytes:
        case bcmCosqControlEgressPoolHighCongestionLimitBytes:
        case bcmCosqControlEgressPoolLowCongestionLimitBytes:
            if (device_info.mmu_cell_size == 0) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_FAIL);
            }
            arg = (arg + device_info.mmu_cell_size - 1) / device_info.mmu_cell_size;

            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_egr_pool_set(unit, gport, cosq, buffer, type, arg));
            break;
        case bcmCosqControlEgressPortPoolYellowLimitBytes:
        case bcmCosqControlEgressPortPoolRedLimitBytes:
        case bcmCosqControlEgressPortPoolSharedLimitBytes:
        case bcmCosqControlEgressPortPoolSharedResumeBytes:
        case bcmCosqControlEgressPortPoolYellowResumeBytes:
        case bcmCosqControlEgressPortPoolRedResumeBytes:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_egr_port_pool_set(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlIngressPortPGSharedLimitBytes:
        case bcmCosqControlIngressPortPGMinLimitBytes:
        case bcmCosqControlIngressPortPGHeadroomLimitBytes:
        case bcmCosqControlIngressPortPGResetFloorBytes:
        case bcmCosqControlIngressPortPGResetOffsetBytes:
        case bcmCosqControlIngressPortPGSharedDynamicEnable:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_ing_port_pg_set(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlIngressPortPoolMinLimitBytes:
        case bcmCosqControlIngressPortPoolSharedLimitBytes:
        case bcmCosqControlIngressPortPoolResumeLimitBytes:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_ing_port_pool_set(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlIngressPool:
        case bcmCosqControlIngressHeadroomPool:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_ing_pg_pool_set(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlIngressPoolLimitBytes:
        case bcmCosqControlIngressPoolResetOffsetLimitBytes:
        case bcmCosqControlIngressHeadroomPoolLimitBytes:
            if (device_info.mmu_cell_size == 0) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_FAIL);
            }
            arg = (arg + device_info.mmu_cell_size - 1) / device_info.mmu_cell_size;

            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_ing_pool_set(unit, gport, cosq, buffer, type, arg));
            break;
        case bcmCosqControlDropLimitAlpha:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_alpha_set(unit, gport, cosq,
                               (bcm_cosq_control_drop_limit_alpha_value_t)arg));
            break;
        case bcmCosqControlLatencyEcnInstantThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_ltsw_ecn_latency_based_threshold_set(unit, gport, cosq,
                                                          bcmSwitchLatencyEcnMarkInstant,
                                                          (uint32_t)arg));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_control_get(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    bcm_cosq_buffer_id_t buffer,
    bcm_cosq_control_t type,
    int *arg)
{
    bcmi_ltsw_cosq_device_info_t device_info = {0};
    uint32_t val;

    SHR_FUNC_ENTER(unit);

    if (!arg) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &device_info));

    switch (type) {
        case bcmCosqControlBandwidthBurstMax:
        case bcmCosqControlBandwidthBurstMin:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_bandwidth_burst_get(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlEgressPool:
        case bcmCosqControlUCEgressPool:
        case bcmCosqControlMCEgressPool:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_egr_spid_get(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlEgressPoolLimitBytes:
        case bcmCosqControlEgressPoolYellowLimitBytes:
        case bcmCosqControlEgressPoolRedLimitBytes:
        case bcmCosqControlEgressPoolLimitEnable:
        case bcmCosqControlEgressUCQueueSharedLimitBytes:
        case bcmCosqControlEgressMCQueueSharedLimitBytes:
        case bcmCosqControlEgressUCQueueResumeOffsetBytes:
        case bcmCosqControlEgressMCQueueResumeOffsetBytes:
        case bcmCosqControlEgressUCQueueMinLimitBytes:
        case bcmCosqControlEgressMCQueueMinLimitBytes:
        case bcmCosqControlEgressUCSharedDynamicEnable:
        case bcmCosqControlEgressMCSharedDynamicEnable:
        case bcmCosqControlEgressUCQueueLimitEnable:
        case bcmCosqControlEgressMCQueueLimitEnable:
        case bcmCosqControlEgressUCQueueColorLimitDynamicEnable:
        case bcmCosqControlEgressMCQueueColorLimitDynamicEnable:
        case bcmCosqControlEgressUCQueueColorLimitEnable:
        case bcmCosqControlEgressMCQueueColorLimitEnable:
        case bcmCosqControlEgressUCQueueRedLimit:
        case bcmCosqControlEgressUCQueueYellowLimit:
        case bcmCosqControlEgressMCQueueRedLimit:
        case bcmCosqControlEgressMCQueueYellowLimit:
        case bcmCosqControlEgressUCQueueGroupMinEnable:
        case bcmCosqControlEgressMCQueueGroupMinEnable:
        case bcmCosqControlEgressUCQueueGroupMinLimitBytes:
        case bcmCosqControlEgressMCQueueGroupMinLimitBytes:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_egr_queue_get(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlEgressPoolSharedLimitBytes:
        case bcmCosqControlEgressPoolResumeLimitBytes:
        case bcmCosqControlEgressPoolYellowSharedLimitBytes:
        case bcmCosqControlEgressPoolYellowResumeLimitBytes:
        case bcmCosqControlEgressPoolRedSharedLimitBytes:
        case bcmCosqControlEgressPoolRedResumeLimitBytes:
        case bcmCosqControlEgressPoolHighCongestionLimitBytes:
        case bcmCosqControlEgressPoolLowCongestionLimitBytes:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_egr_pool_get(unit, gport, cosq, buffer, type, arg));

            *arg = (*arg) * device_info.mmu_cell_size;
            break;
        case bcmCosqControlEgressPortPoolYellowLimitBytes:
        case bcmCosqControlEgressPortPoolRedLimitBytes:
        case bcmCosqControlEgressPortPoolSharedLimitBytes:
        case bcmCosqControlEgressPortPoolSharedResumeBytes:
        case bcmCosqControlEgressPortPoolYellowResumeBytes:
        case bcmCosqControlEgressPortPoolRedResumeBytes:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_egr_port_pool_get(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlIngressPortPGSharedLimitBytes:
        case bcmCosqControlIngressPortPGMinLimitBytes:
        case bcmCosqControlIngressPortPGHeadroomLimitBytes:
        case bcmCosqControlIngressPortPGResetFloorBytes:
        case bcmCosqControlIngressPortPGResetOffsetBytes:
        case bcmCosqControlIngressPortPGSharedDynamicEnable:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_ing_port_pg_get(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlIngressPortPoolMinLimitBytes:
        case bcmCosqControlIngressPortPoolSharedLimitBytes:
        case bcmCosqControlIngressPortPoolResumeLimitBytes:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_ing_port_pool_get(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlIngressPool:
        case bcmCosqControlIngressHeadroomPool:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_ing_pg_pool_get(unit, gport, cosq, type, arg));
            break;
        case bcmCosqControlIngressPoolLimitBytes:
        case bcmCosqControlIngressPoolResetOffsetLimitBytes:
        case bcmCosqControlIngressHeadroomPoolLimitBytes:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_ing_pool_get(unit, gport, cosq, buffer, type, arg));

            *arg = (*arg) * device_info.mmu_cell_size;
            break;
        case bcmCosqControlDropLimitAlpha:
            SHR_IF_ERR_VERBOSE_EXIT
               (tm_ltsw_cosq_thd_alpha_get(unit, gport, cosq,
                               (bcm_cosq_control_drop_limit_alpha_value_t *)arg));
            break;
        case bcmCosqControlLatencyEcnInstantThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_ltsw_ecn_latency_based_threshold_get(unit, gport, cosq,
                                                          bcmSwitchLatencyEcnMarkInstant,
                                                          &val));
            *arg = (int)val;
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

exit:
    LOG_INFO(BSL_LOG_MODULE,
        (BSL_META_U(unit,
            "gport %d cosq %d buffer %d type %d arg %d\n"),
            gport, cosq, buffer, type, *arg));
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_port_uc_spid_get(
    int unit,
    bcm_port_t port,
    int queue,
    int *spid,
    int *use_qgroup_min)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_port_uc_spid_get(unit, port, queue, spid, use_qgroup_min));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_shared_limit_get(
    int unit,
    int itm,
    int spid,
    int *shared_limit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_shared_limit_get(unit, itm, spid, shared_limit));

exit:
    SHR_FUNC_EXIT()
}

static int
bcm56780_a0_ltsw_cosq_thd_port_inppri_profile_set(
    int unit,
    bcm_port_t port,
    int profile_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_port_inppri_profile_set(unit, port, profile_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_port_inppri_profile_get(
    int unit,
    bcm_port_t port,
    int *profile_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_port_inppri_profile_get(unit, port, profile_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_port_pg_profile_set(
    int unit,
    bcm_port_t port,
    int profile_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_port_pg_profile_set(unit, port, profile_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_port_pg_profile_get(
    int unit,
    bcm_port_t port,
    int *profile_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_port_pg_profile_get(unit, port, profile_id));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_service_pool_set(
    int unit,
    bcm_service_pool_id_t id,
    bcm_cosq_service_pool_t cosq_service_pool)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_service_pool_set(unit, id, cosq_service_pool));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_service_pool_get(
    int unit,
    bcm_service_pool_id_t id,
    bcm_cosq_service_pool_t *cosq_service_pool)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_service_pool_get(unit, id, cosq_service_pool));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_service_pool_override_set(
    int unit,
    bcm_cosq_service_pool_override_type_t type,
    bcm_service_pool_id_t service_pool,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_service_pool_override_set(unit, type, service_pool, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_service_pool_override_get(
    int unit,
    bcm_cosq_service_pool_override_type_t type,
    bcm_service_pool_id_t *service_pool,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_service_pool_override_get(unit, type, service_pool, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_priority_group_mapping_profile_set(
    int unit,
    int profile_index,
    bcm_cosq_priority_group_mapping_profile_type_t type,
    int array_count,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_priority_group_mapping_profile_set(unit, profile_index,
                                                             type, array_count,
                                                             arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_priority_group_mapping_profile_get(
    int unit,
    int profile_index,
    bcm_cosq_priority_group_mapping_profile_type_t type,
    int array_max,
    int *arg,
    int *array_count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_priority_group_mapping_profile_get(unit, profile_index,
                                                             type, array_max,
                                                             arg, array_count));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_port_priority_group_property_set(
    int unit,
    bcm_port_t port,
    int priority_group_id,
    bcm_cosq_port_prigroup_control_t type,
    int arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_port_priority_group_property_set(unit, port,
                                                           priority_group_id,
                                                           type, arg));

exit:
    SHR_FUNC_EXIT()
}

static int
bcm56780_a0_ltsw_cosq_thd_port_priority_group_property_get(
    int unit,
    bcm_port_t port,
    int priority_group_id,
    bcm_cosq_port_prigroup_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_port_priority_group_property_get(unit, port,
                                                           priority_group_id,
                                                           type, arg));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_buffer_id_multi_get(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    bcm_cosq_dir_t direction,
    int array_max,
    bcm_cosq_buffer_id_t *buf_id_array,
    int *array_count)
{
    bcm_port_t local_port;
    int pipe, i, idx;
    int itm_map = 0;
    int itm = 0;
    bcmi_ltsw_cosq_port_map_info_t port_info;
    int ibuf_arr[ITMS_PER_DEV] = {0};
    int ebuf_arr[ITMS_PER_DEV] = {0};
    SHR_FUNC_ENTER(unit);

    if ((direction < bcmCosqIngress) ||
        (direction >= bcmCosqDirectionMaxCount) ||
        (buf_id_array == NULL) ||
        (array_count == NULL)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (!BCM_GPORT_IS_SET(gport) ||
        BCM_GPORT_IS_LOCAL(gport) ||
        BCM_GPORT_IS_MODPORT(gport) ||
        BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) ||
        BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_cosq_localport_resolve(unit, gport, &local_port));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, local_port, &local_port));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_port_map_info_get(unit, local_port, &port_info));

    pipe = port_info.pipe;

    if (array_max <= 0) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    } else {
        *array_count = (direction == bcmCosqIngress) ? 1 :
                        MIN(array_max, ITMS_PER_DEV);
    }

    /*
     * pipes 0,1,6,7 on itm 0
     * pipes 2,3,4,5 on itm 1
     */
    if (0xc3 & (1 << pipe)) {
        itm = 0;
        itm_map |= (1 << itm);
    } else if (0x3c & (1 << pipe)) {
        itm = 1;
        itm_map |= (1 << itm);
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

    idx = 0;
    for (itm = 0; itm < ITMS_PER_DEV; itm++) {
        ebuf_arr[itm] = itm;
        if (itm_map & (1 << itm)) {
            ibuf_arr[idx] = itm;
            idx++;
        }
    }

    for (i = 0; i < *array_count; i++) {
        if (bcmCosqIngress == direction) {
            buf_id_array[i] = ibuf_arr[i];
        } else {
            buf_id_array[i] = ebuf_arr[i];
        }
    }

    for (i = *array_count; i < array_max; i++) {
        buf_id_array[i] = BCM_COSQ_INVALID_BUF_ID;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_cpu_cosq_enable_set(
    int unit,
    bcm_cos_queue_t cosq,
    int enable)
{
    tm_ltsw_cosq_cpu_cosq_config_t cpu_cosq_config = {0};
    int enable_status = 0;
    SHR_FUNC_ENTER(unit);

    if ((cosq < 0) || (cosq >= NUM_CPU_MCAST_QUEUE)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (enable) {
        enable = 1;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_thd_cpu_cosq_enable_get(unit, cosq, &enable_status));

    if (enable == enable_status) {
        SHR_EXIT();
    }

    /* When enabled, restore the Min and Shared from the cached value */
    if (!enable) {
        SHR_IF_ERR_VERBOSE_EXIT
            (tm_ltsw_cosq_thd_cpu_cosq_enable_get(unit, cosq, &cpu_cosq_config));
        cpu_q_min_limit[unit][cosq] = cpu_cosq_config.q_min_limit;
        cpu_q_shared_limit[unit][cosq] = cpu_cosq_config.q_shared_limit;
        cpu_q_limit_dynamic[unit][cosq] = cpu_cosq_config.q_limit_dynamic;
        cpu_q_limit_enable[unit][cosq] = cpu_cosq_config.q_limit_enable;
        cpu_q_color_limit_enable[unit][cosq] = cpu_cosq_config.q_color_limit_enable;
    }

    cpu_cosq_config.q_min_limit
        = enable ? cpu_q_min_limit[unit][cosq] : 0;
    cpu_cosq_config.q_shared_limit
        = enable ? cpu_q_shared_limit[unit][cosq] : 0;
    cpu_cosq_config.q_limit_dynamic
        = enable ? cpu_q_limit_dynamic[unit][cosq] : 0;
    cpu_cosq_config.q_limit_enable
        = enable ? cpu_q_limit_enable[unit][cosq] : 1;
    cpu_cosq_config.q_color_limit_enable
        = enable ? cpu_q_color_limit_enable[unit][cosq] : 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_cosq_thd_cpu_cosq_enable_set(unit, cosq, &cpu_cosq_config));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_cpu_cosq_enable_get(
    int unit,
    bcm_cos_queue_t cosq,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (cosq_thd_cpu_cosq_enable_get(unit, cosq, enable));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_cosq_thd_byte_to_cell(
    int unit,
    uint32_t bytes,
    int *cells)
{
    *cells = cosq_thd_byte_to_cell(bytes);

    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_cosq_thd_cell_to_byte(
    int unit,
    uint32_t cells,
    int *bytes)
{
    *bytes = cosq_thd_cell_to_byte(cells);

    return SHR_E_NONE;
}

/*!
 * \brief Cosq_thd driver function variable for bcm56780_a0 device.
 */
static mbcm_ltsw_cosq_thd_drv_t bcm56780_a0_ltsw_cosq_thd_drv = {
    .cosq_thd_init = bcm56780_a0_ltsw_cosq_thd_init,
    .cosq_thd_detach = bcm56780_a0_ltsw_cosq_thd_detach,
    .cosq_thd_dynamic_get = bcm56780_a0_ltsw_cosq_thd_dynamic_get,
    .cosq_thd_port_guarantee_reset = bcm56780_a0_ltsw_cosq_thd_port_guarantee_reset,
    .cosq_thd_control_set = bcm56780_a0_ltsw_cosq_thd_control_set,
    .cosq_thd_control_get = bcm56780_a0_ltsw_cosq_thd_control_get,
    .cosq_thd_port_uc_spid_get = bcm56780_a0_ltsw_cosq_thd_port_uc_spid_get,
    .cosq_thd_shared_limit_get = bcm56780_a0_ltsw_cosq_thd_shared_limit_get,
    .cosq_thd_port_inppri_profile_set = bcm56780_a0_ltsw_cosq_thd_port_inppri_profile_set,
    .cosq_thd_port_inppri_profile_get = bcm56780_a0_ltsw_cosq_thd_port_inppri_profile_get,
    .cosq_thd_port_pg_profile_set = bcm56780_a0_ltsw_cosq_thd_port_pg_profile_set,
    .cosq_thd_port_pg_profile_get = bcm56780_a0_ltsw_cosq_thd_port_pg_profile_get,
    .cosq_thd_service_pool_set = bcm56780_a0_ltsw_cosq_thd_service_pool_set,
    .cosq_thd_service_pool_get = bcm56780_a0_ltsw_cosq_thd_service_pool_get,
    .cosq_thd_service_pool_override_set = bcm56780_a0_ltsw_cosq_thd_service_pool_override_set,
    .cosq_thd_service_pool_override_get = bcm56780_a0_ltsw_cosq_thd_service_pool_override_get,
    .cosq_thd_priority_group_mapping_profile_set = bcm56780_a0_ltsw_cosq_thd_priority_group_mapping_profile_set,
    .cosq_thd_priority_group_mapping_profile_get = bcm56780_a0_ltsw_cosq_thd_priority_group_mapping_profile_get,
    .cosq_thd_port_priority_group_property_set = bcm56780_a0_ltsw_cosq_thd_port_priority_group_property_set,
    .cosq_thd_port_priority_group_property_get = bcm56780_a0_ltsw_cosq_thd_port_priority_group_property_get,
    .cosq_thd_buffer_id_multi_get = bcm56780_a0_ltsw_cosq_thd_buffer_id_multi_get,
    .cosq_thd_cpu_cosq_enable_set = bcm56780_a0_ltsw_cosq_thd_cpu_cosq_enable_set,
    .cosq_thd_cpu_cosq_enable_get = bcm56780_a0_ltsw_cosq_thd_cpu_cosq_enable_get,
    .cosq_thd_byte_to_cell = bcm56780_a0_ltsw_cosq_thd_byte_to_cell,
    .cosq_thd_cell_to_byte = bcm56780_a0_ltsw_cosq_thd_cell_to_byte,
};

/******************************************************************************
 * Public functions
 */

int
bcm56780_a0_ltsw_cosq_thd_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_cosq_thd_drv_set(unit, &bcm56780_a0_ltsw_cosq_thd_drv));

exit:
    SHR_FUNC_EXIT();
}

