/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/flexctr.h>

#include <bcm_int/ltsw/flexctr_int.h>
#include <bcm_int/ltsw/mbcm/flexctr.h>
#include <bcm_int/ltsw/chip/bcm56780_a0/variant_dispatch.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_FLEXCTR

/*!
 * \brief Flex counter trigger interval database.
 */
static bcmint_flexctr_interval_info_t bcm56780_a0_ltsw_flexctr_interval_db[] = {
    /* Unlimited collection. */
    {bcmFlexctrTriggerIntervalUnlimited},
    /* 100 nanosecond interval. */
    {bcmFlexctrTriggerInterval100ns},
    /* 500 nanosecond interval. */
    {bcmFlexctrTriggerInterval500ns},
    /* 1 microsecond interval. */
    {bcmFlexctrTriggerInterval1us},
    /* 10 microsecond interval. */
    {bcmFlexctrTriggerInterval10us},
    /* 100 microsecond interval. */
    {bcmFlexctrTriggerInterval100us},
    /* 1 millisecond interval. */
    {bcmFlexctrTriggerInterval1ms},
    /* 10 millisecond interval. */
    {bcmFlexctrTriggerInterval10ms},
    /* 100 millisecond interval. */
    {bcmFlexctrTriggerInterval100ms},
    /* 1 second interval. */
    {bcmFlexctrTriggerInterval1s},
    /* 10 second interval. */
    {bcmFlexctrTriggerInterval10s},
};

/*!
 * \brief Flex counter action scale enumeration mapping.
 */
static bcmint_flexctr_enum_map_t bcm56780_a0_ltsw_flexctr_action_scale_enum[] = {
    { SCALE_INFINITEs, 0 },     /* bcmFlexctrTriggerIntervalUnlimited */
    { SCALE_128_NSECs, 1 },     /* bcmFlexctrTriggerInterval100ns */
    { SCALE_512_NSECs, 2 },     /* bcmFlexctrTriggerInterval500ns */
    { SCALE_1024_NSECs, 3 },    /* bcmFlexctrTriggerInterval1us */
    { SCALE_8_USECs, 4 },       /* bcmFlexctrTriggerInterval10us */
    { SCALE_131_USECs, 5 },     /* bcmFlexctrTriggerInterval100us */
    { SCALE_1_MSECs, 6 },       /* bcmFlexctrTriggerInterval1ms */
    { SCALE_8_MSECs, 7 },       /* bcmFlexctrTriggerInterval10ms */
    { SCALE_134_MSECs, 8 },     /* bcmFlexctrTriggerInterval100ms */
    { SCALE_1_SECs, 9 },        /* bcmFlexctrTriggerInterval1s */
    { SCALE_8_SECs, 10 },       /* bcmFlexctrTriggerInterval10s */
};

/******************************************************************************
 * Private functions
 */

static int
bcm56780_a0_ltsw_flexctr_trigger_interval_validate(
    int unit,
    int interval)
{
    bcmint_flexctr_interval_info_t *interval_db, *ii;
    size_t i, count;

    count = COUNTOF(bcm56780_a0_ltsw_flexctr_interval_db);
    interval_db = bcm56780_a0_ltsw_flexctr_interval_db;

    if (interval < bcmFlexctrTriggerIntervalUnlimited ||
        interval >= bcmFlexctrTriggerIntervalCount) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Invalid trigger interval %d\n"),
                   interval));
        return SHR_E_PARAM;
    }

    for (i = 0; i < count; i++) {
        ii = &(interval_db[i]);
        if (interval == ii->interval) {
            break;
        }
    }

    /* Not found. */
    if (i >= count) {
        LOG_INFO(BSL_LOG_MODULE,
                 (BSL_META_U(unit, "Flex counter interval %d not found\n"),
                  interval));

        return SHR_E_UNAVAIL;
    }

    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_flexctr_action_scale_enum_map_get(
    int unit,
    const bcmint_flexctr_enum_map_t **map,
    uint32_t *count)
{
    if ((count == NULL) || (map == NULL)) {
        return SHR_E_PARAM;
    }

    *map = bcm56780_a0_ltsw_flexctr_action_scale_enum;
    *count = COUNTOF(bcm56780_a0_ltsw_flexctr_action_scale_enum);
    return SHR_E_NONE;
}

/*!
 * \brief Flexctr driver function variable for bcm56780_a0 device.
 */
static mbcm_ltsw_flexctr_drv_t bcm56780_a0_ltsw_flexctr_drv = {
    .flexctr_trigger_interval_validate = bcm56780_a0_ltsw_flexctr_trigger_interval_validate,
    .flexctr_action_scale_enum_map_get = bcm56780_a0_ltsw_flexctr_action_scale_enum_map_get
};

/******************************************************************************
 * Public functions
 */

int
bcm56780_a0_ltsw_flexctr_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv_set(unit, &bcm56780_a0_ltsw_flexctr_drv));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm56780_a0_ltsw_variant_drv_attach(unit, BCM56780_A0_LTSW_VARIANT_FLEXCTR));

exit:
    SHR_FUNC_EXIT();
}

