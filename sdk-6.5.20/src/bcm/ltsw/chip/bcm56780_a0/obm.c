/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm/switch.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/mbcm/obm.h>

#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/tm/obm.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_COSQ

/******************************************************************************
 * Private functions
 */


#define OBM_CLASSIFIER_NUM_ENTRY_DSCP       64
#define OBM_CLASSIFIER_NUM_ENTRY_MPLS       8
#define OBM_CLASSIFIER_NUM_ENTRY_ETAG       8
#define OBM_CLASSIFIER_NUM_ENTRY_VLAN       8
#define OBM_CLASSIFIER_NUM_ENTRY_HIGIG3     16
#define OBM_CLASSIFIER_NUM_ENTRY_FIELD      4

static const char *obm_pkt_pri_type[] =
{
    PKT_PRI_TYPE_DSCPs,
    PKT_PRI_TYPE_MPLSs,
    PKT_PRI_TYPE_ETAGs,
    PKT_PRI_TYPE_VLANs,
    NULL,
    NULL,
    PKT_PRI_TYPE_HIGIG3s,
};

static int
obm_get_pm_from_phy_port(int pnum)
{
    return ((pnum + 7) / 8);
}

static int
obm_pm_validate(int unit, int pm_id, bool *valid)
{
    bcm_pbmp_t pbmp;
    int pm = -1;
    int port = 0;

    SHR_FUNC_ENTER(unit);

    *valid = FALSE;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_dev_phys_pbmp(unit, &pbmp));

    BCM_PBMP_ITER(pbmp, port) {
        pm = obm_get_pm_from_phy_port(port);
        if (pm == pm_id) {
            *valid = TRUE;
            SHR_EXIT();
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
obm_pkt_pri_type_get(int unit,
                     int piority_type,
                     const char **sym_val)
{
    int table_len = sizeof(obm_pkt_pri_type) /
        sizeof(obm_pkt_pri_type[0]);

    if (piority_type < 0 || piority_type >= table_len) {
        return SHR_E_PARAM;
    }

    *sym_val = obm_pkt_pri_type[piority_type];

    return SHR_E_NONE;
}

static int
obm_classifier_max_entry_get(
    int unit,
    bcm_switch_obm_classifier_type_t switch_obm_classifier_type,
    int *max_count)
{
    SHR_FUNC_ENTER(unit);

    switch (switch_obm_classifier_type) {
        case bcmSwitchObmClassifierDscp:
            *max_count = OBM_CLASSIFIER_NUM_ENTRY_DSCP;
            break;
        case bcmSwitchObmClassifierMpls:
            *max_count = OBM_CLASSIFIER_NUM_ENTRY_MPLS;
            break;
        case bcmSwitchObmClassifierEtag:
            *max_count = OBM_CLASSIFIER_NUM_ENTRY_ETAG;
            break;
        case bcmSwitchObmClassifierVlan:
            *max_count = OBM_CLASSIFIER_NUM_ENTRY_VLAN;
            break;
        case bcmSwitchObmClassifierHigig3:
            *max_count = OBM_CLASSIFIER_NUM_ENTRY_HIGIG3;
            break;
        case bcmSwitchObmClassifierField:
            *max_count = OBM_CLASSIFIER_NUM_ENTRY_FIELD;
            break;
        case bcmSwitchObmClassifierHigig2:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}


static int
bcm56780_a0_ltsw_obm_port_max_usage_mode_get(
    int unit,
    bcm_port_t port,
    bcm_obm_max_watermark_mode_t *obm_wm_mode)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_obm_port_max_usage_mode_get(unit, port, obm_wm_mode));

exit:
    SHR_FUNC_EXIT();

}

static int
bcm56780_a0_ltsw_obm_port_max_usage_mode_set(
    int unit,
    bcm_port_t port,
    bcm_obm_max_watermark_mode_t obm_wm_mode)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_obm_port_max_usage_mode_set(unit, port, obm_wm_mode));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_obm_port_pri_traffic_class_mapping_get(
    int unit,
    bcm_port_t port,
    bcm_obm_lookup_priority_type_t piority_type,
    int priority,
    bcm_obm_traffic_class_t *obm_tc)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_obm_port_pri_traffic_class_mapping_set(
    int unit,
    bcm_port_t port,
    bcm_obm_lookup_priority_type_t piority_type,
    int priority,
    bcm_obm_traffic_class_t obm_tc)
{
    return SHR_E_UNAVAIL;
}

static int
bcm56780_a0_ltsw_obm_port_control_get(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_obm_port_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmiObmPortControlHeaderType:
        case bcmiObmPortControlDscpMapEnable:
        case bcmiObmPortControlMplsMapEnable:
        case bcmiObmPortControlEtagMapEnable:
        case bcmiObmPortControlDefaultPktPri:
        case bcmiObmPortControlInnerTpidEnable:
        case bcmiObmPortControlOuterTpid0Enable:
        case bcmiObmPortControlOuterTpid1Enable:
        case bcmiObmPortControlOuterTpid2Enable:
        case bcmiObmPortControlOuterTpid3Enable:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_obm_port_pkt_parse_get(unit, port, type, arg, false));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_obm_port_control_set(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_obm_port_control_t type,
    int arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmiObmPortControlHeaderType:
        case bcmiObmPortControlDscpMapEnable:
        case bcmiObmPortControlMplsMapEnable:
        case bcmiObmPortControlEtagMapEnable:
        case bcmiObmPortControlDefaultPktPri:
        case bcmiObmPortControlInnerTpidEnable:
        case bcmiObmPortControlOuterTpid0Enable:
        case bcmiObmPortControlOuterTpid1Enable:
        case bcmiObmPortControlOuterTpid2Enable:
        case bcmiObmPortControlOuterTpid3Enable:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_obm_port_pkt_parse_set(unit, port, type, arg));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_obm_pm_port_control_get(
    int unit,
    int pm_id,
    bcmi_ltsw_obm_port_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmiObmPortControlInnerTpid:
        case bcmiObmPortControlOuterTpid0:
        case bcmiObmPortControlOuterTpid1:
        case bcmiObmPortControlOuterTpid2:
        case bcmiObmPortControlOuterTpid3:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_obm_pm_pkt_parse_tpid_get(unit, pm_id, type, arg));
            break;
        case bcmiObmPortControlEtagEthertype:
        case bcmiObmPortControlVntagEthertype:
        case bcmiObmPortControlHigig3Ethertype:
            SHR_IF_ERR_VERBOSE_EXIT
                (tm_ltsw_obm_pm_pkt_parse_ethertype_get(unit, pm_id, type, arg));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_obm_pm_port_control_set(
    int unit,
    int pm_id,
    bcmi_ltsw_obm_port_control_t type,
    int arg)
{
    int from_pm, to_pm, pm;
    bool valid = FALSE;

    SHR_FUNC_ENTER(unit);

    if (pm_id == -1) {
        from_pm = 1;
        to_pm = 21;
    } else if ((pm_id >= 1) && (pm_id <=  21)) {
        from_pm = to_pm = pm_id;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    for (pm = from_pm; pm <= to_pm; pm++ ) {
        SHR_IF_ERR_VERBOSE_EXIT
            (obm_pm_validate(unit, pm, &valid));

        if(valid) {
            switch (type) {
                case bcmiObmPortControlInnerTpid:
                case bcmiObmPortControlOuterTpid0:
                case bcmiObmPortControlOuterTpid1:
                case bcmiObmPortControlOuterTpid2:
                case bcmiObmPortControlOuterTpid3:
                    SHR_IF_ERR_VERBOSE_EXIT
                        (tm_ltsw_obm_pm_pkt_parse_tpid_set(unit, pm, type, arg));
                    break;
                case bcmiObmPortControlEtagEthertype:
                case bcmiObmPortControlVntagEthertype:
                case bcmiObmPortControlHigig3Ethertype:
                    SHR_IF_ERR_VERBOSE_EXIT
                        (tm_ltsw_obm_pm_pkt_parse_ethertype_set(unit, pm, type, arg));
                    break;
                default:
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_obm_classifier_mapping_multi_get(
    int unit,
    bcm_gport_t gport,
    bcm_switch_obm_classifier_type_t switch_obm_classifier_type,
    int array_max,
    bcm_switch_obm_classifier_t *switch_obm_classifier,
    int *array_count)
{
    int piority_type, piority, obm_tc, i, max_count;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (obm_classifier_max_entry_get(unit, switch_obm_classifier_type,
                                      &max_count));

    switch (switch_obm_classifier_type) {
        case bcmSwitchObmClassifierDscp:
        case bcmSwitchObmClassifierMpls:
        case bcmSwitchObmClassifierEtag:
        case bcmSwitchObmClassifierVlan:
        case bcmSwitchObmClassifierHigig3:
            if (array_max > max_count) {
                *array_count = max_count;
            } else {
                *array_count = array_max;
            }
            for (i = 0; i < *array_count; i++) {
                piority = switch_obm_classifier[i].obm_code_point;
                piority_type = switch_obm_classifier_type;
                SHR_IF_ERR_VERBOSE_EXIT
                    (tm_ltsw_obm_port_pkt_pri_tc_map_get(unit, gport, piority_type,
                                                         piority, &obm_tc, false));

                switch_obm_classifier[i].obm_priority = obm_tc;
            }
            break;
        case bcmSwitchObmClassifierField:
            if (array_max > max_count) {
                *array_count = max_count;
            } else {
                *array_count = array_max;
            }

            for (i = 0; i < *array_count; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (tm_ltsw_obm_pm_pkt_parse_user_define_ethertype_get(
                        unit, gport, i, &switch_obm_classifier[i]));
            }
            break;
        case bcmSwitchObmClassifierHigig2:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_obm_classifier_mapping_multi_set(
    int unit,
    bcm_gport_t gport,
    bcm_switch_obm_classifier_type_t switch_obm_classifier_type,
    int array_count,
    bcm_switch_obm_classifier_t *switch_obm_classifier)
{
    int piority_type, piority, obm_tc, i, max_count;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (obm_classifier_max_entry_get(unit, switch_obm_classifier_type,
                                      &max_count));

    switch (switch_obm_classifier_type) {
        case bcmSwitchObmClassifierDscp:
        case bcmSwitchObmClassifierMpls:
        case bcmSwitchObmClassifierEtag:
        case bcmSwitchObmClassifierVlan:
        case bcmSwitchObmClassifierHigig3:
            if (array_count > max_count) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            for (i = 0; i < array_count; i++) {
                piority_type = switch_obm_classifier_type;
                piority = switch_obm_classifier[i].obm_code_point;
                obm_tc = switch_obm_classifier[i].obm_priority;
                SHR_IF_ERR_VERBOSE_EXIT
                    (tm_ltsw_obm_port_pkt_pri_tc_map_set(unit, gport, piority_type,
                                                         piority, obm_tc));
            }
            break;
        case bcmSwitchObmClassifierField:
            if (array_count > max_count) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }

            for (i = 0; i < array_count; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (tm_ltsw_obm_pm_pkt_parse_user_define_ethertype_set(
                         unit, gport, i, &switch_obm_classifier[i]));
            }
            break;
        case bcmSwitchObmClassifierHigig2:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_obm_traffic_class_pfc_priority_mapping_get(
    int unit,
    bcm_port_t port,
    bcm_obm_traffic_class_t obm_traffic_class,
    int max_pri_count,
    int *priority_list,
    int *pri_count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_obm_traffic_class_pfc_priority_mapping_get(unit, port, obm_traffic_class, max_pri_count, priority_list, pri_count));

exit:
    SHR_FUNC_EXIT();

}

static int
bcm56780_a0_ltsw_obm_traffic_class_pfc_priority_mapping_set(
    int unit,
    bcm_port_t port,
    bcm_obm_traffic_class_t obm_traffic_class,
    int max_pri_count,
    int *priority_list)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_obm_traffic_class_pfc_priority_mapping_set(unit, port, obm_traffic_class, max_pri_count, priority_list));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_obm_init(int unit)
{
    static tm_ltsw_obm_chip_driver_t bcm56780_a0_obm_drv_cb = {
        .pkt_pri_type_get = obm_pkt_pri_type_get,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_obm_init(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_obm_chip_driver_register(unit, &bcm56780_a0_obm_drv_cb));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_obm_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_obm_detach(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_obm_chip_driver_deregister(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_obm_port_fc_enable_set(
    int unit,
    int lport,
    int fc_type)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tm_ltsw_obm_port_fc_enable_set(unit, lport, fc_type));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Obm driver function variable for bcm56780_a0 device.
 */
static mbcm_ltsw_obm_drv_t bcm56780_a0_ltsw_obm_drv = {
    .obm_port_max_usage_mode_get = bcm56780_a0_ltsw_obm_port_max_usage_mode_get,
    .obm_port_max_usage_mode_set = bcm56780_a0_ltsw_obm_port_max_usage_mode_set,
    .obm_port_pri_traffic_class_mapping_get = bcm56780_a0_ltsw_obm_port_pri_traffic_class_mapping_get,
    .obm_port_pri_traffic_class_mapping_set = bcm56780_a0_ltsw_obm_port_pri_traffic_class_mapping_set,
    .obm_port_control_get = bcm56780_a0_ltsw_obm_port_control_get,
    .obm_port_control_set = bcm56780_a0_ltsw_obm_port_control_set,
    .obm_pm_port_control_get = bcm56780_a0_ltsw_obm_pm_port_control_get,
    .obm_pm_port_control_set = bcm56780_a0_ltsw_obm_pm_port_control_set,
    .obm_classifier_mapping_multi_get = bcm56780_a0_ltsw_obm_classifier_mapping_multi_get,
    .obm_classifier_mapping_multi_set = bcm56780_a0_ltsw_obm_classifier_mapping_multi_set,
    .obm_traffic_class_pfc_priority_mapping_get = bcm56780_a0_ltsw_obm_traffic_class_pfc_priority_mapping_get,
    .obm_traffic_class_pfc_priority_mapping_set = bcm56780_a0_ltsw_obm_traffic_class_pfc_priority_mapping_set,
    .obm_init = bcm56780_a0_ltsw_obm_init,
    .obm_detach = bcm56780_a0_ltsw_obm_detach,
    .obm_port_fc_enable_set = bcm56780_a0_ltsw_obm_port_fc_enable_set
};

/******************************************************************************
 * Public functions
 */

int
bcm56780_a0_ltsw_obm_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_obm_drv_set(unit, &bcm56780_a0_ltsw_obm_drv));

exit:
    SHR_FUNC_EXIT();
}

