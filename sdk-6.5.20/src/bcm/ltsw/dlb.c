/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/dlb.h>
#include <bcm_int/ltsw/generated/dlb_ha.h>
#include <bcm_int/ltsw/dlb_int.h>
#include <bcm_int/ltsw/mbcm/dlb.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/cosq.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/issu.h>

#include <sal/sal_types.h>
#include <sal/sal_mutex.h>
#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_DLB

/*! Signature for Dynamic Load Balance. */
#define DLB_SIGNATURE 0xd1bdb

/*! Unused DLB Id. */
#define DLB_ID_UNUSED (0)

/*!
 * \brief DLB Id status.
 */
/*! Used DLB Id. */
#define DLB_ID_USED (1 << 0)

/*! Reserved DLB Id. */
#define DLB_ID_RESERVED (1 << 1)

/*! DLB Id is configured. */
#define DLB_ID_CONFIGURED (1 << 2)

/*! DLB Id is monitored. */
#define DLB_ID_MONITORED (1 << 3)

/*! DGM is enabled on this DLB Id. */
#define DLB_ID_DGM_ENABLED (1 << 4)

/*! Maximum of DLB quality map profile. */
#define DLB_QUALITY_MAP_PROFILE_MAX 8

/*!
 * \brief Generic database of Dynamic Load Balance.
 */
typedef struct dlb_db_s {

    /*! DLB signature. */
    uint32_t signature;

    /*! DLB module lock. */
    sal_mutex_t lock;

    /*! Chip-specific sub-features for DLB. */
    uint32_t features;

    /*! Type-based capability for DLB. */
    bcmi_ltsw_dlb_capability_t capability[bcmi_dlb_type_count];

    /*! Type-based information for each DLB instance Id. */
    bcmint_dlb_info_t *info[bcmi_dlb_type_count];

    /*! DLB member quality map profile id count. */
    int quality_map_profile_id_count;

    /*! DLB member quality map profile database. */
    bcmint_dlb_quality_map_profile_t *quality_map_profile;

    /*! Type-based control information for DLB. */
    bcmint_dlb_ctrl_info_t *ctrl_info[bcmi_dlb_type_count];

} dlb_db_t;

/*!
 * \brief The Dlb database.
 */
static dlb_db_t bcmi_ltsw_dlb_db[BCM_MAX_NUM_UNITS];

/******************************************************************************
 * Private functions
 */


/*!
 * \brief Create protection mutex for DLB.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_lock_create(int unit)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];

    SHR_FUNC_ENTER(unit);

    if (dlb_db->lock == NULL) {
        dlb_db->lock = sal_mutex_create("bcmDlbMutex");
        SHR_NULL_CHECK(dlb_db->lock, SHR_E_MEMORY);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy protection mutex for DLB.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 */
static int
dlb_lock_destroy(int unit)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];

    SHR_FUNC_ENTER(unit);

    if (dlb_db->lock != NULL) {
        sal_mutex_destroy(dlb_db->lock);
        dlb_db->lock = NULL;
    }

    SHR_FUNC_EXIT();
}


/*!
 * \brief Dlb mutax lock.
 *
 * \param [in] unit Unit Number.
 */
static void
dlb_lock(int unit)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];

    if (dlb_db->lock) {
        sal_mutex_take(dlb_db->lock, SAL_MUTEX_FOREVER);
    }
}

/*!
 * \brief Dlb mutax unlock.
 *
 * \param [in] unit Unit Number.
 */
static void
dlb_unlock(int unit)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];

    if (dlb_db->lock) {
        sal_mutex_give(dlb_db->lock);
    }
}

/*!
 * \brief De-init the dlb module based on DLB type.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_db_type_deinit(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmi_ltsw_dlb_capability_t *cap = &dlb_db->capability[dlb_type];

    SHR_FUNC_ENTER(unit);

    sal_memset(dlb_db->info[dlb_type], 0,
               sizeof(bcmint_dlb_info_t) * (cap->id_max + 1));

    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Judge the dlb db is initialized or not.
 *
 * \param [in] unit Unit Number.
 *
 * \retval true initialized.
 * \retval false non-initialized.
 */
static bool
dlb_db_is_initialized(int unit)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];

    if (dlb_db->signature == DLB_SIGNATURE) {
        return true;
    }

    return false;
}

/*!
 * \brief Validate the chip feature for Dynamic Load Balance functionality.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_validate_feature(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (!ltsw_feature(unit, LTSW_FT_DLB)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the chip feature for Dynamic Group Multipath functionality.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_validate_feature_dgm(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (!ltsw_feature(unit, LTSW_FT_DLB_DGM)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the DLB component initialization status.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_validate_initialization(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (!dlb_db_is_initialized(unit)) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the DLB type for a unit.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_validate_type(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    uint32_t dlb_features = dlb_db->features;
    bool valid;

    SHR_FUNC_ENTER(unit);

    switch (dlb_type) {
        case bcmi_dlb_type_fp_trunk:
            valid = dlb_features & BCMI_LTSW_DLB_F_FP_TRUNK ? true : false;
            break;
        case bcmi_dlb_type_fabric_trunk:
            valid = dlb_features & BCMI_LTSW_DLB_F_FABRIC_TRUNK ? true : false;
            break;
        case bcmi_dlb_type_ecmp:
            valid = dlb_features & BCMI_LTSW_DLB_F_ECMP ? true : false;
            break;
        default:
            valid = false;
            break;
    }
    if (!valid) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the DLB type and Id for a unit.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_validate_type_id(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmi_ltsw_dlb_capability_t *cap = &dlb_db->capability[dlb_type];
    bcmint_dlb_info_t *dlb_info = NULL;

    SHR_FUNC_ENTER(unit);

    if (dlb_db->info[dlb_type] == NULL) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (dlb_id < cap->id_min || dlb_id > cap->id_max) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dlb_info = &dlb_db->info[dlb_type][dlb_id];

    if (!(dlb_info->flags & DLB_ID_USED)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the DLB Id status is configured or not.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_validate_type_id_configured(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmint_dlb_info_t *dlb_info = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type_id(unit, dlb_type, dlb_id));

    dlb_info = &dlb_db->info[dlb_type][dlb_id];
    if (!(dlb_info->flags & DLB_ID_CONFIGURED)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the DLB monitoring configurations.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] monitor DLB monitoring configurations.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_validate_monitor(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_monitor_t *monitor)
{
    SHR_FUNC_ENTER(unit);

    if (monitor) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_dlb_monitor_validate(unit, dlb_type, monitor));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the DLB member port is local or not.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_validate_member_port(
    int unit,
    int port)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &port));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the type-based DLB member port attributes.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] attribute Type-based DLB member port attribute.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_validate_member_attribute(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_member_attribute_t *attribute)
{
    int invalid = 0;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(attribute, SHR_E_PARAM);

    if (attribute->scaling_factor == BCMI_LTSW_DLB_SCALING_FACTOR_INVALID) {
        invalid++;
    }
    if (attribute->load_weight == BCMI_LTSW_DLB_LOAD_WEIGHT_INVALID) {
        invalid++;
    }
    if (attribute->qsize_weight == BCMI_LTSW_DLB_QUEUE_SIZE_WEIGHT_INVALID) {
        invalid++;
    }

    if (invalid != 0 && invalid != 3) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (invalid == 0) {
        if (attribute->load_weight < 0 ||
            attribute->load_weight > 100) {
            return BCM_E_PARAM;
        }
        if (attribute->qsize_weight < 0 ||
            attribute->qsize_weight > 100) {
            return BCM_E_PARAM;
        }
        if ((attribute->load_weight + attribute->qsize_weight) < 0 ||
            (attribute->load_weight + attribute->qsize_weight) > 100) {
            return BCM_E_PARAM;
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_member_attribute_validate(unit, dlb_type, attribute));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the DLB member.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] member The DLB member.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_validate_member(
    int unit,
    bcmi_ltsw_dlb_member_t *member)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(member, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_member_port(unit, member->port_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the configurations for DLB functionalities.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_config DLB configurations.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_validate_config(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_config_t *dlb_config)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    uint32_t dlb_features = dlb_db->features;
    bool valid = false;
    int i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(dlb_config, SHR_E_PARAM);

    if (dlb_config->num_paths != 0) {
        for (i = 0; i < dlb_config->num_paths; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (dlb_validate_member(unit, &dlb_config->member[i]));
        }
    }

    if (dlb_config->alternate_num_paths != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (dlb_validate_feature_dgm(unit));

        switch (dlb_type) {
            case bcmi_dlb_type_fp_trunk:
            case bcmi_dlb_type_fabric_trunk:
                valid = dlb_features & BCMI_LTSW_DLB_F_TRUNK_DGM ? true : false;
                break;
            case bcmi_dlb_type_ecmp:
                valid = dlb_features & BCMI_LTSW_DLB_F_ECMP_DGM ? true : false;
                break;
            default:
                valid = false;
                break;
        }

        if (!valid) {
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        }

        for (i = 0; i < dlb_config->alternate_num_paths; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (dlb_validate_member(unit, &dlb_config->alternate_member[i]));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_config_validate(unit, dlb_type, dlb_config));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create protection mutex for DLB.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_db_init(int unit)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmi_ltsw_dlb_type_t dlb_type;
    uint32_t features;
    bcmi_ltsw_dlb_capability_t cap;
    void *ptr = NULL;
    uint32_t ha_alloc_size = 0, ha_req_size = 0;
    uint32_t ha_instance_size = 0, ha_array_size = 0;
    shr_ha_sub_id info_sub_comp_id[] = {
        BCMINT_DLB_INFO_FP_TRUNK_SUB_COMP_ID,
        BCMINT_DLB_INFO_FABRIC_TRUNK_SUB_COMP_ID,
        BCMINT_DLB_INFO_ECMP_SUB_COMP_ID
    };
    const char *info_blk_ids[] = {
        "bcmDlbInfoFpTrunk",
        "bcmDlbInfoFabricTrunk",
        "bcmDlbInfoEcmp"
    };
    shr_ha_sub_id ctrl_info_sub_comp_id[] = {
        BCMINT_DLB_CTRL_INFO_FP_TRUNK_SUB_COMP_ID,
        BCMINT_DLB_CTRL_INFO_FABRIC_TRUNK_SUB_COMP_ID,
        BCMINT_DLB_CTRL_INFO_ECMP_SUB_COMP_ID
    };
    const char *ctrl_info_blk_ids[] = {
        "bcmDlbCtrlInfoFpTrunk",
        "bcmDlbCtrlInfoFabricTrunk",
        "bcmDlbCtrlInfoEcmp"
    };
    shr_ha_sub_id qmap_prof_sub_comp_id = BCMINT_DLB_QUALITY_MAP_PROFILE_SUB_COMP_ID;
    const char *qmap_prof_blk_id = "bcmDlbQmapProfile";
    int warm = bcmi_warmboot_get(unit);
    bcmi_ltsw_cosq_device_info_t cosq_dev_info;
    int bytes_per_cell;
    bcmint_dlb_ctrl_info_t *ctrl_info = NULL;
    int rv;

    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_feature_get(unit, &features));
    dlb_db->features = features;

    if (features) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_cosq_device_info_get(unit, &cosq_dev_info));
        bytes_per_cell = cosq_dev_info.mmu_cell_size;

        for (dlb_type = bcmi_dlb_type_fp_trunk;
             dlb_type < bcmi_dlb_type_count; dlb_type++) {
            rv = dlb_validate_type(unit, dlb_type);
            if (SHR_FAILURE(rv)) {
                continue;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (mbcm_ltsw_dlb_capability_get(unit, dlb_type, &cap));

            dlb_db->capability[dlb_type] = cap;

            ha_array_size = cap.id_max + 1;
            ha_instance_size = sizeof(bcmint_dlb_info_t);
            ha_req_size = ha_array_size * ha_instance_size;
            ha_alloc_size = ha_req_size;
            ptr = bcmi_ltsw_ha_mem_alloc(unit,
                                         BCMI_HA_COMP_ID_DLB,
                                         info_sub_comp_id[dlb_type],
                                         info_blk_ids[dlb_type],
                                         &ha_alloc_size);
            SHR_NULL_CHECK(ptr, SHR_E_MEMORY);
            SHR_IF_ERR_VERBOSE_EXIT((ha_alloc_size < ha_req_size) ?
                                    SHR_E_MEMORY : SHR_E_NONE);
            if (!warm) {
                sal_memset(ptr, 0, ha_alloc_size);
            }
            rv = bcmi_ltsw_issu_struct_info_report(unit,
                                         BCMI_HA_COMP_ID_DLB,
                                         info_sub_comp_id[dlb_type],
                                         0, ha_instance_size, ha_array_size,
                                         BCMINT_DLB_INFO_T_ID);
            if (rv != SHR_E_EXISTS) {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            dlb_db->info[dlb_type] = ptr;
        }
        for (dlb_type = bcmi_dlb_type_fp_trunk;
             dlb_type < bcmi_dlb_type_count; dlb_type++) {
            rv = dlb_validate_type(unit, dlb_type);
            if (SHR_FAILURE(rv)) {
                continue;
            }
            ha_array_size = 1;
            ha_instance_size = sizeof(bcmint_dlb_ctrl_info_t);
            ha_req_size = ha_array_size * ha_instance_size;
            ha_alloc_size = ha_req_size;
            ptr = bcmi_ltsw_ha_mem_alloc(unit,
                                         BCMI_HA_COMP_ID_DLB,
                                         ctrl_info_sub_comp_id[dlb_type],
                                         ctrl_info_blk_ids[dlb_type],
                                         &ha_alloc_size);
            SHR_NULL_CHECK(ptr, SHR_E_MEMORY);
            SHR_IF_ERR_VERBOSE_EXIT((ha_alloc_size < ha_req_size) ?
                                    SHR_E_MEMORY : SHR_E_NONE);
            if (!warm) {
                sal_memset(ptr, 0, ha_alloc_size);
            }
            rv = bcmi_ltsw_issu_struct_info_report(unit,
                                         BCMI_HA_COMP_ID_DLB,
                                         ctrl_info_sub_comp_id[dlb_type],
                                         0, ha_instance_size, ha_array_size,
                                         BCMINT_DLB_CTRL_INFO_T_ID);
            if (rv != SHR_E_EXISTS) {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            dlb_db->ctrl_info[dlb_type] = ptr;
            ctrl_info = dlb_db->ctrl_info[dlb_type];
            ctrl_info->bytes_per_cell = bytes_per_cell;
        }
        dlb_db->quality_map_profile_id_count = DLB_QUALITY_MAP_PROFILE_MAX;
        if (dlb_db->quality_map_profile_id_count > 0) {
            ha_array_size = dlb_db->quality_map_profile_id_count;
            ha_instance_size = sizeof(bcmint_dlb_quality_map_profile_t);
            ha_req_size = ha_array_size * ha_instance_size;
            ha_alloc_size = ha_req_size;
            ptr = bcmi_ltsw_ha_mem_alloc(unit,
                                         BCMI_HA_COMP_ID_DLB,
                                         qmap_prof_sub_comp_id,
                                         qmap_prof_blk_id,
                                         &ha_alloc_size);
            SHR_NULL_CHECK(ptr, SHR_E_MEMORY);
            SHR_IF_ERR_VERBOSE_EXIT((ha_alloc_size < ha_req_size) ?
                                    SHR_E_MEMORY : SHR_E_NONE);
            if (!warm) {
                sal_memset(ptr, 0, ha_alloc_size);
            }
            rv = bcmi_ltsw_issu_struct_info_report(unit,
                                         BCMI_HA_COMP_ID_DLB,
                                         qmap_prof_sub_comp_id,
                                         0, ha_instance_size, ha_array_size,
                                         BCMINT_DLB_QUALITY_MAP_PROFILE_T_ID);
            if (rv != SHR_E_EXISTS) {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            dlb_db->quality_map_profile = ptr;
        }
    }

    dlb_db->signature = DLB_SIGNATURE;

exit:
    if (SHR_FUNC_ERR() && features && !warm) {
        for (dlb_type = bcmi_dlb_type_fp_trunk;
             dlb_type < bcmi_dlb_type_count; dlb_type++) {
            if (dlb_db->info[dlb_type]) {
                (void)bcmi_ltsw_ha_mem_free(unit, dlb_db->info[dlb_type]);
                dlb_db->info[dlb_type] = NULL;
            }
            if (dlb_db->ctrl_info[dlb_type]) {
                (void)bcmi_ltsw_ha_mem_free(unit, dlb_db->ctrl_info[dlb_type]);
                dlb_db->ctrl_info[dlb_type] = NULL;
            }
        }
        if (dlb_db->quality_map_profile) {
            (void)bcmi_ltsw_ha_mem_free(unit, dlb_db->quality_map_profile);
            dlb_db->quality_map_profile = NULL;
            dlb_db->quality_map_profile_id_count = 0;
        }
    }
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy protection mutex for DLB.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 */
static int
dlb_db_deinit(int unit)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmi_ltsw_dlb_type_t dlb_type;
    bcmi_ltsw_dlb_capability_t cap;

    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    sal_memset(&cap, 0, sizeof(cap));

    for (dlb_type = bcmi_dlb_type_fp_trunk;
         dlb_type < bcmi_dlb_type_count; dlb_type++) {
        dlb_db->capability[dlb_type] = cap;
        dlb_db->info[dlb_type] = NULL;
        dlb_db->ctrl_info[dlb_type] = NULL;
    }

    dlb_db->quality_map_profile = NULL;
    dlb_db->quality_map_profile_id_count = 0;
    dlb_db->features = 0;
    dlb_db->signature = 0;

    SHR_EXIT();

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create a type-based DLB Id.
 *
 * \param [in] unit Unit Number.
 * \param [in] option DLB create option, See BCMI_LTSW_DLB_O_XXX.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [out] dlb_id DLB Identifier.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_id_create(
    int unit,
    uint32_t option,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t *dlb_id)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    uint32_t dlb_features = dlb_db->features;
    bcmi_ltsw_dlb_capability_t *cap = &dlb_db->capability[dlb_type];
    bcmint_dlb_info_t *dlb_info = NULL;
    int i;

    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    if (option & BCMI_LTSW_DLB_O_WITH_ID) {
        i = *dlb_id;
        if (i < cap->id_min || i > cap->id_max) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        dlb_info = &dlb_db->info[dlb_type][i];
        if (dlb_info->flags != DLB_ID_UNUSED) {
            SHR_ERR_EXIT(SHR_E_EXISTS);
        }
        dlb_info->flags |= DLB_ID_USED;
    } else {
        for (i = cap->id_min; i <= cap->id_max; i++) {
            dlb_info = &dlb_db->info[dlb_type][i];
            if (dlb_info->flags != DLB_ID_UNUSED) {
                continue;
            }
            *dlb_id = i;
            dlb_info->flags |= DLB_ID_USED;
            break;
        }
        if (i > cap->id_max) {
            SHR_ERR_EXIT(SHR_E_RESOURCE);
        }
    }

    if (dlb_type == bcmi_dlb_type_fp_trunk) {
        if (dlb_features & BCMI_LTSW_DLB_F_TRUNK_SHARED) {
            dlb_info = &dlb_db->info[bcmi_dlb_type_fabric_trunk][*dlb_id];
            dlb_info->flags |= DLB_ID_RESERVED;
        }
    } else if (dlb_type == bcmi_dlb_type_fabric_trunk) {
        if (dlb_features & BCMI_LTSW_DLB_F_TRUNK_SHARED) {
            dlb_info = &dlb_db->info[bcmi_dlb_type_fp_trunk][*dlb_id];
            dlb_info->flags |= DLB_ID_RESERVED;
        }
    }

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a type-based DLB Id.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id DLB Identifier.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_id_destroy(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    uint32_t dlb_features = dlb_db->features;
    bcmint_dlb_info_t *dlb_info = &dlb_db->info[dlb_type][dlb_id];

    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type_id(unit, dlb_type, dlb_id));

    if (dlb_info->flags == DLB_ID_UNUSED) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }
    if (dlb_info->flags != DLB_ID_USED) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dlb_info->flags = DLB_ID_UNUSED;

    if (dlb_type == bcmi_dlb_type_fp_trunk) {
        if (dlb_features & BCMI_LTSW_DLB_F_TRUNK_SHARED) {
            dlb_info = &dlb_db->info[bcmi_dlb_type_fabric_trunk][dlb_id];
            dlb_info->flags = DLB_ID_UNUSED;
        }
    } else if (dlb_type == bcmi_dlb_type_fabric_trunk) {
        if (dlb_features & BCMI_LTSW_DLB_F_TRUNK_SHARED) {
            dlb_info = &dlb_db->info[bcmi_dlb_type_fp_trunk][dlb_id];
            dlb_info->flags = DLB_ID_UNUSED;
        }
    }

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare profile set of DLB quality map profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] entries DLB quality map profile.
 * \param [in] entries_per_set Number of entries in the profile set.
 * \param [in] index Entry index of profile table.
 * \param [out] cmp Result of comparison.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_member_quality_map_profile_cmp_cb(
    int unit,
    void *entries,
    int entries_per_set,
    int index,
    int *cmp)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmint_dlb_quality_map_profile_t *quality_map_profile = NULL;
    uint32_t quality_map_profile_format1;
    uint32_t quality_map_profile_format2;

    SHR_FUNC_ENTER(unit);

    if (!entries || (entries_per_set != 1) || !cmp) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    quality_map_profile = (bcmint_dlb_quality_map_profile_t *)entries;

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_member_quality_map_profile_format(unit,
                                                 quality_map_profile,
                                                 &quality_map_profile_format1));

    quality_map_profile = &dlb_db->quality_map_profile[index];
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_member_quality_map_profile_format(unit,
                                                 quality_map_profile,
                                                 &quality_map_profile_format2));

    *cmp = (quality_map_profile_format1 == quality_map_profile_format2) ? 0 : 1;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the DLB member quality map profile.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_member_quality_map_init(int unit)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_DLB_QUALITY_MAP;
    int entry_min, entry_max;
    bcm_pbmp_t pbmp;
    int port;
    bcmi_ltsw_dlb_member_attribute_t attribute =
    {
        BCMINT_DLB_DEFAULT_SCALING_FACTOR,
        BCMINT_DLB_DEFAULT_LOAD_WEIGHT,
        BCMINT_DLB_DEFAULT_QUEUE_SIZE_WEIGHT
    };
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    if (bcmi_ltsw_profile_register_check(unit, ph)) {
        SHR_EXIT();
    }

    entry_min = 0;
    entry_max = dlb_db->quality_map_profile_id_count - 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit, &ph, &entry_min, &entry_max, 1, NULL,
                                    dlb_member_quality_map_profile_cmp_cb));

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_ALL, &pbmp));

        BCM_PBMP_ITER(pbmp, port) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_dlb_member_attribute_set(unit, port, bcmi_dlb_type_ecmp, &attribute));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover the DLB member quality map profile referece count while WB.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_member_quality_map_wb_recover(int unit)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_DLB_QUALITY_MAP;
    int port, quality_map_id, profile_index;
    bcm_pbmp_t pbmp;
    int rv;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(pbmp);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_ALL, &pbmp));
    BCM_PBMP_ITER(pbmp, port) {
        rv = mbcm_ltsw_dlb_member_attribute_get(unit, port, -1,
                                                NULL, &quality_map_id);
        if (rv == SHR_E_NOT_FOUND) {
            continue;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_dlb_member_quality_map_id2profile(unit, -1,
                                        dlb_db->quality_map_profile_id_count,
                                        dlb_db->quality_map_profile,
                                        quality_map_id,
                                        &profile_index));
        /* Recover the reference count. */
        SHR_IF_ERR_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit, ph,
                                                  1, profile_index, 1));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear the information of DLB member quality map profile.
 *
 * This function is used to clear the information of DLB member quality map profile.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_member_quality_map_deinit(int unit)
{
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_DLB_QUALITY_MAP;

    SHR_FUNC_ENTER(unit);

    if (!bcmi_ltsw_profile_register_check(unit, ph)) {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_unregister(unit, ph));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Adjust the DLB member attributes.
 *
 * \param [in] unit Unit Number.
 * \param [in] attribute DLB member port attribute.
 * \param [out] new_attribute Ajusted DLB member port attribute.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_member_attribute_adjust(
    int unit,
    bcmi_ltsw_dlb_member_attribute_t *attribute,
    bcmi_ltsw_dlb_member_attribute_t *new_attribute)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(attribute, SHR_E_PARAM);
    SHR_NULL_CHECK(new_attribute, SHR_E_PARAM);

    if (attribute->scaling_factor == BCMI_LTSW_DLB_SCALING_FACTOR_INVALID) {
        new_attribute->scaling_factor = BCMINT_DLB_DEFAULT_SCALING_FACTOR;
    } else {
        new_attribute->scaling_factor = attribute->scaling_factor;
    }
    if (attribute->load_weight == BCMI_LTSW_DLB_LOAD_WEIGHT_INVALID) {
        new_attribute->load_weight = BCMINT_DLB_DEFAULT_LOAD_WEIGHT;
    } else {
        new_attribute->load_weight = attribute->load_weight;
    }
    if (attribute->qsize_weight == BCMI_LTSW_DLB_QUEUE_SIZE_WEIGHT_INVALID) {
        new_attribute->qsize_weight = BCMINT_DLB_DEFAULT_QUEUE_SIZE_WEIGHT;
    } else {
        new_attribute->qsize_weight = attribute->qsize_weight;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the DLB member attributes.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] attribute DLB member port attribute.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_member_attribute_set(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_member_attribute_t *attribute)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmint_dlb_quality_map_profile_t quality_map_profile;
    bcmint_dlb_quality_map_profile_t *profile_ptr = NULL;
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_DLB_QUALITY_MAP;
    int profile_index;
    bool profile_index_valid = false;
    int old_profile_index = 0;
    bool old_profile_index_valid = false;
    int quality_map_id;
    int old_quality_map_id;
    bcmi_ltsw_dlb_member_attribute_t new_attribute;
    int rv;
    uint32_t ref_count;

    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    rv = mbcm_ltsw_dlb_member_attribute_get(unit, port, dlb_type,
                                            NULL, &old_quality_map_id);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }
    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_dlb_member_quality_map_id2profile(unit, dlb_type,
                                        dlb_db->quality_map_profile_id_count,
                                        dlb_db->quality_map_profile,
                                        old_quality_map_id,
                                        &old_profile_index));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_get(unit, ph, old_profile_index,
                                             &ref_count));
        if (ref_count) {
            old_profile_index_valid = true;
        }
    }

    if (!attribute) {
        if (!old_profile_index_valid) {
            SHR_ERR_EXIT(SHR_E_NOT_FOUND);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_dlb_member_attribute_clear(unit, port, dlb_type));

        rv = bcmi_ltsw_profile_index_free(unit, ph, old_profile_index);
        if (SHR_SUCCESS(rv)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mbcm_ltsw_dlb_member_quality_map_clear(unit, dlb_type,
                                                        old_quality_map_id));
            profile_ptr = &dlb_db->quality_map_profile[old_profile_index];
            sal_memset(profile_ptr, 0, sizeof(*profile_ptr));
        } else {
            if (rv != SHR_E_BUSY) {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (dlb_validate_member_attribute(unit, dlb_type, attribute));

        SHR_IF_ERR_VERBOSE_EXIT
            (dlb_member_attribute_adjust(unit, attribute, &new_attribute));

        /* Free old profile first, if old is valid. */
        if (old_profile_index_valid) {
            rv = bcmi_ltsw_profile_index_free(unit, ph, old_profile_index);
            if (SHR_SUCCESS(rv)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (mbcm_ltsw_dlb_member_quality_map_clear(unit, dlb_type,
                                                            old_quality_map_id));
                profile_ptr = &dlb_db->quality_map_profile[old_profile_index];
                sal_memset(profile_ptr, 0, sizeof(*profile_ptr));
            } else {
                if (rv != SHR_E_BUSY) {
                    SHR_IF_ERR_VERBOSE_EXIT(rv);
                }
            }
        }

        /* Allocate new profile. */
        quality_map_profile.load_percent = new_attribute.load_weight;
        quality_map_profile.qsize_percent = new_attribute.qsize_weight;
        rv = bcmi_ltsw_profile_index_allocate(unit, ph, &quality_map_profile, 0,
                                              1, &profile_index);
        if (rv != SHR_E_EXISTS) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        if (rv == SHR_E_EXISTS) {
            profile_index_valid = true;
        }

        if (!profile_index_valid) {
            profile_ptr = &dlb_db->quality_map_profile[profile_index];
            profile_ptr->load_percent = quality_map_profile.load_percent;
            profile_ptr->qsize_percent = quality_map_profile.qsize_percent;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_dlb_member_quality_map_profile2id(unit, dlb_type,
                                        dlb_db->quality_map_profile_id_count,
                                        dlb_db->quality_map_profile,
                                        profile_index,
                                        &quality_map_id));
        if (!profile_index_valid) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mbcm_ltsw_dlb_member_quality_map_set(unit,
                                          dlb_type,
                                          quality_map_id,
                                          quality_map_profile.load_percent,
                                          quality_map_profile.qsize_percent));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_dlb_member_attribute_set(unit, port, dlb_type,
                                                new_attribute.scaling_factor,
                                                quality_map_id));
    }

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the DLB member attributes.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [out] attribute DLB member port attribute.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_member_attribute_get(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_member_attribute_t *attribute)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_DLB_QUALITY_MAP;
    int profile_index;
    int scaling_factor, quality_map_id;
    uint32_t ref_count;
    bcmint_dlb_quality_map_profile_t *profile_ptr = NULL;

    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_member_attribute_get(unit, port, dlb_type,
                                            &scaling_factor, &quality_map_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_member_quality_map_id2profile(unit, dlb_type,
                                        dlb_db->quality_map_profile_id_count,
                                        dlb_db->quality_map_profile,
                                        quality_map_id,
                                        &profile_index));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_get(unit, ph, profile_index, &ref_count));
    if (ref_count) {
        profile_ptr = &dlb_db->quality_map_profile[profile_index];
        attribute->scaling_factor = scaling_factor;
        attribute->load_weight = profile_ptr->load_percent;
        attribute->qsize_weight = profile_ptr->qsize_percent;
    }

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-initialize the member attributes for DLB.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_member_attribute_deinit(int unit)
{
    int rv;
    bcm_pbmp_t pbmp;
    int port;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(pbmp);
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_member_pbmp_get(unit, &pbmp));

    BCM_PBMP_ITER(pbmp, port) {
        rv = dlb_member_attribute_set(unit, port, -1, NULL);
        if (rv == SHR_E_NOT_FOUND) {
            continue;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the DLB configurations.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [in] dlb_config DLB configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_config_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_config_t *dlb_config)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmint_dlb_info_t *dlb_info = &dlb_db->info[dlb_type][dlb_id];

    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type_id(unit, dlb_type, dlb_id));

    if (!dlb_config) {
        if (dlb_info->flags & DLB_ID_CONFIGURED) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mbcm_ltsw_dlb_config_clear(unit, dlb_type, dlb_id));
            dlb_info->flags &= ~DLB_ID_DGM_ENABLED;
            dlb_info->flags &= ~DLB_ID_MONITORED;
            dlb_info->flags &= ~DLB_ID_CONFIGURED;
        } else {
            SHR_ERR_EXIT(SHR_E_NOT_FOUND);
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (dlb_validate_config(unit, dlb_type, dlb_config));

        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_dlb_config_set(unit, dlb_type, dlb_id, dlb_config));
        dlb_info->flags |=  DLB_ID_CONFIGURED;
        if (dlb_config->flags & BCMI_LTSW_DLB_CF_DGM_ENABLED) {
            dlb_info->flags |=  DLB_ID_DGM_ENABLED;
        } else {
            dlb_info->flags &= ~DLB_ID_DGM_ENABLED;
        }
    }

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the DLB configurations.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [out] dlb_config DLB configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_config_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_config_t *dlb_config)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmint_dlb_info_t *dlb_info = &dlb_db->info[dlb_type][dlb_id];

    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type_id_configured(unit, dlb_type, dlb_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_config_get(unit, dlb_type, dlb_id, dlb_config));
    if (dlb_info->flags & DLB_ID_DGM_ENABLED) {
        dlb_config->flags |=  BCMI_LTSW_DLB_CF_DGM_ENABLED;
    }

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the DLB monitoring configurations.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [in] monitor DLB monitoring configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_monitor_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_monitor_t *monitor)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    bcmint_dlb_info_t *dlb_info = &dlb_db->info[dlb_type][dlb_id];

    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type_id(unit, dlb_type, dlb_id));

    if (!monitor) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_monitor(unit, dlb_type, monitor));

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_monitor_set(unit, dlb_type, dlb_id, monitor));
    dlb_info->flags |=  DLB_ID_MONITORED;

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the DLB monitoring configurations.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [out] monitor DLB monitoring configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_monitor_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_monitor_t *monitor)
{
    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    if (!monitor) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type_id(unit, dlb_type, dlb_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_monitor_get(unit, dlb_type, dlb_id, monitor));

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB member status.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] status Type-based DLB member status.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_member_status_set(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int status)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_member_status_set(unit, port, dlb_type, status));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DLB member status.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [out] status Type-based DLB member status.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_member_status_get(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int *status)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_member_status_get(unit, port, dlb_type, status));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB Eligibility Ethertype.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags Flags.
 * \param [in] Ethertype count.
 * \param [in] Ethertype array.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_ethertype_set(
    int unit,
    uint32_t flags,
    int ethertype_count,
    int *ethertype_array)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_ethertype_set(unit, flags, ethertype_count, ethertype_array));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DLB Eligibility Ethertype.
 *
 * \param [in] unit Unit Number.
 * \param [in] Max ethertype count.
 * \param [out] flags Flags.
 * \param [out] ethertype array.
 * \param [out] Actual ethertype count.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_ethertype_get(
    int unit,
    int ethertype_max,
    uint32_t *flags,
    int *ethertype_array,
    int *ethertype_count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_ethertype_get(unit, ethertype_max, flags,
                                     ethertype_array, ethertype_count));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the DLB controlling type for a specific DLB type.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_control_type_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type)
{
    SHR_FUNC_ENTER(unit);

    if (type < 0 || type >= bcmiDlbControlTypeCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_control_type_validate(unit, dlb_type, type));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the DLB controlling type value for a specific DLB type.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [in] value Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_control_value_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];

    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmiDlbControlTypeEgressBytesMinThreshold:
        case bcmiDlbControlTypeEgressBytesMaxThreshold:
        case bcmiDlbControlTypeQueuedBytesMinThreshold:
        case bcmiDlbControlTypeQueuedBytesMaxThreshold:
        case bcmiDlbControlTypePhysicalQueuedBytesMinThreshold:
        case bcmiDlbControlTypePhysicalQueuedBytesMaxThreshold:
            dlb_lock(unit);
            SHR_IF_ERR_CONT
                (mbcm_ltsw_dlb_control_info_value_validate(unit, dlb_type,
                                                           dlb_db->ctrl_info,
                                                           type, value));
            dlb_unlock(unit);
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT
                (mbcm_ltsw_dlb_control_value_validate(unit, dlb_type,
                                                      type, value));
            break;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB controlling information.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [in] value Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_control_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];

    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    switch (type) {
        case bcmiDlbControlTypeSampleRate:
        case bcmiDlbControlTypeEgressBytesMinThreshold:
        case bcmiDlbControlTypeEgressBytesMaxThreshold:
        case bcmiDlbControlTypeQueuedBytesMinThreshold:
        case bcmiDlbControlTypeQueuedBytesMaxThreshold:
        case bcmiDlbControlTypePhysicalQueuedBytesMinThreshold:
        case bcmiDlbControlTypePhysicalQueuedBytesMaxThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (mbcm_ltsw_dlb_control_info_set(unit, dlb_type,
                                                dlb_db->ctrl_info,
                                                type, value));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT
                (mbcm_ltsw_dlb_control_set(unit, dlb_type, type, value));
            break;
    }

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DLB controlling information.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [out] value Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_control_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t *value)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];

    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    switch (type) {
        case bcmiDlbControlTypeSampleRate:
        case bcmiDlbControlTypeEgressBytesMinThreshold:
        case bcmiDlbControlTypeEgressBytesMaxThreshold:
        case bcmiDlbControlTypeQueuedBytesMinThreshold:
        case bcmiDlbControlTypeQueuedBytesMaxThreshold:
        case bcmiDlbControlTypePhysicalQueuedBytesMinThreshold:
        case bcmiDlbControlTypePhysicalQueuedBytesMaxThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (mbcm_ltsw_dlb_control_info_get(unit, dlb_type,
                                                dlb_db->ctrl_info,
                                                type, value));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT
                (mbcm_ltsw_dlb_control_get(unit, dlb_type, type, value));
            break;
    }

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize DLB controlling tables.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_control_init(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeSampleRate,
                         62500));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeEgressBytesMaxThreshold,
                         65536 * 7));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeEgressBytesMinThreshold,
                         65536));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeEgressBytesExponent,
                         0));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeQueuedBytesExponent,
                         0));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypePhysicalQueuedBytesExponent,
                         0));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeEgressBytesDecreaseReset,
                         0));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeQueuedBytesDecreaseReset,
                         0));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypePhysicalQueuedBytesDecreaseReset,
                         0));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeQueuedBytesMinThreshold,
                         0));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeQueuedBytesMaxThreshold,
                         0));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypePhysicalQueuedBytesMinThreshold,
                         0));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypePhysicalQueuedBytesMaxThreshold,
                         0));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeRandomSeed,
                         0));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeMonitorIngressFieldRandomSeed,
                         1));
    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type,
                         bcmiDlbControlTypeMonitorIngressRandomSeed,
                         1));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover the dlb configurations during WarmBoot.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_wb_recover(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_member_quality_map_wb_recover(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the dlb module.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_type_init(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_type_init(unit, dlb_type));

    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (dlb_control_init(unit, dlb_type));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-init the dlb module.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_type_deinit(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_type_deinit(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_db_type_deinit(unit, dlb_type));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the dlb module.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_init(int unit)
{
    bcmi_ltsw_dlb_type_t dlb_type;
    int rv;
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_member_quality_map_init(unit));

    if (warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (dlb_wb_recover(unit));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_dlb_init(unit));

        for (dlb_type = bcmi_dlb_type_fp_trunk;
             dlb_type < bcmi_dlb_type_count; dlb_type++) {
            rv = dlb_validate_type(unit, dlb_type);
            if (SHR_FAILURE(rv)) {
                continue;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (dlb_type_init(unit, dlb_type));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-init the dlb module.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_deinit(int unit)
{
    bcmi_ltsw_dlb_type_t dlb_type;
    int rv;
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    if (!warm) {
        for (dlb_type = bcmi_dlb_type_fp_trunk;
             dlb_type < bcmi_dlb_type_count; dlb_type++) {
            rv = dlb_validate_type(unit, dlb_type);
            if (SHR_FAILURE(rv)) {
                continue;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (dlb_type_deinit(unit, dlb_type));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (dlb_member_attribute_deinit(unit));

        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_dlb_deinit(unit));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_member_quality_map_deinit(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set statistics for a DLB group.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [in] stat DLB configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_stat_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_stat_t *stat)
{
    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type_id_configured(unit, dlb_type, dlb_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_stat_set(unit, dlb_type, dlb_id, stat));

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get statistics for a DLB group.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [in] sync_mode Sync from HW or not.
 * \param [out] stat DLB configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
dlb_stat_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bool sync_mode,
    bcmi_ltsw_dlb_stat_t *stat)
{
    SHR_FUNC_ENTER(unit);

    dlb_lock(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type_id_configured(unit, dlb_type, dlb_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_dlb_stat_get(unit, dlb_type, dlb_id, sync_mode, stat));

exit:
    dlb_unlock(unit);
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
bcmi_ltsw_dlb_id_create(
    int unit,
    uint32_t option,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t *dlb_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(dlb_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_id_create(unit, option, dlb_type, dlb_id));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_id_destroy(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_id_destroy(unit, dlb_type, dlb_id));

exit:
    SHR_FUNC_EXIT();
}

bool
bcmi_ltsw_dlb_id_configured(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id)
{
    int rv;

    dlb_lock(unit);
    rv = dlb_validate_type_id_configured(unit, dlb_type, dlb_id);
    dlb_unlock(unit);

    return SHR_SUCCESS(rv) ? true : false;
}

int
bcmi_ltsw_dlb_member_attribute_set(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_member_attribute_t *attribute)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_member_port(unit, port));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_member_attribute_set(unit, port, dlb_type, attribute));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_member_attribute_get(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_member_attribute_t *attribute)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(attribute, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_member_port(unit, port));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_member_attribute_get(unit, port, dlb_type, attribute));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_stat_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_stat_t *stat)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(stat, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_stat_get(unit, dlb_type, dlb_id, false, stat));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_stat_sync_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_stat_t *stat)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(stat, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_stat_get(unit, dlb_type, dlb_id, true, stat));

exit:
    SHR_FUNC_EXIT();
}

void
bcmi_ltsw_dlb_sw_dump(int unit)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];
    uint32_t dlb_features = dlb_db->features;
    bcmi_ltsw_dlb_type_t dlb_type;
    bcmi_ltsw_dlb_id_t dlb_id;
    bcmi_ltsw_dlb_capability_t *cap = NULL;
    bcmint_dlb_info_t *dlb_info = NULL;
    int i, rv;
    bcmint_dlb_ctrl_info_t *ctrl_info = NULL;
    const char *dlb_type_str[] = BCMI_LTSW_DLB_TYPE_STR;
    uint32_t ref_count;

    if (!dlb_db_is_initialized(unit)) {
        return;
    }

    LOG_CLI((BSL_META_U(unit,
                        "\nSW Information DLB - Unit %"PRId32"\n"), unit));
    LOG_CLI((BSL_META_U(unit,
                        "  DLB database features : 0x%08"PRIx32"\n"), dlb_features));

    for (dlb_type = bcmi_dlb_type_fp_trunk;
         dlb_type < bcmi_dlb_type_count; dlb_type++) {
        if (SHR_FAILURE(dlb_validate_type(unit, dlb_type))) {
            continue;
        }
        LOG_CLI((BSL_META_U(unit,
                            "  DLB type : %s\n"), dlb_type_str[dlb_type]));
        LOG_CLI((BSL_META_U(unit,
                            "    Capability : \n")));
        cap = &dlb_db->capability[dlb_type];
        LOG_CLI((BSL_META_U(unit,
                            "        id_min : %"PRId32"\n"),
                 cap->id_min));
        LOG_CLI((BSL_META_U(unit,
                            "        id_max : %"PRId32"\n"),
                 cap->id_max));
        LOG_CLI((BSL_META_U(unit,
                            "        max_groups : %"PRId32"\n"),
                 cap->max_groups));
        LOG_CLI((BSL_META_U(unit,
                            "        max_members_per_group : %"PRId32"\n"),
                 cap->max_members_per_group));
        LOG_CLI((BSL_META_U(unit,
                            "        max_alt_members_per_group : %"PRId32"\n"),
                 cap->max_alt_members_per_group));
        LOG_CLI((BSL_META_U(unit,
                            "    Ids : \n")));
        for (dlb_id = cap->id_min; dlb_id <= cap->id_max; dlb_id++) {
            dlb_info = &dlb_db->info[dlb_type][dlb_id];
            if (dlb_info->flags == DLB_ID_UNUSED) {
                continue;
            }
            if (dlb_info->flags == DLB_ID_RESERVED) {
                continue;
            }
            LOG_CLI((BSL_META_U(unit,
                                "        dlb_id : %"PRId32" (0x%08"PRIx32")\n"),
                     dlb_id, dlb_info->flags));
        }

        LOG_CLI((BSL_META_U(unit,
                            "    CtrlInfo : \n")));
        ctrl_info = dlb_db->ctrl_info[dlb_type];
        LOG_CLI((BSL_META_U(unit,
                            "        bytes_per_cell : %"PRIu64"\n"),
                 ctrl_info->bytes_per_cell));
        LOG_CLI((BSL_META_U(unit,
                            "        sample_rate : %"PRIu64"\n"),
                 ctrl_info->sample_rate));
        LOG_CLI((BSL_META_U(unit,
                            "        egress_bytes : [%"PRIu64":%"PRIu64"]\n"),
                 ctrl_info->egress_bytes_min, ctrl_info->egress_bytes_max));
        LOG_CLI((BSL_META_U(unit,
                            "        queued_bytes : [%"PRIu64":%"PRIu64"]\n"),
                 ctrl_info->queued_bytes_min, ctrl_info->queued_bytes_max));
        LOG_CLI((BSL_META_U(unit,
                            "        physical_queued_bytes : [%"PRIu64":%"PRIu64"]\n"),
                 ctrl_info->physical_queued_bytes_min,
                 ctrl_info->physical_queued_bytes_max));
    }

    if (dlb_db->quality_map_profile &&
        dlb_db->quality_map_profile_id_count > 0) {
        LOG_CLI((BSL_META_U(unit,
                            "  DLB quality map profile : (total %"PRId32")\n"),
                            dlb_db->quality_map_profile_id_count));
        for (i = 0; i < dlb_db->quality_map_profile_id_count; i++) {
            rv = bcmi_ltsw_profile_ref_count_get(unit,
                                              BCMI_LTSW_PROFILE_DLB_QUALITY_MAP,
                                              i, &ref_count);
            if (rv < 0) {
                continue;
            }
            LOG_CLI((BSL_META_U(unit,
                                "    profile Id : %"PRId32" (Ref. %"PRId32")\n"),
                     i, ref_count));
            LOG_CLI((BSL_META_U(unit,
                                "        load_percent : %"PRId32"\n"),
                     dlb_db->quality_map_profile[i].load_percent));
            LOG_CLI((BSL_META_U(unit,
                                "        qsize_percent : %"PRId32"\n"),
                     dlb_db->quality_map_profile[i].qsize_percent));
        }
    }

    return;
}

int
bcmi_ltsw_dlb_feature_get(
    int unit,
    uint32_t *features)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(features, SHR_E_PARAM);

    *features = dlb_db->features;

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_capability_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_capability_t *cap)
{
    dlb_db_t *dlb_db = &bcmi_ltsw_dlb_db[unit];

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(cap, SHR_E_PARAM);

    *cap = dlb_db->capability[dlb_type];

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    if (dlb_db_is_initialized(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_dlb_deinit(unit));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_lock_create(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_db_init(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_init(unit));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_deinit(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_db_deinit(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_lock_destroy(unit));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_type_init(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_type_init(unit, dlb_type));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_type_deinit(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_type_deinit(unit, dlb_type));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_config_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_config_t *dlb_config)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_config_set(unit, dlb_type, dlb_id, dlb_config));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_config_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_config_t *dlb_config)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(dlb_config, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_config_get(unit, dlb_type, dlb_id, dlb_config));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_monitor_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_monitor_t *monitor)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_monitor_set(unit, dlb_type, dlb_id, monitor));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_monitor_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_monitor_t *monitor)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(monitor, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_monitor_get(unit, dlb_type, dlb_id, monitor));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_member_status_set(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int status)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_member_port(unit, port));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_member_status_set(unit, port, dlb_type, status));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_member_status_get(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int *status)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(status, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_member_port(unit, port));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_member_status_get(unit, port, dlb_type, status));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_ethertype_set(
    int unit,
    uint32_t flags,
    int ethertype_count,
    int *ethertype_array)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_ethertype_set(unit, flags, ethertype_count, ethertype_array));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_ethertype_get(
    int unit,
    int ethertype_count_max,
    uint32_t *flags,
    int *ethertype_array,
    int *ethertype_count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_ethertype_get(unit, ethertype_count_max, flags,
                           ethertype_array, ethertype_count));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_control_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_type_validate(unit, dlb_type, type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_value_validate(unit, dlb_type, type, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_set(unit, dlb_type, type, value));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_control_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t *value)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(value, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_type_validate(unit, dlb_type, type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_control_get(unit, dlb_type, type, value));

exit:
    SHR_FUNC_EXIT();
}

int
bcmi_ltsw_dlb_stat_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_stat_t *stat)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(stat, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_feature(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_initialization(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_validate_type(unit, dlb_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (dlb_stat_set(unit, dlb_type, dlb_id, stat));

exit:
    SHR_FUNC_EXIT();
}

