/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm/mirror.h>
#include <bcm/flexctr.h>
#include <bcm/field.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/mirror.h>
#include <bcm_int/ltsw/xfs/mirror.h>
#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/tunnel.h>
#include <bcm_int/ltsw/stack.h>
#include <bcm_int/ltsw/switch.h>
#include <bcm_int/ltsw/field.h>
#include <bcm_int/ltsw/flexctr.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw/mod.h>
#include <bcm_int/ltsw/cosq.h>

#include <sal/sal_types.h>
#include <bsl/bsl.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>
#include <bcmlt/bcmlt.h>
#include <shr/shr_bitop.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_MIRROR

/*! Mirror destination is a tunnel encap. */
#define MIRROR_DEST_IS_TUNNEL(mirror_dest) \
            ((mirror_dest->flags & BCMINT_MIRROR_DEST_TUNNELS) || \
             (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_TUNNEL_VXLAN) || \
             (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_PSAMP_FORMAT_2) || \
             (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP) || \
             (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_INT_PROBE) || \
             (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_IFA))

/*!
 * \brief Ethernet type for mirror encap.
 */
/*! IPv4 type. */
#define MIRROR_ENCAP_ETHERTYPE_IPV4 0x0800

/*! IPv6 type. */
#define MIRROR_ENCAP_ETHERTYPE_IPV6 0x86DD

/*!
 * \brief IP protocol type for mirror encap.
 */
/*! GRE protocol. */
#define MIRROR_ENCAP_IP_PROTO_TYPE_GRE 0x2F

/*! UDP protocol. */
#define MIRROR_ENCAP_IP_PROTO_TYPE_UDP 0x11

/*! Default protocol type of GRE header. */
#define MIRROR_ENCAP_GRE_DEF_PROTO_TYPE 0x88BE

/*! GRE protocol type for ERSPAN type III. */
#define MIRROR_ENCAP_GRE_PROTO_TYPE_ERSPAN3 0x22EB

/*! Reserved system source value(spare port 139) for mirror encapsulation HiGig3 header. */
#define MIRROR_ENCAP_HG3_HEADER_RSVD_SYS_SOURCE 139

/*!
 * \brief IP protocol version.
 */
/*! IPv4. */
#define MIRROR_ENCAP_IP_VER_IPV4 4

/*! IPv6. */
#define MIRROR_ENCAP_IP_VER_IPV6 6

/*!
 * \brief Mirror container number on source.
 */
/*! Max num. */
#define MIRROR_CONTAINER_NUM_MAX 8

/*! Ingress mirroring port. */
#define MIRROR_CONTAINER_NUM_PORT_ING 4

/*! Egress mirroring port. */
#define MIRROR_CONTAINER_NUM_PORT_EGR 8

/*! Ingress mirroring vp. */
#define MIRROR_CONTAINER_NUM_VP_ING 2

/*! FP mirroring. */
#define MIRROR_CONTAINER_NUM_FP_ING 4

/*! Mirror instance number per session table. */
#define MIRROR_INSTANCE_NUM 16

/*! The minimum container id for FP mirroring. */
#define MIRROR_CONTAINER_FP_MIN 2

/*! The container id for field destination mirroring. */
#define MIRROR_CONTAINER_FIELD_DEST 6

/*! Loopback destination type:DEVICE_PORT. */
#define MIRROR_LOOPBACK_DEST_TYPE_DEV_PORT 10

/*! Sample threshold bit width. */
#define MIRROR_SAMPLE_THRESHOLD_BIT_WIDTH 29

/*! Sample maximum threshold. */
#define MIRROR_SAMPLE_MAX_THRESHOLD (1 << MIRROR_SAMPLE_THRESHOLD_BIT_WIDTH)

/*!
 * \brief Mirror encapsulation HiGig3 header structure.
 */
typedef struct mirror_encap_hg3_header_s {

    /*! Ethernet type. */
    uint16_t ethertype;

    /*! Base Header. */
    uint64_t base_hdr;

} mirror_encap_hg3_header_t;

/*!
 * \brief Mirror encapsulation sub-header of ERSPAN type 3.
 */
typedef struct mirror_encap_erspan3_sub_header_s {

    /*! Indicates that ERSPAN payload is an Ethernet protocol frame. */
    bool pdu_frame;

    /*! Frame Type of ERSPAN payload. */
    uint8_t frame_type;

    /*! Unique identifier of an ERSPAN engine within a system. */
    uint8_t hw_id;

    /*! Indicates the original frame was SPAN in egress, Ingress (0) or Egress (1). */
    bool direction;

    /*! Time unit to be supported for time-stamping. */
    uint8_t ts_gra;

    /*! Indicates the optional platform-specific sub-header is present. */
    bool optional_hdr;

} mirror_encap_erspan3_sub_header_t;

/*!
 * \brief Mirror encapsulation loopback header structure.
 */
typedef struct mirror_encap_lb_header_s {

    /*! Loopback header type. */
    bcm_mirror_loopback_header_type_t loopback_header_type;

    /*! Source system port in the 2nd pass. */
    int src_sys_port;

    /*! Destination system port in the 2nd pass. */
    int dst_sys_port;

    /*! Generic controls to do things such as bypass specific lookups, override certain types of drops, suppress mirroring etc. */
    int processing_ctrl_0;

} mirror_encap_lb_header_t;

/*!
 * \brief RPSAN encapsulation structure.
 */
typedef struct mirror_encap_rspan_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! VLAN priority to insert into the encapsulation header. Applicable only when vlan_id is valid. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header. Applicable only if vlan_id is valid. */
    bool cfi;

    /*! VLAN ID to insert into the mirrored packet. */
    bcm_vlan_t vlan_id;

    /*! TPID to insert into the mirrored packet. */
    uint16_t tpid;

    /*! Enable to add Virtual Network Tag (VN-Tag) in NIV mirror tunneling. */
    bool vn_tag;

    /*! Source virtual interface of NIV tag, applicable only if vn_tag is enabled. */
    uint16_t src_niv_vif;

    /*! Destination virtual interface of NIV tag, applicable only if vn_tag is enabled. */
    uint16_t dst_niv_vif;

} mirror_encap_rspan_t;

/*!
 * \brief ERSPAN encapsulation structure.
 */
typedef struct mirror_encap_erspan_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv4 address. */
    bcm_ip_t src_ipv4;

    /*! Destination IPv4 address. */
    bcm_ip_t dst_ipv4;

    /*! IPv4 type of service. */
    uint8_t tos;

    /*! IPv4 time to live. */
    uint8_t ttl;

    /*! IPv4 protocol type. */
    uint8_t proto;

    /*! IPv4 dont fragment flag. */
    bool df;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! GRE header, 0x88BE for GRE protocol type 2, 0x22EB for GRE protocol type 3. */
    uint32_t gre_header;

    /*! Session id, applicable only if gre_header == 0x22EB. */
    uint16_t session_id;

    /*! Switch id, applicable only if gre_header == 0x22EB. */
    uint32_t switch_id;

    /*! Enable to encapsulate with sequence number. */
    bool seq_ena;

    /*! Sequence number inserted into GRE header. */
    uint32_t seq_num;

    /*! Enable to encapsulate with HiGig3 header. Applicable only if destination port is remote port. */
    bool hg3_ena;

    /*! HiGig3 header. Applicable only if hg3_ena is set. */
    mirror_encap_hg3_header_t hg3_header;

    /*! Sub-header of ERSPAN type 3, applicable only if gre_header == 0x22EB. */
    mirror_encap_erspan3_sub_header_t erspan3_sub_header;

} mirror_encap_erspan_t;

/*!
 * \brief ERSPAN IPv6 encapsulation structure.
 */
typedef struct mirror_encap_erspan_ipv6_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv6 address. */
    bcm_ip6_t src_ipv6;

    /*! Destination IPv6 address. */
    bcm_ip6_t dst_ipv6;

    /*! IPv6 traffic class. */
    uint8_t traffic_class;

    /*! IPv6 hop limit. */
    uint8_t hop_limit;

    /*! IPv6 next header. */
    uint8_t next_header;

    /*! IPv6 flow label. */
    uint32_t flow_label;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! GRE header, 0x88BE for GRE protocol type 2, 0x22EB for GRE protocol type 3. */
    uint32_t gre_header;

    /*! Session id, applicable only if gre_header == 0x22EB. */
    uint16_t session_id;

    /*! Switch id, applicable only if gre_header == 0x22EB. */
    uint32_t switch_id;

    /*! Enable to encapsulate with sequence number. */
    bool seq_ena;

    /*! Sequence number inserted into GRE header. */
    uint32_t seq_num;

    /*! Enable to encapsulate with HiGig3 header. Applicable only if destination port is remote port. */
    bool hg3_ena;

    /*! HiGig3 header. Applicable only if hg3_ena is set. */
    mirror_encap_hg3_header_t hg3_header;

    /*! Sub-header of ERSPAN type 3, applicable only if gre_header == 0x22EB. */
    mirror_encap_erspan3_sub_header_t erspan3_sub_header;

} mirror_encap_erspan_ipv6_t;

/*!
 * \brief PSAMP encap structure.
 */
typedef struct mirror_encap_psamp_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv4 address. */
    bcm_ip_t src_ipv4;

    /*! Destination IPv4 address. */
    bcm_ip_t dst_ipv4;

    /*! IPv4 type of service. */
    uint8_t tos;

    /*! IPv4 time to live. */
    uint8_t ttl;

    /*! IPv4 protocol type. */
    uint8_t proto;

    /*! IPv4 dont fragment flag. */
    bool df;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Observation domain for IP flow information export (IPFIX) header. */
    uint32_t observation_domain;

    /*! Template identifier for IPFIX header. */
    uint16_t template_id;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Packet sampling (PSAMP) IP flow information export (IPFIX) version number. */
    uint32_t ipfix_ver;

    /*! Packet sampling (PSAMP) epoch / revision number. */
    uint16_t psamp_epoch;

    /*! Variable flag (default to 0xFF). */
    uint8_t variable_flag;

    /*! Enable to encapsulate with sequence number. */
    bool seq_ena;

    /*! Sequence number inserted into IPFIX header. */
    uint32_t seq_num;

    /*! Enable to encapsulate with HiGig3 header. Applicable only if destination port is remote port. */
    bool hg3_ena;

    /*! HiGig3 header. Applicable only if hg3_ena is set. */
    mirror_encap_hg3_header_t hg3_header;

} mirror_encap_psamp_t;

/*!
 * \brief PSAMP IPv6 encapsulation structure.
 */
typedef struct mirror_encap_psamp_ipv6_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv6 address. */
    bcm_ip6_t src_ipv6;

    /*! Destination IPv6 address. */
    bcm_ip6_t dst_ipv6;

    /*! IPv6 traffic class. */
    uint8_t traffic_class;

    /*! IPv6 hop limit. */
    uint8_t hop_limit;

    /*! IPv6 next header. */
    uint8_t next_header;

    /*! IPv6 flow label. */
    uint32_t flow_label;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Observation domain for IP flow information export (IPFIX) header. */
    uint32_t observation_domain;

    /*! Template identifier for IPFIX header. */
    uint16_t template_id;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Packet sampling (PSAMP) IP flow information export (IPFIX) version number. */
    uint32_t ipfix_ver;

    /*! Packet sampling (PSAMP) epoch / revision number. */
    uint16_t psamp_epoch;

    /*! Variable flag (default to 0xFF). */
    uint8_t variable_flag;

    /*! Enable to encapsulate with sequence number. */
    bool seq_ena;

    /*! Sequence number inserted into IPFIX header. */
    uint32_t seq_num;

    /*! Enable to encapsulate with HiGig3 header. Applicable only if destination port is remote port. */
    bool hg3_ena;

    /*! HiGig3 header. Applicable only if hg3_ena is set. */
    mirror_encap_hg3_header_t hg3_header;

} mirror_encap_psamp_ipv6_t;

/*!
 * \brief sFlow encapsulation structure.
 */
typedef struct mirror_encap_sflow_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv4 address. */
    bcm_ip_t src_ipv4;

    /*! Destination IPv4 address. */
    bcm_ip_t dst_ipv4;

    /*! IPv4 type of service. */
    uint8_t tos;

    /*! IPv4 time to live. */
    uint8_t ttl;

    /*! IPv4 protocol type. */
    uint8_t proto;

    /*! IPv4 dont fragment flag. */
    bool df;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Enable to encapsulate with sequence number. */
    bool seq_ena;

    /*! Sequence number inserted into SFLOW header. */
    uint32_t seq_num;

    /*! Enable to encapsulate with HiGig3 header. Applicable only if destination port is remote port. */
    bool hg3_ena;

    /*! HiGig3 header. Applicable only if hg3_ena is set. */
    mirror_encap_hg3_header_t hg3_header;

} mirror_encap_sflow_t;

/*!
 * \brief sFlow IPv6 encapsulation structure.
 */
typedef struct mirror_encap_sflow_ipv6_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv6 address. */
    bcm_ip6_t src_ipv6;

    /*! Destination IPv6 address. */
    bcm_ip6_t dst_ipv6;

    /*! IPv6 traffic class. */
    uint8_t traffic_class;

    /*! IPv6 hop limit. */
    uint8_t hop_limit;

    /*! IPv6 next header. */
    uint8_t next_header;

    /*! IPv6 flow label. */
    uint32_t flow_label;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Enable to add starting sequence number in sFlow header. */
    bool initial_seq_num_ena;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Enable to encapsulate with sequence number. */
    bool seq_ena;

    /*! Sequence number inserted into SFLOW header. */
    uint32_t seq_num;

    /*! Enable to encapsulate with HiGig3 header. Applicable only if destination port is remote port. */
    bool hg3_ena;

    /*! HiGig3 header. Applicable only if hg3_ena is set. */
    mirror_encap_hg3_header_t hg3_header;

} mirror_encap_sflow_ipv6_t;

/*!
 * \brief Mirror-on-drop encapsulation structure.
 */
typedef struct mirror_encap_mirror_on_drop_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv4 address. */
    bcm_ip_t src_ipv4;

    /*! Destination IPv4 address. */
    bcm_ip_t dst_ipv4;

    /*! IPv4 type of service. */
    uint8_t tos;

    /*! IPv4 time to live. */
    uint8_t ttl;

    /*! IPv4 protocol type. */
    uint8_t proto;

    /*! IPv4 dont fragment flag. */
    bool df;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Observation domain for IP flow information export (IPFIX) header. */
    uint32_t observation_domain;

    /*! Template identifier for IPFIX header. */
    uint16_t template_id;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Packet sampling (PSAMP) IP flow information export (IPFIX) version number. */
    uint32_t ipfix_ver;

    /*! Switch id. */
    uint32_t switch_id;

    /*! Variable flag (default to 0xFF). */
    uint8_t variable_flag;

    /*! Enable to encapsulate with sequence number. */
    bool seq_ena;

    /*! Sequence number inserted into IPFIX header. */
    uint32_t seq_num;

    /*! Enable to encapsulate with HiGig3 header. Applicable only if destination port is remote port. */
    bool hg3_ena;

    /*! HiGig3 header. Applicable only if hg3_ena is set. */
    mirror_encap_hg3_header_t hg3_header;

    /*! Mirror-on-drop mode. */
    bcmi_ltsw_mirror_mirror_on_drop_mode_t mode;

} mirror_encap_mirror_on_drop_t;

/*!
 * \brief sFlow IPv6 encapsulation structure.
 */
typedef struct mirror_encap_mirror_on_drop_ipv6_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv6 address. */
    bcm_ip6_t src_ipv6;

    /*! Destination IPv6 address. */
    bcm_ip6_t dst_ipv6;

    /*! IPv6 traffic class. */
    uint8_t traffic_class;

    /*! IPv6 hop limit. */
    uint8_t hop_limit;

    /*! IPv6 next header. */
    uint8_t next_header;

    /*! IPv6 flow label. */
    uint32_t flow_label;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Observation domain for IP flow information export (IPFIX) header. */
    uint32_t observation_domain;

    /*! Template identifier for IPFIX header. */
    uint16_t template_id;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Packet sampling (PSAMP) IP flow information export (IPFIX) version number. */
    uint32_t ipfix_ver;

    /*! Switch id. */
    uint32_t switch_id;

    /*! Variable flag (default to 0xFF). */
    uint8_t variable_flag;

    /*! Enable to encapsulate with sequence number. */
    bool seq_ena;

    /*! Sequence number inserted into IPFIX header. */
    uint32_t seq_num;

    /*! Enable to encapsulate with HiGig3 header. Applicable only if destination port is remote port. */
    bool hg3_ena;

    /*! HiGig3 header. Applicable only if hg3_ena is set. */
    mirror_encap_hg3_header_t hg3_header;

    /*! Mirror-on-drop mode. */
    bcmi_ltsw_mirror_mirror_on_drop_mode_t mode;

} mirror_encap_mirror_on_drop_ipv6_t;

/*!
 * \brief VXLAN encap structure.
 */
typedef struct mirror_encap_vxlan_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv4 address. */
    bcm_ip_t src_ipv4;

    /*! Destination IPv4 address. */
    bcm_ip_t dst_ipv4;

    /*! IPv4 type of service. */
    uint8_t tos;

    /*! IPv4 time to live. */
    uint8_t ttl;

    /*! IPv4 protocol type. */
    uint8_t proto;

    /*! IPv4 dont fragment flag. */
    bool df;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! The type of VXLAN header. */
    int vxlan_type;

    /*! Encapsulation VNID in VXLAN packet Header. Applicable only if VXLAN_TYPE == TABLE_VXLAN. */
    uint32_t vxlan_vnid;

    /*! Enable to encapsulate with HiGig3 header. Applicable only if destination port is remote port. */
    bool hg3_ena;

    /*! HiGig3 header. Applicable only if hg3_ena is set. */
    mirror_encap_hg3_header_t hg3_header;

} mirror_encap_vxlan_t;

/*!
 * \brief VXLAN IPv6 encapsulation structure.
 */
typedef struct mirror_encap_vxlan_ipv6_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv6 address. */
    bcm_ip6_t src_ipv6;

    /*! Destination IPv6 address. */
    bcm_ip6_t dst_ipv6;

    /*! IPv6 traffic class. */
    uint8_t traffic_class;

    /*! IPv6 hop limit. */
    uint8_t hop_limit;

    /*! IPv6 next header. */
    uint8_t next_header;

    /*! IPv6 flow label. */
    uint32_t flow_label;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! The type of VXLAN header. */
    int vxlan_type;

    /*! Encapsulation VNID in VXLAN packet Header. Applicable only if VXLAN_TYPE == TABLE_VXLAN. */
    uint32_t vxlan_vnid;

    /*! Enable to encapsulate with HiGig3 header. Applicable only if destination port is remote port. */
    bool hg3_ena;

    /*! HiGig3 header. Applicable only if hg3_ena is set. */
    mirror_encap_hg3_header_t hg3_header;

} mirror_encap_vxlan_ipv6_t;

/*!
 * \brief IFA 1.0 Proble encapsulation structure.
 */
typedef struct mirror_encap_ifa_1_probe_s {

    /*! ProbeMarker1 Value. */
    uint32_t probemarker_1;

    /*! ProbeMarker2 Value. */
    uint32_t probemarker_2;

    /*! Version. */
    uint8_t version;

    /*! Message type. */
    uint8_t msg_type;

    /*! Telemetry request vector. */
    uint16_t request_vector;

    /*! Telemetry action vector. */
    uint16_t action_vector;

    /*! Hop Limit condition. */
    uint16_t hop_limit;

    /*! Maximum length. */
    uint16_t max_length;

} mirror_encap_ifa_1_probe_t;

/******************************************************************************
 * Private functions
 */


/*
 * Encapsulation type.
 */
typedef enum {
    /* No encap header. */
    ENCAP_NONE,

    /* RSPAN encap. */
    ENCAP_RSPAN,

    /* ERSPAN encap. */
    ENCAP_ERSPAN,

    /* ERSPAN IPv6 encap. */
    ENCAP_ERSPAN_IPv6,

    /* PSAMP encap. */
    ENCAP_PSAMP,

    /* PSAMP IPv6 encap. */
    ENCAP_PSAMP_IPv6,

    /* sFlow encap. */
    ENCAP_SFLOW,

    /* sFlow IPv6 encap. */
    ENCAP_SFLOW_IPv6,

    /* Mirror-on-drop encap. */
    ENCAP_MIRROR_ON_DROP,

    /* Mirror-on-drop IPv6 encap. */
    ENCAP_MIRROR_ON_DROP_IPv6,

    /* VXLAN encap. */
    ENCAP_VXLAN,

    /* VXLAN IPv6 encap. */
    ENCAP_VXLAN_IPv6,

    /* IFA 1.0 probe encap. */
    ENCAP_IFA_1_PROBE,

    /* Last encap type. */
    ENCAP_COUNT
} mirror_encap_type;

/*
 * Helper info structure for mirror encap.
 */
typedef struct mirror_encap_helper_info_s {
    /* Pipe id of mirror destination local port. */
    int pipe;
} mirror_encap_helper_info_t;

/*
 * Data structure for Mirror encapsulation profile entry.
 */
typedef struct mirror_encap_profile_entry_s {
    /* Egress mirroring or not. */
    bool egr;

    /* Truncate or not. */
    bool truncate;

    /* Truncate mode. */
    bcm_mirror_truncate_mode_t truncate_mode;

    /* Truncate length profile id. */
    int truncate_profile_id;

    /* Destination system port ID. */
    int sys_port;

    /* Encap type. */
    mirror_encap_type type;

    /*
     * Enable to add loopback header ahead of mirror encapsulation header.
     */
    bool lb_ena;

    /* Loopback header added to mirror copy, applicable only if lb_ena is true. */
    mirror_encap_lb_header_t lb_header;

    /* Encap data. */
    union {
        mirror_encap_rspan_t rspan;
        mirror_encap_erspan_t erspan;
        mirror_encap_erspan_ipv6_t erspan_ipv6;
        mirror_encap_psamp_t psamp;
        mirror_encap_psamp_ipv6_t psamp_ipv6;
        mirror_encap_sflow_t sflow;
        mirror_encap_sflow_ipv6_t sflow_ipv6;
        mirror_encap_mirror_on_drop_t mirror_on_drop;
        mirror_encap_mirror_on_drop_ipv6_t mirror_on_drop_ipv6;
        mirror_encap_vxlan_t vxlan;
        mirror_encap_vxlan_ipv6_t vxlan_ipv6;
        mirror_encap_ifa_1_probe_t ifa_1_probe;
    } encap;

    /* Helper info. */
    mirror_encap_helper_info_t helper_info;
} mirror_encap_profile_entry_t;

/*
 * Data structure to store encapsulation information.
 */
typedef struct mirror_encap_info_s {
    /* Encap type for specific encap entry. */
    mirror_encap_type *type;
} mirror_encap_info_t;

static mirror_encap_info_t mirror_encap_info[BCM_MAX_NUM_UNITS];

static const bcmint_mirror_db_t *xfs_mirror_db[BCM_MAX_NUM_UNITS];

/*
 * Data structure to store truncate information.
 */
typedef struct mirror_truncate_info_s {

    /* Truncate length profile num. */
    int length_prf_num;

    /* Truncate length profile id used bitmap. */
    SHR_BITDCL *length_prf_bmp;

} mirror_truncate_info_t;

static mirror_truncate_info_t mirror_truncate_info[BCM_MAX_NUM_UNITS];

/* Mirror truncate length profile number. */
#define MIRROR_TRUNCATE_LENGTH_PRF_NUM(unit) \
    (mirror_truncate_info[unit].length_prf_num)

/* Mirror truncate length profile id used bitmap. */
#define MIRROR_TRUNCATE_LENGTH_PRF_BMP(unit) \
    (mirror_truncate_info[unit].length_prf_bmp)

/* Set Mirror truncate length profile used bitmap. */
#define MIRROR_TRUNCATE_LENGTH_PRF_BMP_USED_SET(unit, id) \
    (SHR_BITSET(MIRROR_TRUNCATE_LENGTH_PRF_BMP(unit), id))

/* Get Mirror truncate length profile used bitmap. */
#define MIRROR_TRUNCATE_LENGTH_PRF_BMP_USED_GET(unit, id) \
    (SHR_BITGET(MIRROR_TRUNCATE_LENGTH_PRF_BMP(unit), id))

/* Clear Mirror truncate length profile used bitmap. */
#define MIRROR_TRUNCATE_LENGTH_PRF_BMP_USED_CLR(unit, id) \
    (SHR_BITCLR(MIRROR_TRUNCATE_LENGTH_PRF_BMP(unit), id))

/* Check Mirror truncate length profile id is valid. */
#define MIRROR_TRUNCATE_LENGTH_PRF_ID_CHECK(unit, id) \
    do { \
        if ((id) < 0 || (id) >= MIRROR_TRUNCATE_LENGTH_PRF_NUM(unit)) { \
            SHR_ERR_EXIT(SHR_E_BADID); \
        } \
    } while (0)

/*!
 * \brief Add Mirror sequence number table.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] pipe PP pipe id.
 * \param [in] seq_num Sequence number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_seq_num_table_add(int unit, int index, int pipe, int seq_num)
{
    int seq_table_index = index, profile_index = 0;
    bcmi_ltsw_tunnel_encap_seq_profile_t entry;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {SEQs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {TNL_ENCAP_SEQUENCE_NUMBER_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {TNL_ENCAP_SEQUENCE_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    /* Get sequence number table index. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_tunnel_encap_seq_num_alloc(unit, 0,
                                              ENCAP_SEQ_NUM_TYPE_MIRROR,
                                              &seq_table_index));
    /* Add sequence number table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_tunnel_encap_seq_num_set(unit,
                                            seq_table_index,
                                            pipe,
                                            seq_num));

    sal_memset(&entry, 0, sizeof(entry));
    entry.enable = true;
    entry.increment = true;
    entry.reserved_value = 0;
    entry.update_en = true;
    entry.mask = 0;

    /* Add sequence profile table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_tunnel_encap_seq_profile_add(unit, &entry, &profile_index));

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = true;
    field[2].u.val = seq_table_index;
    field[3].u.val = profile_index;

    /* Add Mirror sequence number table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_EGR_SEQs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror sequence number table.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] seq_num Sequence number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_seq_num_table_delete(int unit, int index)
{
    int seq_table_index, profile_index;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {SEQs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {TNL_ENCAP_SEQUENCE_NUMBER_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {TNL_ENCAP_SEQUENCE_PROFILE_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_EGR_SEQs,
                           &lt_entry,
                           NULL, NULL));
    seq_table_index = field[2].u.val;
    profile_index = field[3].u.val;

    /* Delete Mirror sequence number table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_EGR_SEQs, &lt_entry, NULL));

    /* Clear sequence number table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_tunnel_encap_seq_num_set(unit, 0,
                                            seq_table_index,
                                            0));
    /* Free sequence number table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_tunnel_encap_seq_num_free(unit,
                                             ENCAP_SEQ_NUM_TYPE_MIRROR,
                                             seq_table_index
                                             ));
    /* Delete sequence profile table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_tunnel_encap_seq_profile_delete(unit, profile_index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror sequence number.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] pipe PP pipe id.
 * \param [out] ena Enable to generate sequence number.
 * \param [out] seq_num Sequence number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_seq_num_table_get(int unit, int index, int pipe, bool *ena,
                               uint32_t *seq_num)
{
    int seq_table_index, rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {SEQs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {TNL_ENCAP_SEQUENCE_NUMBER_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    rv = bcmi_lt_entry_get(unit,
                           MIRROR_EGR_SEQs,
                           &lt_entry,
                           NULL, NULL);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_EXIT();
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    seq_table_index = field[2].u.val;
    *ena = field[1].u.val;

    rv = bcmi_ltsw_tunnel_encap_seq_num_get(unit,
                                            seq_table_index,
                                            pipe,
                                            seq_num);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_EXIT();
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to RSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_table_add(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {VNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {SRC_NIV_VIFs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {DST_NIV_VIFs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[2].u.val = entry->encap.rspan.vlan_id;
    field[3].u.val = entry->encap.rspan.tpid;
    field[4].u.val = entry->encap.rspan.vn_tag;
    field[5].u.val = entry->encap.rspan.src_niv_vif;
    field[6].u.val = entry->encap.rspan.dst_niv_vif;
    field[7].u.val = entry->encap.rspan.pri;
    field[8].u.val = entry->encap.rspan.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit, MIRROR_ENCAP_RSPANs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from RSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_ENCAP_RSPANs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from RSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_table_get(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {VNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_NIV_VIFs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_NIV_VIFs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_RSPANs,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.rspan.vlan_id = field[2].u.val;
    entry->encap.rspan.tpid = field[3].u.val;
    entry->encap.rspan.vn_tag = field[4].u.val;
    entry->encap.rspan.src_niv_vif = field[5].u.val;
    entry->encap.rspan.dst_niv_vif = field[6].u.val;
    entry->encap.rspan.pri = field[7].u.val;
    entry->encap.rspan.cfi = field[8].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to ERSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_table_add(int unit, int index,
                              mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {GRE_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {SESSION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {SWITCH_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {SEQs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {HIGIG3s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {ERSPAN3_SUB_HDR_HW_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {ERSPAN3_SUB_HDR_TS_GRAs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*23*/ {ERSPAN3_SUB_HDR_OPT_SUB_HDRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*24*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*25*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.erspan.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.erspan.dst_mac);
    field[3].u.val = data;
    field[4].u.val = entry->encap.erspan.src_ipv4;
    field[5].u.val = entry->encap.erspan.dst_ipv4;
    field[6].u.val = entry->encap.erspan.tos;
    field[7].u.val = entry->encap.erspan.ttl;
    field[8].u.val = entry->encap.erspan.proto;
    field[9].u.val = entry->encap.erspan.df;
    field[10].u.val = entry->encap.erspan.ethertype;
    field[11].u.val = entry->encap.erspan.outer_vlan;
    field[12].u.val = entry->encap.erspan.vlan_id;
    field[13].u.val = entry->encap.erspan.tpid;
    field[14].u.val = entry->encap.erspan.gre_header;
    field[15].u.val = entry->encap.erspan.session_id;
    field[16].u.val = entry->encap.erspan.switch_id;
    field[17].u.val = entry->encap.erspan.seq_ena;
    field[18].u.val = entry->encap.erspan.hg3_ena;
    field[19].u.val = entry->encap.erspan.hg3_header.ethertype;
    field[20].u.val = entry->encap.erspan.hg3_header.base_hdr;
    field[21].u.val = entry->encap.erspan.erspan3_sub_header.hw_id;
    field[22].u.val = entry->encap.erspan.erspan3_sub_header.ts_gra;
    field[23].u.val = entry->encap.erspan.erspan3_sub_header.optional_hdr;
    field[24].u.val = entry->encap.erspan.pri;
    field[25].u.val = entry->encap.erspan.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit, MIRROR_ENCAP_ERSPANs, &lt_entry, NULL));

    /* Add sequence number table if needed. */
    if (entry->encap.erspan.seq_ena) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_seq_num_table_add(unit,
                                            index,
                                            entry->helper_info.pipe,
                                            entry->encap.erspan.seq_num));
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from ERSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_ENCAP_ERSPANs, &lt_entry, NULL));

    /* Delete sequence number table if any. */
    rv = mirror_encap_seq_num_table_delete(unit, index);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from ERSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_table_get(int unit, int index,
                              mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {GRE_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {SESSION_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {SWITCH_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {SEQs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {HIGIG3s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {ERSPAN3_SUB_HDR_HW_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {ERSPAN3_SUB_HDR_TS_GRAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*23*/ {ERSPAN3_SUB_HDR_OPT_SUB_HDRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*24*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*25*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_ERSPANs,
                           &lt_entry,
                           NULL, NULL));

    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.erspan.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.erspan.dst_mac, &data);
    entry->encap.erspan.src_ipv4 = field[4].u.val;
    entry->encap.erspan.dst_ipv4 = field[5].u.val;
    entry->encap.erspan.tos = field[6].u.val;
    entry->encap.erspan.ttl = field[7].u.val;
    entry->encap.erspan.proto = field[8].u.val;
    entry->encap.erspan.df = field[9].u.val;
    entry->encap.erspan.ethertype = field[10].u.val;
    entry->encap.erspan.outer_vlan = field[11].u.val;
    entry->encap.erspan.vlan_id = field[12].u.val;
    entry->encap.erspan.tpid = field[13].u.val;
    entry->encap.erspan.gre_header = field[14].u.val;
    entry->encap.erspan.session_id = field[15].u.val;
    entry->encap.erspan.switch_id = field[16].u.val;
    entry->encap.erspan.seq_ena = field[17].u.val;
    entry->encap.erspan.hg3_ena = field[18].u.val;
    entry->encap.erspan.hg3_header.ethertype = field[19].u.val;
    entry->encap.erspan.hg3_header.base_hdr = field[20].u.val;
    entry->encap.erspan.erspan3_sub_header.hw_id = field[21].u.val;
    entry->encap.erspan.erspan3_sub_header.ts_gra = field[22].u.val;
    entry->encap.erspan.erspan3_sub_header.optional_hdr = field[23].u.val;
    entry->encap.erspan.pri = field[24].u.val;
    entry->encap.erspan.cfi = field[25].u.val;

    /* Get sequence number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_seq_num_table_get(unit, index,
                                        entry->helper_info.pipe,
                                        &entry->encap.erspan.seq_ena,
                                        &entry->encap.erspan.seq_num));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to ERSPAN IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_ipv6_table_add(int unit, int index,
                                   mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {GRE_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {SESSION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {SWITCH_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {SEQs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {HIGIG3s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*23*/ {ERSPAN3_SUB_HDR_HW_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*24*/ {ERSPAN3_SUB_HDR_TS_GRAs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*25*/ {ERSPAN3_SUB_HDR_OPT_SUB_HDRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*26*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*27*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.erspan_ipv6.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.erspan_ipv6.dst_mac);
    field[3].u.val = data;
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.erspan_ipv6.src_ipv6);
    field[4].u.val = ipv6_addr[1];
    field[5].u.val = ipv6_addr[0];
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.erspan_ipv6.dst_ipv6);
    field[6].u.val = ipv6_addr[1];
    field[7].u.val = ipv6_addr[0];
    field[8].u.val = entry->encap.erspan_ipv6.traffic_class;
    field[9].u.val = entry->encap.erspan_ipv6.hop_limit;
    field[10].u.val = entry->encap.erspan_ipv6.next_header;
    field[11].u.val = entry->encap.erspan_ipv6.flow_label;
    field[12].u.val = entry->encap.erspan_ipv6.ethertype;
    field[13].u.val = entry->encap.erspan_ipv6.outer_vlan;
    field[14].u.val = entry->encap.erspan_ipv6.vlan_id;
    field[15].u.val = entry->encap.erspan_ipv6.tpid;
    field[16].u.val = entry->encap.erspan_ipv6.gre_header;
    field[17].u.val = entry->encap.erspan_ipv6.session_id;
    field[18].u.val = entry->encap.erspan_ipv6.switch_id;
    field[19].u.val = entry->encap.erspan_ipv6.seq_ena;
    field[20].u.val = entry->encap.erspan_ipv6.hg3_ena;
    field[21].u.val = entry->encap.erspan_ipv6.hg3_header.ethertype;
    field[22].u.val = entry->encap.erspan_ipv6.hg3_header.base_hdr;
    field[23].u.val = entry->encap.erspan_ipv6.erspan3_sub_header.hw_id;
    field[24].u.val = entry->encap.erspan_ipv6.erspan3_sub_header.ts_gra;
    field[25].u.val = entry->encap.erspan_ipv6.erspan3_sub_header.optional_hdr;
    field[26].u.val = entry->encap.erspan_ipv6.pri;
    field[27].u.val = entry->encap.erspan_ipv6.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_ERSPAN_IPV6s,
                              &lt_entry,
                              NULL));
    /* Add sequence number table if needed. */
    if (entry->encap.erspan_ipv6.seq_ena) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_seq_num_table_add(unit,
                                            index,
                                            entry->helper_info.pipe,
                                            entry->encap.erspan_ipv6.seq_num));
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from ERSPAN IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_ipv6_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_ERSPAN_IPV6s,
                              &lt_entry,
                              NULL));
    /* Delete sequence number table if any. */
    rv = mirror_encap_seq_num_table_delete(unit, index);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from ERSPAN IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_ipv6_table_get(int unit, int index,
                                   mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {GRE_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {SESSION_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {SWITCH_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {SEQs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {HIGIG3s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*23*/ {ERSPAN3_SUB_HDR_HW_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*24*/ {ERSPAN3_SUB_HDR_TS_GRAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*25*/ {ERSPAN3_SUB_HDR_OPT_SUB_HDRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*26*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*27*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_ERSPAN_IPV6s,
                           &lt_entry,
                           NULL, NULL));

    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.erspan_ipv6.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.erspan_ipv6.dst_mac, &data);
    ipv6_addr[1] = field[4].u.val;
    ipv6_addr[0] = field[5].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.erspan_ipv6.src_ipv6, ipv6_addr);
    ipv6_addr[1] = field[6].u.val;
    ipv6_addr[0] = field[7].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.erspan_ipv6.dst_ipv6, ipv6_addr);
    entry->encap.erspan_ipv6.traffic_class = field[8].u.val;
    entry->encap.erspan_ipv6.hop_limit = field[9].u.val;
    entry->encap.erspan_ipv6.next_header = field[10].u.val;
    entry->encap.erspan_ipv6.flow_label = field[11].u.val;
    entry->encap.erspan_ipv6.ethertype = field[12].u.val;
    entry->encap.erspan_ipv6.outer_vlan = field[13].u.val;
    entry->encap.erspan_ipv6.vlan_id = field[14].u.val;
    entry->encap.erspan_ipv6.tpid = field[15].u.val;
    entry->encap.erspan_ipv6.gre_header = field[16].u.val;
    entry->encap.erspan_ipv6.session_id = field[17].u.val;
    entry->encap.erspan_ipv6.switch_id = field[18].u.val;
    entry->encap.erspan_ipv6.seq_ena = field[19].u.val;
    entry->encap.erspan_ipv6.hg3_ena = field[20].u.val;
    entry->encap.erspan_ipv6.hg3_header.ethertype = field[21].u.val;
    entry->encap.erspan_ipv6.hg3_header.base_hdr = field[22].u.val;
    entry->encap.erspan_ipv6.erspan3_sub_header.hw_id = field[23].u.val;
    entry->encap.erspan_ipv6.erspan3_sub_header.ts_gra = field[24].u.val;
    entry->encap.erspan_ipv6.erspan3_sub_header.optional_hdr = field[25].u.val;
    entry->encap.erspan_ipv6.pri = field[26].u.val;
    entry->encap.erspan_ipv6.cfi = field[27].u.val;

    /* Get sequence number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_seq_num_table_get(unit, index,
                                        entry->helper_info.pipe,
                                        &entry->encap.erspan_ipv6.seq_ena,
                                        &entry->encap.erspan_ipv6.seq_num));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to PSAMP LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_table_add(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {METADATA_TYPEs, 0, 0, {0}},
        /*19*/ {METADATAs, 0, 0, {0}},
        /*20*/ {IPFIX_VERSIONs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {PSAMP_EPOCHs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {VARIABLE_FLAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*23*/ {HIGIG3s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*24*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*25*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*26*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*27*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp.dst_mac);
    field[3].u.val = data;
    field[4].u.val = entry->encap.psamp.src_ipv4;
    field[5].u.val = entry->encap.psamp.dst_ipv4;
    field[6].u.val = entry->encap.psamp.tos;
    field[7].u.val = entry->encap.psamp.ttl;
    field[8].u.val = entry->encap.psamp.proto;
    field[9].u.val = entry->encap.psamp.df;
    field[10].u.val = entry->encap.psamp.l4_dst_port;
    field[11].u.val = entry->encap.psamp.l4_src_port;
    field[12].u.val = entry->encap.psamp.ethertype;
    field[13].u.val = entry->encap.psamp.outer_vlan;
    field[14].u.val = entry->encap.psamp.vlan_id;
    field[15].u.val = entry->encap.psamp.tpid;
    field[16].u.val = entry->encap.psamp.observation_domain;
    field[17].u.val = entry->encap.psamp.template_id;
    if (entry->encap.psamp.metadata_type == bcmMirrorPsampFmt2HeaderUserMeta) {
        field[18].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[18].u.sym_val = TABLE_METADATAs;
        field[19].flags = BCMI_LT_FIELD_F_SET;
        field[19].u.val = entry->encap.psamp.metadata;
    } else if (entry->encap.psamp.metadata_type ==
               bcmMirrorPsampFmt2HeaderZeroes) {
        field[18].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[18].u.sym_val = ZEROESs;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    field[20].u.val = entry->encap.psamp.ipfix_ver;
    field[21].u.val = entry->encap.psamp.psamp_epoch;
    field[22].u.val = entry->encap.psamp.variable_flag;
    field[23].u.val = entry->encap.psamp.hg3_ena;
    field[24].u.val = entry->encap.psamp.hg3_header.ethertype;
    field[25].u.val = entry->encap.psamp.hg3_header.base_hdr;
    field[26].u.val = entry->encap.psamp.pri;
    field[27].u.val = entry->encap.psamp.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_PSAMP_METADATAs,
                              &lt_entry,
                              NULL));
    /* Add sequence number table if needed. */
    if (entry->encap.psamp.seq_ena) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_seq_num_table_add(unit,
                                            index,
                                            entry->helper_info.pipe,
                                            entry->encap.psamp.seq_num));
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from PSAMP LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_PSAMP_METADATAs,
                              &lt_entry,
                              NULL));
    /* Delete sequence number table if any. */
    rv = mirror_encap_seq_num_table_delete(unit, index);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from PSAMP LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_table_get(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_GET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*19*/ {METADATAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {IPFIX_VERSIONs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {PSAMP_EPOCHs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {VARIABLE_FLAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*23*/ {HIGIG3s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*24*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*25*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*26*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*27*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_PSAMP_METADATAs,
                           &lt_entry,
                           NULL, NULL));

    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp.dst_mac, &data);
    entry->encap.psamp.src_ipv4 = field[4].u.val;
    entry->encap.psamp.dst_ipv4 = field[5].u.val;
    entry->encap.psamp.tos = field[6].u.val;
    entry->encap.psamp.ttl = field[7].u.val;
    entry->encap.psamp.proto = field[8].u.val;
    entry->encap.psamp.df = field[9].u.val;
    entry->encap.psamp.l4_dst_port = field[10].u.val;
    entry->encap.psamp.l4_src_port = field[11].u.val;
    entry->encap.psamp.ethertype = field[12].u.val;
    entry->encap.psamp.outer_vlan = field[13].u.val;
    entry->encap.psamp.vlan_id = field[14].u.val;
    entry->encap.psamp.tpid = field[15].u.val;
    entry->encap.psamp.observation_domain = field[16].u.val;
    entry->encap.psamp.template_id = field[17].u.val;
    if (sal_strcmp(field[18].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.psamp.metadata_type = bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.psamp.metadata = field[19].u.val;
    } else {
        entry->encap.psamp.metadata_type = bcmMirrorPsampFmt2HeaderZeroes;
    }
    entry->encap.psamp.ipfix_ver = field[20].u.val;
    entry->encap.psamp.psamp_epoch = field[21].u.val;
    entry->encap.psamp.variable_flag = field[22].u.val;
    entry->encap.psamp.hg3_ena = field[23].u.val;
    entry->encap.psamp.hg3_header.ethertype = field[24].u.val;
    entry->encap.psamp.hg3_header.base_hdr = field[25].u.val;
    entry->encap.psamp.pri = field[26].u.val;
    entry->encap.psamp.cfi = field[27].u.val;

    /* Get sequence number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_seq_num_table_get(unit, index,
                                        entry->helper_info.pipe,
                                        &entry->encap.psamp.seq_ena,
                                        &entry->encap.psamp.seq_num));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to PSAMP IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_ipv6_table_add(int unit, int index,
                                  mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {METADATA_TYPEs, 0, 0, {0}},
        /*21*/ {METADATAs, 0, 0, {0}},
        /*22*/ {IPFIX_VERSIONs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*23*/ {PSAMP_EPOCHs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*24*/ {VARIABLE_FLAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*25*/ {HIGIG3s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*26*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*27*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*28*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*29*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp_ipv6.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp_ipv6.dst_mac);
    field[3].u.val = data;
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.psamp_ipv6.src_ipv6);
    field[4].u.val = ipv6_addr[1];
    field[5].u.val = ipv6_addr[0];
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.psamp_ipv6.dst_ipv6);
    field[6].u.val = ipv6_addr[1];
    field[7].u.val = ipv6_addr[0];
    field[8].u.val = entry->encap.psamp_ipv6.traffic_class;
    field[9].u.val = entry->encap.psamp_ipv6.hop_limit;
    field[10].u.val = entry->encap.psamp_ipv6.next_header;
    field[11].u.val = entry->encap.psamp_ipv6.flow_label;
    field[12].u.val = entry->encap.psamp_ipv6.l4_dst_port;
    field[13].u.val = entry->encap.psamp_ipv6.l4_src_port;
    field[14].u.val = entry->encap.psamp_ipv6.ethertype;
    field[15].u.val = entry->encap.psamp_ipv6.outer_vlan;
    field[16].u.val = entry->encap.psamp_ipv6.vlan_id;
    field[17].u.val = entry->encap.psamp_ipv6.tpid;
    field[18].u.val = entry->encap.psamp_ipv6.observation_domain;
    field[19].u.val = entry->encap.psamp_ipv6.template_id;
    if (entry->encap.psamp_ipv6.metadata_type ==
        bcmMirrorPsampFmt2HeaderUserMeta) {
        field[20].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[20].u.sym_val = TABLE_METADATAs;
        field[21].flags = BCMI_LT_FIELD_F_SET;
        field[21].u.val = entry->encap.psamp_ipv6.metadata;
    } else if (entry->encap.psamp_ipv6.metadata_type ==
               bcmMirrorPsampFmt2HeaderZeroes) {
        field[20].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[20].u.sym_val = ZEROESs;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    field[22].u.val = entry->encap.psamp_ipv6.ipfix_ver;
    field[23].u.val = entry->encap.psamp_ipv6.psamp_epoch;
    field[24].u.val = entry->encap.psamp_ipv6.variable_flag;
    field[25].u.val = entry->encap.psamp_ipv6.hg3_ena;
    field[26].u.val = entry->encap.psamp_ipv6.hg3_header.ethertype;
    field[27].u.val = entry->encap.psamp_ipv6.hg3_header.base_hdr;
    field[28].u.val = entry->encap.psamp_ipv6.pri;
    field[29].u.val = entry->encap.psamp_ipv6.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_PSAMP_METADATA_IPV6s,
                              &lt_entry,
                              NULL));
    /* Add sequence number table if needed. */
    if (entry->encap.psamp_ipv6.seq_ena) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_seq_num_table_add(unit,
                                            index,
                                            entry->helper_info.pipe,
                                            entry->encap.psamp_ipv6.seq_num));
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from PSAMP IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_ipv6_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_PSAMP_METADATA_IPV6s,
                              &lt_entry,
                              NULL));
    /* Delete sequence number table if any. */
    rv = mirror_encap_seq_num_table_delete(unit, index);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from PSAMP IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_ipv6_table_get(int unit, int index,
                                  mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_GET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*21*/ {METADATAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {IPFIX_VERSIONs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*23*/ {PSAMP_EPOCHs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*24*/ {VARIABLE_FLAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*25*/ {HIGIG3s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*26*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*27*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*28*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*29*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_PSAMP_METADATA_IPV6s,
                           &lt_entry,
                           NULL, NULL));

    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp_ipv6.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp_ipv6.dst_mac, &data);
    ipv6_addr[1] = field[4].u.val;
    ipv6_addr[0] = field[5].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.psamp_ipv6.src_ipv6, ipv6_addr);
    ipv6_addr[1] = field[6].u.val;
    ipv6_addr[0] = field[7].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.psamp_ipv6.dst_ipv6, ipv6_addr);
    entry->encap.psamp_ipv6.traffic_class = field[8].u.val;
    entry->encap.psamp_ipv6.hop_limit = field[9].u.val;
    entry->encap.psamp_ipv6.next_header = field[10].u.val;
    entry->encap.psamp_ipv6.flow_label = field[11].u.val;
    entry->encap.psamp_ipv6.l4_dst_port = field[12].u.val;
    entry->encap.psamp_ipv6.l4_src_port = field[13].u.val;
    entry->encap.psamp_ipv6.ethertype = field[14].u.val;
    entry->encap.psamp_ipv6.outer_vlan = field[15].u.val;
    entry->encap.psamp_ipv6.vlan_id = field[16].u.val;
    entry->encap.psamp_ipv6.tpid = field[17].u.val;
    entry->encap.psamp_ipv6.observation_domain = field[18].u.val;
    entry->encap.psamp_ipv6.template_id = field[19].u.val;
    if (sal_strcmp(field[20].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.psamp_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.psamp_ipv6.metadata = field[21].u.val;
    } else {
        entry->encap.psamp_ipv6.metadata_type = bcmMirrorPsampFmt2HeaderZeroes;
    }
    entry->encap.psamp_ipv6.ipfix_ver = field[22].u.val;
    entry->encap.psamp_ipv6.psamp_epoch = field[23].u.val;
    entry->encap.psamp_ipv6.variable_flag = field[24].u.val;
    entry->encap.psamp_ipv6.hg3_ena = field[25].u.val;
    entry->encap.psamp_ipv6.hg3_header.ethertype = field[26].u.val;
    entry->encap.psamp_ipv6.hg3_header.base_hdr = field[27].u.val;
    entry->encap.psamp_ipv6.pri = field[28].u.val;
    entry->encap.psamp_ipv6.cfi = field[29].u.val;

    /* Get sequence number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_seq_num_table_get(unit, index,
                                        entry->helper_info.pipe,
                                        &entry->encap.psamp_ipv6.seq_ena,
                                        &entry->encap.psamp_ipv6.seq_num));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to SFLOW LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_table_add(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {METADATA_TYPEs, 0, 0, {0}},
        /*17*/ {METADATAs, 0, 0, {0}},
        /*18*/ {HIGIG3s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow.dst_mac);
    field[3].u.val = data;
    field[4].u.val = entry->encap.sflow.src_ipv4;
    field[5].u.val = entry->encap.sflow.dst_ipv4;
    field[6].u.val = entry->encap.sflow.tos;
    field[7].u.val = entry->encap.sflow.ttl;
    field[8].u.val = entry->encap.sflow.proto;
    field[9].u.val = entry->encap.sflow.df;
    field[10].u.val = entry->encap.sflow.l4_dst_port;
    field[11].u.val = entry->encap.sflow.l4_src_port;
    field[12].u.val = entry->encap.sflow.ethertype;
    field[13].u.val = entry->encap.sflow.outer_vlan;
    field[14].u.val = entry->encap.sflow.vlan_id;
    field[15].u.val = entry->encap.sflow.tpid;
    if (entry->encap.sflow.metadata_type == bcmMirrorPsampFmt2HeaderUserMeta) {
        field[16].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[16].u.sym_val = TABLE_METADATAs;
        field[17].flags = BCMI_LT_FIELD_F_SET;
        field[17].u.val = entry->encap.sflow.metadata;
    } else if (entry->encap.sflow.metadata_type ==
               bcmMirrorPsampFmt2HeaderZeroes) {
        field[16].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[16].u.sym_val = ZEROESs;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    field[18].u.val = entry->encap.sflow.hg3_ena;
    field[19].u.val = entry->encap.sflow.hg3_header.ethertype;
    field[20].u.val = entry->encap.sflow.hg3_header.base_hdr;
    field[21].u.val = entry->encap.sflow.pri;
    field[22].u.val = entry->encap.sflow.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_SFLOW_SEQs,
                              &lt_entry,
                              NULL));
    /* Add sequence number table if needed. */
    if (entry->encap.sflow.seq_ena) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_seq_num_table_add(unit,
                                            index,
                                            entry->helper_info.pipe,
                                            entry->encap.sflow.seq_num));
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from SFLOW LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_SFLOW_SEQs,
                              &lt_entry,
                              NULL));
    /* Delete sequence number table if any. */
    rv = mirror_encap_seq_num_table_delete(unit, index);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from SFLOW LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_table_get(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_GET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*17*/ {METADATAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {HIGIG3s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_SFLOW_SEQs,
                           &lt_entry,
                           NULL, NULL));

    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow.dst_mac, &data);
    entry->encap.sflow.src_ipv4 = field[4].u.val;
    entry->encap.sflow.dst_ipv4 = field[5].u.val;
    entry->encap.sflow.tos = field[6].u.val;
    entry->encap.sflow.ttl = field[7].u.val;
    entry->encap.sflow.proto = field[8].u.val;
    entry->encap.sflow.df = field[9].u.val;
    entry->encap.sflow.l4_dst_port = field[10].u.val;
    entry->encap.sflow.l4_src_port = field[11].u.val;
    entry->encap.sflow.ethertype = field[12].u.val;
    entry->encap.sflow.outer_vlan = field[13].u.val;
    entry->encap.sflow.vlan_id = field[14].u.val;
    entry->encap.sflow.tpid = field[15].u.val;
    if (sal_strcmp(field[16].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.sflow.metadata_type = bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.sflow.metadata = field[17].u.val;
    } else {
        entry->encap.sflow.metadata_type = bcmMirrorPsampFmt2HeaderZeroes;
    }
    entry->encap.sflow.hg3_ena = field[18].u.val;
    entry->encap.sflow.hg3_header.ethertype = field[19].u.val;
    entry->encap.sflow.hg3_header.base_hdr = field[20].u.val;
    entry->encap.sflow.pri = field[21].u.val;
    entry->encap.sflow.cfi = field[22].u.val;

    /* Get sequence number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_seq_num_table_get(unit, index,
                                        entry->helper_info.pipe,
                                        &entry->encap.sflow.seq_ena,
                                        &entry->encap.sflow.seq_num));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to SFLOW IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_ipv6_table_add(int unit, int index,
                                  mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {METADATA_TYPEs, 0, 0, {0}},
        /*19*/ {METADATAs, 0, 0, {0}},
        /*20*/ {HIGIG3s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*23*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*24*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow_ipv6.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow_ipv6.dst_mac);
    field[3].u.val = data;
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.sflow_ipv6.src_ipv6);
    field[4].u.val = ipv6_addr[1];
    field[5].u.val = ipv6_addr[0];
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.sflow_ipv6.dst_ipv6);
    field[6].u.val = ipv6_addr[1];
    field[7].u.val = ipv6_addr[0];
    field[8].u.val = entry->encap.sflow_ipv6.traffic_class;
    field[9].u.val = entry->encap.sflow_ipv6.hop_limit;
    field[10].u.val = entry->encap.sflow_ipv6.next_header;
    field[11].u.val = entry->encap.sflow_ipv6.flow_label;
    field[12].u.val = entry->encap.sflow_ipv6.l4_dst_port;
    field[13].u.val = entry->encap.sflow_ipv6.l4_src_port;
    field[14].u.val = entry->encap.sflow_ipv6.ethertype;
    field[15].u.val = entry->encap.sflow_ipv6.outer_vlan;
    field[16].u.val = entry->encap.sflow_ipv6.vlan_id;
    field[17].u.val = entry->encap.sflow_ipv6.tpid;
    if (entry->encap.sflow_ipv6.metadata_type ==
        bcmMirrorPsampFmt2HeaderUserMeta) {
        field[18].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[18].u.sym_val = TABLE_METADATAs;
        field[19].flags = BCMI_LT_FIELD_F_SET;
        field[19].u.val = entry->encap.sflow_ipv6.metadata;
    } else if (entry->encap.sflow_ipv6.metadata_type ==
               bcmMirrorPsampFmt2HeaderZeroes) {
        field[18].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[18].u.sym_val = ZEROESs;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    field[20].u.val = entry->encap.sflow_ipv6.hg3_ena;
    field[21].u.val = entry->encap.sflow_ipv6.hg3_header.ethertype;
    field[22].u.val = entry->encap.sflow_ipv6.hg3_header.base_hdr;
    field[23].u.val = entry->encap.sflow_ipv6.pri;
    field[24].u.val = entry->encap.sflow_ipv6.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_SFLOW_SEQ_IPV6s,
                              &lt_entry,
                              NULL));
    /* Add sequence number table if needed. */
    if (entry->encap.sflow_ipv6.seq_ena) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_seq_num_table_add(unit,
                                            index,
                                            entry->helper_info.pipe,
                                            entry->encap.sflow_ipv6.seq_num));
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from SFLOW IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_ipv6_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_SFLOW_SEQ_IPV6s,
                              &lt_entry,
                              NULL));
    /* Delete sequence number table if any. */
    rv = mirror_encap_seq_num_table_delete(unit, index);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from SFLOW IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_ipv6_table_get(int unit, int index,
                                  mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_GET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*19*/ {METADATAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {HIGIG3s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*23*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*24*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_SFLOW_SEQ_IPV6s,
                           &lt_entry,
                           NULL, NULL));

    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow_ipv6.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow_ipv6.dst_mac, &data);
    ipv6_addr[1] = field[4].u.val;
    ipv6_addr[0] = field[5].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.sflow_ipv6.src_ipv6, ipv6_addr);
    ipv6_addr[1] = field[6].u.val;
    ipv6_addr[0] = field[7].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.sflow_ipv6.dst_ipv6, ipv6_addr);
    entry->encap.sflow_ipv6.traffic_class = field[8].u.val;
    entry->encap.sflow_ipv6.hop_limit = field[9].u.val;
    entry->encap.sflow_ipv6.next_header = field[10].u.val;
    entry->encap.sflow_ipv6.flow_label = field[11].u.val;
    entry->encap.sflow_ipv6.l4_dst_port = field[12].u.val;
    entry->encap.sflow_ipv6.l4_src_port = field[13].u.val;
    entry->encap.sflow_ipv6.ethertype = field[14].u.val;
    entry->encap.sflow_ipv6.outer_vlan = field[15].u.val;
    entry->encap.sflow_ipv6.vlan_id = field[16].u.val;
    entry->encap.sflow_ipv6.tpid = field[17].u.val;
    if (sal_strcmp(field[18].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.sflow_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.sflow_ipv6.metadata = field[19].u.val;
    } else {
        entry->encap.sflow_ipv6.metadata_type = bcmMirrorPsampFmt2HeaderZeroes;
    }
    entry->encap.sflow_ipv6.hg3_ena = field[20].u.val;
    entry->encap.sflow_ipv6.hg3_header.ethertype = field[21].u.val;
    entry->encap.sflow_ipv6.hg3_header.base_hdr = field[22].u.val;
    entry->encap.sflow_ipv6.pri = field[23].u.val;
    entry->encap.sflow_ipv6.cfi = field[24].u.val;

    /* Get sequence number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_seq_num_table_get(unit, index,
                                        entry->helper_info.pipe,
                                        &entry->encap.sflow_ipv6.seq_ena,
                                        &entry->encap.sflow_ipv6.seq_num));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to Mirror-on-drop LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_table_add(int unit, int index,
                                      mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, 0, 0, {0}},
        /*3*/ {DST_MACs, 0, 0, {0}},
        /*4*/ {SRC_IPV4s, 0, 0, {0}},
        /*5*/ {DST_IPV4s, 0, 0, {0}},
        /*6*/ {TOSs, 0, 0, {0}},
        /*7*/ {TTLs, 0, 0, {0}},
        /*8*/ {PROTOs, 0, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, 0, 0, {0}},
        /*10*/ {L4_DST_PORTs, 0, 0, {0}},
        /*11*/ {L4_SRC_PORTs, 0, 0, {0}},
        /*12*/ {ETHERTYPEs, 0, 0, {0}},
        /*13*/ {OUTER_VLANs, 0, 0, {0}},
        /*14*/ {VLAN_IDs, 0, 0, {0}},
        /*15*/ {TPIDs, 0, 0, {0}},
        /*16*/ {OBSERVATION_DOMAINs, 0, 0, {0}},
        /*17*/ {TEMPLATE_IDENTIFIERs, 0, 0, {0}},
        /*18*/ {METADATAs, 0, 0, {0}},
        /*19*/ {IPFIX_VERSIONs, 0, 0, {0}},
        /*20*/ {SWITCH_IDs, 0, 0, {0}},
        /*21*/ {VARIABLE_FLAGs, 0, 0, {0}},
        /*22*/ {HIGIG3s, 0, 0, {0}},
        /*23*/ {HIGIG3_ETHERTYPEs, 0, 0, {0}},
        /*24*/ {HIGIG3_BASE_HDRs, 0, 0, {0}},
        /*25*/ {METADATA_TYPEs, 0, 0, {0}},
        /*26*/ {PRIs, 0, 0, {0}},
        /*27*/ {CFIs, 0, 0, {0}},
        /*28*/ {MODEs, 0 | BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
    };
    bcmlt_field_def_t fld_def;
    int rv, i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    /* Only set valid fields. */
    for (i = 1; i < lt_entry.nfields; i++) {
        if (i == 18) {
            /* METADATAs is determine by METADATA_TYPEs */
            continue;
        }
        rv = bcmi_lt_field_def_get(unit,
                                   MIRROR_ENCAP_MIRROR_ON_DROPs,
                                   field[i].fld_name,
                                   &fld_def);
        if (SHR_SUCCESS(rv)) {
            field[i].flags |= BCMI_LT_FIELD_F_SET;
        }
    }

    field[0].u.val = index;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.mirror_on_drop.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.mirror_on_drop.dst_mac);
    field[3].u.val = data;
    field[4].u.val = entry->encap.mirror_on_drop.src_ipv4;
    field[5].u.val = entry->encap.mirror_on_drop.dst_ipv4;
    field[6].u.val = entry->encap.mirror_on_drop.tos;
    field[7].u.val = entry->encap.mirror_on_drop.ttl;
    field[8].u.val = entry->encap.mirror_on_drop.proto;
    field[9].u.val = entry->encap.mirror_on_drop.df;
    field[10].u.val = entry->encap.mirror_on_drop.l4_dst_port;
    field[11].u.val = entry->encap.mirror_on_drop.l4_src_port;
    field[12].u.val = entry->encap.mirror_on_drop.ethertype;
    field[13].u.val = entry->encap.mirror_on_drop.outer_vlan;
    field[14].u.val = entry->encap.mirror_on_drop.vlan_id;
    field[15].u.val = entry->encap.mirror_on_drop.tpid;
    field[16].u.val = entry->encap.mirror_on_drop.observation_domain;
    field[17].u.val = entry->encap.mirror_on_drop.template_id;
    field[19].u.val = entry->encap.mirror_on_drop.ipfix_ver;
    field[20].u.val = entry->encap.mirror_on_drop.switch_id;
    field[21].u.val = entry->encap.mirror_on_drop.variable_flag;
    field[22].u.val = entry->encap.mirror_on_drop.hg3_ena;
    field[23].u.val = entry->encap.mirror_on_drop.hg3_header.ethertype;
    field[24].u.val = entry->encap.mirror_on_drop.hg3_header.base_hdr;
    if (entry->encap.mirror_on_drop.metadata_type ==
        bcmMirrorPsampFmt2HeaderUserMeta) {
        field[18].flags = BCMI_LT_FIELD_F_SET;
        field[18].u.val = entry->encap.mirror_on_drop.metadata;
        field[25].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[25].u.sym_val = TABLE_METADATAs;
    } else if (entry->encap.mirror_on_drop.metadata_type ==
               bcmMirrorPsampFmt2HeaderZeroes) {
        field[25].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[25].u.sym_val = ZEROESs;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    field[26].u.val = entry->encap.mirror_on_drop.pri;
    field[27].u.val = entry->encap.mirror_on_drop.cfi;
    if (field[28].flags & BCMI_LT_FIELD_F_SET) {
        field[28].flags |= BCMI_LT_FIELD_F_SYMBOL;
        if (entry->encap.mirror_on_drop.mode ==
            bcmiMirrorOnDropModeEgress) {
            field[28].u.sym_val = EGRESSs;
        } else if (entry->encap.mirror_on_drop.mode ==
                   bcmiMirrorOnDropModeIngress) {
            field[28].u.sym_val = INGRESSs;
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_MIRROR_ON_DROPs,
                              &lt_entry,
                              NULL));
    /* Add sequence number table if needed. */
    if (entry->encap.mirror_on_drop.seq_ena) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_seq_num_table_add(unit,
                 index,
                 entry->helper_info.pipe,
                 entry->encap.mirror_on_drop.seq_num));
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from Mirror-on-drop LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_MIRROR_ON_DROPs,
                              &lt_entry,
                              NULL));
    /* Delete sequence number table if any. */
    rv = mirror_encap_seq_num_table_delete(unit, index);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from Mirror-on-drop LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_table_get(int unit, int index,
                                      mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, 0, 0, {0}},
        /*3*/ {DST_MACs, 0, 0, {0}},
        /*4*/ {SRC_IPV4s, 0, 0, {0}},
        /*5*/ {DST_IPV4s, 0, 0, {0}},
        /*6*/ {TOSs, 0, 0, {0}},
        /*7*/ {TTLs, 0, 0, {0}},
        /*8*/ {PROTOs, 0, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, 0, 0, {0}},
        /*10*/ {L4_DST_PORTs, 0, 0, {0}},
        /*11*/ {L4_SRC_PORTs, 0, 0, {0}},
        /*12*/ {ETHERTYPEs, 0, 0, {0}},
        /*13*/ {OUTER_VLANs, 0, 0, {0}},
        /*14*/ {VLAN_IDs, 0, 0, {0}},
        /*15*/ {TPIDs, 0, 0, {0}},
        /*16*/ {OBSERVATION_DOMAINs, 0, 0, {0}},
        /*17*/ {TEMPLATE_IDENTIFIERs, 0, 0, {0}},
        /*18*/ {METADATAs, 0, 0, {0}},
        /*19*/ {IPFIX_VERSIONs, 0, 0, {0}},
        /*20*/ {SWITCH_IDs, 0, 0, {0}},
        /*21*/ {VARIABLE_FLAGs, 0, 0, {0}},
        /*22*/ {HIGIG3s, 0, 0, {0}},
        /*23*/ {HIGIG3_ETHERTYPEs, 0, 0, {0}},
        /*24*/ {HIGIG3_BASE_HDRs, 0, 0, {0}},
        /*25*/ {METADATA_TYPEs, 0 |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*26*/ {PRIs, 0, 0, {0}},
        /*27*/ {CFIs, 0, 0, {0}},
        /*28*/ {MODEs, 0 | BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
    };
    bcmlt_field_def_t fld_def;
    int rv, i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    /* Only get valid fields. */
    for (i = 1; i < lt_entry.nfields; i++) {
        rv = bcmi_lt_field_def_get(unit,
                                   MIRROR_ENCAP_MIRROR_ON_DROPs,
                                   field[i].fld_name,
                                   &fld_def);
        if (SHR_SUCCESS(rv)) {
            field[i].flags |= BCMI_LT_FIELD_F_GET;
        }
    }

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_MIRROR_ON_DROPs,
                           &lt_entry,
                           NULL, NULL));

    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.mirror_on_drop.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.mirror_on_drop.dst_mac, &data);
    entry->encap.mirror_on_drop.src_ipv4 = field[4].u.val;
    entry->encap.mirror_on_drop.dst_ipv4 = field[5].u.val;
    entry->encap.mirror_on_drop.tos = field[6].u.val;
    entry->encap.mirror_on_drop.ttl = field[7].u.val;
    entry->encap.mirror_on_drop.proto = field[8].u.val;
    entry->encap.mirror_on_drop.df = field[9].u.val;
    entry->encap.mirror_on_drop.l4_dst_port = field[10].u.val;
    entry->encap.mirror_on_drop.l4_src_port = field[11].u.val;
    entry->encap.mirror_on_drop.ethertype = field[12].u.val;
    entry->encap.mirror_on_drop.outer_vlan = field[13].u.val;
    entry->encap.mirror_on_drop.vlan_id = field[14].u.val;
    entry->encap.mirror_on_drop.tpid = field[15].u.val;
    entry->encap.mirror_on_drop.observation_domain = field[16].u.val;
    entry->encap.mirror_on_drop.template_id = field[17].u.val;
    entry->encap.mirror_on_drop.ipfix_ver = field[19].u.val;
    entry->encap.mirror_on_drop.switch_id = field[20].u.val;
    entry->encap.mirror_on_drop.variable_flag = field[21].u.val;
    entry->encap.mirror_on_drop.hg3_ena = field[22].u.val;
    entry->encap.mirror_on_drop.hg3_header.ethertype = field[23].u.val;
    entry->encap.mirror_on_drop.hg3_header.base_hdr = field[24].u.val;
    if (sal_strcmp(field[25].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.mirror_on_drop.metadata_type =
            bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.mirror_on_drop.metadata = field[18].u.val;
    } else {
        entry->encap.mirror_on_drop.metadata_type =
            bcmMirrorPsampFmt2HeaderZeroes;
    }
    entry->encap.mirror_on_drop.pri = field[26].u.val;
    entry->encap.mirror_on_drop.cfi = field[27].u.val;
    if ((field[28].flags & BCMI_LT_FIELD_F_GET) &&
        sal_strcmp(field[28].u.sym_val, EGRESSs) == 0) {
        entry->encap.mirror_on_drop.mode = bcmiMirrorOnDropModeEgress;
    } else {
        entry->encap.mirror_on_drop.mode = bcmiMirrorOnDropModeIngress;
    }

    /* Get sequence number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_seq_num_table_get(unit, index,
                                        entry->helper_info.pipe,
                                        &entry->encap.mirror_on_drop.seq_ena,
                                        &entry->encap.mirror_on_drop.seq_num));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to Mirror-on-drop IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_ipv6_table_add(int unit, int index,
                                           mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, 0, 0, {0}},
        /*3*/ {DST_MACs, 0, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, 0, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, 0, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, 0, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, 0, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, 0, 0, {0}},
        /*9*/ {HOP_LIMITs, 0, 0, {0}},
        /*10*/ {NEXT_HEADERs, 0, 0, {0}},
        /*11*/ {FLOW_LABELs, 0, 0, {0}},
        /*12*/ {L4_DST_PORTs, 0, 0, {0}},
        /*13*/ {L4_SRC_PORTs, 0, 0, {0}},
        /*14*/ {ETHERTYPEs, 0, 0, {0}},
        /*15*/ {OUTER_VLANs, 0, 0, {0}},
        /*16*/ {VLAN_IDs, 0, 0, {0}},
        /*17*/ {TPIDs, 0, 0, {0}},
        /*18*/ {OBSERVATION_DOMAINs, 0, 0, {0}},
        /*19*/ {TEMPLATE_IDENTIFIERs, 0, 0, {0}},
        /*20*/ {METADATAs, 0, 0, {0}},
        /*21*/ {IPFIX_VERSIONs, 0, 0, {0}},
        /*22*/ {SWITCH_IDs, 0, 0, {0}},
        /*23*/ {VARIABLE_FLAGs, 0, 0, {0}},
        /*24*/ {HIGIG3s, 0, 0, {0}},
        /*25*/ {HIGIG3_ETHERTYPEs, 0, 0, {0}},
        /*26*/ {HIGIG3_BASE_HDRs, 0, 0, {0}},
        /*27*/ {METADATA_TYPEs, 0, 0, {0}},
        /*28*/ {PRIs, 0, 0, {0}},
        /*29*/ {CFIs, 0, 0, {0}},
        /*30*/ {MODEs, 0 | BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
    };
    bcmlt_field_def_t fld_def;
    int rv, i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    /* Only set valid fields. */
    for (i = 1; i < lt_entry.nfields; i++) {
        rv = bcmi_lt_field_def_get(unit,
                                   MIRROR_ENCAP_MIRROR_ON_DROP_IPV6s,
                                   field[i].fld_name,
                                   &fld_def);
        if (SHR_SUCCESS(rv)) {
            field[i].flags |= BCMI_LT_FIELD_F_SET;
        }
    }

    field[0].u.val = index;
    bcmi_ltsw_util_mac_to_uint64(&data,
                                 entry->encap.mirror_on_drop_ipv6.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data,
                                 entry->encap.mirror_on_drop_ipv6.dst_mac);
    field[3].u.val = data;
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.mirror_on_drop_ipv6.src_ipv6);
    field[4].u.val = ipv6_addr[1];
    field[5].u.val = ipv6_addr[0];
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.mirror_on_drop_ipv6.dst_ipv6);
    field[6].u.val = ipv6_addr[1];
    field[7].u.val = ipv6_addr[0];
    field[8].u.val = entry->encap.mirror_on_drop_ipv6.traffic_class;
    field[9].u.val = entry->encap.mirror_on_drop_ipv6.hop_limit;
    field[10].u.val = entry->encap.mirror_on_drop_ipv6.next_header;
    field[11].u.val = entry->encap.mirror_on_drop_ipv6.flow_label;
    field[12].u.val = entry->encap.mirror_on_drop_ipv6.l4_dst_port;
    field[13].u.val = entry->encap.mirror_on_drop_ipv6.l4_src_port;
    field[14].u.val = entry->encap.mirror_on_drop_ipv6.ethertype;
    field[15].u.val = entry->encap.mirror_on_drop_ipv6.outer_vlan;
    field[16].u.val = entry->encap.mirror_on_drop_ipv6.vlan_id;
    field[17].u.val = entry->encap.mirror_on_drop_ipv6.tpid;
    field[18].u.val = entry->encap.mirror_on_drop_ipv6.observation_domain;
    field[19].u.val = entry->encap.mirror_on_drop_ipv6.template_id;
    field[21].u.val = entry->encap.mirror_on_drop_ipv6.ipfix_ver;
    field[22].u.val = entry->encap.mirror_on_drop_ipv6.switch_id;
    field[23].u.val = entry->encap.mirror_on_drop_ipv6.variable_flag;
    field[24].u.val = entry->encap.mirror_on_drop_ipv6.hg3_ena;
    field[25].u.val = entry->encap.mirror_on_drop_ipv6.hg3_header.ethertype;
    field[26].u.val = entry->encap.mirror_on_drop_ipv6.hg3_header.base_hdr;
    if (entry->encap.mirror_on_drop_ipv6.metadata_type ==
        bcmMirrorPsampFmt2HeaderUserMeta) {
        field[20].flags = BCMI_LT_FIELD_F_SET;
        field[20].u.val = entry->encap.mirror_on_drop_ipv6.metadata;
        field[27].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[27].u.sym_val = TABLE_METADATAs;
    } else if (entry->encap.mirror_on_drop_ipv6.metadata_type ==
               bcmMirrorPsampFmt2HeaderZeroes) {
        field[27].flags = BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL;
        field[27].u.sym_val = ZEROESs;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    field[28].u.val = entry->encap.mirror_on_drop_ipv6.pri;
    field[29].u.val = entry->encap.mirror_on_drop_ipv6.cfi;
    if (field[30].flags & BCMI_LT_FIELD_F_SET) {
        field[30].flags |= BCMI_LT_FIELD_F_SYMBOL;
        if (entry->encap.mirror_on_drop_ipv6.mode ==
            bcmiMirrorOnDropModeEgress) {
            field[30].u.sym_val = EGRESSs;
        } else if (entry->encap.mirror_on_drop_ipv6.mode ==
                   bcmiMirrorOnDropModeIngress) {
            field[30].u.sym_val = INGRESSs;
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_MIRROR_ON_DROP_IPV6s,
                              &lt_entry,
                              NULL));
    /* Add sequence number table if needed. */
    if (entry->encap.mirror_on_drop_ipv6.seq_ena) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_seq_num_table_add(unit,
                 index,
                 entry->helper_info.pipe,
                 entry->encap.mirror_on_drop_ipv6.seq_num));
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from Mirror-on-drop IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_ipv6_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_MIRROR_ON_DROP_IPV6s,
                              &lt_entry,
                              NULL));
    /* Delete sequence number table if any. */
    rv = mirror_encap_seq_num_table_delete(unit, index);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from Mirror-on-drop IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_ipv6_table_get(int unit, int index,
                                           mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {METADATAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {IPFIX_VERSIONs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {SWITCH_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*23*/ {VARIABLE_FLAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*24*/ {HIGIG3s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*25*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*26*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*27*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_GET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*28*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*29*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*30*/ {MODEs, 0 | BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
    };
    bcmlt_field_def_t fld_def;
    int rv, i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    /* Only get valid fields. */
    for (i = 1; i < lt_entry.nfields; i++) {
        rv = bcmi_lt_field_def_get(unit,
                                   MIRROR_ENCAP_MIRROR_ON_DROPs,
                                   field[i].fld_name,
                                   &fld_def);
        if (SHR_SUCCESS(rv)) {
            field[i].flags |= BCMI_LT_FIELD_F_GET;
        }
    }

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_MIRROR_ON_DROP_IPV6s,
                           &lt_entry,
                           NULL, NULL));

    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.mirror_on_drop_ipv6.src_mac,
                                 &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.mirror_on_drop_ipv6.dst_mac,
                                 &data);
    ipv6_addr[1] = field[4].u.val;
    ipv6_addr[0] = field[5].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.mirror_on_drop_ipv6.src_ipv6,
                                 ipv6_addr);
    ipv6_addr[1] = field[6].u.val;
    ipv6_addr[0] = field[7].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.mirror_on_drop_ipv6.dst_ipv6,
                                 ipv6_addr);
    entry->encap.mirror_on_drop_ipv6.traffic_class = field[8].u.val;
    entry->encap.mirror_on_drop_ipv6.hop_limit = field[9].u.val;
    entry->encap.mirror_on_drop_ipv6.next_header = field[10].u.val;
    entry->encap.mirror_on_drop_ipv6.flow_label = field[11].u.val;
    entry->encap.mirror_on_drop_ipv6.l4_dst_port = field[12].u.val;
    entry->encap.mirror_on_drop_ipv6.l4_src_port = field[13].u.val;
    entry->encap.mirror_on_drop_ipv6.ethertype = field[14].u.val;
    entry->encap.mirror_on_drop_ipv6.outer_vlan = field[15].u.val;
    entry->encap.mirror_on_drop_ipv6.vlan_id = field[16].u.val;
    entry->encap.mirror_on_drop_ipv6.tpid = field[17].u.val;
    entry->encap.mirror_on_drop_ipv6.observation_domain = field[18].u.val;
    entry->encap.mirror_on_drop_ipv6.template_id = field[19].u.val;
    entry->encap.mirror_on_drop_ipv6.ipfix_ver = field[21].u.val;
    entry->encap.mirror_on_drop_ipv6.switch_id = field[22].u.val;
    entry->encap.mirror_on_drop_ipv6.variable_flag = field[23].u.val;
    entry->encap.mirror_on_drop_ipv6.hg3_ena = field[24].u.val;
    entry->encap.mirror_on_drop_ipv6.hg3_header.ethertype = field[25].u.val;
    entry->encap.mirror_on_drop_ipv6.hg3_header.base_hdr = field[26].u.val;
    if (sal_strcmp(field[27].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.mirror_on_drop_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.mirror_on_drop_ipv6.metadata = field[20].u.val;
    } else {
        entry->encap.mirror_on_drop_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderZeroes;
    }
    entry->encap.mirror_on_drop_ipv6.pri = field[28].u.val;
    entry->encap.mirror_on_drop_ipv6.cfi = field[29].u.val;
    if ((field[30].flags & BCMI_LT_FIELD_F_GET) &&
        sal_strcmp(field[30].u.sym_val, EGRESSs) == 0) {
        entry->encap.mirror_on_drop.mode = bcmiMirrorOnDropModeEgress;
    } else {
        entry->encap.mirror_on_drop.mode = bcmiMirrorOnDropModeIngress;
    }

    /* Get sequence number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_seq_num_table_get(unit, index,
                                    entry->helper_info.pipe,
                                    &entry->encap.mirror_on_drop_ipv6.seq_ena,
                                    &entry->encap.mirror_on_drop_ipv6.seq_num));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to VXLAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_vxlan_table_add(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {VXLAN_TYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {VXLAN_VNIDs, 0, 0, {0}},
        /*18*/ {HIGIG3s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.vxlan.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.vxlan.dst_mac);
    field[3].u.val = data;
    field[4].u.val = entry->encap.vxlan.src_ipv4;
    field[5].u.val = entry->encap.vxlan.dst_ipv4;
    field[6].u.val = entry->encap.vxlan.tos;
    field[7].u.val = entry->encap.vxlan.ttl;
    field[8].u.val = entry->encap.vxlan.proto;
    field[9].u.val = entry->encap.vxlan.df;
    field[10].u.val = entry->encap.vxlan.l4_dst_port;
    field[11].u.val = entry->encap.vxlan.l4_src_port;
    field[12].u.val = entry->encap.vxlan.ethertype;
    field[13].u.val = entry->encap.vxlan.outer_vlan;
    field[14].u.val = entry->encap.vxlan.vlan_id;
    field[15].u.val = entry->encap.vxlan.tpid;
    field[16].flags |= BCMI_LT_FIELD_F_SYMBOL;
    if (entry->encap.vxlan.vxlan_type) {
        field[16].u.sym_val = TABLE_VXLANs;
        field[17].flags |= BCMI_LT_FIELD_F_SET;
        field[17].u.val = entry->encap.vxlan.vxlan_vnid;
    } else {
        field[16].u.sym_val = EGR_VFIs;
    }
    field[18].u.val = entry->encap.vxlan.hg3_ena;
    field[19].u.val = entry->encap.vxlan.hg3_header.ethertype;
    field[20].u.val = entry->encap.vxlan.hg3_header.base_hdr;
    field[21].u.val = entry->encap.vxlan.pri;
    field[22].u.val = entry->encap.vxlan.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_VXLANs,
                              &lt_entry,
                              NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from VXLAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_vxlan_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_VXLANs,
                              &lt_entry,
                              NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from VXLAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_vxlan_table_get(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {VXLAN_TYPEs, BCMI_LT_FIELD_F_GET |
                             BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*17*/ {VXLAN_VNIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {HIGIG3s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_VXLANs,
                           &lt_entry,
                           NULL, NULL));

    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.vxlan.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.vxlan.dst_mac, &data);
    entry->encap.vxlan.src_ipv4 = field[4].u.val;
    entry->encap.vxlan.dst_ipv4 = field[5].u.val;
    entry->encap.vxlan.tos = field[6].u.val;
    entry->encap.vxlan.ttl = field[7].u.val;
    entry->encap.vxlan.proto = field[8].u.val;
    entry->encap.vxlan.df = field[9].u.val;
    entry->encap.vxlan.l4_dst_port = field[10].u.val;
    entry->encap.vxlan.l4_src_port = field[11].u.val;
    entry->encap.vxlan.ethertype = field[12].u.val;
    entry->encap.vxlan.outer_vlan = field[13].u.val;
    entry->encap.vxlan.vlan_id = field[14].u.val;
    entry->encap.vxlan.tpid = field[15].u.val;
    if (sal_strcmp(field[16].u.sym_val, TABLE_VXLANs) == 0) {
        entry->encap.vxlan.vxlan_type = 1;
        entry->encap.vxlan.vxlan_vnid = field[17].u.val;
    } else {
        entry->encap.vxlan.vxlan_type = 0;
    }
    entry->encap.vxlan.hg3_ena = field[18].u.val;
    entry->encap.vxlan.hg3_header.ethertype = field[19].u.val;
    entry->encap.vxlan.hg3_header.base_hdr = field[20].u.val;
    entry->encap.vxlan.pri = field[21].u.val;
    entry->encap.vxlan.cfi = field[22].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to VXLAN IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_vxlan_ipv6_table_add(int unit, int index,
                                  mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {VXLAN_TYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {VXLAN_VNIDs, 0, 0, {0}},
        /*20*/ {HIGIG3s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*23*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*24*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.vxlan_ipv6.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.vxlan_ipv6.dst_mac);
    field[3].u.val = data;
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.vxlan_ipv6.src_ipv6);
    field[4].u.val = ipv6_addr[1];
    field[5].u.val = ipv6_addr[0];
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.vxlan_ipv6.dst_ipv6);
    field[6].u.val = ipv6_addr[1];
    field[7].u.val = ipv6_addr[0];
    field[8].u.val = entry->encap.vxlan_ipv6.traffic_class;
    field[9].u.val = entry->encap.vxlan_ipv6.hop_limit;
    field[10].u.val = entry->encap.vxlan_ipv6.next_header;
    field[11].u.val = entry->encap.vxlan_ipv6.flow_label;
    field[12].u.val = entry->encap.vxlan_ipv6.l4_dst_port;
    field[13].u.val = entry->encap.vxlan_ipv6.l4_src_port;
    field[14].u.val = entry->encap.vxlan_ipv6.ethertype;
    field[15].u.val = entry->encap.vxlan_ipv6.outer_vlan;
    field[16].u.val = entry->encap.vxlan_ipv6.vlan_id;
    field[17].u.val = entry->encap.vxlan_ipv6.tpid;
    field[18].flags |= BCMI_LT_FIELD_F_SYMBOL;
    if (entry->encap.vxlan_ipv6.vxlan_type) {
        field[18].u.sym_val = TABLE_VXLANs;
        field[19].flags |= BCMI_LT_FIELD_F_SET;
        field[19].u.val = entry->encap.vxlan_ipv6.vxlan_vnid;
    } else {
        field[18].u.sym_val = EGR_VFIs;
    }
    field[20].u.val = entry->encap.vxlan_ipv6.hg3_ena;
    field[21].u.val = entry->encap.vxlan_ipv6.hg3_header.ethertype;
    field[22].u.val = entry->encap.vxlan_ipv6.hg3_header.base_hdr;
    field[23].u.val = entry->encap.vxlan_ipv6.pri;
    field[24].u.val = entry->encap.vxlan_ipv6.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_VXLAN_IPV6s,
                              &lt_entry,
                              NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from VXLAN IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_vxlan_ipv6_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_VXLAN_IPV6s,
                              &lt_entry,
                              NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from VXLAN IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_vxlan_ipv6_table_get(int unit, int index,
                                  mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, 0, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {VXLAN_TYPEs, BCMI_LT_FIELD_F_GET |
                             BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*19*/ {VXLAN_VNIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {HIGIG3s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {HIGIG3_ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {HIGIG3_BASE_HDRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*23*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*24*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_VXLAN_IPV6s,
                           &lt_entry,
                           NULL, NULL));

    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.vxlan_ipv6.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.vxlan_ipv6.dst_mac, &data);
    ipv6_addr[1] = field[4].u.val;
    ipv6_addr[0] = field[5].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.vxlan_ipv6.src_ipv6, ipv6_addr);
    ipv6_addr[1] = field[6].u.val;
    ipv6_addr[0] = field[7].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.vxlan_ipv6.dst_ipv6, ipv6_addr);
    entry->encap.vxlan_ipv6.traffic_class = field[8].u.val;
    entry->encap.vxlan_ipv6.hop_limit = field[9].u.val;
    entry->encap.vxlan_ipv6.next_header = field[10].u.val;
    entry->encap.vxlan_ipv6.flow_label = field[11].u.val;
    entry->encap.vxlan_ipv6.l4_dst_port = field[12].u.val;
    entry->encap.vxlan_ipv6.l4_src_port = field[13].u.val;
    entry->encap.vxlan_ipv6.ethertype = field[14].u.val;
    entry->encap.vxlan_ipv6.outer_vlan = field[15].u.val;
    entry->encap.vxlan_ipv6.vlan_id = field[16].u.val;
    entry->encap.vxlan_ipv6.tpid = field[17].u.val;
    if (sal_strcmp(field[18].u.sym_val, TABLE_VXLANs) == 0) {
        entry->encap.vxlan_ipv6.vxlan_type = 1;
        entry->encap.vxlan_ipv6.vxlan_vnid = field[19].u.val;
    } else {
        entry->encap.vxlan_ipv6.vxlan_type = 0;
    }
    entry->encap.vxlan_ipv6.hg3_ena = field[20].u.val;
    entry->encap.vxlan_ipv6.hg3_header.ethertype = field[21].u.val;
    entry->encap.vxlan_ipv6.hg3_header.base_hdr = field[22].u.val;
    entry->encap.vxlan_ipv6.pri = field[23].u.val;
    entry->encap.vxlan_ipv6.cfi = field[24].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror basic encapsulation table.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_basic_table_add(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {ENCAP_MODEs, BCMI_LT_FIELD_F_SET |
                            BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    /* Do not need to add this table when lb_ena is false. */
    if (!entry->lb_ena) {
        SHR_EXIT();
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    switch (entry->lb_header.loopback_header_type) {
        case bcmMirrorLoopbackHeaderGeneric:
            field[1].u.sym_val = NO_ENCAP_LOOPBACKs;
            break;
        case bcmMirrorLoopbackHeaderIfa:
            field[1].u.sym_val = ENCAP_IFA_LOOPBACKs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit, MIRROR_ENCAP_BASICs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror basic encapsulation table.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_basic_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    rv = bcmi_lt_entry_delete(unit, MIRROR_ENCAP_BASICs, &lt_entry, NULL);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror basic encapsulation table.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_basic_table_get(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {ENCAP_MODEs, BCMI_LT_FIELD_F_GET |
                            BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    rv = bcmi_lt_entry_get(unit, MIRROR_ENCAP_BASICs, &lt_entry, NULL, NULL);
    if (rv == SHR_E_NOT_FOUND) {
        entry->lb_ena = false;
        SHR_EXIT();
    } else if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }
    entry->lb_ena = true;

    if (sal_strcmp(field[1].u.sym_val, NO_ENCAP_LOOPBACKs) == 0) {
        entry->lb_header.loopback_header_type = bcmMirrorLoopbackHeaderGeneric;
    } else if (sal_strcmp(field[1].u.sym_val, ENCAP_IFA_LOOPBACKs)==
               0) {
        entry->lb_header.loopback_header_type = bcmMirrorLoopbackHeaderIfa;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add NPL Mirror loopback header table.
 *
 * \param [in] unit Unit number.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_npl_loopback_header_table_add(
    int unit,
    mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {LOOPBACK_CTRLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {SYS_SOURCE_IFA_PROBE_COPYs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    /* Do not need to add this table when lb_ena is false. */
    if (!entry->lb_ena) {
        SHR_EXIT();
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    /* PROCESSING_CTRL_0 must be set as 0x4(loopback_hdr_dst_valid). */
    entry->lb_header.processing_ctrl_0 = 0x4;
    field[0].u.val = entry->lb_header.processing_ctrl_0;
    /* SOURCE_SYSTEM_PORT */
    field[1].u.val = entry->lb_header.src_sys_port;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              R_IFA_EDITOR_PARAMSs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete NPL Mirror loopback header table.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_npl_loopback_header_table_delete(int unit)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {LOOPBACK_CTRLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {SYS_SOURCE_IFA_PROBE_COPYs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = 0;
    field[1].u.val = 0;

    rv = bcmi_lt_entry_delete(unit,
                              R_IFA_EDITOR_PARAMSs, &lt_entry, NULL);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get NPL Mirror loopback header table.
 *
 * \param [in] unit Unit number.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_npl_loopback_header_table_get(
    int unit,
    mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {LOOPBACK_CTRLs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {SYS_SOURCE_IFA_PROBE_COPYs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           R_IFA_EDITOR_PARAMSs, &lt_entry, NULL, NULL);
    if (rv == SHR_E_NOT_FOUND) {
        entry->lb_ena = false;
        SHR_EXIT();
    } else if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }
    entry->lb_ena = TRUE;
    entry->lb_header.processing_ctrl_0 = field[0].u.val;
    entry->lb_header.src_sys_port = field[1].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror loopback header table.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_loopback_header_table_add(int unit, int index,
                                       mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {ENCAPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {HDR_SOURCE_SYSTEM_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {HDR_DESTINATION_TYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {HDR_DESTINATION_OBJs, 0, 0, {0}},
        /*5*/ {HDR_PROCESSING_CTRL_0s, 0, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    /* Do not need to add this table when lb_ena is false. */
    if (!entry->lb_ena) {
        SHR_EXIT();
    }

    if (entry->lb_header.loopback_header_type >= bcmMirrorLoopbackHeaderCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->lb_ena;
    field[2].u.val = entry->lb_header.src_sys_port;
    field[3].u.val = MIRROR_LOOPBACK_DEST_TYPE_DEV_PORT;
    if (entry->lb_header.loopback_header_type == bcmMirrorLoopbackHeaderIfa) {
        field[4].flags = BCMI_LT_FIELD_F_SET;
        field[4].u.val = entry->lb_header.dst_sys_port;

        field[5].flags = BCMI_LT_FIELD_F_SET;
        /* loopback_hdr_dst_valid. */
        field[5].u.val = 4;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_GENERIC_LOOPBACKs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror loopback header table.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_loopback_header_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    rv = bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_GENERIC_LOOPBACKs, &lt_entry, NULL);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror loopback header table.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_loopback_header_table_get(int unit, int index,
                                       mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {ENCAPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {HDR_SOURCE_SYSTEM_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {HDR_DESTINATION_TYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {HDR_DESTINATION_OBJs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {HDR_PROCESSING_CTRL_0s, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_GENERIC_LOOPBACKs, &lt_entry, NULL, NULL);
    if (rv == SHR_E_NOT_FOUND) {
        entry->lb_ena = false;
        SHR_EXIT();
    } else if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }
    entry->lb_ena = field[1].u.val;
    entry->lb_header.src_sys_port = field[2].u.val;
    entry->lb_header.dst_sys_port = field[4].u.val;
    if (field[5].u.val != 0) {
        entry->lb_header.loopback_header_type = bcmMirrorLoopbackHeaderIfa;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to IFA 1.0 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_ifa_1_probe_table_add(
    int unit,
    int index,
    mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {PROBE_MARKER_1s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {PROBE_MARKER_2s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {VERSIONs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {MSG_TYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {REQUEST_VECTORs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {ACTION_VECTORs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {HOP_LIMITs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {MAX_LENGTHs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.ifa_1_probe.probemarker_1;
    field[2].u.val = entry->encap.ifa_1_probe.probemarker_2;
    field[3].u.val = entry->encap.ifa_1_probe.version;
    field[4].u.val = entry->encap.ifa_1_probe.msg_type;
    field[5].u.val = entry->encap.ifa_1_probe.request_vector;
    field[6].u.val = entry->encap.ifa_1_probe.action_vector;
    field[7].u.val = entry->encap.ifa_1_probe.hop_limit;
    field[8].u.val = entry->encap.ifa_1_probe.max_length;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit, MIRROR_ENCAP_IFA_1_PROBEs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from IFA 1.0 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_ifa_1_probe_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_ENCAP_IFA_1_PROBEs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from IFA 1.0 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_ifa_1_probe_table_get(
    int unit,
    int index,
    mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {PROBE_MARKER_1s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {PROBE_MARKER_2s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {VERSIONs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {MSG_TYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {REQUEST_VECTORs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {ACTION_VECTORs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {MAX_LENGTHs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_IFA_1_PROBEs,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.ifa_1_probe.probemarker_1 = field[1].u.val;
    entry->encap.ifa_1_probe.probemarker_2 = field[2].u.val;
    entry->encap.ifa_1_probe.version = field[3].u.val;
    entry->encap.ifa_1_probe.msg_type = field[4].u.val;
    entry->encap.ifa_1_probe.request_vector = field[5].u.val;
    entry->encap.ifa_1_probe.action_vector = field[6].u.val;
    entry->encap.ifa_1_probe.hop_limit = field[7].u.val;
    entry->encap.ifa_1_probe.max_length = field[8].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set Mirror encap type.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] type Mirror encap type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_type_set(int unit, int index, mirror_encap_type type)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_encap_info[unit].type, SHR_E_INIT);

    mirror_encap_info[unit].type[index] = type;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap type.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] type Mirror encap type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_type_get(int unit, int index, mirror_encap_type *type)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_encap_info[unit].type, SHR_E_INIT);

    *type = mirror_encap_info[unit].type[index];

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get pipe id from system port.
 *
 * \param [in] unit Unit number.
 * \param [in] system_port System port.
 * \param [out] pipe PP Pipe id of system port.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_table_sys_port_resolve(int unit, int system_port, int *pipe)
{
    bcm_port_t local_port;
    bcm_gport_t gport;
    SHR_FUNC_ENTER(unit);

    if (system_port == 0) {
        *pipe = 0;
        SHR_EXIT();
    }

    /* Get gport from system port. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_sys_port_to_port(unit,
                                    system_port,
                                    &gport));

    /* Get local port from gport. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_mirror_local_port_get(unit,
                                         gport,
                                         NULL,
                                         &local_port));
    if (pipe) {
        /* Get PP pipe id. */
        *pipe = bcmi_ltsw_dev_logic_port_pp_pipe(unit, local_port);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_table_add(int unit, int index,
                       mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t instance_field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {EGRs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    bcmi_lt_field_t instance_attr_field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TRUNCATEs, 0, 0, {0}},
        /*2*/ {SYSTEM_PORT_TABLE_IDs, 0, 0, {0}},
        /*3*/ {TRUNCATE_ACTIONs, 0, 0, {0}},
        /*4*/ {MIRROR_TRUNCATE_LENGTH_IDs, 0, 0, {0}},
    };
    bcmlt_field_def_t fld_def;
    int rv, i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = instance_field;
    lt_entry.nfields = sizeof(instance_field)/sizeof(instance_field[0]);
    lt_entry.attr = 0;

    instance_field[0].u.val = index;
    instance_field[1].u.val = entry->egr;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit, MIRROR_ENCAP_INSTANCEs, &lt_entry, NULL));

    lt_entry.fields = instance_attr_field;
    lt_entry.nfields = sizeof(instance_attr_field)/
                       sizeof(instance_attr_field[0]);
    lt_entry.attr = 0;

    /* Only set valid fields. */
    for (i = 1; i < lt_entry.nfields; i++) {
        rv = bcmi_lt_field_def_get(unit,
                                   MIRROR_ENCAP_INSTANCE_ATTRs,
                                   instance_attr_field[i].fld_name,
                                   &fld_def);
        if (SHR_SUCCESS(rv)) {
            if (i == 3) {
                instance_attr_field[i].flags |= BCMI_LT_FIELD_F_SYMBOL;
            }
            instance_attr_field[i].flags |= BCMI_LT_FIELD_F_SET;
        }
    }

    instance_attr_field[0].u.val = index;
    instance_attr_field[1].u.val = entry->truncate;
    instance_attr_field[2].u.val = entry->sys_port;
    if (entry->truncate_mode == bcmMirrorTruncateDefault) {
        instance_attr_field[3].u.sym_val = TRUNCATEs;
    } else if (entry->truncate_mode == bcmMirrorTruncateAdjustment) {
        instance_attr_field[3].u.sym_val = TRUNCATE_ADJUSTs;
    }
    instance_attr_field[4].u.val = entry->truncate_profile_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_INSTANCE_ATTRs,
                              &lt_entry,
                              NULL));

    /* Add mirror encap loopback header table if needed. */
    if (entry->type == ENCAP_IFA_1_PROBE &&
        xfs_mirror_db[unit] &&
        xfs_mirror_db[unit]->ifa_1_probe_encap_npl_lb_header) {
        /* NPL insert loopback header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_npl_loopback_header_table_add(unit, entry));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_loopback_header_table_add(unit, index, entry));
    }

    if (entry->type == ENCAP_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_basic_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_RSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_ERSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_ERSPAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_ipv6_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_PSAMP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_ipv6_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_SFLOW_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_ipv6_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_MIRROR_ON_DROP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_MIRROR_ON_DROP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_ipv6_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_VXLAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_vxlan_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_VXLAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_vxlan_ipv6_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_IFA_1_PROBE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_ifa_1_probe_table_add(unit, index, entry));
    }
    /* Save encap type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_type_set(unit, index, entry->type));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] type Mirror encap type.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_table_delete(int unit, mirror_encap_type type, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t instance_field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    bcmi_lt_field_t instance_attr_field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = instance_field;
    lt_entry.nfields = sizeof(instance_field)/sizeof(instance_field[0]);
    lt_entry.attr = 0;

    instance_field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_ENCAP_INSTANCEs, &lt_entry, NULL));

    lt_entry.fields = instance_attr_field;
    lt_entry.nfields = sizeof(instance_attr_field)/
                       sizeof(instance_attr_field[0]);
    lt_entry.attr = 0;

    instance_attr_field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_INSTANCE_ATTRs,
                              &lt_entry,
                              NULL));

    /* Delete mirror encap loopback header table entry if any. */
    if (type == ENCAP_IFA_1_PROBE &&
        xfs_mirror_db[unit] &&
        xfs_mirror_db[unit]->ifa_1_probe_encap_npl_lb_header) {
        /* NPL insert loopback header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_npl_loopback_header_table_delete(unit));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_loopback_header_table_delete(unit, index));
    }

    if (type == ENCAP_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_basic_table_delete(unit, index));
    } else if (type == ENCAP_RSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_table_delete(unit, index));
    } else if (type == ENCAP_ERSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_table_delete(unit, index));
    } else if (type == ENCAP_ERSPAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_ipv6_table_delete(unit, index));
    } else if (type == ENCAP_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_table_delete(unit, index));
    } else if (type == ENCAP_PSAMP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_ipv6_table_delete(unit, index));
    } else if (type == ENCAP_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_table_delete(unit, index));
    } else if (type == ENCAP_SFLOW_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_ipv6_table_delete(unit, index));
    } else if (type == ENCAP_MIRROR_ON_DROP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_table_delete(unit, index));
    } else if (type == ENCAP_MIRROR_ON_DROP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_ipv6_table_delete(unit, index));
    } else if (type == ENCAP_VXLAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_vxlan_table_delete(unit, index));
    } else if (type == ENCAP_VXLAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_vxlan_ipv6_table_delete(unit, index));
    } else if (type == ENCAP_IFA_1_PROBE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_ifa_1_probe_table_delete(unit, index));
    }
    /* Save encap type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_type_set(unit, index, ENCAP_NONE));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_table_get(int unit, int index,
                       mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t instance_field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {EGRs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    bcmi_lt_field_t instance_attr_field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TRUNCATEs, 0, 0, {0}},
        /*2*/ {SYSTEM_PORT_TABLE_IDs, 0, 0, {0}},
        /*3*/ {TRUNCATE_ACTIONs, 0, 0, {0}},
        /*4*/ {MIRROR_TRUNCATE_LENGTH_IDs, 0, 0, {0}},
    };
    bcmlt_field_def_t fld_def;
    int rv, i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = instance_field;
    lt_entry.nfields = sizeof(instance_field)/sizeof(instance_field[0]);
    lt_entry.attr = 0;
    instance_field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_INSTANCEs,
                           &lt_entry,
                           NULL, NULL));
    entry->egr = instance_field[1].u.val;

    lt_entry.fields = instance_attr_field;
    lt_entry.nfields = sizeof(instance_attr_field)/
                       sizeof(instance_attr_field[0]);

    /* Only get valid fields. */
    for (i = 1; i < lt_entry.nfields; i++) {
        rv = bcmi_lt_field_def_get(unit,
                                   MIRROR_ENCAP_INSTANCE_ATTRs,
                                   instance_attr_field[i].fld_name,
                                   &fld_def);
        if (SHR_SUCCESS(rv)) {
            if (i == 3) {
                instance_attr_field[i].flags |= BCMI_LT_FIELD_F_SYMBOL;
            }
            instance_attr_field[i].flags |= BCMI_LT_FIELD_F_GET;
        }
    }

    lt_entry.attr = 0;
    instance_attr_field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_INSTANCE_ATTRs,
                           &lt_entry,
                           NULL, NULL));
    entry->truncate = instance_attr_field[1].u.val;
    entry->sys_port = instance_attr_field[2].u.val;
    if (instance_attr_field[3].u.sym_val) {
        if(sal_strcmp(instance_attr_field[3].u.sym_val, TRUNCATEs) == 0) {
            entry->truncate_mode = bcmMirrorTruncateDefault;
        } else if (sal_strcmp(instance_attr_field[3].u.sym_val,
                              TRUNCATE_ADJUSTs) == 0) {
            entry->truncate_mode = bcmMirrorTruncateAdjustment;
        }
    } else {
        /* Return default value for null case */
        entry->truncate_mode = bcmMirrorTruncateDefault;
    }
    entry->truncate_profile_id = instance_attr_field[4].u.val;

    /* Get pipe id from system port. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_table_sys_port_resolve(unit, entry->sys_port,
                                             &entry->helper_info.pipe));

    /* Get mirror encap loopback header table entry if any. */
    if (entry->type == ENCAP_IFA_1_PROBE &&
        xfs_mirror_db[unit] &&
        xfs_mirror_db[unit]->ifa_1_probe_encap_npl_lb_header) {
        /* NPL insert loopback header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_npl_loopback_header_table_get(unit, entry));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_loopback_header_table_get(unit, index, entry));
    }

    if (entry->type == ENCAP_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_basic_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_RSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_ERSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_ERSPAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_ipv6_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_PSAMP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_ipv6_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_SFLOW_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_ipv6_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_MIRROR_ON_DROP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_MIRROR_ON_DROP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_ipv6_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_VXLAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_vxlan_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_VXLAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_vxlan_ipv6_table_get(unit, index, entry));
    } else if (entry->type == ENCAP_IFA_1_PROBE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_ifa_1_probe_table_get(unit, index, entry));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear all entries in Mirror encap profile.
 *
 * \param [in]  unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_encap_profile_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_INSTANCEs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_INSTANCE_ATTRs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_RSPANs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_ERSPANs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_ERSPAN_IPV6s));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_PSAMP_METADATAs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_PSAMP_METADATA_IPV6s));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_SFLOW_SEQs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_SFLOW_SEQ_IPV6s));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_MIRROR_ON_DROPs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_MIRROR_ON_DROP_IPV6s));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_VXLANs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_VXLAN_IPV6s));

    if (xfs_mirror_db[unit] &&
        xfs_mirror_db[unit]->ifa_1_probe_encap) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MIRROR_ENCAP_IFA_1_PROBEs));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap profile entry.
 *
 * \param [in]  unit Unit Number.
 * \param [in]  type Mirror encap type.
 * \param [in]  index Entry index of profile table.
 * \param [in|out] entry Mirror encap profile entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_encap_profile_entry_get(int unit, mirror_encap_type type,
                               int index, mirror_encap_profile_entry_t *entry)
{
    SHR_FUNC_ENTER(unit);

    entry->type = type;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_table_get(unit, index, entry));

exit:
    SHR_FUNC_EXIT();
}

static int
mirror_encap_profile_index_allocate_ifa_1_probe(
    int unit, bcmi_ltsw_profile_hdl_t profile_hdl,
    void *profile_entries, int flags,
    int entries_per_set, int *index)
{
    int i, num_allocated = 0;
    uint64_t idx_min_data = 0LL, idx_max_data = 0LL;
    int idx_min, idx_max, idx_num;
    int *list = NULL, alloc_sz = 0;

    /*
     * IFA 1.0 reserved an index for probe header insertion,
     * so we need to allocate that index.
     */

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    if (!xfs_mirror_db[unit] ||
        (xfs_mirror_db[unit] &&
         xfs_mirror_db[unit]->ifa_1_probe_encap == FALSE)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Get the number of encap IDs */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       MIRROR_ENCAP_INSTANCEs,
                                       MIRROR_ENCAP_IDs,
                                       &idx_min_data,
                                       &idx_max_data));
    idx_min = (int)idx_min_data;
    idx_max = (int)idx_max_data;
    idx_num = idx_max - idx_min;

    /* List to record allocated index. */
    alloc_sz = idx_num * sizeof(int);
    list = sal_alloc(alloc_sz, "ltswProfileidxIfa1Probe");
    SHR_NULL_CHECK(list, SHR_E_MEMORY);
    sal_memset(list, 0x00, alloc_sz);

    *index = 0;
    /* Trying to allocate the reserved index. */
    for (i = 0; i < idx_num; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_index_allocate
                (unit, profile_hdl, profile_entries, flags,
                 entries_per_set, index));
        if (*index == xfs_mirror_db[unit]->ifa_1_probe_encap_index) {
            break;
        } else {
            /* Record un-used index. */
            num_allocated++;
            list[i] = *index;
        }
    }
    if (*index != xfs_mirror_db[unit]->ifa_1_probe_encap_index) {
        /*
         * The reserved index has been occupied by a precedent with different
         * IFA 1.0 encap, we cannot got the reserved index for such case.
         */
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }

exit:
    /* Free the un-used indexes. */
    for (i = 0; i < num_allocated; i++) {
        (void)bcmi_ltsw_profile_index_free(unit,
                                           profile_hdl,
                                           list[i]);
    }
    SHR_FREE(list);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a Mirror encap profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] entry Mirror encap profile entry data pointer.
 * \param [out] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_profile_entry_add(int unit, mirror_encap_profile_entry_t *entry,
                               int *index)
{
    bcmi_ltsw_profile_hdl_t profile_hdl;
    int rv, new_index;
    bool allocated = false;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    profile_hdl = BCMI_LTSW_PROFILE_MIRROR_ENCAP;

    if (entry->type == ENCAP_IFA_1_PROBE) {
        rv = mirror_encap_profile_index_allocate_ifa_1_probe
                (unit, profile_hdl, entry, 0, 1, index);
    } else {
        rv = bcmi_ltsw_profile_index_allocate
                (unit, profile_hdl, entry, 0, 1, index);
        if (xfs_mirror_db[unit] &&
            xfs_mirror_db[unit]->ifa_1_probe_encap) {
            if (SHR_SUCCESS(rv) &&
                *index == xfs_mirror_db[unit]->ifa_1_probe_encap_index) {
                /*
                 * This index is reserved by IFA 1.0, so allocate
                 * another index.
                 */
                rv = bcmi_ltsw_profile_index_allocate
                        (unit, profile_hdl, entry, 0, 1, &new_index);
                (void)bcmi_ltsw_profile_index_free(unit, profile_hdl, *index);
                *index = new_index;
            }
        }
    }
    if (rv == SHR_E_EXISTS) {
        /* The same profile already exists. */
        SHR_EXIT();
    }

    if (SHR_FAILURE(rv)) {
       SHR_ERR_EXIT(rv);
    }
    allocated = true;

    /* Add entry to table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_table_add(unit, *index, entry));

exit:
    if (SHR_FUNC_ERR()) {
        if (allocated) {
            (void)bcmi_ltsw_profile_index_free(unit, profile_hdl, *index);
        }
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] type Mirror encap type.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_profile_entry_delete(int unit, mirror_encap_type type, int index)
{
    int rv;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_free(unit,
                                      BCMI_LTSW_PROFILE_MIRROR_ENCAP,
                                      index);

    if (rv == SHR_E_BUSY) {
        /* The profile entry is still in used. */
       SHR_EXIT();
    }

    if (rv != SHR_E_NONE) {
        SHR_ERR_EXIT(rv);
    }

    /* Delete table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_table_delete(unit, type, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sequence number enable from mirror encap profile entry.
 *
 * \param [in]  unit Unit Number.
 * \param [in]  type Mirror encap type.
 * \param [in]  entry Mirror encap profile entry.
 * \param [out] enable Sequence number enable.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_encap_profile_seq_enable_get(int unit, mirror_encap_type type,
                                    mirror_encap_profile_entry_t *entry,
                                    bool *enable)
{
    bool ena = false;

    switch (type) {
        case ENCAP_ERSPAN:
            ena = entry->encap.erspan.seq_ena;
            break;
        case ENCAP_ERSPAN_IPv6:
            ena = entry->encap.erspan_ipv6.seq_ena;
            break;
        case ENCAP_PSAMP:
            ena = entry->encap.psamp.seq_ena;
            break;
        case ENCAP_PSAMP_IPv6:
            ena = entry->encap.psamp_ipv6.seq_ena;
            break;
        case ENCAP_SFLOW:
            ena = entry->encap.sflow.seq_ena;
            break;
        case ENCAP_SFLOW_IPv6:
            ena = entry->encap.sflow_ipv6.seq_ena;
            break;
        case ENCAP_MIRROR_ON_DROP:
            ena = entry->encap.mirror_on_drop.seq_ena;
            break;
        case ENCAP_MIRROR_ON_DROP_IPv6:
            ena = entry->encap.mirror_on_drop_ipv6.seq_ena;
            break;
        default:
            break;
    }

    *enable = ena;
    return SHR_E_NONE;
}

/*!
 * \brief Calculate hash signature for Mirror encap LT.
 *
 * \param [in]  unit Unit Number.
 * \param [in]  entries Mirror encap profile entry.
 * \param [in]  entries_per_set Number of entries in the profile set.
 * \param [out] hash Hash signature.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_encap_profile_hash_cb(int unit, void *entries,
                             int entries_per_set, uint32_t *hash)
{
    mirror_encap_profile_entry_t *encap_profile = NULL;
    mirror_encap_type type;
    void *entry;
    int size = 0;
    SHR_FUNC_ENTER(unit);

    encap_profile = (mirror_encap_profile_entry_t *)entries;
    SHR_NULL_CHECK(encap_profile, SHR_E_PARAM);
    type = encap_profile->type;
    entry = encap_profile;
    entry += sizeof(mirror_encap_type);

    switch (type) {
        case ENCAP_RSPAN:
            size = sizeof(mirror_encap_rspan_t);
            break;
        case ENCAP_ERSPAN:
            size = sizeof(mirror_encap_erspan_t);
            break;
        case ENCAP_ERSPAN_IPv6:
            size = sizeof(mirror_encap_erspan_ipv6_t);
            break;
        case ENCAP_PSAMP:
            size = sizeof(mirror_encap_psamp_t);
            break;
        case ENCAP_PSAMP_IPv6:
            size = sizeof(mirror_encap_psamp_ipv6_t);
            break;
        case ENCAP_SFLOW:
            size = sizeof(mirror_encap_sflow_t);
            break;
        case ENCAP_SFLOW_IPv6:
            size = sizeof(mirror_encap_sflow_ipv6_t);
            break;
        case ENCAP_MIRROR_ON_DROP:
            size = sizeof(mirror_encap_mirror_on_drop_t);
            break;
        case ENCAP_MIRROR_ON_DROP_IPv6:
            size = sizeof(mirror_encap_mirror_on_drop_ipv6_t);
            break;
        case ENCAP_VXLAN:
            size = sizeof(mirror_encap_vxlan_t);
            break;
        case ENCAP_VXLAN_IPv6:
            size = sizeof(mirror_encap_vxlan_ipv6_t);
            break;
        case ENCAP_IFA_1_PROBE:
            size = sizeof(mirror_encap_ifa_1_probe_t);
            break;
        default:
            break;
    }

    *hash = shr_crc32(0, entry, entries_per_set * size);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare profile set of Mirror encap LT.
 *
 * \param [in]  unit Unit Number.
 * \param [in]  entries Mirror encap profile.
 * \param [in]  entries_per_set Number of entries in the profile set.
 * \param [in]  index Entry index of profile table.
 * \param [out] cmp Result of comparison.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_encap_profile_cmp_cb(int unit, void *entries,
                            int entries_per_set, int index, int *cmp)
{
    mirror_encap_profile_entry_t *encap_profile = NULL, entry_tmp;
    mirror_encap_type type;
    int rv = SHR_E_NONE;
    bool seq_ena = false;
    SHR_FUNC_ENTER(unit);

    encap_profile = (mirror_encap_profile_entry_t *)entries;
    SHR_NULL_CHECK(encap_profile, SHR_E_PARAM);
    type = encap_profile->type;

    sal_memset(&entry_tmp, 0, sizeof(mirror_encap_profile_entry_t));
    entry_tmp.egr = encap_profile->egr;
    entry_tmp.sys_port = encap_profile->sys_port;
    entry_tmp.truncate = encap_profile->truncate;
    entry_tmp.truncate_mode = encap_profile->truncate_mode;
    entry_tmp.truncate_profile_id = encap_profile->truncate_profile_id;
    if (encap_profile->type == ENCAP_SFLOW) {
        entry_tmp.encap.sflow.seq_ena = encap_profile->encap.sflow.seq_ena;
    } else if (encap_profile->type == ENCAP_SFLOW_IPv6) {
        entry_tmp.encap.sflow_ipv6.seq_ena =
            encap_profile->encap.sflow_ipv6.seq_ena;
    }
    /* Get profile entry for given index. */
    rv = mirror_encap_profile_entry_get(unit, type, index, &entry_tmp);
    if (rv == SHR_E_NOT_FOUND) {
        *cmp = 1;
    } else if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_seq_enable_get(unit, type,
                                             encap_profile, &seq_ena));
    if (!seq_ena) {
        /* Compare pipe id only when sequence number is enabled.*/
        entry_tmp.helper_info.pipe = encap_profile->helper_info.pipe;
    }

    *cmp = sal_memcmp(encap_profile, &entry_tmp,
                      sizeof(mirror_encap_profile_entry_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover encap profile.
 *
 * \param [in]  unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_encap_profile_recover(int unit)
{
    int dunit, rv, instance_id, sess_id, id, encap_id, session_ref_cnt = 0;
    uint32_t prf_ref_cnt = 0;
    uint64_t data;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_MIRROR_ENCAP;
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type = ENCAP_NONE;
    bcmi_ltsw_cosq_mod_dest_t mod_dest;
    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MIRROR_SESSIONs, &entry_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, MIRROR_INSTANCE_IDs, &data));
        instance_id = (int)data;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, MIRROR_SESSION_IDs, &data));
        sess_id = (int)data;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, MIRROR_ENCAP_IDs, &data));
        encap_id = (int)data;

        id = sess_id * MIRROR_INSTANCE_NUM + instance_id;
        /* Get session ref_cnt. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_mirror_session_ref_cnt_get(unit, id, &session_ref_cnt));

        /* Get encap profile ref_cnt. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_get(unit,
                                             profile_hdl,
                                             encap_id,
                                             &prf_ref_cnt));
        if (prf_ref_cnt == 0) {
            /* Get encap type. */
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_encap_type_get(unit, encap_id, &type));

            /* Get encap profile entry. */
            sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_encap_profile_entry_get(unit, type, encap_id, &entry));

            /* Update hash value for this profile entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_profile_hash_update(unit,
                                               profile_hdl,
                                               &entry,
                                               1,
                                               encap_id));
        }

        /* Increase encap profile reference count. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit,
                                                  profile_hdl,
                                                  1,
                                                  encap_id,
                                                  session_ref_cnt));
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

    /* Recover encap profile from mirror-on-drop LT. */
    sal_memset(&mod_dest, 0, sizeof(bcmi_ltsw_cosq_mod_dest_t));
    rv = bcmi_ltsw_cosq_mod_dest_get(unit, &mod_dest);
    if (SHR_SUCCESS(rv)) {
        encap_id = mod_dest.encap_id;

        /* Get encap profile ref_cnt. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_get(unit,
                                             profile_hdl,
                                             encap_id,
                                             &prf_ref_cnt));
        if (prf_ref_cnt == 0) {
            /* Get encap type. */
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_encap_type_get(unit, encap_id, &type));

            /* Get encap profile entry. */
            sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_encap_profile_entry_get(unit, type, encap_id, &entry));

            /* Update hash value for this profile entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_profile_hash_update(unit,
                                               profile_hdl,
                                               &entry,
                                               1,
                                               encap_id));
        }

        /* Increase encap profile reference count. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit,
                                                  profile_hdl,
                                                  1,
                                                  encap_id,
                                                  1));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set system destination for a Mirror encap profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] system_port System port of mirror encap profile entry.
 *                          Null indicates not care.
 * \param [out] pipe PP Pipe id of mirror destination local port.
 *                   Used for per-pipe sequence number. Null indicates not care.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_profile_sys_dest_set(int unit, bcm_mirror_destination_t *mirror_dest,
                                  int *system_port, int *pipe)
{
    bcm_port_t local_port, sys_port = 0;
    bool is_remote, seq_ena;
    SHR_FUNC_ENTER(unit);

    seq_ena = (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) ?
        true : false;

    /* Get local port from Mirror gport. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_mirror_local_port_get(unit,
                                         mirror_dest->gport,
                                         &is_remote,
                                         &local_port));
    /*
     * 1.For remote mirror destination, need to program system port accordingly.
     * Otherwise, program system port as 0, for the sake of saving resource.
     * 2.To support per-pipe sequence number for mirror encap, there is no way
     * to retrieve the pipe number from encap LT except system port field, so in
     * this case, have to program system port.
     */
    if (is_remote || seq_ena) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_to_sys_port(unit, mirror_dest->gport, &sys_port));
    }
    if (system_port) {
        *system_port = sys_port;
    }
    if (pipe) {
        /* Get PP pipe id of mirror destination local port. */
        *pipe = bcmi_ltsw_dev_logic_port_pp_pipe(unit, local_port);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct mirror encap HiGig3 header.
 *
 * The format of HiGig3 header:
 *   Ethertype(2 bytes):
 *     ETHERTYPE[15:0]
 *       --Bits[15:6] - Reserved Ethertype MSB bits for HIGIG3.
 *       --Bits[5:4] - Version(0 for this Rev of the header).
 *       --Bits[3:2] - Indicate presence of extension headers.
 *       --Bits[1] -  Reserved.
 *       --Bit[0] - Mirror copy.
 *
 *   Base header(6 bytes):
 *     SYSTEM_DESTINATION_TYPE[47]
 *       --Identifies type of information carried in system destination.
 *         0x0 - system_fabric_port(unicast destination).
 *         0x1 - fabric_multicast_group(multicast destination).
 *     SYSTEM_DESTINATION[46:32]
 *       --Either fabric_multicast_group or system_fabric_port(which includes
 *         modid, port).
 *     L3_ROUTED[31]
 *       --Identifies if packet is L3 routed.
 *     SYSTEM_SOURCE[30:16]
 *       --Identifies system source port.
 *     ENTROPY[15:8]
 *       --Entropy value to be used in the fabric for load balancing.
 *     CNG[7:6]
 *       --Color/Drop precendence.
 *     CN[5:4]
 *       --Fabric ICN. Overrides any transport QoS if non-zero.
 *     TC[3:0]
 *       --Traffic class.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination structure.
 * \param [out] hg3_ena Enable HiGig3.
 * \param [out] hg3_header HiGig.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_hg3_header_construct(int unit,
                                  bcm_mirror_destination_t *mirror_dest,
                                  bool *hg3_ena,
                                  mirror_encap_hg3_header_t *hg3_header)
{
    bcm_port_t local_port, sys_port;
    bool is_remote = false;
    bool is_hg = false;
    int type;
    uint64_t base_hdr = 0LL;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(hg3_ena, SHR_E_PARAM);
    SHR_NULL_CHECK(hg3_header, SHR_E_PARAM);

    /* Get local port from mirror destination gport. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_mirror_local_port_get(unit,
                                         mirror_dest->gport,
                                         &is_remote,
                                         &local_port));

    /* Not a remote port, don't consturct HiGig3 header. */
    if (!is_remote) {
        *hg3_ena = false;
        SHR_EXIT();
    } else {
        is_hg = bcmi_ltsw_port_is_type(unit,
                                       local_port,
                                       BCMI_LTSW_PORT_TYPE_HG);
        /* Local port is not a HG port, don't construct HiGig3 header. */
        if (!is_hg) {
            *hg3_ena = false;
            SHR_EXIT();
        }
    }

    *hg3_ena = true;
    /* Get HiGig3 ethernet type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_hg3_eth_type_get(unit, &type));

    /* Get system destination port. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_to_sys_port(unit, mirror_dest->gport, &sys_port));

    base_hdr = MIRROR_ENCAP_HG3_HEADER_RSVD_SYS_SOURCE << 16;
    base_hdr |= ((uint64_t)sys_port & 0xFFFFFFFF) << 32;
    hg3_header->ethertype = type << 6;
    /* Indicate mirror copy. */
    hg3_header->ethertype |= 0x1;
    hg3_header->base_hdr = base_hdr;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct mirror encap loopback header.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination structure.
 * \param [out] lb_ena Enable to add loopback header.
 * \param [out] lb_header Loopback header data structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_lb_header_construct(int unit,
                                 bcm_mirror_destination_t *mirror_dest,
                                 bool *lb_ena,
                                 mirror_encap_lb_header_t *lb_header)
{
    int sys_port, local_port, l2_if;
    int my_modid, gport;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(lb_ena, SHR_E_PARAM);
    SHR_NULL_CHECK(lb_header, SHR_E_PARAM);

    if (!(mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_LOOPBACK_ENABLE)) {
        *lb_ena = false;
        SHR_EXIT();
    }

    /* Get local port from Mirror gport. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_mirror_local_port_get(unit,
                                         mirror_dest->gport,
                                         NULL,
                                         &local_port));

    if (!bcmi_ltsw_port_is_type(unit, local_port,
                                BCMI_LTSW_PORT_TYPE_LB)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_stk_modid_get(unit, &my_modid));

    lb_header->loopback_header_type = mirror_dest->loopback_header_type;

    if ((mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_INT_PROBE) &&
        xfs_mirror_db[unit] &&
        xfs_mirror_db[unit]->ifa_1_probe_encap_npl_lb_header) {

        /* Get the L2 interface of 2nd PASS dst port. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_to_l2_if
                (unit, mirror_dest->second_pass_dst_port, &l2_if));

        /* Set the OIF with l2_if to internal loopback port. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set
                (unit, local_port, BCMI_PT_EGR_MC_L2_OIF, l2_if));

        /*
         * Reserved system source as ingress_system_port in second pass flow.
         */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_stk_ifa_system_source_alloc(unit, &sys_port));
    } else {
        BCM_GPORT_MODPORT_SET
            (gport, my_modid, mirror_dest->second_pass_src_port);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_to_sys_port(unit, gport, &sys_port));
    }
    lb_header->src_sys_port = sys_port;

    BCM_GPORT_MODPORT_SET(gport, my_modid, mirror_dest->second_pass_dst_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_to_sys_port(unit, gport, &sys_port));
    lb_header->dst_sys_port = sys_port;

    *lb_ena = true;
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Resolve mirror encap loopback header into mirror destination.
 *
 * \param [in] unit Unit Number.
 * \param [in] lb_ena Enable to add loopback header.
 * \param [in] lb_header Loopback header data structure.
 * \param [out] mirror_dest Mirror destination structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_lb_header_resolve(int unit,
                               bool lb_ena,
                               mirror_encap_lb_header_t *lb_header,
                               bcm_mirror_destination_t *mirror_dest)
{
    int sys_port;
    SHR_FUNC_ENTER(unit);

    if (!lb_ena) {
        SHR_EXIT();
    }

    mirror_dest->flags2 |= BCM_MIRROR_DEST_FLAGS2_LOOPBACK_ENABLE;
    mirror_dest->loopback_header_type = lb_header->loopback_header_type;
    sys_port = lb_header->src_sys_port;
    /* Get destination port from loopback header. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_sys_port_to_port(unit,
                                    sys_port,
                                    &mirror_dest->second_pass_src_port));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_port_local_get(unit,
                                 mirror_dest->second_pass_src_port,
                                 &mirror_dest->second_pass_src_port));

    if (lb_header->loopback_header_type == bcmMirrorLoopbackHeaderIfa) {
        sys_port = lb_header->dst_sys_port;
        /* Get destination port from loopback header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_sys_port_to_port(unit,
                                        sys_port,
                                        &mirror_dest->second_pass_dst_port));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_port_local_get(unit,
                                     mirror_dest->second_pass_dst_port,
                                     &mirror_dest->second_pass_dst_port));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add RSPAN Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_add(int unit, bool egr,
                       bcm_mirror_destination_t *mirror_dest, int *index)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    entry.type = ENCAP_RSPAN;
    entry.egr = egr;
    entry.truncate = mirror_dest->truncate;
    entry.truncate_mode = mirror_dest->encap_truncate_mode;
    entry.truncate_profile_id = mirror_dest->encap_truncate_profile_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, &entry.sys_port,
                                           NULL));

    if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
        entry.encap.rspan.untag = true;
    }
    entry.encap.rspan.pri = mirror_dest->pkt_prio;
    entry.encap.rspan.cfi = mirror_dest->cfi;
    entry.encap.rspan.vlan_id = mirror_dest->vlan_id;
    entry.encap.rspan.tpid = mirror_dest->tpid;

    if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_NIV) {
        entry.encap.rspan.vn_tag = true;
        entry.encap.rspan.src_niv_vif = mirror_dest->niv_src_vif;
        entry.encap.rspan.dst_niv_vif = mirror_dest->niv_dst_vif;
    }

    /* Construct LB header if needed. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_construct(unit,
                                          mirror_dest,
                                          &entry.lb_ena,
                                          &entry.lb_header));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete RSPAN Mirror encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_delete(int unit, bcm_mirror_destination_t *mirror_dest,
                          int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, ENCAP_RSPAN, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get RSPAN Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_get(int unit, int index,
                       bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    type = ENCAP_RSPAN;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_L2;
    if (entry.encap.rspan.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    mirror_dest->pkt_prio = entry.encap.rspan.pri;
    mirror_dest->cfi = entry.encap.rspan.cfi;
    mirror_dest->vlan_id = entry.encap.rspan.vlan_id;
    mirror_dest->tpid = entry.encap.rspan.tpid;

    if (entry.encap.rspan.vn_tag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_NIV;
        mirror_dest->niv_src_vif = entry.encap.rspan.src_niv_vif;
        mirror_dest->niv_dst_vif = entry.encap.rspan.dst_niv_vif;
    }

    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add ERSPAN Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_add(int unit, bool egr,
                        bcm_mirror_destination_t *mirror_dest, int *index)
{
    mirror_encap_type type;
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_ERSPAN_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_ERSPAN;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    entry.type = type;
    entry.egr = egr;
    entry.truncate = mirror_dest->truncate;
    entry.truncate_mode = mirror_dest->encap_truncate_mode;
    entry.truncate_profile_id = mirror_dest->encap_truncate_profile_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, &entry.sys_port,
                                           &entry.helper_info.pipe));

    if (type == ENCAP_ERSPAN) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.erspan.untag = true;
        }
        sal_memcpy(entry.encap.erspan.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.erspan.dst_mac, mirror_dest->dst_mac, 6);
        entry.encap.erspan.src_ipv4 = mirror_dest->src_addr;
        entry.encap.erspan.dst_ipv4 = mirror_dest->dst_addr;
        entry.encap.erspan.tos = mirror_dest->tos;
        entry.encap.erspan.ttl = mirror_dest->ttl;
        entry.encap.erspan.proto = MIRROR_ENCAP_IP_PROTO_TYPE_GRE;
        entry.encap.erspan.df = mirror_dest->df;
        entry.encap.erspan.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV4;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.erspan.outer_vlan = true;
        }
        entry.encap.erspan.pri = mirror_dest->pkt_prio;
        entry.encap.erspan.cfi = mirror_dest->cfi;
        entry.encap.erspan.vlan_id = mirror_dest->vlan_id;
        entry.encap.erspan.tpid = mirror_dest->tpid;
        entry.encap.erspan.gre_header = mirror_dest->gre_protocol ?
                                        mirror_dest->gre_protocol :
                                        MIRROR_ENCAP_GRE_DEF_PROTO_TYPE;
        entry.encap.erspan.session_id = mirror_dest->erspan_header.session_id;
        entry.encap.erspan.switch_id = mirror_dest->erspan_header.switch_id;
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            entry.encap.erspan.seq_ena = true;
            entry.encap.erspan.seq_num = mirror_dest->gre_seq_number;
        }
        entry.encap.erspan.erspan3_sub_header.hw_id =
            mirror_dest->erspan_header.hw_id;
        entry.encap.erspan.erspan3_sub_header.ts_gra =
            mirror_dest->erspan_header.timestamp_granularity;
        entry.encap.erspan.erspan3_sub_header.optional_hdr =
            mirror_dest->erspan_header.optional_hdr;
        /* Construct HiGig3 header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_hg3_header_construct(unit,
                                               mirror_dest,
                                               &entry.encap.erspan.hg3_ena,
                                               &entry.encap.erspan.hg3_header));
        /* Construct LB header if needed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_lb_header_construct(unit,
                                              mirror_dest,
                                              &entry.lb_ena,
                                              &entry.lb_header));
    } else if (type == ENCAP_ERSPAN_IPv6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.erspan_ipv6.untag = true;
        }
        sal_memcpy(entry.encap.erspan_ipv6.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.erspan_ipv6.dst_mac, mirror_dest->dst_mac, 6);
        sal_memcpy(entry.encap.erspan_ipv6.src_ipv6,
                   mirror_dest->src6_addr, 16);
        sal_memcpy(entry.encap.erspan_ipv6.dst_ipv6,
                   mirror_dest->dst6_addr, 16);
        entry.encap.erspan_ipv6.traffic_class = mirror_dest->tos;
        entry.encap.erspan_ipv6.hop_limit = mirror_dest->ttl;
        entry.encap.erspan_ipv6.next_header = MIRROR_ENCAP_IP_PROTO_TYPE_GRE;
        entry.encap.erspan_ipv6.flow_label = mirror_dest->flow_label;
        entry.encap.erspan_ipv6.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV6;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.erspan_ipv6.outer_vlan = true;
        }
        entry.encap.erspan_ipv6.pri = mirror_dest->pkt_prio;
        entry.encap.erspan_ipv6.cfi = mirror_dest->cfi;
        entry.encap.erspan_ipv6.vlan_id = mirror_dest->vlan_id;
        entry.encap.erspan_ipv6.tpid = mirror_dest->tpid;
        entry.encap.erspan_ipv6.gre_header = mirror_dest->gre_protocol ?
                                             mirror_dest->gre_protocol :
                                             MIRROR_ENCAP_GRE_DEF_PROTO_TYPE;
        entry.encap.erspan_ipv6.session_id =
            mirror_dest->erspan_header.session_id;
        entry.encap.erspan_ipv6.switch_id =
            mirror_dest->erspan_header.switch_id;
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            entry.encap.erspan_ipv6.seq_ena = true;
            entry.encap.erspan_ipv6.seq_num = mirror_dest->gre_seq_number;
        }
        entry.encap.erspan_ipv6.erspan3_sub_header.hw_id =
            mirror_dest->erspan_header.hw_id;
        entry.encap.erspan_ipv6.erspan3_sub_header.ts_gra =
            mirror_dest->erspan_header.timestamp_granularity;
        entry.encap.erspan_ipv6.erspan3_sub_header.optional_hdr =
            mirror_dest->erspan_header.optional_hdr;
        /* Construct HiGig3 header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_hg3_header_construct(
                 unit,
                 mirror_dest,
                 &entry.encap.erspan_ipv6.hg3_ena,
                 &entry.encap.erspan_ipv6.hg3_header));
        /* Construct LB header if needed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_lb_header_construct(
                 unit,
                 mirror_dest,
                 &entry.lb_ena,
                 &entry.lb_header));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete ERSPAN Mirror encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_delete(int unit, bcm_mirror_destination_t *mirror_dest,
                           int index)
{
    mirror_encap_type type;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_ERSPAN_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_ERSPAN;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, type, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ERSPAN Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_get(int unit, int index,
                        bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, NULL,
                                           &entry.helper_info.pipe));
    type = ENCAP_ERSPAN;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_IP_GRE;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV4;

    if (entry.encap.erspan.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.erspan.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.erspan.dst_mac, 6);
    mirror_dest->src_addr = entry.encap.erspan.src_ipv4;
    mirror_dest->dst_addr = entry.encap.erspan.dst_ipv4;
    mirror_dest->tos = entry.encap.erspan.tos;
    mirror_dest->ttl = entry.encap.erspan.ttl;
    mirror_dest->df = entry.encap.erspan.df;
    mirror_dest->pkt_prio = entry.encap.erspan.pri;
    mirror_dest->cfi = entry.encap.erspan.cfi;
    mirror_dest->vlan_id = entry.encap.erspan.vlan_id;
    mirror_dest->tpid = entry.encap.erspan.tpid;
    mirror_dest->gre_protocol = entry.encap.erspan.gre_header;
    mirror_dest->erspan_header.session_id = entry.encap.erspan.session_id;
    mirror_dest->erspan_header.switch_id = entry.encap.erspan.switch_id;
    mirror_dest->erspan_header.hw_id =
        entry.encap.erspan.erspan3_sub_header.hw_id;
    mirror_dest->erspan_header.timestamp_granularity =
        entry.encap.erspan.erspan3_sub_header.ts_gra;
    mirror_dest->erspan_header.optional_hdr =
        entry.encap.erspan.erspan3_sub_header.optional_hdr;
    if (entry.encap.erspan.seq_ena) {
        mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
        mirror_dest->gre_seq_number = entry.encap.erspan.seq_num;
    }
    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ERSPAN IPv6 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_ipv6_get(int unit, int index,
                             bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, NULL,
                                           &entry.helper_info.pipe));
    type = ENCAP_ERSPAN_IPv6;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_IP_GRE;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV6;

    if (entry.encap.erspan_ipv6.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }

    sal_memcpy(mirror_dest->src_mac, entry.encap.erspan_ipv6.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.erspan_ipv6.dst_mac, 6);
    sal_memcpy(mirror_dest->src6_addr, entry.encap.erspan_ipv6.src_ipv6,
               16);
    sal_memcpy(mirror_dest->dst6_addr, entry.encap.erspan_ipv6.dst_ipv6,
               16);
    mirror_dest->tos = entry.encap.erspan_ipv6.traffic_class;
    mirror_dest->ttl = entry.encap.erspan_ipv6.hop_limit;
    mirror_dest->flow_label = entry.encap.erspan_ipv6.flow_label;
    mirror_dest->pkt_prio = entry.encap.erspan_ipv6.pri;
    mirror_dest->cfi = entry.encap.erspan_ipv6.cfi;
    mirror_dest->vlan_id = entry.encap.erspan_ipv6.vlan_id;
    mirror_dest->tpid = entry.encap.erspan_ipv6.tpid;
    mirror_dest->gre_protocol = entry.encap.erspan_ipv6.gre_header;
    mirror_dest->erspan_header.session_id = entry.encap.erspan_ipv6.session_id;
    mirror_dest->erspan_header.switch_id = entry.encap.erspan_ipv6.switch_id;
    mirror_dest->erspan_header.hw_id =
        entry.encap.erspan_ipv6.erspan3_sub_header.hw_id;
    mirror_dest->erspan_header.timestamp_granularity =
        entry.encap.erspan_ipv6.erspan3_sub_header.ts_gra;
    mirror_dest->erspan_header.optional_hdr =
        entry.encap.erspan_ipv6.erspan3_sub_header.optional_hdr;
    if (entry.encap.erspan_ipv6.seq_ena) {
         mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
         mirror_dest->gre_seq_number = entry.encap.erspan_ipv6.seq_num;
    }
    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add sFlow Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_add(int unit, bool egr,
                       bcm_mirror_destination_t *mirror_dest, int *index)
{
    mirror_encap_type type;
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_SFLOW_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_SFLOW;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    entry.type = type;
    entry.egr = egr;
    entry.truncate = mirror_dest->truncate;
    entry.truncate_mode = mirror_dest->encap_truncate_mode;
    entry.truncate_profile_id = mirror_dest->encap_truncate_profile_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, &entry.sys_port,
                                           &entry.helper_info.pipe));

    if (type == ENCAP_SFLOW) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.sflow.untag = true;
        }
        sal_memcpy(entry.encap.sflow.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.sflow.dst_mac, mirror_dest->dst_mac, 6);
        entry.encap.sflow.src_ipv4 = mirror_dest->src_addr;
        entry.encap.sflow.dst_ipv4 = mirror_dest->dst_addr;
        entry.encap.sflow.tos = mirror_dest->tos;
        entry.encap.sflow.ttl = mirror_dest->ttl;
        entry.encap.sflow.proto = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.sflow.df = mirror_dest->df;
        entry.encap.sflow.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.sflow.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.sflow.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV4;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.sflow.outer_vlan = true;
        }
        entry.encap.sflow.pri = mirror_dest->pkt_prio;
        entry.encap.sflow.cfi = mirror_dest->cfi;
        entry.encap.sflow.vlan_id = mirror_dest->vlan_id;
        entry.encap.sflow.tpid = mirror_dest->tpid;
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            entry.encap.sflow.seq_ena = true;
            entry.encap.sflow.seq_num = mirror_dest->initial_seq_number;
        }
        entry.encap.sflow.metadata_type = mirror_dest->meta_data_type;
        entry.encap.sflow.metadata = mirror_dest->meta_data;
        /* Construct HiGig3 header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_hg3_header_construct(
                 unit,
                 mirror_dest,
                 &entry.encap.sflow.hg3_ena,
                 &entry.encap.sflow.hg3_header));
        /* Construct LB header if needed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_lb_header_construct(
                 unit,
                 mirror_dest,
                 &entry.lb_ena,
                 &entry.lb_header));
    } else if (type == ENCAP_SFLOW_IPv6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.sflow_ipv6.untag = true;
        }
        sal_memcpy(entry.encap.sflow_ipv6.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.sflow_ipv6.dst_mac, mirror_dest->dst_mac, 6);
        sal_memcpy(entry.encap.sflow_ipv6.src_ipv6,
                   mirror_dest->src6_addr, 16);
        sal_memcpy(entry.encap.sflow_ipv6.dst_ipv6,
                   mirror_dest->dst6_addr, 16);
        entry.encap.sflow_ipv6.traffic_class = mirror_dest->tos;
        entry.encap.sflow_ipv6.hop_limit = mirror_dest->ttl;
        entry.encap.sflow_ipv6.next_header = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.sflow_ipv6.flow_label = mirror_dest->flow_label;
        entry.encap.sflow_ipv6.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.sflow_ipv6.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.sflow_ipv6.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV6;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.sflow_ipv6.outer_vlan = true;
        }
        entry.encap.sflow_ipv6.pri = mirror_dest->pkt_prio;
        entry.encap.sflow_ipv6.cfi = mirror_dest->cfi;
        entry.encap.sflow_ipv6.vlan_id = mirror_dest->vlan_id;
        entry.encap.sflow_ipv6.tpid = mirror_dest->tpid;
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            entry.encap.sflow_ipv6.seq_ena = true;
            entry.encap.sflow_ipv6.seq_num = mirror_dest->initial_seq_number;
        }
        entry.encap.sflow_ipv6.metadata_type = mirror_dest->meta_data_type;
        entry.encap.sflow_ipv6.metadata = mirror_dest->meta_data;
        /* Construct HiGig3 header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_hg3_header_construct(
                 unit,
                 mirror_dest,
                 &entry.encap.sflow_ipv6.hg3_ena,
                 &entry.encap.sflow_ipv6.hg3_header));
        /* Construct LB header if needed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_lb_header_construct(
                 unit,
                 mirror_dest,
                 &entry.lb_ena,
                 &entry.lb_header));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete sFlow Mirror encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_delete(int unit, bcm_mirror_destination_t *mirror_dest,
                          int index)
{
    mirror_encap_type type;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_SFLOW_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_SFLOW;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, type, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sFlow Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_get(int unit, int index,
                       bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);


    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, NULL,
                                           &entry.helper_info.pipe));
    type = ENCAP_SFLOW;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_SFLOW;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV4;

    if (entry.encap.sflow.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.sflow.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.sflow.dst_mac, 6);
    mirror_dest->src_addr = entry.encap.sflow.src_ipv4;
    mirror_dest->dst_addr = entry.encap.sflow.dst_ipv4;
    mirror_dest->tos = entry.encap.sflow.tos;
    mirror_dest->ttl = entry.encap.sflow.ttl;
    mirror_dest->df = entry.encap.sflow.df;
    mirror_dest->udp_src_port = entry.encap.sflow.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.sflow.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.sflow.pri;
    mirror_dest->cfi = entry.encap.sflow.cfi;
    mirror_dest->vlan_id = entry.encap.sflow.vlan_id;
    mirror_dest->tpid = entry.encap.sflow.tpid;

    if (entry.encap.sflow.seq_ena) {
        mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
        mirror_dest->initial_seq_number = entry.encap.sflow.seq_num;
    }
    mirror_dest->meta_data_type = entry.encap.sflow.metadata_type;
    mirror_dest->meta_data = entry.encap.sflow.metadata;
    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sFlow IPv6 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_ipv6_get(int unit, int index,
                            bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, NULL,
                                           &entry.helper_info.pipe));
    type = ENCAP_SFLOW_IPv6;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_SFLOW;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV6;

    if (entry.encap.sflow_ipv6.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.sflow_ipv6.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.sflow_ipv6.dst_mac, 6);
    sal_memcpy(mirror_dest->src6_addr, entry.encap.sflow_ipv6.src_ipv6, 16);
    sal_memcpy(mirror_dest->dst6_addr, entry.encap.sflow_ipv6.dst_ipv6, 16);
    mirror_dest->tos = entry.encap.sflow_ipv6.traffic_class;
    mirror_dest->ttl = entry.encap.sflow_ipv6.hop_limit;
    mirror_dest->flow_label = entry.encap.sflow_ipv6.flow_label;
    mirror_dest->udp_src_port = entry.encap.sflow_ipv6.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.sflow_ipv6.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.sflow_ipv6.pri;
    mirror_dest->cfi = entry.encap.sflow_ipv6.cfi;
    mirror_dest->vlan_id = entry.encap.sflow_ipv6.vlan_id;
    mirror_dest->tpid = entry.encap.sflow_ipv6.tpid;
    if (entry.encap.sflow_ipv6.seq_ena) {
        mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
        mirror_dest->initial_seq_number = entry.encap.sflow_ipv6.seq_num;
    }
    mirror_dest->meta_data_type = entry.encap.sflow_ipv6.metadata_type;
    mirror_dest->meta_data = entry.encap.sflow_ipv6.metadata;
    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add PSAMP Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_add(int unit, bool egr,
                       bcm_mirror_destination_t *mirror_dest, int *index)
{
    mirror_encap_type type;
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_PSAMP_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_PSAMP;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    entry.type = type;
    entry.egr = egr;
    entry.truncate = mirror_dest->truncate;
    entry.truncate_mode = mirror_dest->encap_truncate_mode;
    entry.truncate_profile_id = mirror_dest->encap_truncate_profile_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, &entry.sys_port,
                                           &entry.helper_info.pipe));

    if (type == ENCAP_PSAMP) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.psamp.untag = true;
        }
        sal_memcpy(entry.encap.psamp.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.psamp.dst_mac, mirror_dest->dst_mac, 6);
        entry.encap.psamp.src_ipv4 = mirror_dest->src_addr;
        entry.encap.psamp.dst_ipv4 = mirror_dest->dst_addr;
        entry.encap.psamp.tos = mirror_dest->tos;
        entry.encap.psamp.ttl = mirror_dest->ttl;
        entry.encap.psamp.proto = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.psamp.df = mirror_dest->df;
        entry.encap.psamp.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.psamp.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.psamp.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV4;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.psamp.outer_vlan = true;
        }
        entry.encap.psamp.pri = mirror_dest->pkt_prio;
        entry.encap.psamp.cfi = mirror_dest->cfi;
        entry.encap.psamp.vlan_id = mirror_dest->vlan_id;
        entry.encap.psamp.tpid = mirror_dest->tpid;
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            entry.encap.psamp.seq_ena = true;
            entry.encap.psamp.seq_num = mirror_dest->initial_seq_number;
        }
        entry.encap.psamp.observation_domain = mirror_dest->observation_domain ?
            mirror_dest->observation_domain :
            BCM_MIRROR_IPFIX_OBSERVATION_DOMAIN_DFLT;
        entry.encap.psamp.template_id = mirror_dest->template_id ?
            mirror_dest->template_id : BCM_MIRROR_IPFIX_TEMPLATE_ID_DFLT;
        entry.encap.psamp.ipfix_ver = mirror_dest->ipfix_version ?
            mirror_dest->ipfix_version : 0xa;
        entry.encap.psamp.psamp_epoch = mirror_dest->psamp_epoch;
        entry.encap.psamp.metadata_type = mirror_dest->meta_data_type;
        entry.encap.psamp.metadata = mirror_dest->meta_data;
        entry.encap.psamp.variable_flag = 0xff;
        /* Construct HiGig3 header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_hg3_header_construct(
                 unit,
                 mirror_dest,
                 &entry.encap.psamp.hg3_ena,
                 &entry.encap.psamp.hg3_header));
        /* Construct LB header if needed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_lb_header_construct(
                 unit,
                 mirror_dest,
                 &entry.lb_ena,
                 &entry.lb_header));
    } else if (type == ENCAP_PSAMP_IPv6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.psamp_ipv6.untag = true;
        }
        sal_memcpy(entry.encap.psamp_ipv6.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.psamp_ipv6.dst_mac, mirror_dest->dst_mac, 6);
        sal_memcpy(entry.encap.psamp_ipv6.src_ipv6,
                   mirror_dest->src6_addr, 16);
        sal_memcpy(entry.encap.psamp_ipv6.dst_ipv6,
                   mirror_dest->dst6_addr, 16);
        entry.encap.psamp_ipv6.traffic_class = mirror_dest->tos;
        entry.encap.psamp_ipv6.hop_limit = mirror_dest->ttl;
        entry.encap.psamp_ipv6.next_header = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.psamp_ipv6.flow_label = mirror_dest->flow_label;
        entry.encap.psamp_ipv6.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.psamp_ipv6.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.psamp_ipv6.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV6;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.psamp_ipv6.outer_vlan = true;
        }
        entry.encap.psamp_ipv6.pri = mirror_dest->pkt_prio;
        entry.encap.psamp_ipv6.cfi = mirror_dest->cfi;
        entry.encap.psamp_ipv6.vlan_id = mirror_dest->vlan_id;
        entry.encap.psamp_ipv6.tpid = mirror_dest->tpid;
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            entry.encap.psamp_ipv6.seq_ena = true;
            entry.encap.psamp_ipv6.seq_num = mirror_dest->initial_seq_number;
        }
        entry.encap.psamp_ipv6.observation_domain =
            mirror_dest->observation_domain ?
            mirror_dest->observation_domain :
            BCM_MIRROR_IPFIX_OBSERVATION_DOMAIN_DFLT;
        entry.encap.psamp_ipv6.template_id = mirror_dest->template_id ?
            mirror_dest->template_id : BCM_MIRROR_IPFIX_TEMPLATE_ID_DFLT;
        entry.encap.psamp_ipv6.ipfix_ver = mirror_dest->ipfix_version ?
            mirror_dest->ipfix_version : 0xa;
        entry.encap.psamp_ipv6.psamp_epoch = mirror_dest->psamp_epoch;
        entry.encap.psamp_ipv6.metadata_type = mirror_dest->meta_data_type;
        entry.encap.psamp_ipv6.metadata = mirror_dest->meta_data;
        entry.encap.psamp_ipv6.variable_flag = 0xff;
        /* Construct HiGig3 header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_hg3_header_construct(
                 unit,
                 mirror_dest,
                 &entry.encap.psamp_ipv6.hg3_ena,
                 &entry.encap.psamp_ipv6.hg3_header));
        /* Construct LB header if needed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_lb_header_construct(
                 unit,
                 mirror_dest,
                 &entry.lb_ena,
                 &entry.lb_header));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete PSAMP Mirror encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_delete(int unit, bcm_mirror_destination_t *mirror_dest,
                          int index)
{
    mirror_encap_type type;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_PSAMP_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_PSAMP;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, type, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get PSAMP Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_get(int unit, int index,
                       bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, NULL,
                                           &entry.helper_info.pipe));
    type = ENCAP_PSAMP;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_PSAMP;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV4;

    if (entry.encap.psamp.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.psamp.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.psamp.dst_mac, 6);
    mirror_dest->src_addr = entry.encap.psamp.src_ipv4;
    mirror_dest->dst_addr = entry.encap.psamp.dst_ipv4;
    mirror_dest->tos = entry.encap.psamp.tos;
    mirror_dest->ttl = entry.encap.psamp.ttl;
    mirror_dest->df = entry.encap.psamp.df;
    mirror_dest->udp_src_port = entry.encap.psamp.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.psamp.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.psamp.pri;
    mirror_dest->cfi = entry.encap.psamp.cfi;
    mirror_dest->vlan_id = entry.encap.psamp.vlan_id;
    mirror_dest->tpid = entry.encap.psamp.tpid;
    mirror_dest->observation_domain = entry.encap.psamp.observation_domain;
    mirror_dest->template_id = entry.encap.psamp.template_id;
    mirror_dest->meta_data_type = entry.encap.psamp.metadata_type;
    mirror_dest->meta_data = entry.encap.psamp.metadata;
    mirror_dest->ipfix_version = entry.encap.psamp.ipfix_ver;
    mirror_dest->psamp_epoch = entry.encap.psamp.psamp_epoch;
    if (entry.encap.psamp.seq_ena) {
        mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
        mirror_dest->initial_seq_number = entry.encap.psamp.seq_num;
    }
    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get PSAMP IPv6 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_ipv6_get(int unit, int index,
                            bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, NULL,
                                           &entry.helper_info.pipe));
    type = ENCAP_PSAMP_IPv6;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_PSAMP;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV6;

    if (entry.encap.psamp_ipv6.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }

    sal_memcpy(mirror_dest->src_mac, entry.encap.psamp_ipv6.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.psamp_ipv6.dst_mac, 6);
    sal_memcpy(mirror_dest->src6_addr, entry.encap.psamp_ipv6.src_ipv6, 16);
    sal_memcpy(mirror_dest->dst6_addr, entry.encap.psamp_ipv6.dst_ipv6, 16);
    mirror_dest->tos = entry.encap.psamp_ipv6.traffic_class;
    mirror_dest->ttl = entry.encap.psamp_ipv6.hop_limit;
    mirror_dest->flow_label = entry.encap.psamp_ipv6.flow_label;
    mirror_dest->udp_src_port = entry.encap.psamp_ipv6.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.psamp_ipv6.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.psamp_ipv6.pri;
    mirror_dest->cfi = entry.encap.psamp_ipv6.cfi;
    mirror_dest->vlan_id = entry.encap.psamp_ipv6.vlan_id;
    mirror_dest->tpid = entry.encap.psamp_ipv6.tpid;
    mirror_dest->observation_domain = entry.encap.psamp_ipv6.observation_domain;
    mirror_dest->template_id = entry.encap.psamp_ipv6.template_id;
    mirror_dest->meta_data_type = entry.encap.psamp_ipv6.metadata_type;
    mirror_dest->meta_data = entry.encap.psamp_ipv6.metadata;
    mirror_dest->ipfix_version = entry.encap.psamp_ipv6.ipfix_ver;
    mirror_dest->psamp_epoch = entry.encap.psamp_ipv6.psamp_epoch;
    if (entry.encap.psamp_ipv6.seq_ena) {
        mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
        mirror_dest->initial_seq_number = entry.encap.psamp_ipv6.seq_num;
    }
    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror-on-drop encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_add(int unit, bool egr,
                                bcm_mirror_destination_t *mirror_dest,
                                int *index)
{
    mirror_encap_type type;
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_MIRROR_ON_DROP_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_MIRROR_ON_DROP;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    entry.type = type;
    entry.egr = egr;
    entry.truncate = mirror_dest->truncate;
    entry.truncate_mode = mirror_dest->encap_truncate_mode;
    entry.truncate_profile_id = mirror_dest->encap_truncate_profile_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, &entry.sys_port,
                                           &entry.helper_info.pipe));

    if (type == ENCAP_MIRROR_ON_DROP) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.mirror_on_drop.untag = true;
        }
        sal_memcpy(entry.encap.mirror_on_drop.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.mirror_on_drop.dst_mac, mirror_dest->dst_mac, 6);
        entry.encap.mirror_on_drop.src_ipv4 = mirror_dest->src_addr;
        entry.encap.mirror_on_drop.dst_ipv4 = mirror_dest->dst_addr;
        entry.encap.mirror_on_drop.tos = mirror_dest->tos;
        entry.encap.mirror_on_drop.ttl = mirror_dest->ttl;
        entry.encap.mirror_on_drop.proto = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.mirror_on_drop.df = mirror_dest->df;
        entry.encap.mirror_on_drop.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.mirror_on_drop.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.mirror_on_drop.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV4;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.mirror_on_drop.outer_vlan = true;
        }
        entry.encap.mirror_on_drop.pri = mirror_dest->pkt_prio;
        entry.encap.mirror_on_drop.cfi = mirror_dest->cfi;
        entry.encap.mirror_on_drop.vlan_id = mirror_dest->vlan_id;
        entry.encap.mirror_on_drop.tpid = mirror_dest->tpid;
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            entry.encap.mirror_on_drop.seq_ena = true;
            entry.encap.mirror_on_drop.seq_num =
                mirror_dest->initial_seq_number;
        }
        entry.encap.mirror_on_drop.observation_domain =
            mirror_dest->observation_domain ? mirror_dest->observation_domain :
            BCM_MIRROR_IPFIX_OBSERVATION_DOMAIN_DFLT;
        entry.encap.mirror_on_drop.template_id = mirror_dest->template_id ?
            mirror_dest->template_id : BCM_MIRROR_IPFIX_TEMPLATE_ID_DFLT;
        entry.encap.mirror_on_drop.ipfix_ver = mirror_dest->ipfix_version ?
            mirror_dest->ipfix_version : 0xa;
        entry.encap.mirror_on_drop.metadata_type = mirror_dest->meta_data_type;
        entry.encap.mirror_on_drop.metadata = mirror_dest->meta_data;
        entry.encap.mirror_on_drop.variable_flag = 0xff;
        if (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_TRUE_EGRESS) {
            entry.encap.mirror_on_drop.mode = bcmiMirrorOnDropModeEgress;
        } else {
            entry.encap.mirror_on_drop.mode = bcmiMirrorOnDropModeIngress;
        }

        /* Construct HiGig3 header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_hg3_header_construct(
                 unit,
                 mirror_dest,
                 &entry.encap.mirror_on_drop.hg3_ena,
                 &entry.encap.mirror_on_drop.hg3_header));
        /* Construct LB header if needed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_lb_header_construct(
                 unit,
                 mirror_dest,
                 &entry.lb_ena,
                 &entry.lb_header));
    } else if (type == ENCAP_MIRROR_ON_DROP_IPv6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.mirror_on_drop_ipv6.untag = true;
        }
        sal_memcpy(entry.encap.mirror_on_drop_ipv6.src_mac,
                   mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.mirror_on_drop_ipv6.dst_mac,
                   mirror_dest->dst_mac, 6);
        sal_memcpy(entry.encap.mirror_on_drop_ipv6.src_ipv6,
                   mirror_dest->src6_addr, 16);
        sal_memcpy(entry.encap.mirror_on_drop_ipv6.dst_ipv6,
                   mirror_dest->dst6_addr, 16);
        entry.encap.mirror_on_drop_ipv6.traffic_class = mirror_dest->tos;
        entry.encap.mirror_on_drop_ipv6.hop_limit = mirror_dest->ttl;
        entry.encap.mirror_on_drop_ipv6.next_header =
            MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.mirror_on_drop_ipv6.flow_label = mirror_dest->flow_label;
        entry.encap.mirror_on_drop_ipv6.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.mirror_on_drop_ipv6.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.mirror_on_drop_ipv6.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV6;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.mirror_on_drop_ipv6.outer_vlan = true;
        }
        entry.encap.mirror_on_drop_ipv6.pri = mirror_dest->pkt_prio;
        entry.encap.mirror_on_drop_ipv6.cfi = mirror_dest->cfi;
        entry.encap.mirror_on_drop_ipv6.vlan_id = mirror_dest->vlan_id;
        entry.encap.mirror_on_drop_ipv6.tpid = mirror_dest->tpid;
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            entry.encap.mirror_on_drop_ipv6.seq_ena = true;
            entry.encap.mirror_on_drop_ipv6.seq_num =
                mirror_dest->initial_seq_number;
        }
        entry.encap.mirror_on_drop_ipv6.observation_domain =
            mirror_dest->observation_domain ?
            mirror_dest->observation_domain :
            BCM_MIRROR_IPFIX_OBSERVATION_DOMAIN_DFLT;
        entry.encap.mirror_on_drop_ipv6.template_id = mirror_dest->template_id ?
            mirror_dest->template_id : BCM_MIRROR_IPFIX_TEMPLATE_ID_DFLT;
        entry.encap.mirror_on_drop_ipv6.ipfix_ver = mirror_dest->ipfix_version ?
            mirror_dest->ipfix_version : 0xa;
        entry.encap.mirror_on_drop_ipv6.metadata_type =
            mirror_dest->meta_data_type;
        entry.encap.mirror_on_drop_ipv6.metadata = mirror_dest->meta_data;
        entry.encap.mirror_on_drop_ipv6.variable_flag = 0xff;
        if (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_TRUE_EGRESS) {
            entry.encap.mirror_on_drop_ipv6.mode = bcmiMirrorOnDropModeEgress;
        } else {
            entry.encap.mirror_on_drop_ipv6.mode = bcmiMirrorOnDropModeIngress;
        }

        /* Construct HiGig3 header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_hg3_header_construct(
                 unit,
                 mirror_dest,
                 &entry.encap.mirror_on_drop_ipv6.hg3_ena,
                 &entry.encap.mirror_on_drop_ipv6.hg3_header));
        /* Construct LB header if needed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_lb_header_construct(
                 unit,
                 mirror_dest,
                 &entry.lb_ena,
                 &entry.lb_header));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror-on-drop encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_delete(int unit,
                                   bcm_mirror_destination_t *mirror_dest,
                                   int index)
{
    mirror_encap_type type;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_MIRROR_ON_DROP_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_MIRROR_ON_DROP;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, type, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror-on-drop encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_get(int unit, int index,
                                bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, NULL,
                                           &entry.helper_info.pipe));
    type = ENCAP_MIRROR_ON_DROP;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags2 |= BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV4;

    if (entry.encap.mirror_on_drop.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.mirror_on_drop.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.mirror_on_drop.dst_mac, 6);
    mirror_dest->src_addr = entry.encap.mirror_on_drop.src_ipv4;
    mirror_dest->dst_addr = entry.encap.mirror_on_drop.dst_ipv4;
    mirror_dest->tos = entry.encap.mirror_on_drop.tos;
    mirror_dest->ttl = entry.encap.mirror_on_drop.ttl;
    mirror_dest->df = entry.encap.mirror_on_drop.df;
    mirror_dest->udp_src_port = entry.encap.mirror_on_drop.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.mirror_on_drop.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.mirror_on_drop.pri;
    mirror_dest->cfi = entry.encap.mirror_on_drop.cfi;
    mirror_dest->vlan_id = entry.encap.mirror_on_drop.vlan_id;
    mirror_dest->tpid = entry.encap.mirror_on_drop.tpid;
    mirror_dest->observation_domain =
        entry.encap.mirror_on_drop.observation_domain;
    mirror_dest->template_id = entry.encap.mirror_on_drop.template_id;
    mirror_dest->meta_data_type = entry.encap.mirror_on_drop.metadata_type;
    mirror_dest->meta_data = entry.encap.mirror_on_drop.metadata;
    mirror_dest->ipfix_version = entry.encap.mirror_on_drop.ipfix_ver;
    if (entry.encap.mirror_on_drop.seq_ena) {
        mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
        mirror_dest->initial_seq_number = entry.encap.mirror_on_drop.seq_num;
    }
    if (entry.encap.mirror_on_drop.mode == bcmiMirrorOnDropModeEgress) {
        mirror_dest->flags2 |= BCM_MIRROR_DEST_FLAGS2_TRUE_EGRESS;
    }

    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror-on-drop IPv6 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_ipv6_get(int unit, int index,
                                     bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, NULL,
                                           &entry.helper_info.pipe));
    type = ENCAP_MIRROR_ON_DROP_IPv6;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags2 |= BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV6;

    if (entry.encap.mirror_on_drop_ipv6.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }

    sal_memcpy(mirror_dest->src_mac,
               entry.encap.mirror_on_drop_ipv6.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac,
               entry.encap.mirror_on_drop_ipv6.dst_mac, 6);
    sal_memcpy(mirror_dest->src6_addr,
               entry.encap.mirror_on_drop_ipv6.src_ipv6, 16);
    sal_memcpy(mirror_dest->dst6_addr,
               entry.encap.mirror_on_drop_ipv6.dst_ipv6, 16);
    mirror_dest->tos = entry.encap.mirror_on_drop_ipv6.traffic_class;
    mirror_dest->ttl = entry.encap.mirror_on_drop_ipv6.hop_limit;
    mirror_dest->flow_label = entry.encap.mirror_on_drop_ipv6.flow_label;
    mirror_dest->udp_src_port = entry.encap.mirror_on_drop_ipv6.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.mirror_on_drop_ipv6.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.mirror_on_drop_ipv6.pri;
    mirror_dest->cfi = entry.encap.mirror_on_drop_ipv6.cfi;
    mirror_dest->vlan_id = entry.encap.mirror_on_drop_ipv6.vlan_id;
    mirror_dest->tpid = entry.encap.mirror_on_drop_ipv6.tpid;
    mirror_dest->observation_domain =
        entry.encap.mirror_on_drop_ipv6.observation_domain;
    mirror_dest->template_id = entry.encap.mirror_on_drop_ipv6.template_id;
    mirror_dest->meta_data_type =
        entry.encap.mirror_on_drop_ipv6.metadata_type;
    mirror_dest->meta_data = entry.encap.mirror_on_drop_ipv6.metadata;
    mirror_dest->ipfix_version = entry.encap.mirror_on_drop_ipv6.ipfix_ver;
    if (entry.encap.mirror_on_drop_ipv6.seq_ena) {
        mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
        mirror_dest->initial_seq_number =
            entry.encap.mirror_on_drop_ipv6.seq_num;
    }
    if (entry.encap.mirror_on_drop_ipv6.mode == bcmiMirrorOnDropModeEgress) {
        mirror_dest->flags2 |= BCM_MIRROR_DEST_FLAGS2_TRUE_EGRESS;
    }

    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add VXLAN Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_vxlan_add(int unit, bool egr,
                       bcm_mirror_destination_t *mirror_dest, int *index)
{
    mirror_encap_type type;
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_VXLAN_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_VXLAN;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    entry.type = type;
    entry.egr = egr;
    entry.truncate = mirror_dest->truncate;
    entry.truncate_mode = mirror_dest->encap_truncate_mode;
    entry.truncate_profile_id = mirror_dest->encap_truncate_profile_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_sys_dest_set(unit, mirror_dest, &entry.sys_port,
                                           NULL));

    if (type == ENCAP_VXLAN) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.vxlan.untag = true;
        }
        sal_memcpy(entry.encap.vxlan.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.vxlan.dst_mac, mirror_dest->dst_mac, 6);
        entry.encap.vxlan.src_ipv4 = mirror_dest->src_addr;
        entry.encap.vxlan.dst_ipv4 = mirror_dest->dst_addr;
        entry.encap.vxlan.tos = mirror_dest->tos;
        entry.encap.vxlan.ttl = mirror_dest->ttl;
        entry.encap.vxlan.proto = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.vxlan.df = mirror_dest->df;
        entry.encap.vxlan.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.vxlan.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.vxlan.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV4;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.vxlan.outer_vlan = true;
        }
        entry.encap.vxlan.pri = mirror_dest->pkt_prio;
        entry.encap.vxlan.cfi = mirror_dest->cfi;
        entry.encap.vxlan.vlan_id = mirror_dest->vlan_id;
        entry.encap.vxlan.tpid = mirror_dest->tpid;
        /* Parameter check.. */
        if (mirror_dest->vni > 0xFFFFFF) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        entry.encap.vxlan.vxlan_vnid = mirror_dest->vni;
        entry.encap.vxlan.vxlan_type = 1;
        /* Construct HiGig3 header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_hg3_header_construct(
                 unit,
                 mirror_dest,
                 &entry.encap.vxlan.hg3_ena,
                 &entry.encap.vxlan.hg3_header));
        /* Construct LB header if needed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_lb_header_construct(
                 unit,
                 mirror_dest,
                 &entry.lb_ena,
                 &entry.lb_header));
    } else if (type == ENCAP_VXLAN_IPv6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.vxlan_ipv6.untag = true;
        }
        sal_memcpy(entry.encap.vxlan_ipv6.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.vxlan_ipv6.dst_mac, mirror_dest->dst_mac, 6);
        sal_memcpy(entry.encap.vxlan_ipv6.src_ipv6,
                   mirror_dest->src6_addr, 16);
        sal_memcpy(entry.encap.vxlan_ipv6.dst_ipv6,
                   mirror_dest->dst6_addr, 16);
        entry.encap.vxlan_ipv6.traffic_class = mirror_dest->tos;
        entry.encap.vxlan_ipv6.hop_limit = mirror_dest->ttl;
        entry.encap.vxlan_ipv6.next_header = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.vxlan_ipv6.flow_label = mirror_dest->flow_label;
        entry.encap.vxlan_ipv6.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.vxlan_ipv6.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.vxlan_ipv6.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV6;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.vxlan_ipv6.outer_vlan = true;
        }
        entry.encap.vxlan_ipv6.pri = mirror_dest->pkt_prio;
        entry.encap.vxlan_ipv6.cfi = mirror_dest->cfi;
        entry.encap.vxlan_ipv6.vlan_id = mirror_dest->vlan_id;
        entry.encap.vxlan_ipv6.tpid = mirror_dest->tpid;
        /*
         * When packet is mirrored to a HIGHG3 port with Vxlan IPv6 encap,
         * the encap packet will have to add 8 more bytes(HIGIG3 header),
         * as a result, the total length of encap packet is 82 bytes, which is
         * more than the maximum length(640-bit) flex engine can support.
         *     L2(12)/HIGIG3(8)/Tag(4)/Ethertype(2)/IPv6(40)/UDP(8)/VXLAN(8)
         *     -> Total of 82 bytes
         * Arch team comes up to a solution to address this issue.
         * Solution: VXLAN encap with flex engine, the VNID is from EGR_VFI.
         * In this case VXLAN header will be added at the right offset by
         * flex engines.
         */
        /* Parameter check. */
        if (mirror_dest->vni > 0xFFFFFF) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        entry.encap.vxlan_ipv6.vxlan_vnid = mirror_dest->vni;
        entry.encap.vxlan_ipv6.vxlan_type = 1;
        /* Construct HiGig3 header. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_hg3_header_construct(
                 unit,
                 mirror_dest,
                 &entry.encap.vxlan_ipv6.hg3_ena,
                 &entry.encap.vxlan_ipv6.hg3_header));
        /* Construct LB header if needed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_lb_header_construct(
                 unit,
                 mirror_dest,
                 &entry.lb_ena,
                 &entry.lb_header));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete VXLAN Mirror encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_vxlan_delete(int unit, bcm_mirror_destination_t *mirror_dest,
                          int index)
{
    mirror_encap_type type;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_VXLAN_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_VXLAN;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, type, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get VXLAN Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_vxlan_get(int unit, int index,
                       bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    type = ENCAP_VXLAN;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags2 |= BCM_MIRROR_DEST_FLAGS2_TUNNEL_VXLAN;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV4;

    if (entry.encap.vxlan.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.vxlan.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.vxlan.dst_mac, 6);
    mirror_dest->src_addr = entry.encap.vxlan.src_ipv4;
    mirror_dest->dst_addr = entry.encap.vxlan.dst_ipv4;
    mirror_dest->tos = entry.encap.vxlan.tos;
    mirror_dest->ttl = entry.encap.vxlan.ttl;
    mirror_dest->df = entry.encap.vxlan.df;
    mirror_dest->udp_src_port = entry.encap.vxlan.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.vxlan.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.vxlan.pri;
    mirror_dest->cfi = entry.encap.vxlan.cfi;
    mirror_dest->vlan_id = entry.encap.vxlan.vlan_id;
    mirror_dest->tpid = entry.encap.vxlan.tpid;
    mirror_dest->vni = entry.encap.vxlan.vxlan_vnid;
    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get VXLAN IPv6 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_vxlan_ipv6_get(int unit, int index,
                            bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    type = ENCAP_VXLAN_IPv6;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags2 |= BCM_MIRROR_DEST_FLAGS2_TUNNEL_VXLAN;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV6;

    if (entry.encap.vxlan_ipv6.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }

    sal_memcpy(mirror_dest->src_mac, entry.encap.vxlan_ipv6.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.vxlan_ipv6.dst_mac, 6);
    sal_memcpy(mirror_dest->src6_addr, entry.encap.vxlan_ipv6.src_ipv6, 16);
    sal_memcpy(mirror_dest->dst6_addr, entry.encap.vxlan_ipv6.dst_ipv6, 16);
    mirror_dest->tos = entry.encap.vxlan_ipv6.traffic_class;
    mirror_dest->ttl = entry.encap.vxlan_ipv6.hop_limit;
    mirror_dest->flow_label = entry.encap.vxlan_ipv6.flow_label;
    mirror_dest->udp_src_port = entry.encap.vxlan_ipv6.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.vxlan_ipv6.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.vxlan_ipv6.pri;
    mirror_dest->cfi = entry.encap.vxlan_ipv6.cfi;
    mirror_dest->vlan_id = entry.encap.vxlan_ipv6.vlan_id;
    mirror_dest->tpid = entry.encap.vxlan_ipv6.tpid;
    mirror_dest->vni = entry.encap.vxlan_ipv6.vxlan_vnid;
    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add IFA 1.0 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_ifa_1_probe_add(
    int unit,
    bool egr,
    bcm_mirror_destination_t *mirror_dest,
    int *index)
{
    mirror_encap_profile_entry_t entry;
    int probe_marker;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    entry.type = ENCAP_IFA_1_PROBE;
    entry.egr = egr;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_switch_control_get(unit, bcmSwitchIntProbeMarker1, &probe_marker));
    entry.encap.ifa_1_probe.probemarker_1 = probe_marker;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_switch_control_get(unit, bcmSwitchIntProbeMarker2, &probe_marker));
    entry.encap.ifa_1_probe.probemarker_2 = probe_marker;


    entry.encap.ifa_1_probe.version = 1;
    entry.encap.ifa_1_probe.msg_type = 1;
    entry.encap.ifa_1_probe.request_vector = 0xffff;
    entry.encap.ifa_1_probe.action_vector = 0xffff;

    if (mirror_dest->int_probe_header.flags &
        BCM_MIRROR_INT_PROBE_HEADER_UPDATE_HOP_LIMIT) {
        entry.encap.ifa_1_probe.hop_limit = mirror_dest->int_probe_header.hop_limit;
    } else {
        entry.encap.ifa_1_probe.hop_limit = 0xff;
    }

    if (mirror_dest->int_probe_header.flags &
        BCM_MIRROR_INT_PROBE_HEADER_UPDATE_MAX_LENGTH) {
        entry.encap.ifa_1_probe.max_length =
            mirror_dest->int_probe_header.max_length;
    } else {
        entry.encap.ifa_1_probe.max_length = 0x400;
    }

    /* Construct LB header if needed. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_construct(unit,
                                          mirror_dest,
                                          &entry.lb_ena,
                                          &entry.lb_header));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete IFA 1.0 Mirror encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_ifa_1_probe_delete(
    int unit,
    bcm_mirror_destination_t *mirror_dest,
    int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, ENCAP_IFA_1_PROBE, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get IFA 1.0 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_ifa_1_probe_get(
    int unit,
    int index,
    bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    type = ENCAP_IFA_1_PROBE;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;
    mirror_dest->encap_truncate_mode = entry.truncate_mode;
    mirror_dest->encap_truncate_profile_id = entry.truncate_profile_id;
    mirror_dest->flags |= BCM_MIRROR_DEST_FLAGS2_INT_PROBE;

    mirror_dest->int_probe_header.hop_limit = entry.encap.ifa_1_probe.hop_limit;
    mirror_dest->int_probe_header.max_length = entry.encap.ifa_1_probe.max_length;
    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror destination for non-encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_non_encap_get(int unit, int index,
                     bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    type = ENCAP_NONE;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_get(unit, type, index, &entry));

    mirror_dest->truncate = entry.truncate;

    /* Lookpack header resolve.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_lb_header_resolve(unit,
                                        entry.lb_ena,
                                        &entry.lb_header,
                                        mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Mirror encap parameter validate.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_param_validate(int unit, bool egr,
                            bcm_mirror_destination_t *mirror_dest)
{
    SHR_FUNC_ENTER(unit);

    if (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_LOOPBACK_ENABLE) {
        /*
         * There is a limitation for IPv6 encap mirroring to loopback port.
         * TD4 encap engine supports to encap upto 80-Byte of header.
         * When loopback header is enabled, adding outer VLAN tag will lead
         * to encap engine uses more than 80 Bytes. Thus, we cannot encap
         * IPv6 header with outer VLAN and loopback header at the same time.
         */
        if (MIRROR_DEST_IS_TUNNEL(mirror_dest) &&
            (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) &&
            BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_add(int unit, bool egr,
                 bcm_mirror_destination_t *mirror_dest, int *index)
{
    mirror_encap_profile_entry_t entry;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    if (!MIRROR_DEST_IS_TUNNEL(mirror_dest)) {
        sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));

        entry.type = ENCAP_NONE;
        entry.egr = egr;
        entry.truncate = mirror_dest->truncate;
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_profile_sys_dest_set(unit, mirror_dest,
                                               &entry.sys_port,
                                               NULL));
        /* Construct LB header if needed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_lb_header_construct(unit,
                                              mirror_dest,
                                              &entry.lb_ena,
                                              &entry.lb_header));
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_profile_entry_add(unit, &entry, index));
        SHR_EXIT();
    }

    /* Not support PSAMP, sFlow, MOD, ERSPAN3 encap for egress mirroring. */
    if (egr) {
        if ((mirror_dest->flags & (BCM_MIRROR_DEST_TUNNEL_SFLOW |
                                   BCM_MIRROR_DEST_TUNNEL_PSAMP)) ||
            (mirror_dest->flags2 & (BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP |
                                    BCM_MIRROR_DEST_FLAGS2_TUNNEL_VXLAN))) {
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        }
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_IP_GRE &&
            mirror_dest->gre_protocol == MIRROR_ENCAP_GRE_PROTO_TYPE_ERSPAN3) {
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        }
    }

    /* Not support IFA Probe header encap. */
    if (mirror_dest->flags2 &
        (BCM_MIRROR_DEST_FLAGS2_IFA | BCM_MIRROR_DEST_FLAGS2_INT_PROBE)) {
        if (!xfs_mirror_db[unit] ||
            (xfs_mirror_db[unit] &&
             xfs_mirror_db[unit]->ifa_1_probe_encap == FALSE)) {
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_param_validate(unit, egr, mirror_dest));

    if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_IP_GRE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_add(unit, egr, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_add(unit, egr, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_add(unit, egr, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_L2) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_add(unit, egr, mirror_dest, index));
    } else if (mirror_dest->flags2 &
               BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_add(unit, egr, mirror_dest, index));
    } else if (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_TUNNEL_VXLAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_vxlan_add(unit, egr, mirror_dest, index));
    } else if (mirror_dest->flags2 &
               (BCM_MIRROR_DEST_FLAGS2_IFA |
                BCM_MIRROR_DEST_FLAGS2_INT_PROBE)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_ifa_1_probe_add(unit, egr, mirror_dest, index));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_delete(int unit, bcm_mirror_destination_t *mirror_dest, int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    if (index == -1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* No encap */
    if (!MIRROR_DEST_IS_TUNNEL(mirror_dest)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_profile_entry_delete(unit, ENCAP_NONE, index));

        SHR_EXIT();
    }

    if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_IP_GRE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_delete(unit, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_delete(unit, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_delete(unit, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_L2) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_delete(unit, mirror_dest, index));
    } else if (mirror_dest->flags2 &
               BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_delete(unit, mirror_dest, index));
    } else if (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_TUNNEL_VXLAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_vxlan_delete(unit, mirror_dest, index));
    } else if (mirror_dest->flags2 &
               (BCM_MIRROR_DEST_FLAGS2_IFA |
                BCM_MIRROR_DEST_FLAGS2_INT_PROBE)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_ifa_1_probe_delete(unit, mirror_dest, index));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_get(int unit, int index,
                 bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_type type = ENCAP_NONE;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    /* Get encap type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_type_get(unit, index, &type));

    if (type == ENCAP_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_non_encap_get(unit, index, mirror_dest));
    } else if (type == ENCAP_RSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_get(unit, index, mirror_dest));
    } else if (type == ENCAP_ERSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_get(unit, index, mirror_dest));
    } else if (type == ENCAP_ERSPAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_ipv6_get(unit, index, mirror_dest));
    } else if (type == ENCAP_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_get(unit, index, mirror_dest));
    } else if (type == ENCAP_PSAMP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_ipv6_get(unit, index, mirror_dest));
    } else if (type == ENCAP_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_get(unit, index, mirror_dest));
    } else if (type == ENCAP_SFLOW_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_ipv6_get(unit, index, mirror_dest));
    } else if (type == ENCAP_MIRROR_ON_DROP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_get(unit, index, mirror_dest));
    }  else if (type == ENCAP_MIRROR_ON_DROP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_ipv6_get(unit, index, mirror_dest));
    } else if (type == ENCAP_VXLAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_vxlan_get(unit, index, mirror_dest));
    } else if (type == ENCAP_VXLAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_vxlan_ipv6_get(unit, index, mirror_dest));
    } else if (type == ENCAP_IFA_1_PROBE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_ifa_1_probe_get(unit, index, mirror_dest));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set ingress mirroring on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Source port number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status of container.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_enable_ingress_set(int unit, bcm_port_t port, int mc_bmp,
                               int enable, int *idx)
{
    int i;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    for (i = 0; i < MIRROR_CONTAINER_NUM_PORT_ING; i++) {
        if (mc_bmp & (1 << i)) {
            if (enable & (1 << i)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_port_tab_set(unit,
                                            port,
                                            BCMI_PT_MIRROR_ID + i,
                                            idx[i]));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_port_tab_set(unit,
                                            port,
                                            BCMI_PT_MIRROR_ID + i,
                                            0));
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ingress mirroring on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Source port number.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_enable_ingress_get(int unit, bcm_port_t port,
                               int *enable, int *idx)
{
    int i, ena = 0, mirror_index = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    for (i = 0; i < MIRROR_CONTAINER_NUM_PORT_ING; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_get(unit,
                                    port,
                                    BCMI_PT_MIRROR_ID + i,
                                    &mirror_index));
        /* Instance 0 is reserved. */
        if (mirror_index != 0) {
            ena |= 1 << i;
            idx[i] = mirror_index;
        }
    }
    *enable = ena;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable the egress port mirroring on a specific ingress port.
 *
 * \param [in] unit Unit Number.
 * \param [in] ing_port Ingress port number.
 * \param [in] egr_port Egress port number.
 * \param [in] container_id Container id.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_table_egress_add(int unit, bcm_port_t ing_port,
                             bcm_port_t egr_port, int container_id, int idx)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_EGR_MIRRORs, &eh));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, PORT_IDs, ing_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, EGR_PORT_IDs, egr_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_CONTAINER_IDs, container_id));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRRORs, 1));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_INSTANCE_IDs, idx));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_SESSION_IDs, container_id));

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get egress port mirroring config on a specific ingress port.
 *
 * \param [in] unit Unit Number.
 * \param [in] ing_port Ingress port number.
 * \param [in] egr_port Egress port number.
 * \param [in] container_id Container id.
 * \param [out] enable Mirror enabled.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_table_egress_get(int unit, bcm_port_t ing_port, bcm_port_t egr_port,
                             int container_id, bool *enable, int* idx)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data = 0LL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_EGR_MIRRORs, &eh));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, PORT_IDs, ing_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, EGR_PORT_IDs, egr_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_CONTAINER_IDs, container_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit,
                              eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eh, MIRRORs, &data));
    *enable = (bool)data;

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eh, MIRROR_INSTANCE_IDs, &data));
    *idx = (int)data;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete egress mirroring on logical table.
 *
 * \param [in] unit Unit Number.
 * \param [in] ing_port Ingress port number.
 * \param [in] egr_port Egress port number.
 * \param [in] i Container id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_table_egress_delete(int unit, bcm_port_t ing_port,
                                bcm_port_t egr_port, int i)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_EGR_MIRRORs, &eh));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, PORT_IDs, ing_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, EGR_PORT_IDs, egr_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_CONTAINER_IDs, i));

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_commit(unit,
                              eh,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));
exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set egress mirroring on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Source port number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_enable_egress_set(int unit, bcm_port_t port, int mc_bmp,
                              int enable, int *idx)
{
    int i, p, max_port_num;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    max_port_num = bcmi_ltsw_dev_logic_port_num(unit);

    for (i = 0; i < MIRROR_CONTAINER_NUM_PORT_EGR; i++) {
        if (mc_bmp & (1 << i)) {
            if (enable & (1 << i)) {
                for (p = 0; p < max_port_num; p++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mirror_port_table_egress_add(unit, p, port,
                                                      i, idx[i]));
                }
            } else {
                for (p = 0; p < max_port_num; p++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mirror_port_table_egress_delete(unit, p, port, i));
                }
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get egress mirroring on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Source port number.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_enable_egress_get(int unit, bcm_port_t port,
                              int *enable, int *idx)
{
    int i, rv, mirror_index = 0, value = 0;
    bool ena = false;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    for (i = 0; i < MIRROR_CONTAINER_NUM_PORT_EGR; i++) {
        rv = mirror_port_table_egress_get(unit, 0, port, i,
                                          &ena, &mirror_index);
        if (rv == SHR_E_NONE && ena) {
            value |= 1 << i;
            idx[i] = mirror_index;
        } else if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }
    *enable = value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set ingress mirroring on a vp.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Source port number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status of container.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_vp_enable_ingress_set(int unit, bcm_port_t port, int mc_bmp,
                             int enable, int *idx)
{
    int i, con_num;
    int ena = 0, dis = 0;

    SHR_FUNC_ENTER(unit);

    con_num = MIRROR_CONTAINER_NUM_VP_ING;

    for (i = 0; i < con_num; i++) {
        if (mc_bmp & (1 << i)) {
            if (enable & (1 << i)) {
                ena |= 1 << i;
            } else {
                dis |= 1 << i;
            }
        }
    }

    if (ena) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_mirror_ctrl_set(unit,
                                                    port,
                                                    ena,
                                                    idx));
    }
    if (dis) {
        /* Only set disabled container. */
        dis = ((1 << con_num) - 1) & (~dis);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_mirror_ctrl_set(unit,
                                                    port,
                                                    dis,
                                                    NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set event control table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] trace_instance Instance array for trace event.
 * \param [in] drop_session Session id for drop event.
 * \param [in] drop_instance Instance for drop event.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_event_control_table_set(int unit, int *trace_instance,
                               int drop_session, int drop_instance)
{
    int i;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TRACE_MIRROR_INSTANCE_ID_0s, 0, 0, {0}},
        /*1*/ {TRACE_MIRROR_INSTANCE_ID_1s, 0, 0, {0}},
        /*2*/ {TRACE_MIRROR_INSTANCE_ID_2s, 0, 0, {0}},
        /*3*/ {TRACE_MIRROR_INSTANCE_ID_3s, 0, 0, {0}},
        /*4*/ {TRACE_MIRROR_INSTANCE_ID_4s, 0, 0, {0}},
        /*5*/ {TRACE_MIRROR_INSTANCE_ID_5s, 0, 0, {0}},
        /*6*/ {TRACE_MIRROR_INSTANCE_ID_6s, 0, 0, {0}},
        /*7*/ {TRACE_MIRROR_INSTANCE_ID_7s, 0, 0, {0}},
        /*8*/ {DROP_MIRROR_SESSION_IDs, 0, 0, {0}},
        /*9*/ {DROP_MIRROR_INSTANCE_IDs, 0, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX && trace_instance; i++) {
        if (trace_instance[i] != -1) {
            field[i].flags |= BCMI_LT_FIELD_F_SET;
            field[i].u.val = trace_instance[i];
        }
    }

    if (drop_session != -1) {
        field[8].flags |= BCMI_LT_FIELD_F_SET;
        field[8].u.val = drop_session;

        field[9].flags |= BCMI_LT_FIELD_F_SET;
        field[9].u.val = drop_instance;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MON_EVENT_CONTROLs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get event control table entry.
 *
 * \param [in] unit Unit Number.
 * \param [out] trace_instance Instance array for trace event.
 * \param [out] drop_session Session id for drop event.
 * \param [out] drop_instance Instance for drop event.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_event_control_table_get(int unit, int *trace_instance,
                               int *drop_session, int *drop_instance)
{
    int i;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TRACE_MIRROR_INSTANCE_ID_0s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {TRACE_MIRROR_INSTANCE_ID_1s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {TRACE_MIRROR_INSTANCE_ID_2s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {TRACE_MIRROR_INSTANCE_ID_3s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {TRACE_MIRROR_INSTANCE_ID_4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {TRACE_MIRROR_INSTANCE_ID_5s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {TRACE_MIRROR_INSTANCE_ID_6s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {TRACE_MIRROR_INSTANCE_ID_7s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {DROP_MIRROR_SESSION_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {DROP_MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MON_EVENT_CONTROLs,
                           &lt_entry,
                           NULL, NULL));

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX && trace_instance; i++) {
        /* Instance 0 is reserved. */
        trace_instance[i] = field[i].u.val ? field[i].u.val : -1;
    }
    if (drop_session) {
        *drop_session = field[8].u.val;
    }
    if (drop_instance) {
        *drop_instance = field[9].u.val ? field[9].u.val : -1;
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get all mirroring configuration applied on event.
 *
 * \param [in] unit Unit Number.
 * \param [in] trace True for trace event, false for drop event.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_event_enable_get(int unit, bool trace, int *enable, int *idx)
{
    int session = 0, instance = 0, trace_instance[MIRROR_CONTAINER_NUM_MAX];
    int i, rv = SHR_E_NONE;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    rv = mirror_event_control_table_get(unit,
                                        trace_instance,
                                        &session,
                                        &instance);
    if (rv == SHR_E_NONE) {
        *enable = 0;
        if (trace) {
            for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
                if (trace_instance[i] != -1) {
                    *enable |= 1 << i;
                    idx[i] = trace_instance[i];
                }
            }
        } else {
            *enable = 1 << session;
            idx[session] = instance;
        }
    } else if (rv != SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Convert BCM trace event to LT name, field.
 *
 * \param [in] unit Unit Number.
 * \param [in] trace_event Trace event.
 * \param [in] table_name Table name.
 * \param [in] key_name Key name.
 * \param [in] key_value Key value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_trace_event_convert(int unit,
                           bcm_pkt_trace_event_t trace_event,
                           const char **table_name,
                           const char **key_name,
                           const char **key_value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_switch_trace_event_to_symbol(unit,
                                                trace_event,
                                                table_name,
                                                key_value));
    if (sal_strcmp(*table_name, MON_ING_TRACE_EVENTs) == 0) {
        *key_name = MON_ING_TRACE_EVENT_IDs;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set trace event table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] trace_event Trace event.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_trace_event_table_set(int unit,
                             bcm_pkt_trace_event_t trace_event,
                             int mc_bmp,
                             int enable)
{
    int i;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*1*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /*2*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 2, {0}},
        /*3*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 3, {0}},
        /*4*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 4, {0}},
        /*5*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 5, {0}},
        /*6*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 6, {0}},
        /*7*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 7, {0}},
        /*8*/ {NULL, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    const char *table_name = NULL, *key_name = NULL, *key_value = NULL;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (mc_bmp & (1 << i)) {
            if (enable & (1 << i)) {
                field[i].flags |= BCMI_LT_FIELD_F_SET |
                                  BCMI_LT_FIELD_F_ELE_VALID;
                field[i].u.val = 1;
            } else {
                field[i].flags |= BCMI_LT_FIELD_F_SET |
                                  BCMI_LT_FIELD_F_ELE_VALID;
                field[i].u.val = 0;
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_trace_event_convert(unit,
                                    trace_event,
                                    &table_name,
                                    &key_name,
                                    &key_value));

    field[8].flags |= BCMI_LT_FIELD_F_SYMBOL;
    field[8].fld_name = key_name;
    field[8].u.sym_val = key_value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, table_name, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get trace event table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] trace_event Trace event.
 * \param [out] enable Enable status.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_trace_event_table_get(int unit,
                             bcm_pkt_trace_event_t trace_event,
                             int *enable)
{
    int i;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /*2*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 2, {0}},
        /*3*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 3, {0}},
        /*4*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 4, {0}},
        /*5*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 5, {0}},
        /*6*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 6, {0}},
        /*7*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 7, {0}},
        /*8*/ {NULL, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    const char *table_name = NULL, *key_name = NULL, *key_value = NULL;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_trace_event_convert(unit,
                                    trace_event,
                                    &table_name,
                                    &key_name,
                                    &key_value));

    field[8].flags |= BCMI_LT_FIELD_F_SYMBOL;
    field[8].fld_name = key_name;
    field[8].u.sym_val = key_value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           table_name,
                           &lt_entry,
                           NULL, NULL));

    *enable = 0;
    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (field[i].u.val != 0) {
            *enable |= 1 << i;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable ingress mirroring on a trace event.
 *
 * \param [in] unit Unit Number.
 * \param [in] trace_event Trace event.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_trace_event_enable_ingress_set(int unit,
                                      bcm_pkt_trace_event_t trace_event,
                                      int mc_bmp,
                                      int enable,
                                      int *idx)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_trace_event_table_set(unit, trace_event, mc_bmp, enable));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_event_control_table_set(unit, idx, -1, -1));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mirroring configuration on trace event.
 *
 * \param [in] unit Unit Number.
 * \param [in] trace_event Trace event.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_trace_event_enable_ingress_get(int unit,
                                      bcm_pkt_trace_event_t trace_event,
                                      int *enable,
                                      int *idx)
{
    int ena = 0, rv;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    /* Use all drops to get all mirror instances. */
    if (trace_event == bcmPktTraceEventCount) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_event_enable_get(unit, true, enable, idx));
    } else {
        rv = mirror_trace_event_table_get(unit, trace_event, enable);
        if (rv == SHR_E_NOT_FOUND) {
            rv = SHR_E_NONE;
        }
        SHR_IF_ERR_VERBOSE_EXIT(rv);

        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_event_enable_get(unit, true, &ena, idx));
        *enable &= ena;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert BCM drop event to LT name, field.
 *
 * \param [in] unit Unit Number.
 * \param [in] drop_event Drop event.
 * \param [in] table_name Table name.
 * \param [in] key_name Key name.
 * \param [in] key_value Key value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_drop_event_convert(int unit,
                          bcm_pkt_drop_event_t drop_event,
                          const char **table_name,
                          const char **key_name,
                          const char **key_value)
{
    int rv = SHR_E_NONE;
    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_switch_drop_event_to_symbol(unit,
                                               drop_event,
                                               table_name,
                                               key_value);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (sal_strcmp(*table_name, MON_ING_DROP_EVENTs) == 0) {
        *key_name = MON_ING_DROP_EVENT_IDs;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set drop event table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] drop_event Drop event.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_drop_event_table_set(int unit,
                            bcm_pkt_drop_event_t drop_event,
                            int mc_bmp,
                            int enable,
                            int *idx)
{
    int i, ena = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRRORs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {NULL, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    const char *table_name = NULL, *key_name = NULL, *key_value = NULL;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (mc_bmp & (1 << i)) {
            if (enable & (1 << i)) {
                ena = 1;
            } else {
                ena = 0;
            }
            break;
        }
    }

    field[0].u.val = ena;

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_drop_event_convert(unit,
                                   drop_event,
                                   &table_name,
                                   &key_name,
                                   &key_value));

    field[1].flags |= BCMI_LT_FIELD_F_SYMBOL;
    field[1].fld_name = key_name;
    field[1].u.sym_val = key_value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, table_name, &lt_entry, NULL));

    /* Set event control table here. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_event_control_table_set(unit, NULL, i, idx[i]));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get drop event table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] drop_event Drop event.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_drop_event_table_get(int unit,
                            bcm_pkt_drop_event_t drop_event,
                            int *enable,
                            int *idx)
{
    int ena = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRRORs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {NULL, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    const char *table_name = NULL, *key_name = NULL, *key_value = NULL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_drop_event_convert(unit,
                                   drop_event,
                                   &table_name,
                                   &key_name,
                                   &key_value));

    field[1].flags |= BCMI_LT_FIELD_F_SYMBOL;
    field[1].fld_name = key_name;
    field[1].u.sym_val = key_value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           table_name,
                           &lt_entry,
                           NULL, NULL));

    ena = field[0].u.val;
    if (ena) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_event_enable_get(unit, false, enable, idx));
    } else {
        *enable = 0;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable ingress mirroring on a drop event.
 *
 * \param [in] unit Unit Number.
 * \param [in] drop_event Drop event.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_drop_event_enable_ingress_set(int unit,
                                     bcm_pkt_drop_event_t drop_event,
                                     int mc_bmp,
                                     int enable,
                                     int *idx)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_drop_event_table_set(unit, drop_event, mc_bmp, enable, idx));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mirroring configuration on drop event.
 *
 * \param [in] unit Unit Number.
 * \param [in] drop_event Drop event.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_drop_event_enable_ingress_get(int unit,
                                     bcm_pkt_drop_event_t drop_event,
                                     int *enable,
                                     int *idx)
{
    int rv;
    SHR_FUNC_ENTER(unit);

    /* Use all drops to get all mirror instances. */
    if (drop_event == bcmPktDropEventCount) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_event_enable_get(unit, false, enable, idx));
    } else {
        rv = mirror_drop_event_table_get(unit, drop_event, enable, idx);
        if (rv == SHR_E_NOT_FOUND) {
            rv = SHR_E_NONE;
        }
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mirroring index on a FP entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] Mirror source type.
 * \param [in] entry_id FP entry id.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_fp_enable_get(int unit, int source_type,
                     int entry_id, int *enable, int *idx)
{
    bool m_enable = false;
    int i, ena = 0, mirror_index = 0;
    bcm_field_action_t action;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    if (source_type == BCMINT_MIRROR_ST_F_FP_ING) {
        action = bcmFieldActionMirrorIngress;
    } else if (source_type == BCMINT_MIRROR_ST_F_FP_EGR) {
        action = bcmFieldActionMirrorEgress;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    for (i = MIRROR_CONTAINER_FP_MIN;
         i < MIRROR_CONTAINER_FP_MIN + MIRROR_CONTAINER_NUM_FP_ING;
         i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_field_mirror_index_get(unit,
                                              entry_id,
                                              action,
                                              i,
                                              &m_enable,
                                              &mirror_index));
        /* Instance 0 is reserved. */
        if (m_enable == true) {
            ena |= 1 << i;
            idx[i] = mirror_index;
            m_enable = false;
        }
    }
    *enable = ena;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mirroring index on a field destination entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] match Field destination match.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_field_destination_enable_get(int unit,
                                    bcm_field_destination_match_t *match,
                                    int *enable, int *idx)
{
    int ena = 0, mirror_index = 0, rv;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(match, SHR_E_PARAM);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    rv = bcmi_ltsw_field_destination_mirror_index_get(unit,
                                                      match,
                                                      &mirror_index);
    /* Instance 0 is reserved. */
    if (SHR_SUCCESS(rv) && mirror_index != 0) {
        ena |= 1 << MIRROR_CONTAINER_FIELD_DEST;
        idx[MIRROR_CONTAINER_FIELD_DEST] = mirror_index;
    } else if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    *enable = ena;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert Mirror counter table.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_session_stat_table_insert(int unit,int session_id)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int pipe_num, pipe = 0, id = 0, instance = 0, rv;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    pipe_num = bcmi_ltsw_dev_max_pp_pipe_num(unit);
    id = session_id / MIRROR_INSTANCE_NUM;
    instance = session_id % MIRROR_INSTANCE_NUM;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, CTR_MIRRORs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MIRROR_INSTANCE_IDs, instance));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MIRROR_SESSION_IDs, id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PIPEs, 0));

    /* Lookup it first, if it exists, return error. */
    rv = bcmlt_entry_commit(entry_hdl,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NONE) {
        SHR_ERR_EXIT(SHR_E_EXISTS);
    }
    bcmlt_entry_free(entry_hdl);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (pipe = 0; pipe < pipe_num; pipe++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, CTR_MIRRORs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MIRROR_INSTANCE_IDs, instance));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MIRROR_SESSION_IDs, id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PIPEs, pipe));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl,
                                         BCMLT_OPCODE_INSERT,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror counter table.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_session_stat_table_delete(int unit,int session_id)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int pipe_num, pipe = 0, id = 0, instance = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    pipe_num = bcmi_ltsw_dev_max_pp_pipe_num(unit);
    id = session_id / MIRROR_INSTANCE_NUM;
    instance = session_id % MIRROR_INSTANCE_NUM;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (pipe = 0; pipe < pipe_num; pipe++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, CTR_MIRRORs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MIRROR_INSTANCE_IDs, instance));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MIRROR_SESSION_IDs, id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PIPEs, pipe));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl,
                                         BCMLT_OPCODE_DELETE,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set Mirror counter table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [in] value Statistics value.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_session_stat_table_set(int unit,int session_id, uint64_t value)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int pipe_num, pipe = 0, id = 0, instance = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    pipe_num = bcmi_ltsw_dev_max_pp_pipe_num(unit);
    id = session_id / MIRROR_INSTANCE_NUM;
    instance = session_id % MIRROR_INSTANCE_NUM;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (pipe = 0; pipe < pipe_num; pipe++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, CTR_MIRRORs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MIRROR_INSTANCE_IDs, instance));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MIRROR_SESSION_IDs, id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PIPEs, pipe));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MIRROR_PKTs, value));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl,
                                         BCMLT_OPCODE_UPDATE,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror counter table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [in] sync Sync mode.
 * \param [out] value Statistics value.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_session_stat_table_get(int unit,int session_id, bool sync,
                              uint64_t *value)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int pipe_num, pipe = 0, id = 0, instance = 0, i =0;
    uint64_t field_val;
    bcmlt_entry_info_t entry_info;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_info_t trans_info;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    uint32_t entry_attr;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(value, SHR_E_PARAM);

    pipe_num = bcmi_ltsw_dev_max_pp_pipe_num(unit);
    id = session_id / MIRROR_INSTANCE_NUM;
    instance = session_id % MIRROR_INSTANCE_NUM;
    entry_attr = sync ? BCMLT_ENT_ATTR_GET_FROM_HW : 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (pipe = 0; pipe < pipe_num; pipe++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, CTR_MIRRORs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MIRROR_INSTANCE_IDs, instance));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MIRROR_SESSION_IDs, id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PIPEs, pipe));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_attrib_set(entry_hdl, entry_attr));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl,
                                         BCMLT_OPCODE_LOOKUP,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_info_get(trans_hdl, &trans_info));
    *value = 0;

    for (i = 0; i < trans_info.num_entries; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_num_get(trans_hdl, i, &entry_info));
        entry_hdl = entry_info.entry_hdl;

        /* Get each entry's stat and accumulate it. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, MIRROR_PKTs, &field_val));
        *value += field_val;
        entry_hdl = BCMLT_INVALID_HDL;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror session table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [in] session Mirror session entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_session_table_add(int unit,int session_id,
                         bcmint_mirror_session_entry_t *session)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_SESSION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {EGRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {MC_COSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {ENTRY_PRIORITYs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {SYSTEM_PORT_TABLE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    session_field[1].u.val = session_id / MIRROR_INSTANCE_NUM;
    session_field[2].u.val = session->egr;
    session_field[3].u.val = session->encap_id;
    session_field[4].u.val = session->mc_cos;
    session_field[5].u.val = session->entry_pri;
    session_field[6].u.val = session->sys_port;
    session_field[7].u.val = session->local_port;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_SESSIONs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror session table with given session id.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_session_table_delete(int unit, int session_id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_SESSION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    session_field[1].u.val = session_id / MIRROR_INSTANCE_NUM;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_SESSIONs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror session table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [out] session Mirror session entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_session_table_get(int unit,int session_id,
                         bcmint_mirror_session_entry_t *session)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_SESSION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {EGRs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {MC_COSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {ENTRY_PRIORITYs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {SYSTEM_PORT_TABLE_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {PORT_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    session_field[1].u.val = session_id / MIRROR_INSTANCE_NUM;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_SESSIONs,
                           &lt_entry,
                           NULL, NULL));

    session->egr = session_field[2].u.val;
    session->encap_id = session_field[3].u.val;
    session->mc_cos = session_field[4].u.val;
    session->entry_pri = session_field[5].u.val;
    session->sys_port = session_field[6].u.val;
    session->local_port = session_field[7].u.val;
    session->valid = true;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable to queue mirror_to_cpu copy in CPU cos.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [in] session Mirror session entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_session_cpu_queue_enable(int unit,int session_id,
                                bcmint_mirror_session_entry_t *session)
{
    bcm_port_t cpu_port;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    cpu_port = bcmi_ltsw_port_cpu(unit);
    /* Only enable for mirror to CPU copy. */
    if (session->local_port != cpu_port) {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                cpu_port,
                                BCMI_PT_MIRROR_CPU,
                                true));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Disable to queue mirror_to_cpu copy in CPU cos.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_session_cpu_queue_disable(int unit, int session_id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_SESSION_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {PORT_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    bcm_port_t cpu_port;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    session_field[1].u.val = session_id / MIRROR_INSTANCE_NUM;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_SESSIONs,
                           &lt_entry,
                           NULL, NULL));
    cpu_port = bcmi_ltsw_port_cpu(unit);
    /* Only enable for mirror to CPU copy. */
    if (session_field[2].u.val != cpu_port) {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                cpu_port,
                                BCMI_PT_MIRROR_CPU,
                                false));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set ingress/flex sampler random seed value.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Sample seed type.
 * \param [in] value Random seed value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sampler_ing_flex_seed_set(int unit,
                                 bcmi_ltsw_mirror_sampler_seed_type_t type,
                                 int value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {CTR_ING_FLEX_POOL_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {SAMPLE_ING_FLEX_SEEDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    if (type == bcmiSamplerSeedIngress) {
        field[0].u.val = 0; /* Pool 0 is for ingress sampler. */
    } else if (type == bcmiSamplerSeedFlex) {
        field[0].u.val = 1; /* Pool 1 is for flex sampler. */
    }
    field[1].u.val = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_SFLOW_CONTROLs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ingress/flex sampler random seed value.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Sample seed type.
 * \param [out] value Random seed value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sampler_ing_flex_seed_get(int unit,
                                 bcmi_ltsw_mirror_sampler_seed_type_t type,
                                 int *value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {CTR_ING_FLEX_POOL_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {SAMPLE_ING_FLEX_SEEDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    if (type == bcmiSamplerSeedIngress) {
        field[0].u.val = 0; /* Pool 0 is for ingress sampler. */
    } else if (type == bcmiSamplerSeedFlex) {
        field[0].u.val = 1; /* Pool 1 is for flex sampler. */
    }
    rv = bcmi_lt_entry_get(unit,
                           MIRROR_SFLOW_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *value = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    *value = field[1].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set egress sampler random seed value.
 *
 * \param [in] unit Unit Number.
 * \param [in] value Random seed value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sampler_egr_seed_set(int unit, int value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_EGR_SEEDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get egress sampler random seed value.
 *
 * \param [in] unit Unit Number.
 * \param [out] value Random seed value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sampler_egr_seed_get(int unit, int *value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_EGR_SEEDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *value = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    *value = field[0].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init sample seed value.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sampler_seed_init(int unit)
{
    int i = 0;
    int value[3] = {0x1, 0x2, 0x1};
    bcmi_ltsw_mirror_sampler_seed_type_t type[3] = {bcmiSamplerSeedIngress,
                                                    bcmiSamplerSeedEgress,
                                                    bcmiSamplerSeedFlex};
    SHR_FUNC_ENTER(unit);

    /* Ingress sample seed. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sampler_ing_flex_seed_set(unit, type[i], value[i]));
    i++;

    /* Egress sample seed. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sampler_egr_seed_set(unit, value[i]));
    i++;

    /* Flex sample seed. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sampler_ing_flex_seed_set(unit, type[i], value[i]));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set mc_cos for mirror copies.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_cos Mc_cos value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_mc_cos_set(int unit, int mc_cos)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MC_PKT_MC_COS_OVERRIDEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MC_PKT_MC_COSs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int num_ucq = 0, num_mcq = 0;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, &num_mcq));

    if (mc_cos == -1) {
        field[0].u.val = false;
        field[1].u.val = 0;
    } else if (mc_cos >= 0 && mc_cos < num_mcq) {
        field[0].u.val = true;
        field[1].u.val = mc_cos;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mc_cos for mirror copies.
 *
 * \param [in] unit Unit Number.
 * \param [out] mc_cos Mc_cos value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_mc_cos_get(int unit, int *mc_cos)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MC_PKT_MC_COS_OVERRIDEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {MC_PKT_MC_COSs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *mc_cos = -1;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if(field[0].u.val) {
        *mc_cos = field[1].u.val;
    } else {
        *mc_cos = -1;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set cpu_cos for mirror-to-cpu copies.
 *
 * \param [in] unit Unit Number.
 * \param [in] cpu_cos Cpu_cos value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_cpu_cos_set(int unit, int cpu_cos)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_CPU_COS_OVERRIDEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TM_CPU_COSs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    if (cpu_cos == -1) {
        field[0].u.val = false;
        field[1].u.val = 0;
    } else if (cpu_cos >= 0) {
        field[0].u.val = true;
        field[1].u.val = cpu_cos;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get cpu_cos for mirror-to-cpu copies.
 *
 * \param [in] unit Unit Number.
 * \param [out] cpu_cos Cpu_cos value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_cpu_cos_get(int unit, int *cpu_cos)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_CPU_COS_OVERRIDEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {TM_CPU_COSs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *cpu_cos = -1;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if(field[0].u.val) {
        *cpu_cos = field[1].u.val;
    } else {
        *cpu_cos = -1;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the keys of mirror sample entry.
 *
 * \param [in] unit Unit number.
 * \param [in] type Sample type.
 * \param [in] profile_id Sample profile id.
 * \param [out] eh Entry handle.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sample_entry_keys_set(int unit, bcmint_mirror_sample_type_t type,
                             int profile_id, bcmlt_entry_handle_t *eh)
{
    int dunit = 0, pool;
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(eh, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MIRROR_SFLOWs, eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(*eh, BASE_INDEXs, profile_id));

    switch (type) {
        case bcmintMirrorSampleIngress:
            pool = 0;
            break;
        case bcmintMirrorSampleFlex:
            pool = 1;
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(*eh, CTR_ING_FLEX_POOL_IDs, pool));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set mirror sample entry fields.
 *
 * \param [in] unit Unit number.
 * \param [in] eh Entry handle.
 * \param [in] entry Sample entry.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sample_entry_fields_set(int unit, bcmlt_entry_handle_t eh,
                               bcmint_mirror_sample_profile_t *entry)
{
    int threshold = 0;
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_ENABLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, SAMPLE_ING_FLEXs, entry->enable));
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_RATE) {
        if (entry->rate > 0) {
            if (entry->rate == 1) {
                threshold = MIRROR_SAMPLE_MAX_THRESHOLD - 1;
            } else if (entry->rate <= (MIRROR_SAMPLE_MAX_THRESHOLD - 1)) {
                threshold = MIRROR_SAMPLE_MAX_THRESHOLD / entry->rate;
            } else {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        } else if (entry->rate == 0) {
            threshold = 0;
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, SAMPLE_ING_FLEX_RATEs,
                                   threshold));
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_POOL_COUNT_ENABLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, SAMPLE_ING_FLEX_POOLs,
                                   entry->pool_count_enable));
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_SAMPLE_COUNT_ENABLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, SAMPLE_ING_FLEX_COUNTERs,
                                   entry->sample_count_enable));
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_TRACE_ENABLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, SAMPLE_ING_FLEX_TRACE_EVENTs,
                                   entry->trace_enable));
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_MIRROR_MODE) {
        const char *mode;

        switch (entry->mirror_mode) {
            case bcmintSampleMirrorModeNone:
                mode = DO_NOT_MODIFYs;
                break;
            case bcmintSampleMirrorModeBelowRate:
                mode = SAMPLER_IS_BELOW_RATEs;
                break;
            case bcmintSampleMirrorModeAboveRate:
                mode = SAMPLER_IS_ABOVE_RATEs;
                break;
            default:
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(eh, SAMPLE_ING_FLEX_MIRROR_MODEs,
                                          mode));
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_SESSION_ID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, SAMPLE_ING_FLEX_MIRROR_SESSION_IDs,
                                   entry->session_id));
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_INSTANCE_ID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, SAMPLE_ING_FLEX_MIRROR_INSTANCE_IDs,
                                   entry->instance_id));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mirror sample entry fields.
 *
 * \param [in] unit Unit number.
 * \param [in] eh Entry handle.
 * \param [in|out] entry Sample entry.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sample_entry_fields_get(int unit, bcmlt_entry_handle_t eh,
                               bcmint_mirror_sample_profile_t *entry)
{
    uint64_t value = 0;
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_ENABLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, SAMPLE_ING_FLEXs, &value));
        entry->enable = (bool)value;
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_RATE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, SAMPLE_ING_FLEX_RATEs, &value));
        if (value) {
            entry->rate = MIRROR_SAMPLE_MAX_THRESHOLD / value;
        } else {
            entry->rate = 0;
        }
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_POOL_COUNT_ENABLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, SAMPLE_ING_FLEX_POOLs, &value));
        entry->pool_count_enable = (bool)value;
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_SAMPLE_COUNT_ENABLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, SAMPLE_ING_FLEX_COUNTERs, &value));
        entry->sample_count_enable = (bool)value;
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_TRACE_ENABLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, SAMPLE_ING_FLEX_TRACE_EVENTs, &value));
        entry->trace_enable = (bool)value;
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_MIRROR_MODE) {
        const char *mode;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(eh, SAMPLE_ING_FLEX_MIRROR_MODEs,
                                          &mode));
        if (sal_strcmp(DO_NOT_MODIFYs, mode) == 0) {
            entry->mirror_mode = bcmintSampleMirrorModeNone;
        } else if (sal_strcmp(SAMPLER_IS_BELOW_RATEs, mode) == 0) {
            entry->mirror_mode = bcmintSampleMirrorModeBelowRate;
        } else if (sal_strcmp(SAMPLER_IS_ABOVE_RATEs, mode) == 0) {
            entry->mirror_mode = bcmintSampleMirrorModeAboveRate;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_SESSION_ID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, SAMPLE_ING_FLEX_MIRROR_SESSION_IDs,
                                   &value));
        entry->session_id = (int)value;
    }

    if (entry->fld_bmp & BCMINT_MIRROR_SAMPLE_PRF_FLD_INSTANCE_ID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, SAMPLE_ING_FLEX_MIRROR_INSTANCE_IDs,
                                   &value));
        entry->instance_id = (int)value;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set sample mirroring enable on sample profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Sample type.
 * \param [in] profile_id Sample profile id.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status of container.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_sample_enable_set(int unit, bcmint_mirror_sample_type_t type,
                         int profile_id, int mc_bmp,
                         int enable, int *idx)
{
    bcmint_mirror_sample_profile_t entry;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);
    sal_memset(&entry, 0, sizeof(entry));

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (mc_bmp & (1 << i)) {
            if (enable & (1 << i)) {
                entry.session_id = i;
                entry.instance_id = idx[i];
                break;
            } else {
                entry.session_id = 0;
                entry.instance_id = 0;
                break;
            }
        }
    }
    entry.fld_bmp = BCMINT_MIRROR_SAMPLE_PRF_FLD_SESSION_ID |
                    BCMINT_MIRROR_SAMPLE_PRF_FLD_INSTANCE_ID;

    /* Set the keys of sample entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_entry_keys_set(unit, type, profile_id, &eh));

    /* Set the fields of sample entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_entry_fields_set(unit, eh, &entry));

    /* Set the entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sample mirroring enable on sample profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Sample type.
 * \param [in] profile_id Sample profile id.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_sample_enable_get(int unit, bcmint_mirror_sample_type_t type,
                         int profile_id,
                         int *enable, int *idx)
{
    bcmint_mirror_sample_profile_t entry;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);
    sal_memset(&entry, 0, sizeof(entry));

    entry.fld_bmp = BCMINT_MIRROR_SAMPLE_PRF_FLD_SESSION_ID |
                    BCMINT_MIRROR_SAMPLE_PRF_FLD_INSTANCE_ID;

    /* Set the keys of sample entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_entry_keys_set(unit, type, profile_id, &eh));

    /* Lookup the entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    /* Get the fields of sample entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_entry_fields_get(unit, eh, &entry));

    *enable = 1 << entry.session_id;
    if (entry.session_id >= MIRROR_CONTAINER_NUM_MAX) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_CONFIG);
    }
    idx[entry.session_id] = entry.instance_id;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set sample profile entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Sample type.
 * \param [in] profile_id Sample profile id.
 * \param [in] profile Sample profile entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_sample_profile_set(int unit, bcmint_mirror_sample_type_t type,
                          int profile_id,
                          bcm_mirror_sample_profile_t *profile)
{
    bcmint_mirror_sample_profile_t entry;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    sal_memset(&entry, 0, sizeof(entry));

    entry.fld_bmp |= BCMINT_MIRROR_SAMPLE_PRF_FLD_ENABLE;
    entry.enable = profile->enable;

    entry.fld_bmp |= BCMINT_MIRROR_SAMPLE_PRF_FLD_RATE;
    entry.rate = profile->rate;

    entry.fld_bmp |= BCMINT_MIRROR_SAMPLE_PRF_FLD_TRACE_ENABLE;
    entry.trace_enable = profile->trace_enable;

    entry.fld_bmp |= BCMINT_MIRROR_SAMPLE_PRF_FLD_MIRROR_MODE;
    entry.mirror_mode = profile->mirror_mode;

    entry.fld_bmp |= BCMINT_MIRROR_SAMPLE_PRF_FLD_POOL_COUNT_ENABLE;
    entry.pool_count_enable = profile->pool_count_enable;

    entry.fld_bmp |= BCMINT_MIRROR_SAMPLE_PRF_FLD_SAMPLE_COUNT_ENABLE;
    entry.sample_count_enable = profile->sample_count_enable;

    /* Set the keys of sample entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_entry_keys_set(unit, type, profile_id, &eh));

    /* Set the fields of sample entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_entry_fields_set(unit, eh, &entry));

    /* Set the entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sample profile entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Sample type.
 * \param [in] profile_id Sample profile id.
 * \param [out] profile Sample profile entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_sample_profile_get(int unit, bcmint_mirror_sample_type_t type,
                          int profile_id,
                          bcm_mirror_sample_profile_t *profile)
{
    bcmint_mirror_sample_profile_t entry;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    sal_memset(&entry, 0, sizeof(entry));

    /* Set the keys of sample entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_entry_keys_set(unit, type, profile_id, &eh));

    /* Lookup the entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    entry.fld_bmp |= BCMINT_MIRROR_SAMPLE_PRF_FLD_ENABLE |
                     BCMINT_MIRROR_SAMPLE_PRF_FLD_RATE |
                     BCMINT_MIRROR_SAMPLE_PRF_FLD_POOL_COUNT_ENABLE |
                     BCMINT_MIRROR_SAMPLE_PRF_FLD_SAMPLE_COUNT_ENABLE |
                     BCMINT_MIRROR_SAMPLE_PRF_FLD_TRACE_ENABLE |
                     BCMINT_MIRROR_SAMPLE_PRF_FLD_MIRROR_MODE;

    /* Get the fields of sample entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_entry_fields_get(unit, eh, &entry));

    profile->enable = entry.enable;
    profile->rate = entry.rate;
    profile->pool_count_enable= entry.pool_count_enable;
    profile->sample_count_enable = entry.sample_count_enable;
    profile->trace_enable = entry.trace_enable;
    profile->mirror_mode = entry.mirror_mode;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Attach counter entries to a sample type.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Sample type.
 * \param [in] stat_counter_id Counter id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_sample_stat_attach(int unit, bcmint_mirror_sample_type_t type,
                          uint32_t stat_counter_id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {CTR_ING_FLEX_POOL_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {NULL, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};
    bcm_flexctr_source_t source;

    SHR_FUNC_ENTER(unit);

    /* Get counter info. */
    SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_flexctr_counter_id_info_get(unit,
                                                   stat_counter_id,
                                                   &counter_info));
    source = counter_info.act_cfg.source;

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    switch (type) {
        case bcmintMirrorSampleIngress:
            field[0].u.val = 0;
            if (source == bcmFlexctrSourceIngSamplePool) {
                field[1].fld_name = SAMPLE_ING_FLEX_POOL_ACTIONs;
            } else if (source == bcmFlexctrSourceIngSampleCount) {
                field[1].fld_name = SAMPLE_ING_FLEX_CTR_ACTIONs;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            field[1].u.val = counter_info.action_index;
            break;
        case bcmintMirrorSampleFlex:
            field[0].u.val = 1;
            if (source == bcmFlexctrSourceFlexSamplePool) {
                field[1].fld_name = SAMPLE_ING_FLEX_POOL_ACTIONs;
            } else if (source == bcmFlexctrSourceFlexSampleCount) {
                field[1].fld_name = SAMPLE_ING_FLEX_CTR_ACTIONs;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            field[1].u.val = counter_info.action_index;
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_SFLOW_CONTROLs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Detach counter entries from a sample type.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Sample type.
 * \param [in] stat_counter_id Counter id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_sample_stat_detach(int unit, bcmint_mirror_sample_type_t type,
                          uint32_t stat_counter_id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {CTR_ING_FLEX_POOL_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {SAMPLE_ING_FLEX_POOL_ACTIONs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SAMPLE_ING_FLEX_CTR_ACTIONs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};
    bcm_flexctr_source_t source;

    SHR_FUNC_ENTER(unit);

    /* Get counter info. */
    SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_flexctr_counter_id_info_get(unit,
                                                   stat_counter_id,
                                                   &counter_info));
    source = counter_info.act_cfg.source;

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    switch (type) {
        case bcmintMirrorSampleIngress:
            field[0].u.val = 0;
            if (source != bcmFlexctrSourceIngSamplePool &&
                source != bcmFlexctrSourceIngSampleCount) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            break;
        case bcmintMirrorSampleFlex:
            field[0].u.val = 1;
            if (source != bcmFlexctrSourceFlexSamplePool &&
                source != bcmFlexctrSourceFlexSampleCount) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit, MIRROR_SFLOW_CONTROLs, &lt_entry,
                           NULL, NULL));

    /* Current flex counter action is not the detached one. */
    if (counter_info.action_index != field[1].u.val &&
        counter_info.action_index != field[2].u.val) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    switch (source) {
        case bcmFlexctrSourceIngSamplePool:
        case bcmFlexctrSourceFlexSamplePool:
            field[1].flags = BCMI_LT_FIELD_F_SET;
            field[1].u.val = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
            break;
        case bcmFlexctrSourceIngSampleCount:
        case bcmFlexctrSourceFlexSampleCount:
            field[2].flags = BCMI_LT_FIELD_F_SET;
            field[2].u.val = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_SFLOW_CONTROLs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set mirror global truncate.
 *
 * \param [in] unit Unit Number.
 * \param [in] truncate Mirror global truncate pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_global_truncate_set(int unit, bcm_mirror_global_truncate_t *truncate)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TRUNCATE_ACTIONs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_TRUNCATE_LENGTH_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(truncate, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].flags |= BCMI_LT_FIELD_F_SYMBOL;
    if (truncate->mode == bcmMirrorTruncateDefault) {
        field[0].u.sym_val = TRUNCATEs;
    } else if (truncate->mode == bcmMirrorTruncateAdjustment) {
        field[0].u.sym_val = TRUNCATE_ADJUSTs;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    field[1].u.val = truncate->profile_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mirror global truncate.
 *
 * \param [in] unit Unit Number.
 * \param [out] truncate Mirror global truncate pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_global_truncate_get(int unit, bcm_mirror_global_truncate_t *truncate)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TRUNCATE_ACTIONs, BCMI_LT_FIELD_F_GET |
                                 BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*1*/ {MIRROR_TRUNCATE_LENGTH_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    int rv;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(truncate, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        truncate->mode = bcmMirrorTruncateDefault;
        SHR_EXIT();
    } else if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }

    if(sal_strcmp(field[0].u.sym_val, TRUNCATEs) == 0) {
        truncate->mode = bcmMirrorTruncateDefault;
    } else if (sal_strcmp(field[0].u.sym_val, TRUNCATE_ADJUSTs) == 0) {
        truncate->mode = bcmMirrorTruncateAdjustment;
    }
    truncate->profile_id = field[1].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set truncate length profile table.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Profile id.
 * \param [in] profile Profile entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_truncate_length_profile_table_set(int unit, int id,
    bcm_mirror_truncate_length_profile_t *profile)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_TRUNCATE_LENGTH_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TRUNCATE_LENGTHs, 0, 0, {0}},
        /*2*/ {TRUNCATE_ACTIONs, 0, 0, {0}},
        /*3*/ {TRUNCATEs, 0, 0, {0}},
        /*4*/ {CELL_TRUNCATEs, 0, 0, {0}},
        /*5*/ {CELL_TRUNCATE_LENGTHs, 0, 0, {0}},
        /*6*/ {CELL_TRUNCATE_LENGTH_SRCs, 0, 0, {0}},
        /*7*/ {TRUNCATE_ZONEs, 0, 0, {0}},
    };
    int rv, i;
    bcmlt_field_def_t fld_def;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    /* Only set valid fields. */
    for (i = 1; i < lt_entry.nfields; i++) {
        rv = bcmi_lt_field_def_get(unit,
                                   MIRROR_TRUNCATE_LENGTHs,
                                   field[i].fld_name,
                                   &fld_def);
        if (SHR_SUCCESS(rv)) {
            if (i == 2 || i == 7) {
                field[i].flags |= BCMI_LT_FIELD_F_SYMBOL;
            }
            field[i].flags |= BCMI_LT_FIELD_F_SET;
        }
    }

    field[0].u.val = id;
    field[1].u.val = profile->adjustment_length;
    field[2].u.sym_val = TRUNCATEs;
    field[4].u.val = 0;
    field[7].u.sym_val = ALL_ZONESs;

    if (field[3].flags & BCMI_LT_FIELD_F_SET) {
        /* TRUNCATEs */
        field[3].u.val = 1;
    }

    switch (profile->mode) {
        case bcmMirrorTruncateDefault:
            field[1].u.val = 0;
            field[2].u.sym_val = TRUNCATEs;
            break;
        case bcmMirrorTruncateAdjustment:
            field[1].u.val = profile->adjustment_length;
            field[2].u.sym_val = TRUNCATE_ADJUSTs;
            field[7].u.sym_val = ALL_ZONESs;
            break;
        case bcmMirrorTruncateAdjustFromL2Encap:
            field[1].u.val = profile->adjustment_length;
            field[2].u.sym_val = TRUNCATE_ADJUSTs;
            field[7].u.sym_val = ZONE_1s;
            break;
        case bcmMirrorTruncateAdjustFromL3L4Encap:
            field[1].u.val = profile->adjustment_length;
            field[2].u.sym_val = TRUNCATE_ADJUSTs;
            field[7].u.sym_val = ZONE_2s;
            break;
        case bcmMirrorTruncateAdjustFromL2:
            field[1].u.val = profile->adjustment_length;
            field[2].u.sym_val = TRUNCATE_ADJUSTs;
            field[7].u.sym_val = ZONE_3s;
            break;
        case bcmMirrorTruncateAdjustFromL3L4:
            field[1].u.val = profile->adjustment_length;
            field[2].u.sym_val = TRUNCATE_ADJUSTs;
            field[7].u.sym_val = ZONE_4s;
            break;
        case bcmMirrorTruncateToMultipleOf64:
            field[4].u.val = 1;
            field[5].u.val = profile->adjustment_length;
            field[6].u.val = 0;
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_TRUNCATE_LENGTHs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete truncate length profile table.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Profile id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_truncate_length_profile_table_delete(int unit, int id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_TRUNCATE_LENGTH_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_TRUNCATE_LENGTHs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get truncate length profile table.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Profile id.
 * \param [out] profile Profile entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_truncate_length_profile_table_get(int unit, int id,
    bcm_mirror_truncate_length_profile_t *profile)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_TRUNCATE_LENGTH_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TRUNCATE_LENGTHs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {TRUNCATE_ACTIONs, 0, 0, {0}},
        /*3*/ {TRUNCATEs, 0, 0, {0}},
        /*4*/ {CELL_TRUNCATEs, 0, 0, {0}},
        /*5*/ {CELL_TRUNCATE_LENGTHs, 0, 0, {0}},
        /*6*/ {CELL_TRUNCATE_LENGTH_SRCs, 0, 0, {0}},
        /*7*/ {TRUNCATE_ZONEs, 0, 0, {0}},
    };
    int rv, i;
    bcmlt_field_def_t fld_def;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    /* Only get valid fields. */
    for (i = 1; i < lt_entry.nfields; i++) {
        rv = bcmi_lt_field_def_get(unit,
                                   MIRROR_TRUNCATE_LENGTHs,
                                   field[i].fld_name,
                                   &fld_def);
        if (SHR_SUCCESS(rv)) {
            if (i == 2 || i == 7) {
                field[i].flags |= BCMI_LT_FIELD_F_SYMBOL;
            }
            field[i].flags |= BCMI_LT_FIELD_F_GET;
        }
    }

    field[0].u.val = id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit, MIRROR_TRUNCATE_LENGTHs, &lt_entry,
                           NULL, NULL));

    profile->adjustment_length = field[1].u.val;

    if ((field[4].flags & BCMI_LT_FIELD_F_GET) &&
        (field[6].flags & BCMI_LT_FIELD_F_GET) &&
        (field[4].u.val == 1) &&
        (field[6].u.val == 1)) {
        /* Not valid */
    } else if ((field[4].flags & BCMI_LT_FIELD_F_GET) &&
               (field[6].flags & BCMI_LT_FIELD_F_GET) &&
               (field[4].u.val == 1) &&
               (field[6].u.val == 0)) {
        profile->adjustment_length = field[5].u.val;
        profile->mode = bcmMirrorTruncateToMultipleOf64;
    } else {
        if (field[2].u.sym_val) {
            if(sal_strcmp(field[2].u.sym_val, TRUNCATEs) == 0) {
                profile->mode = bcmMirrorTruncateDefault;
            } else if (sal_strcmp(field[2].u.sym_val,
                                  TRUNCATE_ADJUSTs) == 0) {
                if(sal_strcmp(field[7].u.sym_val, ALL_ZONESs) == 0) {
                    profile->mode = bcmMirrorTruncateAdjustment;
                } else if (sal_strcmp(field[7].u.sym_val,
                                      ZONE_1s) == 0) {
                    profile->mode = bcmMirrorTruncateAdjustFromL2Encap;
                } else if (sal_strcmp(field[7].u.sym_val,
                                      ZONE_2s) == 0) {
                    profile->mode = bcmMirrorTruncateAdjustFromL3L4Encap;
                } else if (sal_strcmp(field[7].u.sym_val,
                                      ZONE_3s) == 0) {
                    profile->mode = bcmMirrorTruncateAdjustFromL2;
                } else if (sal_strcmp(field[7].u.sym_val,
                                      ZONE_4s) == 0) {
                    profile->mode = bcmMirrorTruncateAdjustFromL3L4;
                }
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Allocate a truncate length profile id.
 *
 * \param [in] unit Unit Number.
 * \param [out] id Profile id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_truncate_length_profile_id_alloc(int unit, int *id)
{
    int i, size;
    SHR_BITDCL *bitmap = NULL;
    SHR_FUNC_ENTER(unit);

    bitmap = MIRROR_TRUNCATE_LENGTH_PRF_BMP(unit);
    size = MIRROR_TRUNCATE_LENGTH_PRF_NUM(unit);
    SHR_NULL_CHECK(bitmap, SHR_E_INIT);

    for (i = 0; i < size; i++) {
        if (!SHR_BITGET(bitmap, i)) {
            break;
        }
    }

    if (i >= size) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }
    *id = i;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Hold a truncate length profile id.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Profile id.
 */
static void
mirror_truncate_length_profile_id_hold(int unit, int id)
{
    if (id >= MIRROR_TRUNCATE_LENGTH_PRF_NUM(unit)) {
        return;
    }
    MIRROR_TRUNCATE_LENGTH_PRF_BMP_USED_SET(unit, id);
    return;
}

/*!
 * \brief Free a truncate length profile id.
 *
 * \param [in] unit Unit Number.
 * \param [out] id Profile id.
 */
static void
mirror_truncate_length_profile_id_free(int unit, int id)
{
    if (id >= MIRROR_TRUNCATE_LENGTH_PRF_NUM(unit)) {
        return;
    }
    MIRROR_TRUNCATE_LENGTH_PRF_BMP_USED_CLR(unit, id);
    return;
}

/*!
 * \brief Create a truncate length profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] options Options flags.
 * \param [inout] profile_id Profile id.
 * \param [in] profile Profile entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_truncate_length_profile_create(int unit, uint32_t options,
    int *profile_id,
    bcm_mirror_truncate_length_profile_t *profile)
{
    int id;
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(profile_id, SHR_E_PARAM);
    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    if (options & BCM_MIRROR_TRUNCATE_LENGTH_PROFILE_OPTIONS_WITH_ID) {
        id = *profile_id;
        MIRROR_TRUNCATE_LENGTH_PRF_ID_CHECK(unit, id);

        if (MIRROR_TRUNCATE_LENGTH_PRF_BMP_USED_GET(unit, id) &&
            !(options &
              BCM_MIRROR_TRUNCATE_LENGTH_PROFILE_OPTIONS_REPLACE)) {
            SHR_ERR_EXIT(SHR_E_EXISTS);
        }

        /* Mark profile id is used. */
        mirror_truncate_length_profile_id_hold(unit, id);
    } else {
        /* Allocate profile id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_truncate_length_profile_id_alloc(unit, &id));

        /* Mark profile id is used. */
        mirror_truncate_length_profile_id_hold(unit, id);
        *profile_id = id;
    }

    /* Program profile table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_truncate_length_profile_table_set(unit, id, profile));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a truncate length profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id Profile id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_truncate_length_profile_destroy(int unit, int profile_id)
{
    SHR_FUNC_ENTER(unit);

    MIRROR_TRUNCATE_LENGTH_PRF_ID_CHECK(unit, profile_id);

    if (!MIRROR_TRUNCATE_LENGTH_PRF_BMP_USED_GET(unit, profile_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* Delete profile table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_truncate_length_profile_table_delete(unit, profile_id));

    /* Free profile id. */
    mirror_truncate_length_profile_id_free(unit, profile_id);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get a truncate length profile with given profile id.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id Profile id.
 * \param [out] profile Profile entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_truncate_length_profile_get(int unit, int profile_id,
    bcm_mirror_truncate_length_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    MIRROR_TRUNCATE_LENGTH_PRF_ID_CHECK(unit, profile_id);

    if (!MIRROR_TRUNCATE_LENGTH_PRF_BMP_USED_GET(unit, profile_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* Lookup profile table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_truncate_length_profile_table_get(unit,
                                                      profile_id,
                                                      profile));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover mirror sequence number profile.
 *
 * \param [in]  unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_seq_num_prof_recover(int unit)
{
    int idx, encap_id;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv, i;
    uint32_t ref_cnt = 0;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MIRROR_EGR_SEQs, &entry_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, MIRROR_ENCAP_IDs, &data));
        encap_id = data;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                                   TNL_ENCAP_SEQUENCE_PROFILE_IDs,
                                   &data));
        idx = data;

        /* Get encap profile ref_cnt. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_get(unit,
                                             BCMI_LTSW_PROFILE_MIRROR_ENCAP,
                                             encap_id,
                                             &ref_cnt));

        for (i = 0; i < ref_cnt; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_tunnel_encap_seq_profile_recover(unit, idx));
        }
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get field value from MIRROR_CONTROL LT.
 *
 * \param [in] unit Unit number.
 * \param [in] fld_name Field name.
 * \param [out] val Field value.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_mirror_control_table_get(
    int unit,
    const char *fld_name,
    int *val)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field;
    bcmlt_field_def_t fld_def;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmi_lt_field_def_get(unit, MIRROR_CONTROLs, fld_name, &fld_def));

    lt_entry.fields = &field;
    lt_entry.nfields = 1;
    lt_entry.attr = 0;

    sal_memset(&field, 0, sizeof(field));
    field.fld_name = fld_name;
    field.flags = BCMI_LT_FIELD_F_GET;
    if (fld_def.symbol) {
        field.flags |= BCMI_LT_FIELD_F_SYMBOL;
    }

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_get(unit, MIRROR_CONTROLs, &lt_entry, NULL, NULL));

    if (!sal_strcmp(fld_name, MIRROR_DUPLICATEs)) {
        *val = field.u.val;
    } else {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set field value to MIRROR_CONTROL LT.
 *
 * \param [in] unit Unit number.
 * \param [in] fld_name Field name.
 * \param [in] val Field value.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_mirror_control_table_set(
    int unit,
    const char *fld_name,
    int val)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field;
    bcmlt_field_def_t fld_def;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmi_lt_field_def_get(unit, MIRROR_CONTROLs, fld_name, &fld_def));

    lt_entry.fields = &field;
    lt_entry.nfields = 1;
    lt_entry.attr = 0;

    sal_memset(&field, 0, sizeof(field));
    field.fld_name = fld_name;
    field.flags = BCMI_LT_FIELD_F_SET;
    if (fld_def.symbol) {
        field.flags |= BCMI_LT_FIELD_F_SYMBOL;
    }

    if (!sal_strcmp(fld_name, MIRROR_DUPLICATEs)) {
        field.u.val = val;
    } else {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}



/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_mirror_db_set(
    int unit,
    const bcmint_mirror_db_t *db)
{
    xfs_mirror_db[unit] = db;
    return SHR_E_NONE;
}

int
xfs_ltsw_mirror_init(int unit)
{
    bcmi_ltsw_profile_hdl_t profile_hdl;
    uint64_t idx_min_data = 0LL, idx_max_data = 0LL;
    int idx_min, idx_max, index;
    uint32_t size = 0;
    int warm = bcmi_warmboot_get(unit);
    mirror_encap_profile_entry_t entry;
    void *ptr = NULL, *ptr1 = NULL;
    int rv;

    SHR_FUNC_ENTER(unit);

    profile_hdl = BCMI_LTSW_PROFILE_MIRROR_ENCAP;

    rv = bcmi_ltsw_profile_unregister(unit, profile_hdl);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       MIRROR_ENCAP_INSTANCEs,
                                       MIRROR_ENCAP_IDs,
                                       &idx_min_data,
                                       &idx_max_data));
    idx_min = (int)idx_min_data;
    idx_max = (int)idx_max_data;
    if (idx_max - idx_min < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit,
                                    &profile_hdl,
                                    &idx_min,
                                    &idx_max,
                                    1,
                                    mirror_encap_profile_hash_cb,
                                    mirror_encap_profile_cmp_cb));

    size = idx_max - idx_min + 1;
    size *= sizeof(mirror_encap_type);
    /*
     * Save encap type in HA for the benefit of:
     * 1. Recover encap profile hash data during wb.
     * 2. Recover mirror destination during wb.
     */
    ptr = bcmi_ltsw_ha_mem_alloc(unit,
                                 BCMI_HA_COMP_ID_MIRROR,
                                 BCMINT_MIRROR_SUB_COMP_ID_MIRROR_ENCAP_TYPE,
                                 "bcmMirrorEncapType",
                                 &size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);
    mirror_encap_info[unit].type = ptr;

    if (!warm) {
        sal_memset(ptr, 0, size);
        SHR_IF_ERR_EXIT
            (mirror_encap_profile_clear(unit));

        /* Reserve one entry for non-encap usage. */
        sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_profile_entry_add(unit, &entry, &index));
        if (index != 0) {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
    } else {
        /* Recover ref_cnt for default entry. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit,
                                                  profile_hdl,
                                                  1, 0, 1));

        /* Recover ref_cnt for encap profile entries. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_profile_recover(unit));
    }

    /* Init sample profile table.*/
    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MIRROR_SFLOWs));
    }

    /* Init mirror sequence number profile. */
    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MIRROR_EGR_SEQs));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_seq_num_prof_recover(unit));
    }

    /* Get length profile id range. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       MIRROR_TRUNCATE_LENGTHs,
                                       MIRROR_TRUNCATE_LENGTH_IDs,
                                       &idx_min_data,
                                       &idx_max_data));
    idx_min = (int)idx_min_data;
    idx_max = (int)idx_max_data;
    if (idx_max - idx_min < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* HA for truncate length profile id used bitmap. */
    mirror_truncate_info[unit].length_prf_num = idx_max - idx_min + 1;
    size = SHR_BITALLOCSIZE(idx_max - idx_min + 1);
    ptr1 = bcmi_ltsw_ha_mem_alloc(unit,
              BCMI_HA_COMP_ID_MIRROR,
              BCMINT_MIRROR_SUB_COMP_ID_MIRROR_TRUNCATE_LENGTH_PRF_ID_BMP,
              "bcmMirrorTruncateLengthPrfBmp",
              &size);
    SHR_NULL_CHECK(ptr1, SHR_E_MEMORY);
    mirror_truncate_info[unit].length_prf_bmp = ptr1;
    if (!warm) {
        sal_memset(ptr1, 0, size);
    }

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sampler_seed_init(unit));
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (!warm && ptr) {
            (void)bcmi_ltsw_ha_mem_free(unit, ptr);
            mirror_encap_info[unit].type = NULL;
        }

        if (!warm && ptr1) {
            (void)bcmi_ltsw_ha_mem_free(unit, ptr1);
            mirror_truncate_info[unit].length_prf_bmp = NULL;
        }
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_deinit(int unit)
{
    int rv;
    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_unregister(unit, BCMI_LTSW_PROFILE_MIRROR_ENCAP);
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_encap_add(
    int unit,
    bool egr,
    bcm_mirror_destination_t *mirror_dest,
    int *index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_add(unit, egr, mirror_dest, index));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_encap_delete(
    int unit,
    bcm_mirror_destination_t *mirror_dest,
    int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_delete(unit, mirror_dest, index));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_encap_get(
    int unit,
    int index,
    bcm_mirror_destination_t *mirror_dest)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_get(unit, index, mirror_dest));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_session_add(
    int unit,
    int session_id,
    bcmint_mirror_session_entry_t *session)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_session_table_add(unit, session_id, session));

    /* Insert Mirror counter LT together with mirror session table. */
    (void)mirror_session_stat_table_insert(unit, session_id);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_session_cpu_queue_enable(unit, session_id, session));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_session_delete(
    int unit,
    int session_id,
    bool egr,
    bool cosq_mod)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_session_cpu_queue_disable(unit, session_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_session_table_delete(unit, session_id));

    /* Delete Mirror counter LT. */
    (void)mirror_session_stat_table_delete(unit, session_id);
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_session_get(
    int unit,
    int session_id,
    bcmint_mirror_session_entry_t *session)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_session_table_get(unit, session_id, session));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_session_stat_get(
    int unit,
    int session_id,
    bool sync,
    uint64_t *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_session_stat_table_get(unit, session_id, sync, value));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_session_stat_set(
    int unit,
    int session_id,
    uint64_t value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_session_stat_table_set(unit, session_id, value));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_enable_get(
    int unit,
    bcmint_mirror_source_t *source,
    int *enable,
    int *instance_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(source, SHR_E_PARAM);

    switch (source->type) {
        case BCMINT_MIRROR_ST_F_PORT_ING:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_port_enable_ingress_get(unit,
                                                source->port,
                                                enable,
                                                instance_id));
            break;
        case BCMINT_MIRROR_ST_F_PORT_EGR:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_port_enable_egress_get(unit,
                                               source->port,
                                               enable,
                                               instance_id));
            break;
        case BCMINT_MIRROR_ST_F_VP_ING:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_port_mirror_ctrl_get(unit,
                                                        source->port,
                                                        enable,
                                                        instance_id));
            break;
        case BCMINT_MIRROR_ST_F_TRACE_EVENT:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_trace_event_enable_ingress_get(unit,
                                                       source->trace_event,
                                                       enable,
                                                       instance_id));
            break;
        case BCMINT_MIRROR_ST_F_DROP_EVENT:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_drop_event_enable_ingress_get(unit,
                                                      source->drop_event,
                                                      enable,
                                                      instance_id));
            break;
        case BCMINT_MIRROR_ST_F_FP_ING:
        case BCMINT_MIRROR_ST_F_FP_EGR:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_fp_enable_get(unit,
                                      source->type,
                                      source->entry_id,
                                      enable,
                                      instance_id));
            break;
        case BCMINT_MIRROR_ST_F_SAMPLE_INGRESS:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_sample_enable_get(unit, bcmintMirrorSampleIngress,
                                          source->sample_profile_id,
                                          enable,
                                          instance_id));
            break;
        case BCMINT_MIRROR_ST_F_SAMPLE_FLEX:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_sample_enable_get(unit, bcmintMirrorSampleFlex,
                                          source->sample_profile_id,
                                          enable,
                                          instance_id));
            break;
        case BCMINT_MIRROR_ST_F_FIELD_DEST:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_field_destination_enable_get(unit,
                                                     &source->field_dest_match,
                                                     enable,
                                                     instance_id));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_enable_set(
    int unit,
    bcmint_mirror_source_t *source,
    int mc_bmp,
    int enable,
    int *instance_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(source, SHR_E_PARAM);

    switch (source->type) {
        case BCMINT_MIRROR_ST_F_PORT_ING:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_port_enable_ingress_set(unit,
                                                source->port,
                                                mc_bmp,
                                                enable,
                                                instance_id));
            break;
        case BCMINT_MIRROR_ST_F_PORT_EGR:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_port_enable_egress_set(unit,
                                               source->port,
                                               mc_bmp,
                                               enable,
                                               instance_id));
            break;
        case BCMINT_MIRROR_ST_F_VP_ING:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_vp_enable_ingress_set(unit,
                                              source->port,
                                              mc_bmp,
                                              enable,
                                              instance_id));
            break;
        case BCMINT_MIRROR_ST_F_TRACE_EVENT:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_trace_event_enable_ingress_set(unit,
                                                       source->trace_event,
                                                       mc_bmp,
                                                       enable,
                                                       instance_id));
            break;
        case BCMINT_MIRROR_ST_F_DROP_EVENT:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_drop_event_enable_ingress_set(unit,
                                                      source->drop_event,
                                                      mc_bmp,
                                                      enable,
                                                      instance_id));
            break;
        case BCMINT_MIRROR_ST_F_SAMPLE_INGRESS:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_sample_enable_set(unit, bcmintMirrorSampleIngress,
                                          source->sample_profile_id,
                                          mc_bmp,
                                          enable,
                                          instance_id));
            break;
        case BCMINT_MIRROR_ST_F_SAMPLE_FLEX:
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_sample_enable_set(unit, bcmintMirrorSampleFlex,
                                          source->sample_profile_id,
                                          mc_bmp,
                                          enable,
                                          instance_id));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_misc_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Init sample profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_mirror_sample_profile_init(unit));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_misc_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Deinit sample profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_mirror_sample_profile_deinit(unit));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_sample_profile_init(int unit)
{
    int warm = bcmi_warmboot_get(unit);
    SHR_FUNC_ENTER(unit);

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MIRROR_SFLOWs));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_sample_profile_deinit(int unit)
{
    return SHR_E_NONE;
}

int
xfs_ltsw_mirror_egress_sampler_rate_range_max(
    int unit,
    int *range_max)
{
    uint64_t idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(range_max, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, MIRROR_PORT_ENCAP_SFLOWs,
                                       SAMPLE_EGR_RATEs, NULL,
                                       &idx_max));
    *range_max = (int)idx_max;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_sampler_seed_set(
    int unit,
    bcmi_ltsw_mirror_sampler_seed_type_t type,
    int value)
{
    SHR_FUNC_ENTER(unit);

    if (type == bcmiSamplerSeedIngress ||
        type == bcmiSamplerSeedFlex) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sampler_ing_flex_seed_set(unit, type, value));
    } else if (type == bcmiSamplerSeedEgress) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sampler_egr_seed_set(unit, value));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_sampler_seed_get(
    int unit,
    bcmi_ltsw_mirror_sampler_seed_type_t type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    if (type == bcmiSamplerSeedIngress ||
        type == bcmiSamplerSeedFlex) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sampler_ing_flex_seed_get(unit, type, value));
    } else if (type == bcmiSamplerSeedEgress) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sampler_egr_seed_get(unit, value));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_mc_cos_set(
    int unit,
    int mc_cos)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_mc_cos_set(unit, mc_cos));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_mc_cos_get(
    int unit,
    int *mc_cos)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_mc_cos_get(unit, mc_cos));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_cpu_cos_set(
    int unit,
    int cpu_cos)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_cpu_cos_set(unit, cpu_cos));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_cpu_cos_get(
    int unit,
    int *cpu_cos)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_cpu_cos_get(unit, cpu_cos));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_sample_profile_set(
    int unit,
    bcmint_mirror_sample_type_t type,
    int profile_id,
    bcm_mirror_sample_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_profile_set(unit, type, profile_id, profile));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_sample_profile_get(
    int unit,
    bcmint_mirror_sample_type_t type,
    int profile_id,
    bcm_mirror_sample_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_profile_get(unit, type, profile_id, profile));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_sample_stat_attach(
    int unit,
    bcmint_mirror_sample_type_t type,
    uint32_t stat_counter_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_stat_attach(unit, type, stat_counter_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_sample_stat_detach(
    int unit,
    bcmint_mirror_sample_type_t type,
    uint32_t stat_counter_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_stat_detach(unit, type, stat_counter_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_global_truncate_set(
    int unit,
    bcm_mirror_global_truncate_t *global_truncate)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_global_truncate_set(unit, global_truncate));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_global_truncate_get(
    int unit,
    bcm_mirror_global_truncate_t *global_truncate)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_global_truncate_get(unit, global_truncate));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_truncate_length_profile_create(
    int unit,
    uint32_t options,
    int *profile_id,
    bcm_mirror_truncate_length_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_truncate_length_profile_create(unit, options,
                                               profile_id,
                                               profile));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_truncate_length_profile_destroy(
    int unit,
    int profile_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_truncate_length_profile_destroy(unit, profile_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_truncate_length_profile_get(
    int unit,
    int profile_id,
    bcm_mirror_truncate_length_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_truncate_length_profile_get(unit,
                                            profile_id,
                                            profile));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_switch_control_set(
    int unit,
    bcm_switch_control_t type,
    int arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmSwitchMirrorAllowDuplicateMirroredPackets:
            SHR_IF_ERR_EXIT
                (mirror_mirror_control_table_set
                    (unit, MIRROR_DUPLICATEs, arg));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mirror_switch_control_get(
    int unit,
    bcm_switch_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmSwitchMirrorAllowDuplicateMirroredPackets:
            SHR_IF_ERR_EXIT
                (mirror_mirror_control_table_get
                    (unit, MIRROR_DUPLICATEs, arg));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

