/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/ipmc.h>
#include <bcm_int/control.h>
#include <bcm_int/common/multicast.h>
#include <bcm_int/ltsw_dispatch.h>

#include <bcm_int/ltsw/xfs/ipmc.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw/xfs/types.h>
#include <bcm_int/ltsw/multicast.h>
#include <bcm_int/ltsw/ipmc.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/sbr.h>
#include <bcm_int/ltsw/util.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_IPMC

/* Encoding for misc_ctrl_0:
 *      misc_ctrl_0[0:0]: If set, entry is valid;
 *      misc_ctrl_0[1:1]: If set, my_station is hit (applies to L2 HOST table);
 *      misc_ctrl_0[3:2]: Opaque info;
 */
#define L2_MISC_CTRL_0_OPQ_CTRL_ID_MAX (0x3)
#define L2_MISC_CTRL_0_OPQ_CTRL_ID(_c) (((_c) >> 2) & 0x3)
#define L2_MISC_CTRL_0(_opaque) (((_opaque & 0x3) << 2) | 1)

/* Encoding for misc_ctrl_1:
 *      misc_ctrl_1[0:0]: If set, packet discard;
 *      misc_ctrl_1[1:1]: If set, packet copy to CPU;
 *      misc_ctrl_1[3:2]: Unused;
 */
#define L2_MISC_CTRL_1_DISCARD(_c) ((_c) & 0x1)
#define L2_MISC_CTRL_1_COPY_TO_CPU(_c) (((_c) >> 1) & 0x1)
#define L2_MISC_CTRL_1(_discard, _cp2cpu)   \
    (((_discard) & 0x1) | (((_cp2cpu) & 0x1) << 1))

/******************************************************************************
 * Private functions
 */


static const char *dest_type_str[] = BCMI_XFS_DEST_TYPE_STR;


/*!
 * \brief Validate ipmc lookup key for L2 domain.
 *
 * \param [in] unit Unit number.
 * \param [in] data IPMC entry information.
 * \param [out] *src_en Enable/Disable operating on source table.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ipmc_l2_key_validate(int unit, bcm_ipmc_addr_t *data, bool *src_en)
{
    uint32_t vfi = 0;
    uint64_t s_ip6_val[2] = {0};

    SHR_FUNC_ENTER(unit);

    if (data == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *src_en = FALSE;
    if (data->flags & BCM_IPMC_IP6) {
        /* When s_ip is nonzero, operate on SG table. */
        bcmi_ltsw_util_ip6_to_uint64(s_ip6_val, &(data->s_ip6_addr));
        if (s_ip6_val[0] || s_ip6_val[1]) {
            *src_en = TRUE;
        }

        if (!BCM_IP6_MULTICAST(data->mc_ip6_addr)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    } else {
        if (data->s_ip_addr != 0) {
            *src_en = TRUE;
        }

        if (!BCM_IP4_MULTICAST(data->mc_ip_addr)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_idx_get(unit, data->vid, &vfi));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Fill key for LT L2_IPV4/IPV6_MULTICAST_TABLE.
 *
 * \param [in] unit Unit number.
 * \param [in] eh Entry handle.
 * \param [in/out] data IPMC entry information.
 * \param [in] src_en Enable operating on source table.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_l2_multicast_table_key_fill(
    int unit,
    bcmlt_entry_handle_t eh,
    bcm_ipmc_addr_t *data,
    bool src_en)
{
    uint32_t vfi = 0;
    uint64_t ipv6_val[2] = {0};

    SHR_FUNC_ENTER(unit);

    if (data->flags & BCM_IPMC_IP6) {
        if (src_en) {
            bcmi_ltsw_util_ip6_to_uint64(ipv6_val, &(data->s_ip6_addr));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(eh, IPV6_SRC_ADDRs,
                                             0, ipv6_val, 2));
        }
        bcmi_ltsw_util_ip6_to_uint64(ipv6_val, &(data->mc_ip6_addr));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(eh, IPV6_DST_ADDRs, 0, ipv6_val, 2));
    } else {
        if (src_en) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(eh, IPV4_SRC_ADDRs, data->s_ip_addr));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, IPV4_DST_ADDRs, data->mc_ip_addr));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_idx_get(unit, data->vid, &vfi));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, VFIs, vfi));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Fill data for LT L2_IPV4/IPV6_MULTICAST_TABLE.
 *
 * \param [in] unit Unit number.
 * \param [in] eh Entry handle.
 * \param [in/out] data IPMC entry information.
 * \param [in] src_en Enable operating on source table.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_l2_multicast_table_data_fill(
    int unit,
    bcmlt_entry_handle_t eh,
    bcm_ipmc_addr_t *data,
    bool src_en)
{
    int dest, dest_type, discard, cp2cpu;
    int str_prof_idx, used = 0;
    uint64_t val;
    bcmi_ltsw_sbr_profile_tbl_hdl_t tbl_hdl;
    bcm_multicast_t mc = 0;

    SHR_FUNC_ENTER(unit);

    if (data->opaque_ctrl_id > L2_MISC_CTRL_0_OPQ_CTRL_ID_MAX) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (_BCM_MULTICAST_IS_L3(data->group_l2) ||
        _BCM_MULTICAST_IS_VPLS(data->group_l2) ||
        _BCM_MULTICAST_IS_FLOW(data->group_l2)) {
        dest = _BCM_MULTICAST_ID_GET(data->group_l2);
        dest_type = BCMI_XFS_DEST_TYPE_L3MC_GROUP;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_multicast_l3_grp_id_get(unit, dest, &mc));
        if (mc != data->group_l2) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    } else if (_BCM_MULTICAST_IS_L2(data->group_l2)) {
        dest = _BCM_MULTICAST_ID_GET(data->group_l2);
        dest_type = BCMI_XFS_DEST_TYPE_L2MC_GROUP;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_multicast_l2_grp_validate(unit, dest, &used));
        if (!used) {
            SHR_ERR_EXIT(SHR_E_NOT_FOUND);
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, DESTINATIONs, dest));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(eh, DESTINATION_TYPEs,
                                      dest_type_str[dest_type]));

    if (data->flags & BCM_IPMC_IP6) {
        if (src_en) {
            tbl_hdl = BCMI_LTSW_SBR_PTH_L2_IPV6_MULTICAST_SG;
        } else {
            tbl_hdl = BCMI_LTSW_SBR_PTH_L2_IPV6_MULTICAST;
        }
    } else {
        if (src_en) {
            tbl_hdl = BCMI_LTSW_SBR_PTH_L2_IPV4_MULTICAST_SG;
        } else {
            tbl_hdl = BCMI_LTSW_SBR_PTH_L2_IPV4_MULTICAST;
        }
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_sbr_profile_ent_index_get(unit,
                                             tbl_hdl,
                                             BCMI_LTSW_SBR_PET_DEF,
                                             &str_prof_idx));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, STRENGTH_PROFILE_INDEXs, str_prof_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, CLASS_IDs, data->lookup_class));

    val = L2_MISC_CTRL_0(data->opaque_ctrl_id);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, MISC_CTRL_0s, val));

    discard = (data->flags & BCM_IPMC_DISCARD) ? 1 : 0;
    cp2cpu = (data->flags & BCM_IPMC_COPYTOCPU) ? 1 : 0;
    val = L2_MISC_CTRL_1(discard, cp2cpu);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, MISC_CTRL_1s, val));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Key parse for L2_IPV4/IPV6_MULTICAST_TABLE entry.
 *
 * \param [in] unit Unit number.
 * \param [in] eh Entry handle.
 * \param [in/out] data IPMC entry information.
 * \param [in] src_en Enable operating on source table.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_l2_multicast_table_key_parse(
    int unit,
    bcmlt_entry_handle_t eh,
    bcm_ipmc_addr_t *data,
    bool src_en)
{
    uint64_t value = 0;
    uint64_t ipv6_val[2] = {0};
    uint32_t act_cnt = 0;
    int vfi;

    SHR_FUNC_ENTER(unit);

    if (data->flags & BCM_IPMC_IP6) {
        if (src_en) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(eh, IPV6_SRC_ADDRs,
                                             0, ipv6_val, 2, &act_cnt));
            bcmi_ltsw_util_uint64_to_ip6(&(data->s_ip6_addr), ipv6_val);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(eh, IPV6_DST_ADDRs,
                                         0, ipv6_val, 2, &act_cnt));
        bcmi_ltsw_util_uint64_to_ip6(&(data->mc_ip6_addr), ipv6_val);
    } else {
        if (src_en) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(eh, IPV4_SRC_ADDRs, &value));
            data->s_ip_addr = (bcm_ip_t)value;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, IPV4_DST_ADDRs, &value));
        data->mc_ip_addr = (bcm_ip_t)value;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, VFIs, &value));
    vfi = (uint32_t)value;
    /* Transform VFI to VPN/vlan */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vpnid_get(unit, vfi, &(data->vid)));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Data parse for L2_IPV4/IPV6_MULTICAST_TABLE entry.
 *
 * \param [in] unit Unit number.
 * \param [in] eh Entry handle.
 * \param [in/out] data IPMC entry information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_l2_multicast_table_data_parse(
    int unit,
    bcmlt_entry_handle_t eh,
    bcm_ipmc_addr_t *data)
{
    uint64_t value = 0;
    int dest_type, dest;

    SHR_FUNC_ENTER(unit);

    data->flags |= BCM_IPMC_L2;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, CLASS_IDs, &value));
    data->lookup_class = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, DESTINATION_TYPEs, &value));
    dest_type = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, DESTINATIONs, &value));
    dest = (uint32_t)value;

    if (dest_type == BCMI_XFS_DEST_TYPE_L3MC_GROUP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_multicast_l3_grp_id_get(unit, dest, &(data->group_l2)));
    } else {
        _BCM_MULTICAST_GROUP_SET(data->group_l2,
                                 _BCM_MULTICAST_TYPE_L2,
                                 dest);
    }

    SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, MISC_CTRL_0s, &value));
    data->opaque_ctrl_id = L2_MISC_CTRL_0_OPQ_CTRL_ID(value);

    SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, MISC_CTRL_1s, &value));
    data->flags |= L2_MISC_CTRL_1_DISCARD(value) ? BCM_IPMC_DISCARD : 0;
    data->flags |= L2_MISC_CTRL_1_COPY_TO_CPU(value) ? BCM_IPMC_COPYTOCPU : 0;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check whether L2_IPV4/IPV6_MULTICAST_TABLE entry existed.
 *
 * \param [in] unit Unit number.
 * \param [in/out] data IPMC entry information.
 * \param [in] src_en Enable operating on source table.
 *
 * \retval SHR_E_NONE Existed.
 * \retval SHE_E_NOT_FOUND Not existed.
 */
static int
lt_l2_multicast_table_exist(
    int unit,
    bcm_ipmc_addr_t *data,
    bool src_en)
{
    int dunit;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    const char *lt_name;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (data->flags & BCM_IPMC_IP6) {
        if (src_en) {
            lt_name = L2_IPV6_MULTICAST_SG_TABLEs;
        } else {
            lt_name = L2_IPV6_MULTICAST_TABLEs;
        }
    } else {
        if (src_en) {
            lt_name = L2_IPV4_MULTICAST_SG_TABLEs;
        } else {
            lt_name = L2_IPV4_MULTICAST_TABLEs;
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &eh));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_l2_multicast_table_key_fill(unit, eh, data, src_en));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit,
                                  eh,
                                  BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}
/*!
 * \brief Operate on LT L2_IPV4/IPV6_MULTICAST_TABLE.
 *
 * \param [in] unit Unit number.
 * \param [in] opcode Operation code.
 * \param [in] data IPMC entry information.
 * \param [in] src_en Enable source table.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_l2_multicast_table_op(
    int unit,
    bcmlt_opcode_t opcode,
    bcm_ipmc_addr_t *data,
    bool src_en)
{
    int dunit;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    const char *lt_name;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (data->flags & BCM_IPMC_IP6) {
        if (src_en) {
            lt_name = L2_IPV6_MULTICAST_SG_TABLEs;
        } else {
            lt_name = L2_IPV6_MULTICAST_TABLEs;
        }
    } else {
        if (src_en) {
            lt_name = L2_IPV4_MULTICAST_SG_TABLEs;
        } else {
            lt_name = L2_IPV4_MULTICAST_TABLEs;
        }
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &eh));

    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_l2_multicast_table_key_fill(unit, eh, data, src_en));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, eh, opcode, BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_l2_multicast_table_data_parse(unit, eh, data));
        break;
    case BCMLT_OPCODE_UPDATE:
    case BCMLT_OPCODE_INSERT:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_l2_multicast_table_key_fill(unit, eh, data, src_en));
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_l2_multicast_table_data_fill(unit, eh, data, src_en));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, eh, opcode, BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_l2_multicast_table_key_fill(unit, eh, data, src_en));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, eh, opcode, BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all L2_IPV4/IPV6_MULTICAST_TABLE entries.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_l2_ipv4_multicast_table_traverse(
    int unit,
    uint32_t flags,
    bcm_ipmc_traverse_cb cb,
    void *user_data)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    int rv = SHR_E_NONE;
    int rv1 = SHR_E_NONE;
    bcm_ipmc_addr_t data;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (flags & BCM_IPMC_IP6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, L2_IPV6_MULTICAST_TABLEs, &eh));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, L2_IPV4_MULTICAST_TABLEs, &eh));
    }

    rv = bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);

    while (rv == SHR_E_NONE) {
        sal_memset(&data, 0, sizeof(data));
        if (flags & BCM_IPMC_IP6) {
            data.flags = BCM_IPMC_IP6;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_l2_multicast_table_key_parse(unit, eh, &data, FALSE));
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_l2_multicast_table_data_parse(unit, eh, &data));

        /* Traverse to the next entry */
        rv = bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        if (cb) {
            rv1 = cb(unit, &data, user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }

    if ((rv != SHR_E_NOT_FOUND) && SHR_FAILURE(rv)) {
        SHR_IF_ERR_EXIT(rv);
    }

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }

    /* Traverse for the L2_IPV6/IPV4_MULTICAST_SG_TABLE. */
    if (flags & BCM_IPMC_IP6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, L2_IPV6_MULTICAST_SG_TABLEs, &eh));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, L2_IPV4_MULTICAST_SG_TABLEs, &eh));
    }

    rv = bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);

    while (rv == SHR_E_NONE) {

        sal_memset(&data, 0, sizeof(data));
        if (flags & BCM_IPMC_IP6) {
            data.flags = BCM_IPMC_IP6;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_l2_multicast_table_key_parse(unit, eh, &data, TRUE));
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_l2_multicast_table_data_parse(unit, eh, &data));

        /* Traverse to the next entry */
        rv = bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        if (cb) {
            rv1 = cb(unit, &data, user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }

    if ((rv != SHR_E_NOT_FOUND) && SHR_FAILURE(rv)) {
        SHR_IF_ERR_EXIT(rv);
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}



/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_ipmc_init(int unit)
{
    /* No need to do ipmc reinit. */
    return 0;
}

int
xfs_ltsw_ipmc_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_ipmc_delete_all_l2(unit));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_pub_info_get(
    int unit,
    bcmint_ipmc_pub_info_t *mc_pub)
{
    uint32_t width = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
          (bcmi_lt_field_width_get(unit, ING_L3_IIF_TABLEs, RPA_ID_PROFILEs,
                                   &width));

    mc_pub->rp_min = 1;
    mc_pub->rp_max = width - 1;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_add_l2(
    int unit,
    bcm_ipmc_addr_t *data)
{
    int rv;
    bcmlt_opcode_t opcode = BCMLT_OPCODE_INSERT;
    bool src_en = FALSE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ipmc_l2_key_validate(unit, data, &src_en));

    /*
     * If added with BCM_IPMC_REPLACE and entry existed,
     * then SHR_E_EXISTED is returned.
     * If added with BCM_IPMC_REPLACE and entry didn't exist,
     * then a new entry will be created.
     */
    rv = lt_l2_multicast_table_exist(unit, data, src_en);
    if (rv == SHR_E_NONE) {
        if (!(data->flags & BCM_IPMC_REPLACE)) {
            SHR_ERR_EXIT(SHR_E_EXISTS);
        }
        opcode = BCMLT_OPCODE_UPDATE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_l2_multicast_table_op(unit, opcode, data, src_en));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_remove_l2(
    int unit,
    bcm_ipmc_addr_t *data)
{
    bcmlt_opcode_t opcode = BCMLT_OPCODE_DELETE;
    bool src_en = FALSE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ipmc_l2_key_validate(unit, data, &src_en));

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_l2_multicast_table_op(unit, opcode, data, src_en));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_find_l2(
    int unit,
    bcm_ipmc_addr_t *data)
{
    bcmlt_opcode_t opcode = BCMLT_OPCODE_LOOKUP;
    bool src_en = FALSE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ipmc_l2_key_validate(unit, data, &src_en));

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_l2_multicast_table_op(unit, opcode, data, src_en));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_traverse_l2(
    int unit,
    uint32_t flags,
    bcm_ipmc_traverse_cb cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_l2_ipv4_multicast_table_traverse(unit, flags, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ipmc_delete_all_l2(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmi_lt_clear(unit, L2_IPV4_MULTICAST_TABLEs));
    SHR_IF_ERR_EXIT
        (bcmi_lt_clear(unit, L2_IPV6_MULTICAST_TABLEs));

    SHR_IF_ERR_EXIT
        (bcmi_lt_clear(unit, L2_IPV4_MULTICAST_SG_TABLEs));
    SHR_IF_ERR_EXIT
        (bcmi_lt_clear(unit, L2_IPV6_MULTICAST_SG_TABLEs));

exit:
    SHR_FUNC_EXIT();
}

