/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/time.h>

#include <bcm_int/ltsw/xfs/time.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/util.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_TIME

/******************************************************************************
 * Private functions
 */


/* Stage 0 Mode PC_SYNCE_STAGE0_MODE_T. */
#define XFS_TIME_PC_SYNCE_STAGE_0_MODE_STR { \
    PC_SYNCE_STAGE_0_MODE_DIV_NONEs, \
    PC_SYNCE_STAGE_0_MODE_DIV_GAP_CLK_4_OVER_5s, \
    PC_SYNCE_STAGE_0_MODE_SDM_FRAC_DIVs \
}

/* Stage 1 Mode PC_SYNCE_STAGE1_MODE_T. */
#define XFS_TIME_PC_SYNCE_STAGE_1_MODE_STR { \
    PC_SYNCE_STAGE_1_MODE_DIV_NONEs, \
    PC_SYNCE_STAGE_1_MODE_DIV_7s, \
    PC_SYNCE_STAGE_1_MODE_DIV_11s \
}

/* LTs for ingress/egress port PTP configuration. */
#define XFS_TIME_PORT_TS_STR {\
    PORT_ING_TS_PTPs, \
    PORT_EGR_TS_PTPs \
}

#define XFS_TIMESYNC_MAX_PROFILE (1)

/*
 * Function:
 *      ltsw_xfs_time_synce_clock_source_squelch_set
 * Purpose:
 *      Internal function to set syncE clock source squelch option.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      clk_src - (IN)  Clock source type (Primary, Secondary).
 *      squelch - (IN)  synce clock source squelch setting.
 * Returns:
 *      BCM_E_xxx
 */
static int
ltsw_xfs_time_synce_clock_source_squelch_set(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    int squelch)
{
    int dunit = 0, rv, idx;
    uint64_t val;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    if (clk_src != bcmTimeSynceClockSourcePrimary &&
        clk_src != bcmTimeSynceClockSourceSecondary) {
        return SHR_E_PARAM;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Select Primary or Secondary clock source. */
    idx = (clk_src == bcmTimeSynceClockSourcePrimary) ? 0 : 1;

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_TS_SYNCE_CLK_CONTROLs, &entry));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Re-enable, so disable first. */
    val = 0;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, CLK_RECOVERYs, idx, &val, 1));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

    val = (squelch) ? 0 : 1;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, OVERRIDEs, val));
    val = (squelch) ? 1 : 0;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, OVERRIDE_CLK_VALIDs, idx, &val, 1));

    /* Re-enable. */
    val = 1;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, CLK_RECOVERYs, idx, &val, 1));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*
 * Function:
 *      ltsw_xfs_time_synce_clock_source_squelch_get
 * Purpose:
 *      Internal function to get syncE clock source squelch option.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      clk_src - (IN)  Clock source type (Primary, Secondary).
 *      squelch - (OUT) synce clock source squelch setting.
 * Returns:
 *      BCM_E_xxx
 */
static int
ltsw_xfs_time_synce_clock_source_squelch_get(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    int *squelch)
{
    int dunit = 0, rv, idx;
    uint32_t r_count;
    uint64_t val;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(squelch, SHR_E_PARAM);

    if (clk_src != bcmTimeSynceClockSourcePrimary &&
        clk_src != bcmTimeSynceClockSourceSecondary) {
        return SHR_E_PARAM;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Select Primary or Secondary clock source. */
    idx = (clk_src == bcmTimeSynceClockSourcePrimary) ? 0 : 1;

    /* Allocate DEVICE_TS_SYNCE_CLK_CONTROLs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_TS_SYNCE_CLK_CONTROLs, &entry));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }
    /* Get the data. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_get(entry, OVERRIDE_CLK_VALIDs, idx,
                                     &val, 1, &r_count));
    *squelch = val;
exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*
 * Function:
 *      ltsw_xfs_time_synce_clock_set_by_port
 * Purpose:
 *      Internal function to set SyncE divisor setting.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      clk_src - (IN)  Clock source type (Primary, Secondary)
 *      divisor - (IN)  Divisor setting.
 * Returns:
 *      BCM_E_xxx
 */
static int
ltsw_xfs_time_synce_clock_set_by_port(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    bcm_time_synce_divisor_setting_t *divisor)
{
    int dunit = 0, rv, idx;
    uint64_t val;
    bcm_port_t port;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t pc_entry = BCMLT_INVALID_HDL;
    static const char *xfs_time_pc_synce_0_str[] =
        XFS_TIME_PC_SYNCE_STAGE_0_MODE_STR;
    static const char *xfs_time_pc_synce_1_str[] =
        XFS_TIME_PC_SYNCE_STAGE_1_MODE_STR;
    const char *symbol[1];

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(divisor, SHR_E_PARAM);

    if (clk_src != bcmTimeSynceClockSourcePrimary &&
        clk_src != bcmTimeSynceClockSourceSecondary) {
        return SHR_E_PARAM;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Select Primary or Secondary clock source. */
    idx = (clk_src == bcmTimeSynceClockSourcePrimary) ? 0 : 1;

    /* Assumes input index is logical port number. */
    port = divisor->index;

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_TS_SYNCE_CLK_CONTROLs, &entry));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Re-enable, so disable first. */
    val = 0;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, CLK_RECOVERYs, idx, &val, 1));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

    /* Serdes port configuration. */
    val = port;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, PORT_IDs, idx, &val, 1));

    symbol[0] = DIVIDE_BY_1s;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_symbol_add(entry, CLK_DIVISORs, idx,
                                            symbol, 1));

    /* Enable recov clk as valid, default it is invalid. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, OVERRIDEs, 1));

    val = 1;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, OVERRIDE_CLK_VALIDs, idx, &val, 1));

    /* Re-enable. */
    val = 1;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, CLK_RECOVERYs, idx, &val, 1));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

    /* Configure time synchronization features. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PC_PORT_TIMESYNCs, &pc_entry));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(pc_entry, PORT_IDs, port));

    /* Set TSCF SDM divisors. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(pc_entry, STAGE_0_MODEs,
            xfs_time_pc_synce_0_str[divisor->stage0_mode]));

    /* Set SDM stage 1 mode to bypass. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(pc_entry, STAGE_1_MODEs,
            xfs_time_pc_synce_1_str[divisor->stage1_div]));

    val = ((divisor->stage0_sdm_whole & 0xFF) << 8 |
           (divisor->stage0_sdm_frac & 0xFF));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(pc_entry, FRACTIONAL_DIVISORs, val));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(pc_entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    if (BCMLT_INVALID_HDL != pc_entry) {
        (void)bcmlt_entry_free(pc_entry);
    }

    SHR_FUNC_EXIT();
}

/*
 * Function:
 *      ltsw_xfs_time_synce_clock_get_by_port
 * Purpose:
 *      Internal function to get SyncE divisor setting.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      clk_src - (IN)  Clock source type (Primary, Secondary)
 *      divisor - (OUT) Divisor setting.
 * Returns:
 *      BCM_E_xxx
 */
static int
ltsw_xfs_time_synce_clock_get_by_port(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    bcm_time_synce_divisor_setting_t *divisor)
{
    int dunit = 0, rv, idx, i;
    uint64_t val;
    uint32_t r_count, entry_num;
    bcm_port_t port;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t pc_entry = BCMLT_INVALID_HDL;
    const char *str_p;
    static const char *xfs_time_pc_synce_0_str[] =
        XFS_TIME_PC_SYNCE_STAGE_0_MODE_STR;
    static const char *xfs_time_pc_synce_1_str[] =
        XFS_TIME_PC_SYNCE_STAGE_1_MODE_STR;
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(divisor, SHR_E_PARAM);

    if (clk_src != bcmTimeSynceClockSourcePrimary &&
        clk_src != bcmTimeSynceClockSourceSecondary) {
        return SHR_E_PARAM;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Select Primary or Secondary clock source. */
    idx = (clk_src == bcmTimeSynceClockSourcePrimary) ? 0 : 1;

    /* Allocate DEVICE_TS_SYNCE_CLK_CONTROLs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_TS_SYNCE_CLK_CONTROLs, &entry));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }
    /* Get the data. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    /* Clear structure. */
    bcm_time_synce_divisor_setting_t_init(divisor);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_get(entry, CLK_RECOVERYs, idx,
                                     &val, 1, &r_count));
    /* Start to parse data. */
    if (r_count == 1 && val == 1) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_get(entry, PORT_IDs, idx,
                                         &val, 1, &r_count));
        /* Assumes input index is logical port number. */
        divisor->index = port = val;
        divisor->input_src = bcmTimeSynceInputSourceTypePort;

        /* Allocate PC_PORT_TIMESYNCs. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate(dunit, PC_PORT_TIMESYNCs, &pc_entry));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(pc_entry, PORT_IDs, port));

        /* Get the data. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(pc_entry,
                                BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));

        /* Fetch stage 0. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(pc_entry, STAGE_0_MODEs, &str_p));
        entry_num = (sizeof(xfs_time_pc_synce_0_str) /
                     sizeof(xfs_time_pc_synce_0_str[0]));
        for (i = 0 ;i < entry_num; i++) {
            if (!sal_strcmp(str_p, xfs_time_pc_synce_0_str[i])) {
                divisor->stage0_mode = i;
            }
        }

        /* Fetch stage 1. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(pc_entry, STAGE_1_MODEs, &str_p));
        entry_num = (sizeof(xfs_time_pc_synce_1_str) /
                     sizeof(xfs_time_pc_synce_1_str[0]));
        for (i = 0 ;i < entry_num; i++) {
            if (!sal_strcmp(str_p, xfs_time_pc_synce_1_str[i])) {
                divisor->stage1_div = i;
            }
        }

        /* Fetch stage0_sdm. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(pc_entry, FRACTIONAL_DIVISORs, &val));
        divisor->stage0_sdm_whole = (val >> 8) & 0xFF;
        divisor->stage0_sdm_frac = (val) & 0xFF;
    }
exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    if (BCMLT_INVALID_HDL != pc_entry) {
        (void)bcmlt_entry_free(pc_entry);
    }

    SHR_FUNC_EXIT();
}

/*
 * Function:
 *      ltsw_xfs_time_synce_clock_set_by_pll
 * Purpose:
 *      Internal function to get SyncE divisor setting.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      clk_src - (IN)  Clock source type (Primary, Secondary)
 *      divisor - (IN)  Divisor setting.
 * Returns:
 *      BCM_E_xxx
 */
static int
ltsw_xfs_time_synce_clock_set_by_pll(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    bcm_time_synce_divisor_setting_t *divisor)
{
    /* No LT, hence not supported. */
    return SHR_E_UNAVAIL;
}

/*
 * Function:
 *      ltsw_xfs_time_port_timesync_config_clr
 * Purpose:
 *      Internal function to clear port ingress/egress time config.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      port    - (IN)  Port Number.
 * Returns:
 *      BCM_E_xxx
 */
static int
ltsw_xfs_time_port_timesync_config_clr(
    int unit,
    bcm_port_t port)
{
    int dunit = 0, rv;
    int idx, entry_num;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    static const char *xfs_time_port_ts_str[] = XFS_TIME_PORT_TS_STR;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    entry_num = (sizeof(xfs_time_port_ts_str) /
                 sizeof(xfs_time_port_ts_str[0]));

    for (idx = 0; idx < entry_num; idx++) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate(dunit, xfs_time_port_ts_str[idx], &entry));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, PORT_IDs, port));

        /* Delete and insert again. */
        rv = bcmlt_entry_commit(entry,
                                BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL);
        if (rv != SHR_E_NONE &&
            rv != SHR_E_NOT_FOUND) {
            SHR_ERR_EXIT(rv);
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry,
                                BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL));
        (void)bcmlt_entry_free(entry);
    }

exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*
 * Function:
 *      ltsw_xfs_time_port_timesync_config_get
 * Purpose:
 *      Internal function to set port ingress/egress time config.
 * Parameters:
 *      unit      - (IN)  Unit number.
 *      port      - (IN)  Port Number.
 *      ts_config - (IN)  Timesync configuration.
 * Returns:
 *      BCM_E_xxx
 */
static int
ltsw_xfs_time_port_timesync_config_set(
    int unit,
    bcm_port_t port,
    bcm_port_timesync_config_t *ts_config)
{
    int dunit = 0, rv;
    uint64_t mac = 0;
    bcmlt_entry_handle_t ientry = BCMLT_INVALID_HDL, eentry = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(ts_config, SHR_E_PARAM);

    if (ts_config->flags & BCM_PORT_TIMESYNC_MPLS ||
        ts_config->flags & BCM_PORT_TIMESYNC_EXTERNAL_MAC_ENABLE) {
        /* LT doesn't support BCM_PORT_TIMESYNC_MPLS & EXTERNAL_MAC. */
        return SHR_E_UNAVAIL;
    }
    if (ts_config->pkt_tocpu != 0) {
        /*
         * Un-supported Timesync Packet type with message copy2cpu control.
         * BCM_PORT_TIMESYNC_PKT_*
         */
        return SHR_E_UNAVAIL;
    }
    if (ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_SYNC ||
        ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_DELAY_REQ ||
        ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_PDELAY_REQ ||
        ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_PDELAY_RESP ||
        ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_FOLLOWUP ||
        ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_DELAY_RESP ||
        ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_PDELAY_RESP_FOLLOWUP ||
        ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_ANNOUNCE ||
        ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_SIGNALLING ||
        ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_MANAGMENT) {
        /* Un-supported Timesync Packet type with message drop control. */
        return SHR_E_UNAVAIL;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate PORT_ING_TS_PTPs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_ING_TS_PTPs, &ientry));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(ientry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(ientry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_EXISTS);

    /* Allocate PORT_EGR_TS_PTPs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_EGR_TS_PTPs, &eentry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eentry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(eentry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_EXISTS);

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(eentry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_EXISTS);

    /* Clear original configuration. */
    ltsw_xfs_time_port_timesync_config_clr(unit, port);

    /* Configure ts_config. */
    if (ts_config->flags & BCM_PORT_TIMESYNC_DEFAULT) {
        /* Set one-step timestamp configurations */
        if (ts_config->flags & BCM_PORT_TIMESYNC_ONE_STEP_TIMESTAMP) {
            /* Enable Correction updates for ingress and egress. */
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_add(ientry, CORRECTION_FIELDs, 1));

            /*
             * Enable for below situations:
             * 1. Ethernet port but not stack port
             * 2. Higig but not higig proxy. (no higig on SDKLT)
             */
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_add(ientry, SIGN_FROM_TIMESTAMPs, 0));

            if (ts_config->flags &
                BCM_PORT_TIMESYNC_TIMESTAMP_CFUPDATE_ALL) {
                SHR_IF_ERR_EXIT
                    (bcmlt_entry_field_symbol_add(eentry, CF_UPDATE_MODEs,
                                                  PORT_BASED_ENABLEs));
            } else {
                /*
                 * The ingress port is default enabled for correction
                 * updates for one-step timestamping and hence the
                 * EGR update mode is set to ingress based correction
                 * updates.
                */
                SHR_IF_ERR_EXIT
                    (bcmlt_entry_field_symbol_add(eentry, CF_UPDATE_MODEs,
                                                  ING_UPDATE_BASED_ENABLEs));
            }

            /* Enable Source Address update for corrections. */
            if (!BCM_MAC_IS_ZERO(ts_config->src_mac_addr)) {
                SHR_IF_ERR_EXIT
                    (bcmlt_entry_field_add(eentry, REPLACE_SRC_MACs, 1));
                bcmi_ltsw_util_mac_to_uint64(&mac, ts_config->src_mac_addr);
                SHR_IF_ERR_EXIT
                    (bcmlt_entry_field_add(eentry, SRC_MACs, mac));
            }

        }

        /* Set two-step correction update enable. */
        if (ts_config->flags & BCM_PORT_TIMESYNC_TWO_STEP_TIMESTAMP) {
            /* Set two-step timestamping in mac for all event pkts. */
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_add(eentry, TS_SYNCs, 1));
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_add(eentry, TS_DELAY_REQs, 1));
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_add(eentry, TS_PDELAY_REQs, 1));
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_add(eentry, TS_PDELAY_RESPs, 1));
        }

        /* Timesync Packet type bitmaps. */
        if (ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_INVALID) {
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_add(eentry, DROP_INVALID_IEEE1588_PKTs, 1));
        }
    }

    /* Write to PORT_ING_TS_PTPs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(ientry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
    /* Write to PORT_EGR_TS_PTPs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(eentry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    if (BCMLT_INVALID_HDL != ientry) {
        (void)bcmlt_entry_free(ientry);
    }
    if (BCMLT_INVALID_HDL != eentry) {
        (void)bcmlt_entry_free(eentry);
    }
    SHR_FUNC_EXIT();
}

/*
 * Function:
 *      ltsw_xfs_time_port_timesync_config_set
 * Purpose:
 *      Internal function to get port ingress/egress time config.
 * Parameters:
 *      unit      - (IN)  Unit number.
 *      port      - (IN)  Port Number.
 *      ts_config - (OUT) Timesync configuration.
 * Returns:
 *      BCM_E_xxx
 */
static int
ltsw_xfs_time_port_timesync_config_get(
    int unit,
    bcm_port_t port,
    bcm_port_timesync_config_t *ts_config)
{
    int dunit = 0, rv;
    uint64_t mac = 0, val;
    const char *str_p;
    bcmlt_entry_handle_t ientry = BCMLT_INVALID_HDL, eentry = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(ts_config, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate PORT_ING_TS_PTPs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_ING_TS_PTPs, &ientry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(ientry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(ientry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_EXISTS);

    /* Get the data. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(ientry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    /* Allocate PORT_EGR_TS_PTPs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_EGR_TS_PTPs, &eentry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eentry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(eentry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_EXISTS);

    /* Get the data. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(eentry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    /* Clear structure. */
    bcm_port_timesync_config_t_init(ts_config);

    /* Start to parse data. */
    ts_config->flags |= BCM_PORT_TIMESYNC_DEFAULT;

    /* Timesync Packet type bitmaps. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eentry, DROP_INVALID_IEEE1588_PKTs, &val));
    if (val == 1) {
        ts_config->pkt_drop |= BCM_PORT_TIMESYNC_PKT_INVALID;
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eentry, TS_SYNCs, &val));
    if (val == 1) {
        ts_config->flags |= BCM_PORT_TIMESYNC_TWO_STEP_TIMESTAMP;
    }

    /* Get one-step timestamp configurations. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(ientry, CORRECTION_FIELDs, &val));
    if (val == 1) {
        ts_config->flags |= BCM_PORT_TIMESYNC_ONE_STEP_TIMESTAMP;

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(eentry, CF_UPDATE_MODEs, &str_p));
        if (!sal_strcmp(str_p, PORT_BASED_ENABLEs)) {
            ts_config->flags |= BCM_PORT_TIMESYNC_TIMESTAMP_CFUPDATE_ALL;
        }

        /* Get Source Address update for corrections. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(eentry, REPLACE_SRC_MACs, &val));
        if (val == 1) {
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_get(eentry, SRC_MACs, &mac));
            bcmi_ltsw_util_uint64_to_mac(ts_config->src_mac_addr, &mac);
        }
    }

exit:
    if (BCMLT_INVALID_HDL != ientry) {
        (void)bcmlt_entry_free(ientry);
    }
    if (BCMLT_INVALID_HDL != eentry) {
        (void)bcmlt_entry_free(eentry);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DEVICE_TS_TODs LT entry.
 *
 * \param [in] unit Unit Number.
 * \param [out] tod Time of the day values.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_INTERNAL Auto-update is not working properly.
 */
static int
ltsw_xfs_lt_tod_entry_get(
    int unit,
    const char *tbl_name,
    bcm_time_tod_t *tod)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t fields[BCMI_LT_FIELD_MAX];
    int hw_update_supported;
    uint64_t auto_update, sec, nsec, adj;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(tod, SHR_E_PARAM);

    if (SHR_SUCCESS(bcmi_lt_field_validate(unit, tbl_name, HW_UPDATEs))) {
        hw_update_supported = 1;
    } else {
        hw_update_supported = 0;
    }

    bcmi_lt_entry_init(&lt_entry, fields);
    bcmi_lt_entry_field_add(unit, &lt_entry, TOD_SECs, 0, BCMI_LT_FIELD_F_GET);
    bcmi_lt_entry_field_add(unit, &lt_entry, TOD_NSECs, 0, BCMI_LT_FIELD_F_GET);
    bcmi_lt_entry_field_add(unit, &lt_entry, ADJUSTs, 0, BCMI_LT_FIELD_F_GET);

    /* Read hw-update fields only when they are valid. */
    if (hw_update_supported) {
        bcmi_lt_entry_field_add(unit, &lt_entry, HW_UPDATEs, 0,
                                BCMI_LT_FIELD_F_GET);
        bcmi_lt_entry_field_add(unit, &lt_entry, TOD_SEC_OPERs, 0,
                                BCMI_LT_FIELD_F_GET);
        bcmi_lt_entry_field_add(unit, &lt_entry, TOD_NSEC_OPERs, 0,
                                BCMI_LT_FIELD_F_GET);
        bcmi_lt_entry_field_add(unit, &lt_entry, ADJUST_OPERs, 0,
                                BCMI_LT_FIELD_F_GET);
        bcmi_lt_entry_field_symbol_add(unit, &lt_entry, OPERATIONAL_STATEs, "",
                                       BCMI_LT_FIELD_F_GET);
    }

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_get(unit, tbl_name, &lt_entry, NULL, NULL));

    if (hw_update_supported) {
        const char *st;

        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, HW_UPDATEs,
                                     &auto_update));
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_symbol_get(unit, &lt_entry, OPERATIONAL_STATEs,
                                            &st));

        if (auto_update &&
            sal_memcmp(st, SUCCESSs, sal_strlen(SUCCESSs))) {
            LOG_VERBOSE(BSL_LOG_MODULE,
                        (BSL_META_U(unit,
                                    "ToD auto-update is not working properly."
                                    "\n")));
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
    } else {
        auto_update = 0;
    }

    if (auto_update) {
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, TOD_SEC_OPERs, &sec));
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, TOD_NSEC_OPERs, &nsec));
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, ADJUST_OPERs, &adj));
    } else {
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, TOD_SECs, &sec));
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, TOD_NSECs, &nsec));
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, ADJUSTs, &adj));
    }

    tod->auto_update = auto_update;
    tod->ts.seconds = sec;
    tod->ts.nanoseconds = nsec;
    tod->ts_adjustment_counter_ns = adj;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DEVICE_TS_TODs LT entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] tod Time of the day values.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_lt_tod_entry_set(
    int unit,
    const char *tbl_name,
    bcm_time_tod_t *tod)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t fields[BCMI_LT_FIELD_MAX];
    uint64_t auto_update, sec, nsec, adj;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(tod, SHR_E_PARAM);

    auto_update = tod->auto_update;
    sec = tod->ts.seconds;
    nsec = tod->ts.nanoseconds;
    adj = tod->ts_adjustment_counter_ns;

    bcmi_lt_entry_init(&lt_entry, fields);
    bcmi_lt_entry_field_add(unit, &lt_entry, TOD_SECs, sec,
                            BCMI_LT_FIELD_F_SET);
    bcmi_lt_entry_field_add(unit, &lt_entry, TOD_NSECs, nsec,
                            BCMI_LT_FIELD_F_SET);
    bcmi_lt_entry_field_add(unit, &lt_entry, ADJUSTs, adj,
                            BCMI_LT_FIELD_F_SET);

    /* Update hw-update field only when it is valid. */
    if (SHR_SUCCESS(bcmi_lt_field_validate(unit, tbl_name, HW_UPDATEs))) {
        bcmi_lt_entry_field_add(unit, &lt_entry, HW_UPDATEs, auto_update,
                                BCMI_LT_FIELD_F_SET);
    }

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_set(unit, tbl_name, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update ToD value.
 *
 * \param [in] unit Unit Number.
 * \param [in] tod Time of the day values.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_time_tod_set(
    int unit,
    uint32 stages,
    bcm_time_tod_t *tod)
{
    bcm_time_tod_t tod_st;
    char *tbl_name;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(tod, SHR_E_PARAM);

    if (stages & BCM_TIME_STAGE_EGRESS) {
        tbl_name = DEVICE_TS_TODs;
    } else if (stages & BCM_TIME_STAGE_MMU) {
        tbl_name = TM_TS_TODs;
    } else {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (!tod->auto_update) {
        SHR_IF_ERR_EXIT
            (ltsw_xfs_lt_tod_entry_set(unit, tbl_name, tod));
        SHR_EXIT();
    }

    /* Check if auto_update is supported. */
    if (SHR_FAILURE(bcmi_lt_field_validate(unit, tbl_name, HW_UPDATEs))) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Restart ToD auto-update operation by disabling and then enabling it. */
    tod->auto_update = 0;
    SHR_IF_ERR_EXIT
        (ltsw_xfs_lt_tod_entry_set(unit, tbl_name, tod));
    tod->auto_update = 1;
    SHR_IF_ERR_EXIT
        (ltsw_xfs_lt_tod_entry_set(unit, tbl_name, tod));

    /* Check if auto-update operation is working properly. */
    SHR_IF_ERR_EXIT
        (ltsw_xfs_lt_tod_entry_get(unit, tbl_name, &tod_st));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ToD value.
 *
 * \param [in] unit Unit Number.
 * \param [out] tod Time of the day values.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_time_tod_get(
    int unit,
    uint32 stages,
    bcm_time_tod_t *tod)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field;
    char *tbl_name;

    SHR_FUNC_ENTER(unit);

    if (stages & BCM_TIME_STAGE_EGRESS) {
        tbl_name = DEVICE_TS_TODs;
    } else if (stages & BCM_TIME_STAGE_MMU) {
        tbl_name = TM_TS_TODs;
    } else {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Force to insert DEVICE_TS_TODs entry. */
    bcmi_lt_entry_init(&lt_entry, &field);
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_lt_entry_insert(unit, tbl_name, &lt_entry, NULL),
         SHR_E_EXISTS);

    /* Get DEVICE_TS_TODs entry. */
    SHR_IF_ERR_EXIT
        (ltsw_xfs_lt_tod_entry_get(unit, tbl_name, tod));

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Get field value from DEVICE_TS_CONTROL LT.
 *
 * \param [in] unit Unit number.
 * \param [in] fld_name Field name.
 * \param [out] val Field value.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_device_ts_control_field_get(
    int unit,
    const char *fld_name,
    int *val)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field;
    bcmlt_field_def_t fld_def;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmi_lt_field_def_get(unit, DEVICE_TS_CONTROLs, fld_name, &fld_def));

    lt_entry.fields = &field;
    lt_entry.nfields = 1;
    lt_entry.attr = 0;

    sal_memset(&field, 0, sizeof(field));
    field.fld_name = fld_name;
    field.flags = BCMI_LT_FIELD_F_GET;
    if (fld_def.symbol) {
        field.flags |= BCMI_LT_FIELD_F_SYMBOL;
    }

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_get(unit, DEVICE_TS_CONTROLs, &lt_entry, NULL, NULL));

    if (!sal_strcmp(fld_name, TIMESTAMPING_MODEs)) {
        if (!sal_strcmp(field.u.sym_val, TIMESTAMP_32_MODEs)) {
            *val = bcmTimesyncTimestampingMode32bit;
        } else {
            *val = bcmTimesyncTimestampingMode48bit;
        }
    } else if (!sal_strcmp(fld_name, IEEE1588_VERSIONs)) {
        if (!sal_strcmp(field.u.sym_val, VER_EQ_2s)) {
            *val = 0;
        } else {
            *val = 1;
        }
    } else {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set field value to DEVICE_TS_CONTROL LT.
 *
 * \param [in] unit Unit number.
 * \param [in] fld_name Field name.
 * \param [in] val Field value.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_device_ts_control_field_set(
    int unit,
    const char *fld_name,
    int val)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field;
    bcmlt_field_def_t fld_def;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmi_lt_field_def_get(unit, DEVICE_TS_CONTROLs, fld_name, &fld_def));

    lt_entry.fields = &field;
    lt_entry.nfields = 1;
    lt_entry.attr = 0;

    sal_memset(&field, 0, sizeof(field));
    field.fld_name = fld_name;
    field.flags = BCMI_LT_FIELD_F_SET;
    if (fld_def.symbol) {
        field.flags |= BCMI_LT_FIELD_F_SYMBOL;
    }

    if (!sal_strcmp(fld_name, TIMESTAMPING_MODEs)) {
        if (val == bcmTimesyncTimestampingMode32bit) {
            field.u.sym_val = TIMESTAMP_32_MODEs;
        } else {
            field.u.sym_val = TIMESTAMP_48_MODEs;
        }
    } else if (!sal_strcmp(fld_name, IEEE1588_VERSIONs)) {
        if (val == 0) {
            field.u.sym_val = VER_EQ_2s;
        } else {
            field.u.sym_val = VER_GT_OR_EQ_2s;
        }
    } else {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_set(unit, DEVICE_TS_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_time_init(int unit)
{
    return SHR_E_NONE;
}

int
xfs_ltsw_time_deinit(int unit)
{
    return SHR_E_NONE;
}

int
xfs_ltsw_time_synce_clock_set(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    bcm_time_synce_divisor_setting_t *divisor)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(divisor, SHR_E_PARAM);

    switch(divisor->input_src) {
        case bcmTimeSynceInputSourceTypePort:
            SHR_IF_ERR_EXIT
                (ltsw_xfs_time_synce_clock_set_by_port(unit, clk_src, divisor));
            break;
        case bcmTimeSynceInputSourceTypePLL:
            SHR_IF_ERR_EXIT
                (ltsw_xfs_time_synce_clock_set_by_pll(unit, clk_src, divisor));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_time_synce_clock_get(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    bcm_time_synce_divisor_setting_t *divisor)
{
    return ltsw_xfs_time_synce_clock_get_by_port(unit, clk_src, divisor);
}

int
xfs_ltsw_time_synce_clock_source_control_set(
    int unit,
    bcm_time_synce_clock_source_config_t *clk_src_config,
    bcm_time_synce_clock_source_control_t control,
    int value)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(clk_src_config, SHR_E_PARAM);

    switch (control) {
        case bcmTimeSynceClockSourceControlSquelch:
            SHR_IF_ERR_EXIT
                (ltsw_xfs_time_synce_clock_source_squelch_set(
                    unit, clk_src_config->clk_src, value));
            break;
        case bcmTimeSynceClockSourceControlFrequency:
            /*
             * The freq setting will dispatch from chip layer, so never enter
             * this mode here.
             *
             * Function:
             * bcmXXXXX_a0_ltsw_time_synce_clock_source_control_set
             * - bcmXXXXX_time_synce_clock_source_freq_cal
             * - xfs_ltsw_time_synce_clock_set
             */
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
   }
exit:

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_time_synce_clock_source_control_get(
    int unit,
    bcm_time_synce_clock_source_config_t *clk_src_config,
    bcm_time_synce_clock_source_control_t control,
    int *value)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(clk_src_config, SHR_E_PARAM);

    switch (control) {
        case bcmTimeSynceClockSourceControlSquelch:
            SHR_IF_ERR_EXIT
                (ltsw_xfs_time_synce_clock_source_squelch_get(
                    unit, clk_src_config->clk_src, value));
            break;
        case bcmTimeSynceClockSourceControlFrequency:
            /*
             * The freq setting will dispatch from chip layer, so never enter
             * this mode here.
             *
             * Function:
             * bcmXXXXX_a0_ltsw_time_synce_clock_source_control_get
             * - bcmXXXXX_time_synce_clock_source_freq_cal
             * - xfs_ltsw_time_synce_clock_set
             */
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
   }
exit:

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_time_tod_set(
    int unit,
    uint32 stages,
    bcm_time_tod_t *tod)
{
    if (stages & (BCM_TIME_STAGE_EGRESS | BCM_TIME_STAGE_MMU)) {
        return ltsw_xfs_time_tod_set(unit, stages, tod);
    }

    return SHR_E_UNAVAIL;
}

int
xfs_ltsw_time_tod_get(
    int unit,
    uint32 stages,
    bcm_time_tod_t *tod)
{
    if (stages & (BCM_TIME_STAGE_EGRESS | BCM_TIME_STAGE_MMU)) {
        return ltsw_xfs_time_tod_get(unit, stages, tod);
    }

    return SHR_E_UNAVAIL;
}

int
xfs_ltsw_time_port_timesync_config_set(
    int unit,
    bcm_port_t port,
    int config_count,
    bcm_port_timesync_config_t *config_array)
{
    int cnt;
    bcm_port_timesync_config_t *ts_config;

    SHR_FUNC_ENTER(unit);

    if (config_count == 0) {
        /* Clear timesync for NULL timesync configuration */
        SHR_IF_ERR_EXIT(ltsw_xfs_time_port_timesync_config_clr(unit, port));
    } else {
        if ((config_count > XFS_TIMESYNC_MAX_PROFILE) ||
            ((config_count > 0) && (NULL == config_array))) {
            return BCM_E_PARAM;
        }
        /* Set timesync profiles */
        for (cnt = 0; cnt < config_count; cnt++) {
            ts_config = (bcm_port_timesync_config_t*) (config_array + cnt);
            SHR_IF_ERR_EXIT
                (ltsw_xfs_time_port_timesync_config_set(unit, port, ts_config));
        }
        return BCM_E_NONE;
    }
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_time_port_timesync_config_get(
    int unit,
    bcm_port_t port,
    int config_count,
    bcm_port_timesync_config_t *config_array,
    int *array_count)
{
    int cnt;
    bcm_port_timesync_config_t *ts_config;

    SHR_FUNC_ENTER(unit);

    if (config_count == 0) {
        return BCM_E_PARAM;
    } else {
        if ((config_count > XFS_TIMESYNC_MAX_PROFILE) ||
            ((config_count > 0) && (NULL == config_array)) ||
            ((NULL == array_count))) {
            return BCM_E_PARAM;
        }
        /* Get timesync profiles */
        for (cnt = 0; cnt < config_count; cnt++) {
            ts_config = (bcm_port_timesync_config_t *) (config_array + cnt);
            SHR_IF_ERR_EXIT
                (ltsw_xfs_time_port_timesync_config_get(unit, port, ts_config));
        }
        *array_count = cnt;
        return BCM_E_NONE;
    }
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_time_switch_control_set(
    int unit,
    bcm_switch_control_t type,
    int arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmSwitchTimesyncEgressTimestampingMode:
            SHR_IF_ERR_EXIT
                (ltsw_xfs_device_ts_control_field_set
                    (unit, TIMESTAMPING_MODEs, arg));
            break;
        case bcmSwitchTimesyncEgressVersion:
        case bcmSwitchTimesyncIngressVersion:
            SHR_IF_ERR_EXIT
                (ltsw_xfs_device_ts_control_field_set
                    (unit, IEEE1588_VERSIONs, arg));
            break;
        case bcmSwitchNtpL4DestPort:
        case bcmSwitchTimesyncLiveWireToD:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_time_switch_control_get(
    int unit,
    bcm_switch_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmSwitchTimesyncEgressTimestampingMode:
            SHR_IF_ERR_EXIT
                (ltsw_xfs_device_ts_control_field_get
                    (unit, TIMESTAMPING_MODEs, arg));
            break;
        case bcmSwitchTimesyncEgressVersion:
        case bcmSwitchTimesyncIngressVersion:
            SHR_IF_ERR_EXIT
                (ltsw_xfs_device_ts_control_field_get
                    (unit, IEEE1588_VERSIONs, arg));
            break;
        case bcmSwitchNtpL4DestPort:
        case bcmSwitchTimesyncLiveWireToD:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_time_switch_control_port_set(
    int unit,
    bcm_port_t port,
    bcm_switch_control_t type,
    int arg)
{
    /* No LT, bcmSwitchTimesyncEgressTimestampingMode is not supported */
    if (type == bcmSwitchTimesyncEgressTimestampingMode) {
        return SHR_E_UNAVAIL;
    } else {
        return SHR_E_PARAM;
    }
}

int
xfs_ltsw_time_switch_control_port_get(
    int unit,
    bcm_port_t port,
    bcm_switch_control_t type,
    int *arg)
{
    /* No LT, bcmSwitchTimesyncEgressTimestampingMode is not supported */
    if (type == bcmSwitchTimesyncEgressTimestampingMode) {
        return SHR_E_UNAVAIL;
    } else {
        return SHR_E_PARAM;
    }
}

