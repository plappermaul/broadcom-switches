/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/stg.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/xfs/stg.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/l3_intf.h>
#include <bcm_int/ltsw/l2.h>
#include <bcm_int/ltsw/stg_int.h>
#include <bcm_int/ltsw/stg.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/stack.h>
#include <bcm_int/ltsw/vlan.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/issu.h>
#include <bcm_int/ltsw/generated/stg_ha.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_STG

/******************************************************************************
 * Private functions
 */


/*
 * \name Macros for STG state.
 * \anchor STG_STP_xxx
 */
#define STG_STP_INVALID         ((uint8_t)0)
#define STG_STP_DISABLE         ((uint8_t)1)
#define STG_STP_BLOCK           ((uint8_t)2)
#define STG_STP_LEARN           ((uint8_t)3)
#define STG_STP_FORWARD         ((uint8_t)4)

/*
 * \name Macros for the list of functionality
 * \anchor STG_F_xxx
 */
#define STG_F_SW_STP_STATE       (1 << 0)

/*
 * \name Macros to disable VLAN check.
 * \anchor VLAN_PORT_DIS_xxx
 */
#define STG_PORT_DIS_ING_CHK     (1 << 0)
#define STG_PORT_DIS_ING_EGR_CHK (1 << 1)
#define STG_PORT_DIS_EGR_CHK     (1 << 2)

/*
 * \brief STG information.
 */
typedef struct stg_info_s {
    /* Enable list of the functionality. */
    uint32_t flags;

    /* STP state for the STG check. */
    bcmint_stg_stp_info_t *stp_state;

    /* Information to disable STG check per port. */
    uint8_t *port_dis_chk;
} stg_info_t;

static stg_info_t stg_info[BCM_MAX_NUM_UNITS] = {{ 0 }};

/* Enable to maintain SW STP state. */
#define STG_SW_STP_STATE_EN(u) \
    (stg_info[u].flags & STG_F_SW_STP_STATE)

/*!
 * \brief Initialize an entry of STG profile table.
 *
 * \param [in] unit      Unit Number.
 * \param [in] ingress   Ingress or egress.
 * \param [in] stg       STG index.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_profile_entry_init(int unit, int ingress, bcm_stg_t stg)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const char *tbl_name[] = {VLAN_EGR_STG_PROFILEs,
                              VLAN_ING_STG_PROFILEs};
    const char *key_name[] = {VLAN_EGR_STG_PROFILE_IDs,
                              VLAN_ING_STG_PROFILE_IDs};
    const char *state[1];
    uint8_t dis_chk_flg[] = {STG_PORT_DIS_EGR_CHK,
                             STG_PORT_DIS_ING_CHK};
    stg_info_t *si = &stg_info[unit];
    uint8_t sw_state = 0;
    int port_num = 0, offset = 0;
    bcm_pbmp_t pbm, pbm_stk;
    int dunit = 0;
    int i = 0;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    /* Allocate entry container. */
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, tbl_name[ingress], &ent_hdl));

    /* Add STG ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, key_name[ingress], stg));

    /* Get CPU and LB ports. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit,
                               BCMI_LTSW_PORT_TYPE_CPU | BCMI_LTSW_PORT_TYPE_LB,
                               &pbm));
    /* Get stacking ports. */
    BCM_PBMP_CLEAR(pbm_stk);
    rv = bcmi_ltsw_stk_pbmp_get(unit, &pbm_stk, NULL, NULL);
    if (rv != SHR_E_INIT) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }
    BCM_PBMP_OR(pbm, pbm_stk);

    port_num = bcmi_ltsw_dev_logic_port_max(unit) + 1;
    offset = STG_SW_STP_STATE_EN(unit) ? (port_num * stg) : 0;

    for (i = 0; i < port_num; i++) {

        /*
         * Set all ports into disable in none-zero stg. But Stacking ports,
         * CPU ports and LB ports are always in forward state.
         */
        if (stg == 0) {
            state[0] = FORWARDs;
            sw_state = STG_STP_FORWARD;
        } else {
            if (BCM_PBMP_MEMBER(pbm, i)) {
                state[0] = FORWARDs;
                sw_state = STG_STP_FORWARD;
            } else {
                state[0] = DISABLEs;
                sw_state = STG_STP_DISABLE;
            }
        }

        if (STG_SW_STP_STATE_EN(unit)) {
            /* Set to forward state if STG check is disable via SW. */
            if (si->port_dis_chk[i] & dis_chk_flg[ingress]) {
                state[0] = FORWARDs;
            }
            /* Store the initial state configured by APIs. */
            if (ingress) {
                si->stp_state[offset + i].ing_state = sw_state;
            } else {
                si->stp_state[offset + i].egr_state = sw_state;
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_add(ent_hdl,
                                                STATEs,
                                                (uint32_t)i,
                                                state, 1));
    }

    /* Insert VLAN_ING_STG_PROFILE entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, ent_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void) bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set STP state for a port in VLAN STG profile table.
 *
 * \param [in] unit      Unit Number.
 * \param [in] ingress   Ingress or egress.
 * \param [in] stg       STG index.
 * \param [in] port      Port ID.
 * \param [in] stp_state Spanning tree state.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_profile_entry_set(int unit, int ingress, bcm_stg_t stg,
                      bcm_port_t port, int stp_state)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const char *tbl_name[] = {VLAN_EGR_STG_PROFILEs,
                              VLAN_ING_STG_PROFILEs};
    const char *key_name[] = {VLAN_EGR_STG_PROFILE_IDs,
                              VLAN_ING_STG_PROFILE_IDs};
    const char *state[1];
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    /* Allocate entry container. */
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, tbl_name[ingress], &ent_hdl));

    /* Add STG ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, key_name[ingress], stg));

    /* Add STP state. */
    switch (stp_state) {
    case BCM_STG_STP_FORWARD:
        state[0] = FORWARDs;
        break;
    case BCM_STG_STP_LISTEN:
    case BCM_STG_STP_BLOCK:
        state[0] = BLOCKs;
        break;
    case BCM_STG_STP_LEARN:
        state[0] = LEARNs;
        break;
    case BCM_STG_STP_DISABLE:
        state[0] = DISABLEs;
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_symbol_add(ent_hdl, STATEs,
                                           (uint32_t)port, state, 1));

    /* Update VLAN STG profile entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, ent_hdl,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));
exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void) bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set STP state for a port in VLAN STG profile SW table.
 *
 * \param [in] unit      Unit Number.
 * \param [in] ingress   Ingress or egress.
 * \param [in] stg       STG index.
 * \param [in] port      Port ID.
 * \param [in] stp_state Spanning tree state.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_profile_entry_sw_set(int unit, int ingress, bcm_stg_t stg,
                         bcm_port_t port, int stp_state)
{
    stg_info_t *si = &stg_info[unit];
    uint8_t sw_state = 0;
    int port_num = 0;

    SHR_FUNC_ENTER(unit);

    /* Add STP state. */
    switch (stp_state) {
    case BCM_STG_STP_FORWARD:
        sw_state = STG_STP_FORWARD;
        break;
    case BCM_STG_STP_LISTEN:
    case BCM_STG_STP_BLOCK:
        sw_state = STG_STP_BLOCK;
        break;
    case BCM_STG_STP_LEARN:
        sw_state = STG_STP_LEARN;
        break;
    case BCM_STG_STP_DISABLE:
        sw_state = STG_STP_DISABLE;
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    port_num = bcmi_ltsw_dev_logic_port_max(unit) + 1;

    /* Store the initial state configured by APIs. */
    if (ingress) {
        si->stp_state[port_num * stg + port].ing_state = sw_state;
    } else {
        si->stp_state[port_num * stg + port].egr_state = sw_state;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get STP state for a port in VLAN STG profile table.
 *
 * \param [in] unit      Unit Number.
 * \param [in] ingress   Ingress or egress.
 * \param [in] stg       STG index.
 * \param [in] port      Port ID.
 * \param [out]stp_state Spanning tree state.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_profile_entry_get(int unit, int ingress, bcm_stg_t stg,
                      bcm_port_t port, int *stp_state)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const char *tbl_name[] = {VLAN_EGR_STG_PROFILEs,
                              VLAN_ING_STG_PROFILEs};
    const char *key_name[] = {VLAN_EGR_STG_PROFILE_IDs,
                              VLAN_ING_STG_PROFILE_IDs};
    const char *state = NULL;
    uint32_t r_cnt = 0;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    /* Allocate entry container. */
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, tbl_name[ingress], &ent_hdl));

    /* Add STG ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, key_name[ingress], stg));


    /* Lookup VLAN STG profile entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, ent_hdl,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    /* Get STP state. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_symbol_get(ent_hdl, STATEs, (uint32_t)port,
                                            &state, 1, &r_cnt));

    if (sal_strcmp(FORWARDs, state) == 0) {
        *stp_state = BCM_STG_STP_FORWARD;
    } else if (sal_strcmp(BLOCKs, state) == 0) {
        *stp_state = BCM_STG_STP_BLOCK;
    } else if (sal_strcmp(LEARNs, state) == 0) {
        *stp_state = BCM_STG_STP_LEARN;
    } else if (sal_strcmp(DISABLEs, state) == 0) {
        *stp_state = BCM_STG_STP_DISABLE;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void) bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get STP state for a port in VLAN STG profile SW table.
 *
 * \param [in] unit      Unit Number.
 * \param [in] ingress   Ingress or egress.
 * \param [in] stg       STG index.
 * \param [in] port      Port ID.
 * \param [out]stp_state Spanning tree state.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_profile_entry_sw_get(int unit, int ingress, bcm_stg_t stg,
                         bcm_port_t port, int *stp_state)
{
    stg_info_t *si = &stg_info[unit];
    uint8_t sw_state = 0;
    int port_num = 0;

    SHR_FUNC_ENTER(unit);

    /* Get STP state from SW entry directly. */
    port_num = bcmi_ltsw_dev_logic_port_max(unit) + 1;

    if (ingress) {
        sw_state = si->stp_state[port_num * stg + port].ing_state;
    } else {
        sw_state = si->stp_state[port_num * stg + port].egr_state;
    }

    switch (sw_state) {
    case STG_STP_FORWARD:
        *stp_state = BCM_STG_STP_FORWARD;
        break;
    case STG_STP_BLOCK:
        *stp_state = BCM_STG_STP_BLOCK;
        break;
    case STG_STP_LEARN:
        *stp_state = BCM_STG_STP_LEARN;
        break;
    case STG_STP_DISABLE:
        *stp_state = BCM_STG_STP_DISABLE;
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear an entry of STG profile table.
 *
 * \param [in] unit      Unit Number.
 * \param [in] ingress   Ingress or egress.
 * \param [in] stg       STG index.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_profile_entry_clear(int unit, int ingress, bcm_stg_t stg)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const char *tbl_name[] = {VLAN_EGR_STG_PROFILEs,
                              VLAN_ING_STG_PROFILEs};
    const char *key_name[] = {VLAN_EGR_STG_PROFILE_IDs,
                              VLAN_ING_STG_PROFILE_IDs};
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    /* Allocate entry container. */
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, tbl_name[ingress], &ent_hdl));

    /* Add STG ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, key_name[ingress], stg));

    /* Delete VLAN STG profile entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, ent_hdl,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void) bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear an entry of STG profile sw table.
 *
 * \param [in] unit      Unit Number.
 * \param [in] ingress   Ingress or egress.
 * \param [in] stg       STG index.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_profile_entry_sw_clear(int unit, int ingress, bcm_stg_t stg)
{
    stg_info_t *si = &stg_info[unit];
    int port_num = 0;
    int offset = 0;
    int i = 0;

    /* Reset SW entry. */
    port_num = bcmi_ltsw_dev_logic_port_max(unit) + 1;
    offset = port_num * stg;
    for (i = 0; i < port_num; i++) {
        if (ingress) {
            si->stp_state[offset + i].ing_state = STG_STP_INVALID;
        } else {
            si->stp_state[offset + i].egr_state = STG_STP_INVALID;
        }
    }

    return SHR_E_NONE;
}

/*!
 * \brief Initialize an entry of VLAN_ING_EGR_STG_MEMBER_PORTS_PROFILE table.
 *
 * \param [in] unit      Unit Number.
 * \param [in] stg       STG index.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_ing_egr_profile_entry_init(int unit, bcm_stg_t stg)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const char *data = NULL;
    const char *mask_state[1];
    int max_port_num = 0;
    int dunit = 0;
    int i = 0;

    SHR_FUNC_ENTER(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
                              VLAN_ING_EGR_STG_MEMBER_PROFILEs, &ent_hdl));

    /* Add STG ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl,
                               VLAN_ING_EGR_STG_MEMBER_PROFILE_IDs, stg));

    /*
     * Legacy chips - Do not check egress STG state in ingress pipleline.
     * MASK_STATEs and COMPARED_STATEs have the same state - forwarding.
     */
    mask_state[0] = FORWARDs;

    max_port_num = bcmi_ltsw_dev_logic_port_max(unit) + 1;
    for (i = 0; i < max_port_num; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_add(ent_hdl,
                                                STATEs,
                                                (uint32_t)i,
                                                mask_state, 1));
    }

    data = FORWARDs;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(ent_hdl, COMPARED_STATEs, data));

    data = L2_MEMBERs;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(ent_hdl, MASK_TARGETs, data));

    data = ANDs;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(ent_hdl, MASK_ACTIONs, data));

    /* Insert VLAN_ING_EGR_STG_MEMBER_PORTS_PROFILE entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, ent_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void) bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear an entry of VLAN_ING_EGR_STG_MEMBER_PORTS_PROFILE table.
 *
 * \param [in] unit      Unit Number.
 * \param [in] stg       STG index.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_ing_egr_profile_entry_clear(int unit, bcm_stg_t stg)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
                              VLAN_ING_EGR_STG_MEMBER_PROFILEs, &ent_hdl));

    /* Add STG ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl,
                               VLAN_ING_EGR_STG_MEMBER_PROFILE_IDs, stg));

    /* Delete VLAN_ING_EGR_STG_MEMBER_PORTS_PROFILE entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, ent_hdl,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void) bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the state in a specified ingress STG.
 *
 * \param [in] unit      Unit Number.
 * \param [in] stg       STG index.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_ing_stp_init(int unit, bcm_stg_t stg)
{
    SHR_FUNC_ENTER(unit);

    /* Initialize VLAN_ING_STG_PROFILE entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_profile_entry_init(unit, 1, stg));

    /* Initialize VLAN_ING_EGR_STG_MEMBER_PORTS_PROFILE entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_ing_egr_profile_entry_init(unit, stg));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear the state in a specified ingress STG.
 *
 * \param [in] unit      Unit Number.
 * \param [in] stg       STG index.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_ing_stp_clear(int unit, bcm_stg_t stg)
{
    SHR_FUNC_ENTER(unit);

    /* Clear VLAN_ING_STG_PROFILE entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_profile_entry_clear(unit, 1, stg));

    /* Clear VLAN_ING_EGR_STG_MEMBER_PORTS_PROFILE entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_ing_egr_profile_entry_clear(unit, stg));

    /* Clear VLAN_ING_STG_PROFILE SW entry.*/
    if (STG_SW_STP_STATE_EN(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (stg_profile_entry_sw_clear(unit, 1, stg));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the state in a specified egress STG.
 *
 * \param [in] unit      Unit Number.
 * \param [in] stg       STG index.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_egr_stp_init(int unit, bcm_stg_t stg)
{
    SHR_FUNC_ENTER(unit);

    /* Initialize VLAN_EGR_STG_PROFILE entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_profile_entry_init(unit, 0, stg));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear the state in a specified egress STG.
 *
 * \param [in] unit      Unit Number.
 * \param [in] stg       STG index.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_egr_stp_clear(int unit, bcm_stg_t stg)
{
    SHR_FUNC_ENTER(unit);

    /* Clear VLAN_EGR_STG_PROFILE entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_profile_entry_clear(unit, 0, stg));

    /* Clear VLAN_EGR_STG_PROFILE SW entry.*/
    if (STG_SW_STP_STATE_EN(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (stg_profile_entry_sw_clear(unit, 0, stg));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Reset all VFI tables with default STG.
 *
 * \param [in] unit      Unit Number.
 * \param [in] stg       STG index.
 * \param [in] ingress   1-ingress or 0-egress.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_vfi_reset(int unit, bcm_stg_t stg, int ingress)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const char *tbl_name[] = {EGR_VFIs, ING_VFI_TABLEs};
    const char *key_name[] = {VFIs, VFIs};
    const char *field_name[] = {STRENGTH_PRFL_IDXs, STRENGTH_PROFILE_INDEXs};
    int rv = SHR_E_NONE;
    uint64_t value = 0;
    bcm_vlan_t vid = 0;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, tbl_name[ingress], &ent_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, ent_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, key_name[ingress], &value));

        /* Entry 0 is reserved. */
        if ((bcm_vlan_t)value == BCM_VLAN_NONE) {
            continue;
        }

        /* VFI (> BCM_VLAN_MAX) is used for VPN. */
        if ((bcm_vlan_t)value > BCM_VLAN_MAX) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vpnid_get(unit, value, &vid));
        } else {
            vid = (bcm_vlan_t)value;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(ent_hdl, field_name[ingress], &value));
            /* Ignore invalid VLAN. */
            if (value == 0) {
                continue;
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_vlan_stg_set(unit, vid, ingress, stg));
    }

    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void) bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover stg usage bitmap during warm boot.
 *
 * \param [in] unit      Unit Number.
 * \param [in] stg_bmp   Bitmap of STGs.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_bmp_recover(int unit, SHR_BITDCL *stg_bmp)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int rv = SHR_E_NONE;
    uint64_t value = 0;
    bcm_stg_t stg = 0;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, VLAN_ING_STG_PROFILEs, &ent_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, ent_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, VLAN_ING_STG_PROFILE_IDs, &value));

        stg = (bcm_stg_t)value;

        SHR_BITSET(stg_bmp, stg);
    }

    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover stg usage map during warm boot.
 *
 * \param [in] unit       Unit Number.
 * \param [in] stg_bmp    Bitmap of STGs.
 * \param [in] uidx_first First user index of STG.
 * \param [in] uidx_next  Next user index of STG.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_map_recover(int unit, SHR_BITDCL *stg_bmp, int *uidx_first, int *uidx_next)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int rv = SHR_E_NONE;
    bcm_vlan_t vid = 0;
    uint64_t value = 0;
    bcm_stg_t stg = 0;
    int dunit = 0;
    int uidx = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_VFI_TABLEs, &ent_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, ent_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, VFIs, &value));

        if (value > BCM_VLAN_MAX) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vpnid_get(unit, value, &vid));
        } else {
            vid = (bcm_vlan_t)value;
            /* vlan 0 (entry 0 in VFI table) is reserved. */
            if (vid == BCM_VLAN_NONE) {
                continue;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(ent_hdl,
                                       STRENGTH_PROFILE_INDEXs, &value));
            /* Ignore invalid VLAN. */
            if (value == 0) {
                continue;
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, SPANNING_TREE_GROUPs, &value));

        stg = (bcm_stg_t)value;

        if (SHR_BITGET(stg_bmp, stg)) {
            uidx = bcmint_stg_user_idx_get(unit, vid);
            uidx_next[uidx] = uidx_first[stg];
            uidx_first[stg]= uidx;
        }
    }

    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the STG state information.
 *
 * This function is used to initialize the STG state information.
 *
 * \param [in]  unit                 Unit Number.
 *
 * \retval SHR_E_NONE                No errors.
 * \retval !SHR_E_NONE               Failure.
 */
static int
stg_stp_state_init(int unit)
{
    stg_info_t *si = &stg_info[unit];
    bcmint_stg_stp_info_t *ha_ptr = NULL;
    uint32_t inst_size = 0;
    uint32_t array_size = 0;
    uint32_t alloc_size = 0;
    uint32_t entry_num = 0;
    uint32_t port_num = 0;
    bcm_port_t port = 0;
    uint16_t dis_flags = 0;
    int wb_flag = 0;
    int rv = 0;

    SHR_FUNC_ENTER(unit);

    si->flags |= STG_F_SW_STP_STATE;

    wb_flag = bcmi_warmboot_get(unit);
    port_num = bcmi_ltsw_dev_logic_port_max(unit) + 1;

    /* Alloc HA memory for the ingress membership in IPIPE. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, VLAN_ING_STG_PROFILEs, &entry_num));
    inst_size = sizeof(bcmint_stg_stp_info_t);
    array_size = port_num * entry_num;
    alloc_size = inst_size * array_size;
    ha_ptr =
        bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_STG,
                               BCMINT_STG_SUB_COMP_ID_HA_STP_INFO,
                               "bcmLtswStgPortState", &alloc_size);
    SHR_NULL_CHECK(ha_ptr, SHR_E_MEMORY);

    si->stp_state = ha_ptr;
    if (!wb_flag) {
        sal_memset(ha_ptr, 0, alloc_size);
    }

    rv = bcmi_ltsw_issu_struct_info_report(unit,
              BCMI_HA_COMP_ID_STG,
              BCMINT_STG_SUB_COMP_ID_HA_STP_INFO,
              0, inst_size, array_size,
              BCMINT_STG_STP_INFO_T_ID);
    if (rv != SHR_E_EXISTS) {
       if (SHR_SUCCESS(rv) && wb_flag) {
           /* ISSU case: Did not support this feature in previous version. */
           si->flags &= ~STG_F_SW_STP_STATE;
       }
       SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (STG_SW_STP_STATE_EN(unit)) {
        /* The status to disable membership check per port. */
        alloc_size = port_num * sizeof(uint8_t);
        SHR_ALLOC(si->port_dis_chk,
                  alloc_size, "bcmLtswStgDisChk");
        SHR_NULL_CHECK(si->port_dis_chk, SHR_E_MEMORY);
        sal_memset(si->port_dis_chk, 0, alloc_size);
        for (port = 0; port < port_num; port++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_stg_check_disable_get(unit, port, &dis_flags));
            if (!dis_flags) {
                continue;
            }
            if (dis_flags & BCMI_LTSW_STG_CHK_ING) {
                stg_info->port_dis_chk[port] |= STG_PORT_DIS_ING_CHK;
            }
            if (dis_flags & BCMI_LTSW_STG_CHK_ING_EGR) {
                stg_info->port_dis_chk[port] |= STG_PORT_DIS_ING_EGR_CHK;
            }
            if (dis_flags & BCMI_LTSW_STG_CHK_EGR) {
                stg_info->port_dis_chk[port] |= STG_PORT_DIS_EGR_CHK;
            }
        }
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (!wb_flag && ha_ptr) {
            (void) bcmi_ltsw_ha_mem_free(unit, ha_ptr);
            ha_ptr = NULL;
            si->stp_state = NULL;
        }
        SHR_FREE(si->port_dis_chk);
    }

    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_stg_size_get(
    int unit,
    bcm_stg_t *stg_min,
    bcm_stg_t *stg_max,
    int *vlan_count,
    int *vpn_count,
    int *vpn_offset)
{
    uint32_t min_vpn_vfi = 0;
    uint32_t max_vpn_vfi = 0;
    uint64_t min_stg = 0;
    uint64_t max_stg = 0;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, VLAN_ING_STG_PROFILEs,
                                       VLAN_ING_STG_PROFILE_IDs,
                                       &min_stg, &max_stg));
    /* Legacy behavior - Reserve Min STG(0). */
    *stg_min = (bcm_stg_t)min_stg + 1;
    *stg_max = (bcm_stg_t)max_stg;

    *vlan_count = BCM_VLAN_COUNT;

    rv = bcmi_ltsw_virtual_vfi_range_get(unit, &min_vpn_vfi, &max_vpn_vfi);
    if (rv != SHR_E_INIT) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    *vpn_count =
        (min_vpn_vfi == max_vpn_vfi) ? 0 : (max_vpn_vfi - min_vpn_vfi + 1);

    /* VLAN and VPN share the VFI spcace, there is an offset for VPN. */
    *vpn_offset = (*vpn_count) ? min_vpn_vfi : 0;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stg_vlan_set(
    int unit,
    bcm_vlan_t vid,
    bcm_stg_t stg)
{
    SHR_FUNC_ENTER(unit);

    /* Set STG in LT ING_VFI_TABLE. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_stg_set(unit, vid, 1, stg));

    /* Set STG in LT EGR_VFI. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_stg_set(unit, vid, 0, stg));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stg_vlan_get(
    int unit,
    bcm_vlan_t vid,
    bcm_stg_t *stg)
{
    SHR_FUNC_ENTER(unit);

    /* Only get STG from LT ING_VFI_TABLE since EGR_VFI has the same value. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_stg_get(unit, vid, 1, stg));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stg_stp_init(
    int unit,
    bcm_stg_t stg)
{
    SHR_FUNC_ENTER(unit);

    /* Initialize the state for ingress STG. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_ing_stp_init(unit, stg));

    /* Initialize the state for ingress STG. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_egr_stp_init(unit, stg));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stg_stp_clear(
    int unit,
    bcm_stg_t stg)
{
    SHR_FUNC_ENTER(unit);

    /* Clear the state for ingress STG. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_ing_stp_clear(unit, stg));

    /* Clear the state for ingress STG. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_egr_stp_clear(unit, stg));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stg_stp_set(
    int unit,
    bcm_stg_t stg,
    bcm_port_t port,
    int stp_state)
{
    stg_info_t *si = &stg_info[unit];
    bcm_port_t local_port = 0;
    int hw_state = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &local_port));

    if (bcmi_ltsw_port_is_type(unit, local_port, BCMI_LTSW_PORT_TYPE_CPU) ||
        bcmi_ltsw_port_is_type(unit, local_port, BCMI_LTSW_PORT_TYPE_LB)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
    }

    /*
     * Set the state for a port in ingress STG.
     * Legacy chips - Do not check egress STG state in ingress pipleline.
     * VLAN_ING_EGR_STG_PROFILE won't be touched here.
     */
    if (STG_SW_STP_STATE_EN(unit)) {
        hw_state = (si->port_dis_chk[local_port] & STG_PORT_DIS_ING_CHK) ?
                   BCM_STG_STP_FORWARD : stp_state;
    } else {
        hw_state = stp_state;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_profile_entry_set(unit, 1, stg, local_port, hw_state));

    if (STG_SW_STP_STATE_EN(unit)) {
        hw_state = (si->port_dis_chk[local_port] & STG_PORT_DIS_EGR_CHK) ?
                   BCM_STG_STP_FORWARD : stp_state;
    } else {
        hw_state = stp_state;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_profile_entry_set(unit, 0, stg, local_port, hw_state));

    /* Set SW state for STG. */
    if (STG_SW_STP_STATE_EN(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (stg_profile_entry_sw_set(unit, 1, stg, local_port, stp_state));

        SHR_IF_ERR_VERBOSE_EXIT
            (stg_profile_entry_sw_set(unit, 0, stg, local_port, stp_state));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stg_stp_get(
    int unit,
    bcm_stg_t stg,
    bcm_port_t port,
    int *stp_state)
{
    bcm_port_t local_port = 0;
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &local_port));

    if (bcmi_ltsw_port_is_type(unit, local_port, BCMI_LTSW_PORT_TYPE_CPU) ||
        bcmi_ltsw_port_is_type(unit, local_port, BCMI_LTSW_PORT_TYPE_LB)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PORT);
    }

    if (STG_SW_STP_STATE_EN(unit)) {
        /* Get the state for a port in STG from SW DB. */
        SHR_IF_ERR_VERBOSE_EXIT
            (stg_profile_entry_sw_get(unit, 1, stg, local_port, stp_state));

    } else {
        /* Get the state for a port in STG. */
        SHR_IF_ERR_VERBOSE_EXIT
            (stg_profile_entry_get(unit, 1, stg, local_port, stp_state));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stg_reinit(
    int unit,
    SHR_BITDCL *stg_bmp,
    int *uidx_first,
    int *uidx_next)
{
    SHR_FUNC_ENTER(unit);

    /* Recover stg usage bitmap. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_bmp_recover(unit, stg_bmp));

    /* Recover stg usage map. */
    SHR_IF_ERR_VERBOSE_EXIT
        (stg_map_recover(unit, stg_bmp, uidx_first, uidx_next));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stg_detach(
    int unit,
    bcm_stg_t stg)
{
    SHR_FUNC_ENTER(unit);

    if (!bcmi_warmboot_get(unit)) {
        /* Reset ING_VFI_TABLE with default STG. */
        SHR_IF_ERR_VERBOSE_EXIT
            (stg_vfi_reset(unit, stg, 0));

        /* Reset EGR_VFI with default STG. */
        SHR_IF_ERR_VERBOSE_EXIT
            (stg_vfi_reset(unit, stg, 1));

        /* Clear all entries in VLAN_ING_STG_PROFILE table. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, VLAN_ING_STG_PROFILEs));

        /* Clear all entries in VLAN_ING_EGR_STG_MEMBER_PROFILE table. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, VLAN_ING_EGR_STG_MEMBER_PROFILEs));

        /* Clear all entries in VLAN_EGR_STG_PROFILE table. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, VLAN_EGR_STG_PROFILEs));
    }

    SHR_FREE(stg_info[unit].port_dis_chk);
    sal_memset(&stg_info[unit], 0, sizeof(stg_info_t));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stg_port_check_set(
    int unit,
    bcm_port_t port,
    int disable,
    uint16_t flags)
{
    stg_info_t *si = &stg_info[unit];
    uint64_t idx_min = 0, idx_max = 0;
    uint32_t port_num = 0;
    int hw_state[2] = {0};
    int stg = 0;

    SHR_FUNC_ENTER(unit);

    if (!STG_SW_STP_STATE_EN(unit)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    port_num = bcmi_ltsw_dev_logic_port_max(unit) + 1;
    if (port >= port_num) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Currently the check of egress STG state in IPIPE is not enabled. */
    if (!(flags & BCMI_LTSW_STG_CHK_ING) &&
        !(flags & BCMI_LTSW_STG_CHK_EGR)) {
        if (flags & BCMI_LTSW_STG_CHK_ING_EGR) {
            si->port_dis_chk[port] |= STG_PORT_DIS_ING_EGR_CHK;
        }
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, VLAN_ING_STG_PROFILEs,
                                       VLAN_ING_STG_PROFILE_IDs,
                                       &idx_min, &idx_max));

    for (stg = (int)idx_min; stg <= (int)idx_max; stg++) {

        if (!bcmint_stg_exist_check(unit, stg)) {
            continue;
        }

        if (disable) {
            /* Set forward state for disable case. */
            hw_state[0] = BCM_STG_STP_FORWARD;
            hw_state[1] = BCM_STG_STP_FORWARD;
        } else {
            /* Trust the information configured by STG APIs. */
            if (flags & BCMI_LTSW_STG_CHK_ING) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (stg_profile_entry_sw_get(unit, 1, stg,
                                              port, &hw_state[1]));
            }
            if (flags & BCMI_LTSW_STG_CHK_EGR) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (stg_profile_entry_sw_get(unit, 0, stg,
                                              port, &hw_state[0]));
            }
        }

        if (flags & BCMI_LTSW_STG_CHK_ING) {
            SHR_IF_ERR_VERBOSE_EXIT
                (stg_profile_entry_set(unit, 1, stg, port, hw_state[1]));
        }
        if (flags & BCMI_LTSW_STG_CHK_EGR) {
            SHR_IF_ERR_VERBOSE_EXIT
                (stg_profile_entry_set(unit, 0, stg, port, hw_state[0]));
        }
    }

    if (flags & BCMI_LTSW_STG_CHK_ING) {
        if (disable) {
            si->port_dis_chk[port] |= STG_PORT_DIS_ING_CHK;
        } else {
            si->port_dis_chk[port] &= ~STG_PORT_DIS_ING_CHK;
        }
    }
    if (flags & BCMI_LTSW_STG_CHK_ING_EGR) {
        if (disable) {
            si->port_dis_chk[port] |= STG_PORT_DIS_ING_EGR_CHK;
        } else {
            si->port_dis_chk[port] &= ~STG_PORT_DIS_ING_EGR_CHK;
        }
    }
    if (flags & BCMI_LTSW_STG_CHK_EGR) {
        if (disable) {
            si->port_dis_chk[port] |= STG_PORT_DIS_EGR_CHK;
        } else {
            si->port_dis_chk[port] &= ~STG_PORT_DIS_EGR_CHK;
        }
    }
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stg_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_FREE(stg_info[unit].port_dis_chk);
    sal_memset(&(stg_info[unit]), 0, sizeof(stg_info_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (stg_stp_state_init(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stg_info_dump(int unit)
{
    stg_info_t *si = &stg_info[unit];
    int dis_flg[] = {STG_PORT_DIS_ING_CHK, STG_PORT_DIS_EGR_CHK};
    char *state_name[] = {"INVALID", "DISABLE", "BLOCK", "LEARN", "FORWARD"};
    uint64_t idx_min = 0;
    uint64_t idx_max = 0;
    uint32_t port_num = 0;
    int i = 0, offset = 0, mismatch = 0;
    int pre_state = 0, state = 0;
    int sw_state = 0, hw_state = 0;
    int stg = 0, port = 0;

    SHR_FUNC_ENTER(unit);

    LOG_CLI((BSL_META_U(unit,
                        "\nSTG XFS SW Information - Unit %d\n"), unit));

    LOG_CLI((BSL_META_U(unit,
                        "    STP SW State Enabled: %4d\n"),
                        STG_SW_STP_STATE_EN(unit)));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, VLAN_ING_STG_PROFILEs,
                                       VLAN_ING_STG_PROFILE_IDs,
                                       &idx_min, &idx_max));

    port_num = bcmi_ltsw_dev_logic_port_max(unit) + 1;

    for (i = 0; i < COUNTOF(dis_flg); i++) {
        if (!STG_SW_STP_STATE_EN(unit)) {
            break;
        }
        if (dis_flg[i] == STG_PORT_DIS_ING_CHK) {
            LOG_CLI((BSL_META_U(unit,
                                "    VLAN_ING_STG_PROFILE:  \n")));
        } else {
            LOG_CLI((BSL_META_U(unit,
                                "    VLAN_EGR_STG_PROFILE:  \n")));
        }

        for (stg = (int)idx_min; stg <= (int)idx_max; stg++) {
            if (!bcmint_stg_exist_check(unit, stg)) {
                continue;
            }
            mismatch = 0;
            LOG_CLI((BSL_META_U(unit,
                                "    Entry = %4d: [0"), stg));
            offset = port_num * stg;
            pre_state = 0;
            for (port = 0; port < port_num; port++) {

                if (dis_flg[i] == STG_PORT_DIS_ING_CHK) {
                    state = si->stp_state[offset + port].ing_state;
                } else {
                    state = si->stp_state[offset + port].egr_state;
                }
                if ((pre_state != state) && (port != 0)) {
                    LOG_CLI((BSL_META_U(unit,
                                        "-%d]=%s [%d"), port - 1,
                                        state_name[pre_state], port));
                }
                if (port + 1 == port_num) {
                     if (pre_state == state) {
                         LOG_CLI((BSL_META_U(unit, "-%d"), port));
                     }
                     LOG_CLI((BSL_META_U(unit, "]=%s"), state_name[state]));
                }
                pre_state = state;

                SHR_IF_ERR_VERBOSE_EXIT
                    (stg_profile_entry_sw_get(
                        unit, (dis_flg[i] == STG_PORT_DIS_ING_CHK) ? 1 : 0,
                        stg, port, &sw_state));
                SHR_IF_ERR_VERBOSE_EXIT
                    (stg_profile_entry_get(
                        unit, (dis_flg[i] == STG_PORT_DIS_ING_CHK) ? 1 : 0,
                        stg, port, &hw_state));
                if (sw_state != hw_state) {
                    if (!(si->port_dis_chk[port] & dis_flg[i])) {
                        mismatch = 1;
                    }
                }
            }
            LOG_CLI((BSL_META_U(unit, "\n")));
            if (mismatch) {
                LOG_CLI((BSL_META_U(unit,
                                    "      Mismatched Entry = %4d\n"), stg));
            }
        }
    }

    if (STG_SW_STP_STATE_EN(unit)) {
        LOG_CLI((BSL_META_U(unit,
                            "\n  Disable state of STG check:  \n")));
        for (port = 0; port < port_num; port++) {
            if (si->port_dis_chk[port]) {
                LOG_CLI((BSL_META_U(unit,
                                    "    port = %4d: flags = %x\n"),
                                    port, si->port_dis_chk[port]));
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

