/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/qos.h>
#include <bcm/port.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/qos_int.h>
#include <bcm_int/ltsw/xfs/qos.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/sbr.h>
#include <bcm_int/ltsw/mbcm/qos.h>
#include <bcm_int/ltsw/issu.h>
#include <bcm_int/ltsw/generated/qos_ha.h>

#include <sal/sal_types.h>
#include <shr/shr_bitop.h>
#include <bsl/bsl.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>
#include <bcmlt/bcmlt.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_QOS

/*! Ingress map type count. */
#define QOS_ING_MAP_TYPE_COUNT 3

/*! Egress map type count. */
#define QOS_EGR_MAP_TYPE_COUNT 14

/*! QoS map shift. */
#define QOS_MAP_SHIFT 16

/*! QoS remarking base shift. */
#define QOS_REMARK_BASE_SHIFT 4

/*! QoS map id mask. */
#define QOS_MAP_ID_MASK ((1 << QOS_MAP_SHIFT) - 1)

/*! QoS remarking table number. */
#define QOS_REMARK_TABLE_NUM 12

/*! Reserved L2 QoS map id. */
#define QOS_RSVD_L2_MAP_ID 0

/*! Reserved L3 QoS map id. */
#define QOS_RSVD_L3_MAP_ID 0

/*!
 * \brief HA sub component id. Note that the value of each macro cannot be changed.
 */
/*! L2 ingress map used bitmap. */
#define QOS_SUBCOMPID_L2_ING_USED_BMP 0

/*! L3 ingress map used bitmap. */
#define QOS_SUBCOMPID_L3_ING_USED_BMP 1

/*! MPLS ingress map used bitmap. */
#define QOS_SUBCOMPID_MPLS_ING_USED_BMP 2

/*! L2 egress map used bitmap. */
#define QOS_SUBCOMPID_L2_EGR_USED_BMP 3

/*! L3 egress map used bitmap. */
#define QOS_SUBCOMPID_L3_EGR_USED_BMP 4

/*! MPLS egress map used bitmap. */
#define QOS_SUBCOMPID_MPLS_EGR_USED_BMP 5

/*! Forwarding ECN egress map used bitmap. */
#define QOS_SUBCOMPID_FWD_ECN_EGR_USED_BMP 6

/*! Forwarding ECN/DSCP egress map used bitmap. */
#define QOS_SUBCOMPID_FWD_ECN_DSCP_EGR_USED_BMP 7

/*! Tunnel ECN egress map used bitmap. */
#define QOS_SUBCOMPID_TNL_ECN_EGR_USED_BMP 8

/*! Tunnel ECN/DSCP egress map used bitmap. */
#define QOS_SUBCOMPID_TNL_ECN_DSCP_EGR_USED_BMP 9

/*! MPLS tunnel egress map used bitmap. */
#define QOS_SUBCOMPID_MPLS_TNL_EGR_USED_BMP 10

/*! Vxlan tunnel flags egress map used bitmap. */
#define QOS_SUBCOMPID_VXLAN_TNL_FLAGS_EGR_USED_BMP 11

/*! Copied L2 egress map used bitmap. */
#define QOS_SUBCOMPID_COPIED_L2_EGR_USED_BMP 12

/*! Copied L3 egress map used bitmap. */
#define QOS_SUBCOMPID_COPIED_L3_EGR_USED_BMP 13

/*! Copied ECN egress map used bitmap. */
#define QOS_SUBCOMPID_COPIED_ECN_EGR_USED_BMP 14

/*! Copied L3 ECN egress map used bitmap. */
#define QOS_SUBCOMPID_COPIED_L3_ECN_EGR_USED_BMP 15

/*! Internal congestion copy egress map used bitmap. */
#define QOS_SUBCOMPID_INT_CONGESTION_COPY_EGR_USED_BMP 16

/*! Table index mapping for L2 egress map. */
#define QOS_SUBCOMPID_TBLIDX_L2_EGRESS 30

/*! Table index mapping for L3 egress map. */
#define QOS_SUBCOMPID_TBLIDX_L3_EGRESS 31

/*! Table index mapping for mpls egress map. */
#define QOS_SUBCOMPID_TBLIDX_MPLS_EGRESS 32

/*! Table index mapping for forwarding ECN egress map. */
#define QOS_SUBCOMPID_TBLIDX_FWD_ECN_EGRESS 33

/*! Table index mapping for forwarding ECN/DSCP egress map. */
#define QOS_SUBCOMPID_TBLIDX_FWD_ECN_DSCP_EGRESS 34

/*! Table index mapping for tunnel ECN egress map. */
#define QOS_SUBCOMPID_TBLIDX_TNL_ECN_EGRESS 35

/*! Table index mapping for tunnel ECN/DSCP egress map. */
#define QOS_SUBCOMPID_TBLIDX_TNL_ECN_DSCP_EGRESS 36

/*! Table index mapping for MPLS tunnel egress map. */
#define QOS_SUBCOMPID_TBLIDX_MPLS_TNL_EGRESS 37

/*! Table index mapping for Vxlan tunnel flags egress map. */
#define QOS_SUBCOMPID_TBLIDX_VXLAN_TNL_FLAGS_EGRESS 38

/*! Table index mapping for copied L2 egress map. */
#define QOS_SUBCOMPID_TBLIDX_COPIED_L2_EGRESS 39

/*! Table index mapping for copied L3 egress map. */
#define QOS_SUBCOMPID_TBLIDX_COPIED_L3_EGRESS 40

/*! Table index mapping for copied ECN egress map. */
#define QOS_SUBCOMPID_TBLIDX_COPIED_ECN_EGRESS 41

/*! Table index mapping for copied L3 ECN egress map. */
#define QOS_SUBCOMPID_TBLIDX_COPIED_L3_ECN_EGRESS 42

/*! Table index mapping for internal congestion copy egress map. */
#define QOS_SUBCOMPID_TBLIDX_INT_CONGESTION_COPY_EGRESS 43

/*! Remarking table chunk information. */
#define QOS_SUBCOMPID_REMARK_TBL_CHUNK 60

/*! DOT1P remarking pointer for egress L2 oif. */
#define QOS_SUBCOMPID_EGR_L2_OIF_DOT1P_PTR 61

/*! Default pointer for QoS map. */
#define QOS_SUBCOMPID_DEF_QOS_PTR 62

/*!
 * \brief QoS map type. Note every new enum must be put following the last valid one.
 */
typedef enum qos_xfs_map_type_s {

    /*! Map dot1p pri/cfi to internal priority/cng. */
    QoSMapTypeL2Ingress = 0,

    /*! Map DSCP of IP packet to internal priority/cng. */
    QoSMapTypeL3Ingress = 1,

    /*! Map Exp of MPLS packet to internal priority/cng. */
    QoSMapTypeMplsIngress = 2,

    /*! Map internal priority/cng to dot1p pri/cfi. */
    QoSMapTypeL2Egress = 3,

    /*! Map internal priority/cng to DSCP of IP packet. */
    QoSMapTypeL3Egress = 4,

    /*! Map internal priority/cng to swap EXP of MPLS packet on transit point. */
    QoSMapTypeMplsEgress = 5,

    /*! Map internal CN to forwarding ECN. */
    QoSMapTypeFwdEcnEgress = 6,

    /*! Map internal priority/cng to forwarding DSCP, at the same time map the internal CN to forwarding ECN. */
    QoSMapTypeFwdEcnDscpEgress = 7,

    /*! Map internal CN to tunnel ECN. */
    QoSMapTypeTnlEcnEgress = 8,

    /*! Map internal priority/cng to tunnel DSCP, at the same time map the internal CN to tunnel ECN. */
    QoSMapTypeTnlEcnDscpEgress = 9,

    /*! Map internal CN/internal priority/cng to tunnel label EXPs of MPLS packet on tunnel initiation. */
    QoSMapTypeMplsTnlEgress = 10,

    /*! Map Vxlan gbp valid flag to G flag, and map fwd_type to BUM flag on Vxlan tunnel initiation. */
    QoSMapTypeVxlanTnlFlagsEgress = 11,

    /*! Map packet pri and cfi copied from IPIPE to outgoing packet pri and cfi. */
    QoSMapTypeCopiedL2Egress = 12,

    /*! Map DSCP copied from IPIPE  to outgoing packet DSCP. */
    QoSMapTypeCopiedL3Egress = 13,

    /*! Map ECN copied from IPIPE  to outgoing packet ECN. */
    QoSMapTypeCopiedEcnEgress = 14,

    /*! Map DSCP copied from IPIPE to outgoing packet DSCP, and at the same time map ECN copied from IPIPE to outgoing  packet ECN. */
    QoSMapTypeCopiedL3EcnEgress = 15,

    /*! Copy qos_ctrl_0 into internal congestion at egress. */
    QoSMapTypeIntCongestionCopyEgress = 16,

    /*! The count of map type, must be the last. */
    QoSMapTypeCount = 17

} qos_xfs_map_type_t;

#define QOS_XFS_MAP_TYPE_STR \
{ \
    "L2Ingress", \
    "L3Ingress", \
    "MplsIngress", \
    "L2Egress", \
    "L3Egress", \
    "MplsEgress", \
    "FwdEcnEgress", \
    "FwdEcnDscpEgress", \
    "TnlEcnEgress", \
    "TnlEcnDscpEgress", \
    "MplsTnlEgress", \
    "VxlanTnlFlagsEgress", \
    "CopiedL2Egress", \
    "CopiedL3Egress", \
    "CopiedEcnEgress", \
    "CopiedL3EcnEgress", \
    "IntCongestionCopyEgress" \
}

/*!
 * \brief Remarking table chunk usage mode.
 */
typedef enum qos_remark_chunk_mode_s {

    /*! None. */
    QoSChunkModeNone = 0,

    /*! 2 bits mode, occupying 4 entries in the chunk per map set. */
    QoSChunkMode2Bits = 1,

    /*! 6 bits mode, occupying 64 entries in the chunk per map set. */
    QoSChunkMode6Bits = 2,

    /*! 8 bits mode, occupying 256 entries in the chunk per map set. */
    QoSChunkMode8Bits = 3,

    /*! 4 bits mode, occupying 16 entries in the chunk per map set. */
    QoSChunkMode4Bits = 4,

    /*! The count of mode, must be the last. */
    QoSChunkModeCount = 5

} qos_remark_chunk_mode_t;

#define QOS_REMARK_CHUNK_MODE_STR \
{ \
    "None", \
    "2Bits", \
    "6Bits", \
    "8Bits", \
    "4Bits" \
}

/*!
 * \brief QoS remarking table configuration data structure.
 */
typedef struct qos_remark_table_cfg_s {

    /*! Table chunk configuration. */
    qos_remark_table_chunk_t *chunk;

    /*! Overlay table means it can be used by multi QoS map types. */
    int overlay;

} qos_remark_table_cfg_t;

/*!
 * \brief QoS configuration data structure.
 */
typedef struct qos_cfg_s {

    /*! QoS L2/L3/MPLS block size for ingress QoS map. */
    int blk_sz[QOS_ING_MAP_TYPE_COUNT];

    /*! QoS map id size for all supported map types. */
    int map_sz[QoSMapTypeCount];

    /*! Used bitmap for QoS map id. */
    SHR_BITDCL *bmp[QoSMapTypeCount];

    /*! Remarking Table configuration. */
    qos_remark_table_cfg_t remark_table[QOS_REMARK_TABLE_NUM];

    /*! Table index mapping for QoS egress map. */
    int *tbl_index[QOS_EGR_MAP_TYPE_COUNT];

    /*! Default pointer for QoS map(Only L2 ingres/egress and L3 ingress are available). */
    int *def_ptr;

    /*! DOT1P remarking pointer for egress L2 oif. */
    int *egr_l2_oif_dot1p_ptr;

    /*! QoS control info. */
    const bcmint_qos_ctrl_info_t *ctrl_info;

} qos_cfg_t;

/*!
 * \brief QoS map table size. Total size is limited to 2K as a WAR of SDKLT-5432.
 */
/*! Table size for L2 block. */
#define QOS_MAP_L2_BLK_DEF_SIZE 4096

/*! Table size for L3 block. */
#define QOS_MAP_L3_BLK_DEF_SIZE 10240

/*! Table size for MPLS block. */
#define QOS_MAP_MPLS_BLK_DEF_SIZE 2048

/*! Total size of QoS map table. */
#define QOS_MAP_MAX_SIZE 16384

/*!
 * \brief QoS map set size.
 */
/*! Entry size in one L2 map set. */
#define QOS_MAP_SET_SIZE_L2 16

/*! Entry size in one L3 map set. */
#define QOS_MAP_SET_SIZE_L3 64

/*! Entry size in one MPLS map set. */
#define QOS_MAP_SET_SIZE_MPLS 8

/*! QoS remark set size(int_pri, cng). */
#define QOS_REMARK_INT_PRI_CNG_SET_SIZE 64

/*! QoS remark set size(int_cn). */
#define QOS_REMARK_INT_CN_SET_SIZE 4

/*! QoS remark set size(int_cn, int_pri, cng). */
#define QOS_REMARK_INT_CN_INT_PRI_CNG_SET_SIZE 256

/*! Minimum QoS remark set size. */
#define QOS_REMARK_MIN_SET_SIZE 16

/*! QoS remark set size for Vxlan flags remarking. */
#define QOS_REMARK_VXLAN_TNL_FLAGS_SET_SIZE 16

/*! QoS remark chunk size. */
#define QOS_REMARK_CHUNK_SIZE QOS_REMARK_INT_CN_INT_PRI_CNG_SET_SIZE

/*! QoS remark table size. */
#define QOS_REMARK_TABLE_SIZE 4096

/*! QoS remark table chunk number. */
#define QOS_REMARK_CHUNK_NUM (QOS_REMARK_TABLE_SIZE/QOS_REMARK_CHUNK_SIZE)

/*!
 * \brief Packet QoS field mask.
 */
/*! Packet priority mask. */
#define QOS_PKT_PRI_MASK 0x7

/*! Packet CFI mask. */
#define QOS_PKT_CFI_MASK 0x1

/*! Packet DSCP mask. */
#define QOS_PKT_DSCP_MASK 0x3f

/*! Packet EXP mask. */
#define QOS_PKT_EXP_MASK 0x7

/*! Packet ECN mask. */
#define QOS_PKT_ECN_MASK 0x3

/*! QoS internal priority mask. */
#define QOS_INT_PRI_MASK 0xf

/*! QoS internal CNG mask. */
#define QOS_INT_CNG_MASK 0x3

/*! QoS internal CN mask. */
#define QOS_INT_CN_MASK 0x3

/*!
 * \brief QoS ingress mapping strength definitions.
 */
/*! Strength profile table index for INT_PRI. */
#define QOS_ING_STR_INT_PRI_PRF_IDX 0x7

/*! Strength profile table index for CNG. */
#define QOS_ING_STR_CNG_PRF_IDX 0x6

/*! Mapped value strength. */
#define QOS_ING_STR_MAP_VALUE 0x7

/*! Policy value strength. */
#define QOS_ING_STR_POLICY_VALUE 0x5

/*! Bus value strength. */
#define QOS_ING_STR_BUS_VALUE 0x6

/******************************************************************************
 * Private functions
 */


/*
 * Encode mode, indicates how to encode packet QoS field into int_pri/cng in
 * the IPIPE or how to encode int_pri/cng/int_cn into QoS field in the EPIPE.
 */
typedef enum qos_table_encode_mode_e {
    /* None. */
    QoSEncodeModeNone = 0,

    /* Encode packet dot1p and cfi into int_pri/cng in IPIPE. */
    QoSEncodeModeIngDot1pCfi = 1,

    /* Encode packet dscp into int_pri/cng in IPIPE. */
    QoSEncodeModeIngDscp = 2,

    /* Encode packet exp into int_pri/cng in IPIPE. */
    QoSEncodeModeIngExp = 3,

    /* Encode intpri_cng into packet dot1p and cfi in EPIPE. */
    QoSEncodeModeEgrDot1pCfi = 4,

    /* Encode intpri_cng into packet dscp in EPIPE. */
    QoSEncodeModeEgrDscp = 5,

    /* Encode intcn_intpri_cng into packet swap exp in EPIPE. */
    QoSEncodeModeEgrExp = 6,

    /* Encode int_cn into packet forwarding(payload) ecn in EPIPE. */
    QoSEncodeModeEgrFwdEcn = 7,

    /* Encode int_cn, responsive into packet tunnel ecn in EPIPE. */
    QoSEncodeModeEgrTnlEcn = 8,

    /* Encode intcn_intpri_cng into packet tunnel EXP0 in EPIPE. */
    QoSEncodeModeEgrTnlExp0 = 9,

    /* Encode intcn_intpri_cng into packet tunnel EXP1 in EPIPE. */
    QoSEncodeModeEgrTnlExp1 = 10,

    /* Encode intcn_intpri_cng into packet tunnel EXP2 in EPIPE. */
    QoSEncodeModeEgrTnlExp2 = 11,

    /* Encode intcn_intpri_cng into packet tunnel EXP3 in EPIPE. */
    QoSEncodeModeEgrTnlExp3 = 12,

    /* Encode intcn_intpri_cng into packet tunnel EXP4 in EPIPE. */
    QoSEncodeModeEgrTnlExp4 = 13,

    /* Encode intcn_intpri_cng into packet tunnel EXP5 in EPIPE. */
    QoSEncodeModeEgrTnlExp5 = 14,

    /* Encode intcn_intpri_cng into packet tunnel EXP6(outermost) in EPIPE. */
    QoSEncodeModeEgrTnlExp6 = 15,

    /* Encode vxlan_gbp_valid into G flag for VXLAN GBP in EPIPE. */
    QoSEncodeModeEgrVxlanGFlag = 16,

    /* Encode fwd_type_extended into BUM flag for VXLAN GBP in EPIPE. */
    QoSEncodeModeEgrVxlanBUMFlag = 17,

    /* Encode packet priority and cfi copied from IPIPE into packet priority and cfi in EPIPE. */
    QoSEncodeModeEgrCopiedDot1pCfi = 18,

    /* Encode packet dscp copied from IPIPE into packet dscp in EPIPE. */
    QoSEncodeModeEgrCopiedDscp = 19,

    /* Encode packet ecn copied from IPIPE into packet ecn in EPIPE. */
    QoSEncodeModeEgrCopiedEcn = 20,

    /* The last mode, invalid. */
    QoSEncodeModeCount = 21,
} qos_table_encode_mode_t;

/*
 * QoS table structure.
 */
typedef struct qos_table_s {

    /* QoS map type. */
    qos_xfs_map_type_t type;

    /* Table count. */
    int count;

    /* Remarking table id array. */
    int remark_tbl_id[QOS_REMARK_TABLE_NUM];

    /* Encode mode of QoS tables. */
    qos_table_encode_mode_t mode[QOS_REMARK_TABLE_NUM];

    /* QoS flags. */
    uint32_t flags;

} qos_table_t;

static qos_cfg_t qos_cfg[BCM_MAX_NUM_UNITS];

/* QoS config. */
#define QOS_CFG(unit) (&qos_cfg[unit])

/* QoS map used bitmap. */
#define QOS_MAP_BMP(unit, type) \
            (QOS_CFG(unit)->bmp[type])

/* Get QoS map used bitmap. */
#define QOS_MAP_BMP_USED_GET(unit, type, id) \
            (SHR_BITGET(QOS_MAP_BMP(unit, type), id))

/* Set QoS map used bitmap. */
#define QOS_MAP_BMP_USED_SET(unit, type, id) \
            (SHR_BITSET(QOS_MAP_BMP(unit, type), id))

/* Clear QoS map used bitmap. */
#define QOS_MAP_BMP_USED_CLR(unit, type, id) \
            (SHR_BITCLR(QOS_MAP_BMP(unit, type), id))

/* QoS egress map table index mapping. */
#define QOS_EGR_TBL_IDX(unit, type, id) \
            (QOS_CFG(unit)->tbl_index[type - QoSMapTypeL2Egress][id])

/* QoS control info. */
#define QOS_CTRL_INFO(unit) (QOS_CFG(unit)->ctrl_info)

/* All Remarking tables. */
#define QOS_REMARK_TABLE_ALL \
            FLEX_QOS_EGR_PHB_0s, \
            FLEX_QOS_EGR_PHB_1s, \
            FLEX_QOS_EGR_PHB_2s, \
            FLEX_QOS_EGR_PHB_3s, \
            FLEX_QOS_EGR_PHB_4s, \
            FLEX_QOS_EGR_PHB_5s, \
            FLEX_QOS_EGR_PHB_6s, \
            FLEX_QOS_EGR_PHB_7s, \
            FLEX_QOS_EGR_PHB_8s, \
            FLEX_QOS_EGR_PHB_9s, \
            FLEX_QOS_EGR_PHB_10s, \
            FLEX_QOS_EGR_PHB_11s

/* QoS mapping table name. */
static const char *qos_map_tbl_name = FLEX_QOS_ING_PHBs;

/* QoS remarking table name. */
static const char *qos_remark_tbl_name[QOS_REMARK_TABLE_NUM] = \
                    {QOS_REMARK_TABLE_ALL};

/*
 * QoS remarking table id definitions.
 */
/* Table id n for FLEX_QOS_EGR_PHB_n. */
#define QRT(n) (n)

/* Invalid table id. */
#define QRT_INVALID (-1)

/* QoS table. */
static qos_table_t qos_table[] = { \
    [QoSMapTypeL2Ingress] = {
        .type = QoSMapTypeL2Ingress,
        .count = 1,
        .mode = {QoSEncodeModeIngDot1pCfi},
        .flags = BCM_QOS_MAP_L2 | BCM_QOS_MAP_INGRESS,
    },
    [QoSMapTypeL3Ingress] = {
        .type = QoSMapTypeL3Ingress,
        .count = 1,
        .mode = {QoSEncodeModeIngDscp},
        .flags = BCM_QOS_MAP_L3 | BCM_QOS_MAP_INGRESS,
    },
    [QoSMapTypeMplsIngress] = {
        .type = QoSMapTypeMplsIngress,
        .count = 1,
        .mode = {QoSEncodeModeIngExp},
        .flags = BCM_QOS_MAP_MPLS | BCM_QOS_MAP_INGRESS,
    },
    [QoSMapTypeL2Egress] = {
        .type = QoSMapTypeL2Egress,
        .count = 3,
        .remark_tbl_id = {QRT(0), QRT(1), QRT(4), QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrDot1pCfi, QoSEncodeModeEgrDot1pCfi,
                 QoSEncodeModeEgrDot1pCfi},
        .flags = BCM_QOS_MAP_L2 | BCM_QOS_MAP_EGRESS,
    },
    [QoSMapTypeL3Egress] = {
        .type = QoSMapTypeL3Egress,
        .count = 2,
        .remark_tbl_id = {QRT(2), QRT(5), QRT(3), QRT(6), \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrDscp, QoSEncodeModeEgrDscp, \
                 /* Only reserve, not program. */ \
                 QoSEncodeModeNone, QoSEncodeModeNone},
        .flags = BCM_QOS_MAP_L3 | BCM_QOS_MAP_EGRESS,
    },
    [QoSMapTypeMplsEgress] = {
        .type = QoSMapTypeMplsEgress,
        .count = 1,
        .remark_tbl_id = {QRT(11), QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrExp},
        .flags = BCM_QOS_MAP_MPLS | BCM_QOS_MAP_EGRESS,
    },
    [QoSMapTypeFwdEcnEgress] = {
        .type = QoSMapTypeFwdEcnEgress,
        .count = 1,
        .remark_tbl_id = {QRT(3), QRT(2), QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrFwdEcn, QoSEncodeModeNone},
        .flags = BCM_QOS_MAP_ECN | BCM_QOS_MAP_EGRESS,
    },
    [QoSMapTypeFwdEcnDscpEgress] =
    {
        .type = QoSMapTypeFwdEcnDscpEgress,
        .count = 2,
        .remark_tbl_id = {QRT(2), QRT(3), QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrDscp, QoSEncodeModeEgrFwdEcn},
        .flags = BCM_QOS_MAP_ECN | BCM_QOS_MAP_L3 | BCM_QOS_MAP_EGRESS,
    },
    [QoSMapTypeTnlEcnEgress] = {
        .type = QoSMapTypeTnlEcnEgress,
        .count = 1,
        .remark_tbl_id = {QRT(6), QRT(5), QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrTnlEcn, QoSEncodeModeNone},
        .flags = BCM_QOS_MAP_ECN | BCM_QOS_MAP_ENCAP | BCM_QOS_MAP_EGRESS,
    },
    [QoSMapTypeTnlEcnDscpEgress] = {
        .type = QoSMapTypeTnlEcnDscpEgress,
        .count = 2,
        .remark_tbl_id = {QRT(5), QRT(6), QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrDscp, QoSEncodeModeEgrTnlEcn},
        .flags = BCM_QOS_MAP_ECN | BCM_QOS_MAP_ENCAP | BCM_QOS_MAP_L3 | \
                 BCM_QOS_MAP_EGRESS,
    },
    [QoSMapTypeMplsTnlEgress] = {
        .type = QoSMapTypeMplsTnlEgress,
        .count = 8,
        .remark_tbl_id = {QRT(3), QRT(4), QRT(5), QRT(6), QRT(7), QRT(8), \
                          QRT(9), QRT(10), QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrTnlExp0, QoSEncodeModeEgrTnlExp0, \
                 QoSEncodeModeEgrTnlExp1, QoSEncodeModeEgrTnlExp2, \
                 QoSEncodeModeEgrTnlExp3, QoSEncodeModeEgrTnlExp4, \
                 QoSEncodeModeEgrTnlExp5, QoSEncodeModeEgrTnlExp6},
        .flags = BCM_QOS_MAP_MPLS | BCM_QOS_MAP_EGRESS | BCM_QOS_MAP_ENCAP,
    },
    [QoSMapTypeVxlanTnlFlagsEgress] = {
        .type = QoSMapTypeVxlanTnlFlagsEgress,
        .count = 2,
        .remark_tbl_id = {QRT(7), QRT(8), QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrVxlanGFlag, QoSEncodeModeEgrVxlanBUMFlag},
    },
    [QoSMapTypeCopiedL2Egress] = {
        .type = QoSMapTypeCopiedL2Egress,
        .count = 3,
        .remark_tbl_id = {QRT(0), QRT(1), QRT(4), QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrCopiedDot1pCfi, QoSEncodeModeEgrCopiedDot1pCfi,
                 QoSEncodeModeEgrCopiedDot1pCfi},
        .flags = BCM_QOS_MAP_L2 | BCM_QOS_MAP_EGRESS |
                 BCM_QOS_MAP_INGRESS_COPIED,
    },
    [QoSMapTypeCopiedL3Egress] = {
        .type = QoSMapTypeCopiedL3Egress,
        .count = 1,
        .remark_tbl_id = {QRT(2), QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrCopiedDscp},
        .flags = BCM_QOS_MAP_L3 | BCM_QOS_MAP_EGRESS |
                 BCM_QOS_MAP_INGRESS_COPIED,
    },
    [QoSMapTypeCopiedEcnEgress] = {
        .type = QoSMapTypeCopiedEcnEgress,
        .count = 1,
        .remark_tbl_id = {QRT(3), QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrCopiedEcn},
        .flags = BCM_QOS_MAP_ECN | BCM_QOS_MAP_EGRESS |
                 BCM_QOS_MAP_INGRESS_COPIED,
    },
    [QoSMapTypeCopiedL3EcnEgress] = {
        .type = QoSMapTypeCopiedL3EcnEgress,
        .count = 4,
        .remark_tbl_id = {QRT(2), QRT(3), QRT(5), QRT(6), \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
        .mode = {QoSEncodeModeEgrCopiedDscp, QoSEncodeModeEgrCopiedEcn,
                 QoSEncodeModeEgrCopiedDscp, QoSEncodeModeEgrCopiedEcn},
        .flags = BCM_QOS_MAP_ECN | BCM_QOS_MAP_L3 | BCM_QOS_MAP_EGRESS |
                 BCM_QOS_MAP_INGRESS_COPIED,
    },
    [QoSMapTypeIntCongestionCopyEgress] = {
        .type = QoSMapTypeIntCongestionCopyEgress,
        .count = 1,
        .remark_tbl_id = {QRT(11), QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID, \
                          QRT_INVALID, QRT_INVALID, QRT_INVALID, QRT_INVALID},
    },
};

/* QoS map is ingress map type. */
#define QOS_MAP_IS_ING_TYPE(type) \
            (type == QoSMapTypeL2Ingress || \
             type == QoSMapTypeL3Ingress || \
             type == QoSMapTypeMplsIngress)

/* QoS map is egress map type. */
#define QOS_MAP_IS_EGR_TYPE(type) \
            (type == QoSMapTypeL2Egress || \
             type == QoSMapTypeL3Egress || \
             type == QoSMapTypeMplsEgress || \
             type == QoSMapTypeFwdEcnEgress || \
             type == QoSMapTypeTnlEcnEgress || \
             type == QoSMapTypeFwdEcnDscpEgress || \
             type == QoSMapTypeTnlEcnDscpEgress || \
             type == QoSMapTypeMplsTnlEgress || \
             type == QoSMapTypeCopiedL2Egress || \
             type == QoSMapTypeCopiedL3Egress || \
             type == QoSMapTypeCopiedEcnEgress || \
             type == QoSMapTypeCopiedL3EcnEgress || \
             type == QoSMapTypeIntCongestionCopyEgress)

/*
 * The map type is a combined type, which means it
 * can implement several functionalities at the same time, i.e,
 * QoSMapTypeFwdEcnDscpEgress can map internal priority/CNG to DSCP, and map
 * internal CN to ECN simultaneously.
 * Such map type needs to program sevaral tables, and use different packet
 * fields to calculate table index.
 */
#define QOS_MAP_IS_COMBINED_TYPE(type) \
            (type == QoSMapTypeFwdEcnDscpEgress || \
             type == QoSMapTypeTnlEcnDscpEgress || \
             type == QoSMapTypeMplsTnlEgress || \
             type == QoSMapTypeCopiedL3EcnEgress)

/*!
 * \brief Get map set size.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [out] size Map set size.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_set_size_get(int unit, qos_xfs_map_type_t type, int *size)
{
    int size_tmp = 0;
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case QoSMapTypeL2Ingress:
        case QoSMapTypeCopiedL2Egress:
            size_tmp = QOS_MAP_SET_SIZE_L2;
            break;
        case QoSMapTypeL3Ingress:
        case QoSMapTypeCopiedL3Egress:
        case QoSMapTypeCopiedL3EcnEgress:
            size_tmp = QOS_MAP_SET_SIZE_L3;
            break;
        case QoSMapTypeMplsIngress:
            size_tmp = QOS_MAP_SET_SIZE_MPLS;
            break;
        case QoSMapTypeL2Egress:
        case QoSMapTypeL3Egress:
        case QoSMapTypeTnlEcnEgress:
        case QoSMapTypeFwdEcnDscpEgress:
        case QoSMapTypeTnlEcnDscpEgress:
            size_tmp = QOS_REMARK_INT_PRI_CNG_SET_SIZE;
            break;
        case QoSMapTypeFwdEcnEgress:
        case QoSMapTypeCopiedEcnEgress:
            size_tmp = QOS_REMARK_INT_CN_SET_SIZE;
            break;
        case QoSMapTypeMplsEgress:
        case QoSMapTypeMplsTnlEgress:
            size_tmp = QOS_REMARK_INT_CN_INT_PRI_CNG_SET_SIZE;
            break;
        case QoSMapTypeVxlanTnlFlagsEgress:
            size_tmp = QOS_REMARK_VXLAN_TNL_FLAGS_SET_SIZE;
            break;
        case QoSMapTypeIntCongestionCopyEgress:
            size_tmp = QOS_REMARK_MIN_SET_SIZE;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /*
     * The minimum remarking set size is 16 since the base_ptr is
     * always multipled by 16 to calculate remarking table index.
     */
    if (size_tmp <= QOS_REMARK_MIN_SET_SIZE) {
        size_tmp = QOS_REMARK_MIN_SET_SIZE;
    }

    *size = size_tmp;
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize QoS database.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_db_init(int unit)
{
    qos_cfg_t *qos_db = NULL;
    int def_blk_sz[QOS_ING_MAP_TYPE_COUNT] = {QOS_MAP_L2_BLK_DEF_SIZE,
                                              QOS_MAP_L3_BLK_DEF_SIZE,
                                              QOS_MAP_MPLS_BLK_DEF_SIZE};
    int set_sz = -1;
    const char *name[] = {BCMI_CPN_QOS_MAP_L2_SIZE,
                          BCMI_CPN_QOS_MAP_L3_SIZE,
                          BCMI_CPN_QOS_MAP_MPLS_SIZE};
    void *ptr[QoSMapTypeCount];
    void *egr_ptr = NULL;
    void *base_ptr[QOS_EGR_MAP_TYPE_COUNT];
    void *default_ptr = NULL;
    char *ptr_tmp = NULL;
    int size = 0, i, chunk_size = 0;
    int warm = bcmi_warmboot_get(unit);
    uint32_t alloc_size = 0, req_size = 0;
    void *egr_l2_oif_ptr = NULL;
    uint32_t ha_instance_size = 0, ha_array_size = 0;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    qos_db = QOS_CFG(unit);

    /* Init local variable. */
    sal_memset(ptr, 0, QoSMapTypeCount * sizeof(void *));
    sal_memset(base_ptr, 0, QOS_EGR_MAP_TYPE_COUNT * sizeof(void *));

    /* Init ingress Map info. */
    for (i = 0; i < QOS_ING_MAP_TYPE_COUNT; i++) {
        qos_db->blk_sz[i] = bcmi_ltsw_property_get(unit,
                                                   name[i],
                                                   def_blk_sz[i]);
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_set_size_get(unit, i, &set_sz));
        qos_db->map_sz[i] = qos_db->blk_sz[i] / set_sz;
        size += qos_db->blk_sz[i];

        /* Block size must be a non-negative integer multiple of set size. */
        if ((qos_db->blk_sz[i] < 0) || (qos_db->blk_sz[i] % set_sz)) {
            SHR_ERR_EXIT(SHR_E_CONFIG);
        }
    }
    if (size > QOS_MAP_MAX_SIZE) {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    for (i = QoSMapTypeL2Egress; i < QoSMapTypeCount; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_set_size_get(unit, i, &set_sz));
        qos_db->map_sz[i] = QOS_REMARK_TABLE_SIZE / set_sz;
    }

    req_size = sizeof(int) * QoSMapTypeCount;
    alloc_size = req_size;
    default_ptr = bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_QOS,
                           QOS_SUBCOMPID_DEF_QOS_PTR, "bcmQosDflt",
                           &alloc_size);
    SHR_NULL_CHECK(default_ptr, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT
            ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);
    qos_db->def_ptr = default_ptr;
    if (!warm) {
        sal_memset(qos_db->def_ptr, 0, alloc_size);
    }

    /* Init QoS map used bitmap. */
    for (i = 0; i < QoSMapTypeCount; i++) {
        if (qos_db->map_sz[i] == 0) {
            continue;
        }

        /* Allocate HA memory for used bitmap. */
        req_size = SHR_BITALLOCSIZE(qos_db->map_sz[i]);
        alloc_size = req_size;
        ptr[i] = bcmi_ltsw_ha_mem_alloc(unit,
                                        BCMI_HA_COMP_ID_QOS,
                                        QOS_SUBCOMPID_L2_ING_USED_BMP + i,
                                        "bcmQosL2IngUsedBmp",
                                        &alloc_size);

        SHR_NULL_CHECK(ptr[i], SHR_E_MEMORY);
        SHR_IF_ERR_VERBOSE_EXIT
            ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);
        qos_db->bmp[i] = ptr[i];

        if (!warm) {
            sal_memset(ptr[i], 0, alloc_size);

            /* Init default pointer, -1 indicates invalid value. */
            qos_db->def_ptr[i] = -1;
        }
    }

    /* Allocate HA memory for egress table chunk data structure. */
    ha_instance_size = sizeof(qos_remark_table_chunk_t);
    ha_array_size = QOS_REMARK_CHUNK_NUM * QOS_REMARK_TABLE_NUM;
    chunk_size = QOS_REMARK_CHUNK_NUM * sizeof(qos_remark_table_chunk_t);
    req_size = ha_instance_size * ha_array_size;
    alloc_size = req_size;
    egr_ptr = bcmi_ltsw_ha_mem_alloc(unit,
                                     BCMI_HA_COMP_ID_QOS,
                                     QOS_SUBCOMPID_REMARK_TBL_CHUNK,
                                     "bcmQosRemarkTbl",
                                     &alloc_size);
    SHR_NULL_CHECK(egr_ptr, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT
        ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);

    rv = bcmi_ltsw_issu_struct_info_report(unit,
             BCMI_HA_COMP_ID_QOS,
             QOS_SUBCOMPID_REMARK_TBL_CHUNK,
             0, ha_instance_size, ha_array_size,
             QOS_REMARK_TABLE_CHUNK_T_ID);
    if (rv != SHR_E_EXISTS) {
       SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    ptr_tmp = egr_ptr;
    for (i = 0; i < QOS_REMARK_TABLE_NUM; i++) {
        qos_db->remark_table[i].chunk = (qos_remark_table_chunk_t *)ptr_tmp;
        ptr_tmp += chunk_size;
        if ((i >= QRT(3)) && (i <= QRT(6))) {
            qos_db->remark_table[i].overlay = 1;
        }
    }
    if (!warm) {
        sal_memset(egr_ptr, 0, alloc_size);
    }

    /* Allocate HA memory for base pointer mapping. */
    for (i = 0; i < QOS_EGR_MAP_TYPE_COUNT; i++) {
        req_size = qos_db->map_sz[i + QoSMapTypeL2Egress] * sizeof(int);
        alloc_size = req_size;
        base_ptr[i] = bcmi_ltsw_ha_mem_alloc(unit,
                                             BCMI_HA_COMP_ID_QOS,
                                             QOS_SUBCOMPID_TBLIDX_L2_EGRESS+ i,
                                             "bcmQosTblIndexL2Egr",
                                             &alloc_size);
        SHR_NULL_CHECK(base_ptr[i], SHR_E_MEMORY);
        SHR_IF_ERR_VERBOSE_EXIT
            ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);
        qos_db->tbl_index[i] = base_ptr[i];
        if (!warm) {
            /* -1 indicates invalid index. */
            sal_memset(base_ptr[i], 0xff, alloc_size);
        }
    }

    /* Allocate HA memory for dot1p remarking pointer of egress L2 oif. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, EGR_L2_OIFs, &req_size));
    req_size *= sizeof(int);
    alloc_size = req_size;
    egr_l2_oif_ptr = bcmi_ltsw_ha_mem_alloc(unit,
                                            BCMI_HA_COMP_ID_QOS,
                                            QOS_SUBCOMPID_EGR_L2_OIF_DOT1P_PTR,
                                            "bcmQosEgrL2OifDot1p",
                                            &alloc_size);
    SHR_NULL_CHECK(egr_l2_oif_ptr, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT
        ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);
    if (!warm) {
        sal_memset(egr_l2_oif_ptr, 0xff, alloc_size);
    }
    qos_db->egr_l2_oif_dot1p_ptr = egr_l2_oif_ptr;

    /* Init chip-specific qos control info. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_ctrl_info_init(unit, &qos_db->ctrl_info));

exit:
    if (SHR_FUNC_ERR()) {
        if (!warm) {
            for (i = 0; i < QoSMapTypeCount; i++) {
                if (ptr[i] != NULL) {
                    (void)bcmi_ltsw_ha_mem_free(unit, ptr[i]);
                    qos_db->bmp[i] = NULL;
                }
            }
            if (egr_ptr != NULL) {
                (void)bcmi_ltsw_ha_mem_free(unit, egr_ptr);
                for (i = 0; i < QOS_REMARK_TABLE_NUM; i++) {
                    qos_db->remark_table[i].chunk = NULL;
                }
            }
            for (i = 0; i < QOS_EGR_MAP_TYPE_COUNT; i++) {
                if (base_ptr[i] != NULL) {
                    (void)bcmi_ltsw_ha_mem_free(unit, base_ptr[i]);
                    qos_db->tbl_index[i] = NULL;
                }
            }
            if (egr_l2_oif_ptr != NULL) {
                (void)bcmi_ltsw_ha_mem_free(unit, egr_l2_oif_ptr);
                qos_db->egr_l2_oif_dot1p_ptr = NULL;
            }
            if (default_ptr != NULL) {
                (void)bcmi_ltsw_ha_mem_free(unit, default_ptr);
                qos_db->def_ptr = NULL;
            }
        }
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Transform QoS map type to native map type.
 *
 * \param [in] unit Unit Number.
 * \param [in] map_type QoS map type.
 * \param [out] type Native map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_type_to_native_type(int unit, bcmi_ltsw_qos_map_type_t map_type,
                            qos_xfs_map_type_t *type)
{
    const bcmint_qos_ctrl_info_t *qos_ctrl = QOS_CTRL_INFO(unit);
    const bcmint_qos_attribute_remark_info_t *qos_remark = qos_ctrl->remark_info;
    SHR_FUNC_ENTER(unit);

    switch (map_type) {
        case bcmiQosMapTypeL2Ingress:
        case bcmiQosMapTypeL3Ingress:
        case bcmiQosMapTypeMplsIngress:
        case bcmiQosMapTypeL2Egress:
        case bcmiQosMapTypeL3Egress:
        case bcmiQosMapTypeMplsEgress:
        case bcmiQosMapTypeFwdEcnEgress:
        case bcmiQosMapTypeFwdEcnDscpEgress:
        case bcmiQosMapTypeTnlEcnEgress:
        case bcmiQosMapTypeTnlEcnDscpEgress:
            *type = (qos_xfs_map_type_t)map_type;
            break;
        case bcmiQosMapTypeMplsTnlEgress:
            *type = QoSMapTypeMplsTnlEgress;
            break;
        case bcmiQosMapTypeCopiedL2Egress:
            if (!(qos_remark && qos_remark->copied_pri_cfi_ena)) {
                SHR_ERR_EXIT(SHR_E_UNAVAIL);
            }
            *type = (qos_xfs_map_type_t)map_type;
            break;
        case bcmiQosMapTypeCopiedL3Egress:
        case bcmiQosMapTypeCopiedEcnEgress:
        case bcmiQosMapTypeCopiedL3EcnEgress:
            if (!(qos_remark && qos_remark->copied_dscp_ecn_ena)) {
                SHR_ERR_EXIT(SHR_E_UNAVAIL);
            }
            *type = (qos_xfs_map_type_t)map_type;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get chunk mode by QoS map type.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [out] mode Chunk usage mode.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_egr_mode_get(int unit, qos_xfs_map_type_t type,
                 qos_remark_chunk_mode_t *mode)
{
    qos_remark_chunk_mode_t mode_tmp;
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case QoSMapTypeFwdEcnEgress:
        case QoSMapTypeCopiedEcnEgress:
            mode_tmp = QoSChunkMode2Bits;
            break;
        case QoSMapTypeL2Egress:
        case QoSMapTypeL3Egress:
        case QoSMapTypeTnlEcnEgress:
        case QoSMapTypeFwdEcnDscpEgress:
        case QoSMapTypeTnlEcnDscpEgress:
        case QoSMapTypeCopiedL3Egress:
        case QoSMapTypeCopiedL3EcnEgress:
            mode_tmp = QoSChunkMode6Bits;
            break;
        case QoSMapTypeMplsEgress:
        case QoSMapTypeMplsTnlEgress:
            mode_tmp = QoSChunkMode8Bits;
            break;
        case QoSMapTypeVxlanTnlFlagsEgress:
        case QoSMapTypeCopiedL2Egress:
        case QoSMapTypeIntCongestionCopyEgress:
            mode_tmp = QoSChunkMode4Bits;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }
    *mode = mode_tmp;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check the chunk id and offset in all corresponding tables.
 *
 * Check if the chunk id and offset are available for the qos map type
 * in all corresponding tables.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] chunk_id Table chunk id.
 * \param [in] set_id Set id in the chunk.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_egr_table_resource_check(int unit, qos_xfs_map_type_t type,
                             int chunk_id, int set_id)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_remark_table_cfg_t *tbl = NULL;
    bool occupied = false;
    qos_remark_chunk_mode_t mode, mode_tmp;
    int tbl_id, i;
    SHR_FUNC_ENTER(unit);

    /* Get mode by QoS map type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_mode_get(unit, type, &mode));

    for (i = 0; i < QOS_REMARK_TABLE_NUM; i++) {
        tbl_id = qos_table[type].remark_tbl_id[i];

        /* Skip unused table. */
        if (tbl_id == QRT_INVALID) {
            continue;
        }

        tbl = &qos_db->remark_table[tbl_id];
        SHR_NULL_CHECK(tbl->chunk, SHR_E_PARAM);

        /* Chunk is full. */
        if (tbl->chunk[chunk_id].full) {
            occupied = true;
            break;
        }

        if (tbl->chunk[chunk_id].allocated) {
            mode_tmp = tbl->chunk[chunk_id].mode;
            /* Not the same mode. */
            if (mode != mode_tmp) {
                occupied = true;
                break;
            }
            /* This set has already been used. */
            if ((tbl->chunk[chunk_id].set_bmp & (1 << set_id)) != 0) {
                occupied = true;
                break;
            }
        } else {
            /* This case should not happen. */
            if ((tbl->chunk[chunk_id].set_bmp & (1 << set_id)) != 0) {
                SHR_ERR_EXIT(SHR_E_INTERNAL);
            }
        }
    }

    if (occupied) {
        SHR_ERR_EXIT(SHR_E_EXISTS);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Reserve QoS egress table resource.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] chunk_id Table chunk id.
 * \param [in] offset Offset in the chunk.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_egr_table_resource_reserve(int unit, qos_xfs_map_type_t type,
                               int chunk_id, int set_id)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_remark_table_cfg_t *tbl = NULL;
    int set_size, set_num, set_mask, i;
    qos_remark_chunk_mode_t mode;
    int tbl_id;
    SHR_FUNC_ENTER(unit);

    /* Get mode by QoS map type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_mode_get(unit, type, &mode));

    /* Get set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));

    set_num = QOS_REMARK_CHUNK_SIZE / set_size;
    set_mask = (1 << set_num) - 1;

    for (i = 0; i < QOS_REMARK_TABLE_NUM; i++) {
        tbl_id = qos_table[type].remark_tbl_id[i];

        /* Skip unused table. */
        if (tbl_id == QRT_INVALID) {
            continue;
        }

        tbl = &qos_db->remark_table[tbl_id];
        SHR_NULL_CHECK(tbl->chunk, SHR_E_PARAM);

        tbl->chunk[chunk_id].set_bmp |= 1 << set_id;
        tbl->chunk[chunk_id].allocated = true;
        tbl->chunk[chunk_id].mode = mode;
        if ((tbl->chunk[chunk_id].set_bmp & set_mask) == set_mask) {
            tbl->chunk[chunk_id].full = true;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Allocate QoS egress table resources.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [out] index Egress table index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_egr_table_resource_alloc(int unit, qos_xfs_map_type_t type,
                             int *index)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_remark_table_cfg_t *tbl = NULL;
    int chk_id = 0, set_id, set_size, set_num, i;
    qos_remark_chunk_mode_t mode, mode_tmp;
    int tbl_id, rv;
    SHR_FUNC_ENTER(unit);

    /* Get mode by QoS map type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_mode_get(unit, type, &mode));

    /* Get set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));
    set_num = QOS_REMARK_CHUNK_SIZE / set_size;

    for (i = 0; i < QOS_REMARK_TABLE_NUM; i++) {
        tbl_id = qos_table[type].remark_tbl_id[i];

        /* Skip unused table. */
        if (tbl_id == QRT_INVALID) {
            continue;
        }

        tbl = &qos_db->remark_table[tbl_id];
        SHR_NULL_CHECK(tbl->chunk, SHR_E_PARAM);

        for (chk_id = 0; chk_id < QOS_REMARK_CHUNK_NUM; chk_id++) {
            /* Chunk is full. */
            if (tbl->chunk[chk_id].full) {
                continue;
            }

            if (tbl->chunk[chk_id].allocated) {
                mode_tmp = tbl->chunk[chk_id].mode;
                /* Not the same mode. */
                if (mode != mode_tmp) {
                    continue;
                }
            }

            /* Traverse set in this chunk. */
            for (set_id = 0; set_id < set_num; set_id++) {
                /* Find a free set. */
                if ((tbl->chunk[chk_id].set_bmp & (1 << set_id)) == 0) {
                    /* Check if this chunk and set can be used in all tables. */
                    rv = qos_egr_table_resource_check(unit,
                                                      type,
                                                      chk_id,
                                                      set_id);
                    if (rv == SHR_E_NONE) {
                        SHR_IF_ERR_VERBOSE_EXIT
                            (qos_egr_table_resource_reserve(unit,
                                                            type,
                                                            chk_id,
                                                            set_id));
                        *index = chk_id * QOS_REMARK_CHUNK_SIZE +
                                 set_id * set_size;
                        SHR_EXIT();
                    } else {
                        continue;
                    }
                }
            }
        }
    }

    if (chk_id >= QOS_REMARK_CHUNK_NUM) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Free QoS egress table resources.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] index Egress table index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_egr_table_resource_free(int unit, qos_xfs_map_type_t type,
                            int index)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_remark_table_cfg_t *tbl = NULL;
    int chk_id, set_id, set_size, set_num, set_mask, i;
    qos_remark_chunk_mode_t mode;
    int tbl_id;
    SHR_FUNC_ENTER(unit);

    /* Get mode by QoS map type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_mode_get(unit, type, &mode));

    /* Get set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));
    set_num = QOS_REMARK_CHUNK_SIZE / set_size;
    set_mask = (1 << set_num) - 1;

    chk_id = index / QOS_REMARK_CHUNK_SIZE;
    set_id = (index % QOS_REMARK_CHUNK_SIZE) / set_size;

    if (chk_id >= QOS_REMARK_CHUNK_NUM ||
        set_id >= set_num) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    for (i = 0; i < QOS_REMARK_TABLE_NUM; i++) {
        tbl_id = qos_table[type].remark_tbl_id[i];

        /* Skip unused table. */
        if (tbl_id == -1) {
            continue;
        }

        tbl = &qos_db->remark_table[tbl_id];
        SHR_NULL_CHECK(tbl->chunk, SHR_E_PARAM);

        tbl->chunk[chk_id].set_bmp &= ~(1 << set_id);
        tbl->chunk[chk_id].full = false;
        if ((tbl->chunk[chk_id].set_bmp & set_mask) == 0) {
            tbl->chunk[chk_id].allocated = false;
            tbl->chunk[chk_id].mode = QoSChunkModeNone;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set QoS egress table index mapping.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] id Map id.
 * \param [in] index Egress table index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_egr_table_index_set(int unit, qos_xfs_map_type_t type, int id,
                        int index)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    SHR_FUNC_ENTER(unit);

    if ((type < QoSMapTypeL2Egress) ||
        (type >= QoSMapTypeCount) ||
        (qos_db->tbl_index[type-QoSMapTypeL2Egress] == NULL) ||
        (id >= qos_db->map_sz[type])) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    QOS_EGR_TBL_IDX(unit, type, id) = index;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear QoS egress table index mapping.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] id Map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_egr_table_index_clear(int unit, qos_xfs_map_type_t type, int id)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    SHR_FUNC_ENTER(unit);

    if ((type < QoSMapTypeL2Egress) ||
        (type >= QoSMapTypeCount) ||
        (qos_db->tbl_index[type-QoSMapTypeL2Egress] == NULL) ||
        (id >= qos_db->map_sz[type])) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    QOS_EGR_TBL_IDX(unit, type, id) = -1;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get QoS egress table index.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] id Map id.
 * \param [out] index Egress table index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_egr_table_index_get(int unit, qos_xfs_map_type_t type, int id,
                        int *index)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    SHR_FUNC_ENTER(unit);

    if ((type < QoSMapTypeL2Egress) ||
        (type >= QoSMapTypeCount) ||
        (qos_db->tbl_index[type-QoSMapTypeL2Egress] == NULL) ||
        (id >= qos_db->map_sz[type])) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *index = QOS_EGR_TBL_IDX(unit, type, id);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Stage table index for a QoS map.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] id Map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_table_index_stage(int unit, qos_xfs_map_type_t type, int id)
{
    int index = -1;
    SHR_FUNC_ENTER(unit);

    if (QOS_MAP_IS_EGR_TYPE(type)) {
        /* Allocate hardware table resource for egress map. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_egr_table_resource_alloc(unit, type, &index));
        /* Set QoS egress table index mapping. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_egr_table_index_set(unit, type, id, index));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Allocate a map id.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [out] id Map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_id_alloc(int unit, qos_xfs_map_type_t type, int *id)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    SHR_BITDCL *bitmap = NULL;
    int i = 0, size = 0;

    SHR_FUNC_ENTER(unit);

    if (type >= QoSMapTypeCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    bitmap = qos_db->bmp[type];
    size = qos_db->map_sz[type];

    for (i = 0; i < size; i++) {
        if ((type == QoSMapTypeL2Ingress && i == QOS_RSVD_L2_MAP_ID) ||
            (type == QoSMapTypeL3Ingress && i == QOS_RSVD_L3_MAP_ID)) {
            continue;
        }
        if (!SHR_BITGET(bitmap, i)) {
            break;
        }
    }
    if (i >= size) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }
    *id = i;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Hold a map id.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] id Map id.
 */
static void
qos_map_id_hold(int unit, qos_xfs_map_type_t type, int id)
{
    if (type >= QoSMapTypeCount) {
        return;
    }
    QOS_MAP_BMP_USED_SET(unit, type, id);
    return;
}

/*!
 * \brief Free a map id.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] id Map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_id_free(int unit, qos_xfs_map_type_t type, int id)
{
    int index;
    SHR_FUNC_ENTER(unit);
    if (type >= QoSMapTypeCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    QOS_MAP_BMP_USED_CLR(unit, type, id);

    if (QOS_MAP_IS_EGR_TYPE(type)) {
        /* Get table index. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_egr_table_index_get(unit, type, id, &index));

        /* Free table resources. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_egr_table_resource_free(unit, type, index));

        /* Clear table index mapping. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_egr_table_index_clear(unit, type, id));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get map type by flags.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS map flags.
 * \param [out] type QoS map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_type_get_by_flags(int unit, uint32_t flags,
                          bcmi_ltsw_qos_map_type_t *type)
{
    bcmi_ltsw_qos_map_type_t type_tmp = bcmiQosMapTypeCount;
    SHR_FUNC_ENTER(unit);

    if (flags & BCM_QOS_MAP_L2) {
        if (flags & BCM_QOS_MAP_INGRESS) {
            type_tmp = bcmiQosMapTypeL2Ingress;
        } else if (flags & BCM_QOS_MAP_EGRESS) {
            type_tmp = bcmiQosMapTypeL2Egress;
            /*
             * {BCM_QOS_MAP_L2 | BCM_QOS_MAP_EGRESS |
             *  BCM_QOS_MAP_INGRESS_COPIED}
             * Map packet pri/cfi copied from IPIPE to outgoing packet pri and
             * cfi.
             */
            if (flags & BCM_QOS_MAP_INGRESS_COPIED) {
                type_tmp = bcmiQosMapTypeCopiedL2Egress;
            }
        }
    } else if (flags & BCM_QOS_MAP_L3) {
        if (flags & BCM_QOS_MAP_INGRESS) {
            type_tmp = bcmiQosMapTypeL3Ingress;
        } else if (flags & BCM_QOS_MAP_EGRESS) {
            type_tmp = bcmiQosMapTypeL3Egress;
            /*
             * 1.{BCM_QOS_MAP_L3 | BCM_QOS_MAP_ECN}
             *   Map internal priority, CNG to packet forwarding(payload) DSCP,
             *   and at the same time map internal CN to packet
             *   forwarding(payload) ECN.
             * 2.{BCM_QOS_MAP_L3 | BCM_QOS_MAP_ECN | BCM_QOS_MAP_ENCAP}
             *   Map internal priority, CNG to packet tunnel DSCP,
             *   and at the same time map internal CN to packet tunnel ECN.
             * 3.{BCM_QOS_MAP_L3 | BCM_QOS_MAP_INGRESS_COPIED}
             *   Map DSCP copied from IPIPE  to outgoing packet DSCP.
             * 4.{BCM_QOS_MAP_L3 | BCM_QOS_MAP_ECN | BCM_QOS_MAP_INGRESS_COPIED}
             *   Map DSCP copied from IPIPE to outgoing packet DSCP, and at the
             *   same time map ECN copied from IPIPE to outgoing  packet ECN.
             */
            if (flags & BCM_QOS_MAP_ECN) {
                if (flags & BCM_QOS_MAP_ENCAP) {
                    /* case 2 */
                    type_tmp = bcmiQosMapTypeTnlEcnDscpEgress;
                } else if(flags & BCM_QOS_MAP_INGRESS_COPIED) {
                    /* case 4 */
                    type_tmp = bcmiQosMapTypeCopiedL3EcnEgress;
                } else {
                    /* case 1 */
                    type_tmp = bcmiQosMapTypeFwdEcnDscpEgress;
                }
            } else if (flags & BCM_QOS_MAP_INGRESS_COPIED) {
                /* case 3 */
                type_tmp = bcmiQosMapTypeCopiedL3Egress;
            }
        }
    } else if (flags & BCM_QOS_MAP_MPLS) {
        if (flags & BCM_QOS_MAP_INGRESS) {
            type_tmp = bcmiQosMapTypeMplsIngress;

            /* Flags check. */
            if (flags & (~(BCM_QOS_MAP_MPLS | BCM_QOS_MAP_INGRESS |
                           BCM_QOS_MAP_WITH_ID | BCM_QOS_MAP_REPLACE))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        } else if (flags & BCM_QOS_MAP_EGRESS) {
            type_tmp = bcmiQosMapTypeMplsEgress;
            if (flags & BCM_QOS_MAP_ENCAP) {
                type_tmp = bcmiQosMapTypeMplsTnlEgress;
            }

            /* Flags check. */
            if (flags & (~(BCM_QOS_MAP_MPLS | BCM_QOS_MAP_EGRESS |
                           BCM_QOS_MAP_ENCAP | BCM_QOS_MAP_WITH_ID |
                           BCM_QOS_MAP_REPLACE))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
    } else if (flags & BCM_QOS_MAP_ECN) {
        /*
         * 1.{BCM_QOS_MAP_ECN}
         *   Map internal CN to packet forwarding(payload) ECN.
         * 2.{BCM_QOS_MAP_ECN | BCM_QOS_MAP_ENCAP}
         *   Map internal CN to packet tunnel ECN.
         * 3.{BCM_QOS_MAP_ECN | BCM_QOS_MAP_INGRESS_COPIED}
         *   Map ECN copied from IPIPE  to outgoing packet ECN.
         */
        if (flags & BCM_QOS_MAP_EGRESS) {
            type_tmp = bcmiQosMapTypeFwdEcnEgress;
            if (flags & BCM_QOS_MAP_ENCAP) {
                type_tmp = bcmiQosMapTypeTnlEcnEgress;
            } else if (flags & BCM_QOS_MAP_INGRESS_COPIED) {
                type_tmp = bcmiQosMapTypeCopiedEcnEgress;
            }
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *type = type_tmp;
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get QoS map type from QoS map id.
 *
 * \param [in] unit Unit Number.
 * \param [in] map_id BCM QoS map id.
 * \param [out] type QoS map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_id_to_map_type(int unit, int map_id, bcmi_ltsw_qos_map_type_t *type)
{
    SHR_FUNC_ENTER(unit);

    *type = map_id >> QOS_MAP_SHIFT;

    if (*type >= bcmiQosMapTypeCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get native map id from QoS map id.
 *
 * \param [in] unit Unit Number.
 * \param [in] map_id BCM QoS map id.
 * \param [out] id Native map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_id_to_native_id(int unit, int map_id, int *id)
{
    *id = map_id & QOS_MAP_ID_MASK;
    return SHR_E_NONE;
}

/*!
 * \brief Validate native map id.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Native map id.
 * \param [in] type Native map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_native_map_id_validate(int unit, int id, qos_xfs_map_type_t type)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);

    SHR_FUNC_ENTER(unit);

    if (id >= qos_db->map_sz[type]) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief QoS map id check.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [in] type QoS map type.
 * \param [in] map_id QoS map id.
 * \param [out] id Map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_id_check(int unit, uint32_t flags, qos_xfs_map_type_t type,
                 int map_id, int *id)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type_tmp;
    bcmi_ltsw_qos_map_type_t map_type;
    int id_tmp;
    SHR_FUNC_ENTER(unit);

    /* Get map type from map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type_tmp));

    id_tmp = map_id & QOS_MAP_ID_MASK;

    if (type_tmp != type) {
        SHR_ERR_EXIT(SHR_E_BADID);
    }
    if (id_tmp >= qos_db->map_sz[type]) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (QOS_MAP_BMP_USED_GET(unit, type, id_tmp)) {
        if (!(flags & BCM_QOS_MAP_REPLACE)) {
            SHR_ERR_EXIT(SHR_E_EXISTS);
        }
    }
    *id = id_tmp;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get QoS table base index from QoS map type and map id.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Map id.
 * \param [in] map QoS map.
 * \param [out] index Table entry index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_to_table_index(int unit, int id, bcmint_qos_map_t *map, int *index)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    int index_tmp, set_size;
    qos_xfs_map_type_t type;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(map, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map->type, &type));

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));

    switch (type) {
        case QoSMapTypeL2Ingress:
            index_tmp = id * set_size;
            break;
        case QoSMapTypeL3Ingress:
            index_tmp = qos_db->blk_sz[QoSMapTypeL2Ingress] +
                        id * set_size;
            break;
        case QoSMapTypeMplsIngress:
            index_tmp = qos_db->blk_sz[QoSMapTypeL2Ingress] +
                        qos_db->blk_sz[QoSMapTypeL3Ingress] +
                        id * set_size;
            break;
        case QoSMapTypeL2Egress:
        case QoSMapTypeL3Egress:
        case QoSMapTypeFwdEcnEgress:
        case QoSMapTypeTnlEcnEgress:
        case QoSMapTypeFwdEcnDscpEgress:
        case QoSMapTypeTnlEcnDscpEgress:
        case QoSMapTypeMplsEgress:
        case QoSMapTypeMplsTnlEgress:
        case QoSMapTypeCopiedL2Egress:
        case QoSMapTypeCopiedL3Egress:
        case QoSMapTypeCopiedEcnEgress:
        case QoSMapTypeCopiedL3EcnEgress:
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_egr_table_index_get(unit, type, id, &index_tmp));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *index = index_tmp;
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get QoS map(packet field) from table index and map type.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] mode QoS encode mode.
 * \param [in] index Table entry index.
 * \param [out] map BCM QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_table_index_to_map(int unit, qos_xfs_map_type_t type,
                       qos_table_encode_mode_t mode,
                       int index, bcm_qos_map_t *map)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    int index_tmp, int_cng, set_size;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(map, SHR_E_PARAM);

    /* Get set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));

    switch (type) {
        case QoSMapTypeL2Ingress:
            index_tmp = index % set_size;
            map->pkt_cfi = index_tmp & QOS_PKT_CFI_MASK;
            map->pkt_pri = (index_tmp >> 1) & QOS_PKT_PRI_MASK;
            break;
        case QoSMapTypeL3Ingress:
            index_tmp = index - qos_db->blk_sz[QoSMapTypeL2Ingress];
            index_tmp = index_tmp % set_size;
            map->dscp = index_tmp;
            break;
        case QoSMapTypeMplsIngress:
            index_tmp = index - qos_db->blk_sz[QoSMapTypeL2Ingress] -
                        qos_db->blk_sz[QoSMapTypeL3Ingress];
            index_tmp = index_tmp % set_size;
            map->exp = index_tmp;
            break;
        case QoSMapTypeL2Egress:
        case QoSMapTypeL3Egress:
            index_tmp = index % QOS_REMARK_CHUNK_SIZE;
            index_tmp = index_tmp % set_size;
            int_cng = (index_tmp >> 4) & QOS_INT_CNG_MASK;
            map->color = BCMI_LTSW_QOS_COLOR_DECODING(int_cng);
            map->int_pri = index_tmp & QOS_INT_PRI_MASK;
            break;
        case QoSMapTypeMplsEgress:
            index_tmp = index % QOS_REMARK_CHUNK_SIZE;
            index_tmp = index_tmp % set_size;
            int_cng = (index_tmp >> 4) & QOS_INT_CNG_MASK;
            map->color = BCMI_LTSW_QOS_COLOR_DECODING(int_cng);
            map->int_pri = index_tmp & QOS_INT_PRI_MASK;
            map->int_cn = (index_tmp >> 6) & QOS_INT_CN_MASK;
            break;
        case QoSMapTypeFwdEcnEgress:
            index_tmp = index % QOS_REMARK_CHUNK_SIZE;
            index_tmp = index_tmp % set_size;
            map->int_cn = index_tmp & QOS_INT_CN_MASK;
            map->latency_marked = (index_tmp >> 2) & 0x1;
            break;
        case QoSMapTypeTnlEcnEgress:
            index_tmp = index % QOS_REMARK_CHUNK_SIZE;
            index_tmp = index_tmp % set_size;
            map->int_cn = index_tmp & QOS_INT_CN_MASK;
            map->responsive = (index_tmp >> 4) & 0x1;
            map->latency_marked = (index_tmp >> 2) & 0x1;
            break;
        case QoSMapTypeFwdEcnDscpEgress:
            index_tmp = index % QOS_REMARK_CHUNK_SIZE;
            index_tmp = index_tmp % set_size;
            if (mode == QoSEncodeModeEgrDscp) {
                int_cng = (index_tmp >> 4) & QOS_INT_CNG_MASK;
                map->color = BCMI_LTSW_QOS_COLOR_DECODING(int_cng);
                map->int_pri = index_tmp & QOS_INT_PRI_MASK;
            } else if (mode == QoSEncodeModeEgrFwdEcn) {
                map->int_cn = index_tmp & QOS_INT_CN_MASK;
                map->latency_marked = (index_tmp >> 2) & 0x1;
            }
            break;
        case QoSMapTypeTnlEcnDscpEgress:
            index_tmp = index % QOS_REMARK_CHUNK_SIZE;
            index_tmp = index_tmp % set_size;
            if (mode == QoSEncodeModeEgrDscp) {
                int_cng = (index_tmp >> 4) & QOS_INT_CNG_MASK;
                map->color = BCMI_LTSW_QOS_COLOR_DECODING(int_cng);
                map->int_pri = index_tmp & QOS_INT_PRI_MASK;
            } else if (mode == QoSEncodeModeEgrTnlEcn) {
                map->int_cn = index_tmp & QOS_INT_CN_MASK;
                map->responsive = (index_tmp >> 4) & 0x1;
                map->latency_marked = (index_tmp >> 2) & 0x1;
            }
            break;
        case QoSMapTypeMplsTnlEgress:
            index_tmp = index % QOS_REMARK_CHUNK_SIZE;
            index_tmp = index_tmp % set_size;
            int_cng = (index_tmp >> 4) & QOS_INT_CNG_MASK;
            map->color = BCMI_LTSW_QOS_COLOR_DECODING(int_cng);
            map->int_pri = index_tmp & QOS_INT_PRI_MASK;
            map->int_cn = (index_tmp >> 6) & QOS_INT_CN_MASK;
            break;
        case QoSMapTypeCopiedL2Egress:
            index_tmp = index % QOS_REMARK_CHUNK_SIZE;
            index_tmp = index % set_size;
            map->copied_pkt_cfi = index_tmp & QOS_PKT_CFI_MASK;
            map->copied_pkt_pri = (index_tmp >> 1) & QOS_PKT_PRI_MASK;
            break;
        case QoSMapTypeCopiedL3Egress:
            index_tmp = index % QOS_REMARK_CHUNK_SIZE;
            index_tmp = index_tmp % set_size;
            map->copied_pkt_dscp = index_tmp & QOS_PKT_DSCP_MASK;
            break;
        case QoSMapTypeCopiedEcnEgress:
            index_tmp = index % QOS_REMARK_CHUNK_SIZE;
            index_tmp = index_tmp % set_size;
            map->copied_pkt_ecn = index_tmp & QOS_PKT_ECN_MASK;
            break;
        case QoSMapTypeCopiedL3EcnEgress:
            index_tmp = index % QOS_REMARK_CHUNK_SIZE;
            index_tmp = index_tmp % set_size;
            if (mode == QoSEncodeModeEgrCopiedDscp) {
                map->copied_pkt_dscp = index_tmp & QOS_PKT_DSCP_MASK;
            } else if (mode == QoSEncodeModeEgrCopiedEcn) {
                map->copied_pkt_ecn = index_tmp & QOS_PKT_ECN_MASK;
            }
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get QoS table index offset from QoS map(packet field) and mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] mode QoS encode mode.
 * \param [in] map QoS map.
 * \param [out] offset Table index offset.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_table_offset_get(int unit, qos_table_encode_mode_t mode,
                         bcm_qos_map_t *qos_map, int *offset)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(qos_map, SHR_E_PARAM);

    switch (mode) {
        case QoSEncodeModeIngDot1pCfi:
            *offset = ((qos_map->pkt_pri << 1) | qos_map->pkt_cfi);
            break;
        case QoSEncodeModeIngDscp:
            *offset = qos_map->dscp;
            break;
        case QoSEncodeModeIngExp:
            *offset = qos_map->exp;
            break;
        case QoSEncodeModeEgrDot1pCfi:
        case QoSEncodeModeEgrDscp:
            *offset = (BCMI_LTSW_QOS_COLOR_ENCODING(qos_map->color) << 4) |
                      qos_map->int_pri;
            break;
        case QoSEncodeModeEgrFwdEcn:
            *offset = qos_map->int_cn | (qos_map->latency_marked << 2);
            break;
        case QoSEncodeModeEgrTnlEcn:
            *offset = (qos_map->responsive << 4) |
                      (qos_map->latency_marked << 2) |
                      qos_map->int_cn;
            break;
        case QoSEncodeModeEgrExp:
        case QoSEncodeModeEgrTnlExp0:
        case QoSEncodeModeEgrTnlExp1:
        case QoSEncodeModeEgrTnlExp2:
        case QoSEncodeModeEgrTnlExp3:
        case QoSEncodeModeEgrTnlExp4:
        case QoSEncodeModeEgrTnlExp5:
        case QoSEncodeModeEgrTnlExp6:
            *offset = (qos_map->int_pri |
                      (BCMI_LTSW_QOS_COLOR_ENCODING(qos_map->color) << 4) |
                      (qos_map->int_cn << 6));
            break;
        case QoSEncodeModeEgrCopiedDot1pCfi:
            *offset = ((qos_map->copied_pkt_pri << 1) |
                       qos_map->copied_pkt_cfi);
            break;
        case QoSEncodeModeEgrCopiedDscp:
            *offset = qos_map->copied_pkt_dscp;
            break;
        case QoSEncodeModeEgrCopiedEcn:
            *offset = qos_map->copied_pkt_ecn;
            break;
        default:
            SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add an ingress phb table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table entry index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_ingress_table_add(int unit, int index, bcmint_qos_map_t *map)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BASE_INDEXs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {INT_PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {INT_CNGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DSCP_VALIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {MAPPED_DSCPs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int offset = 0;
    qos_xfs_map_type_t type;
    qos_table_encode_mode_t mode;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map->type, &type));
    mode = qos_table[type].mode[0];

    /* Get offset. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_offset_get(unit, mode, map->entry, &offset));

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index + offset;
    field[1].u.val = map->entry->int_pri;
    field[2].u.val = BCMI_LTSW_QOS_COLOR_ENCODING(map->entry->color);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, qos_map_tbl_name, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete an ingress phb table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table entry index.
 * \param [in] type QoS map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_ingress_table_delete(int unit, int index, qos_xfs_map_type_t type)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BASE_INDEXs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, qos_map_tbl_name, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get an ingress phb table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table entry index.
 * \param [in] type QoS map type.
 * \param [out] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_ingress_table_get(int unit, int index, bcmint_qos_map_t *map)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BASE_INDEXs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {INT_PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {INT_CNGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DSCP_VALIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {MAPPED_DSCPs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           qos_map_tbl_name,
                           &lt_entry,
                           NULL, NULL));

    map->entry->int_pri = field[1].u.val;
    map->entry->color = BCMI_LTSW_QOS_COLOR_DECODING(field[2].u.val);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a set of entries into ingress phb table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_ingress_table_add_array(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, base_index, int_cng;
    bcm_qos_map_t *map_tmp;
    int set_sz;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    set_sz = *map->count;
    map_tmp = map->entry;
    base_index = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (i = 0; i < set_sz; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, qos_map_tbl_name, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, BASE_INDEXs, base_index));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, INT_PRIs, map_tmp->int_pri));
        int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, INT_CNGs, int_cng));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl,
                                         BCMLT_OPCODE_INSERT,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
        base_index++;
        map_tmp++;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete a set of entries from ingress phb table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_ingress_table_delete_array(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, base_index;
    int set_sz;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);

    set_sz = *map->count;
    base_index = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (i = 0; i < set_sz; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, qos_map_tbl_name, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, BASE_INDEXs, base_index));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl,
                                         BCMLT_OPCODE_DELETE,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
        base_index++;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get a set of entries from ingress phb table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [out] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_ingress_table_get_array(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, base_index, base_index_tmp;
    bcm_qos_map_t *map_tmp;
    int set_sz, cnt = 0;
    bcmlt_entry_info_t entry_info;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_info_t trans_info;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    uint64_t data = 0LL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    set_sz = *map->count;
    map_tmp = map->entry;
    base_index = index;
    base_index_tmp = base_index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (i = 0; i < set_sz; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, qos_map_tbl_name, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, BASE_INDEXs, base_index_tmp));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl,
                                         BCMLT_OPCODE_LOOKUP,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
        base_index_tmp++;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_info_get(trans_hdl, &trans_info));

    base_index_tmp = base_index;
    /* Get map from each entry. */
    for (i = 0; i < trans_info.num_entries; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_num_get(trans_hdl, i, &entry_info));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_info.entry_hdl, INT_PRIs, &data));
        map_tmp->int_pri = (int)data;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_info.entry_hdl, INT_CNGs, &data));
        map_tmp->color = BCMI_LTSW_QOS_COLOR_DECODING(data);

        SHR_IF_ERR_VERBOSE_EXIT
            (qos_table_index_to_map(unit,
                                    map->type,
                                    0,
                                    base_index_tmp,
                                    map_tmp));
        base_index_tmp++;
        map_tmp++;
        cnt++;
    }

    *map->count = cnt;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Encode QoS map into QOS_FIELD.
 *
 * \param [in] unit Unit Number.
 * \param [in] mode QoS encode mode.
 * \param [in] map BCM QoS map.
 * \param [out] val QoS field value.
 * \param [out] drop Packet drop.
 * \param [out] valid Valid bit set.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_to_field(int unit, qos_table_encode_mode_t mode,
                 bcm_qos_map_t *map, int *val, bool *drop, bool *valid)
{
    int val_tmp = 0;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(drop, SHR_E_PARAM);
    SHR_NULL_CHECK(valid, SHR_E_PARAM);

    *valid = true;
    *drop = (map->actions & BCM_QOS_MAP_ACTION_DROP) ? true : false;

    switch (mode) {
        case QoSEncodeModeEgrDot1pCfi:
        case QoSEncodeModeEgrCopiedDot1pCfi:
            val_tmp = (map->pkt_pri << 1) | map->pkt_cfi;
            break;
        case QoSEncodeModeEgrDscp:
        case QoSEncodeModeEgrCopiedDscp:
            val_tmp = map->dscp;
            break;
        case QoSEncodeModeEgrExp:
            val_tmp = map->exp;
            break;
        case QoSEncodeModeEgrFwdEcn:
        case QoSEncodeModeEgrTnlEcn:
        case QoSEncodeModeEgrCopiedEcn:
            val_tmp = map->pkt_ecn;
            break;
        case QoSEncodeModeEgrTnlExp0:
        case QoSEncodeModeEgrTnlExp1:
        case QoSEncodeModeEgrTnlExp2:
        case QoSEncodeModeEgrTnlExp3:
        case QoSEncodeModeEgrTnlExp4:
        case QoSEncodeModeEgrTnlExp5:
        case QoSEncodeModeEgrTnlExp6:
            val_tmp = map->tunnel_exp[mode - QoSEncodeModeEgrTnlExp0];

            if (val_tmp == BCM_MPLS_EXP_INVALID) {
                *valid = false;
            }
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }
    *val = val_tmp;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Decode QOS_FIELD into QoS map.
 *
 * \param [in] unit Unit Number.
 * \param [in] mode QoS encode mode.
 * \param [in] val QoS field value.
 * \param [in] drop Packet drop.
 * \param [in] valid Valid bit set.
 * \param [in|out] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_field_to_map(int unit, qos_table_encode_mode_t mode, int val,
                 bool drop, bool valid, bcm_qos_map_t *map)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);

    if (drop) {
        map->actions |= BCM_QOS_MAP_ACTION_DROP;
    }

    switch (mode) {
        case QoSEncodeModeEgrDot1pCfi:
        case QoSEncodeModeEgrCopiedDot1pCfi:
            map->pkt_pri = (val >> 1) & QOS_PKT_PRI_MASK;
            map->pkt_cfi = val & QOS_PKT_CFI_MASK;
            break;
        case QoSEncodeModeEgrDscp:
        case QoSEncodeModeEgrCopiedDscp:
            map->dscp = val & QOS_PKT_DSCP_MASK;
            break;
        case QoSEncodeModeEgrExp:
            map->exp = val & QOS_PKT_EXP_MASK;
            break;
        case QoSEncodeModeEgrFwdEcn:
        case QoSEncodeModeEgrTnlEcn:
        case QoSEncodeModeEgrCopiedEcn:
            map->pkt_ecn = val & QOS_PKT_ECN_MASK;
            break;
        case QoSEncodeModeEgrTnlExp0:
        case QoSEncodeModeEgrTnlExp1:
        case QoSEncodeModeEgrTnlExp2:
        case QoSEncodeModeEgrTnlExp3:
        case QoSEncodeModeEgrTnlExp4:
        case QoSEncodeModeEgrTnlExp5:
        case QoSEncodeModeEgrTnlExp6:
            map->tunnel_exp[mode - QoSEncodeModeEgrTnlExp0] = valid ?
                (val & QOS_PKT_EXP_MASK) : BCM_MPLS_EXP_INVALID;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add extra entries into tunnel ecn remarking table.
 *
 * There is a difference between tunnel ECN remarking and normal payload ECN
 * remarking. The offset for tunnel ECN remarking includes following parts:
 *    fwd_hdr_ecn_present : ecn_map_input_vector[5:5]
 *        -- Indicate IPv4 or IPv6 header exists.
 *    responsive : ecn_map_input_vector[4:4]
 *        -- Indicate the flow is responsive flow(TCP) or not.
 *    lb_int_cn : ecn_map_input_vector[3:0]
 *        --int_cn[1:0] Internal congestion indicator.
 *        --mark_latency[2:2] Latency or not.
 * Currently we only expose int_cn, mark_latency, responsive to customers, and
 * it seems that we don't find enough reasons to expose fwd_hdr_ecn_present
 * anyway we should program extra entries into remarking tables
 * to cover all cases for specific responsive & int_cn that customers pass
 * into API, i.e, customers pass responsive=0 int_cn=1, then we should cover
 * responsive=0 int_cn=1 fwd_hdr_ecn_present=0,
 * responsive=0 int_cn=1 fwd_hdr_ecn_present=1, etc.
 *
 * \param [in] unit Unit Number.
 * \param [in] tbl_name Table Name.
 * \param [in] index Base index.
 * \param [in] val QoS field value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_tnl_ecn_table_add(int unit, const char *tbl_name, int index,
                                 int val)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BASE_INDEXs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {QOS_FIELDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int ip_hdr = 0, index_tmp = 0;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (ip_hdr = 0; ip_hdr <= 1; ip_hdr++) {
        index_tmp = index | (ip_hdr << 5);

        field[0].u.val = index_tmp;
        field[1].u.val = val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit,
                               tbl_name,
                               &lt_entry,
                               NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add an egress table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table entry index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_table_add(int unit, int index, bcmint_qos_map_t *map)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BASE_INDEXs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {QOS_FIELDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {PKT_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int i, cnt, val, tbl_id, offset = 0;
    bcm_qos_map_t *map_tmp;
    qos_xfs_map_type_t type;
    qos_table_encode_mode_t mode;
    bool drop = false, valid = true;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    map_tmp = map->entry;
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map->type, &type));

    cnt = qos_table[type].count;

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < cnt; i++) {
        drop = false;
        valid = true;
        if (type == QoSMapTypeL2Egress) {
            if (!(map->flags & BCM_QOS_MAP_L2) &&
                (i == 0 || i == 2)) {
                continue;
            }
            if (!(map->flags & BCM_QOS_MAP_L2_INNER_TAG) &&
                (i == 1)) {
                continue;
            }
        }
        mode = qos_table[type].mode[i];
        /* Set the QOS_FIELD. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_to_field(unit, mode, map_tmp, &val, &drop, &valid));
        /* Get offset. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_table_offset_get(unit, mode, map_tmp, &offset));

        field[0].u.val = index + offset;
        field[1].u.val = val;
        field[2].u.val = drop;

        tbl_id = qos_table[type].remark_tbl_id[i];
        if (valid) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_set(unit,
                                   qos_remark_tbl_name[tbl_id],
                                   &lt_entry,
                                   NULL));
        } else {
            /* Invalidate entry to not remarking. */
            SHR_IF_ERR_EXIT_EXCEPT_IF
                (bcmi_lt_entry_delete(unit,
                                      qos_remark_tbl_name[tbl_id],
                                      &lt_entry,
                                      NULL), SHR_E_NOT_FOUND);
        }

        /* Tunnel ECN remarking table programming. */
        if (mode == QoSEncodeModeEgrTnlEcn) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_egress_tnl_ecn_table_add(unit,
                                                  qos_remark_tbl_name[tbl_id],
                                                  index + offset,
                                                  val));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete an egress table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table entry index.
 * \param [in] type QoS map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_table_delete(int unit, int index, qos_xfs_map_type_t type)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BASE_INDEXs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int i, cnt, tbl_id;

    SHR_FUNC_ENTER(unit);
    cnt = qos_table[type].count;

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    for (i = 0; i < cnt; i++) {
        tbl_id = qos_table[type].remark_tbl_id[i];
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_delete(unit,
                                  qos_remark_tbl_name[tbl_id],
                                  &lt_entry,
                                  NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get an egress table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table entry index.
 * \param [out] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_table_get(int unit, int index, bcmint_qos_map_t *map)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {BASE_INDEXs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {QOS_FIELDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {PKT_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    bcm_qos_map_t *map_tmp;
    int val, tbl_id, rv;
    qos_xfs_map_type_t type;
    qos_table_encode_mode_t mode;
    bool drop = false, valid = true;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map->type, &type));

    tbl_id = qos_table[type].remark_tbl_id[0];
    mode = qos_table[type].mode[0];

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    rv = bcmi_lt_entry_get(unit,
                           qos_remark_tbl_name[tbl_id],
                           &lt_entry,
                           NULL, NULL);
    if (rv == SHR_E_NOT_FOUND) {
        valid = false;
    } else if (SHR_SUCCESS(rv)) {
        val = (int)field[1].u.val;
        drop = (bool)field[2].u.val;
    } else {
        SHR_ERR_EXIT(rv);
    }

    map_tmp = map->entry;
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_field_to_map(unit, mode, val, drop, valid, map_tmp));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a set of entries into egress table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_table_add_array(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, j, base_index, base_index_tmp;
    bcm_qos_map_t *map_tmp;
    int set_sz, cnt, val, tbl_id;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    qos_xfs_map_type_t type;
    qos_table_encode_mode_t mode;
    bool drop = false, valid = true;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map->type, &type));

    cnt = qos_table[type].count;

    set_sz = *map->count;
    base_index = index;

    /* Traverse table array. */
    for (j = 0; j < cnt; j++) {
        map_tmp = map->entry;
        base_index_tmp = base_index;
        tbl_id = qos_table[type].remark_tbl_id[j];
        mode = qos_table[type].mode[j];

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));
        for (i = 0; i < set_sz; i++) {
            drop = false;
            valid = true;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit,
                                      qos_remark_tbl_name[tbl_id],
                                      &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, BASE_INDEXs, base_index_tmp));
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_to_field(unit, mode, map_tmp, &val, &drop, &valid));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, QOS_FIELDs, val));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, PKT_DROPs, drop));
            if (valid) {
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_INSERT,
                                                 entry_hdl));
            } else {
                /* Delete entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_DELETE,
                                                 entry_hdl));
            }
            entry_hdl = BCMLT_INVALID_HDL;
            base_index_tmp++;
            map_tmp++;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_transaction_commit(unit,
                                        trans_hdl,
                                        BCMLT_PRIORITY_NORMAL));
        bcmlt_transaction_free(trans_hdl);
        trans_hdl = BCMLT_INVALID_HDL;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete a set of entries from egress table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_table_delete_array(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, j, base_index, base_index_tmp, rv;
    int set_sz, cnt, tbl_id;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    qos_xfs_map_type_t type;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map->type, &type));

    cnt = qos_table[type].count;

    set_sz = *map->count;
    base_index = index;

    /* Traverse table array. */
    for (j = 0; j < cnt; j++) {
        base_index_tmp = base_index;
        tbl_id = qos_table[type].remark_tbl_id[j];
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit,
                                  qos_remark_tbl_name[tbl_id],
                                  &entry_hdl));
        for (i = 0; i < set_sz; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, BASE_INDEXs, base_index_tmp));

            rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE,
                                    BCMLT_PRIORITY_NORMAL);
            if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
                SHR_ERR_EXIT(rv);
            }
            base_index_tmp++;
        }
        bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get a set of entries from egress table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_table_get_array(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, j, base_index, base_index_tmp, rv, field;
    bcm_qos_map_t *map_tmp;
    int set_sz, cnt = 0, tbl_id;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t data = 0LL;
    qos_xfs_map_type_t type;
    qos_table_encode_mode_t mode;
    bool drop, valid;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map->type, &type));

    cnt = qos_table[type].count;
    set_sz = *map->count;
    base_index = index;

    /*
     * Only combined type need to traverse the whole table array
     * since all the tables of normal type are programmed as the same value.
     */
    if (!QOS_MAP_IS_COMBINED_TYPE(type)) {
        cnt = 1;
    }

    /* Traverse table array. */
    for (j = 0; j < cnt; j++) {
        map_tmp = map->entry;
        base_index_tmp = base_index;
        tbl_id = qos_table[type].remark_tbl_id[j];
        mode = qos_table[type].mode[j];

        /* Inner vlan dot1p remarking use table 1. */
        if (map->flags & BCM_QOS_MAP_L2_INNER_TAG) {
            tbl_id = qos_table[type].remark_tbl_id[1];
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit,
                                  qos_remark_tbl_name[tbl_id],
                                  &entry_hdl));
        for (i = 0; i < set_sz; i++) {
            valid = true;
            drop = false;
            field = 0;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, BASE_INDEXs, base_index_tmp));

            rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                                    BCMLT_PRIORITY_NORMAL);
            if (rv == SHR_E_NOT_FOUND) {
                valid = false;
            } else if (SHR_SUCCESS(rv)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, QOS_FIELDs, &data));
                field = (int)data;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, PKT_DROPs, &data));
                drop = (bool)data;
            } else {
                SHR_ERR_EXIT(rv);
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (qos_field_to_map(unit, mode, field, drop, valid, map_tmp));
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_table_index_to_map(unit,
                                        type,
                                        mode,
                                        base_index_tmp,
                                        map_tmp));
            base_index_tmp++;
            map_tmp++;
        }
        bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add map table entry or entries.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 * \param [in] set Add full set or single entry.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_table_add(int unit, int index, bcmint_qos_map_t *map, bool set)
{
    qos_xfs_map_type_t type;
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map->type, &type));
    if (set) {
        if (QOS_MAP_IS_ING_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_ingress_table_add_array(unit, index, map));
        } else if (QOS_MAP_IS_EGR_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_egress_table_add_array(unit, index, map));
        }
    } else {
        if (QOS_MAP_IS_ING_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_ingress_table_add(unit, index, map));
        } else if (QOS_MAP_IS_EGR_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_egress_table_add(unit, index, map));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete map table entry or entries.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 * \param [in] set Delete full set or single entry.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_table_delete(int unit, int index, bcmint_qos_map_t *map, bool set)
{
    qos_xfs_map_type_t type;
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map->type, &type));
    if (set) {
        if (QOS_MAP_IS_ING_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_ingress_table_delete_array(unit, index, map));
        } else if (QOS_MAP_IS_EGR_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_egress_table_delete_array(unit, index, map));
        }
    } else {
        if (QOS_MAP_IS_ING_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_ingress_table_delete(unit, index, type));
        } else if (QOS_MAP_IS_EGR_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_egress_table_delete(unit, index, type));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get map table entry or entries.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] set Delete full set or single entry.
 * \param [out] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_table_get(int unit, int index, bool set, bcmint_qos_map_t *map)
{
    qos_xfs_map_type_t type;
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map->type, &type));
    if (set) {
        if (QOS_MAP_IS_ING_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_ingress_table_get_array(unit, index, map));
        } else if (QOS_MAP_IS_EGR_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_egress_table_get_array(unit, index, map));
        }
    } else {
        if (QOS_MAP_IS_ING_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_ingress_table_get(unit, index, map));
        } else if (QOS_MAP_IS_EGR_TYPE(type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_egress_table_get(unit, index, map));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create a QoS map.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [out] map_id QoS map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_create(int unit, uint32_t flags, int *map_id)
{
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int id = -1, alloc_size, set_size, index;
    bcmint_qos_map_t map;
    SHR_FUNC_ENTER(unit);

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));

    /* Get map type from QoS flags. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_get_by_flags(unit, flags, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));

    if (flags & BCM_QOS_MAP_WITH_ID) {
        /* Validate map id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_check(unit, flags, type, *map_id, &id));
        /* Stage table index. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_table_index_stage(unit, type, id));
        qos_map_id_hold(unit, type, id);
    } else {
        /* Allocate a map id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_alloc(unit, type, &id));
        /* Stage table index. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_table_index_stage(unit, type, id));

        qos_map_id_hold(unit, type, id);
        /* Return BCM map id. */
        *map_id = id | (map_type << QOS_MAP_SHIFT);
    }

    /* Get map set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));
    alloc_size = set_size * sizeof(bcm_qos_map_t);

    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);

    map.type = map_type;
    map.flags = flags;
    map.count = &set_size;

    /* Get table index. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_to_table_index(unit, id, &map, &index));

    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map, true));

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a QoS map.
 *
 * \param [in] unit Unit Number.
 * \param [in] map_id QoS map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_destroy(int unit, int map_id)
{
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    bcmint_qos_map_t map;
    int id, set_size, index;

    SHR_FUNC_ENTER(unit);
    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    /* Get native map id from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_native_id(unit, map_id, &id));
    /* Validate native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_native_map_id_validate(unit, id, type));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* Get map set size by map type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));

    map.count = &set_size;
    map.type = map_type;
    map.entry = sal_alloc(sizeof(bcm_qos_map_t), "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, sizeof(bcm_qos_map_t));

    /* Get table index. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_to_table_index(unit, id, &map, &index));

    /* Delete qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_delete(unit, index, &map, true));
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_free(unit, type, id));

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check QoS map parameter.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [in] type QoS map type.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_param_check(int unit, uint32_t flags, qos_xfs_map_type_t type,
                    bcm_qos_map_t *map)
{
    int i;
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case QoSMapTypeL2Ingress:
            if (!(flags & BCM_QOS_MAP_L2) || !(flags & BCM_QOS_MAP_INGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_pri > QOS_INT_PRI_MASK) || (map->int_pri < 0) ||
                (map->pkt_pri > QOS_PKT_PRI_MASK) || (map->pkt_cfi > 1) ||
                ((map->color != bcmColorGreen) &&
                (map->color != bcmColorYellow) &&
                (map->color != bcmColorRed))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeL3Ingress:
            if (!(flags & BCM_QOS_MAP_L3) || !(flags & BCM_QOS_MAP_INGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_pri > QOS_INT_PRI_MASK) || (map->int_pri < 0) ||
                (map->dscp > QOS_PKT_DSCP_MASK) || (map->dscp < 0) ||
                ((map->color != bcmColorGreen) &&
                 (map->color != bcmColorYellow) &&
                 (map->color != bcmColorRed))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeMplsIngress:
            if (!(flags & BCM_QOS_MAP_MPLS) || !(flags & BCM_QOS_MAP_INGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_pri > QOS_INT_PRI_MASK) || (map->int_pri < 0) ||
                (map->exp > QOS_PKT_EXP_MASK) || (map->exp < 0) ||
                ((map->color != bcmColorGreen) &&
                (map->color != bcmColorYellow) &&
                (map->color != bcmColorRed))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeL2Egress:
            if (!((flags & BCM_QOS_MAP_L2) ||
                  (flags & BCM_QOS_MAP_L2_INNER_TAG))||
                !(flags & BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_pri > QOS_INT_PRI_MASK) || (map->int_pri < 0) ||
                (map->pkt_pri > QOS_PKT_PRI_MASK) || (map->pkt_cfi > 1) ||
                ((map->color != bcmColorGreen) &&
                (map->color != bcmColorYellow) &&
                (map->color != bcmColorRed))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeL3Egress:
            if (!(flags & BCM_QOS_MAP_L3) || !(flags & BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_pri > QOS_INT_PRI_MASK) || (map->int_pri < 0) ||
                (map->dscp > QOS_PKT_DSCP_MASK) || (map->dscp < 0) ||
                ((map->color != bcmColorGreen) &&
                 (map->color != bcmColorYellow) &&
                 (map->color != bcmColorRed))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeMplsEgress:
            if (!(flags & BCM_QOS_MAP_MPLS) || !(flags & BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_pri > QOS_INT_PRI_MASK) || (map->int_pri < 0) ||
                (map->exp > QOS_PKT_EXP_MASK) || (map->exp < 0) ||
                (map->int_cn > QOS_INT_CN_MASK) ||
                ((map->color != bcmColorGreen) &&
                 (map->color != bcmColorYellow) &&
                 (map->color != bcmColorRed))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeFwdEcnEgress:
            if (!(flags & BCM_QOS_MAP_ECN) || !(flags & BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_cn > QOS_INT_CN_MASK) ||
                (map->pkt_ecn > QOS_PKT_ECN_MASK) ||
                (map->latency_marked > 1)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeTnlEcnEgress:
            if (!(flags & BCM_QOS_MAP_ECN) || !(flags & BCM_QOS_MAP_EGRESS) ||
                !(flags & BCM_QOS_MAP_ENCAP)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_cn > QOS_INT_CN_MASK) ||
                (map->pkt_ecn > QOS_PKT_ECN_MASK) ||
                (map->responsive > 1) ||
                (map->latency_marked > 1)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeFwdEcnDscpEgress:
            if (!(flags & BCM_QOS_MAP_ECN) || !(flags & BCM_QOS_MAP_EGRESS) ||
                !(flags & BCM_QOS_MAP_L3)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_cn > QOS_INT_CN_MASK) ||
                (map->pkt_ecn > QOS_PKT_ECN_MASK) ||
                (map->latency_marked > 1)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_pri > QOS_INT_PRI_MASK) || (map->int_pri < 0) ||
                (map->dscp > QOS_PKT_DSCP_MASK) || (map->dscp < 0) ||
                ((map->color != bcmColorGreen) &&
                 (map->color != bcmColorYellow) &&
                 (map->color != bcmColorRed))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeTnlEcnDscpEgress:
            if (!(flags & BCM_QOS_MAP_ECN) || !(flags & BCM_QOS_MAP_EGRESS) ||
                !(flags & BCM_QOS_MAP_ENCAP) || !(flags & BCM_QOS_MAP_L3)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_cn > QOS_INT_CN_MASK) ||
                (map->pkt_ecn > QOS_PKT_ECN_MASK) ||
                (map->responsive > 1) ||
                (map->latency_marked > 1)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_pri > QOS_INT_PRI_MASK) || (map->int_pri < 0) ||
                (map->dscp > QOS_PKT_DSCP_MASK) || (map->dscp < 0) ||
                ((map->color != bcmColorGreen) &&
                 (map->color != bcmColorYellow) &&
                 (map->color != bcmColorRed))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeMplsTnlEgress:
            if (!(flags & BCM_QOS_MAP_MPLS) || !(flags & BCM_QOS_MAP_EGRESS) ||
                !(flags & BCM_QOS_MAP_ENCAP)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->int_pri > QOS_INT_PRI_MASK) || (map->int_pri < 0) ||
                (map->int_cn > QOS_INT_CN_MASK) ||
                ((map->color != bcmColorGreen) &&
                 (map->color != bcmColorYellow) &&
                 (map->color != bcmColorRed))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            for (i = 0; i < BCM_QOS_MAX_TUNNEL_EXP; i++) {
                if ((map->tunnel_exp[i] > QOS_PKT_EXP_MASK) ||
                    ((map->tunnel_exp[i] < 0) && (map->tunnel_exp[i] !=
                      BCM_MPLS_EXP_INVALID))) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }
            }
            break;
        case QoSMapTypeCopiedL2Egress:
            if (!(flags & BCM_QOS_MAP_L2) || !(flags & BCM_QOS_MAP_EGRESS) ||
                !(flags & BCM_QOS_MAP_INGRESS_COPIED)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->pkt_pri > QOS_PKT_PRI_MASK) || (map->pkt_cfi > 1) ||
                (map->copied_pkt_pri > QOS_PKT_PRI_MASK) ||
                (map->copied_pkt_cfi > 1)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeCopiedL3Egress:
            if (!(flags & BCM_QOS_MAP_L3) || !(flags & BCM_QOS_MAP_EGRESS) ||
                !(flags & BCM_QOS_MAP_INGRESS_COPIED)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->copied_pkt_dscp > QOS_PKT_DSCP_MASK) ||
                (map->dscp > QOS_PKT_DSCP_MASK) || (map->dscp < 0)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeCopiedEcnEgress:
            if (!(flags & BCM_QOS_MAP_ECN) || !(flags & BCM_QOS_MAP_EGRESS) ||
                !(flags & BCM_QOS_MAP_INGRESS_COPIED)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->copied_pkt_ecn > QOS_PKT_ECN_MASK) ||
                (map->pkt_ecn > QOS_PKT_ECN_MASK)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeCopiedL3EcnEgress:
            if (!(flags & BCM_QOS_MAP_ECN) || !(flags & BCM_QOS_MAP_EGRESS) ||
                !(flags & BCM_QOS_MAP_INGRESS_COPIED) ||
                !(flags & BCM_QOS_MAP_L3)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((map->copied_pkt_dscp > QOS_PKT_DSCP_MASK) ||
                (map->dscp > QOS_PKT_DSCP_MASK) || (map->dscp < 0) ||
                (map->copied_pkt_ecn > QOS_PKT_ECN_MASK) ||
                (map->pkt_ecn > QOS_PKT_ECN_MASK)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief QoS clear map set.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in|out] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_clr_map_set(int unit, qos_xfs_map_type_t type, bcm_qos_map_t *map)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case QoSMapTypeL2Ingress:
            map->int_pri = 0;
            map->color = bcmColorGreen;
            break;
        case QoSMapTypeL3Ingress:
            map->int_pri = 0;
            map->color = bcmColorGreen;
            break;
        case QoSMapTypeMplsIngress:
            map->int_pri = 0;
            map->color = bcmColorGreen;
            break;
        case QoSMapTypeL2Egress:
        case QoSMapTypeCopiedL2Egress:
            map->pkt_pri = 0;
            map->pkt_cfi = 0;
            break;
        case QoSMapTypeL3Egress:
        case QoSMapTypeCopiedL3Egress:
            map->pkt_pri = 0;
            map->pkt_cfi = 0;
            map->dscp = 0;
            break;
        case QoSMapTypeMplsEgress:
            map->exp = 0;
            break;
        case QoSMapTypeFwdEcnEgress:
        case QoSMapTypeTnlEcnEgress:
        case QoSMapTypeCopiedEcnEgress:
            map->pkt_ecn = 0;
            break;
        case QoSMapTypeFwdEcnDscpEgress:
        case QoSMapTypeTnlEcnDscpEgress:
        case QoSMapTypeCopiedL3EcnEgress:
            map->dscp = 0;
            map->pkt_ecn = 0;
            break;
        case QoSMapTypeMplsTnlEgress:
            sal_memset(map->tunnel_exp, 0,
                       sizeof(int) * BCM_QOS_MAX_TUNNEL_EXP);
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }
    map->actions = 0;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add an entry into a QoS map.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [in] map QoS map.
 * \param [in] map_id QoS map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_add(int unit, uint32_t flags, bcm_qos_map_t *qos_map, int map_id)
{
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    bcm_qos_map_t qos_map_tmp;
    bcmint_qos_map_t map;
    int id, count = 1, index;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(qos_map, SHR_E_PARAM);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    /* Get native map id from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_native_id(unit, map_id, &id));
    /* Validate native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_native_map_id_validate(unit, id, type));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Validate map parameter. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_param_check(unit, flags, type, qos_map));

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));
    sal_memcpy(&qos_map_tmp, qos_map, sizeof(bcm_qos_map_t));
    map.type = map_type;
    map.flags = flags;
    map.count = &count;
    map.entry = &qos_map_tmp;

    /* Get table index. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_to_table_index(unit, id, &map, &index));

    /* Add qos map table entry. */
    /* coverity[callee_ptr_arith : FALSE] */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map, false));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete an entry from a QoS map.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [in] map QoS map.
 * \param [in] map_id QoS map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_delete(int unit, uint32_t flags, bcm_qos_map_t *qos_map, int map_id)
{
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int id, count = 1, index;
    bcm_qos_map_t clr_map;
    bcmint_qos_map_t map;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(qos_map, SHR_E_PARAM);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    /* Get native map id from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_native_id(unit, map_id, &id));
    /* Validate native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_native_map_id_validate(unit, id, type));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    sal_memcpy(&clr_map, qos_map, sizeof(clr_map));
    /* Clear the map. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_clr_map_set(unit, type, &clr_map));

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));
    map.type = map_type;
    map.flags = flags;
    map.count = &count;
    map.entry = &clr_map;

    /* Get table index. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_to_table_index(unit, id, &map, &index));

    /* Add qos map table entry. */
    /* coverity[callee_ptr_arith : FALSE] */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map, false));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Transform native map type to QoS map type.
 *
 * \param [in] unit       Unit Number.
 * \param [in] type       Native map type.
 * \param [out] map_type  QoS map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_native_type_to_qos_map_type(int unit, qos_xfs_map_type_t type,
                                bcmi_ltsw_qos_map_type_t *map_type)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case QoSMapTypeL2Ingress:
        case QoSMapTypeL3Ingress:
        case QoSMapTypeMplsIngress:
        case QoSMapTypeL2Egress:
        case QoSMapTypeL3Egress:
        case QoSMapTypeMplsEgress:
        case QoSMapTypeFwdEcnEgress:
        case QoSMapTypeFwdEcnDscpEgress:
        case QoSMapTypeTnlEcnEgress:
        case QoSMapTypeTnlEcnDscpEgress:
        case QoSMapTypeCopiedL2Egress:
        case QoSMapTypeCopiedL3Egress:
        case QoSMapTypeCopiedEcnEgress:
        case QoSMapTypeCopiedL3EcnEgress:
            *map_type = (bcmi_ltsw_qos_map_type_t)type;
            break;
        case QoSMapTypeMplsTnlEgress:
            *map_type = bcmiQosMapTypeMplsTnlEgress;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Search QoS map id with mapping pointer and QoS map type.
 *
 * \param [in] unit Unit Number.
 * \param [in] ptr Mapping pointer.
 * \param [in] type Native map type.
 * \param [out] map_id QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_id_search_by_index(int unit, int ptr, qos_xfs_map_type_t type,
                           int *map_id)
{
    int id, ptr_tmp, num;
    qos_cfg_t *qos_db = QOS_CFG(unit);
    bcmi_ltsw_qos_map_type_t mtype;
    SHR_FUNC_ENTER(unit);

    num = qos_db->map_sz[type];
    for (id = 0; id < num; id++) {
        if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
            continue;
        }
        if (QOS_EGR_TBL_IDX(unit, type, id) == -1) {
            /* QoS map has been destroyed. */
            SHR_ERR_EXIT(SHR_E_NOT_FOUND);
        }
        ptr_tmp = QOS_EGR_TBL_IDX(unit, type, id) >>
                  QOS_REMARK_BASE_SHIFT;
        if (ptr_tmp == ptr) {
            /* Transform native type back to map type. */
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_native_type_to_qos_map_type
                     (unit, type, &mtype));
            *map_id = id | (mtype << QOS_MAP_SHIFT);
            SHR_EXIT();
        }
    }
    if (id >= num) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Search QoS map id with mapping pointer and multiple QoS map types.
 *
 * \param [in] unit Unit Number.
 * \param [in] ptr Mapping pointer.
 * \param [in] num Number of type array elements.
 * \param [in] type_array Native map type array.
 * \param [out] map_id QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_id_get_by_types_and_index(int unit, int ptr, int num,
                                  qos_xfs_map_type_t *type_array,
                                  int *map_id)
{
    int i, rv = SHR_E_NONE;
    SHR_FUNC_ENTER(unit);

    for (i = 0; i < num; i++) {
        rv = qos_map_id_search_by_index(unit, ptr, type_array[i], map_id);
        if (SHR_SUCCESS(rv)) {
            SHR_EXIT();
        } else if (rv == SHR_E_NOT_FOUND) {
            continue;
        }
    }
    SHR_ERR_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct QoS map id with mapping pointer and QoS map type.
 *
 * \param [in] unit Unit Number.
 * \param [in] ptr Mapping pointer.
 * \param [in] map_type QoS map type.
 * \param [out] map_id QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_id_construct(int unit, int ptr, bcmi_ltsw_qos_map_type_t map_type,
                     int *map_id)
{
    int id, ptr_tmp, num, set_size;
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t mtype;
    qos_xfs_map_type_t type_array[QoSMapTypeCount];
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(map_id, SHR_E_PARAM);

    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));

    switch (type) {
        case QoSMapTypeL2Ingress:
            id = ptr / set_size;
            break;
        case QoSMapTypeL3Ingress:
            ptr_tmp = ptr - qos_db->blk_sz[QoSMapTypeL2Ingress];
            id = ptr_tmp / set_size;
            break;
        case QoSMapTypeMplsIngress:
            ptr_tmp = ptr - qos_db->blk_sz[QoSMapTypeL2Ingress] -
                      qos_db->blk_sz[QoSMapTypeL3Ingress];
            id = ptr_tmp / set_size;
            break;
        case QoSMapTypeFwdEcnDscpEgress:
        case QoSMapTypeFwdEcnEgress:
        case QoSMapTypeL3Egress:
        case QoSMapTypeCopiedL3Egress:
        case QoSMapTypeCopiedEcnEgress:
        case QoSMapTypeCopiedL3EcnEgress:
            num = 0;
            type_array[num++] = QoSMapTypeFwdEcnDscpEgress;
            type_array[num++] = QoSMapTypeFwdEcnEgress;
            type_array[num++]= QoSMapTypeL3Egress;
            type_array[num++] = QoSMapTypeCopiedL3Egress;
            type_array[num++] = QoSMapTypeCopiedEcnEgress;
            type_array[num++]= QoSMapTypeCopiedL3EcnEgress;
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_id_get_by_types_and_index(unit, ptr, num,
                                                   type_array, map_id));
            SHR_EXIT();
            break;
        case QoSMapTypeTnlEcnDscpEgress:
        case QoSMapTypeTnlEcnEgress:
            num = 0;
            type_array[num++] = QoSMapTypeTnlEcnDscpEgress;
            type_array[num++] = QoSMapTypeTnlEcnEgress;
            type_array[num++]= QoSMapTypeL3Egress;
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_id_get_by_types_and_index(unit, ptr, num,
                                                   type_array, map_id));
            SHR_EXIT();
            break;
        case QoSMapTypeL2Egress:
        case QoSMapTypeMplsEgress:
        case QoSMapTypeMplsTnlEgress:
        case QoSMapTypeCopiedL2Egress:
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_id_search_by_index(unit, ptr, type, map_id));
            SHR_EXIT();
            break;
        default:
            SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    if (id < 0) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* Transform native type back to map type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_native_type_to_qos_map_type(unit, type, &mtype));
    *map_id = id | (mtype << QOS_MAP_SHIFT);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Select the source of egress VLAN priority on port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port id.
 * \param [in] src Source of egress VLAN priority.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_egr_l2_map_set(int unit, bcm_port_t port, int src)
{
    int l2_oif, index, ptr, cur_index;
    bcm_port_t port_out;
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    SHR_FUNC_ENTER(unit);

    /* Validate port. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &port_out));

    /* Get L2 oif. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_to_l2_if(unit, port, &l2_oif));

    /* Get current mapping ptr. */
    cur_index = qos_db->egr_l2_oif_dot1p_ptr[l2_oif];
    ptr = cur_index & QOS_MAP_ID_MASK;
    type = cur_index >> QOS_MAP_SHIFT;

    switch (src) {
        case bcmPortEgressVlanPriSrcIntPri:
            index = (type == QoSMapTypeL2Egress) ? ptr :
                    qos_db->def_ptr[QoSMapTypeL2Egress];
            break;
        case bcmPortEgressVlanPriSrcVpn:
            index = 0;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
            break;
    }

    /* Set mapping ptr. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                port,
                                BCMI_PT_PHB_VLAN,
                                index));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the source of egress VLAN priority on port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port id.
 * \param [out] src Source of egress VLAN priority.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_egr_l2_map_get(int unit, bcm_port_t port, int *src)
{
    int index;
    bcm_port_t port_out;
    SHR_FUNC_ENTER(unit);

    /* Validate port. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &port_out));

    /* Get mapping ptr. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_get(unit, port, BCMI_PT_PHB_VLAN, &index));
    if (index == 0) {
        *src = bcmPortEgressVlanPriSrcVpn;
        SHR_EXIT();
    } else {
        *src = bcmPortEgressVlanPriSrcIntPri;
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear QoS ingress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_ing_map_clear(int unit, bcm_gport_t port)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    int index;
    SHR_FUNC_ENTER(unit);

    index = qos_db->def_ptr[QoSMapTypeL2Ingress];

    /* Clear dot1p ptr. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                port,
                                BCMI_PT_VLAN_PHB,
                                index));

    /* Disable DSCP mapping. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                port,
                                BCMI_PT_DSCP_MAP_TO_PHB,
                                0));

    /* Clear DSCP ptr. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                port,
                                BCMI_PT_DSCP_PHB,
                                0));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set QoS ingress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] map_id QoS Map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_ing_map_set(int unit, bcm_gport_t port, int map_id)
{
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int id, index;
    bcmi_ltsw_port_tab_t ptype1 = 0, ptype2 = 0;
    bcmint_qos_map_t map;
    SHR_FUNC_ENTER(unit);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    /* Get native map id from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_native_id(unit, map_id, &id));
    /* Validate native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_native_map_id_validate(unit, id, type));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    switch (type) {
        case QoSMapTypeL2Ingress:
            ptype1 = BCMI_PT_OVLAN_MAP_TO_PHB;
            ptype2 = BCMI_PT_VLAN_PHB;
            break;
        case QoSMapTypeL3Ingress:
            ptype1 = BCMI_PT_DSCP_MAP_TO_PHB;
            ptype2 = BCMI_PT_DSCP_PHB;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));
    map.type = map_type;
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_to_table_index(unit, id, &map, &index));

    /* Enable mapping. */
    if (ptype1 != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit, port, ptype1, 1));
    }

    /* Set mapping ptr. */
    if (ptype2 != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit, port, ptype2, index));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get QoS ingress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] flags QoS flags.
 * \param [out] map_id QoS Map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_ing_map_get(int unit, bcm_gport_t port, uint32_t flags, int *map_id)
{
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int index = 0;
    bcmi_ltsw_port_tab_t ptype1 = 0;
    uint32_t flags_tmp = flags;
    SHR_FUNC_ENTER(unit);

    /* Get map type from QoS flags. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_get_by_flags(unit, flags, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    flags_tmp &= ~BCM_QOS_MAP_INGRESS;

    switch (type) {
        case QoSMapTypeL2Ingress:
            ptype1 = BCMI_PT_VLAN_PHB;
            flags_tmp &= ~BCM_QOS_MAP_L2;
            break;
        case QoSMapTypeL3Ingress:
            ptype1 = BCMI_PT_DSCP_PHB;
            flags_tmp &= ~BCM_QOS_MAP_L3;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* More flags that could not be handled. */
    if (flags_tmp) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Get mapping ptr. */
    if (ptype1 != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_get(unit, port, ptype1, &index));
    }

    /* Fetch map id from QoS map type and mapping ptr. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_construct(unit, index, map_type, map_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear QoS egress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_egr_map_clear(int unit, bcm_gport_t port)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    int l2_oif = 0, index, src;
    qos_xfs_map_type_t type;
    SHR_FUNC_ENTER(unit);

    /* When Dot1p remarking is disabled on one port, only update bookkeeping. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_egr_l2_map_get(unit, port, &src));

    /* Get L2 oif. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_to_l2_if(unit, port, &l2_oif));
    index = qos_db->egr_l2_oif_dot1p_ptr[l2_oif];
    type = index >> QOS_MAP_SHIFT;
    if (type == 0) {
        /* For upgrade. */
        type = QoSMapTypeL2Egress;
    }
    index = qos_db->def_ptr[type];

    if (src != bcmPortEgressVlanPriSrcVpn) {
        /* Clear dot1p ptr. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit,
                                    port,
                                    BCMI_PT_PHB_VLAN,
                                    index));
    }
    qos_db->egr_l2_oif_dot1p_ptr[l2_oif] = (type << QOS_MAP_SHIFT) | index;

    /* Clear DSCP ptr. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                port,
                                BCMI_PT_PHB_DSCP,
                                0));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set QoS egress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] map_id QoS Map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_egr_map_set(int unit, bcm_gport_t port, int map_id)
{
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int id, index, l2_oif, src;
    bcmi_ltsw_port_tab_t ptype1 = 0;
    bcmint_qos_map_t map;
    qos_cfg_t *qos_db = QOS_CFG(unit);
    SHR_FUNC_ENTER(unit);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    /* Get native map id from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_native_id(unit, map_id, &id));
    /* Validate native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_native_map_id_validate(unit, id, type));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* When Dot1p remarking is disabled on one port, only update bookkeeping. */
    if (type == QoSMapTypeL2Egress ||
        type == QoSMapTypeCopiedL2Egress) {
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_port_egr_l2_map_get(unit, port, &src));
    }

    switch (type) {
        case QoSMapTypeL2Egress:
            if (src == bcmPortEgressVlanPriSrcIntPri) {
                ptype1 = BCMI_PT_PHB_VLAN;
            }
            break;
        case QoSMapTypeCopiedL2Egress:
            if (src == bcmPortEgressVlanPriSrcPktPri) {
                ptype1 = BCMI_PT_PHB_VLAN;
            }
            break;
        case QoSMapTypeL3Egress:
        case QoSMapTypeFwdEcnEgress:
        case QoSMapTypeFwdEcnDscpEgress:
        case QoSMapTypeCopiedL3Egress:
        case QoSMapTypeCopiedEcnEgress:
        case QoSMapTypeCopiedL3EcnEgress:
            ptype1 = BCMI_PT_PHB_DSCP;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));
    map.type = map_type;
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_to_table_index(unit, id, &map, &index));

    index = index >> QOS_REMARK_BASE_SHIFT;

    /* Get L2 oif. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_to_l2_if(unit, port, &l2_oif));

    /* Set mapping ptr. */
    if (ptype1 != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit,
                                    port,
                                    ptype1,
                                    index));
    }

    if (type == QoSMapTypeL2Egress ||
        type == QoSMapTypeCopiedL2Egress) {
        /* Store pointer together with type. */
        qos_db->egr_l2_oif_dot1p_ptr[l2_oif] = (type << QOS_MAP_SHIFT) | index;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get QoS egress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] flags QoS flags.
 * \param [out] map_id QoS Map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_egr_map_get(int unit, bcm_gport_t port, uint32_t flags, int *map_id)
{
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int index = 0, l2_oif;
    bcmi_ltsw_port_tab_t ptype1 = 0;
    uint32_t flags_tmp = flags;
    qos_cfg_t *qos_db = QOS_CFG(unit);
    SHR_FUNC_ENTER(unit);

    /* Get map type from QoS flags. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_get_by_flags(unit, flags, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    flags_tmp &= ~BCM_QOS_MAP_EGRESS;

    switch (type) {
        case QoSMapTypeL2Egress:
            flags_tmp &= ~BCM_QOS_MAP_L2;
            break;
        case QoSMapTypeL3Egress:
            ptype1 = BCMI_PT_PHB_DSCP;
            flags_tmp &= ~BCM_QOS_MAP_L3;
            break;
        case QoSMapTypeFwdEcnEgress:
            ptype1 = BCMI_PT_PHB_DSCP;
            flags_tmp &= ~BCM_QOS_MAP_ECN;
            break;
        case QoSMapTypeFwdEcnDscpEgress:
            ptype1 = BCMI_PT_PHB_DSCP;
            flags_tmp &= ~(BCM_QOS_MAP_ECN | BCM_QOS_MAP_L3);
            break;
        case QoSMapTypeCopiedL2Egress:
            flags_tmp &= ~(BCM_QOS_MAP_L2 | BCM_QOS_MAP_INGRESS_COPIED);
            break;
        case QoSMapTypeCopiedL3Egress:
            ptype1 = BCMI_PT_PHB_DSCP;
            flags_tmp &= ~(BCM_QOS_MAP_L3 | BCM_QOS_MAP_INGRESS_COPIED);
            break;
        case QoSMapTypeCopiedEcnEgress:
            ptype1 = BCMI_PT_PHB_DSCP;
            flags_tmp &= ~(BCM_QOS_MAP_ECN | BCM_QOS_MAP_INGRESS_COPIED);
            break;
        case QoSMapTypeCopiedL3EcnEgress:
            ptype1 = BCMI_PT_PHB_DSCP;
            flags_tmp &= ~(BCM_QOS_MAP_ECN | BCM_QOS_MAP_L3 |
                           BCM_QOS_MAP_INGRESS_COPIED);
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* More flags that could not be handled. */
    if (flags_tmp) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Get L2 oif. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_to_l2_if(unit, port, &l2_oif));

    /* Get remarking ptr. */
    if (ptype1 != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_get(unit, port, ptype1, &index));
    }

    /* For L2 egress map, read index from bookkeeping always. */
    if (type == QoSMapTypeL2Egress ||
        type == QoSMapTypeCopiedL2Egress) {
        index = qos_db->egr_l2_oif_dot1p_ptr[l2_oif] & QOS_MAP_ID_MASK;
    }

    /* Fetch map id from QoS map type and mapping ptr. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_construct(unit, index, map_type, map_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Attach QoS map to an object(Gport).
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] ing_map Ingress map id.
 * \param [in] egr_map Egress map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_map_set(int unit, bcm_gport_t port, int ing_map, int egr_map)
{
    int rv;
    bcm_port_t port_out;
    SHR_FUNC_ENTER(unit);

    if (BCM_GPORT_IS_MPLS_PORT(port) ||
        BCM_GPORT_IS_FLOW_PORT(port)) {
        /*
         * If both MPLS and QoS APIs are allowed to program the same
         * resource(like VP), MPLS API takes MPLS lock first, and then
         * QoS lock, QoS API takes QoS lock first, and then MPLS lock,
         * so there will be inevitably deadlock issue between them.
         * To avoid this deadlock issue, the functionality to attach QoS map
         * to MPLS/Flow port of this API is deprecated.
         * This functionality must be implemented in MPLS/Flow module.
         */
         SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else {
        /* Validate port. */
        rv = bcmi_ltsw_port_gport_validate(unit, port, &port_out);
        if (SHR_FAILURE(rv)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        /* -1 means no change. */
        if (ing_map != -1) {
            /* Clear the existing map. */
            if (ing_map == 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (qos_port_ing_map_clear(unit, port));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (qos_port_ing_map_set(unit, port, ing_map));
            }
        }

        /* -1 means no change. */
        if (egr_map != -1) {
            if (egr_map == 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (qos_port_egr_map_clear(unit, port));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (qos_port_egr_map_set(unit, port, egr_map));
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve the QoS maps attached to an object(Gport).
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] flags QoS flags.
 * \param [out] map_id QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_map_get(int unit, bcm_gport_t port, uint32_t flags, int *map_id)
{
    int rv;
    bcm_port_t port_out;
    SHR_FUNC_ENTER(unit);

    if (BCM_GPORT_IS_MPLS_PORT(port) ||
        BCM_GPORT_IS_FLOW_PORT(port)) {
        /*
         * If both MPLS and QoS APIs are allowed to program the same
         * resource(like VP), MPLS API takes MPLS lock first, and then
         * QoS lock, QoS API takes QoS lock first, and then MPLS lock,
         * so there will be inevitably deadlock issue between them.
         * To avoid this deadlock issue, the functionality to attach QoS map
         * to MPLS/Flow port of this API is deprecated.
         * This functionality must be implemented in MPLS/Flow module.
         */
         SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else {
        /* Validate port. */
        rv = bcmi_ltsw_port_gport_validate(unit, port, &port_out);
        if (SHR_FAILURE(rv)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        if (flags & BCM_QOS_MAP_INGRESS) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_port_ing_map_get(unit, port, flags, map_id));
        } else if (flags & BCM_QOS_MAP_EGRESS) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_port_egr_map_get(unit, port, flags, map_id));
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parameter check for QoS map multi get API.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [in] type QoS map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_multi_get_param_check(int unit, uint32_t flags, qos_xfs_map_type_t type)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case QoSMapTypeL2Ingress:
            if ((flags != (BCM_QOS_MAP_L2 | BCM_QOS_MAP_INGRESS)) &&
                (flags != (BCM_QOS_MAP_L2 | BCM_QOS_MAP_INGRESS |
                           BCM_QOS_MAP_L2_UNTAGGED))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeL3Ingress:
            if (flags != (BCM_QOS_MAP_L3 | BCM_QOS_MAP_INGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeMplsIngress:
            if (flags != (BCM_QOS_MAP_MPLS | BCM_QOS_MAP_INGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeL2Egress:
            if ((flags != (BCM_QOS_MAP_L2 | BCM_QOS_MAP_EGRESS)) &&
                (flags != (BCM_QOS_MAP_L2_INNER_TAG | BCM_QOS_MAP_EGRESS))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((flags & BCM_QOS_MAP_L2_OUTER_TAG) &&
                (flags & BCM_QOS_MAP_L2_INNER_TAG)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeL3Egress:
            if (flags != (BCM_QOS_MAP_L3 | BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeMplsEgress:
            if (flags != (BCM_QOS_MAP_MPLS | BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeFwdEcnEgress:
            if (flags != (BCM_QOS_MAP_ECN | BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeTnlEcnEgress:
            if (flags != (BCM_QOS_MAP_ECN | BCM_QOS_MAP_ENCAP |
                          BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeFwdEcnDscpEgress:
            if (flags != (BCM_QOS_MAP_ECN | BCM_QOS_MAP_L3 |
                          BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeTnlEcnDscpEgress:
            if (flags != (BCM_QOS_MAP_ECN | BCM_QOS_MAP_ENCAP |
                          BCM_QOS_MAP_L3 | BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeMplsTnlEgress:
            if (flags != (BCM_QOS_MAP_MPLS | BCM_QOS_MAP_EGRESS |
                          BCM_QOS_MAP_ENCAP)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeCopiedL2Egress:
            if ((flags != (BCM_QOS_MAP_L2 | BCM_QOS_MAP_EGRESS |
                           BCM_QOS_MAP_INGRESS_COPIED)) &&
                (flags != (BCM_QOS_MAP_L2_INNER_TAG | BCM_QOS_MAP_EGRESS |
                           BCM_QOS_MAP_INGRESS_COPIED))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if ((flags & BCM_QOS_MAP_L2_OUTER_TAG) &&
                (flags & BCM_QOS_MAP_L2_INNER_TAG)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeCopiedL3Egress:
            if (flags != (BCM_QOS_MAP_L3 | BCM_QOS_MAP_EGRESS |
                          BCM_QOS_MAP_INGRESS_COPIED)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeCopiedEcnEgress:
            if (flags != (BCM_QOS_MAP_ECN | BCM_QOS_MAP_EGRESS |
                          BCM_QOS_MAP_INGRESS_COPIED)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeCopiedL3EcnEgress:
            if (flags != (BCM_QOS_MAP_ECN | BCM_QOS_MAP_L3 |
                          BCM_QOS_MAP_EGRESS | BCM_QOS_MAP_INGRESS_COPIED)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get an entire QoS mapping for the given QoS Map ID.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [in] map_id QoS map id.
 * \param [in] array_size Size of allocated entries in array.
 * \param [out] array QoS map array.
 * \param [out] count Actual number of QoS map entries.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_multi_get(int unit, uint32_t flags, int map_id, int array_size,
                  bcm_qos_map_t *array, int *count)
{
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    bcmint_qos_map_t map;
    int id, set_size, alloc_size, index;

    SHR_FUNC_ENTER(unit);
    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));

    SHR_NULL_CHECK(count, SHR_E_PARAM);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    /* Get native map id from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_native_id(unit, map_id, &id));
    /* Validate native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_native_map_id_validate(unit, id, type));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Flags checking. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_multi_get_param_check(unit, flags, type));

    /* Get map set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));

    /* Zero is to query. */
    if (array_size == 0) {
        *count = set_size;
        SHR_EXIT();
    }
    alloc_size = set_size * sizeof(bcm_qos_map_t);

    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);

    map.type = map_type;
    map.flags = flags;
    map.count = &set_size;

    /* Get table index. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_to_table_index(unit, id, &map, &index));

    /* Get map from table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_get(unit, index, true, &map));

    if (set_size >= array_size) {
        set_size = array_size;
    }
    *count = set_size;
    alloc_size = set_size * sizeof(bcm_qos_map_t);
    sal_memcpy(array, map.entry, alloc_size);

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the count of all used QoS Map IDs.
 *
 * \param [in] unit Unit Number.
 * \param [out] count Count of all QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_id_count_get(int unit, int *count)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    int cnt = 0;

    *count = 0;
    for (type = QoSMapTypeL2Ingress; type < QoSMapTypeCount; type++) {
        cnt = 0;
        /* Count bit size. */
        SHR_BITCOUNT_RANGE(qos_db->bmp[type], cnt, 0, qos_db->map_sz[type]);
        *count += cnt;
    }
    return SHR_E_NONE;
}

/*!
 * \brief Get all used map id and flags.
 *
 * \param [in] unit Unit Number.
 * \param [in] array_size Size of allocated entries in map_id array.
 * \param [out] map_id QoS map id array.
 * \param [out] flags QoS flags array.
 * \param [out] count Actual number of QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_id_used_get_all(int unit, int array_size, int *map_id,
                        int *flags, int *count)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int cnt = 0, id;
    uint32_t flags_tmp;

    SHR_FUNC_ENTER(unit);

    /* Traverse all map types. */
    for (type = QoSMapTypeL2Ingress; type < QoSMapTypeCount; type++) {
        flags_tmp = qos_table[type].flags;
        for (id = 0; (id < qos_db->map_sz[type]) && (cnt < array_size) ; id++) {
            if (QOS_MAP_BMP_USED_GET(unit, type, id)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (qos_native_type_to_qos_map_type(unit, type, &map_type));
                *(map_id + cnt) = id | (map_type << QOS_MAP_SHIFT);
                *(flags + cnt) = flags_tmp;
                cnt++;
            }
        }
    }
    *count = cnt;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the list of all QoS Map IDs.
 *
 * \param [in] unit Unit Number.
 * \param [in] array_size Size of allocated entries in map_id array.
 * \param [out] map_id QoS map id array.
 * \param [out] flags QoS flags array.
 * \param [out] count Actual number of QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_multi_get(int unit, int array_size, int *map_id,
              int *flags, int *count)
{
    SHR_FUNC_ENTER(unit);

    /* Zero to query the count. */
    if (array_size == 0) {
        SHR_NULL_CHECK(count, SHR_E_PARAM);

        /* Get the count of all used maps. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_count_get(unit, count));
    } else {
        SHR_NULL_CHECK(map_id, SHR_E_PARAM);
        SHR_NULL_CHECK(flags, SHR_E_PARAM);
        SHR_NULL_CHECK(count, SHR_E_PARAM);

        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_used_get_all(unit, array_size, map_id, flags, count));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init QoS ingress mapping strength profile table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_ing_strength_table_init(int unit)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {FLEX_QOS_ING_PHB_INT_PRI_STRENGTH_PROFILE_IDs,
               BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MAPPED_VALUE_STRENGTHs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {POLICY_VALUE_STRENGTHs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {BUS_VALUE_STRENGTHs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    bcmi_lt_field_t field_tmp[] =
    {
        /*0*/ {FLEX_QOS_ING_PHB_INT_CNG_STRENGTH_PROFILE_IDs,
               BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MAPPED_VALUE_STRENGTHs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {POLICY_VALUE_STRENGTHs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {BUS_VALUE_STRENGTHs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    const char *name = FLEX_QOS_ING_PHB_INT_PRI_STRENGTH_PROFILEs;

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = QOS_ING_STR_INT_PRI_PRF_IDX;
    field[1].u.val = QOS_ING_STR_MAP_VALUE;
    field[2].u.val = QOS_ING_STR_POLICY_VALUE;
    field[3].u.val = QOS_ING_STR_BUS_VALUE;

    /* Insert INT_PRI strength table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, name, &lt_entry, NULL));

    name = FLEX_QOS_ING_PHB_INT_CNG_STRENGTH_PROFILEs;
    lt_entry.fields = field_tmp;
    lt_entry.nfields = sizeof(field_tmp)/sizeof(field_tmp[0]);
    lt_entry.attr = 0;

    field_tmp[0].u.val = QOS_ING_STR_CNG_PRF_IDX;
    field_tmp[1].u.val = QOS_ING_STR_MAP_VALUE;
    field_tmp[2].u.val = QOS_ING_STR_POLICY_VALUE;
    field_tmp[3].u.val = QOS_ING_STR_BUS_VALUE;

    /* Insert CNG strength table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, name, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init QoS ingress policy table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_ing_policy_table_init(int unit)
{
    int i, j, ent_num, field_num, rv;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const bcmint_qos_ctrl_info_t *qos_ctrl = QOS_CTRL_INFO(unit);
    const bcmint_qos_tbl_db_t *qos_tbl_db;
    const bcmint_qos_tbl_info_t *tbl_info;
    const bcmint_qos_tbl_cfg_t  *tbl_cfg;
    const bcmint_qos_tbl_ent_t  *tbl_ent;
    bcmlt_priority_level_t priority = BCMLT_PRIORITY_NORMAL;
    SHR_FUNC_ENTER(unit);

    qos_tbl_db = qos_ctrl->tbl_db;
    tbl_info = &qos_tbl_db->tbls[QOS_TBL_ING_POLICY];
    tbl_cfg = tbl_info->tbl_cfg;
    ent_num = tbl_cfg->ent_num;
    field_num = tbl_cfg->field_num;

    for (i = 0; i < ent_num; i++) {
        tbl_ent = &tbl_cfg->ent[i];
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, tbl_info->name, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl,
                                          tbl_cfg->key_name[0],
                                          tbl_ent->key[0]));
        for (j = 0; j < field_num; j++) {
            if (tbl_cfg->field_array) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                                           tbl_cfg->field_array[j],
                                           tbl_ent->field[j]));
            }
        }

        rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE, priority);
        if (rv == SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT, priority));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init QoS egress policy table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_egr_policy_table_init(int unit)
{
    int i, j, ent_num, field_num, sym_field_num, rv;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const bcmint_qos_ctrl_info_t *qos_ctrl = QOS_CTRL_INFO(unit);
    const bcmint_qos_tbl_db_t *qos_tbl_db;
    const bcmint_qos_tbl_info_t *tbl_info;
    const bcmint_qos_tbl_cfg_t  *tbl_cfg;
    const bcmint_qos_tbl_ent_t  *tbl_ent;
    bcmlt_priority_level_t priority = BCMLT_PRIORITY_NORMAL;
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    int *def_ptr = qos_db->def_ptr;
    int egr_policy_field_value = 0;
    SHR_FUNC_ENTER(unit);

    qos_tbl_db = qos_ctrl->tbl_db;
    tbl_info = &qos_tbl_db->tbls[QOS_TBL_EGR_POLICY];
    tbl_cfg = tbl_info->tbl_cfg;
    ent_num = tbl_cfg->ent_num;
    sym_field_num = tbl_cfg->sym_field_num;
    field_num = tbl_cfg->field_num;

    for (i = 0; i < ent_num; i++) {
        tbl_ent = &tbl_cfg->ent[i];
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, tbl_info->name, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl,
                                          tbl_cfg->key_name[0],
                                          tbl_ent->key[0]));
        for (j = 0; j < sym_field_num; j++) {
            if (tbl_cfg->sym_field_array) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_symbol_add(entry_hdl,
                                                  tbl_cfg->sym_field_array[j],
                                                  tbl_ent->sym_field[j]));
            }
        }

        /*
         * Programming mapping pointer in policy table for dot1p/ToS copy profiles.
         */
        for (j = 0; j < field_num; j++) {
            if (tbl_cfg->field_array && tbl_ent->field_flags[j] != 0) {
                switch (tbl_ent->field_flags[j]) {
                    case BCMINT_QOS_EGR_POLICY_TABLE_FLAGS_L2_DOT1P_COPY:
                        type = QoSMapTypeCopiedL2Egress;
                        break;
                    case BCMINT_QOS_EGR_POLICY_TABLE_FLAGS_L3_TOS_COPY:
                        type = QoSMapTypeCopiedL3EcnEgress;
                        break;
                    case BCMINT_QOS_EGR_POLICY_TABLE_FLAGS_INT_CONGESTION_COPY:
                        type = QoSMapTypeIntCongestionCopyEgress;
                        break;
                    default:
                        SHR_ERR_EXIT(SHR_E_PARAM);
                }
                egr_policy_field_value = def_ptr[type];
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                                           tbl_cfg->field_array[j],
                                           egr_policy_field_value));
            }
        }

        /* Insert entry. */
        rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE, priority);
        if (rv == SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT, priority));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add L2 default mapping table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_ing_l2_default_add(int unit)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    int alloc_size, set_size, index, i;
    bcmint_qos_map_t map;
    bcm_qos_map_t *qos_map = NULL;
    SHR_FUNC_ENTER(unit);

    type = QoSMapTypeL2Ingress;
    /* Get map set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));
    alloc_size = set_size * sizeof(bcm_qos_map_t);

    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);
    map.type = bcmiQosMapTypeL2Ingress;
    map.flags = BCM_QOS_MAP_L2 | BCM_QOS_MAP_INGRESS;
    map.count = &set_size;

    qos_map = map.entry;
    /* Program default entries. */
    for (i = 0; i < set_size; i++) {
        qos_map->pkt_pri = (i >> 1) & QOS_PKT_PRI_MASK;
        qos_map->pkt_cfi = i & QOS_PKT_CFI_MASK;
        qos_map->int_pri = qos_map->pkt_pri;
        qos_map->color = qos_map->pkt_cfi;
        qos_map++;
    }
    index = 0;

    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map, true));
    qos_db->def_ptr[type] = index;

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable default dot1p mapping on all ports.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_ing_l2_mapping_port_enable_all(int unit)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    int index, data[2];
    bcm_pbmp_t pbmp;
    bcm_port_t port;
    bcmi_ltsw_port_tab_t type[2];
    SHR_FUNC_ENTER(unit);

    index = qos_db->def_ptr[QoSMapTypeL2Ingress];

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_ALL, &pbmp));
    /* Enable mapping. */
    type[0] = BCMI_PT_OVLAN_MAP_TO_PHB;
    data[0] = 1;

    /* Set mapping pointer. */
    type[1] = BCMI_PT_VLAN_PHB;
    data[1] = index;

    BCM_PBMP_ITER(pbmp, port) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_multi_set(unit, port, type, data, 2));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add L3 default mapping table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_ing_l3_default_add(int unit)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    int alloc_size, set_size, index;
    bcmint_qos_map_t map;
    SHR_FUNC_ENTER(unit);

    type = QoSMapTypeL3Ingress;
    /* Get map set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));
    alloc_size = set_size * sizeof(bcm_qos_map_t);

    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);
    map.type = bcmiQosMapTypeL3Ingress;
    map.flags = BCM_QOS_MAP_L3 | BCM_QOS_MAP_INGRESS;
    map.count = &set_size;

    index = qos_db->blk_sz[type - 1];

    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map, true));
    qos_db->def_ptr[type] = index;

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add L2 default remarking table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_egr_l2_default_add(int unit)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    int alloc_size, set_size, index, i, cng;
    bcmint_qos_map_t map;
    bcm_qos_map_t *qos_map = NULL;
    SHR_FUNC_ENTER(unit);

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));
    type = QoSMapTypeL2Egress;
    /* Get map set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));
    alloc_size = set_size * sizeof(bcm_qos_map_t);

    /* Allocate hardware table resource for egress map. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_table_resource_alloc(unit, type, &index));

    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);
    map.type = bcmiQosMapTypeL2Egress;
    map.flags = BCM_QOS_MAP_L2 | BCM_QOS_MAP_EGRESS;
    map.count = &set_size;

    qos_map = map.entry;
    /* Program default entries. */
    for (i = 0; i < set_size; i++) {
        qos_map->int_pri = i & QOS_INT_PRI_MASK;
        cng = (i >> 4) & QOS_INT_CNG_MASK;
        qos_map->color = BCMI_LTSW_QOS_COLOR_DECODING(cng);
        qos_map->pkt_pri = qos_map->int_pri > QOS_PKT_PRI_MASK ?
                           QOS_PKT_PRI_MASK : qos_map->int_pri;
        qos_map->pkt_cfi = cng > 1 ? 1 : cng;
        qos_map++;
    }

    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map, true));
    qos_db->def_ptr[type] = index >> QOS_REMARK_BASE_SHIFT;

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable default dot1p remarking on all ports.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_egr_l2_remarking_port_enable_all(int unit)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    int index, l2_iif;
    bcm_pbmp_t pbmp;
    bcm_port_t port;
    SHR_FUNC_ENTER(unit);

    index = qos_db->def_ptr[QoSMapTypeL2Egress];

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_ALL, &pbmp));

    BCM_PBMP_ITER(pbmp, port) {
        /* Get L2 iif. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_to_l2_if(unit, port, &l2_iif));

        /* Set remarking pointer. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit,
                                    port,
                                    BCMI_PT_PHB_VLAN,
                                    index));
        qos_db->egr_l2_oif_dot1p_ptr[l2_iif] = index |
            (QoSMapTypeL2Egress << QOS_MAP_SHIFT);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add default table entries for Vxlan flags remarking.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_egr_vxlan_flags_default_add(int unit)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    int set_size, index, ent_num, field_num, i, j, id, index_tmp;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const bcmint_qos_ctrl_info_t *qos_ctrl = QOS_CTRL_INFO(unit);
    const bcmint_qos_tbl_db_t *qos_tbl_db;
    const bcmint_qos_tbl_info_t *tbl_info;
    const bcmint_qos_tbl_cfg_t  *tbl_cfg;
    const bcmint_qos_tbl_ent_t  *tbl_ent;
    bcmlt_priority_level_t priority = BCMLT_PRIORITY_NORMAL;
    SHR_FUNC_ENTER(unit);

    qos_tbl_db = qos_ctrl->tbl_db;
    type = QoSMapTypeVxlanTnlFlagsEgress;
    /* Get map set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));

    /* Allocate hardware table resource for egress map. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_table_resource_alloc(unit, type, &index));

    /* Program entry for GBP & EVPN. */
    for (id = QOS_TBL_EGR_PHB_VXLAN_G; id <= QOS_TBL_EGR_PHB_VXLAN_BUM; id++) {
        tbl_info = &qos_tbl_db->tbls[id];
        tbl_cfg = tbl_info->tbl_cfg;
        ent_num = tbl_cfg->ent_num;
        field_num = tbl_cfg->field_num;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, tbl_info->name, &entry_hdl));

        for (i = 0; i < ent_num; i++) {
            tbl_ent = &tbl_cfg->ent[i];
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                                       tbl_cfg->key_name[0],
                                       tbl_ent->key_offset[0] + index));
            for (j = 0; j < field_num; j++) {
                if (tbl_cfg->field_array) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl,
                                               tbl_cfg->field_array[j],
                                               tbl_ent->field[j]));
                }
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT, priority));
        }
        bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    qos_db->def_ptr[type] = index >> QOS_REMARK_BASE_SHIFT;

    index += set_size;
    /* Allocate hardware table resource for egress map. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_table_resource_alloc(unit, type, &index_tmp));
    if (index != index_tmp) {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }
    /* Program entry for GBP & !EVPN. */
    tbl_info = &qos_tbl_db->tbls[QOS_TBL_EGR_PHB_VXLAN_G];
    tbl_cfg = tbl_info->tbl_cfg;
    ent_num = tbl_cfg->ent_num;
    field_num = tbl_cfg->field_num;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, tbl_info->name, &entry_hdl));

    for (i = 0; i < ent_num; i++) {
        tbl_ent = &tbl_cfg->ent[i];
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl,
                                   tbl_cfg->key_name[0],
                                   tbl_ent->key_offset[0] + index));
        for (j = 0; j < field_num; j++) {
            if (tbl_cfg->field_array) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                                           tbl_cfg->field_array[j],
                                           tbl_ent->field[j]));
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT, priority));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mapping pointer for Vxlan G/BUM flags remarking.
 *
 * \param [in] unit Unit Number.
 * \param [in] g_ena Enable G flag remarking.
 * \param [in] bum_ena Enable BUM flag remarking.
 * \param [out] ptr Mapping pointer.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_vxlan_flags_map_ptr_get(int unit, int g_ena, int bum_ena, int *ptr)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    int set_size;
    SHR_FUNC_ENTER(unit);

    /* G flag is always remarked in QoS. */
    if (!g_ena || !ptr) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    type = QoSMapTypeVxlanTnlFlagsEgress;
    /* Get map set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));

    switch (bum_ena) {
        case 1:
            *ptr = qos_db->def_ptr[type];
            break;
        case 0:
            /* Neighbour set. */
            *ptr = qos_db->def_ptr[type] + (set_size >> QOS_REMARK_BASE_SHIFT);
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add default copied L3 ECN egress map table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_egr_copied_l3_ecn_default_add(int unit)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    int alloc_size, set_size, index, i;
    bcmint_qos_map_t map;
    bcm_qos_map_t *qos_map = NULL;
    const bcmint_qos_ctrl_info_t *qos_ctrl = QOS_CTRL_INFO(unit);
    const bcmint_qos_attribute_remark_info_t *qos_remark = NULL;
    SHR_FUNC_ENTER(unit);

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));
    qos_remark = qos_ctrl->remark_info;
    if (!(qos_remark && qos_remark->copied_dscp_ecn_ena)) {
        SHR_EXIT();
    }

    type = QoSMapTypeCopiedL3EcnEgress;
    /* Get map set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));
    alloc_size = set_size * sizeof(bcm_qos_map_t);

    /* Allocate hardware table resource for egress map. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_table_resource_alloc(unit, type, &index));

    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);
    map.type = QoSMapTypeCopiedL3EcnEgress;
    map.flags = qos_table[type].flags;
    map.count = &set_size;

    qos_map = map.entry;
    /* Program default entries. */
    for (i = 0; i < set_size; i++) {
        qos_map->copied_pkt_dscp = i & QOS_PKT_DSCP_MASK;
        qos_map->copied_pkt_ecn = i & QOS_PKT_ECN_MASK;
        qos_map->dscp = qos_map->copied_pkt_dscp;
        qos_map->pkt_ecn = qos_map->copied_pkt_ecn;
        qos_map++;
    }

    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map, true));
    qos_db->def_ptr[type] = index >> QOS_REMARK_BASE_SHIFT;

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add default copied L2 egress map table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_egr_copied_l2_default_add(int unit)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    int alloc_size, set_size, index, i;
    bcmint_qos_map_t map;
    bcm_qos_map_t *qos_map = NULL;
    const bcmint_qos_ctrl_info_t *qos_ctrl = QOS_CTRL_INFO(unit);
    const bcmint_qos_attribute_remark_info_t *qos_remark = NULL;
    SHR_FUNC_ENTER(unit);

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));
    qos_remark = qos_ctrl->remark_info;
    if (!(qos_remark && qos_remark->copied_pri_cfi_ena)) {
        SHR_EXIT();
    }

    type = QoSMapTypeCopiedL2Egress;
    /* Get map set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));
    alloc_size = set_size * sizeof(bcm_qos_map_t);

    /* Allocate hardware table resource for egress map. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_table_resource_alloc(unit, type, &index));

    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);
    map.type = QoSMapTypeCopiedL2Egress;
    map.flags = qos_table[type].flags;
    map.count = &set_size;

    qos_map = map.entry;
    /* Program default entries. */
    for (i = 0; i < set_size; i++) {
        qos_map->copied_pkt_pri = (i >> 1) & QOS_PKT_PRI_MASK;
        qos_map->copied_pkt_cfi = i & QOS_PKT_CFI_MASK;
        qos_map->pkt_pri = qos_map->copied_pkt_pri;
        qos_map->pkt_cfi = qos_map->copied_pkt_cfi;
        qos_map++;
    }

    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map, true));
    qos_db->def_ptr[type] = index >> QOS_REMARK_BASE_SHIFT;

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add default table entries for internal congestion copy.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_egr_int_congestion_copy_default_add(int unit)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type;
    int set_size, index, ent_num, field_num, i, j, id;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const bcmint_qos_ctrl_info_t *qos_ctrl = QOS_CTRL_INFO(unit);
    const bcmint_qos_tbl_db_t *qos_tbl_db;
    const bcmint_qos_tbl_info_t *tbl_info;
    const bcmint_qos_tbl_cfg_t  *tbl_cfg;
    bcmlt_priority_level_t priority = BCMLT_PRIORITY_NORMAL;
    const bcmint_qos_attribute_remark_info_t *qos_remark = qos_ctrl->remark_info;
    SHR_FUNC_ENTER(unit);

    if (!qos_remark->copy_int_congestion_ena) {
        SHR_EXIT();
    }

    qos_tbl_db = qos_ctrl->tbl_db;
    type = QoSMapTypeIntCongestionCopyEgress;
    /* Get map set size. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_set_size_get(unit, type, &set_size));

    /* Allocate hardware table resource for egress map. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_table_resource_alloc(unit, type, &index));

    id = QOS_TBL_EGR_PHB_INT_CONGESTION_COPY;
    tbl_info = &qos_tbl_db->tbls[id];
    tbl_cfg = tbl_info->tbl_cfg;
    ent_num = tbl_cfg->ent_num;
    field_num = tbl_cfg->field_num;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, tbl_info->name, &entry_hdl));

    for (i = 0; i < ent_num; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl,
                                   tbl_cfg->key_name[0],
                                   i + index));
        for (j = 0; j < field_num; j++) {
            if (tbl_cfg->field_array && tbl_cfg->one_to_one) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                                           tbl_cfg->field_array[j],
                                           i));
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT, priority));
    }
    qos_db->def_ptr[type] = index >> QOS_REMARK_BASE_SHIFT;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init QoS table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_table_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Clear QoS table first. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_qos_table_clear_all(unit));

    /*
     * Reserve the first set of remarking table for invalid usage.
     */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_table_resource_reserve(unit, QoSMapTypeL2Egress, 0, 0));
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_table_resource_reserve(unit, QoSMapTypeL3Egress, 0, 0));
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_table_resource_reserve(unit, QoSMapTypeMplsEgress, 0, 0));
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_table_resource_reserve(unit, QoSMapTypeMplsTnlEgress, 0, 0));

    /* Add L2 default mapping table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_ing_l2_default_add(unit));

    /* Enable default L2 mapping on ports. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_ing_l2_mapping_port_enable_all(unit));

    /* Add L3 default mapping table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_ing_l3_default_add(unit));

    /* Add L2 default remarking table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_l2_default_add(unit));

    /* Enable default L2 remarking on ports. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_l2_remarking_port_enable_all(unit));

    /* Init ingress policy table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_ing_policy_table_init(unit));

    /* Init ingress strength table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_ing_strength_table_init(unit));

    /* Init remarking table for Vxlan flags remarking. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_vxlan_flags_default_add(unit));

    /* Init remarking table for per-port dot1p copy. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_copied_l2_default_add(unit));

    /* Init remarking table for L3 DSCP&ECN copy. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_copied_l3_ecn_default_add(unit));

    /* Init remarking table for internal congestion copy. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_int_congestion_copy_default_add(unit));

    /* Init egress policy table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_egr_policy_table_init(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Resolve QoS map id into mapping pointer and QoS map type.
 *
 * \param [in] unit Unit Number.
 * \param [in] map_id QoS map id.
 * \param [out] map_type QoS map type. NULL indicates not care.
 * \param [out] ptr Mapping pointer. NULL indicates not care.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_id_resolve(int unit, int map_id, bcmi_ltsw_qos_map_type_t *map_type,
                   int *ptr)
{
    qos_xfs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type_tmp;
    bcmint_qos_map_t map;
    int id, index;
    SHR_FUNC_ENTER(unit);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type_tmp));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type_tmp, &type));
    /* Get native map id from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_native_id(unit, map_id, &id));
    /* Validate native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_native_map_id_validate(unit, id, type));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));
    map.type = map_type_tmp;
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_to_table_index(unit, id, &map, &index));

    if (QOS_MAP_IS_EGR_TYPE(type)) {
        /* Check the index to avoid QoS map has been destroyed. */
        if (index == -1) {
            SHR_ERR_EXIT(SHR_E_NOT_FOUND);
        }
        index = index >> QOS_REMARK_BASE_SHIFT;
    }

    if (map_type != NULL) {
        *map_type = map_type_tmp;
    }
    if (ptr != NULL) {
        *ptr = index;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get default mapping pointer.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [out] ptr Mapping pointer.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_default_ptr_get(int unit, bcmi_ltsw_qos_map_type_t type, int *ptr)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xfs_map_type_t type_tmp;
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, type, &type_tmp));

    if (type_tmp != QoSMapTypeL2Ingress &&
        type_tmp != QoSMapTypeL3Ingress &&
        type_tmp != QoSMapTypeL2Egress &&
        type_tmp != QoSMapTypeCopiedL2Egress) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *ptr = qos_db->def_ptr[type_tmp];

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get dummy mapping pointer.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [out] ptr Mapping pointer.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_dummy_ptr_get(int unit, bcmi_ltsw_qos_map_type_t type, int *ptr)
{
    qos_xfs_map_type_t type_tmp;
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, type, &type_tmp));

    if (!QOS_MAP_IS_EGR_TYPE(type_tmp)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *ptr = 0;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Dump QoS map used bitmap.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static void
qos_sw_dump_map_bmp(int unit)
{
    int i, j, size;
    const char *type_list[] = QOS_XFS_MAP_TYPE_STR;
    qos_cfg_t *qos_db = QOS_CFG(unit);
    SHR_BITDCL *bmp = NULL;

    LOG_CLI((BSL_META_U(unit,
                        "----------------%20s----------------\n"),
                        "Used bitmap"));

    LOG_CLI((BSL_META_U(unit,
                        "  %20s         Bmp(upper->lower)\n"),
                        "Type"));

    for (i = 0; i < QoSMapTypeCount; i++) {
        size = SHRi_BITDCLSIZE(qos_db->map_sz[i]);
        bmp = qos_db->bmp[i];
        /* Dump type name. */
        LOG_CLI((BSL_META_U(unit,
                            "  %30s     "),
                            type_list[i]));
        if (bmp == NULL) {
            continue;
        }
        /* Dump all used bitmap. */
        for (j = size - 1; j >= 0; j--) {
            LOG_CLI((BSL_META_U(unit,
                            "%8x "),
                            bmp[j]));
        }
        LOG_CLI((BSL_META_U(unit, "\n")));
    }
}

/*!
 * \brief Dump QoS remarking table configuration.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static void
qos_sw_dump_remark_table(int unit)
{
    int i, j;
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_remark_table_chunk_t *chunk = NULL;
    const char *mode_name[] = {"None", "2Bits", "6Bits", "8Bits", "4Bits"};
    uint32_t bmp[2];

    LOG_CLI((BSL_META_U(unit,
                        "----------------%20s----------------\n"),
                        "Remarking table"));

    for (i = 0; i < QOS_REMARK_TABLE_NUM; i++) {
        LOG_CLI((BSL_META_U(unit,
                        "  Table[%d]       : %s\n"),
                        i,
                        qos_db->remark_table[i].overlay? "Overlay" : "Normal"));
        chunk = qos_db->remark_table[i].chunk;
        if (chunk == NULL) {
            continue;
        }
        LOG_CLI((BSL_META_U(unit,
                        "  Chunk    Bitmap    Full    Alloc          Mode\n")));

        /* Dump qos remarking table chunk configuration. */
        for (j = 0; j < QOS_REMARK_CHUNK_NUM; j++) {
            bmp[0] = (chunk[j].set_bmp >> 32) & 0xffffffff;
            bmp[1] = chunk[j].set_bmp & 0xffffffff;
            LOG_CLI((BSL_META_U(unit,
                        "  %4d    %x %x    %4s    %4s    %20s\n"),
                        j,
                        bmp[0], bmp[1],
                        chunk[j].full ? "T" : "F",
                        chunk[j].allocated ? "T" : "F",
                        mode_name[chunk[j].mode]));
        }
        LOG_CLI((BSL_META_U(unit, "\n")));
    }
}

/*!
 * \brief Dump QoS remarking table index mapping.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static void
qos_sw_dump_tbl_idx_mapping(int unit)
{
    int i, id, num;
    const char *type_list[] = QOS_XFS_MAP_TYPE_STR;
    qos_cfg_t *qos_db = QOS_CFG(unit);
    int *tbl_index = NULL;
    qos_xfs_map_type_t type;

    LOG_CLI((BSL_META_U(unit,
                        "----------------%20s----------------\n"),
                        "Table index"));

    LOG_CLI((BSL_META_U(unit,
                        "  TableIdx[map_id] = index\n")));

    for (i = 0; i < QOS_EGR_MAP_TYPE_COUNT; i++) {
        type = QoSMapTypeL2Egress + i;
        LOG_CLI((BSL_META_U(unit,
                        "  Type(%s)\n"), type_list[type]));
        tbl_index = qos_db->tbl_index[i];
        if (tbl_index == NULL) {
            continue;
        }

        num = qos_db->map_sz[QoSMapTypeL2Egress + i];
        for (id = 0; id < num; id++) {
            /* Only dump valid value. */
            if (tbl_index[id] != -1) {
                LOG_CLI((BSL_META_U(unit,
                        "  TableIdx[%d] = %d\n"),
                        id, tbl_index[id]));
            }
        }
        LOG_CLI((BSL_META_U(unit, "\n")));
    }
}

/*!
 * \brief Dump QoS module software bookkeepings.
 *
 * \param [in] unit Unit Number.
 */
static void
qos_sw_dump(int unit)
{
    int i;
    const char *blk_name[] = {"L2", "L3", "MPLS"};
    const char *type_list[] = QOS_XFS_MAP_TYPE_STR;
    qos_cfg_t *qos_db = QOS_CFG(unit);

    LOG_CLI((BSL_META_U(unit,
                        "\nSW Information QoS - Unit %d\n"), unit));
    LOG_CLI((BSL_META_U(unit,
                        "----------------%20s----------------\n"),
                        "Block size"));
    /* Dump block size. */
    for (i = 0; i < QOS_ING_MAP_TYPE_COUNT; i++) {
        LOG_CLI((BSL_META_U(unit,
                        "  %20s       : %4d\n"),
                        blk_name[i], qos_db->blk_sz[i]));
    }

    LOG_CLI((BSL_META_U(unit,
                        "----------------%20s----------------\n"),
                        "Map id size"));
    /* Dump map id size. */
    for (i = 0; i < QoSMapTypeCount; i++) {
        LOG_CLI((BSL_META_U(unit,
                        "  %30s       : %4d\n"),
                        type_list[i], qos_db->map_sz[i]));
    }

    LOG_CLI((BSL_META_U(unit,
                        "----------------%20s----------------\n"),
                        "Default pointer"));
    /* Dump default pointer. */
    for (i = 0; i < QoSMapTypeCount; i++) {
        LOG_CLI((BSL_META_U(unit,
                        "  %30s       : %4d\n"),
                        type_list[i], qos_db->def_ptr[i]));
    }

    qos_sw_dump_map_bmp(unit);

    qos_sw_dump_remark_table(unit);

    qos_sw_dump_tbl_idx_mapping(unit);
}

/*!
 * \brief Restore default QoS setting on a new port during flex port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_attach(int unit, bcm_port_t port)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    int ptr, data[2], l2_iif;
    bcmi_ltsw_port_tab_t type[2];
    SHR_FUNC_ENTER(unit);

    ptr = qos_db->def_ptr[QoSMapTypeL2Ingress];
    /* Enable ingress mapping. */
    type[0] = BCMI_PT_OVLAN_MAP_TO_PHB;
    data[0] = 1;

    /* Set mapping pointer. */
    type[1] = BCMI_PT_VLAN_PHB;
    data[1] = ptr;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_multi_set(unit, port, type, data, 2));

    ptr = qos_db->def_ptr[QoSMapTypeL2Egress];

    /* Get L2 iif. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_to_l2_if(unit, port, &l2_iif));

    /* Set egress remarking pointer. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                port,
                                BCMI_PT_PHB_VLAN,
                                ptr));
    qos_db->egr_l2_oif_dot1p_ptr[l2_iif] = ptr |
        (QoSMapTypeL2Egress << QOS_MAP_SHIFT);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear default QoS setting on a to-be-removed port during flex port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_detach(int unit, bcm_port_t port)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    int data[2], l2_iif;
    bcmi_ltsw_port_tab_t type[2];
    SHR_FUNC_ENTER(unit);

    /* Disable ingress mapping. */
    type[0] = BCMI_PT_OVLAN_MAP_TO_PHB;
    data[0] = 0;

    /* Set mapping pointer. */
    type[1] = BCMI_PT_VLAN_PHB;
    data[1] = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_multi_set(unit, port, type, data, 2));

    /* Get L2 iif. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_to_l2_if(unit, port, &l2_iif));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit, port, BCMI_PT_PHB_VLAN, 0));
    qos_db->egr_l2_oif_dot1p_ptr[l2_iif] = 0;

exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_qos_init(int unit)
{
    int warm = bcmi_warmboot_get(unit);
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_db_init(unit));

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_table_init(unit));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_detach(int unit)
{
    return SHR_E_NONE;
}

int
xfs_ltsw_qos_map_create(
    int unit,
    uint32_t flags,
    int *map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_create(unit, flags, map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_map_destroy(
    int unit,
    int map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_destroy(unit, map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_map_add(
    int unit,
    uint32_t flags,
    bcm_qos_map_t *map,
    int map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_add(unit, flags, map, map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_map_delete(
    int unit,
    uint32_t flags,
    bcm_qos_map_t *map,
    int map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_delete(unit, flags, map, map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_port_map_set(
    int unit,
    bcm_gport_t port,
    int ing_map,
    int egr_map)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_map_set(unit, port, ing_map, egr_map));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_port_map_type_get(
    int unit,
    bcm_gport_t port,
    uint32_t flags,
    int *map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_map_get(unit, port, flags, map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_map_multi_get(
    int unit,
    uint32_t flags,
    int map_id,
    int array_size,
    bcm_qos_map_t *array,
    int *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_multi_get(unit,
                           flags,
                           map_id,
                           array_size,
                           array,
                           count));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_multi_get(
    int unit,
    int array_size,
    int *map_id,
    int *flags,
    int *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_multi_get(unit,
                       array_size,
                       map_id,
                       flags,
                       count));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_map_id_resolve(
    int unit,
    int map_id,
    bcmi_ltsw_qos_map_type_t *type,
    int *ptr)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_resolve(unit, map_id, type, ptr));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_map_id_construct(
    int unit,
    int ptr,
    bcmi_ltsw_qos_map_type_t type,
    int *map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_construct(unit, ptr, type, map_id));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_default_ptr_get(
    int unit,
    bcmi_ltsw_qos_map_type_t type,
    int *ptr)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_default_ptr_get(unit, type, ptr));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_dummy_ptr_get(
    int unit,
    bcmi_ltsw_qos_map_type_t type,
    int *ptr)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_dummy_ptr_get(unit, type, ptr));
exit:
    SHR_FUNC_EXIT();
}

void
xfs_ltsw_qos_sw_dump(int unit)
{
    qos_sw_dump(unit);
}

int
xfs_ltsw_qos_port_egr_l2_map_set(
    int unit,
    bcm_port_t port,
    int src)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_egr_l2_map_set(unit, port, src));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_port_egr_l2_map_get(
    int unit,
    bcm_port_t port,
    int *src)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_egr_l2_map_get(unit, port, src));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_port_attach(
    int unit,
    bcm_port_t port)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_attach(unit, port));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_port_detach(
    int unit,
    bcm_port_t port)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_detach(unit, port));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_qos_vxlan_flags_map_ptr_get(
    int unit,
    int g_ena,
    int bum_ena,
    int *ptr)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_vxlan_flags_map_ptr_get(unit, g_ena, bum_ena, ptr));
exit:
    SHR_FUNC_EXIT();
}

