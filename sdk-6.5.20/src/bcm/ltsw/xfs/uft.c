/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>

#include <bcm_int/ltsw/xfs/uft.h>
#include <bcm_int/ltsw/uft.h>
#include <bcm_int/ltsw/uft_int.h>
#include <bcm_int/ltsw/mbcm/uft.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/feature.h>

#include <sal/sal_types.h>
#include <sal/sal_libc.h>
#include <bcmltd/chip/bcmltd_str.h>
#include <bcmltd/chip/bcmltd_device_constants.h>
#include <shr/shr_types.h>
#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_UFT

/*! Maximum number of physical EM banks. */
#define UFT_DEV_EM_BANK_CNT_MAX (128)

/*!
 * \brief Device EM bank info.
 */
typedef struct uft_bank_info_s {

    /*! Bank ID. */
    int bank_id;

    /*! Bank string. */
    const char *bank_str;

    /*! Number of lookups supported by the bank. */
    int lkup_cnt;

    /*! List of EM groups which may contain this bank. */
    int group[DEVICE_EM_GROUP_CNT_MAX];

    /*! Count of EM groups. */
    int group_cnt;

    /*!  Paired bank ID required to support 2 lookups. */
    int pair_bank;

    /*! Indicates the bank is used as the pair bank for another bank. */
    bool paired;

    /*! Bank is fixed. */
    bool fixed;

    /*! Bank is valid. */
    bool valid;

} uft_bank_info_t;

/*!
 * \brief Device EM group info.
 */
typedef struct uft_group_info_s {

    /*! Group ID. */
    int group_id;

    /*! Group string. */
    const char *group_str;

    /*! List of dedicated banks which attached to this group. */
    int fixed_bank[DEVICE_EM_BANK_CNT_MAX];

    /*! Count of dedicated banks. */
    int fixed_cnt;

    /*! List of variable banks which attached to this group. */
    int var_bank[DEVICE_EM_BANK_CNT_MAX];

    /*! Count of variable banks. */
    int var_cnt;

    /*! Logical table array whose lookup0 are mapped to this group. */
    const char *lkup0_lt[MAX_MAPPED_LT];

    /*! Count of lookup0 logical tables. */
    int lkup0_lt_cnt;

    /*! Logical table array whose lookup1 are mapped to this group. */
    const char *lkup1_lt[MAX_MAPPED_LT];

    /*! Count of lookup1 logical tables. */
    int lkup1_lt_cnt;

    /*! EM group attribute. */
    const char *attr;

    /*! Tile mode. */
    const char *tile_mode;

    /*! Group is valid. */
    bool valid;

} uft_group_info_t;

/*!
 * \brief UFT dev info.
 */
typedef struct uft_dev_info_s {

    /*! UFT dev info initialized. */
    bool inited;

    /*! Maximum number of EM banks. */
    int max_bank;

    /*! Maximum number of EM groups. */
    int max_group;

    /*! Device EM bank info. */
    uft_bank_info_t *bank_info;

    /*! Device EM group info. */
    uft_group_info_t *group_info;

} uft_dev_info_t;

/*!
 * \brief UFT dev info.
 */
static uft_dev_info_t xfs_ltsw_uft_dev_info[BCM_MAX_NUM_UNITS];

/******************************************************************************
 * Private functions
 */


/*!
 * \brief Convert an ID to a string.
 *
 * \param [in] name_id_map Strings to IDs mapping table.
 * \param [in] map_len Size of the mapping table.
 * \param [in] id The ID to convert.
 *
 * \retval Non-NULL Pionter to a string matching ID.
 * \retval NULL String not found for provided ID.
 */
static const char*
ltsw_xfs_uft_id2name(const shr_enum_map_t *name_id_map, int map_len, int id)
{
    int idx;

    if (name_id_map == NULL) {
        return NULL;
    }

    for (idx = 0; idx < map_len; idx++) {
        if (name_id_map[idx].val == id) {
            return name_id_map[idx].name;
        }
    }

    return NULL;
}

/*!
 * \brief Convert a string to an ID.
 *
 * \param [in] name_id_map Strings to IDs mapping table.
 * \param [in] map_len Size of the mapping table.
 * \param [in] name Pointer to a string to convert.
 *
 * \retval Non-negative integer value matching string.
 * \retval -1 ID not found for provided string.
 */
static int
ltsw_xfs_uft_name2id(const shr_enum_map_t *name_id_map, int map_len, const char *name)
{
    int idx;

    if (name_id_map == NULL || name == NULL) {
        return -1;
    }

    for (idx = 0; idx < map_len; idx++) {
        if (sal_strcasecmp(name_id_map[idx].name, name) == 0) {
            return name_id_map[idx].val;
        }
    }

    return -1;
}

/*!
 * \brief Configure the maximum number of table entries for a logical table.
 *
 * \param [in] unit Unit number.
 * \param [in] table_id Logical table ID.
 * \param [in] max_entries Maximum number of table entries.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_table_max_entries_set(
    int unit,
    const char *table_id,
    int max_entries)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_CONTROLs, &entry_hdl));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs, table_id));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, MAX_ENTRIESs, max_entries));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the table size for a logical table.
 *
 * \param [in] unit Unit number.
 * \param [in] table_id Logical table ID.
 * \param [in] entry_limit The greatest number of table entries.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_table_size_get(
    int unit,
    const char *table_id,
    uint64_t *table_size)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_INFOs, &entry_hdl));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs, table_id));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, ENTRY_LIMITs, table_size));
exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the maximum lookups supported by a logical table.
 *
 * \param [in] unit Unit number.
 * \param [in] table_id Logical table ID.
 * \param [in] lkup_cnt Maximum lookups of the logical table.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_table_lookup_cnt_get(
    int unit,
    const char *table_id,
    uint64_t *lkup_cnt)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_EM_INFOs, &entry_hdl));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs, table_id));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, LOOKUP_CNTs, lkup_cnt));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init DEVICE_EM_TILE LT.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_device_em_tile_init(
    int unit,
    bcmint_uft_mode_info_t *mode_db)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    bcmint_uft_table_info_t *table_db = NULL;
    bcmint_uft_entry_info_t *entry_db = NULL;
    int tbl_idx = 0, ent_idx = 0, fld_idx = 0;
    const char *table = NULL;
    const char *field = NULL;
    const char *symbol = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (tbl_idx = 0; tbl_idx < mode_db->table_cnt; tbl_idx++) {
        table = mode_db->table_db[tbl_idx].table_name;
        table_db = &mode_db->table_db[tbl_idx];
        for (ent_idx = 0; ent_idx < table_db->entry_cnt; ent_idx++) {
            entry_db = &table_db->entry_db[ent_idx];
            SHR_IF_ERR_EXIT
                (bcmlt_entry_allocate(dunit, table, &entry_hdl));
            for (fld_idx = 0; fld_idx < entry_db->field_cnt; fld_idx++) {
                field = entry_db->field_db[fld_idx].field_name;
                symbol = entry_db->field_db[fld_idx].symbol;
                SHR_IF_ERR_EXIT
                    (bcmlt_entry_field_symbol_add(entry_hdl, field, symbol));
            }
            SHR_IF_ERR_EXIT
                (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_UPDATE,
                                             entry_hdl));
            entry_hdl = BCMLT_INVALID_HDL;
        }
    }
    SHR_IF_ERR_EXIT
        (bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init UFT mode, UAT mode, tunnel mode and VFP mode.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_tile_mode_init(int unit)
{
    bcmi_ltsw_uft_mode_t uft_mode;
    int uat_mode = 0, egress_uat_mode = 0, tunnel_mode = 0, vfp_mode = 0;
    bcmint_uft_mode_info_t *mode_db = NULL;
    int i = 0;
    bcmint_uft_db_t uft_db = {
        .uft_mode_cnt = 0,
        .uft_mode_db = NULL,
    };

    SHR_FUNC_ENTER(unit);

    if (bcmi_warmboot_get(unit)) {
        SHR_EXIT();
    }

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    /* Tile modes configurations for UFT mode. */
    uft_mode = bcmi_ltsw_property_get(unit, BCMI_CPN_UFT_MODE, 3);
    if ((uft_mode <= bcmiUftModeInvalid ) ||
        (uft_mode >= bcmiUftModeCount)) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Invalid UFT mode [%d].\n"),
                   uft_mode));
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    mode_db = NULL;
    for (i = 0; i < uft_db.uft_mode_cnt; i++) {
        if(uft_db.uft_mode_db[i].mode == uft_mode) {
            mode_db = &uft_db.uft_mode_db[i];
            break;
        }
    }

    if (mode_db == NULL) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "UFT mode [%d] unavailable.\n"),
                   uft_mode));
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else {
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_device_em_tile_init(unit, mode_db));
    }

    /* Tile mode configurations for ingress UAT mode. */
    uat_mode = bcmi_ltsw_property_get(unit, BCMI_CPN_UAT_MODE, 0);
    if ((uat_mode != 0 ) && (uat_mode != 1)) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Invalid UAT mode [%d].\n"),
                   uat_mode));
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    mode_db = NULL;
    for (i = 0; i < uft_db.uat_mode_cnt; i++) {
        if(uft_db.uat_mode_db[i].mode == uat_mode) {
            mode_db = &uft_db.uat_mode_db[i];
            break;
        }
    }

    if (mode_db == NULL) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "UAT mode [%d] unavailable.\n"),
                   uat_mode));
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else {
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_device_em_tile_init(unit, mode_db));
    }

    /* Tile mode configurations for egress UAT mode. */
    egress_uat_mode = bcmi_ltsw_property_get(unit, BCMI_CPN_EGRESS_UAT_MODE, 0);
    if ((egress_uat_mode != 0 ) && (egress_uat_mode != 1)) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Invalid egress UAT mode [%d].\n"),
                   egress_uat_mode));
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    mode_db = NULL;
    for (i = 0; i < uft_db.egress_uat_mode_cnt; i++) {
        if(uft_db.egress_uat_mode_db[i].mode == egress_uat_mode) {
            mode_db = &uft_db.egress_uat_mode_db[i];
            break;
        }
    }

    if (mode_db == NULL) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Egress UAT mode [%d] unavailable.\n"),
                   egress_uat_mode));
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else {
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_device_em_tile_init(unit, mode_db));
    }

    /* Tile mode configurations for VFP mode. */
    vfp_mode = bcmi_ltsw_property_get(unit, BCMI_CPN_VFP_MODE, 0);
    if ((vfp_mode != 0 ) && (vfp_mode != 1) && (vfp_mode != 2)) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Invalid VFP mode [%d].\n"),
                   vfp_mode));
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    mode_db = NULL;
    for (i = 0; i < uft_db.vfp_mode_cnt; i++) {
        if(uft_db.vfp_mode_db[i].mode == vfp_mode) {
            mode_db = &uft_db.vfp_mode_db[i];
            break;
        }
    }

    if (mode_db == NULL) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "VFP mode [%d] unavailable.\n"),
                   vfp_mode));
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else {
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_device_em_tile_init(unit, mode_db));
    }

    /* Tile mode configurations for tunnel mode. */
    tunnel_mode = bcmi_ltsw_property_get(unit, BCMI_CPN_TUNNEL_MODE, 0);
    if ((tunnel_mode != 0 ) && (tunnel_mode != 1) && (tunnel_mode != 2)) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Invalid tunnel mode[%d].\n"),
                   tunnel_mode));
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    mode_db = NULL;
    for (i = 0; i < uft_db.tunnel_mode_cnt; i++) {
        if(uft_db.tunnel_mode_db[i].mode == tunnel_mode) {
            mode_db = &uft_db.tunnel_mode_db[i];
            break;
        }
    }

    if (mode_db == NULL) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Tunnel mode [%d] unavailable.\n"),
                   tunnel_mode));
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else {
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_device_em_tile_init(unit, mode_db));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the current tile mode of a EM tile.
 *
 * \param [in] unit Unit number.
 * \param [in] tile_id Tile ID.
 * \param [out] mode Tile mode.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_tile_mode_get(
    int unit,
    const char *tile_id,
    const char **mode)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *field_val;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_TILEs, &entry_hdl));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_TILE_IDs, tile_id));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, MODEs, &field_val));
    *mode = field_val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the current tile attribute of a EM tile.
 *
 * \param [in] unit Unit number.
 * \param [in] tile_id Tile ID.
 * \param [out] tile_info Information about the tile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_tile_info_get(
    int unit,
    const char *tile_id,
    bcmint_uft_entry_info_t *tile_info)
{
    int i;
    int tbl_idx = 0, ent_idx = 0;
    bcmint_uft_mode_info_t *mode_db = NULL;
    bcmint_uft_table_info_t *table_db = NULL;
    bcmint_uft_entry_info_t *entry_db = NULL;
    bcmi_ltsw_uft_mode_t uft_mode;
    int vfp_mode = 0;
    bcmint_uft_db_t uft_db = {
        .uft_mode_cnt = 0,
        .uft_mode_db = NULL,
        .vfp_mode_cnt = 0,
        .vfp_mode_db = NULL,
    };

    SHR_FUNC_ENTER(unit);

    /* Initialize the tile attr to HASH type.
     * Here only traverse UFT tiles and VFP tiles. All the index tiles are fixed,
     * will not enter this routine. All the UAT tiles are HASH type, don't needs
     * to explicitly retrieve attribute.
     */
    tile_info->entry_attr = HASHs;
    tile_info->hw_learn = FALSE;

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    SHR_IF_ERR_EXIT
        (xfs_ltsw_uft_mode_get(unit, &uft_mode));

    mode_db = NULL;
    for (i = 0; i < uft_db.uft_mode_cnt; i++) {
        if(uft_db.uft_mode_db[i].mode == uft_mode) {
            mode_db = &uft_db.uft_mode_db[i];
            break;
        }
    }
    if (mode_db == NULL) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    for (tbl_idx = 0; tbl_idx < mode_db->table_cnt; tbl_idx++) {
        table_db = &mode_db->table_db[tbl_idx];
        for (ent_idx = 0; ent_idx < table_db->entry_cnt; ent_idx++) {
            entry_db = &table_db->entry_db[ent_idx];
            if (sal_strcmp(entry_db->field_db[0].symbol, tile_id) == 0) {
                tile_info->entry_attr = entry_db->entry_attr;
                if (tile_info->entry_attr == NULL) {
                    SHR_ERR_EXIT(SHR_E_INTERNAL);
                }
                tile_info->hw_learn = entry_db->hw_learn;
                SHR_EXIT();
            }
        }
    }

    vfp_mode = bcmi_ltsw_property_get(unit, BCMI_CPN_VFP_MODE, 0);
    mode_db = NULL;
    for (i = 0; i < uft_db.vfp_mode_cnt; i++) {
        if(uft_db.vfp_mode_db[i].mode == vfp_mode) {
            mode_db = &uft_db.vfp_mode_db[i];
            break;
        }
    }

    for (tbl_idx = 0; tbl_idx < mode_db->table_cnt; tbl_idx++) {
        table_db = &mode_db->table_db[tbl_idx];
        for (ent_idx = 0; ent_idx < table_db->entry_cnt; ent_idx++) {
            entry_db = &table_db->entry_db[ent_idx];
            if (sal_strcmp(entry_db->field_db[0].symbol, tile_id) == 0) {
                tile_info->entry_attr = entry_db->entry_attr;
                if (tile_info->entry_attr == NULL) {
                    SHR_ERR_EXIT(SHR_E_INTERNAL);
                }
                SHR_EXIT();
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the EM bank info structure for bank ID.
 *
 * \param [in] unit Unit number.
 * \param [in] bank_id EM bank ID string.
 * \param [out] banki Pointer to EM bank info structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_bank_info_get(
    int unit,
    int bank_id,
    uft_bank_info_t **banki)
{
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_bank_info_t *bank_info = NULL;
    int i;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < dev_info->max_bank; i++) {
        bank_info = dev_info->bank_info + i;
        if (!bank_info->valid) {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
        if (bank_info->bank_id == bank_id) {
            *banki = bank_info;
            SHR_EXIT();
        }
    }
    SHR_ERR_EXIT(SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert EM group ID string to int.
 *
 * \param [in] unit Unit number.
 * \param [in] group_str EM group ID string.
 * \param [out] group_id EM group ID.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_group_id_get(
    int unit,
    const char *group_str,
    int *group_id)
{
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_group_info_t *group_info = NULL;
    int i;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < dev_info->max_group; i++) {
        group_info = dev_info->group_info + i;
        if (sal_strcmp(group_info->group_str, group_str) == 0) {
            *group_id = group_info->group_id;
            SHR_EXIT();
        }
    }
    SHR_ERR_EXIT(SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check if variable banks in a EM group need pair banks.
 *
 * For a EM group, if a LT which supports 2 lookups is in the lookup0 LT array,
 * but not in the lookup1 LT array, pair banks is needed for this EM group. And
 * name of the LT is retuned. If pair bank is not needed, LT of NULL is returned.
 *
 * \param [in] unit Unit number.
 * \param [in] group_info Pointer to EM group info structure.
 * \param [out] pair Flag to indicate pair banks are required for a EM group.
 * \param [out] table Logical table that requires pair bank.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_group_pair_check(
    int unit,
    uft_group_info_t *group_info,
    bool *pair,
    const char **table)
{
    uint64_t lkup_cnt;
    int idx = 0;
    bool is_found = FALSE;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(table, SHR_E_PARAM);
    SHR_NULL_CHECK(group_info, SHR_E_PARAM);

    for (idx = 0; idx < group_info->lkup0_lt_cnt; idx++) {
        /* Find a LT which supports 2 lookups in lookup0 logical table array. */
        *table = group_info->lkup0_lt[idx];
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_table_lookup_cnt_get(unit, *table, &lkup_cnt));
        if (lkup_cnt == 2) {
            is_found = TRUE;
            break;
        }
    }

    if (!is_found) {
        *pair = FALSE;
        SHR_EXIT();
    }

    /* If the LT is in lookup1 logical table array, do not need pair EM group. */
    for (idx = 0; idx < group_info->lkup1_lt_cnt; idx++) {
        if (sal_strcmp(group_info->lkup1_lt[idx], *table) == 0) {
            *pair = FALSE;
            SHR_EXIT();
        }
    }

    *pair = TRUE;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Find the pair EM group for given a table.
 *
 * This function traverse EM groups. If the LT is in the lookup1 logical table
 * array and not in in the lookup0 logical table array. The EM group will be
 * returned as pair EM group.
 *
 * \param [in] unit Unit number.
 * \param [in] table Logical table that requires pair banks.
 * \param [out] pair_group Pointer to EM group info structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_group_pair_find(
    int unit,
    const char *table,
    uft_group_info_t **pair_group)
{
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_group_info_t *group_info;
    uft_bank_info_t *bank_info;
    int i = 0, idx = 0;
    bool is_found;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(table, SHR_E_PARAM);
    SHR_NULL_CHECK(pair_group, SHR_E_PARAM);

    for (i = 0; i < dev_info->max_group; i++) {
        group_info = dev_info->group_info + i;
        if ((!group_info->valid) ||
            (sal_strcmp(group_info->attr, HASHs) != 0) ||
            (group_info->var_cnt == 0) ||
            (group_info->lkup1_lt_cnt == 0)) {
            continue;
        }

        is_found = FALSE;
        for (idx = 0; idx < group_info->lkup0_lt_cnt; idx++) {
            if (sal_strcmp(group_info->lkup0_lt[idx], table) == 0) {
                is_found = TRUE;
                break;
            }
        }

        /* The LT is in the lookup0 array, can not be used as pair EM group. */
        if (is_found) {
            continue;
        }

        /* Check if the LT is in the lookup1 logical table array. */
        is_found = FALSE;
        for (idx = 0; idx < group_info->lkup1_lt_cnt; idx++) {
            if (sal_strcmp(group_info->lkup1_lt[idx], table) == 0) {
                is_found = TRUE;
                break;
            }
        }

        if (!is_found) {
            continue;
        } else {
            SHR_IF_ERR_EXIT
                (ltsw_xfs_uft_bank_info_get(unit, group_info->var_bank[0],
                                            &bank_info));
            if(bank_info->paired) {
                /* Already be used as pair banks for another EM group, skip. */
                continue;
            } else {
                *pair_group = group_info;
                SHR_EXIT();
            }
        }
    }

    SHR_ERR_EXIT(SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize group-specific data.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_group_info_init(int unit)
{
    int rv = SHR_E_NONE;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_group_info_t *group_info = NULL;
    int group_id = 0;
    const char *group_str;
    const char *attr_str[MAX_ATTRIBUTES];
    const char *fixed_bank[DEVICE_EM_BANK_CNT_MAX];
    uint32_t array_cnt = 0;
    uint64_t field_val = 0;
    const char *tile_mode = NULL;
    int bank_id;
    int i;
    bcmint_uft_db_t uft_db = {
        .bank_id_cnt = 0,
        .bank_id_map = NULL,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUP_INFOs, &entry_hdl));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_attrib_set(entry_hdl, BCMLT_ENT_ATTR_TRAVERSE_SNAPSHOT));

    group_id = 0;
    while ((rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                    BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        group_info = dev_info->group_info + group_id;
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, DEVICE_EM_GROUP_IDs,
                                          &group_str));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl, ATTRIBUTESs, 0,
                                                attr_str, MAX_ATTRIBUTES,
                                                &array_cnt));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, TILE_MODEs, &tile_mode));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl, LOOKUP0_LTs, 0,
                                                group_info->lkup0_lt,
                                                MAX_MAPPED_LT,
                                                &array_cnt));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl, LOOKUP1_LTs, 0,
                                                group_info->lkup1_lt,
                                                MAX_MAPPED_LT,
                                                &array_cnt));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, NUM_LOOKUP0_LTs, &field_val));
        group_info->lkup0_lt_cnt = field_val;
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, NUM_LOOKUP1_LTs, &field_val));
        group_info->lkup1_lt_cnt = field_val;

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl, FIXED_DEVICE_EM_BANK_IDs,
                                                0, fixed_bank,
                                                DEVICE_EM_BANK_CNT_MAX,
                                                &array_cnt));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, NUM_FIXED_BANKSs, &field_val));
        group_info->fixed_cnt = 0;
        for (i = 0; i < field_val; i++) {
            bank_id = ltsw_xfs_uft_name2id(uft_db.bank_id_map, uft_db.bank_id_cnt,
                                           fixed_bank[i]);
            if (bank_id < 0) {
                LOG_WARN(BSL_LOG_MODULE,
                         (BSL_META_U(unit, "EM bank [%s] unsupported.\n"),
                          fixed_bank[i]));
                break;
            }
            group_info->fixed_bank[group_info->fixed_cnt] = bank_id;
            group_info->fixed_cnt++;
        }

        group_info->group_id = group_id;
        group_info->group_str = group_str;
        group_info->tile_mode = tile_mode;
        group_info->attr = attr_str[0];
        group_info->valid = TRUE;
        group_id++;
        dev_info->max_group++;
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_attrib_clear(entry_hdl, BCMLT_ENT_ATTR_TRAVERSE_SNAPSHOT));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_attrib_set(entry_hdl, BCMLT_ENT_ATTR_TRAVERSE_DONE));
    rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_TRAVERSE,
                            BCMLT_PRIORITY_NORMAL);
    if ((rv != SHR_E_NONE) && (rv != SHR_E_NOT_FOUND) &&
        (rv != SHR_E_UNAVAIL)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize bank-specific data.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_bank_info_init(int unit)
{
    int rv = SHR_E_NONE;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_bank_info_t *bank_info = NULL;
    uft_group_info_t *group_info = NULL;
    int bank_id = 0, group_id = 0;
    int i = 0, j = 0, k = 0;
    const char *group_array[DEVICE_EM_GROUP_CNT_MAX];
    const char *bank_str = NULL;
    const char *tile_id = NULL;
    const char *tile_mode = NULL;
    uint32_t array_cnt = 0;
    uint64_t group_cnt = 0;
    uint64_t lkup_cnt = 0;
    bcmint_uft_db_t uft_db = {
        .bank_id_cnt = 0,
        .bank_id_map = NULL,
        .tile_bank_cnt = 0,
        .tile_bank_map = 0,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_BANK_INFOs, &entry_hdl));

    while ((rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                    BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        bank_info = dev_info->bank_info + i;
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, DEVICE_EM_BANK_IDs,
                                          &bank_str));
        bank_id = ltsw_xfs_uft_name2id(uft_db.bank_id_map, uft_db.bank_id_cnt,
                                       bank_str);
        if (bank_id < 0) {
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "EM bank [%s] unsupported.\n"),
                      bank_str));
            continue;
        }
        tile_id = ltsw_xfs_uft_id2name(uft_db.tile_bank_map, uft_db.tile_bank_cnt,
                                       bank_id);
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_tile_mode_get(unit, tile_id, &tile_mode));
        if (sal_strcmp(tile_mode, TILE_MODE_DISABLEDs) == 0) {
            continue;
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl, DEVICE_EM_GROUP_IDs,
                                                0, group_array,
                                                DEVICE_EM_GROUP_CNT_MAX,
                                                &array_cnt));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, GROUP_CNTs, &group_cnt));
        for (j = 0; j < group_cnt; j++) {
            SHR_IF_ERR_EXIT
                (ltsw_xfs_uft_group_id_get(unit, group_array[j], &group_id));
            bank_info->group[bank_info->group_cnt] = group_id;
            bank_info->group_cnt++;
            group_info = dev_info->group_info + group_id;
            for (k = 0; k < group_info->fixed_cnt; k++) {
                if (group_info->fixed_bank[k] == bank_id ) {
                    bank_info->fixed = TRUE;
                    break;
                }
            }
        }

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, LOOKUP_CNTs, &lkup_cnt));
        bank_info->lkup_cnt = lkup_cnt;
        bank_info->bank_id = bank_id;
        bank_info->bank_str = bank_str;
        bank_info->pair_bank = -1;
        bank_info->valid = TRUE;
        dev_info->max_bank++;
        i++;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clean up UFT resources.
 *
 * \param [in] unit Unit number.
 *
 * \retval None.
 */
static void
ltsw_xfs_uft_info_cleanup(int unit)
{
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];

    SHR_FREE(dev_info->group_info);
    SHR_FREE(dev_info->bank_info);
    sal_memset(dev_info, 0, sizeof(uft_dev_info_t));

    return;
}

/*!
 * \brief Initialize the variable banks list for each EM group.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_var_bank_info_init(int unit)
{
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_bank_info_t *bank_info = NULL;
    uft_group_info_t *group_info = NULL;
    int group_id = 0, bank_id = 0;
    int i = 0, j = 0;
    const char *tile_id = NULL;
    const char *tile_mode = NULL;
    int hw_learn_enable = 0;
    bcmint_uft_entry_info_t tile_info = {
        .entry_attr = NULL,
        .hw_learn = FALSE,
    };
    bcmint_uft_db_t uft_db = {
        .tile_bank_cnt = 0,
        .tile_bank_map = 0,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    hw_learn_enable = bcmi_ltsw_property_get(unit,
                                             BCMI_CPN_FLOWTRACKER_HARDWARE_LEARN_ENABLE,
                                             0);

    for (i = 0; i < dev_info->max_bank; i++) {
        bank_info = dev_info->bank_info + i;
        if ((!bank_info->valid) || (bank_info->fixed)) {
            continue;
        }

        bank_id = bank_info->bank_id;
        tile_id = ltsw_xfs_uft_id2name(uft_db.tile_bank_map, uft_db.tile_bank_cnt,
                                       bank_id);
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_tile_mode_get(unit, tile_id, &tile_mode));

        for (j = 0; j < bank_info->group_cnt; j++) {
            group_id = bank_info->group[j];
            group_info = dev_info->group_info + group_id;
            if (sal_strcmp(tile_mode, group_info->tile_mode) != 0) {
                continue;
            }

            /*
             * For a tile that applicable to multiple groups,
             * need get the tile attribute to decide the bank assignment.
             */
            SHR_IF_ERR_EXIT
                (ltsw_xfs_uft_tile_info_get(unit, tile_id, &tile_info));
            if ((sal_strcmp(tile_info.entry_attr, ALPM_LEVEL1_LEVEL2_ONLYs) == 0) ||
                (sal_strcmp(tile_info.entry_attr, ALPM_COMPRESSION_LEVEL1_LEVEL2_ONLYs) == 0)) {
                if (sal_strcmp(group_info->attr, ALPM_LEVEL_3s) == 0) {
                    continue;
                }
            } else if ((sal_strcmp(NONEs, tile_info.entry_attr) != 0) &&
                (sal_strcmp(group_info->attr, tile_info.entry_attr)) != 0) {
                continue;
            }

            if (sal_strcmp(group_info->attr, DYNAMIC_FT_FPs) == 0) {
                if (hw_learn_enable == 0) {
                    /*
                     * Flowtracker HW learning is disabled, all IFTA80 tiles and
                     * IFTA90 tiles should be assigned to DT_EM_FP_ENTRY.
                     */
                    if (sal_strcmp(DT_EM_FT_ENTRYs, group_info->lkup0_lt[0]) == 0) {
                        continue;
                    }
                } else {
                    /*
                     * Flowtracker HW learning is enabled. If HW learning is
                     * supported on a tile, this tile should be reserved for
                     * DT_EM_FT_ENTRY. Otherwise, assign it to DT_EM_FP_ENTRY.
                     */
                    if (tile_info.hw_learn) {
                        if (sal_strcmp(DT_EM_FP_ENTRYs, group_info->lkup0_lt[0]) == 0) {
                            continue;
                        }
                    } else {
                        if (sal_strcmp(DT_EM_FT_ENTRYs, group_info->lkup0_lt[0]) == 0) {
                            continue;
                        }
                    }
                }
            }

            
            if ((sal_strcmp(group_info->lkup0_lt[0], L3_IPV4_UNICAST_DEFIP_TABLEs) == 0) ||
                (sal_strcmp(group_info->lkup0_lt[0], L3_IPV6_UNICAST_DEFIP_128_TABLEs) == 0) ||
                (sal_strcmp(group_info->lkup1_lt[0], L3_IPV4_UNICAST_DEFIP_TABLEs) == 0) ||
                (sal_strcmp(group_info->lkup1_lt[0], L3_IPV6_UNICAST_DEFIP_128_TABLEs) == 0)) {
                continue;
            }

            group_info->var_bank[group_info->var_cnt] = bank_id;
            group_info->var_cnt++;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief UFT pair bank info init.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_pair_bank_info_init(int unit)
{
    int rv;
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_bank_info_t *bank_info = NULL;
    uft_group_info_t *group_info = NULL;
    uft_group_info_t *pair_group = NULL;
    const char *table = NULL;
    int i = 0, j = 0;
    bool need_pair = FALSE;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < dev_info->max_group; i++) {
        group_info = dev_info->group_info + i;
        if ((!group_info->valid) ||
            (sal_strcmp(group_info->attr, HASHs) != 0) ||
            (group_info->var_cnt == 0) ||
            (group_info->lkup0_lt_cnt == 0)) {
            continue;
        }

        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_group_pair_check(unit, group_info, &need_pair, &table));
        if (!need_pair) {
           continue;
        }

        
        if ((sal_strcmp(table, L3_IPV4_UNICAST_DEFIP_TABLEs) == 0) ||
           (sal_strcmp(table, L3_IPV6_UNICAST_DEFIP_128_TABLEs) == 0)) {
            continue;
        }

        rv = ltsw_xfs_uft_group_pair_find(unit, table, &pair_group);
        if (rv == SHR_E_NOT_FOUND) {
            continue;
        }
        SHR_IF_ERR_EXIT(rv);

        if ((group_info == pair_group) ||
            (group_info->var_cnt != pair_group->var_cnt)) {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }

        for (j = 0; j < group_info->var_cnt; j++) {
            SHR_IF_ERR_EXIT
                (ltsw_xfs_uft_bank_info_get(unit, group_info->var_bank[j],
                                            &bank_info));
            bank_info->pair_bank = pair_group->var_bank[j];
            SHR_IF_ERR_EXIT
                (ltsw_xfs_uft_bank_info_get(unit, pair_group->var_bank[j],
                                            &bank_info));
            bank_info->paired = TRUE;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize UFT resource manager.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_info_init(int unit)
{
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    int alloc_sz = 0;

    SHR_FUNC_ENTER(unit);

    /* Allocate buffer for group info. */
    alloc_sz = sizeof(uft_group_info_t) * DEVICE_EM_GROUP_CNT_MAX;
    SHR_ALLOC(dev_info->group_info, alloc_sz, "bcmLtswHashGroupInfo");
    SHR_NULL_CHECK(dev_info->group_info, SHR_E_MEMORY);
    sal_memset(dev_info->group_info, 0, alloc_sz);

    /* Allocate buffer for bank info. */
    alloc_sz = sizeof(uft_bank_info_t) * UFT_DEV_EM_BANK_CNT_MAX;
    SHR_ALLOC(dev_info->bank_info, alloc_sz, "bcmLtswHashBankInfo");
    SHR_NULL_CHECK(dev_info->bank_info, SHR_E_MEMORY);
    sal_memset(dev_info->bank_info, 0, alloc_sz);

    dev_info->max_bank = 0;
    dev_info->max_group = 0;

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_group_info_init(unit));

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_bank_info_init(unit));

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_var_bank_info_init(unit));

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_pair_bank_info_init(unit));

    dev_info->inited = TRUE;

exit:
    if (SHR_FUNC_ERR()) {
        ltsw_xfs_uft_info_cleanup(unit);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init DEVICE_EM_BANK LT, update PAIRED_DEVICE_EM_BANK_ID field.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_pair_bank_init(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_bank_info_t *bank_info = NULL;
    int i = 0;
    int pair_bank = 0;
    const char *field_sym = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_BANK_PAIRs, &entry_hdl));

    for (i = 0; i < dev_info->max_bank; i++) {
        bank_info = dev_info->bank_info + i;
        if ((!bank_info->valid) || (bank_info->pair_bank < 0)) {
            continue;
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_clear(entry_hdl));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_BANK_IDs,
                                          bank_info->bank_str));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, PAIRED_DEVICE_EM_BANK_IDs,
                                          &field_sym));
        pair_bank = bank_info->pair_bank;
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_bank_info_get(unit, pair_bank, &bank_info));
        if (sal_strcmp(bank_info->bank_str, field_sym) == 0) {
            continue;
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, PAIRED_DEVICE_EM_BANK_IDs,
                                          bank_info->bank_str));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init DEVICE_EM_GROUP LT, enable the usage of variable banks.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_em_group_init(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_group_info_t *group_info = NULL;
    uft_bank_info_t *bank_info = NULL;
    int i = 0, j = 0;
    const char *bank_array[DEVICE_EM_BANK_CNT_MAX];
    uint32_t bank_cnt = 0;
    const char *symbol_array[DEVICE_EM_BANK_CNT_MAX];
    uint32_t array_cnt = 0;
    bool is_updated = TRUE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUPs, &entry_hdl));

    for (i = 0; i < dev_info->max_group; i++) {
        group_info = dev_info->group_info + i;
        if (!group_info->valid || group_info->var_cnt < 1) {
            continue;
        }

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_GROUP_IDs,
                                          group_info->group_str));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl, DEVICE_EM_BANK_IDs,
                                                0, symbol_array,
                                                DEVICE_EM_BANK_CNT_MAX,
                                                &array_cnt));

        for (j = 0; j < group_info->var_cnt; j++) {
            SHR_IF_ERR_EXIT
                (ltsw_xfs_uft_bank_info_get(unit, group_info->var_bank[j],
                                            &bank_info));
            bank_array[j] = bank_info->bank_str;
        }
        bank_cnt = group_info->var_cnt;

        is_updated = TRUE;
        for (j = 0; j < bank_cnt; j++) {
            if (sal_strcmp(bank_array[j], symbol_array[j]) != 0) {
                is_updated = FALSE;
                break;
            }
        }
        if (is_updated) {
            continue;
        }

        SHR_IF_ERR_EXIT
            (bcmlt_entry_clear(entry_hdl));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_GROUP_IDs,
                                          group_info->group_str));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl, DEVICE_EM_BANK_IDs,
                                                0, bank_array, bank_cnt));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, NUM_BANKSs, bank_cnt));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Deinit DEVICE_EM_BANK_PAIR LT, invalidate pair banks.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_em_bank_deinit(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_bank_info_t *bank_info = NULL;
    int i = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_BANK_PAIRs, &entry_hdl));

    for (i = 0; i < dev_info->max_bank; i++) {
        bank_info = dev_info->bank_info + i;
        if ((!bank_info->valid) || (bank_info->pair_bank < 0)) {
            continue;
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_BANK_IDs,
                                          bank_info->bank_str));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, PAIRED_DEVICE_EM_BANK_IDs,
                                          INVALIDs));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Deinit DEVICE_EM_GROUP LT, disable the usage of variable banks.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_em_group_deinit(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_group_info_t *group_info = NULL;
    int i = 0;
    const char *bank_array[DEVICE_EM_BANK_CNT_MAX];

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < DEVICE_EM_BANK_CNT_MAX; i++) {
        bank_array[i] = INVALIDs;
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUPs, &entry_hdl));

    for (i = 0; i < dev_info->max_group; i++) {
        group_info = dev_info->group_info + i;
        if (!group_info->valid || group_info->var_cnt == 0) {
            continue;
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_GROUP_IDs,
                                          group_info->group_str));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl,
                                                DEVICE_EM_BANK_IDs,
                                                0,
                                                bank_array,
                                                DEVICE_EM_BANK_CNT_MAX));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, NUM_BANKSs, 0));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the maximum number of entries for logical tables.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_table_max_entries_init(int unit)
{
    int rv = SHR_E_NONE;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *table_id = NULL;
    const char *property = NULL;
    int num_entries = 0;
    uint64_t table_size = 0;
    bcmint_uft_db_t uft_db = {
        .property_cnt = 0,
        .property_map = NULL,
    };
    int i;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_EM_INFOs, &entry_hdl));

    while ((rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                    BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, TABLE_IDs,
                                          &table_id));
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_table_size_get(unit, table_id, &table_size));
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_table_max_entries_set(unit, table_id, table_size));
    }

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    for (i = 0; i < uft_db.property_cnt; i++) {
        property = uft_db.property_map[i].str;
        table_id = uft_db.property_map[i].table;
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_table_size_get(unit, table_id, &table_size));
        num_entries = bcmi_ltsw_property_get(unit, property, table_size);
        if (num_entries > table_size) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "Error configuration: %s: %d. "
                                  "The maximum number of entries exceeds the entry limit = %d.\n"),
                      property, num_entries, (int)table_size));
            SHR_ERR_EXIT(SHR_E_CONFIG);
        }
        SHR_IF_ERR_EXIT
            (ltsw_xfs_uft_table_max_entries_set(unit, table_id, num_entries));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the maximum number of entry moves for hash reordering.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_table_move_depth_init(int unit)
{
    int move_depth;

    SHR_FUNC_ENTER(unit);

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_L2,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthL2,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_L3,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthL3,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_EXACT_MATCH,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthExactMatch,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_VLAN_1,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthVlanTranslate1,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_VLAN_2,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthVlanTranslate2,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_EGRESS_VLAN_1,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthEgressVlanTranslate1,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_EGRESS_VLAN_2,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthEgressVlanTranslate2,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_L3_TUNNEL,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthL3Tunnel,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_VLAN_3,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthVlanTranslate3,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_L2_TUNNEL,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthL2Tunnel,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_L2_TUNNEL_VNID,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthL2TunnelVnid,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_FLOW_TRACKER,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthFlowTracker,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_IPMC_GROUP,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthIpmcGroup,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_IPMC_SOURCE_GROUP,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthIpmcSourceGroup,
                                               move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_L2MC,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xfs_ltsw_uft_multi_move_depth_set(unit,
                                               bcmSwitchHashMultiMoveDepthL2mc,
                                               move_depth));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check if a bank is assigned to a LT.
 *
 * \param [in] unit Unit number.
 * \param [in] bank_id Bank ID.
 * \param [in] table_id Logical table name.
 * \param [out] is_mapped True if bank is mapped to a LT.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_bank_table_is_mapped(
    int unit,
    bcm_switch_hash_bank_t bank_id,
    const char *table_id,
    bool *is_mapped)
{
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_bank_info_t *bank_info = NULL;
    uft_group_info_t *group_info = NULL;
    int i, j;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_uft_bank_info_get(unit, bank_id, &bank_info));

    *is_mapped = FALSE;
    for (i = 0; i < bank_info->group_cnt; i++) {
        group_info = dev_info->group_info + bank_info->group[i];
        for (j = 0; j < group_info->lkup0_lt_cnt; j++) {
            if (sal_strcmp(table_id, group_info->lkup0_lt[j]) == 0) {
                *is_mapped = TRUE;
                SHR_EXIT();
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Remove default table entries.
 *
 * \param [in] unit Unit number.
 * \param [in] bank_num Bank number.
 * \param [in] def_lt_array Array of default LT.
 * \param [in] hdl_cnt Count of default LT entry handles.
 * \param [out] entry_hdl_array LT entry handle array contain default table entries.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_default_table_clear(
    int unit,
    bcm_switch_hash_bank_t bank_num,
    const char **def_lt_array,
    int hdl_cnt,
    bcmlt_entry_handle_t *entry_hdl_array)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int rv = SHR_E_NONE;
    const char *table_id = NULL;
    int i = 0;
    int num_entries = 0;
    bool is_mapped = FALSE;

    SHR_FUNC_ENTER(unit);

    if (hdl_cnt == 0) {
        SHR_EXIT();
    }


    for (i = 0; i < hdl_cnt; i++) {
        table_id = def_lt_array[i];
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_uft_bank_table_is_mapped(unit, bank_num, table_id, &is_mapped));
        if (!is_mapped) {
            continue;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, table_id, &entry_hdl_array[i]));
        num_entries = 0;
        while ((rv = bcmlt_entry_commit(entry_hdl_array[i], BCMLT_OPCODE_TRAVERSE,
                                        BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl_array[i], BCMLT_OPCODE_DELETE,
                                    BCMLT_PRIORITY_NORMAL));
            num_entries++;
            /* There should be only one entry for each default table. */
            break;
        }

        /*
         * No entry created, don't need to add the entry back later.
         * Just release the entry handler.
         */
        if (num_entries == 0){
            (void)bcmlt_entry_free(entry_hdl_array[i]);
            entry_hdl_array[i] = BCMLT_INVALID_HDL;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add default table entries.
 *
 * \param [in] unit Unit number.
 * \param [in] entry_hdl_array LT entry handle array contain default table entries.
 * \param [in] hdl_cnt Count of default LT entry handles.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_default_table_insert(
    int unit,
    bcmlt_entry_handle_t *entry_hdl_array,
    int hdl_cnt)
{
    int i;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < hdl_cnt; i++) {
        if (entry_hdl_array[i] == BCMLT_INVALID_HDL) {
            continue;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(entry_hdl_array[i], BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable or disable robust hash.
 *
 * \param [in] unit Unit number.
 * \param [in] bank_num Bank number.
 * \param [in] flags Bank control flags.
 * \param [in] robust 1 to enable robust hash, 0 to disable robust hash.
 * \param [in] seed Robust hashing seed.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_bank_robust_enable_set(
    int unit,
    bcm_switch_hash_bank_t bank_num,
    uint32_t flags,
    uint32_t robust,
    uint32_t seed)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *tile_id = NULL;
    int alloc_sz = 0;
    int i = 0;
    bcmlt_entry_handle_t *entry_hdl_array = NULL;
    bcmint_uft_db_t uft_db = {
        .num_lt_array = 0,
        .def_lt_array = NULL,
        .tile_bank_cnt = 0,
        .tile_bank_map = NULL,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    for (i = 0; i < uft_db.tile_bank_cnt; i++) {
        if (uft_db.tile_bank_map[i].val == bank_num) {
            tile_id = uft_db.tile_bank_map[i].name;
            break;
        }
    }
    if (tile_id == NULL){
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    /* Allocate buffer for default LT entry handlers. */
    alloc_sz = sizeof(bcmlt_entry_handle_t) * uft_db.num_lt_array;
    if (alloc_sz > 0) {
        SHR_ALLOC(entry_hdl_array, alloc_sz, "bcmLtswHashDefTableEntryHdl");
        SHR_NULL_CHECK(entry_hdl_array, SHR_E_MEMORY);
        sal_memset(entry_hdl_array, BCMLT_INVALID_HDL, alloc_sz);
    }

    /* Remove default LT entries from this bank. */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_uft_default_table_clear(unit, bank_num, uft_db.def_lt_array,
                                          uft_db.num_lt_array, entry_hdl_array));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_TILEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_TILE_IDs, tile_id));
    if (flags & BCM_SWITCH_HASH_BANK_CONTROL_ROBUST_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ROBUSTs, robust));
    }
    if (flags & BCM_SWITCH_HASH_BANK_CONTROL_SEED_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, SEEDs, seed));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

    /* Insert default table entries back. */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_uft_default_table_insert(unit, entry_hdl_array,
                                           uft_db.num_lt_array));

exit:
    if (entry_hdl_array != NULL) {
        for (i = 0; i < uft_db.num_lt_array; i++) {
            if (entry_hdl_array[i] != BCMLT_INVALID_HDL) {
                (void)bcmlt_entry_free(entry_hdl_array[i]);
            }
        }
    }
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FREE(entry_hdl_array);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get robust hash enable status.
 *
 * \param [in] unit Unit number.
 * \param [in] bank_num Bank number.
 * \param [out] robust 1 if robust hash is enabled, 0 if robust hash is disabled.
 * \param [out] seed Robust hashing seed.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_bank_robust_enable_get(
    int unit,
    bcm_switch_hash_bank_t bank_num,
    uint32_t *robust,
    uint32_t *seed)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *tile_id = NULL;
    uint64_t field_val;
    int i = 0;
    bcmint_uft_db_t uft_db = {
        .tile_bank_cnt = 0,
        .tile_bank_map = NULL,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    for (i = 0; i < uft_db.tile_bank_cnt; i++) {
        if (uft_db.tile_bank_map[i].val == bank_num) {
            tile_id = uft_db.tile_bank_map[i].name;
            break;
        }
    }
    if (tile_id == NULL) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_TILEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_TILE_IDs, tile_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    if (robust) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, ROBUSTs, &field_val));
        *robust = field_val;
    }

    if (seed) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, SEEDs, &field_val));
        *seed = field_val;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set hash offset into the hash vector.
 *
 * \param [in] unit Unit number.
 * \param [in] bank_num Bank number.
 * \param [in] hash_offset Hash offset.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_bank_offset_set(
    int unit,
    bcm_switch_hash_bank_t bank_num,
    uint32_t offset)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t *entry_hdl_array = NULL;
    const char *bank_str = NULL;
    int alloc_sz = 0;
    int i = 0;
    bcmint_uft_db_t uft_db = {
        .num_lt_array = 0,
        .def_lt_array = NULL,
        .bank_id_cnt = 0,
        .bank_id_map = NULL,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    for (i = 0; i < uft_db.bank_id_cnt; i++) {
        if (uft_db.bank_id_map[i].val == bank_num) {
            bank_str = uft_db.bank_id_map[i].name;
            break;
        }
    }
    if (bank_str == NULL) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    /* Allocate buffer for default LT entry handlers. */
    alloc_sz = sizeof(bcmlt_entry_handle_t) * uft_db.num_lt_array;
    if (alloc_sz > 0) {
        SHR_ALLOC(entry_hdl_array, alloc_sz, "bcmLtswHashDefTableEntryHdl");
        SHR_NULL_CHECK(entry_hdl_array, SHR_E_MEMORY);
        sal_memset(entry_hdl_array, BCMLT_INVALID_HDL, alloc_sz);
    }

    /* Remove default LT entries from this bank. */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_uft_default_table_clear(unit, bank_num, uft_db.def_lt_array,
                                          uft_db.num_lt_array, entry_hdl_array));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_BANKs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_BANK_IDs, bank_str));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, OFFSETs, offset));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl_array != NULL) {
        for (i = 0; i < uft_db.num_lt_array; i++) {
            if (entry_hdl_array[i] != BCMLT_INVALID_HDL) {
                (void)bcmlt_entry_free(entry_hdl_array[i]);
            }
        }
    }
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FREE(entry_hdl_array);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get hash offset from the hash vector.
 *
 * \param [in] unit Unit number.
 * \param [in] bank_num Bank number.
 * \param [out] offset Hash offset.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_uft_bank_offset_get(
    int unit,
    bcm_switch_hash_bank_t bank_num,
    uint32_t *offset)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *bank_str = NULL;
    uint64_t field_val;
    int i = 0;
    bcmint_uft_db_t uft_db = {
        .num_lt_array = 0,
        .def_lt_array = NULL,
        .bank_id_cnt = 0,
        .bank_id_map = NULL,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    for (i = 0; i < uft_db.bank_id_cnt; i++) {
        if (uft_db.bank_id_map[i].val == bank_num) {
            bank_str = uft_db.bank_id_map[i].name;
            break;
        }
    }
    if (bank_str == NULL) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_BANKs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_BANK_IDs, bank_str));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, OFFSETs, &field_val));
    *offset = field_val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_uft_init(int unit)
{
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];

    SHR_FUNC_ENTER(unit);

    if (!bcmi_ltsw_dev_exists(unit)) {
        SHR_ERR_EXIT(SHR_E_UNIT);
    }

    if (dev_info->inited == TRUE) {
        ltsw_xfs_uft_info_cleanup(unit);
    }

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_tile_mode_init(unit));

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_info_init(unit));

    if (bcmi_warmboot_get(unit)) {
        dev_info->inited = TRUE;
        SHR_EXIT();
    }

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_pair_bank_init(unit));

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_em_group_init(unit));

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_table_max_entries_init(unit));

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_table_move_depth_init(unit));

    dev_info->inited = TRUE;

exit:
    if (SHR_FUNC_ERR()) {
        ltsw_xfs_uft_info_cleanup(unit);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_uft_detach(int unit)
{
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];

    SHR_FUNC_ENTER(unit);

    if (!bcmi_ltsw_dev_exists(unit)) {
        SHR_ERR_EXIT(SHR_E_UNIT);
    }

    if (dev_info->inited == FALSE) {
        SHR_EXIT();
    }

    dev_info->inited = FALSE;

    if (bcmi_warmboot_get(unit)) {
        SHR_EXIT();
    }

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_em_group_deinit(unit));

    SHR_IF_ERR_EXIT
        (ltsw_xfs_uft_em_bank_deinit(unit));

exit:
    ltsw_xfs_uft_info_cleanup(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_uft_mode_get(
    int unit,
    bcmi_ltsw_uft_mode_t *uft_mode)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(uft_mode, SHR_E_PARAM);

    *uft_mode = bcmi_ltsw_property_get(unit, BCMI_CPN_UFT_MODE, 3);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_uft_multi_move_depth_set(
    int unit,
    bcm_switch_control_t type,
    int arg)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    bcmlt_field_def_t field_def[2];
    const char *table_id = NULL;
    uint32_t num_fields;
    int i = 0;
    bcmint_uft_db_t uft_db = {
        .move_depth_cnt = 0,
        .move_depth_map = NULL,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(unit, TABLE_EM_CONTROLs, 2, field_def,
                                    &num_fields));
    if ((arg < field_def[0].min) || (arg > field_def[0].max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (i = 0; i < uft_db.move_depth_cnt; i++) {
        if (uft_db.move_depth_map[i].val > type) {
            break;
        }
        if (uft_db.move_depth_map[i].val == type) {
            table_id = uft_db.move_depth_map[i].name;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TABLE_EM_CONTROLs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs, table_id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, MOVE_DEPTHs, arg));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_UPDATE,
                                             entry_hdl));
            entry_hdl = BCMLT_INVALID_HDL;
        }
    }

    if (table_id == NULL) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_uft_multi_move_depth_get(
    int unit,
    bcm_switch_control_t type,
    int *arg)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *table_id = NULL;
    uint64_t field_val = 0;
    int i = 0;
    bcmint_uft_db_t uft_db = {
        .move_depth_cnt = 0,
        .move_depth_map = NULL,
    };

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    for (i = 0; i < uft_db.move_depth_cnt; i++) {
        if (uft_db.move_depth_map[i].val > type) {
            break;
        }
        if (uft_db.move_depth_map[i].val == type) {
            table_id = uft_db.move_depth_map[i].name;
            break;
        }
    }

    if (table_id == NULL) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_EM_CONTROLs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs, table_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, MOVE_DEPTHs, &field_val));
    *arg = (int)field_val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_uft_bank_info_get(
    int unit,
    bcm_switch_hash_bank_info_t *bank_info)
{
    int rv;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_bank_info_t *banki = NULL;
    bcm_switch_hash_bank_t bank_num;
    uint64_t field_val = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(bank_info, SHR_E_PARAM);
    bank_num = bank_info->bank_num;
    if ((bank_num < bcmSwitchHashBank0) || (bank_num >= bcmSwitchHashBankCount)) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Invalid bank number [%d].\n"), bank_num));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (dev_info->inited != TRUE) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    rv = ltsw_xfs_uft_bank_info_get(unit, bank_num, &banki);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    SHR_IF_ERR_EXIT(rv);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_BANK_INFOs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_BANK_IDs,
                                      banki->bank_str));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, BASE_ENTRY_WIDTHs, &field_val));
    bank_info->base_entry_width = field_val;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NUM_BASE_ENTRIESs, &field_val));
    bank_info->num_base_entries = field_val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_uft_bank_multi_get(
    int unit,
    bcm_switch_hash_table_t hash_table,
    int array_size,
    bcm_switch_hash_bank_t *bank_array,
    int *num_banks)
{
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_group_info_t *group_info = NULL;
    const char *table_id = NULL;
    int i = 0, j = 0, k = 0, idx = 0;
    int bank_id;
    bool is_found = FALSE;
    bcmint_uft_db_t uft_db = {
        .hash_table_cnt = 0,
        .hash_table_map = NULL,
    };

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(bank_array, SHR_E_PARAM);
    SHR_NULL_CHECK(num_banks, SHR_E_PARAM);

    if ((hash_table < 0) || (hash_table >= bcmHashTable__Num)) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Invalid hash table [%d].\n"), hash_table));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (array_size <= 0 ) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Array size must be greater than zero.\n")));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (dev_info->inited != TRUE) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    SHR_IF_ERR_EXIT
        (mbcm_ltsw_uft_db_get(unit, &uft_db));

    *num_banks = 0;
    for (i = 0; i < uft_db.hash_table_cnt; i++) {
        if (uft_db.hash_table_map[i].val > hash_table) {
            break;
        }
        if (uft_db.hash_table_map[i].val != hash_table) {
            continue;
        }
        table_id = uft_db.hash_table_map[i].name;
        /* Traverse EM groups to which the LT is mapped. */
        for (j = 0; j < dev_info->max_group; j++) {
            group_info = dev_info->group_info + j;
            if (!group_info->valid || group_info->var_cnt < 1) {
                continue;
            }
            is_found = FALSE;
            for (idx = 0; idx < group_info->lkup0_lt_cnt; idx++) {
                if (sal_strcmp(group_info->lkup0_lt[idx], table_id) == 0) {
                    is_found = TRUE;
                    break;
                }
            }
            if (is_found == FALSE) {
                continue;
            }

            /* Retrieve the variable banks. */
            for (idx = 0; idx < group_info->var_cnt; idx++) {
                bank_id = group_info->var_bank[idx];
                is_found = FALSE;
                for (k = 0; k < *num_banks; k++) {
                    if (bank_array[k] == bank_id) {
                        is_found = TRUE;
                        break;
                    }
                }
                if (is_found == TRUE) {
                    continue;
                }
                bank_array[*num_banks] = bank_id;
                *num_banks += 1;
                if (*num_banks >= array_size) {
                    SHR_EXIT();
                }
            }
        }
    }

    if (table_id == NULL) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_uft_table_multi_get(
    int unit,
    bcm_switch_hash_bank_t bank_num,
    int array_size,
    bcm_switch_hash_table_t *table_array,
    int *num_tables)
{
    int rv;
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    int hash_table;
    bcm_switch_hash_bank_t bank_array[bcmSwitchHashBankCount];
    int num_banks;
    int i;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(table_array, SHR_E_PARAM);
    SHR_NULL_CHECK(num_tables, SHR_E_PARAM);

    if ((bank_num < bcmSwitchHashBank0) || (bank_num >= bcmSwitchHashBankCount)) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Invalid bank number [%d].\n"), bank_num));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (array_size <= 0 ) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Array size must be greater than zero.\n")));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (dev_info->inited != TRUE) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    *num_tables = 0;
    for (hash_table = 0; hash_table < bcmHashTable__Num; hash_table++) {
        if (hash_table == bcmHashTableMPLS) {
            continue;
        }
        rv = xfs_ltsw_uft_bank_multi_get(unit, hash_table,
                                         bcmSwitchHashBankCount, bank_array,
                                         &num_banks);
        SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_UNAVAIL);
        if (rv == SHR_E_UNAVAIL) {
            continue;
        }

        for (i = 0; i < num_banks; i++) {
            if (bank_array[i] == bank_num) {
                table_array[*num_tables] = hash_table;
                *num_tables += 1;
                break;
            }
        }
        if (*num_tables >= array_size) {
            break;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_uft_bank_control_set(
    int unit,
    bcm_switch_hash_bank_control_t *bank_control)
{
    int rv;
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_bank_info_t *bank_info = NULL;
    bcm_switch_hash_bank_t bank_num;
    int pair_bank;
    uint32_t valid_flags = 0;
    uint32_t flags = 0, robust = 0, seed = 0, offset = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(bank_control, SHR_E_PARAM);
    if (dev_info->inited != TRUE) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    bank_num = bank_control->bank_num;
    flags = bank_control->valid_fields;
    robust = bank_control->robust;
    seed = bank_control->seed;
    offset = bank_control->offset;

    if ((bank_num < bcmSwitchHashBank0) ||
        (bank_num >= bcmSwitchHashBankCount)) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Invalid bank number [%d].\n"), bank_num));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    valid_flags = BCM_SWITCH_HASH_BANK_CONTROL_ROBUST_VALID |
                  BCM_SWITCH_HASH_BANK_CONTROL_HASH_TYPE_VALID |
                  BCM_SWITCH_HASH_BANK_CONTROL_OFFSET_VALID |
                  BCM_SWITCH_HASH_BANK_CONTROL_SEED_VALID;
    if ((~valid_flags) & flags) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Invalid bank control fields [%d].\n"),
                                flags));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((flags & BCM_SWITCH_HASH_BANK_CONTROL_HASH_TYPE_VALID) &&
        (bank_control->hash_type != BCM_HASH_OFFSET)) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Hash type [%d] Unsupported.\n"),
                                bank_control->hash_type));
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (flags & BCM_SWITCH_HASH_BANK_CONTROL_ROBUST_VALID) {
        if ((robust != 0) && (robust != 1)) {
            LOG_VERBOSE(BSL_LOG_MODULE,
                        (BSL_META_U(unit, "Robust enable must be either 0 or 1.\n")));
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    rv = ltsw_xfs_uft_bank_info_get(unit, bank_num, &bank_info);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    SHR_IF_ERR_EXIT(rv);
    pair_bank = bank_info->pair_bank;

    if ((flags & BCM_SWITCH_HASH_BANK_CONTROL_ROBUST_VALID) ||
        (flags & BCM_SWITCH_HASH_BANK_CONTROL_SEED_VALID)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_uft_bank_robust_enable_set(unit, bank_num, flags, robust,
                                                  seed));
        if (pair_bank >= 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_uft_bank_robust_enable_set(unit, pair_bank, flags,
                                                      robust, seed));
        }
    }

    if (flags & BCM_SWITCH_HASH_BANK_CONTROL_OFFSET_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_uft_bank_offset_set(unit, bank_num, offset));
        if (pair_bank >= 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_uft_bank_offset_set(unit, pair_bank, offset));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_uft_bank_control_get(
    int unit,
    bcm_switch_hash_bank_control_t *bank_control)
{
    int rv;
    uft_dev_info_t *dev_info = &xfs_ltsw_uft_dev_info[unit];
    uft_bank_info_t *bank_info = NULL;
    bcm_switch_hash_bank_t bank_num;
    uint32_t valid_flags = 0;
    uint32_t robust = 0, seed = 0, offset = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(bank_control, SHR_E_PARAM);
    if (dev_info->inited != TRUE) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    bank_num = bank_control->bank_num;
    if ((bank_num < bcmSwitchHashBank0) || (bank_num >= bcmSwitchHashBankCount)) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Invalid bank number [%d].\n"), bank_num));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    valid_flags = BCM_SWITCH_HASH_BANK_CONTROL_ROBUST_VALID |
                  BCM_SWITCH_HASH_BANK_CONTROL_HASH_TYPE_VALID |
                  BCM_SWITCH_HASH_BANK_CONTROL_OFFSET_VALID |
                  BCM_SWITCH_HASH_BANK_CONTROL_SEED_VALID;
    if ((~valid_flags) & bank_control->valid_fields) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Invalid bank control fields [%d].\n"),
                     bank_control->valid_fields));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    rv = ltsw_xfs_uft_bank_info_get(unit, bank_num, &bank_info);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    SHR_IF_ERR_EXIT(rv);

    if (bank_control->valid_fields & BCM_SWITCH_HASH_BANK_CONTROL_HASH_TYPE_VALID) {
        bank_control->hash_type = BCM_HASH_OFFSET;
    }

    if ((bank_control->valid_fields & BCM_SWITCH_HASH_BANK_CONTROL_ROBUST_VALID) ||
        (bank_control->valid_fields & BCM_SWITCH_HASH_BANK_CONTROL_SEED_VALID)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_uft_bank_robust_enable_get(unit, bank_num, &robust, &seed));
        if (bank_control->valid_fields & BCM_SWITCH_HASH_BANK_CONTROL_ROBUST_VALID) {
            bank_control->robust = robust;
        }
        if (bank_control->valid_fields & BCM_SWITCH_HASH_BANK_CONTROL_SEED_VALID) {
            bank_control->seed = seed;
        }
    }

    if (bank_control->valid_fields & BCM_SWITCH_HASH_BANK_CONTROL_OFFSET_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_uft_bank_offset_get(unit, bank_num, &offset));
        bank_control->offset = offset;
    }

exit:
    SHR_FUNC_EXIT();
}

