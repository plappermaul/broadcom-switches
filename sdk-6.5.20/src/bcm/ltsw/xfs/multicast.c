/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/multicast.h>
#include <bcm_int/control.h>
#include <bcm_int/ltsw_dispatch.h>

#include <bcm_int/ltsw/xfs/multicast.h>
#include <bcm_int/ltsw/multicast.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw/index_table_mgmt.h>
#include <bcm_int/ltsw/init.h>
#include <bcm_int/ltsw/l3_egress.h>
#include <bcm_int/ltsw/l3_intf.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/sbr.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/vlan.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_MULTICAST

/******************************************************************************
 * Private functions
 */


/* Min remap index. */
#define     XFS_MC_TM_AGG_LIST_MEMBER_REMAP_IDX_MIN    1
#define     XFS_MC_LIST_MEMBER_REMAP_OFFSET            16384

/* Default L2 multicast group ID for default VLAN. */
#define XFS_MC_DEF_VLAN_GRP_ID                         0

/* Multicast EGR_TABLE_INDEX_UPDATE_PROFILE ID. */
typedef enum xfs_mc_egr_tbl_idx_update_profile_id_s {

    /* IPMC update profile ID. */
    XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC = 0x8,

    /* L3 tunnel update profile ID. */
    XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC_IPTNL = 0xa,

    /* L2 Tunnel update profile ID. */
    XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC_L2TNL = 0xc,

    /* L2 Tunnel Access update profile ID. */
    XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC_L2TNL_ACC = 0x10,
} xfs_mc_egr_tbl_idx_update_profile_id_t;

/* Data structure for TM_MC_AGG_LIST_MEMBER_REMAP entry. */
typedef struct lt_mc_list_member_remap_entry_s {
    /* Entry index. */
    uint32_t ent_idx;

    /* EGR_TABLE_INDEX_UPDATE_PROFILE ID. */
    uint8_t update_prof_id;

    /* Index value of Remap object 0. */
    uint32_t remap_index_0;

    /* Index value of Remap object 1. */
    uint32_t remap_index_1;

    /* Index value of Remap object 2. */
    uint32_t remap_index_2;

} lt_mc_list_member_remap_entry_t;

/*
 * Multicast replication head REPL_HEAD free blocks.
 */
typedef struct xfs_mc_repl_head_free_block_s {

    /* Starting index of a free block of REPL_HEAD table entries. */
    int index;

    /* Number of entries in the free block. */
    int size;

    /* Pointer to next free block. */
    struct xfs_mc_repl_head_free_block_s *next;

} xfs_mc_repl_head_free_block_t;

/*
 * Multicast replication head info structure.
 */
typedef struct xfs_mc_repl_head_info_s {

    /* Array of lists of free blocks. */
    xfs_mc_repl_head_free_block_t **free_list_array;

    /* Number of lists in the array. */
    int array_size;

} xfs_mc_repl_head_info_t;


typedef struct xfs_mc_info_s {
    /* L3 multicast replication head table size. */
    uint32_t                 repl_head_sz;

    /* L3 multicast replication head info. */
    xfs_mc_repl_head_info_t  repl_head_info;

    /* Minimum vaule of L3 mc remap index. */
    uint32_t                 remap_idx_min;

    /* Maximum vaule of L3 mc remap index. */
    uint32_t                 remap_idx_max;

} xfs_mc_info_t;


/* Static global variable of multicast info. */
static xfs_mc_info_t xfs_mc_info[BCM_MAX_NUM_UNITS] = {{ 0 }};

/* Multicast information. */
#define MC_INFO(u)                 (&xfs_mc_info[u])

/* IPMC replication head info. */
#define REPL_HEAD_SIZE(u)          (MC_INFO(u)->repl_head_sz)
#define REPL_HEAD(u)               (&(MC_INFO(u)->repl_head_info))
#define REPL_HEAD_FREE_LIST(u, idx) \
    (MC_INFO(u)->repl_head_info.free_list_array[idx])

/* MC list member remap index info. */
#define REMAP_IDX_MIN(u)           (MC_INFO(u)->remap_idx_min)
#define REMAP_IDX_MAX(u)           (MC_INFO(u)->remap_idx_max)

/******************************************************************************
 * Private functions
 */

/*!
 * \brief Get a L2 multicast group.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  l2mc_id        L2 multicast group id.
 * \param [in]  port_size      Maxium mumber of GPORTS in this group.
 * \param [out] port_array     Returned egress ports of this group.
 * \param [out] encap_id_array Returned list of encap_id.
 * \param [out] port_count     Count of returned ports.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l2_grp_get(
    int unit,
    int l2mc_id,
    int port_size,
    bcm_gport_t *gport_array,
    bcm_if_t *encap_id_array,
    int *port_count)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t *port_id_arr = NULL;
    int       max_ports, idx;
    uint32_t  r_cnt, cnt;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_MC_GROUPs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_MC_GROUP_IDs, l2mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    port_id_arr = sal_alloc(sizeof(uint64_t) * max_ports, "xfsMcPortIdArr");
    SHR_NULL_CHECK(port_id_arr, SHR_E_MEMORY);
    sal_memset(port_id_arr, 0, sizeof(uint64_t) * max_ports);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_get(eh, PORT_IDs, 0,
                                     port_id_arr, max_ports, &r_cnt));

    cnt = 0;
    for (idx = 0; idx < r_cnt; idx++) {
        /*
         * When port_size is > 0, only port_size ports are returned.
         * When port_size is 0, then just return the actual port_count.
         */
        if ((port_size > 0) && (cnt >= port_size)) {
            break;
        }

        /* Port is the member of this L2 multicast group. */
        if (port_id_arr[idx] == 1) {
            if (gport_array != NULL) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_port_gport_get(unit, idx, (gport_array + cnt)));
            }
            if (encap_id_array != NULL) {
                encap_id_array[cnt] = BCM_IF_INVALID;
            }
            cnt++;
        }
    }
    *port_count = cnt;

exit:
    SHR_FREE(port_id_arr);

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Free a block of REPL_HEAD table entries.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  index         Index of the first entry of the block.
 * \param [in]  size          Size of the block.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
mc_repl_head_block_free(
    int unit,
    int index,
    int size)
{
    int i;
    int block_index, block_size;
    int coalesced_index, coalesced_size;
    xfs_mc_repl_head_free_block_t *block_ptr;
    xfs_mc_repl_head_free_block_t *prev_block_ptr;
    xfs_mc_repl_head_free_block_t *next_block_ptr;
    xfs_mc_repl_head_free_block_t *coalesced_block_ptr;

    SHR_FUNC_ENTER(unit);

    if (size <= 0) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    /*
     * First, coalesce the block with any existing free blocks
     * that are contiguous with the block.
     */
    coalesced_index = index;
    coalesced_size = size;
    for (i = 0; i < REPL_HEAD(unit)->array_size; i++) {
        block_ptr = REPL_HEAD_FREE_LIST(unit, i);
        prev_block_ptr = NULL;
        while (NULL != block_ptr) {
            block_index = block_ptr->index;
            block_size = block_ptr->size;
            next_block_ptr = block_ptr->next;
            if ((block_index + block_size) == coalesced_index) {
                coalesced_index = block_index;
                coalesced_size += block_size;
                if (block_ptr == REPL_HEAD_FREE_LIST(unit, i)) {
                    REPL_HEAD_FREE_LIST(unit, i) = next_block_ptr;
                } else {
                    /*
                     * In the following line of code, Coverity thinks the
                     * prev_block_ptr may still be NULL when dereferenced.
                     * This situation will never occur because
                     * if block_ptr is not pointing to the head of the
                     * linked list, prev_block_ptr would not be NULL.
                     */
                    /* coverity[var_deref_op : FALSE] */
                    prev_block_ptr->next = next_block_ptr;
                }
                SHR_FREE(block_ptr);
            } else if ((coalesced_index + coalesced_size) == block_index) {
                coalesced_size += block_size;
                if (block_ptr == REPL_HEAD_FREE_LIST(unit, i)) {
                    REPL_HEAD_FREE_LIST(unit, i) = next_block_ptr;
                } else {
                    /*
                     * In the following line of code, Coverity thinks the
                     * prev_block_ptr may still be NULL when dereferenced.
                     * This situation will never occur because
                     * if block_ptr is not pointing to the head of the
                     * linked list, prev_block_ptr would not be NULL.
                     */
                    /* coverity[var_deref_op : FALSE] */
                    prev_block_ptr->next = next_block_ptr;
                }
                SHR_FREE(block_ptr);
            } else {
                prev_block_ptr = block_ptr;
            }
            block_ptr = next_block_ptr;
        }
    }

    /* Insert coalesced free block. */
    coalesced_block_ptr = sal_alloc(sizeof(xfs_mc_repl_head_free_block_t),
                                    "xfsMcCoalescedReplHeadFreeBlock");
    SHR_NULL_CHECK(coalesced_block_ptr, SHR_E_MEMORY);
    coalesced_block_ptr->index = coalesced_index;
    coalesced_block_ptr->size = coalesced_size;
    if (coalesced_size > (REPL_HEAD(unit)->array_size - 1)) {
        /* Insert into free list 0. */
        coalesced_block_ptr->next = REPL_HEAD_FREE_LIST(unit, 0);
        REPL_HEAD_FREE_LIST(unit, 0) = coalesced_block_ptr;
    } else {
        coalesced_block_ptr->next = REPL_HEAD_FREE_LIST(unit, coalesced_size);
        REPL_HEAD_FREE_LIST(unit, coalesced_size) = coalesced_block_ptr;
    }

    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Allocate a free block of REPL_HEAD table entries..
 *
 * \param [in]  unit          Unit number.
 * \param [in]  size          Size of free block requested.
 * \param [out] index         Index of the first entry of the free block.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
mc_repl_head_block_alloc(
    int unit,
    int size,
    int *index)
{
    int max_array_index;
    int i;
    int block_index, block_size;
    xfs_mc_repl_head_free_block_t *next_block_ptr;

    SHR_FUNC_ENTER(unit);

    if (size == 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (NULL == index) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    max_array_index = REPL_HEAD(unit)->array_size - 1;
    for (i = size; i <= max_array_index; i++) {
        if (NULL != REPL_HEAD_FREE_LIST(unit, i)) {
           block_index = REPL_HEAD_FREE_LIST(unit, i)->index;
           block_size = REPL_HEAD_FREE_LIST(unit, i)->size;
           next_block_ptr = REPL_HEAD_FREE_LIST(unit, i)->next;
           SHR_FREE(REPL_HEAD_FREE_LIST(unit, i));
           REPL_HEAD_FREE_LIST(unit, i) = next_block_ptr;

           /*
            *If the obtained free block contains more entries
            * than requested, insert the remainder back into
            * the free list array.
            */
           if (block_size > size) {
               SHR_IF_ERR_VERBOSE_EXIT
                   (mc_repl_head_block_free(unit,
                                            block_index + size,
                                            block_size - size));
           }

           *index = block_index;
           SHR_EXIT();
        }
    }

    /* Get free block from free list 0. */
    if (NULL != REPL_HEAD_FREE_LIST(unit, 0)) {
        block_index = REPL_HEAD_FREE_LIST(unit, 0)->index;
        block_size = REPL_HEAD_FREE_LIST(unit, 0)->size;
        next_block_ptr = REPL_HEAD_FREE_LIST(unit, 0)->next;
        if (block_size < size) {
            /*
             * Free blocks on list 0 should never be
             * smaller than requested size.
             */
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }

        SHR_FREE(REPL_HEAD_FREE_LIST(unit, 0));
        REPL_HEAD_FREE_LIST(unit, 0) = next_block_ptr;

        /*
         * If the obtained free block contains more entries
         * than requested, insert the remainder back into
         * the free list array.
         */
        if (block_size > size) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_repl_head_block_free(unit,
                                         block_index + size,
                                         block_size - size));
        }

        *index = block_index;
        SHR_EXIT();
    }

    /* No free block of sufficient size can be found */
    SHR_ERR_EXIT(SHR_E_RESOURCE);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-initialize replication head info.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static void
mc_repl_head_info_deinit(int unit)
{
    int i;
    xfs_mc_repl_head_free_block_t *block_ptr;
    xfs_mc_repl_head_free_block_t *next_block_ptr;

    if (NULL != REPL_HEAD(unit)) {
        if (NULL != REPL_HEAD(unit)->free_list_array) {
            for (i = 0; i < REPL_HEAD(unit)->array_size; i++) {
                block_ptr = REPL_HEAD_FREE_LIST(unit, i);
                while (NULL != block_ptr) {
                    next_block_ptr = block_ptr->next;
                    SHR_FREE(block_ptr);
                    block_ptr = next_block_ptr;
                }
                REPL_HEAD_FREE_LIST(unit, i) = NULL;
            }
            SHR_FREE(REPL_HEAD(unit)->free_list_array);
            REPL_HEAD(unit)->free_list_array = NULL;
            REPL_HEAD(unit)->array_size = 0;
        }
    }

    return;
}

/*!
 * \brief Initialize replication head info.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
mc_repl_head_info_init(int unit)
{
    int alloc_size;
    int max_array_index = 0;
    uint64_t agg_list_id_min = 0, agg_list_id_max = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TM_MC_PORT_AGG_LISTs,
                                       TM_MC_PORT_AGG_LIST_IDs,
                                       &agg_list_id_min, &agg_list_id_max));

    REPL_HEAD_SIZE(unit) = agg_list_id_max - agg_list_id_min + 1;
    sal_memset(REPL_HEAD(unit), 0, sizeof(xfs_mc_repl_head_info_t));

    /*
     * Each element of the array is a linked list of free blocks.
     * Array element N is a linked list of free blocks of size N.
     * When allocating a block of REPL_HEAD table entries, the max
     * number of entries needed is equal to the max number of members
     * in a replication group. This will also be the max index of the
     * array. Of course, the REPL_HEAD table may contain bigger blocks
     * of free entries. Array element 0 wil be a linked list of free
     * blocks with size greater than the max number of members in a
     * replication group.
     */
    max_array_index = bcmi_ltsw_dev_logic_port_num(unit);
    alloc_size = (max_array_index + 1) *
                  sizeof(xfs_mc_repl_head_free_block_t *);
    REPL_HEAD(unit)->free_list_array =
        sal_alloc(alloc_size, "xfsMcReplHeadFreeListArr");
    SHR_NULL_CHECK(REPL_HEAD(unit)->free_list_array, SHR_E_MEMORY);
    sal_memset(REPL_HEAD(unit)->free_list_array, 0, alloc_size);
    REPL_HEAD(unit)->array_size = max_array_index + 1;

    REPL_HEAD_FREE_LIST(unit, 0) =
        sal_alloc(sizeof(xfs_mc_repl_head_free_block_t),
                  "xfsMcReplHeadFreeBlock");
    SHR_NULL_CHECK(REPL_HEAD_FREE_LIST(unit, 0), SHR_E_MEMORY);

    /*
     * Initially, there is only one free block, starting at entry 1 of
     * REPL_HEAD table and ending at the last entry.
     * Entry 0 is reserved.
     */
    REPL_HEAD_FREE_LIST(unit, 0)->index = agg_list_id_min;
    REPL_HEAD_FREE_LIST(unit, 0)->size = REPL_HEAD_SIZE(unit);
    REPL_HEAD_FREE_LIST(unit, 0)->next = NULL;

exit:
    if (SHR_FUNC_ERR()) {
        mc_repl_head_info_deinit(unit);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get info for a L3 multicast group.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  l3mc_id        L3 multicast group id.
 * \param [out] repl_head_base Replication head base ptr for this group.
 * \param [out] repl_head_cnt  Count of repl_head entries.
 * \param [out] l2_mem_arr     Returned L2 bitmap member.
 * \param [out] l3_mem_arr     Returned L3 bitmap member.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_info_get(
    int unit,
    int l3mc_id,
    int *repl_head_base,
    int *repl_head_cnt,
    int *l2_mem_arr,
    int *l3_mem_arr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int       dunit = 0;
    uint64_t  value = 0;
    int       max_ports, idx;
    uint32_t  r_cnt;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_GROUPs, &eh));

    /* Add L3 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, l3mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, TM_MC_PORT_AGG_LIST_IDs, &value));
    *repl_head_base = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, NUM_PORT_LIST_ENTRIESs, &value));
    *repl_head_cnt = value;

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    if (l2_mem_arr != NULL) {
        for (idx = 0; idx < max_ports; idx++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(eh, L2_PORTs,
                                             idx, &value, 1, &r_cnt));
            l2_mem_arr[idx] = value;
        }
    }

    if (l3_mem_arr != NULL) {
        for (idx = 0; idx < max_ports; idx++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(eh, L3_PORTs,
                                             idx, &value, 1, &r_cnt));
            l3_mem_arr[idx] = value;
        }
    }

exit:

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Set info for a L3 multicast group.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  l3mc_id        L3 multicast group id.
 * \param [in]  repl_head_base Replication head base ptr for this group.
 * \param [in]  repl_head_cnt  Count of repl_head entries.
 * \param [in]  l2_mem_arr     L2 bitmap member.
 * \param [in]  l3_mem_arr     L3 bitmap member.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_info_set(
    int unit,
    int l3mc_id,
    int repl_head_base,
    int repl_head_cnt,
    int *l2_mem_arr,
    int *l3_mem_arr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int      dunit = 0;
    uint64_t value = 0;
    int      max_ports, idx;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_GROUPs, &eh));

    /* Add L3 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, l3mc_id));

    value = repl_head_base;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_PORT_AGG_LIST_IDs, value));

    value = repl_head_cnt;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, NUM_PORT_LIST_ENTRIESs, value));

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    for (idx = 0; idx < max_ports; idx++) {
        value = l2_mem_arr[idx];
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(eh, L2_PORTs, idx, &value, 1));
    }
    for (idx = 0; idx < max_ports; idx++) {
        value = l3_mem_arr[idx];
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(eh, L3_PORTs, idx, &value, 1));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Add/Remove a port to/from L2 bitmap of a L3 multicast group.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  l3mc_id        L3 multicast group id.
 * \param [in]  port           Logical port id.
 * \param [in]  set            1 means add, 0 means remove.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_port_l2_set(
    int unit,
    int l3mc_id,
    bcm_port_t port,
    int set)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int      dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_GROUPs, &eh));

    /* Add L3 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, l3mc_id));

    value = set;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(eh, L2_PORTs, port, &value, 1));


    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));
exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set encap_id array to SDKLT(HW).
 *
 * \param [in]  unit            Unit Number.
 * \param [in]  pal_id          Port aggregate encap list ID.
 * \param [in]  agg_id          Port aggregate ID.
 * \param [in]  encap_id_arr    Encap id array.
 * \param [in]  encap_id_cnt    Count of encap id.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_encap_set(
    int unit,
    int pal_id,
    int agg_id,
    int *encap_id_arr,
    uint32_t encap_id_cnt)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t value = 0;
    int idx;

    SHR_FUNC_ENTER(unit);

    if ((encap_id_cnt > 0) && (encap_id_arr == NULL)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_PORT_AGG_LISTs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_PORT_AGG_LIST_IDs, pal_id));

    if (encap_id_cnt > 0) {

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, TM_MC_PORT_AGG_IDs, agg_id));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, NUM_AGG_LIST_MEMBERs, encap_id_cnt));

        for (idx = 0; idx < encap_id_cnt; idx++) {
            value = encap_id_arr[idx];
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(eh, AGG_LIST_MEMBERs,
                                             idx, &value, 1));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, eh,
                                  BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get encap id array of a port aggregate list ID.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  pal_id         Port's related list ID.
 * \param [out] agg_id         Port's aggregate ID.
 * \param [in]  encap_id_sz    Maximum count of returned encap id. When it is 0,
 *                             it means to return all encap id for this port.
 * \param [out] encap_id_arr   Returned Encap id array.
 * \param [out] encap_id_cnt   Returned count of encap id.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_encap_get(
    int unit,
    int pal_id,
    int *agg_id,
    int encap_id_sz,
    int *encap_id_arr,
    int *encap_id_cnt)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int      dunit;
    uint64_t value;
    int      idx;
    uint32_t r_cnt = 0;

    SHR_FUNC_ENTER(unit);

    if (encap_id_sz < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    } else if ((encap_id_sz > 0) && (encap_id_arr == NULL)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (encap_id_cnt == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_PORT_AGG_LISTs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_PORT_AGG_LIST_IDs, pal_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, TM_MC_PORT_AGG_IDs, &value));
    *agg_id = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, NUM_AGG_LIST_MEMBERs, &value));
    *encap_id_cnt = value;

    for (idx = 0; idx < (*encap_id_cnt); idx++) {
        if ((encap_id_sz > 0) && (idx >= encap_id_sz)) {
            SHR_EXIT();
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(eh, AGG_LIST_MEMBERs,
                                         idx, &value, 1, &r_cnt));
        if (encap_id_arr != NULL) {
            encap_id_arr[idx] = value;
        }
    }
    *encap_id_cnt = idx;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set egress encap to a port of L3 multicast group.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  l3mc_id        L3 multicast group id.
 * \param [in]  port           Logical port id.
 * \param [in]  encap_id_arr   Encap id array.
 * \param [in]  encap_id_cnt   Count of encap id.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_port_encap_set(
    int unit,
    uint32_t l3mc_id,
    bcm_port_t port,
    int *encap_id_arr,
    int encap_id_cnt)
{
    uint32_t max_ports = 0;
    int      idx = 0;
    int     *l2_memb = NULL;
    int     *l3_memb = NULL;

    /* Replication head info. */
    int rh_base = 0, rh_cnt = 0, new_rh_base;
    int member_id, new_member_id;
    /* Encap id array. */
    int *tmp_eid_arr = NULL;
    int  r_cnt = 0;
    uint64_t eid_min = 0, eid_max = 0;

    /* Port Aggregate List ID. */
    int pal_id;
    int agg_id;

    SHR_FUNC_ENTER(unit);

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    l2_memb = sal_alloc(sizeof(int) * max_ports, "xfsMcL2MemArr");
    SHR_NULL_CHECK(l2_memb, SHR_E_MEMORY);
    sal_memset(l2_memb, 0, sizeof(int) * max_ports);

    l3_memb = sal_alloc(sizeof(int) * max_ports, "xfsMcL3MemArr");
    SHR_NULL_CHECK(l3_memb, SHR_E_MEMORY);
    sal_memset(l3_memb, 0, sizeof(int) * max_ports);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_l3_grp_info_get(unit, l3mc_id,
                            &rh_base, &rh_cnt,
                            l2_memb, l3_memb));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TM_MC_PORT_AGG_LISTs,
                                       NUM_AGG_LIST_MEMBERs,
                                       &eid_min, &eid_max));
    tmp_eid_arr = sal_alloc(sizeof(int) * eid_max, "xfcMcEncapIdArr");
    SHR_NULL_CHECK(tmp_eid_arr, SHR_E_MEMORY);

    /* It means to remove a port from a group when encap_id_cnt equals 0. */
    if (encap_id_cnt == 0) {
        if (l3_memb[port] == 0) {
            SHR_EXIT();
        }

        if (rh_cnt > 1) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_repl_head_block_alloc(unit, (rh_cnt - 1), &new_rh_base));

            /*
             * When a port is removed from a group, repl_head entry for
             * this port is deleted. So each original repl_head entry is
             * needed to be moved to a new place.
             */
            member_id = 0;
            new_member_id = 0;
            for (idx = 0; idx < max_ports; idx++) {
                if (l3_memb[idx] == 0) {
                    continue;
                }

                if (idx != port) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mc_l3_grp_encap_get(unit, rh_base + member_id,
                                             &agg_id, eid_max,
                                             tmp_eid_arr, &r_cnt));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mc_l3_grp_encap_set(unit, new_rh_base + new_member_id,
                                             agg_id, tmp_eid_arr, r_cnt));
                    new_member_id++;
                }
                member_id++;
            }
            l3_memb[port] = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_info_set(unit, l3mc_id,
                                    new_rh_base, (rh_cnt - 1),
                                    l2_memb, l3_memb));
        } else {
            l3_memb[port] = 0;
            
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_info_set(unit, l3mc_id, rh_base,
                                    0, l2_memb, l3_memb));
        }

        /* Free old repl_head encap list entries. */
        member_id = 0;
        l3_memb[port] = 1;
        for (idx = 0; idx < max_ports; idx++) {
            if (l3_memb[idx] == 0) {
                continue;
            }
            agg_id = idx;
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_encap_set(unit, rh_base + member_id,
                                     agg_id, NULL, 0));
            member_id++;
        }

        /* Free repl_head resources. */
        if (rh_base > 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_repl_head_block_free(unit, rh_base, rh_cnt));
        }
    } else if (encap_id_cnt > 0) { /* Port is still a L3 member of the group. */
        /* Port is already a l3 member of the group. */
        if (l3_memb[port]) {
            member_id = 0;
            for (idx = 0; idx < max_ports; idx++) {
                if (l3_memb[idx]) {
                    if (idx == port) {
                        break;
                    }
                    member_id++;
                }
            }
            pal_id = rh_base + member_id;
            agg_id = port;
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_encap_set(unit, pal_id,
                                     agg_id, encap_id_arr, encap_id_cnt));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_repl_head_block_alloc(unit, (rh_cnt + 1), &new_rh_base));

            /*
             * When a port is newly added to a group, repl_head entry for
             * this port is added. So each original repl_head entry is
             * needed to be moved to a new place.
             * And note that member_id may be changed.
             */
            member_id = 0;
            new_member_id = 0;
            for (idx = 0; idx < max_ports; idx++) {
                if (idx == port) {
                    agg_id = port;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mc_l3_grp_encap_set(unit, new_rh_base + new_member_id,
                                             agg_id, encap_id_arr,
                                             encap_id_cnt));
                    new_member_id++;
                    continue;
                }

                if (l3_memb[idx] == 0) {
                    continue;
                }

                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_encap_get(unit, rh_base + member_id,
                                         &agg_id, eid_max,
                                         tmp_eid_arr, &r_cnt));
                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_encap_set(unit, new_rh_base + new_member_id,
                                         agg_id, tmp_eid_arr, r_cnt));
                member_id++;
                new_member_id++;
            }

            l3_memb[port] = 1;
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_info_set(unit, l3mc_id,
                                    new_rh_base, (rh_cnt + 1),
                                    l2_memb, l3_memb));

            /* Free old repl_head encap list entries. */
            member_id = 0;
            for (idx = 0; idx < max_ports; idx++) {
                if (l3_memb[idx] == 0) {
                    continue;
                }
                if (idx == port) {
                    continue;
                }

                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_encap_set(unit, rh_base + member_id, 0, NULL, 0));
                member_id++;
            }

            /* Free repl_head resources. */
            if ((rh_base > 0) && (rh_cnt > 0)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_repl_head_block_free(unit, rh_base, rh_cnt));
            }
        }
    }

exit:

    SHR_FREE(tmp_eid_arr);
    SHR_FREE(l2_memb);
    SHR_FREE(l3_memb);

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get encap id array of port.
 *
 * \param [in]  unit          Unit Number.
 * \param [in]  l3cm_id       L3 multicast group id.
 * \param [in]  encap_id_sz   Maximum count of returned encap id. When it is 0,
 *                            it means to return all encap id for this group.
 * \param [out] encap_id_arr  Returned Encap id array.
 * \param [out] encap_id_cnt  Returned Count of encap id.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_port_encap_get(
    int unit,
    uint32_t l3mc_id,
    bcm_port_t port,
    int encap_id_sz,
    int *encap_id_arr,
    int *encap_id_cnt)
{
    /* Replicastion head info. */
    int rh_base = 0, rh_cnt = 0;
    int *l2_memb = NULL;
    int *l3_memb = NULL;

    /* Port Aggregate List Id*/
    int pal_id;
    int agg_id;

    int max_ports, member_id;
    int idx;
    int found = 0;

    SHR_FUNC_ENTER(unit);

    if (encap_id_sz < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    } else if ((encap_id_sz > 0) && (NULL == encap_id_arr)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (NULL == encap_id_cnt) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);

    l2_memb = sal_alloc(sizeof(int) * max_ports, "xfsMcL2MemArr");
    SHR_NULL_CHECK(l2_memb, SHR_E_MEMORY);
    sal_memset(l2_memb, 0, sizeof(int) * max_ports);

    l3_memb = sal_alloc(sizeof(int) * max_ports, "xfsMcL3MemArr");
    SHR_NULL_CHECK(l3_memb, SHR_E_MEMORY);
    sal_memset(l3_memb, 0, sizeof(int) * max_ports);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_l3_grp_info_get(unit, l3mc_id,
                            &rh_base, &rh_cnt,
                            l2_memb, l3_memb));

    /* It means this group has no egress member. */
    if (rh_base == 0) {
        *encap_id_cnt = 0;
        SHR_EXIT();
    }

    /* Find the corresponding repl_head entry index for the given port. */
    member_id = 0;
    for (idx = 0; idx < max_ports; idx++) {
        if (l3_memb[idx]) {
            if (idx == port) {
                found = 1;
                break;
            }
            member_id++;
        }
    }

    if (found) {
        pal_id = rh_base + member_id;
        SHR_IF_ERR_VERBOSE_EXIT
            (mc_l3_grp_encap_get(unit, pal_id, &agg_id,
                                 encap_id_sz, encap_id_arr, encap_id_cnt));
    } else {
        *encap_id_cnt = 0;
    }

exit:
    SHR_FREE(l2_memb);
    SHR_FREE(l3_memb);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the aggregate ID Mappings.
 *
 * \param [in]  unit            Unit Number.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_aggid_init(int unit)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;
    int max_ports = 0, i;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Clean up L2 multicast table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TM_MC_PORT_AGG_MAPs));

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_PORT_AGG_MAPs, &eh));
    for (i = 0; i < max_ports; i++) {
        /* By default, agg_id is same as PORT_ID. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, PORT_IDs, i));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, TM_MC_PORT_AGG_IDs, i));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, eh,
                                  BCMLT_OPCODE_INSERT,
                                  BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert multicast encap info to
 * entry of the LT TM_MC_AGG_LIST_MEMBER_REMAP.
 *
 * \param [in] unit            Unit number.
 * \param [in] tunnel_encap    Tunnel encap information.
 * \param [in] entry           Entry info.
 *
 * \retval SHR_E_NONE          No errors.
 * \retval !SHR_E_NONE         Failure.
 */
static int
mc_encap_to_list_member_remap_entry(
    int unit,
    bcm_multicast_encap_t *mc_encap,
    lt_mc_list_member_remap_entry_t *entry)
{
    int vp;
    int nh_idx;
    bcmi_ltsw_l3_egr_obj_type_t type;

    SHR_FUNC_ENTER(unit);

    if (mc_encap->encap_type == bcmMulticastEncapTypeL3Tunnel ||
        mc_encap->encap_type == bcmMulticastEncapTypeL2Tunnel) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_resolve(unit,
                                                mc_encap->ul_egress_if,
                                                &nh_idx, &type));
    }

    switch(mc_encap->encap_type) {
    case bcmMulticastEncapTypeL3Tunnel:
        entry->update_prof_id =
            XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC_IPTNL;
        entry->remap_index_0 = nh_idx;
        entry->remap_index_1 = mc_encap->l3_intf;
        entry->remap_index_2 = 0;
        break;
    case bcmMulticastEncapTypeL2Tunnel:
        if (BCM_GPORT_IS_MPLS_PORT(mc_encap->port_id)) {
            vp = BCM_GPORT_MPLS_PORT_ID_GET(mc_encap->port_id);
        } else if (BCM_GPORT_IS_FLOW_PORT(mc_encap->port_id)) {
            vp = BCM_GPORT_FLOW_PORT_ID_GET(mc_encap->port_id);
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        entry->update_prof_id =
            XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC_L2TNL;
        entry->remap_index_0 = nh_idx;
        entry->remap_index_1 = vp;
        entry->remap_index_2 = mc_encap->l3_intf;
        break;
    case bcmMulticastEncapTypeL2TunnelAccess:
        if (BCM_GPORT_IS_MPLS_PORT(mc_encap->port_id)) {
            vp = BCM_GPORT_MPLS_PORT_ID_GET(mc_encap->port_id);
        } else if (BCM_GPORT_IS_FLOW_PORT(mc_encap->port_id)) {
            vp = BCM_GPORT_FLOW_PORT_ID_GET(mc_encap->port_id);
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        entry->update_prof_id =
            XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC_L2TNL_ACC;
        entry->remap_index_0 = vp;
        entry->remap_index_2 = mc_encap->l3_intf;
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert multicast encap info from
 * entry of the LT TM_MC_AGG_LIST_MEMBER_REMAP.
 *
 * \param [in] unit            Unit number.
 * \param [in] mc_encap        Multicast encap information.
 * \param [in] entry           Entry info.
 *
 * \retval SHR_E_NONE          No errors.
 * \retval !SHR_E_NONE         Failure.
 */
static int
mc_encap_from_list_member_remap_entry(
    int unit,
    bcm_multicast_encap_t *mc_encap,
    lt_mc_list_member_remap_entry_t *entry)
{
    int vp;
    int nh_idx, ul_egress_if;
    bcmi_ltsw_virtual_vp_info_t vp_info = {0};
    bcmi_ltsw_gport_info_t gport_info = {0};

    SHR_FUNC_ENTER(unit);

    if (entry->update_prof_id ==
        XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC_IPTNL ||
        entry->update_prof_id ==
        XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC_L2TNL) {
        nh_idx = entry->remap_index_0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_construct(unit, nh_idx,
                                                  BCMI_LTSW_L3_EGR_OBJ_T_UL,
                                                  &ul_egress_if));
    }
    switch(entry->update_prof_id) {
    case XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC_IPTNL:
        mc_encap->encap_type   = bcmMulticastEncapTypeL3Tunnel;
        mc_encap->ul_egress_if = ul_egress_if;
        mc_encap->l3_intf      = entry->remap_index_1;
        mc_encap->port_id      = 0;
        break;
    case XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC_L2TNL:
        mc_encap->encap_type   = bcmMulticastEncapTypeL2Tunnel;
        mc_encap->ul_egress_if = ul_egress_if;
        vp                     = entry->remap_index_1;
        mc_encap->l3_intf      = entry->remap_index_2;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info));
        if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_MPLS) {
            gport_info.gport_type = _SHR_GPORT_TYPE_MPLS_PORT;
            gport_info.mpls_id    = vp;
        } else if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_FLOW) {
            gport_info.gport_type = _SHR_GPORT_TYPE_FLOW_PORT;
            gport_info.flow_id    = vp;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_construct(unit,
                                            &gport_info,
                                            &mc_encap->port_id));
        break;
    case XFS_MC_EGR_TABLE_INDEX_UPDATE_PROFILE_IDX_IPMC_L2TNL_ACC:
        mc_encap->encap_type   = bcmMulticastEncapTypeL2TunnelAccess;
        mc_encap->l3_intf      = entry->remap_index_2;
        vp                     = entry->remap_index_0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info));
        if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_MPLS) {
            gport_info.gport_type = _SHR_GPORT_TYPE_MPLS_PORT;
            gport_info.mpls_id    = vp;
        } else if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_FLOW) {
            gport_info.gport_type = _SHR_GPORT_TYPE_FLOW_PORT;
            gport_info.flow_id    = vp;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_construct(unit,
                                            &gport_info,
                                            &mc_encap->port_id));
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
        break;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert entry to handle for the LT TM_MC_AGG_LIST_MEMBER_REMAP.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  entry     Entry info.
 * \param [out] ent_hdl   Entry handle for LT TM_MC_AGG_LIST_MEMBER_REMAP.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mc_list_member_remap_entry_to_hdl(
    int unit,
    lt_mc_list_member_remap_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl,
                               TM_MC_AGG_LIST_MEMBER_REMAP_IDs,
                               entry->ent_idx));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl,
                               TM_EGR_OBJECT_UPDATE_PROFILE_IDs,
                               entry->update_prof_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl,
                               REMAP_OBJECT_INDEX_0s,
                               entry->remap_index_0));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl,
                               REMAP_OBJECT_INDEX_1s,
                               entry->remap_index_1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl,
                               REMAP_OBJECT_INDEX_2s,
                               entry->remap_index_2));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct entry of the LT TM_MC_AGG_LIST_MEMBER_REMAP from handle.
 *
 * \param [in] unit         Unit number.
 * \param [in] entry        Entry info.
 * \param [in] ent_hdl_0    Entry handle for EGR_L3_TUNNEL_0.
 * \param [in] ent_hdl_1    Entry handle for EGR_L3_TUNNEL_1.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mc_list_member_remap_entry_from_hdl(
    int unit,
    lt_mc_list_member_remap_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl,
                               TM_EGR_OBJECT_UPDATE_PROFILE_IDs, &value));
    entry->update_prof_id = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, REMAP_OBJECT_INDEX_0s, &value));
    entry->remap_index_0 = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, REMAP_OBJECT_INDEX_1s, &value));
    entry->remap_index_1 = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, REMAP_OBJECT_INDEX_2s, &value));
    entry->remap_index_2 = (uint32_t)value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT TM_MC_AGG_LIST_MEMBER_REMAP.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mc_list_member_remap_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_mc_list_member_remap_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_AGG_LIST_MEMBER_REMAPs, &ent_hdl));

    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl,
                                   TM_MC_AGG_LIST_MEMBER_REMAP_IDs,
                                   entry->ent_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mc_list_member_remap_entry_from_hdl(unit, entry, ent_hdl));
        break;
    case BCMLT_OPCODE_UPDATE:
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    case BCMLT_OPCODE_INSERT:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mc_list_member_remap_entry_to_hdl(unit, entry, ent_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl,
                                   TM_MC_AGG_LIST_MEMBER_REMAP_IDs,
                                   entry->ent_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
}

exit:
    if (ent_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash of tm_mc_agg_list_member_remap entry.
 *
 * \param [in] unit     Unit number.
 * \param [in] entry    Entry info of bcm_mulitcast_encap_t type.
 * \param [out] hash    Hash value.
 *
 * \retval SHR_E_NONE   No errors.
 * \retval !SHR_E_NONE  Failure.
 */
static int
lt_mc_list_member_remap_hash(int unit, void *entry, uint16_t *hash)
{
    lt_mc_list_member_remap_entry_t remap_entry;

    SHR_FUNC_ENTER(unit);

    sal_memset(&remap_entry, 0, sizeof(remap_entry));
    SHR_IF_ERR_VERBOSE_EXIT
        (mc_encap_to_list_member_remap_entry
            (unit, (bcm_multicast_encap_t *)entry, &remap_entry));

    *hash = shr_crc16(0, (uint8*)&remap_entry, sizeof(remap_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare tm_mc_agg_list_member_remap entry.
 *
 * \param [in] unit       Unit number.
 * \param [in] index      Index of entry to be compared.
 * \param [in] entry      Entry content of bcm_multicast_encap_t.
 * \param [out] result    Compare result. 0 if equal, 1 not equal.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mc_list_member_remap_cmp(int unit, int index, void *entry, int *result)
{
    lt_mc_list_member_remap_entry_t src_entry, dst_entry;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_encap_to_list_member_remap_entry
            (unit, (bcm_multicast_encap_t *)entry, &src_entry));

    sal_memset(&dst_entry, 0, sizeof(dst_entry));
    dst_entry.ent_idx = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_mc_list_member_remap_op(unit, BCMLT_OPCODE_LOOKUP, &dst_entry));

    *result = 1;

    if (src_entry.update_prof_id != dst_entry.update_prof_id) {
        SHR_EXIT();
    }
    if (src_entry.remap_index_0 != dst_entry.remap_index_0) {
        SHR_EXIT();
    }
    if (src_entry.remap_index_1 != dst_entry.remap_index_1) {
        SHR_EXIT();
    }
    if (src_entry.remap_index_2 != dst_entry.remap_index_2) {
        SHR_EXIT();
    }

    *result = 0;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert tm_mc_agg_list_member_remap entry.
 *
 * \param [in] unit     Unit number.
 * \param [in] flags    Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index    Index of entry to be inserted.
 * \param [in] entry    Entry content of bcm_mulicast_encap_t.
 *
 * \retval SHR_E_NONE   No errors.
 * \retval !SHR_E_NONE  Failure.
 */
static int
lt_mc_list_member_remap_insert(int unit, uint32_t flags, int index, void *entry)
{
    lt_mc_list_member_remap_entry_t remap_entry;

    SHR_FUNC_ENTER(unit);

    sal_memset(&remap_entry, 0, sizeof(remap_entry));
    remap_entry.ent_idx = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (mc_encap_to_list_member_remap_entry
            (unit, (bcm_multicast_encap_t *)entry, &remap_entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_mc_list_member_remap_op(unit, BCMLT_OPCODE_INSERT, &remap_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete tm_mc_agg_list_member_remap entry.
 *
 * \param [in] unit     Unit number.
 * \param [in] index    Index of entry to be deleted.
 *
 * \retval SHR_E_NONE   No errors.
 * \retval !SHR_E_NONE  Failure.
 */
static int
lt_mc_list_member_remap_delete(int unit, int index)
{
    lt_mc_list_member_remap_entry_t remap_entry;

    SHR_FUNC_ENTER(unit);

    sal_memset(&remap_entry, 0, sizeof(remap_entry));
    remap_entry.ent_idx = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_mc_list_member_remap_op(unit, BCMLT_OPCODE_DELETE, &remap_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize replicast list member remap info.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
mc_list_member_remap_info_init(int unit)
{
    uint64_t idx_min, idx_max;
    bcmi_ltsw_idx_tbl_lt_info_t lt_info;
    bcmi_ltsw_idx_tbl_user_info_t user_info;
    bcmi_ltsw_idx_tbl_id_t tbl_id =
        BCMI_LTSW_IDX_TBL_ID_TM_MC_AGG_LIST_MEMBER_REMAP;
    bcmi_ltsw_idx_tbl_tm_mc_agg_list_member_remap_user_id user_id =
        BCMI_TM_MC_AGG_LIST_MEMBER_REMAP_USER_ID_MC;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TM_MC_AGG_LIST_MEMBER_REMAPs,
                                       TM_MC_AGG_LIST_MEMBER_REMAP_IDs,
                                       &idx_min, &idx_max));
    REMAP_IDX_MIN(unit) = (uint32_t)idx_min;
    REMAP_IDX_MAX(unit) = (uint32_t)idx_max;

    sal_memset(&lt_info, 0, sizeof(lt_info));
    lt_info.user_cnt  = BCMI_TM_MC_AGG_LIST_MEMBER_REMAP_USER_ID_CNT;
    lt_info.tbl_name  = TM_MC_AGG_LIST_MEMBER_REMAPs;
    lt_info.idx_field = TM_MC_AGG_LIST_MEMBER_REMAP_IDs;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = XFS_MC_TM_AGG_LIST_MEMBER_REMAP_IDX_MIN;
    user_info.idx_max     = REMAP_IDX_MAX(unit);
    user_info.func_hash   = lt_mc_list_member_remap_hash;
    user_info.func_cmp    = lt_mc_list_member_remap_cmp;
    user_info.func_insert = lt_mc_list_member_remap_insert;
    user_info.func_del    = lt_mc_list_member_remap_delete;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit, tbl_id, user_id,
                                    &lt_info, &user_info));

exit:
    if (SHR_FUNC_ERR()) {
        (void)bcmi_ltsw_idx_tbl_unregister(unit, tbl_id, user_id);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert a free block of REPL_HEAD table entries into free array list.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of the first entry of the block.
 * \param [in] size Size of block.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval SHR_E_MEMORY Out of memory.
 */
static int
mc_repl_head_block_insert(int unit, int index, int size)
{
    xfs_mc_repl_head_free_block_t *block_ptr;

    SHR_FUNC_ENTER(unit);

    block_ptr = sal_alloc(sizeof(xfs_mc_repl_head_free_block_t),
                          "xfsMcReplHeadFreeBlock");
    SHR_NULL_CHECK(block_ptr, SHR_E_MEMORY);

    block_ptr->index = index;
    block_ptr->size = size;
    if (size > (MC_INFO(unit)->repl_head_info.array_size - 1)) {
        /* Insert into free list 0 */
        block_ptr->next = REPL_HEAD_FREE_LIST(unit, 0);
        REPL_HEAD_FREE_LIST(unit, 0) = block_ptr;
    } else {
        block_ptr->next = REPL_HEAD_FREE_LIST(unit, size);
        REPL_HEAD_FREE_LIST(unit, size) = block_ptr;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Mark a block of REPL_HEAD table entries as used.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of the first entry of the block.
 * \param [in] size Size of block.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mc_repl_head_block_used_set(int unit, int index, int size)
{
    int i;
    xfs_mc_repl_head_free_block_t *prev_block_ptr;
    xfs_mc_repl_head_free_block_t *block_ptr;
    int block_index, block_size, sub_block_size;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < MC_INFO(unit)->repl_head_info.array_size; i++) {
        block_ptr = REPL_HEAD_FREE_LIST(unit, i);
        prev_block_ptr = NULL;
        while (NULL != block_ptr) {
            block_index = block_ptr->index;
            block_size = block_ptr->size;
            if ((index >= block_index) &&
                ((index + size) <= (block_index + block_size))) {
                /*
                 * This free block contains the block to be marked as used.
                 * Remove this free block from linked list.
                 */
                if (block_ptr == REPL_HEAD_FREE_LIST(unit, i)) {
                    REPL_HEAD_FREE_LIST(unit, i) = block_ptr->next;
                } else {
                    /*
                     * In the following line of code, Coverity thinks the
                     * prev_block_ptr may still be NULL when dereferenced.
                     * This situation will never occur because
                     * if block_ptr is not pointing to the head of the
                     * linked list, prev_block_ptr would not be NULL.
                     */
                    /* coverity[var_deref_op : FALSE] */
                    prev_block_ptr->next = block_ptr->next;
                }
                SHR_FREE(block_ptr);

                /*
                 * This free block contains up to 3 sub-blocks: the sub-block
                 * to be marked as used, and the sub-blocks before and after
                 * it. The sub-blocks before and after the used sub-block
                 * need to be inserted back into the free list array.
                 * Insert the sub-block before the used sub-block back into
                 * the free list array.
                 */
                sub_block_size = index - block_index;
                if (sub_block_size > 0) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mc_repl_head_block_insert(unit,
                                                   block_index,
                                                   sub_block_size));
                }

                /*
                 * Insert the sub-block after the used sub-block back into
                 * the free list array.
                 */
                sub_block_size = (block_index + block_size) - (index + size);
                if (sub_block_size > 0) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mc_repl_head_block_insert(unit,
                                                   index + size,
                                                   sub_block_size));
                }

                SHR_EXIT();
            }

            prev_block_ptr = block_ptr;
            block_ptr = block_ptr->next;
        }
    }

    /* The block to be marked used is not found among the free blocks. */
    SHR_ERR_EXIT(BCM_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover software replication head resource state.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mc_repl_reload(int unit)
{
    int l3mc_id;
    int repl_head_base, repl_head_cnt;
    int rv = SHR_E_NONE;
    uint64_t l3mc_min, l3mc_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TM_MC_GROUPs, TM_MC_GROUP_IDs,
                                       &l3mc_min, &l3mc_max));

    for (l3mc_id = l3mc_min; l3mc_id <= l3mc_max; l3mc_id++) {
        rv = mc_l3_grp_info_get(unit, l3mc_id, &repl_head_base,
                                &repl_head_cnt, NULL, NULL);
        if (rv == SHR_E_NONE) {
            if ((repl_head_base == 0) || (repl_head_cnt == 0)) {
                continue;
            }

            /* Update REPL_HEAD table usage */
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_repl_head_block_used_set(unit,
                                             repl_head_base,
                                             repl_head_cnt));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize a L2 multicast group for default Vlan.
 *
 * \param [in] unit Unit number.
 * \param [in] init If set, means initialization.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mc_def_vlan_grp_set(int unit, bool init)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t *port_id_arr = NULL;
    int max_ports;
    bcm_port_t port;
    bcm_pbmp_t pbmp;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_MC_GROUPs, &eh));

    /* Add L2 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_MC_GROUP_IDs, XFS_MC_DEF_VLAN_GRP_ID));

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    port_id_arr =
        sal_alloc(sizeof(uint64_t) * max_ports, "xfsMcPortIdArr");
    SHR_NULL_CHECK(port_id_arr, SHR_E_MEMORY);
    sal_memset(port_id_arr, 0, sizeof(uint64_t) * max_ports);

    BCM_PBMP_CLEAR(pbmp);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_def_flood_port_get(unit, &pbmp));
    BCM_PBMP_ITER(pbmp, port) {
        if ((port < 0) || (port >= max_ports)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        port_id_arr[port] = 1;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(eh, PORT_IDs, 0, port_id_arr, max_ports));

    if (init) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_INSERT,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    }

exit:
    SHR_FREE(port_id_arr);

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}
/*!
 * \brief Calculate hash of l2 mc group pbmp.
 *
 * \param [in] unit     Unit number.
 * \param [in] entry    Entry info of bcm_mulitcast_encap_t type.
 * \param [out] hash    Hash value.
 *
 * \retval SHR_E_NONE   No errors.
 * \retval !SHR_E_NONE  Failure.
 */
static int
lt_l2_mc_group_hash(int unit, void *entry, uint16_t *hash)
{
    *hash = shr_crc16(0, (uint8*)entry, sizeof(bcm_pbmp_t));
    return SHR_E_NONE;
}

/*!
 * \brief Compare l2 mc group pbmp.
 *
 * \param [in]  unit        Unit number.
 * \param [in]  index      Entry index in the chip to compare.
 * \param [in]  entry      Entry.
 * \param [out] result    Compare result.
 *
 * \retval SHR_E_NONE   No errors.
 * \retval !SHR_E_NONE  Failure.
 */
static int
lt_l2_mc_group_compare(int unit, int index, void *entry, int *result)
{
    int port_cnt = 0, i;
    bcm_port_t port;
    bcm_gport_t *port_arr = NULL;
    bcm_pbmp_t pbmp;
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_multicast_l2_egress_get(unit, index, 0, NULL, NULL, &port_cnt));

    if (port_cnt != 0) {
        port_arr = sal_alloc(sizeof(bcm_gport_t) * port_cnt, "xfsMcPortIdArr");
        SHR_NULL_CHECK(port_arr, SHR_E_MEMORY);
        sal_memset(port_arr, 0, sizeof(bcm_port_t) * port_cnt);
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_multicast_l2_egress_get(unit, index, port_cnt,
                                              port_arr, NULL, &port_cnt));
    }
    BCM_PBMP_CLEAR(pbmp);
    for (i = 0; i < port_cnt; i++) {
        port = BCM_GPORT_MODPORT_PORT_GET(port_arr[i]);
        BCM_PBMP_PORT_ADD(pbmp, port);
    }
    *result = sal_memcmp(entry, (void*)&pbmp, sizeof(bcm_pbmp_t));

exit:
    SHR_FREE(port_arr);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert L2 mc group entry.
 *
 * \param [in] unit     Unit number.
 * \param [in] flags    Operation flags.
 * \param [in] index    Index of entry to be inserted.
 * \param [in] entry    Entry content.
 *
 * \retval SHR_E_NONE   No errors.
 * \retval !SHR_E_NONE  Failure.
 */
static int
lt_l2_mc_group_insert(int unit, uint32_t flags, int index, void *entry)
{
    bcm_port_t *port_arr = NULL;
    uint32_t i, cnt = 0, max_ports;
    bcm_pbmp_t *pbmp = (bcm_pbmp_t *)entry;
    SHR_FUNC_ENTER(unit);

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    port_arr = sal_alloc(sizeof(bcm_port_t) * max_ports, "xfsMcPortIdArr");
    SHR_NULL_CHECK(port_arr, SHR_E_MEMORY);
    sal_memset(port_arr, 0, sizeof(bcm_port_t) * max_ports);
    for (i = 0; i < max_ports; i++) {
        if (BCM_PBMP_MEMBER(*pbmp, i)) {
            port_arr[cnt] = i;
            cnt++;
        }
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_multicast_l2_grp_create(unit, index));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_multicast_l2_grp_update(unit, index, bcmintMcL2GrpMemSet,
                                          port_arr, cnt));
exit:
    SHR_FREE(port_arr);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete L2 mc group entry.
 *
 * \param [in] unit     Unit number.
 * \param [in] index    Index of entry to be inserted.
 *
 * \retval SHR_E_NONE   No errors.
 * \retval !SHR_E_NONE  Failure.
 */
static int
lt_l2_mc_group_delete(int unit, int index)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_multicast_l2_grp_destroy(unit, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief l2 mc resource for vlan default flooding init.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
mc_vlan_default_flooding_init(int unit)
{
    bcmi_ltsw_idx_tbl_lt_info_t lt_info;
    bcmi_ltsw_idx_tbl_user_info_t user_info;
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_L2_MC_GROUP;
    bcmi_ltsw_idx_tbl_l2_mc_group_user_id user_id = BCMI_L2_MC_GROUP_USER_ID_VLAN;
    bcmint_multicast_pub_info_t mc_pub;
    SHR_FUNC_ENTER(unit);

    sal_memset(&lt_info, 0, sizeof(lt_info));
    lt_info.user_cnt  = BCMI_L2_MC_GROUP_USER_ID_CNT;
    lt_info.tbl_name  = L2_MC_GROUPs;
    lt_info.idx_field = L2_MC_GROUP_IDs;

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_multicast_pub_info_get(unit, &mc_pub));

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = mc_pub.l2mc_vlan_flood_min;
    user_info.idx_max     = mc_pub.l2mc_vlan_flood_max;
    user_info.func_hash   = lt_l2_mc_group_hash;
    user_info.func_cmp    = lt_l2_mc_group_compare;
    user_info.func_insert = lt_l2_mc_group_insert;
    user_info.func_del    = lt_l2_mc_group_delete;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit, tbl_id, user_id,
                                    &lt_info, &user_info));

exit:
    if (SHR_FUNC_ERR()) {
        (void)bcmi_ltsw_idx_tbl_unregister(unit, tbl_id, user_id);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear L2 mc group entry.
 *
 * \param [in] unit     Unit number.
 *
 * \retval SHR_E_NONE   No errors.
 * \retval !SHR_E_NONE  Failure.
 */
static int
lt_l2_mc_clear(int unit)
{
    bcmint_multicast_pub_info_t mc_pub;
    int mc_index;
    int bcm_init = bcmi_ltsw_init_state_get(unit);
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_multicast_pub_info_get(unit, &mc_pub));

    /* For multicast module init, keep all VLAN reserved L2MC entries.
     * For code boot/init bcm/rc, clean all L2MC entires.
     * Reserved L2MC entries are managed in VLAN module through MC function.
     */
    if (!bcm_init && (mc_pub.l2mc_vlan_flood_max != 0)) {
        /* Clear only multicast owned l2mc entries. Keep VLAN owned entires. */
        for (mc_index = 0; mc_index <= mc_pub.l2mc_max; mc_index++) {
             (void)lt_l2_mc_group_delete(unit, mc_index);
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, L2_MC_GROUPs));
    }
exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_multicast_init(int unit)
{
    int warm;

    SHR_FUNC_ENTER(unit);

    warm = bcmi_warmboot_get(unit);
    if (!warm) {

        /* Clean up L2 multicast table. */
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_l2_mc_clear(unit));

        /* Clean up L3 multicast table. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TM_MC_GROUPs));

        /* Clean up REPL_LIST table. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TM_MC_PORT_AGG_LISTs));

        /* Initialize the port aggid. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mc_aggid_init(unit));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_repl_head_info_init(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_list_member_remap_info_init(unit));

    if (warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mc_repl_reload(unit));
    }

    if(!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mc_def_vlan_grp_set(unit, TRUE));
    }

exit:
    if (SHR_FUNC_ERR()) {
        (void)xfs_ltsw_multicast_detach(unit);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_detach(int unit)
{
    (void)bcmi_ltsw_idx_tbl_unregister(
              unit,
              BCMI_LTSW_IDX_TBL_ID_TM_MC_AGG_LIST_MEMBER_REMAP,
              BCMI_TM_MC_AGG_LIST_MEMBER_REMAP_USER_ID_MC);
    mc_repl_head_info_deinit(unit);

    return SHR_E_NONE;
}

int
xfs_ltsw_multicast_pub_info_get(
    int unit,
    bcmint_multicast_pub_info_t *mc_pub)
{
    uint64_t l2mc_min, l2mc_max;
    uint64_t l3mc_min, l3mc_max;
    uint32_t l2mc_vlan_flood_num = 0, num_prof;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, L2_MC_GROUPs, L2_MC_GROUP_IDs,
                                       &l2mc_min, &l2mc_max));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, VLAN_ING_MEMBER_PROFILEs, &num_prof));
    l2mc_vlan_flood_num =
        bcmi_ltsw_property_get(unit,
                               BCMI_CPN_VLAN_FLOODING_L2MC_NUM_RESERVED,
                               num_prof);
    if ((l2mc_vlan_flood_num < 0) ||
        (l2mc_vlan_flood_num > l2mc_max)) {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }
    /* L2 MC group 0 is reserved for defaut vlan in TD4. */
    if (l2mc_vlan_flood_num == 0) {
        mc_pub->l2mc_min = 1;
        mc_pub->l2mc_max = l2mc_max;
        mc_pub->l2mc_vlan_flood_min = 0;
        mc_pub->l2mc_vlan_flood_max = 0;
    } else {
        mc_pub->l2mc_min = 1;
        mc_pub->l2mc_max = l2mc_max - l2mc_vlan_flood_num;
        mc_pub->l2mc_vlan_flood_min = mc_pub->l2mc_max + 1;
        mc_pub->l2mc_vlan_flood_max = l2mc_max;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TM_MC_GROUPs, TM_MC_GROUP_IDs,
                                       &l3mc_min, &l3mc_max));
    mc_pub->l3mc_min = l3mc_min;
    mc_pub->l3mc_max = l3mc_max;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, TM_MC_AGG_LIST_MEMBER_REMAPs,
                              &(mc_pub->encap_sz)));
    mc_pub->encap_sz += XFS_MC_LIST_MEMBER_REMAP_OFFSET;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_l2_grp_create(
    int unit,
    uint32_t l2mc_id)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_MC_GROUPs, &eh));

    /* Add L2 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_MC_GROUP_IDs, l2mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_INSERT,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_l2_grp_destroy(
    int unit,
    uint32_t l2mc_id)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_MC_GROUPs, &eh));

    /* Add L2 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_MC_GROUP_IDs, l2mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_l2_grp_update(
    int unit,
    uint32_t l2mc_id,
    bcmint_multicast_l2_grp_op_code_t opcode,
    bcm_port_t *port_array,
    uint32_t port_count)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int       dunit = 0;
    uint64_t *port_id_arr = NULL;
    uint64_t  data = 0;
    int       max_ports, idx;
    bcm_port_t l_port;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_MC_GROUPs, &eh));

    /* Add L2 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_MC_GROUP_IDs, l2mc_id));

    switch (opcode) {
    case bcmintMcL2GrpMemAdd:
        data = 1;
        for (idx = 0; idx < port_count; idx++) {
            /*
             * PORT_ID is an array of bool values for logical ports.
             * So port_array[idx] is the index of array.
             */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(eh, PORT_IDs,
                                             port_array[idx],
                                             &data, 1));
        }
        break;
    case bcmintMcL2GrpMemDel:
        data = 0;
        for (idx = 0; idx < port_count; idx++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(eh, PORT_IDs,
                                             port_array[idx],
                                             &data, 1));
        }
        break;
    case bcmintMcL2GrpMemSet:
        max_ports = bcmi_ltsw_dev_logic_port_num(unit);
        port_id_arr =
            sal_alloc(sizeof(uint64_t) * max_ports, "xfsMcPortIdArr");
        SHR_NULL_CHECK(port_id_arr, SHR_E_MEMORY);
        sal_memset(port_id_arr, 0, sizeof(uint64_t) * max_ports);

        for (idx = 0; idx < port_count; idx++) {
            l_port = port_array[idx];
            if ((l_port < 0) || (l_port >= max_ports)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            port_id_arr[l_port] = 1;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(eh, PORT_IDs,
                                         0, port_id_arr, max_ports));
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
        break;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    SHR_FREE(port_id_arr);

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_l2_egress_get(
    int unit,
    uint32_t l2mc_id,
    int port_size,
    bcm_gport_t *port_array,
    bcm_if_t *encap_id_array,
    int *port_count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_l2_grp_get(unit, l2mc_id, port_size,
                       port_array, encap_id_array, port_count));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_l3_grp_create(
    int unit,
    uint32_t l3mc_id)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_GROUPs, &eh));

    /* Add L3 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, l3mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_INSERT,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_l3_grp_destroy(
    int unit,
    uint32_t l3mc_id)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_GROUPs, &eh));

    /* Add L3 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, l3mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_l3_grp_update(
    int unit,
    uint32_t l3mc_id,
    bcmint_multicast_l3_grp_op_code_t opcode,
    bcm_port_t port,
    bcm_if_t *encap_id_array,
    uint32_t encap_count)
{
    /* Encap id array. */
    int *eid_arr = NULL;
    int  r_cnt = 0;
    uint64_t eid_min = 0, eid_max = 0;

    int  idx = 0;
    int  match = FALSE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TM_MC_PORT_AGG_LISTs,
                                       NUM_AGG_LIST_MEMBERs,
                                       &eid_min, &eid_max));

    switch (opcode) {
    case bcmintMcL3GrpPortEncapAdd:
        /* For add operation, it only has one encap_id. */
        if (encap_id_array[0] == BCM_IF_INVALID) {

            /* -1 means a layer 2 copy. */
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_port_l2_set(unit, l3mc_id, port, 1));

        } else {
            eid_arr = sal_alloc(sizeof(int) * eid_max, "xfsMcEncapIdArr");
            SHR_NULL_CHECK(eid_arr, SHR_E_MEMORY);

            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_port_encap_get(unit, l3mc_id, port,
                                          eid_max, eid_arr, &r_cnt));

            for (idx = 0; idx < r_cnt; idx++) {
                if (eid_arr[idx] == encap_id_array[0]) {
                    /* Encap_id is already added. */
                    SHR_EXIT();
                }
            }
            if (r_cnt == eid_max) {
                SHR_ERR_EXIT(SHR_E_FULL);
            }
            eid_arr[idx] = encap_id_array[0];

            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_port_encap_set(unit, l3mc_id, port,
                                          eid_arr, (r_cnt + 1)));

        }
        break;
    case bcmintMcL3GrpPortEncapDel:
        /* For del operation, it only has one encap_id. */
        if (encap_id_array[0] == BCM_IF_INVALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_port_l2_set(unit, l3mc_id, port, 0));
        } else {
            eid_arr = sal_alloc(sizeof(int) * eid_max, "xfsMcEncapIdArr");
            SHR_NULL_CHECK(eid_arr, SHR_E_MEMORY);

            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_port_encap_get(unit, l3mc_id, port,
                                          eid_max, eid_arr, &r_cnt));

            match = FALSE;
            for (idx = 0; idx < r_cnt; idx++) {
                if (match) {
                    eid_arr[idx - 1] = eid_arr[idx];
                } else {
                    if (eid_arr[idx] == encap_id_array[0]) {
                        match = TRUE;
                    }
                }
            }

            if (match) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_port_encap_set(unit, l3mc_id, port,
                                              eid_arr, (r_cnt - 1)));
            } else {
                SHR_ERR_EXIT(SHR_E_NOT_FOUND);
            }
        }

        break;
    case bcmintMcL3GrpPortEncapDelAll:
        if (port == BCM_PORT_INVALID) {
            /* Delete all replications for the specified mulitcast group ID. */
            int     *l2_memb = NULL;
            int     *l3_memb = NULL;
            uint32_t max_ports = 0;
            int rh_base = 0, rh_cnt = 0;
            bcm_pbmp_t mc_pbmp;
            bcm_port_t port_iter;
            BCM_PBMP_CLEAR(mc_pbmp);

            max_ports = bcmi_ltsw_dev_logic_port_num(unit);
            l2_memb = sal_alloc(sizeof(int) * max_ports, "xfsMcL2MemArr");
            SHR_NULL_CHECK(l2_memb, SHR_E_MEMORY);
            sal_memset(l2_memb, 0, sizeof(int) * max_ports);

            l3_memb = sal_alloc(sizeof(int) * max_ports, "xfsMcL3MemArr");
            SHR_NULL_CHECK(l3_memb, SHR_E_MEMORY);
            sal_memset(l3_memb, 0, sizeof(int) * max_ports);

            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_info_get(unit, l3mc_id, &rh_base, &rh_cnt,
                                    l2_memb, l3_memb));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_ALL, &mc_pbmp));

            BCM_PBMP_ITER(mc_pbmp, port_iter) {
                if (l2_memb[port_iter]) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mc_l3_grp_port_l2_set(unit, l3mc_id, port_iter, 0));
                }
                if (l3_memb[port_iter]) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mc_l3_grp_port_encap_set(unit, l3mc_id, port_iter,
                                                  NULL, 0));
                }
            }
        }
        break;
    case bcmintMcL3GrpPortEncapSet:
        if (encap_count > eid_max) {
            SHR_ERR_EXIT(SHR_E_FULL);
        }
        eid_arr = sal_alloc(sizeof(int) * eid_max, "xfsMcEncapIdArr");
        SHR_NULL_CHECK(eid_arr, SHR_E_MEMORY);
        match = FALSE;
        r_cnt = 0;
        for (idx = 0; idx < encap_count; idx++) {
            if (encap_id_array[idx] == BCM_IF_INVALID) {
                match = TRUE;
                continue;
            }
            eid_arr[r_cnt] = encap_id_array[idx];
            r_cnt++;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (mc_l3_grp_port_l2_set(unit, l3mc_id, port, match));

        SHR_IF_ERR_VERBOSE_EXIT
            (mc_l3_grp_port_encap_set(unit, l3mc_id, port,
                                      eid_arr, r_cnt));

        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
        break;
    }

exit:

    SHR_FREE(eid_arr);

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_l3_egress_get(
    int unit,
    uint32_t l3mc_id,
    int port_size,
    bcm_gport_t *port_array,
    bcm_if_t *encap_id_array,
    int *port_count)
{
    uint32_t  max_ports = 0;
    int       idx = 0;
    int      *l2_memb = NULL;
    int      *l3_memb = NULL;
    bcm_if_t *local_id_arr = NULL;
    uint64_t  eid_min = 0, eid_max = 0;
    int       eid = 0;

    /* Replication head info. */
    int rh_base, rh_cnt;
    int r_cnt = 0;

    bcm_gport_t gport;

    SHR_FUNC_ENTER(unit);

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    l2_memb = sal_alloc(sizeof(int) * max_ports, "xfsMcL2MemArr");
    SHR_NULL_CHECK(l2_memb, SHR_E_MEMORY);
    sal_memset(l2_memb, 0, sizeof(int) * max_ports);

    l3_memb = sal_alloc(sizeof(int) * max_ports, "xfsMcL3MemArr");
    SHR_NULL_CHECK(l3_memb, SHR_E_MEMORY);
    sal_memset(l3_memb, 0, sizeof(int) * max_ports);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_l3_grp_info_get(unit, l3mc_id,
                            &rh_base, &rh_cnt,
                            l2_memb, l3_memb));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TM_MC_PORT_AGG_LISTs,
                                       NUM_AGG_LIST_MEMBERs,
                                       &eid_min, &eid_max));

    local_id_arr = sal_alloc(sizeof(bcm_if_t) * eid_max, "xfsMcLocArr");
    SHR_NULL_CHECK(local_id_arr, SHR_E_MEMORY);
    sal_memset(local_id_arr, 0, sizeof(int) * eid_max);

    *port_count = 0;
    for (idx = 0; idx < max_ports; idx++) {
        /*
         * When port_size is > 0, only port_size ports are returned.
         * When port_size is 0, then just return the actual port_count.
         */
        if ((port_size > 0) && (*port_count >= port_size)) {
            SHR_EXIT();
        }
        if (l3_memb[idx] == 1) {
            if (port_size > 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_port_encap_get(unit,
                                              l3mc_id,
                                              idx,
                                              (port_size - (*port_count)),
                                              local_id_arr, &r_cnt));
            } else {
                 SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_port_encap_get(unit,
                                              l3mc_id,
                                              idx,
                                              0,
                                              local_id_arr, &r_cnt));
            }
            if (port_array != NULL) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_port_gport_get(unit, idx, &gport));
            }
            for (eid = 0; eid < r_cnt; eid++) {
                if (((*port_count + eid) >= port_size) && (port_size != 0)) {
                    break;
                }
                if (encap_id_array != NULL) {
                    encap_id_array[(*port_count) + eid] = local_id_arr[eid];
                }
                if (port_array != NULL) {
                    port_array[(*port_count) + eid] = gport;
                }
            }
            (*port_count) += eid;
        }
    }

    for (idx = 0; idx < max_ports; idx++) {
        /*
         * When port_size is > 0, only port_size ports are returned.
         * When port_size is 0, then just return the actual port_count.
         */
        if ((port_size > 0) && (*port_count >= port_size)) {
            SHR_EXIT();
        }
        if (l2_memb[idx] == 1) {
            if (port_array != NULL) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_port_gport_get(unit,
                                             idx,
                                             &(port_array[*port_count])));
            }
            if (encap_id_array != NULL) {
                encap_id_array[*port_count] = BCM_IF_INVALID;
            }
            *port_count += 1;
        }
    }


exit:

    SHR_FREE(l2_memb);
    SHR_FREE(l3_memb);
    SHR_FREE(local_id_arr);

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_encap_create(
    int unit,
    bcm_multicast_encap_t *mc_encap,
    bcm_if_t *encap_id)
{
    int nh_idx;
    bcmi_ltsw_l3_egr_obj_type_t type;
    int vp, l3_oif = 0;
    bcmi_ltsw_l3_egr_intf_type_t intf_type;
    bcmi_ltsw_idx_tbl_id_t tbl_id =
        BCMI_LTSW_IDX_TBL_ID_TM_MC_AGG_LIST_MEMBER_REMAP;
    bcmi_ltsw_idx_tbl_tm_mc_agg_list_member_remap_user_id user_id =
        BCMI_TM_MC_AGG_LIST_MEMBER_REMAP_USER_ID_MC;
    int remap_idx = 0;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    if ((mc_encap->encap_type <= bcmMulticastEncapTypeInvalid) ||
        (mc_encap->encap_type >= bcmMulticastEncapTypeCount)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (mc_encap->encap_type == bcmMulticastEncapTypeL3Tunnel ||
        mc_encap->encap_type == bcmMulticastEncapTypeL2Tunnel) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_resolve(unit, mc_encap->ul_egress_if,
                                                &nh_idx, &type));
        if (type != BCMI_LTSW_L3_EGR_OBJ_T_UL) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    switch(mc_encap->encap_type) {
    case bcmMulticastEncapTypeL3:
        /* Validate mc_encap->l3_intf. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egr_intf_to_index(unit, mc_encap->l3_intf,
                                            &l3_oif, &intf_type));
        if (mc_encap->l3_intf == bcmi_ltsw_l3_intf_l2tocpu_idx_get(unit)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        *encap_id = mc_encap->l3_intf;
        SHR_EXIT();
    case bcmMulticastEncapTypeL3Tunnel:
        /* Validate mc_encap->l3_intf. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egr_intf_to_index(unit, mc_encap->l3_intf,
                                            &l3_oif, &intf_type));
        if (mc_encap->l3_intf == bcmi_ltsw_l3_intf_l2tocpu_idx_get(unit)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        break;
    case bcmMulticastEncapTypeL2Tunnel:
    case bcmMulticastEncapTypeL2TunnelAccess:
        if (mc_encap->l3_intf != 0) {
            /* Validate mc_encap->l3_intf. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_egr_intf_to_index(unit, mc_encap->l3_intf,
                                                &l3_oif, &intf_type));
            if (mc_encap->l3_intf == bcmi_ltsw_l3_intf_l2tocpu_idx_get(unit)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (BCM_GPORT_IS_MPLS_PORT(mc_encap->port_id)) {
            vp = BCM_GPORT_MPLS_PORT_ID_GET(mc_encap->port_id);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vp_used_get(unit,
                                               vp,
                                               BCMI_LTSW_VP_TYPE_MPLS));
        } else if (BCM_GPORT_IS_FLOW_PORT(mc_encap->port_id)) {
            vp = BCM_GPORT_FLOW_PORT_ID_GET(mc_encap->port_id);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vp_used_get(unit,
                                               vp,
                                               BCMI_LTSW_VP_TYPE_FLOW));
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Check if this entry has already been created. */
    rv = (bcmi_ltsw_idx_tbl_entry_find(unit, 0, tbl_id, user_id,
                                       mc_encap, &remap_idx));
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_NOT_FOUND);

    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_alloc(unit, 0, tbl_id, user_id,
                                           mc_encap, &remap_idx));
    }
    *encap_id = remap_idx + XFS_MC_LIST_MEMBER_REMAP_OFFSET;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_encap_destroy(
    int unit,
    bcm_if_t encap_id)
{
    bcmi_ltsw_idx_tbl_id_t tbl_id =
        BCMI_LTSW_IDX_TBL_ID_TM_MC_AGG_LIST_MEMBER_REMAP;
    bcmi_ltsw_idx_tbl_tm_mc_agg_list_member_remap_user_id user_id =
        BCMI_TM_MC_AGG_LIST_MEMBER_REMAP_USER_ID_MC;
    int remap_idx;

    SHR_FUNC_ENTER(unit);

    if ((encap_id < 0) ||
        (encap_id > (REMAP_IDX_MAX(unit) + XFS_MC_LIST_MEMBER_REMAP_OFFSET))) {
        SHR_ERR_EXIT(SHR_E_BADID);
    }

    if (encap_id < XFS_MC_LIST_MEMBER_REMAP_OFFSET) {
        /* Nothing to do for non-tunnel ipmc. */
        SHR_EXIT();
    }

    remap_idx = encap_id - XFS_MC_LIST_MEMBER_REMAP_OFFSET;
    if ((remap_idx < XFS_MC_TM_AGG_LIST_MEMBER_REMAP_IDX_MIN) ||
        (remap_idx > REMAP_IDX_MAX(unit))) {
        SHR_ERR_EXIT(SHR_E_BADID);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_free(unit, 0, tbl_id, user_id, remap_idx));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_encap_get(
    int unit,
    bcm_if_t encap_id,
    bcm_multicast_encap_t *mc_encap)
{
    int remap_idx;
    lt_mc_list_member_remap_entry_t remap_entry;

    SHR_FUNC_ENTER(unit);

    if ((encap_id < 0) ||
        (encap_id > REMAP_IDX_MAX(unit) + XFS_MC_LIST_MEMBER_REMAP_OFFSET)) {
        SHR_ERR_EXIT(SHR_E_BADID);
    }

    if (encap_id < XFS_MC_LIST_MEMBER_REMAP_OFFSET) {
        /* Non-tunnel IPMC service. */
        mc_encap->encap_type = bcmMulticastEncapTypeL3;
        mc_encap->ul_egress_if = 0;
        mc_encap->l3_intf = encap_id;
        mc_encap->port_id = 0;
        SHR_EXIT();
    }

    remap_idx = encap_id - XFS_MC_LIST_MEMBER_REMAP_OFFSET;
    if ((remap_idx < XFS_MC_TM_AGG_LIST_MEMBER_REMAP_IDX_MIN) ||
        (remap_idx > REMAP_IDX_MAX(unit))) {
        SHR_ERR_EXIT(SHR_E_BADID);
    }

    sal_memset(&remap_entry, 0, sizeof(remap_entry));
    remap_entry.ent_idx = remap_idx;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_mc_list_member_remap_op(unit, BCMLT_OPCODE_LOOKUP, &remap_entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_encap_from_list_member_remap_entry
            (unit, mc_encap, &remap_entry));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_encap_recover(
    int unit,
    bcm_if_t encap_id)
{
    bcm_multicast_encap_t mc_encap;
    uint32 ref_cnt;
    int remap_ent_idx;

    SHR_FUNC_ENTER(unit);

    if (encap_id >= XFS_MC_LIST_MEMBER_REMAP_OFFSET) {
        remap_ent_idx = encap_id - XFS_MC_LIST_MEMBER_REMAP_OFFSET;
    } else {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_get(
            unit,
            BCMI_LTSW_IDX_TBL_ID_TM_MC_AGG_LIST_MEMBER_REMAP,
            BCMI_TM_MC_AGG_LIST_MEMBER_REMAP_USER_ID_MC,
            remap_ent_idx, &ref_cnt));

    if (ref_cnt == 0) {
        sal_memset(&mc_encap, 0, sizeof(mc_encap));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_multicast_encap_get(unit, encap_id, &mc_encap));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_hash_update(
                unit,
                BCMI_LTSW_IDX_TBL_ID_TM_MC_AGG_LIST_MEMBER_REMAP,
                BCMI_TM_MC_AGG_LIST_MEMBER_REMAP_USER_ID_MC,
                &mc_encap, remap_ent_idx));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_increase(
            unit,
            BCMI_LTSW_IDX_TBL_ID_TM_MC_AGG_LIST_MEMBER_REMAP,
            BCMI_TM_MC_AGG_LIST_MEMBER_REMAP_USER_ID_MC,
            remap_ent_idx));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_def_vlan_grp_id_get(
    int unit,
    uint32_t *grp_id)
{
    SHR_FUNC_ENTER(unit);

    if (grp_id == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *grp_id = XFS_MC_DEF_VLAN_GRP_ID;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_def_vlan_grp_update(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_def_vlan_grp_set(unit, FALSE));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_l2_l3_combined_set(
    int unit,
    bool enable)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int      dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L3_MC_CONTROLs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_L3_MC_COMBINED_MODEs, enable));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_l2_l3_combined_get(
    int unit,
    bool *enable)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value = 0;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L3_MC_CONTROLs, &eh));

    rv = bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, L2_L3_MC_COMBINED_MODEs, &value));
        *enable = value;
    } else {
        *enable = FALSE;
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_remap_group_set(
    int unit,
    int mc_index_from,
    int mc_index_to)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int      dunit;
    uint32_t table_num;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, ING_IPMC_REMAP_TABLEs, &table_num));
    if (!table_num) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_IPMC_REMAP_TABLEs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, IPMC_INDEXs, mc_index_from));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, REMAPPED_IPMC_INDEXs, mc_index_to));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_remap_group_get(
    int unit,
    int mc_index_from,
    int *mc_index_to)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    uint64_t value = 0;
    int      dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_IPMC_REMAP_TABLEs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, IPMC_INDEXs, mc_index_from));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, REMAPPED_IPMC_INDEXs, &value));
    *mc_index_to = (int)value;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_multicast_vlan_flood_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_vlan_default_flooding_init(unit));

exit:
    SHR_FUNC_EXIT();
}

