/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/rate.h>

#include <bcm_int/ltsw/xfs/rate.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/port.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_RATE

/*! Storm control LT table. */
#define RATE_SC METER_L2_IIF_STORM_CONTROLs

/*! Storm control map LT table. */
#define RATE_SC_MAP R_STORM_CONTROL_CONFIGs

/*! Storm control map Maximum. */
#define RATE_SC_MAP_MAX 4

/******************************************************************************
 * Private functions
 */


/* Ingress FP meter in pipe unique operating mode. */
static bool meter_ing_pipeunique;

/*!
 * \brief Clear Rate related LT tables.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Clear METER_STORM_CONTROL table. */
    SHR_IF_ERR_EXIT
        (bcmi_lt_clear(unit, RATE_SC));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the rate hw status.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port number.
 * \param [in] sc_id Storm Control Meter Index.
 * \param [out] rate_hw_info Rate HW Information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_status(
    int unit,
    bcm_port_t port,
    uint32_t sc_id,
    bcmint_rate_hw_info_t *hw_info)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    const char *enable_fid = "METER_OFFSET";
    int i = 0;
    uint64_t enable;
    uint32_t r_count;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(hw_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Storm Control meter. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, RATE_SC, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, METER_L2_IIF_STORM_CONTROL_IDs, sc_id));
    if (meter_ing_pipeunique) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, PIPEs, 0));
    }
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (SHR_FAILURE(rv)) {
        if (rv == SHR_E_NOT_FOUND) {
            /*
             * Since SDK6 take register value from a per port register,
             * SDKLT doesn't insert all ports.
             */
            SHR_EXIT();
        }
        SHR_ERR_EXIT(rv);
    }

    /* Read HW enable status. */
    hw_info->enable = FALSE;
    for (i = 0 ; i < RATE_SC_MAP_MAX ; i++) {
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_get(entry, enable_fid,
                                     i,
                                     &enable, 1, &r_count));
        if (enable == 1) {
            hw_info->enable = TRUE;
            break;
        }
    }

exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the L2 IIF rate configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port number.
 * \param [in] sc_id Storm Control Meter Index.
 * \param [in] rate_info Rate Information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_l2_iif_set(
    int unit,
    bcm_port_t port,
    uint32_t sc_id,
    bcmint_rate_info_t *rate_info)
{
    int enable;
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(rate_info, SHR_E_PARAM);

    /* Storm Control is enabled for broadcast packets. */
    if (rate_info->fmask & BCM_RATE_BCAST) {
        enable = 0;
        if (rate_info->flags & BCM_RATE_BCAST) {
            enable = 1;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit,
                                    port,
                                    BCMI_PT_SC_BC_EN,
                                    enable));
    }

    /* Storm Control is enabled for multicast packets. */
    if ((rate_info->fmask) &
        (BCM_RATE_MCAST | BCM_RATE_KNOWN_MCAST)) {
        enable = 0;
        if ((rate_info->flags) &
            (BCM_RATE_MCAST | BCM_RATE_KNOWN_MCAST)) {
            enable = 1;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit,
                                    port,
                                    BCMI_PT_SC_MC_EN,
                                    enable));
    }

    /* Storm Control is enabled for unknown multicast packets. */
    if ((rate_info->fmask) &
        (BCM_RATE_MCAST | BCM_RATE_UNKNOWN_MCAST)) {
        enable = 0;
        if ((rate_info->flags) &
            (BCM_RATE_MCAST | BCM_RATE_UNKNOWN_MCAST)) {
            enable = 1;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit,
                                    port,
                                    BCMI_PT_SC_UMC_EN,
                                    enable));
    }

    /* Storm Control is enabled for unknown unicast packets. */
    if (rate_info->fmask & BCM_RATE_DLF) {
        enable = 0;
        if (rate_info->flags & BCM_RATE_DLF) {
            enable = 1;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit,
                                    port,
                                    BCMI_PT_SC_UUC_EN,
                                    enable));
    }

    /* Storm Control Meter Index. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                port,
                                BCMI_PT_SC_METER_INDEX,
                                sc_id));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the L2 IIF rate configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port number.
 * \param [out] sc_id Storm Control Meter Index.
 * \param [out] rate_info Rate Information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_l2_iif_get(
    int unit,
    bcm_port_t port,
    uint32_t *sc_id,
    bcmint_rate_info_t *rate_info)
{
    int flags = 0;
    int enable, enable1;
    int value;

    SHR_FUNC_ENTER(unit);

    if (rate_info != NULL) {
        /* Get Storm Control meter cfg. */
        if (rate_info->fmask & BCM_RATE_BCAST) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_tab_get(unit,
                                        port,
                                        BCMI_PT_SC_BC_EN,
                                        &value));
            enable = (value == 1) ? TRUE : FALSE ;
            if (enable) {
                flags |= BCM_RATE_BCAST;
            }
        }
        if (rate_info->fmask & BCM_RATE_MCAST) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_tab_get(unit,
                                        port,
                                        BCMI_PT_SC_MC_EN,
                                        &value));
            enable = (value == 1) ? TRUE : FALSE;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_tab_get(unit,
                                        port,
                                        BCMI_PT_SC_UMC_EN,
                                        &value));
            enable1 = (value == 1) ? TRUE : FALSE;
            if (enable | enable1) {
                flags |= BCM_RATE_MCAST;
            }
        }
        if (rate_info->fmask & BCM_RATE_KNOWN_MCAST) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_tab_get(unit,
                                        port,
                                        BCMI_PT_SC_MC_EN,
                                        &value));
            enable = (value == 1) ? TRUE : FALSE;
            if (enable) {
                flags |= BCM_RATE_KNOWN_MCAST;
            }
        }
        if (rate_info->fmask & BCM_RATE_UNKNOWN_MCAST) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_tab_get(unit,
                                        port,
                                        BCMI_PT_SC_UMC_EN,
                                        &value));
            enable = (value == 1) ? TRUE : FALSE;
            if (enable) {
                flags |= BCM_RATE_UNKNOWN_MCAST;
            }
        }
        if (rate_info->fmask & BCM_RATE_DLF) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_tab_get(unit,
                                        port,
                                        BCMI_PT_SC_UUC_EN,
                                        &value));
            enable = (value == 1) ? TRUE : FALSE;
            if (enable) {
                flags |= BCM_RATE_DLF;
            }
        }
        rate_info->flags = flags;
    }

    if (sc_id != NULL) {
        /* Storm Control Meter Index. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_get(unit,
                                    port,
                                    BCMI_PT_SC_METER_INDEX,
                                    &value));
        *sc_id = value;
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the rate configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] rate_info Rate Information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_meter_set(
    int unit,
    uint32_t sc_id,
    bcmint_rate_info_t *rate_info)
{
    int dunit = 0, rv;
    int pipe_num, pipe;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    const char *byte_mode_fids[2] ={
        "METER_RATE_KBPS",
        "BURST_SIZE_KBITS"};
    const char *pkt_mode_fids[2] = {
        "METER_RATE_PPS",
        "BURST_SIZE_PKTS"};
    const char *enable_fid = "METER_OFFSET";
    const char *rate_fid, *burst_fid;
    uint64_t meter_rate = 0, burst_size = 0, enable = 0;
    bcmint_rate_dev_info_t dev_info;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(rate_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (meter_ing_pipeunique) {
        pipe_num = bcmi_ltsw_dev_max_pp_pipe_num(unit);
    } else {
        pipe_num = 1;
    }

    for (pipe = 0; pipe < pipe_num; pipe++) {
        /* Storm Control meter. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate(dunit, RATE_SC, &entry));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, METER_L2_IIF_STORM_CONTROL_IDs, sc_id));
        if (meter_ing_pipeunique) {
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_add(entry, PIPEs, pipe));
        }

        /* Force to insert entry. */
        rv = bcmlt_entry_commit(entry,
                                BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL);
        if (rv != SHR_E_NONE &&
            rv != SHR_E_EXISTS) {
            SHR_ERR_EXIT(rv);
        }

        /* Set the update data. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, BYTE_MODEs, rate_info->byte_mode));

        SHR_IF_ERR_EXIT
            (xfs_ltsw_rate_dev_get(unit, &dev_info));

        if (dev_info.map_idx[LT_RATE_MAP_BCAST] == rate_info->map_idx) {
            if (rate_info->flags & BCM_RATE_BCAST) {
                enable = 1;
            }
        } else if (dev_info.map_idx[LT_RATE_MAP_KNOWN_L2MC] == rate_info->map_idx) {
            if (rate_info->flags & (BCM_RATE_MCAST | BCM_RATE_KNOWN_MCAST)) {
                enable = 1;
            }
        } else if (dev_info.map_idx[LT_RATE_MAP_UNKNOWN_L2MC] == rate_info->map_idx) {
            if (rate_info->flags & (BCM_RATE_MCAST | BCM_RATE_UNKNOWN_MCAST)) {
                enable = 1;
            }
        } else if (dev_info.map_idx[LT_RATE_MAP_DLF] == rate_info->map_idx) {
            if (rate_info->flags & BCM_RATE_DLF) {
                enable = 1;
            }
        }

        if (enable) {
            if (rate_info->byte_mode) {
                rate_fid = byte_mode_fids[0];
                burst_fid = byte_mode_fids[1];

                meter_rate = rate_info->meter_kbps;
                burst_size = rate_info->burst_kbits;
            } else {
                rate_fid = pkt_mode_fids[0];
                burst_fid = pkt_mode_fids[1];

                meter_rate = rate_info->meter_pps;
                if (!rate_info->burst_pkts) {
                    burst_size = meter_rate;
                } else {
                    burst_size = rate_info->burst_pkts;
                }
            }
            if (meter_rate != 0) {
                SHR_IF_ERR_EXIT
                    (bcmlt_entry_field_array_add(entry, rate_fid,
                                                 rate_info->map_idx,
                                                 &meter_rate, 1));
            }
            if (burst_size != 0) {
                SHR_IF_ERR_EXIT
                    (bcmlt_entry_field_array_add(entry, burst_fid,
                                                 rate_info->map_idx,
                                                 &burst_size, 1));
            }
        }

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_add(entry, enable_fid,
                                         rate_info->map_idx,
                                         &enable, 1));
        /* Update the entry. */
        rv = bcmlt_entry_commit(entry,
                                BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL);
        if (SHR_FAILURE(rv)) {
            SHR_ERR_EXIT(rv);
        }

        (void)bcmlt_entry_free(entry);
    }

exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the rate configuration.
 *
 * \param [in] unit Unit Number.
 * \param [out] rate_info Rate Information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_meter_get(
    int unit,
    uint32_t sc_id,
    bcmint_rate_info_t *rate_info)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    const char *byte_mode_fids[2] ={
        "METER_RATE_KBPS_OPER",
        "BURST_SIZE_KBITS_OPER"};
    const char *pkt_mode_fids[2] = {
        "METER_RATE_PPS_OPER",
        "BURST_SIZE_PKTS_OPER"};
    const char *rate_fid;
    const char *burst_fid;
    uint64_t meter_rate = 0, burst_size = 0;
    bool byte_mode;
    uint64_t value;
    uint32_t r_count;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(rate_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Storm Control meter. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, RATE_SC, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, METER_L2_IIF_STORM_CONTROL_IDs, sc_id));
    if (meter_ing_pipeunique) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, PIPEs, 0));
    }
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);

    if (SHR_FAILURE(rv)) {
        if (rv == SHR_E_NOT_FOUND) {
            /*
             * Since SDK6 take register value from a per port register,
             * SDKLT doesn't insert all ports.
             */
            SHR_EXIT();
        }
        SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry, BYTE_MODEs, &value));
    byte_mode = (value == 1) ? TRUE : FALSE ;
    if (rate_info->byte_mode != byte_mode) {
        SHR_EXIT();
    }

    if (rate_info->byte_mode) {
        rate_fid = byte_mode_fids[0];
        burst_fid = byte_mode_fids[1];

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_get(entry, rate_fid,
                                         rate_info->map_idx,
                                         &meter_rate, 1, &r_count));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_get(entry, burst_fid,
                                         rate_info->map_idx,
                                         &burst_size, 1, &r_count));

        rate_info->meter_kbps = meter_rate;
        rate_info->burst_kbits = burst_size;
    } else {
        rate_fid = pkt_mode_fids[0];
        burst_fid = pkt_mode_fids[1];

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_get(entry, rate_fid,
                                         rate_info->map_idx,
                                         &meter_rate, 1, &r_count));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_get(entry, burst_fid,
                                         rate_info->map_idx,
                                         &burst_size, 1, &r_count));

        rate_info->meter_pps = meter_rate;
        rate_info->burst_pkts = burst_size;
    }
exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the rate device configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] dev_info Device Configuration.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_dev_set(
    int unit,
    bcmint_rate_dev_info_t *dev_info)
{
    int dunit = 0, rv;
    uint64_t value;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(dev_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, RATE_SC_MAP, &entry));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Set the data. */
    if (dev_info->map_supported[LT_RATE_MAP_BCAST]) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, BCAST_SECTION_SELs,
                                   dev_info->map_idx[LT_RATE_MAP_BCAST]));
    }

    if (dev_info->map_supported[LT_RATE_MAP_KNOWN_L2MC] ||
        dev_info->map_supported[LT_RATE_MAP_KNOWN_IPMC]) {
        /* For LT_RATE_MAP_KNOWN_L2MC and LT_RATE_MAP_KNOWN_IPMC. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, KNOWN_MCAST_SECTION_SELs,
                                   dev_info->map_idx[LT_RATE_MAP_KNOWN_L2MC]));
    }

    if (dev_info->map_supported[LT_RATE_MAP_UNKNOWN_L2MC] ||
        dev_info->map_supported[LT_RATE_MAP_UNKNOWN_IPMC]) {
        /* For LT_RATE_MAP_UNKNOWN_L2MC and LT_RATE_MAP_UNKNOWN_IPMC. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(
                entry, UNKNOWN_MCAST_SECTION_SELs,
                dev_info->map_idx[LT_RATE_MAP_UNKNOWN_L2MC]));
    }

    if (dev_info->map_supported[LT_RATE_MAP_DLF]) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, UNKNOWN_UCAST_SECTION_SELs,
                                   dev_info->map_idx[LT_RATE_MAP_DLF]));
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

    (void)bcmlt_entry_free(entry);

    /* Get FP Per Pipe mode. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, METER_FP_CONFIGs, &entry));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry, METER_ING_OPERMODE_PIPEUNIQUEs, &value));
    meter_ing_pipeunique = (value == 1) ? TRUE : FALSE ;

exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();

}

/*!
 * \brief Get the rate device configuration.
 *
 * \param [in] unit Unit Number.
 * \param [out] dev_info Device Configuration.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_dev_get(
    int unit,
    bcmint_rate_dev_info_t *dev_info)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    uint64_t idx;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(dev_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Get storm control LT status */
    rv =  bcmlt_entry_allocate(dunit, RATE_SC_MAP, &entry);
    if (rv == SHR_E_PARAM) {
        /* The LT doesn't exist, not support storm control */
        for (idx = LT_RATE_MAP_BCAST;
             idx < LT_RATE_MAP_NUM;
             idx++) {
            dev_info->map_supported[idx] = FALSE;
        }
        SHR_EXIT();
    } else if (rv == SHR_E_NONE) {
        /* The LT exist, support storm control and check each packet types */

        /* Force to insert entry. */
        rv = bcmlt_entry_commit(entry,
                                BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL);
        if (rv != SHR_E_NONE &&
            rv != SHR_E_EXISTS) {
            SHR_ERR_EXIT(rv);
        }

        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry,
                                BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));

        rv = bcmlt_entry_field_get(entry, BCAST_SECTION_SELs, &idx);
        if (rv == SHR_E_NONE) {
            dev_info->map_idx[LT_RATE_MAP_BCAST] = idx;
            dev_info->map_supported[LT_RATE_MAP_BCAST] = TRUE;
        }

        /* For LT_RATE_MAP_KNOWN_L2MC and LT_RATE_MAP_KNOWN_IPMC. */
        rv = bcmlt_entry_field_get(entry, KNOWN_MCAST_SECTION_SELs, &idx);
        if (rv == SHR_E_NONE) {
            dev_info->map_idx[LT_RATE_MAP_KNOWN_L2MC] = idx;
            dev_info->map_idx[LT_RATE_MAP_KNOWN_IPMC] = idx;
            dev_info->map_supported[LT_RATE_MAP_KNOWN_L2MC] = TRUE;
            dev_info->map_supported[LT_RATE_MAP_KNOWN_IPMC] = TRUE;
        }

        /* For LT_RATE_MAP_UNKNOWN_L2MC and LT_RATE_MAP_UNKNOWN_IPMC. */
        rv = bcmlt_entry_field_get(entry, UNKNOWN_MCAST_SECTION_SELs, &idx);
        if (rv == SHR_E_NONE) {
            dev_info->map_idx[LT_RATE_MAP_UNKNOWN_L2MC] = idx;
            dev_info->map_idx[LT_RATE_MAP_UNKNOWN_IPMC] = idx;
            dev_info->map_supported[LT_RATE_MAP_UNKNOWN_L2MC] = TRUE;
            dev_info->map_supported[LT_RATE_MAP_UNKNOWN_IPMC] = TRUE;
        }

        rv = bcmlt_entry_field_get(entry, UNKNOWN_UCAST_SECTION_SELs, &idx);
        if (rv == SHR_E_NONE) {
            dev_info->map_idx[LT_RATE_MAP_DLF] = idx;
            dev_info->map_supported[LT_RATE_MAP_DLF] = TRUE;
        }
    }

exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set Meter/Rate control with overhead on wire accounted for per packet.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] value Number of bytes to adjust.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_meter_adjust_set(
    int unit,
    bcm_port_t port,
    int value)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    uint64_t val;

    SHR_FUNC_ENTER(unit);

    if (value < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, METER_FP_CONTROLs, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Set the data. */
    val = value;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, BYTE_COUNT_INGs, val));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Meter/Rate control with overhead on wire accounted for per packet.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] value Number of bytes to adjust.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_meter_adjust_get(
    int unit,
    bcm_port_t port,
    int *value)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    uint64_t val;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(value, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, METER_FP_CONTROLs, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Get the data. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry, BYTE_COUNT_INGs, &val));
    *value = val;

exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Set Meter/Rate control with overhead on wire accounted for per packet
 * for EFP.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] value Number of bytes to adjust.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_shaper_adjust_set(
    int unit,
    bcm_port_t port,
    int value)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    uint64_t val;

    SHR_FUNC_ENTER(unit);

    if (value < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TM_SHAPER_PORTs, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Set the data. */
    val = value;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, INTER_FRAME_GAP_ENCAPs, 1));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, INTER_FRAME_GAP_BYTEs, val));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Meter/Rate control with overhead on wire accounted for per packet
 * for EFP.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] value Number of bytes to adjust.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_rate_shaper_adjust_get(
    int unit,
    bcm_port_t port,
    int *value)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    uint64_t val;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(value, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TM_SHAPER_PORTs, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Get the data. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry, INTER_FRAME_GAP_BYTEs, &val));
    *value = val;

exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_rate_status(
    int unit,
    bcm_port_t port,
    uint32_t sc_id,
    bcmint_rate_hw_info_t *hw_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_status(unit, port, sc_id, hw_info));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_rate_l2_iif_set(
    int unit,
    bcm_port_t port,
    uint32_t sc_id,
    bcmint_rate_info_t *rate_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_l2_iif_set(unit, port, sc_id, rate_info));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_rate_l2_iif_get(
    int unit,
    bcm_port_t port,
    uint32_t *sc_id,
    bcmint_rate_info_t *rate_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_l2_iif_get(unit, port, sc_id, rate_info));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_rate_meter_set(
    int unit,
    uint32_t sc_id,
    bcmint_rate_info_t *rate_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_meter_set(unit, sc_id, rate_info));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_rate_meter_get(
    int unit,
    uint32_t sc_id,
    bcmint_rate_info_t *rate_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_meter_get(unit, sc_id, rate_info));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_rate_clear(int unit)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_clear(unit));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_rate_dev_set(
    int unit,
    bcmint_rate_dev_info_t *dev_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_dev_set(unit, dev_info));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_rate_dev_get(
    int unit,
    bcmint_rate_dev_info_t *dev_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_dev_get(unit, dev_info));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_rate_meter_adjust_set(
    int unit,
    bcm_port_t port,
    int value)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_meter_adjust_set(unit, port, value));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_rate_meter_adjust_get(
    int unit,
    bcm_port_t port,
    int *value)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_meter_adjust_get(unit, port, value));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_rate_shaper_adjust_set(
    int unit,
    bcm_port_t port,
    int value)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_shaper_adjust_set(unit, port, value));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_rate_shaper_adjust_get(
    int unit,
    bcm_port_t port,
    int *value)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xfs_rate_shaper_adjust_get(unit, port, value));
exit:
    SHR_FUNC_EXIT();
}

