/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>

#include <bcm_int/ltsw/xfs/dlb.h>
#include <bcm_int/ltsw/dlb_int.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_DLB

/******************************************************************************
 * Private functions
 */


/*!
 * \brief Assignment mode encode to HW.
 *
 * \param [in] unit Unit Number.
 * \param [in] assignment_mode Assignment Mode.
 * \param [out] assignment_mode_symbol Assignment Mode LT symbol.
 *
 * \retval SHE_E_NONE No errors.
 * \retval SHR_E_PARAM Invalid Parameter.
 */
static int
ltsw_xfs_dlb_assignment_mode_encode(
    int unit,
    int assignment_mode,
    const char **assignment_mode_symbol)
{
    const char *local_assignment_mode_symbol;

    SHR_FUNC_ENTER(unit);

    switch (assignment_mode) {
        case BCMI_LTSW_DLB_ASSIGNMENT_MODE_TIME_ELIGIBILITY:
            local_assignment_mode_symbol = TIME_ELIGIBILITYs;
            break;
        case BCMI_LTSW_DLB_ASSIGNMENT_MODE_FIXED:
            local_assignment_mode_symbol = FIXEDs;
            break;
        case BCMI_LTSW_DLB_ASSIGNMENT_MODE_PACKET_SPRAY:
            local_assignment_mode_symbol = PACKET_SPRAYs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (assignment_mode_symbol) {
        *assignment_mode_symbol = local_assignment_mode_symbol;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Assignment mode decode from HW.
 *
 * \param [in] unit Unit Number.
 * \param [in] assignment_mode_symbol Assignment Mode LT symbol.
 * \param [out] assignment_mode Assignment Mode.
 *
 * \retval SHE_E_NONE No errors.
 * \retval SHR_E_PARAM Invalid Parameter.
 */
static int
ltsw_xfs_dlb_assignment_mode_decode(
    int unit,
    const char *assignment_mode_symbol,
    int *assignment_mode)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(assignment_mode_symbol, SHR_E_PARAM);
    SHR_NULL_CHECK(assignment_mode, SHR_E_PARAM);

    if (sal_strcmp(assignment_mode_symbol, TIME_ELIGIBILITYs) == 0) {
        *assignment_mode = BCMI_LTSW_DLB_ASSIGNMENT_MODE_TIME_ELIGIBILITY;
    } else if (sal_strcmp(assignment_mode_symbol, FIXEDs) == 0) {
        *assignment_mode = BCMI_LTSW_DLB_ASSIGNMENT_MODE_FIXED;
    } else if (sal_strcmp(assignment_mode_symbol, PACKET_SPRAYs) == 0) {
        *assignment_mode = BCMI_LTSW_DLB_ASSIGNMENT_MODE_PACKET_SPRAY;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Flow size encode to HW.
 *
 * \param [in] unit Unit Number.
 * \param [in] flow_size Flow Size.
 * \param [out] flow_size_symbol Flow Size LT symbol.
 *
 * \retval SHE_E_NONE No errors.
 * \retval SHR_E_PARAM Invalid Parameter.
 */
static int
ltsw_xfs_dlb_flow_size_encode(
    int unit,
    int flow_size,
    const char **flow_size_symbol)
{
    const char *local_flow_size_symbol;

    SHR_FUNC_ENTER(unit);

    switch (flow_size) {
        case 0:
            local_flow_size_symbol = FLOW_SET_SIZE_0s;
            break;
        case 256:
            local_flow_size_symbol = FLOW_SET_SIZE_256s;
            break;
        case 512:
            local_flow_size_symbol = FLOW_SET_SIZE_512s;
            break;
        case 1024:
            local_flow_size_symbol = FLOW_SET_SIZE_1024s;
            break;
        case 2048:
            local_flow_size_symbol = FLOW_SET_SIZE_2048s;
            break;
        case 4096:
            local_flow_size_symbol = FLOW_SET_SIZE_4096s;
            break;
        case 8192:
            local_flow_size_symbol = FLOW_SET_SIZE_8192s;
            break;
        case 16384:
            local_flow_size_symbol = FLOW_SET_SIZE_16384s;
            break;
        case 32768:
            local_flow_size_symbol = FLOW_SET_SIZE_32768s;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (flow_size_symbol) {
        *flow_size_symbol = local_flow_size_symbol;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Flow size decode from HW.
 *
 * \param [in] unit Unit Number.
 * \param [in] flow_size_symbol Flow Size LT symbol.
 * \param [out] flow_size Flow Size.
 *
 * \retval SHE_E_NONE No errors.
 * \retval SHR_E_PARAM Invalid Parameter.
 */
static int
ltsw_xfs_dlb_flow_size_decode(
    int unit,
    const char *flow_size_symbol,
    int *flow_size)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(flow_size_symbol, SHR_E_PARAM);
    SHR_NULL_CHECK(flow_size, SHR_E_PARAM);

    if (sal_strcmp(flow_size_symbol, FLOW_SET_SIZE_0s) == 0) {
        *flow_size = 0;
    } else if (sal_strcmp(flow_size_symbol, FLOW_SET_SIZE_256s) == 0) {
        *flow_size = 256;
    } else if (sal_strcmp(flow_size_symbol, FLOW_SET_SIZE_512s) == 0) {
        *flow_size = 512;
    } else if (sal_strcmp(flow_size_symbol, FLOW_SET_SIZE_1024s) == 0) {
        *flow_size = 1024;
    } else if (sal_strcmp(flow_size_symbol, FLOW_SET_SIZE_2048s) == 0) {
        *flow_size = 2048;
    } else if (sal_strcmp(flow_size_symbol, FLOW_SET_SIZE_4096s) == 0) {
        *flow_size = 4096;
    } else if (sal_strcmp(flow_size_symbol, FLOW_SET_SIZE_8192s) == 0) {
        *flow_size = 8192;
    } else if (sal_strcmp(flow_size_symbol, FLOW_SET_SIZE_16384s) == 0) {
        *flow_size = 16384;
    } else if (sal_strcmp(flow_size_symbol, FLOW_SET_SIZE_32768s) == 0) {
        *flow_size = 32768;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Flow size encode to HW.
 *
 * \param [in] unit Unit Number.
 * \param [in] scaling_factor Scaling factor.
 * \param [out] scaling_factor_symbol Scaling factor LT symbol.
 *
 * \retval SHE_E_NONE No errors.
 * \retval SHR_E_PARAM Invalid Parameter.
 */
static int
ltsw_xfs_dlb_scaling_factor_encode(
    int unit,
    int scaling_factor,
    const char **scaling_factor_symbol)
{
    const char *local_scaling_factor_symbol;

    SHR_FUNC_ENTER(unit);

    switch (scaling_factor) {
        case 10:
            local_scaling_factor_symbol = SCALING_FACTOR_10Gs;
            break;
        case 25:
            local_scaling_factor_symbol = SCALING_FACTOR_25Gs;
            break;
        case 40:
            local_scaling_factor_symbol = SCALING_FACTOR_40Gs;
            break;
        case 50:
            local_scaling_factor_symbol = SCALING_FACTOR_50Gs;
            break;
        case 75:
            local_scaling_factor_symbol = SCALING_FACTOR_75Gs;
            break;
        case 100:
            local_scaling_factor_symbol = SCALING_FACTOR_100Gs;
            break;
        case 200:
            local_scaling_factor_symbol = SCALING_FACTOR_200Gs;
            break;
        case 400:
            local_scaling_factor_symbol = SCALING_FACTOR_400Gs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (scaling_factor_symbol) {
        *scaling_factor_symbol = local_scaling_factor_symbol;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Scaling factor decode from HW.
 *
 * \param [in] unit Unit Number.
 * \param [in] scaling_factor_symbol Scaling factor LT symbol.
 * \param [out] scaling_factor Scaling factor.
 *
 * \retval SHE_E_NONE No errors.
 * \retval SHR_E_PARAM Invalid Parameter.
 */
static int
ltsw_xfs_dlb_scaling_factor_decode(
    int unit,
    const char *scaling_factor_symbol,
    int *scaling_factor)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(scaling_factor_symbol, SHR_E_PARAM);
    SHR_NULL_CHECK(scaling_factor, SHR_E_PARAM);

    if (sal_strcmp(scaling_factor_symbol, SCALING_FACTOR_10Gs) == 0) {
        *scaling_factor = 10;
    } else if (sal_strcmp(scaling_factor_symbol, SCALING_FACTOR_25Gs) == 0) {
        *scaling_factor = 25;
    } else if (sal_strcmp(scaling_factor_symbol, SCALING_FACTOR_40Gs) == 0) {
        *scaling_factor = 40;
    } else if (sal_strcmp(scaling_factor_symbol, SCALING_FACTOR_50Gs) == 0) {
        *scaling_factor = 50;
    } else if (sal_strcmp(scaling_factor_symbol, SCALING_FACTOR_75Gs) == 0) {
        *scaling_factor = 75;
    } else if (sal_strcmp(scaling_factor_symbol, SCALING_FACTOR_100Gs) == 0) {
        *scaling_factor = 100;
    } else if (sal_strcmp(scaling_factor_symbol, SCALING_FACTOR_200Gs) == 0) {
        *scaling_factor = 200;
    } else if (sal_strcmp(scaling_factor_symbol, SCALING_FACTOR_400Gs) == 0) {
        *scaling_factor = 400;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief clear the dlb TRUNK hw tables.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_clear_trunk(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_TRUNKs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_TRUNK_CONTROLs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_TRUNK_PORT_CONTROLs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_TRUNK_MONITORs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_TRUNK_STATSs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_TRUNK_PORT_STATUSs));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief clear the dlb ECMP hw tables.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_clear_ecmp(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_ECMPs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_ECMP_CONTROLs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_ECMP_PORT_CONTROLs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_ECMP_MONITORs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_ECMP_STATSs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_ECMP_PORT_STATUSs));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the dlb hw tables.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_hw_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_PORT_CONTROLs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_QUALITY_MAPs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_CONTROLs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, DLB_QUANTIZATION_THRESHOLDs));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate configurations of a DLB group.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_config DLB configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_config_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_config_t *dlb_config)
{
    uint64_t min, max;
    const char *lt_name = NULL;
    bcmi_ltsw_dlb_alternate_config_t *alt_config;
    uint64_t cfg_value;

    SHR_FUNC_ENTER(unit);

    if (dlb_config->alternate_num_paths != 0) {
        if (dlb_type == bcmi_dlb_type_fp_trunk ||
            dlb_type == bcmi_dlb_type_fabric_trunk) {
            lt_name = DLB_TRUNKs;
        } else if (dlb_type == bcmi_dlb_type_ecmp) {
            lt_name = DLB_ECMPs;
        }

        alt_config = &dlb_config->alternate_config;

        cfg_value = alt_config->alternate_path_bias;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, lt_name, ALTERNATE_PATH_BIASs,
                                           &min, &max));
        if (cfg_value < min || cfg_value > max) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        cfg_value = alt_config->alternate_path_cost;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, lt_name, ALTERNATE_PATH_COSTs,
                                           &min, &max));
        if (cfg_value < min || cfg_value > max) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        cfg_value = alt_config->primary_path_threshold;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, lt_name, PRIMARY_PATH_THRESHOLDs,
                                           &min, &max));
        if (cfg_value < min || cfg_value > max) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set configurations of a DLB group.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [in] dlb_config DLB configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_config_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_config_t *dlb_config)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    const char *lt_name = NULL;
    uint64_t value;
    const char *symbol;
    int dunit, update, i;
    int old_num_paths, old_alternate_num_paths;
    bcmi_ltsw_dlb_alternate_config_t *alt_config;
    uint32_t primary_path_threshold;
    uint32_t alternate_path_cost;
    uint32_t alternate_path_bias;
    bcmlt_opcode_t opcode;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNKs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMPs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = dlb_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    update = rv == SHR_E_NOT_FOUND ? 0 : 1;

    if (update) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, NUM_PATHSs, &value));
        old_num_paths = value & 0xffffffff;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, ALTERNATE_NUM_PATHSs, &value));
        old_alternate_num_paths = value & 0xffffffff;
        opcode = BCMLT_OPCODE_UPDATE;
    } else {
        old_num_paths = 0;
        old_alternate_num_paths = 0;
        opcode = BCMLT_OPCODE_INSERT;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_clear(lte_hdl));

    value = dlb_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));

    value = dlb_config->inactivity_time;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, INACTIVITY_TIMEs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_assignment_mode_encode(unit, dlb_config->assignment_mode,
                                             &symbol));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(lte_hdl, ASSIGNMENT_MODEs, symbol));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_flow_size_encode(unit, dlb_config->flowset_size,
                                       &symbol));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(lte_hdl, FLOW_SET_SIZEs, symbol));

    value = dlb_config->num_paths;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, NUM_PATHSs, value));

    if ((dlb_config->num_paths >= 0) &&
        (dlb_config->num_paths < old_num_paths)) {
        for (i = dlb_config->num_paths; i < old_num_paths; i++) {
            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, PORT_IDs,
                                             i, &value, 1));
            if (dlb_type == bcmi_dlb_type_ecmp) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl, NHOP_IDs,
                                                 i, &value, 1));
            }
        }
    }

    if (dlb_config->num_paths > 0 && dlb_config->member != NULL) {
        for (i = 0; i < dlb_config->num_paths; i++) {
            value = dlb_config->member[i].port_id;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, PORT_IDs,
                                             i, &value, 1));
            if (dlb_type == bcmi_dlb_type_ecmp) {
                value = dlb_config->member[i].nhop_id;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl, NHOP_IDs,
                                                 i, &value, 1));
            }
        }
    }

    if (dlb_config->alternate_num_paths > 0) {
        alt_config = &dlb_config->alternate_config;
        primary_path_threshold = alt_config->primary_path_threshold;
        alternate_path_cost = alt_config->alternate_path_cost;
        alternate_path_bias = alt_config->alternate_path_bias;
    } else {
        primary_path_threshold = 0;
        alternate_path_cost = 0;
        alternate_path_bias = 0;
    }

    value = primary_path_threshold;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PRIMARY_PATH_THRESHOLDs, value));

    value = alternate_path_cost;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, ALTERNATE_PATH_COSTs, value));

    value = alternate_path_bias;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, ALTERNATE_PATH_BIASs, value));

    value = dlb_config->alternate_num_paths;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, ALTERNATE_NUM_PATHSs, value));

    if ((dlb_config->alternate_num_paths >= 0) &&
        (dlb_config->alternate_num_paths < old_alternate_num_paths)) {
        for (i = dlb_config->alternate_num_paths;
             i < old_alternate_num_paths; i++) {
            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, ALTERNATE_PORT_IDs,
                                             i, &value, 1));
            if (dlb_type == bcmi_dlb_type_ecmp) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl, ALTERNATE_NHOP_IDs,
                                                 i, &value, 1));
            }
        }
    }

    if (dlb_config->alternate_num_paths > 0 &&
        dlb_config->alternate_member != NULL) {
        for (i = 0; i < dlb_config->alternate_num_paths; i++) {
            value = dlb_config->alternate_member[i].port_id;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, ALTERNATE_PORT_IDs,
                                             i, &value, 1));
            if (dlb_type == bcmi_dlb_type_ecmp) {
                value = dlb_config->alternate_member[i].nhop_id;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl, ALTERNATE_NHOP_IDs,
                                                 i, &value, 1));
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, opcode, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get configurations of a DLB group.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [out] dlb_config DLB configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_config_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_config_t *dlb_config)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    uint64_t value;
    const char *symbol;
    int dunit, i;
    bcmi_ltsw_dlb_alternate_config_t *alt_config;
    uint32_t count = 0;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNKs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMPs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = dlb_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    value = dlb_config->inactivity_time;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, INACTIVITY_TIMEs, &value));
    dlb_config->inactivity_time = value & 0xffffffff;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(lte_hdl, ASSIGNMENT_MODEs, &symbol));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_assignment_mode_decode(unit, symbol,
                                             &dlb_config->assignment_mode));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(lte_hdl, FLOW_SET_SIZEs, &symbol));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_flow_size_decode(unit, symbol,
                                       &dlb_config->flowset_size));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, NUM_PATHSs, &value));
    dlb_config->num_paths = value & 0xffffffff;

    if (dlb_config->max_num_paths > 0 && dlb_config->member != NULL) {
        for (i = 0; i < dlb_config->num_paths; i++) {
            if (i >= dlb_config->max_num_paths) {
                break;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(lte_hdl, PORT_IDs, i,
                                             &value, 1, &count));
            dlb_config->member[i].port_id = value & 0xffffffff;

            if (dlb_type == bcmi_dlb_type_ecmp) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_get(lte_hdl, NHOP_IDs, i,
                                                 &value, 1, &count));
                dlb_config->member[i].nhop_id = value & 0xffffffff;
            }
        }
    }

    alt_config = &dlb_config->alternate_config;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, PRIMARY_PATH_THRESHOLDs, &value));
    alt_config->primary_path_threshold = value & 0xffffffff;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, ALTERNATE_PATH_COSTs, &value));
    alt_config->alternate_path_cost = value & 0xffffffff;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, ALTERNATE_PATH_BIASs, &value));
    alt_config->alternate_path_bias = value & 0xffffffff;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, ALTERNATE_NUM_PATHSs, &value));
    dlb_config->alternate_num_paths = value & 0xffffffff;

    if (dlb_config->max_alternate_num_paths > 0 &&
        dlb_config->alternate_member != NULL) {
        for (i = 0; i < dlb_config->alternate_num_paths; i++) {
            if (i >= dlb_config->max_alternate_num_paths) {
                break;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(lte_hdl, ALTERNATE_PORT_IDs, i,
                                             &value, 1, &count));
            dlb_config->alternate_member[i].port_id = value & 0xffffffff;

            if (dlb_type == bcmi_dlb_type_ecmp) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_get(lte_hdl, ALTERNATE_NHOP_IDs, i,
                                                 &value, 1, &count));
                dlb_config->alternate_member[i].nhop_id= value & 0xffffffff;
            }
        }
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear configurations of a DLB group.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_config_clear(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    uint64_t value;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNKs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMPs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = dlb_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the DLB monitoring configurations.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [in] monitor DLB monitoring configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_monitor_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_monitor_t *monitor)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    uint64_t value;
    int dunit, rv;
    uint64_t field_max, max_sample_threshold;
    uint64_t sample_threshold;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNK_MONITORs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMP_MONITORs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = dlb_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));

    if (!monitor) {
        rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL);
        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        SHR_EXIT();
    }

    value = monitor->enable ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, MONITORs, value));

    value = (monitor->action == BCMI_LTSW_DLB_MON_TRACE) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRACEs, value));

    /* Program h/w only if user is enabling DLB id monitoring, and a non-zero
     * rate is specified. Rate of 0 means 'do not sample', which means
     * effectively disabling monitoring
     */
    if (monitor->sample_rate > 0) {
        /* Calculate threshold based on sampling rate provided. We complement
         * the value calculated since packet sampling happens when h/w's
         * random number generator is >= the programmed threshold
         * (In case of sflow, sampling happens if RNG value <= threshold)
         */

        /* Rate of 1 means sample each packet. In this case we need to adjust
         * value to be the max value that can be fitted in SAMPLE_THRESHOLDf
         */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, lt_name, SAMPLE_THRESHOLDs,
                                           NULL, &field_max));
        if (monitor->sample_rate == 1) {
            max_sample_threshold = field_max;
        } else {
            max_sample_threshold = field_max + 1;
        }
        sample_threshold = max_sample_threshold / monitor->sample_rate;
        /* Complement the value */
        /* Note 'field_max' is used here as mask to zero out bits 31:29 */
        value = ~sample_threshold & field_max;
    } else {
        value = 0;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SAMPLE_THRESHOLDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the DLB monitoring configurations.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [out] monitor DLB monitoring configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_monitor_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_monitor_t *monitor)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    const char *lt_name = NULL;
    uint64_t value;
    int dunit;
    uint64_t field_max, max_sample_threshold;
    uint32_t sample_threshold;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNK_MONITORs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMP_MONITORs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = dlb_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (rv == SHR_E_NOT_FOUND) {
        sal_memset(monitor, 0, sizeof(*monitor));
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, MONITORs, &value));
    monitor->enable = value ? 1 : 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, TRACEs, &value));
    monitor->action = value ? BCMI_LTSW_DLB_MON_TRACE : 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, SAMPLE_THRESHOLDs, &value));
    sample_threshold = value & 0xffffffff;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, lt_name, SAMPLE_THRESHOLDs,
                                       NULL, &field_max));

    /* Calculate sample_rate from sample threshold */
    /* field_max' is used as mask here */
    sample_threshold = ~sample_threshold & (uint32_t)field_max;
    max_sample_threshold = field_max + 1;

    if (sample_threshold == 0) {
        monitor->sample_rate = (int)max_sample_threshold;
    } else {
        monitor->sample_rate = (int)max_sample_threshold / sample_threshold;
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear the DLB monitoring configurations.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_monitor_clear(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    uint64_t value;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNK_MONITORs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMP_MONITORs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = dlb_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the DLB member quality map table.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] quality_map_id DLB member port quality map profile Id.
 * \param [in] quantized_avg_port_loading DLB member port quantized average port loading.
 * \param [in] quantized_avg_qsize DLB member port quantized average queue size.
 * \param [in] quantized_avg_port_qsize DLB member port quantized average port queue size.
 * \param [in] quality DLB member port quality.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_member_quality_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    int quality_map_id,
    int quantized_avg_port_loading,
    int quantized_avg_qsize,
    int quantized_avg_port_qsize,
    int quality)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = DLB_QUALITY_MAPs;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(dlb_type);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = quality_map_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_QUALITY_MAP_IDs, value));

    value = quantized_avg_port_loading;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, QUANTIZED_AVG_PORT_LOADINGs, value));

    value = quantized_avg_qsize;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, QUANTIZED_AVG_PORT_QUEUE_SIZEs, value));

    value = quantized_avg_port_qsize;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, QUANTIZED_AVG_TM_QUEUE_SIZEs, value));

    value = quality;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, QUALITYs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear the DLB member quality map table.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] quality_map_id DLB member port quality map profile Id.
 * \param [in] quantized_avg_port_loading DLB member port quantized average port loading.
 * \param [in] quantized_avg_qsize DLB member port quantized average queue size.
 * \param [in] quantized_avg_port_qsize DLB member port quantized average port queue size.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_member_quality_clear(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    int quality_map_id,
    int quantized_avg_port_loading,
    int quantized_avg_qsize,
    int quantized_avg_port_qsize)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = DLB_QUALITY_MAPs;
    int dunit, rv;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(dlb_type);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = quality_map_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_QUALITY_MAP_IDs, value));

    value = quantized_avg_port_loading;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, QUANTIZED_AVG_PORT_LOADINGs, value));

    value = quantized_avg_qsize;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, QUANTIZED_AVG_PORT_QUEUE_SIZEs, value));

    value = quantized_avg_port_qsize;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, QUANTIZED_AVG_TM_QUEUE_SIZEs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the DLB member quality map profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] quality_map_id DLB member port quality map profile Id.
 * \param [in] load_percent DLB member port load percent.
 * \param [in] qsize_percent DLB member port queue size percent.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_member_quality_map_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    int quality_map_id,
    int load_percent,
    int qsize_percent)
{
    int quantized_avg_port_loading;
    int quantized_avg_qsize;
    int quantized_avg_port_qsize;
    int quality;
    int avg_port_qsize_percent = 100 - load_percent - qsize_percent;

    SHR_FUNC_ENTER(unit);

    for (quantized_avg_port_loading = 0;
         quantized_avg_port_loading < 8;
         quantized_avg_port_loading++) {
        for (quantized_avg_qsize = 0;
             quantized_avg_qsize < 8;
             quantized_avg_qsize++) {
            for (quantized_avg_port_qsize = 0;
                 quantized_avg_port_qsize < 8;
                 quantized_avg_port_qsize++) {
                quality  = (quantized_avg_port_loading * load_percent +
                            quantized_avg_qsize * qsize_percent +
                            quantized_avg_port_qsize * avg_port_qsize_percent);
                quality /= 100;
                SHR_IF_ERR_VERBOSE_EXIT
                    (ltsw_xfs_dlb_member_quality_set(unit, dlb_type,
                                                     quality_map_id,
                                                     quantized_avg_port_loading,
                                                     quantized_avg_qsize,
                                                     quantized_avg_port_qsize,
                                                     quality));
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear the DLB member quality map profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] quality_map_id DLB member port quality map profile Id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_member_quality_map_clear(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    int quality_map_id)
{
    int quantized_avg_port_loading;
    int quantized_avg_qsize;
    int quantized_avg_port_qsize;

    SHR_FUNC_ENTER(unit);

    for (quantized_avg_port_loading = 0;
         quantized_avg_port_loading < 8;
         quantized_avg_port_loading++) {
        for (quantized_avg_qsize = 0;
             quantized_avg_qsize < 8;
             quantized_avg_qsize++) {
            for (quantized_avg_port_qsize = 0;
                 quantized_avg_port_qsize < 8;
                 quantized_avg_port_qsize++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (ltsw_xfs_dlb_member_quality_clear(unit, dlb_type,
                                                       quality_map_id,
                                                       quantized_avg_port_loading,
                                                       quantized_avg_qsize,
                                                       quantized_avg_port_qsize));
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the DLB member port bitmap.
 *
 * \param [in] unit Unit Number.
 * \param [out] pbmp DLB member port bitmap.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_member_pbmp_get(
    int unit,
    bcm_pbmp_t *pbmp)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit, rv, port;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(pbmp, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, DLB_PORT_CONTROLs, &lte_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, lte_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, PORT_IDs, &value));
        port = value & 0xffffffff;

        BCM_PBMP_PORT_ADD(*pbmp, port);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the DLB member attributes.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] attribute DLB member port attribute.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_member_attribute_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_member_attribute_t *attribute)
{
    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(dlb_type);

    if (attribute->scaling_factor != BCMI_LTSW_DLB_SCALING_FACTOR_INVALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_dlb_scaling_factor_encode(unit, attribute->scaling_factor,
                                                NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the DLB member attributes.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] scaling_factor DLB member port scaling factor.
 * \param [in] quality_map_id DLB member port quality map profile Id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_member_attribute_set(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int scaling_factor,
    int quality_map_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = DLB_PORT_CONTROLs;
    int dunit;
    uint64_t value;
    const char *symbol = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    value = quality_map_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_QUALITY_MAP_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_scaling_factor_encode(unit, scaling_factor, &symbol));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(lte_hdl,
                                      PORT_LOAD_SCALING_FACTORs, symbol));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(lte_hdl,
                                      PORT_QUEUE_SIZE_SCALING_FACTORs, symbol));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(lte_hdl,
                                      TM_QUEUE_SIZE_SCALING_FACTORs, symbol));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the DLB member attributes.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [out] scaling_factor DLB member port scaling factor.
 * \param [out] quality_map_id DLB member port quality map profile Id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_member_attribute_get(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int *scaling_factor,
    int *quality_map_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = DLB_PORT_CONTROLs;
    uint64_t value;
    const char *symbol = NULL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    if (quality_map_id) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, DLB_QUALITY_MAP_IDs, &value));
        *quality_map_id = value & 0xffffffff;
    }

    if (scaling_factor) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(lte_hdl,
                                          PORT_LOAD_SCALING_FACTORs, &symbol));
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_dlb_scaling_factor_decode(unit, symbol, scaling_factor));
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

static int
ltsw_xfs_dlb_member_attribute_clear(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = DLB_PORT_CONTROLs;
    uint64_t value;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(dlb_type);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB member status.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] status Type-based DLB member status.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_member_status_set(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int status)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    uint64_t value;
    int dunit;
    int override, override_link_state;

    SHR_FUNC_ENTER(unit);

    switch (status) {
        case BCMI_LTSW_DLB_MEMBER_STATUS_FORCE_DOWN:
            override = 1;
            override_link_state = 0;
            break;
        case BCMI_LTSW_DLB_MEMBER_STATUS_FORCE_UP:
            override = 1;
            override_link_state = 1;
            break;
        case BCMI_LTSW_DLB_MEMBER_STATUS_HW:
            override = 0;
            override_link_state = 0;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNK_PORT_CONTROLs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMP_PORT_CONTROLs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    value = override;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, OVERRIDEs, value));

    value = override_link_state;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, OVERRIDE_LINK_STATEs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DLB member status from HW.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [out] status Type-based DLB member status.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_member_status_get_hw(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int *status)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    const char *lt_name = NULL;
    uint64_t value;
    int dunit;
    int link_state;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNK_PORT_STATUSs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMP_PORT_STATUSs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, LINK_STATEs, &value));
    link_state = value & 0xffffffff;

    if (link_state) {
        *status = BCMI_LTSW_DLB_MEMBER_STATUS_HW_UP;
    } else {
        *status = BCMI_LTSW_DLB_MEMBER_STATUS_HW_DOWN;
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DLB member status.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [out] status Type-based DLB member status.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_member_status_get(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int *status)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    const char *lt_name = NULL;
    uint64_t value;
    int dunit;
    int override, override_link_state;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNK_PORT_CONTROLs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMP_PORT_CONTROLs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, OVERRIDEs, &value));
    override = value & 0xffffffff;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, OVERRIDE_LINK_STATEs, &value));
    override_link_state = value & 0xffffffff;

    if (override) {
        if (override_link_state) {
            *status = BCMI_LTSW_DLB_MEMBER_STATUS_FORCE_UP;
        } else {
            *status = BCMI_LTSW_DLB_MEMBER_STATUS_FORCE_DOWN;
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_dlb_member_status_get_hw(unit, port, dlb_type, status));
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB controlling information to quantization threshold LT table.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] ctrl_info Dynamic Load Balance controlling information.
 * \param [in] type Dynamic Load Balance controlling type.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_quantization_threshold_table_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmint_dlb_ctrl_info_t *ctrl_info,
    bcmi_ltsw_dlb_control_type_t type)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = DLB_QUANTIZATION_THRESHOLDs;
    const char *fld_name = NULL;
    int dunit;
    uint64_t value;
    uint64_t quantization_threshold_id_min;
    uint64_t quantization_threshold_id_max;
    uint64_t qthd_id, min, max, increment, multiple, divisor;

    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(dlb_type);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, lt_name,
                               DLB_QUANTIZATION_THRESHOLD_IDs,
                               &quantization_threshold_id_min,
                               &quantization_threshold_id_max));

    switch (type) {
        case bcmiDlbControlTypeSampleRate:
        case bcmiDlbControlTypeEgressBytesMinThreshold:
        case bcmiDlbControlTypeEgressBytesMaxThreshold:
            fld_name = PORT_LOAD_QUANTIZATION_THRESHOLDs;
            min = ctrl_info->egress_bytes_min;
            max = ctrl_info->egress_bytes_max;
            increment = (max - min) / quantization_threshold_id_max;
            multiple = 1000000 / ctrl_info->sample_rate;
            divisor = 8;
            break;
        case bcmiDlbControlTypeQueuedBytesMinThreshold:
        case bcmiDlbControlTypeQueuedBytesMaxThreshold:
            fld_name = PORT_QUEUE_SIZE_QUANTIZATION_THRESHOLDs;
            min = ctrl_info->queued_bytes_min;
            max = ctrl_info->queued_bytes_max;
            increment = (max - min) / quantization_threshold_id_max;
            multiple = 1;
            divisor = ctrl_info->bytes_per_cell;
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesMinThreshold:
        case bcmiDlbControlTypePhysicalQueuedBytesMaxThreshold:
            fld_name = TM_QUEUE_SIZE_QUANTIZATION_THRESHOLDs;
            min = ctrl_info->physical_queued_bytes_min;
            max = ctrl_info->physical_queued_bytes_max;
            increment = (max - min) / quantization_threshold_id_max;
            multiple = 1;
            divisor = ctrl_info->bytes_per_cell;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    for (qthd_id  = quantization_threshold_id_min;
         qthd_id <= quantization_threshold_id_max; qthd_id++) {
        value = qthd_id;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, DLB_QUANTIZATION_THRESHOLD_IDs,
                                   value));

        value = (min + qthd_id * increment) * multiple / divisor;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, fld_name, value));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB controlling value to control LT table.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [in] data Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_control_table_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t data)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = DLB_CONTROLs;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(dlb_type);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    switch (type) {
        case bcmiDlbControlTypeSampleRate:
            value = 1000000 / data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, SAMPLING_PERIODs, value));
            break;
        case bcmiDlbControlTypeEgressBytesExponent:
            value = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, PORT_LOAD_WEIGHTs, value));
            break;
        case bcmiDlbControlTypeQueuedBytesExponent:
            value = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, PORT_QUEUE_SIZE_WEIGHTs, value));
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesExponent:
            value = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, TM_QUEUE_SIZE_WEIGHTs, value));
            break;
        case bcmiDlbControlTypeEgressBytesDecreaseReset:
            value = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, CAP_PORT_LOADs, value));
            break;
        case bcmiDlbControlTypeQueuedBytesDecreaseReset:
            value = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, CAP_PORT_QUEUE_SIZEs, value));
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesDecreaseReset:
            value = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, CAP_TM_QUEUE_SIZEs, value));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DLB controlling value from control LT table.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [out] data Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_control_table_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t *data)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = DLB_CONTROLs;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(dlb_type);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    switch (type) {
        case bcmiDlbControlTypeEgressBytesExponent:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, PORT_LOAD_WEIGHTs, &value));
            break;
        case bcmiDlbControlTypeQueuedBytesExponent:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, PORT_QUEUE_SIZE_WEIGHTs, &value));
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesExponent:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, TM_QUEUE_SIZE_WEIGHTs, &value));
            break;
        case bcmiDlbControlTypeEgressBytesDecreaseReset:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, CAP_PORT_LOADs, &value));
            break;
        case bcmiDlbControlTypeQueuedBytesDecreaseReset:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, CAP_PORT_QUEUE_SIZEs, &value));
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesDecreaseReset:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, CAP_TM_QUEUE_SIZEs, &value));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (data) {
        *data = value;
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB controlling value to type based control LT table.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [in] data Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_type_control_table_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t data)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNK_CONTROLs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMP_CONTROLs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    switch (type) {
        case bcmiDlbControlTypeRandomSeed:
            value = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, SEEDs, value));
            break;
        case bcmiDlbControlTypeMonitorIngressFieldRandomSeed:
            value = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, FP_ING_SEEDs, value));
            break;
        case bcmiDlbControlTypeMonitorIngressRandomSeed:
            value = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, MONITOR_SEEDs, value));
            break;
        case bcmiDlbControlTypeBaseEcmpId:
            value = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, BASE_ECMP_IDs, value));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DLB controlling value from type based control LT table.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [out] data Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_type_control_table_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t *data)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNK_CONTROLs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMP_CONTROLs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    switch (type) {
        case bcmiDlbControlTypeRandomSeed:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, SEEDs, &value));
            break;
        case bcmiDlbControlTypeMonitorIngressFieldRandomSeed:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, FP_ING_SEEDs, &value));
            break;
        case bcmiDlbControlTypeMonitorIngressRandomSeed:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, MONITOR_SEEDs, &value));
            break;
        case bcmiDlbControlTypeBaseEcmpId:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, BASE_ECMP_IDs, &value));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (data) {
        *data = value;
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate DLB controlling value with information.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] ctrl_info Dynamic Load Balance controlling information.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [in] value Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_control_info_value_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmint_dlb_ctrl_info_t **ctrl_info,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    bcmint_dlb_ctrl_info_t *cinfo = ctrl_info[bcmi_dlb_type_fp_trunk];
    uint64_t min, max;
    const char *lt_name = DLB_QUANTIZATION_THRESHOLDs;

    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(dlb_type);

    switch (type) {
        case bcmiDlbControlTypeEgressBytesMinThreshold:
        case bcmiDlbControlTypeEgressBytesMaxThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, lt_name,
                                       PORT_LOAD_QUANTIZATION_THRESHOLDs,
                                       &min, &max));
            value = value * (1000000 / cinfo->sample_rate) / 8;
            break;
        case bcmiDlbControlTypeQueuedBytesMinThreshold:
        case bcmiDlbControlTypeQueuedBytesMaxThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, lt_name,
                                       PORT_QUEUE_SIZE_QUANTIZATION_THRESHOLDs,
                                       &min, &max));
            value /= cinfo->bytes_per_cell;
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesMinThreshold:
        case bcmiDlbControlTypePhysicalQueuedBytesMaxThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, lt_name,
                                       TM_QUEUE_SIZE_QUANTIZATION_THRESHOLDs,
                                       &min, &max));
            value /= cinfo->bytes_per_cell;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (value < min || value > max) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check DLB controlling value with information.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] ctrl_info Dynamic Load Balance controlling information.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [in] value Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_control_info_check(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmint_dlb_ctrl_info_t *ctrl_info,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk) {
        SHR_EXIT();
    }

    switch (type) {
        case bcmiDlbControlTypeSampleRate:
            if (ctrl_info->sample_rate == value) {
                SHR_ERR_EXIT(SHR_E_EXISTS);
            }
            break;
        case bcmiDlbControlTypeEgressBytesMinThreshold:
            if (ctrl_info->egress_bytes_min == value) {
                SHR_ERR_EXIT(SHR_E_EXISTS);
            }
            break;
        case bcmiDlbControlTypeEgressBytesMaxThreshold:
            if (ctrl_info->egress_bytes_max == value) {
                SHR_ERR_EXIT(SHR_E_EXISTS);
            }
            break;
        case bcmiDlbControlTypeQueuedBytesMinThreshold:
            if (ctrl_info->queued_bytes_min == value) {
                SHR_ERR_EXIT(SHR_E_EXISTS);
            }
            break;
        case bcmiDlbControlTypeQueuedBytesMaxThreshold:
            if (ctrl_info->queued_bytes_max == value) {
                SHR_ERR_EXIT(SHR_E_EXISTS);
            }
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesMinThreshold:
            if (ctrl_info->physical_queued_bytes_min == value) {
                SHR_ERR_EXIT(SHR_E_EXISTS);
            }
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesMaxThreshold:
            if (ctrl_info->physical_queued_bytes_max == value) {
                SHR_ERR_EXIT(SHR_E_EXISTS);
            }
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Save DLB controlling value to information.
 *
 * \param [in] unit Unit Number.
 * \param [in] ctrl_info Dynamic Load Balance controlling information.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [out] value Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_control_info_save(
    int unit,
    bcmint_dlb_ctrl_info_t *ctrl_info,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmiDlbControlTypeSampleRate:
            ctrl_info->sample_rate = value;
            break;
        case bcmiDlbControlTypeEgressBytesMinThreshold:
            ctrl_info->egress_bytes_min = value;
            if (value > ctrl_info->egress_bytes_max) {
                ctrl_info->egress_bytes_max = value;
            }
            break;
        case bcmiDlbControlTypeEgressBytesMaxThreshold:
            if (ctrl_info->egress_bytes_min > value) {
                value = ctrl_info->egress_bytes_min;
            }
            ctrl_info->egress_bytes_max = value;
            break;
        case bcmiDlbControlTypeQueuedBytesMinThreshold:
            ctrl_info->queued_bytes_min = value;
            if (value > ctrl_info->queued_bytes_max) {
                ctrl_info->queued_bytes_max = value;
            }
            break;
        case bcmiDlbControlTypeQueuedBytesMaxThreshold:
            if (ctrl_info->queued_bytes_min > value) {
                value = ctrl_info->queued_bytes_min;
            }
            ctrl_info->queued_bytes_max = value;
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesMinThreshold:
            ctrl_info->physical_queued_bytes_min = value;
            if (value > ctrl_info->physical_queued_bytes_max) {
                ctrl_info->physical_queued_bytes_max = value;
            }
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesMaxThreshold:
            if (ctrl_info->physical_queued_bytes_min > value) {
                value = ctrl_info->physical_queued_bytes_min;
            }
            ctrl_info->physical_queued_bytes_max = value;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB controlling value with information.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] ctrl_info Dynamic Load Balance controlling information.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [in] value Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_control_info_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmint_dlb_ctrl_info_t **ctrl_info,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    bcmint_dlb_ctrl_info_t cinfo, *ci = ctrl_info[bcmi_dlb_type_fp_trunk];
    int rv;

    SHR_FUNC_ENTER(unit);

    rv = ltsw_xfs_dlb_control_info_check(unit, dlb_type, ci, type, value);
    if (rv != SHR_E_NONE) {
        if (rv != SHR_E_EXISTS) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

    sal_memcpy(&cinfo, ci, sizeof(bcmint_dlb_ctrl_info_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_control_info_save(unit, &cinfo, type, value));

    switch (type) {
        case bcmiDlbControlTypeSampleRate:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_dlb_control_table_set(unit, dlb_type, type, value));
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_dlb_quantization_threshold_table_set(unit, dlb_type,
                                                               &cinfo, type));
            break;
        case bcmiDlbControlTypeEgressBytesMinThreshold:
        case bcmiDlbControlTypeEgressBytesMaxThreshold:
        case bcmiDlbControlTypeQueuedBytesMinThreshold:
        case bcmiDlbControlTypeQueuedBytesMaxThreshold:
        case bcmiDlbControlTypePhysicalQueuedBytesMinThreshold:
        case bcmiDlbControlTypePhysicalQueuedBytesMaxThreshold:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_dlb_quantization_threshold_table_set(unit, dlb_type,
                                                               &cinfo, type));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_control_info_save(unit, ci, type, value));

    ci = ctrl_info[bcmi_dlb_type_fabric_trunk];
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_control_info_save(unit, ci, type, value));

    ci = ctrl_info[bcmi_dlb_type_ecmp];
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_control_info_save(unit, ci, type, value));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DLB controlling value from information.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] ctrl_info Dynamic Load Balance controlling information.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [out] value Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_control_info_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmint_dlb_ctrl_info_t **ctrl_info,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t *value)
{
    bcmint_dlb_ctrl_info_t *cinfo = ctrl_info[bcmi_dlb_type_fp_trunk];

    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(dlb_type);

    switch (type) {
        case bcmiDlbControlTypeSampleRate:
            *value = cinfo->sample_rate;
            break;
        case bcmiDlbControlTypeEgressBytesMinThreshold:
            *value = cinfo->egress_bytes_min;
            break;
        case bcmiDlbControlTypeEgressBytesMaxThreshold:
            *value = cinfo->egress_bytes_max;
            break;
        case bcmiDlbControlTypeQueuedBytesMinThreshold:
            *value = cinfo->queued_bytes_min;
            break;
        case bcmiDlbControlTypeQueuedBytesMaxThreshold:
            *value = cinfo->queued_bytes_max;
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesMinThreshold:
            *value = cinfo->physical_queued_bytes_min;
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesMaxThreshold:
            *value = cinfo->physical_queued_bytes_max;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate DLB controlling type.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_control_type_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmiDlbControlTypeBaseEcmpId:
            if (dlb_type != bcmi_dlb_type_ecmp) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        default:
            break;
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate DLB controlling value.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [in] value Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_control_value_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    uint64_t min, max;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(dlb_type);

    switch (type) {
        case bcmiDlbControlTypeSampleRate:
            if (value <= 0) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            lt_name = DLB_CONTROLs;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, lt_name,
                                               SAMPLING_PERIODs,
                                               &min, &max));
            min += 1;
            value = 1000000 / value;
            break;
        case bcmiDlbControlTypeEgressBytesExponent:
            lt_name = DLB_CONTROLs;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, lt_name,
                                               PORT_LOAD_WEIGHTs,
                                               &min, &max));
            break;
        case bcmiDlbControlTypeQueuedBytesExponent:
            lt_name = DLB_CONTROLs;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, lt_name,
                                               PORT_QUEUE_SIZE_WEIGHTs,
                                               &min, &max));
            break;
        case bcmiDlbControlTypePhysicalQueuedBytesExponent:
            lt_name = DLB_CONTROLs;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, lt_name,
                                               TM_QUEUE_SIZE_WEIGHTs,
                                               &min, &max));
            break;
        case bcmiDlbControlTypeEgressBytesDecreaseReset:
        case bcmiDlbControlTypeQueuedBytesDecreaseReset:
        case bcmiDlbControlTypePhysicalQueuedBytesDecreaseReset:
            min = 0;
            max = 1;
            break;
        case bcmiDlbControlTypeRandomSeed:
            if (dlb_type == bcmi_dlb_type_fp_trunk ||
                dlb_type == bcmi_dlb_type_fabric_trunk) {
                lt_name = DLB_TRUNK_CONTROLs;
            } else if (dlb_type == bcmi_dlb_type_ecmp) {
                lt_name = DLB_ECMP_CONTROLs;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, lt_name,
                                               SEEDs,
                                               &min, &max));
            break;
        case bcmiDlbControlTypeMonitorIngressFieldRandomSeed:
            if (dlb_type == bcmi_dlb_type_fp_trunk ||
                dlb_type == bcmi_dlb_type_fabric_trunk) {
                lt_name = DLB_TRUNK_CONTROLs;
            } else if (dlb_type == bcmi_dlb_type_ecmp) {
                lt_name = DLB_ECMP_CONTROLs;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, lt_name,
                                               FP_ING_SEEDs,
                                               &min, &max));
            break;
        case bcmiDlbControlTypeMonitorIngressRandomSeed:
            if (dlb_type == bcmi_dlb_type_fp_trunk ||
                dlb_type == bcmi_dlb_type_fabric_trunk) {
                lt_name = DLB_TRUNK_CONTROLs;
            } else if (dlb_type == bcmi_dlb_type_ecmp) {
                lt_name = DLB_ECMP_CONTROLs;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, lt_name,
                                               MONITOR_SEEDs,
                                               &min, &max));
            break;
        case bcmiDlbControlTypeBaseEcmpId:
            lt_name = DLB_ECMP_CONTROLs;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, lt_name,
                                               BASE_ECMP_IDs,
                                               &min, &max));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (value < min || value > max) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB controlling information.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [in] value Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_control_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmiDlbControlTypeEgressBytesExponent:
        case bcmiDlbControlTypeQueuedBytesExponent:
        case bcmiDlbControlTypePhysicalQueuedBytesExponent:
        case bcmiDlbControlTypeEgressBytesDecreaseReset:
        case bcmiDlbControlTypeQueuedBytesDecreaseReset:
        case bcmiDlbControlTypePhysicalQueuedBytesDecreaseReset:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_dlb_control_table_set(unit, dlb_type, type, value));
            break;
        case bcmiDlbControlTypeRandomSeed:
        case bcmiDlbControlTypeMonitorIngressFieldRandomSeed:
        case bcmiDlbControlTypeMonitorIngressRandomSeed:
        case bcmiDlbControlTypeBaseEcmpId:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_dlb_type_control_table_set(unit, dlb_type,
                                                     type, value));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DLB controlling information.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] type Dynamic Load Balance controlling type.
 * \param [out] value Type-based controlling value for DLB.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_control_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t *value)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmiDlbControlTypeEgressBytesExponent:
        case bcmiDlbControlTypeQueuedBytesExponent:
        case bcmiDlbControlTypePhysicalQueuedBytesExponent:
        case bcmiDlbControlTypeEgressBytesDecreaseReset:
        case bcmiDlbControlTypeQueuedBytesDecreaseReset:
        case bcmiDlbControlTypePhysicalQueuedBytesDecreaseReset:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_dlb_control_table_get(unit, dlb_type, type, value));
            break;
        case bcmiDlbControlTypeRandomSeed:
        case bcmiDlbControlTypeMonitorIngressFieldRandomSeed:
        case bcmiDlbControlTypeMonitorIngressRandomSeed:
        case bcmiDlbControlTypeBaseEcmpId:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_dlb_type_control_table_get(unit, dlb_type,
                                                     type, value));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set statistic for a DLB group.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [in] stat DLB configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_stat_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_stat_t *stat)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    uint64_t value;
    int dunit;
    bool update = false;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNK_STATSs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMP_STATSs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = dlb_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));

    value = stat->fail_count;
    if (value != (uint64_t)0xffffffff) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, FAIL_CNTs, value));
        update = true;
    }

    value = stat->port_reassignment_count;
    if (value != (uint64_t)0xffffffff) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, PORT_REASSIGNMENT_CNTs, value));
        update = true;
    }

    if (dlb_type == bcmi_dlb_type_ecmp) {
        value = stat->member_reassignment_count;
        if (value != (uint64_t)0xffffffff) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, MEMBER_REASSIGNMENT_CNTs,
                                       value));
            update = true;
        }
    }

    if (update) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get statistic for a DLB group.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [in] sync_mode Sync from HW or not.
 * \param [out] stat DLB configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_stat_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bool sync_mode,
    bcmi_ltsw_dlb_stat_t *stat)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    const char *lt_name = NULL;
    uint64_t value;
    int dunit;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNK_STATSs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMP_STATSs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = dlb_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_attrib_set(lte_hdl,
                                sync_mode ? BCMLT_ENT_ATTR_GET_FROM_HW : 0));
    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));
    }

    sal_memset(stat, 0, sizeof(*stat));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, FAIL_CNTs, &value));
    stat->fail_count = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, PORT_REASSIGNMENT_CNTs, &value));
    stat->port_reassignment_count = value;

    if (dlb_type == bcmi_dlb_type_ecmp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, MEMBER_REASSIGNMENT_CNTs, &value));
        stat->member_reassignment_count = value;
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get statistic for a DLB group.
 *
 * \param [in] unit Unit Number.
 * \param [in] dlb_type Dynamic Load Balance type.
 * \param [in] dlb_id Dynamic Load Balance Id.
 * \param [in] sync_mode Sync from HW or not.
 * \param [out] stat DLB configurations.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_dlb_stat_clear(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    const char *lt_name = NULL;
    uint64_t value;
    int dunit;

    SHR_FUNC_ENTER(unit);

    if (dlb_type == bcmi_dlb_type_fp_trunk ||
        dlb_type == bcmi_dlb_type_fabric_trunk) {
        lt_name = DLB_TRUNK_STATSs;
    } else if (dlb_type == bcmi_dlb_type_ecmp) {
        lt_name = DLB_ECMP_STATSs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = dlb_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_dlb_init(int unit)
{
    return SHR_E_NONE;
}

int
xfs_ltsw_dlb_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_hw_deinit(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_type_init(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type)
{
    return SHR_E_NONE;
}

int
xfs_ltsw_dlb_type_deinit(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type)
{
    SHR_FUNC_ENTER(unit);

    switch (dlb_type) {
        case bcmi_dlb_type_fp_trunk:
        case bcmi_dlb_type_fabric_trunk:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_dlb_clear_trunk(unit));
            break;
        case bcmi_dlb_type_ecmp:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_dlb_clear_ecmp(unit));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_config_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_config_t *dlb_config)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_config_validate(unit, dlb_type, dlb_config));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_config_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_config_t *dlb_config)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_config_set(unit, dlb_type, dlb_id, dlb_config));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_config_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_config_t *dlb_config)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_config_get(unit, dlb_type, dlb_id, dlb_config));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_config_clear(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_config_clear(unit, dlb_type, dlb_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_stat_clear(unit, dlb_type, dlb_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_monitor_clear(unit, dlb_type, dlb_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_monitor_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_monitor_t *monitor)
{
    SHR_FUNC_ENTER(unit);

    if (monitor->enable) {
        switch (monitor->action) {
            case BCMI_LTSW_DLB_MON_ACTION_NONE:
            case BCMI_LTSW_DLB_MON_TRACE:
                break;
            default:
                SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_monitor_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_monitor_t *monitor)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_monitor_set(unit, dlb_type, dlb_id, monitor));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_monitor_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_monitor_t *monitor)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_monitor_get(unit, dlb_type, dlb_id, monitor));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_monitor_clear(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_monitor_clear(unit, dlb_type, dlb_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_member_quality_map_profile_format(
    int unit,
    bcmint_dlb_quality_map_profile_t *quality_map_profile,
    uint32_t *quality_map_profile_format)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(quality_map_profile, SHR_E_PARAM);
    SHR_NULL_CHECK(quality_map_profile_format, SHR_E_PARAM);

    *quality_map_profile_format  = 0;
    *quality_map_profile_format |= quality_map_profile->load_percent << 8;
    *quality_map_profile_format |= quality_map_profile->qsize_percent;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_member_quality_map_profile2id(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    int quality_map_profile_count,
    bcmint_dlb_quality_map_profile_t *quality_map_profile,
    int profile_index,
    int *quality_map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(quality_map_id, SHR_E_PARAM);
    *quality_map_id = profile_index;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_member_quality_map_id2profile(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    int quality_map_profile_count,
    bcmint_dlb_quality_map_profile_t *quality_map_profile,
    int quality_map_id,
    int *profile_index)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile_index, SHR_E_PARAM);
    *profile_index = quality_map_id;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_member_quality_map_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    int quality_map_id,
    int load_percent,
    int qsize_percent)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_member_quality_map_set(unit, dlb_type, quality_map_id,
                                             load_percent, qsize_percent));

exit:
    SHR_FUNC_EXIT();
    return SHR_E_UNAVAIL;
}

int
xfs_ltsw_dlb_member_quality_map_clear(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    int quality_map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_member_quality_map_clear(unit, dlb_type, quality_map_id));

exit:
    SHR_FUNC_EXIT();
    return SHR_E_UNAVAIL;
}

int
xfs_ltsw_dlb_member_pbmp_get(
    int unit,
    bcm_pbmp_t *pbmp)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_member_pbmp_get(unit, pbmp));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_member_attribute_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_member_attribute_t *attribute)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_member_attribute_validate(unit, dlb_type, attribute));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_member_attribute_set(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int scaling_factor,
    int quality_map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_member_attribute_set(unit, port, dlb_type,
                                           scaling_factor, quality_map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_member_attribute_get(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int *scaling_factor,
    int *quality_map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_member_attribute_get(unit, port, dlb_type,
                                           scaling_factor, quality_map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_member_attribute_clear(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_member_attribute_clear(unit, port, dlb_type));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_member_status_set(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int status)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_member_status_set(unit, port, dlb_type, status));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_member_status_get(
    int unit,
    bcm_port_t port,
    bcmi_ltsw_dlb_type_t dlb_type,
    int *status)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_member_status_get(unit, port, dlb_type, status));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_control_info_value_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmint_dlb_ctrl_info_t **ctrl_info,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_control_info_value_validate(unit, dlb_type,
                                                  ctrl_info, type, value));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_control_info_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmint_dlb_ctrl_info_t **ctrl_info,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_control_info_set(unit, dlb_type, ctrl_info, type, value));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_control_info_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmint_dlb_ctrl_info_t **ctrl_info,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_control_info_get(unit, dlb_type, ctrl_info, type, value));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_control_type_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_control_type_validate(unit, dlb_type, type));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_control_value_validate(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_control_value_validate(unit, dlb_type, type, value));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_control_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_control_set(unit, dlb_type, type, value));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_control_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_control_type_t type,
    uint64_t *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_control_get(unit, dlb_type, type, value));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_stat_set(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bcmi_ltsw_dlb_stat_t *stat)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_stat_set(unit, dlb_type, dlb_id, stat));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_dlb_stat_get(
    int unit,
    bcmi_ltsw_dlb_type_t dlb_type,
    bcmi_ltsw_dlb_id_t dlb_id,
    bool sync_mode,
    bcmi_ltsw_dlb_stat_t *stat)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_dlb_stat_get(unit, dlb_type, dlb_id, sync_mode, stat));

exit:
    SHR_FUNC_EXIT();
}

