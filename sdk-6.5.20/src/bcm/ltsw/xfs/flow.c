/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/common/multicast.h>
#include <bcm_int/control.h>
#include <bcm_int/ltsw_dispatch.h>

#include <bcm_int/ltsw/xfs/flow.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw/flow.h>
#include <bcm_int/ltsw/flow_int.h>
#include <bcm_int/ltsw/qos.h>
#include <bcm_int/ltsw/sbr.h>
#include <bcm_int/ltsw/vlan.h>
#include <bcm_int/ltsw/l3.h>
#include <bcm_int/ltsw/l3_egress.h>
#include <bcm_int/ltsw/flexctr.h>
#include <bcm_int/ltsw/tunnel.h>
#include <bcm_int/ltsw/index_table_mgmt.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/xfs/types.h>
#include <bcm_int/ltsw/types.h>
#include <bcm_int/ltsw/stack.h>

#include <bsl/bsl.h>
#include <shr/shr_debug.h>
#include <sal/sal_time.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_FLOW

/******************************************************************************
 * Private functions
 */

#define INVALID_L2_IF  0xFFFFFFFF

typedef struct xfs_flow_info_s {
    /*! Protection mutex. */
    sal_mutex_t    xfs_flow_mutex;

    /*! l2_iif num. */
    uint32_t       l2_iif_num;

    /*! l2_iif mapping for VP with port/trunk as match criteria. */
    uint32_t       *l2_iif_map;

} xfs_flow_info_t;

/*
 * \Flow book keeping information.
 */
static xfs_flow_info_t   xfs_flow_info[BCM_MAX_NUM_UNITS];

#define XFS_FLOW_INFO(_unit_)      (&xfs_flow_info[_unit_])

#define XFS_FLOW_LOCK(_unit_) \
    sal_mutex_take(XFS_FLOW_INFO(_unit_)->xfs_flow_mutex, SAL_MUTEX_FOREVER)
#define XFS_FLOW_UNLOCK(_unit_) \
    sal_mutex_give(XFS_FLOW_INFO(_unit_)->xfs_flow_mutex)

typedef struct vlan_xlate_user_data_s {
        bcm_flow_match_traverse_cb cb;
        void *user_data;
} vlan_xlate_user_data_t;

/*! Field definition of split_horizon_ctrl in egr_dvp. */
#define VP_SHC_DOMAIN_ID_SFT 0x0
#define VP_SHC_DOMAIN_ID_MSK 0x3
#define VP_SHC_EN_SFT 0x2
#define VP_SHC_EN_MSK 0x1
#define VP_SHC_L2_ONLY_SFT 0x3
#define VP_SHC_L2_ONLY_MSK 0x1

/*! EGR_DVP EDIT_CTRL_ID control ID */
#define VP_EDIT_CTRL_NONE                0x0
#define VP_EDIT_CTRL_DO_NOT_MOD          0x01
#define VP_EDIT_CTRL_INIT_L2_TUNNEL      0xC
#define VP_EDIT_CTRL_INIT_MPLS_L2_TUNNEL 0xD

/*! EGR_DVP OBJ_TABLE_SEL_1 control ID */
#define VP_OBJ_TABLE_SEL_1_NONE              0x0
#define VP_OBJ_TABLE_SEL_1_L2_OIF            0x1
#define VP_OBJ_TABLE_SEL_1_L3_OIF_2          0x2
#define VP_OBJ_TABLE_SEL_1_EGR_L3_TUNNEEL    0x4
#define VP_OBJ_TABLE_SEL_1_EGR_VC_LABEL      0x8

/*! EGR_L3_TUNNEL_0 EDIT_CTRL_ID control ID */
#define EGR_L3_TUNNEL_0_EDIT_CTRL_ID_NONE         0x0
#define EGR_L3_TUNNEL_0_EDIT_CTRL_ID_VXLAN_IPV4   0xA
#define EGR_L3_TUNNEL_0_EDIT_CTRL_ID_VXLAN_IPV6   0xB

/*! EGR_L3_TUNNEL_0 IP_HDR_DF_CTRL */
#define EGR_L3_TUNNEL_0_IP_HDR_DF_CTRL_IP6_PLD         0x1
#define EGR_L3_TUNNEL_0_IP_HDR_DF_CTRL_IP4_PLD         0x2
#define EGR_L3_TUNNEL_0_IP_HDR_DF_CTRL_INHERIT_IP4_PLD 0x4

/*! Field definition of TUNNEL_WORD_0 in EGR_L3_TUNNEL_1. */
#define TUNNEL_WORD_0_FLOW_LABEL_SFT 0
#define TUNNEL_WORD_0_FLOW_LABEL_MSK 0xFFFFF
#define TUNNEL_WORD_0_ECN_SFT 20
#define TUNNEL_WORD_0_ECN_MSK 0x3
#define TUNNEL_WORD_0_DSCP_SFT 22
#define TUNNEL_WORD_0_DSCP_MSK 0x3F

/*! Field definition of TUNNEL_WORD_1 in EGR_L3_TUNNEL_1. */
#define TUNNEL_WORD_1_PROTOCOL_SFT      0
#define TUNNEL_WORD_1_PROTOCOL_MSK      0xFF
#define TUNNEL_WORD_1_ENTROPY_LABEL_SFT 0
#define TUNNEL_WORD_1_ENTROPY_LABEL_MSK 0xFFFF
#define TUNNEL_WORD_1_PLD_PROTOCOL_SFT  16
#define TUNNEL_WORD_1_PLD_PROTOCOL_MSK  0xFFFF

/*! Default VXLAN UDP destination port. */
#define VXLAN_UDP_DST_PORT 4789
#define UDP_PROTOCOL       17

#define EGR_DVP_PROCESS_CTRL_2_MTU_CHK_EN   (1 << 0)

/*! Field definition of L2MC_L3MC_L2_OIF_SYS_DST_VALID in ING_DVP_TABLE. */
#define DEST_TYPE_L2_MC   (1 << 0)
#define DEST_TYPE_L3_MC   (1 << 1)
#define DEST_TYPE_L2_OIF  (1 << 2)

/*! Field definition of TTL_OR_MPLS_CTRL in EGR_L3_TUNNEL_0. */
#define TTL_OR_MPLS_CTRL_TTL_SFT            0
#define TTL_OR_MPLS_CTRL_TTL_MSK            0x1
#define TTL_OR_MPLS_CTRL_MPLS_VALID_SFT     1
#define TTL_OR_MPLS_CTRL_MPLS_VALID_MSK     0x1
#define TTL_OR_MPLS_CTRL_FIXED_SRC_PORT_SFT 2
#define TTL_OR_MPLS_CTRL_FIXED_SRC_PORT_MSK 0x1

/*! Field definition of TUNNEL_WORD_2 in EGR_L3_TUNNEL_1. */
#define TUNNEL_WORD_2_UDP_SRC_PORT_SFT      0
#define TUNNEL_WORD_2_UDP_SRC_PORT_MSK      0xFFFF
#define TUNNEL_WORD_2_UDP_DST_PORT_SFT      16
#define TUNNEL_WORD_2_UDP_DST_PORT_MSK      0xFFFF

/*! Field definition of TUNNEL_WORD_1 in EGR_L3_TUNNEL_0. */
#define TUNNEL_WORD_1_I_FLAG_SFT            27
#define TUNNEL_WORD_1_REMAP_PTR_SFT         8
#define TUNNEL_WORD_1_REMAP_PTR_MSK         0xFF

/******************************************************************************
 * Private functions
 */

/*!
 * \brief Update ingress vlan xlate tables based on match criteria.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     opt           Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in-out] info          Flow match information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_ing_xlate_ctrl(int unit,
                              bcmint_flow_hw_opt_type_t opt,
                              bcm_flow_match_config_t *info)
{
    bcm_vlan_translate_key_t key_type;
    bcm_gport_t port;
    bcm_vlan_t outer_vlan;
    bcm_vlan_t inner_vlan;
    bcmi_ltsw_vlan_ing_xlate_cfg_t cfg;
    uint32_t vfi = 0;

    SHR_FUNC_ENTER(unit);

    if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN) {
        key_type = bcmVlanTranslateKeyPortGroupOuter;
    } else if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_INNER_VLAN) {
        key_type = bcmVlanTranslateKeyPortGroupInner;
    } else if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN_STACKED) {
        key_type = bcmVlanTranslateKeyPortGroupDouble;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }
    port = info->port;
    outer_vlan = info->vlan;
    inner_vlan = info->inner_vlan;

    sal_memset(&cfg, 0, sizeof(cfg));
    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_ltsw_vlan_ing_xlate_get(unit, key_type, port, outer_vlan,
                                             inner_vlan, &cfg));
        BCM_GPORT_FLOW_PORT_ID_SET(info->flow_port, cfg.svp);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, cfg.vfi, &(info->vpn)));

        info->intf_id = cfg.l3_iif;
    } else if (opt == HW_OPT_SET) {
        if (info->valid_elements & BCM_FLOW_MATCH_FLOW_PORT_VALID) {
            cfg.fld_bmp |= BCMI_LTSW_VLAN_ING_XLATE_FLD_SVP;
            cfg.svp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
        }
        if (info->valid_elements & BCM_FLOW_MATCH_VPN_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vfi_idx_get(unit, info->vpn, &vfi));
            cfg.fld_bmp |= BCMI_LTSW_VLAN_ING_XLATE_FLD_VFI;
            cfg.vfi = vfi;
        }
        if (info->valid_elements & BCM_FLOW_MATCH_IIF_VALID) {
            cfg.fld_bmp |= BCMI_LTSW_VLAN_ING_XLATE_FLD_L3_IIF;
            cfg.l3_iif = info->intf_id;
        }

        if (info->options & BCM_FLOW_MATCH_OPTION_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                   (bcmi_ltsw_vlan_ing_xlate_update(unit, key_type, port,
                                                    outer_vlan,
                                                    inner_vlan, &cfg));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                   (bcmi_ltsw_vlan_ing_xlate_add(unit, key_type, port,
                                                 outer_vlan, inner_vlan, &cfg));
        }
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_ltsw_vlan_ing_xlate_delete(unit, key_type, port,
                                                outer_vlan, inner_vlan));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:

    SHR_FUNC_EXIT();
}

/*!
 * \brief Helper function for flow match to traverse ingress translation tables.
 *
 * This function is used to parse info from ingress translation entries and
 * call flow match callback.
 *
 * \param [in] unit              Unit number.
 * \param [in] key_type          Key Type - bcmVlanTranslateKey*.
 * \param [in] port              Port ID.
 * \param [in] outer_vlan        Outer VLAN ID.
 * \param [in] inner_vlan        Inner VLAN ID.
 * \param [in] cfg               Ingress xlate configuration.
 * \param [in] user_data         User data to a call back.
 *
 * \retval SHR_E_NONE            No errors.
 * \retval !SHR_E_NONE           Failure.
 */
static int
xfs_flow_vlan_ing_xlate_traverse_cb(int unit, bcm_vlan_translate_key_t key_type,
                                    bcm_gport_t port,  bcm_vlan_t outer_vlan,
                                    bcm_vlan_t inner_vlan,
                                    bcmi_ltsw_vlan_ing_xlate_cfg_t *cfg,
                                    void *user_data)
{
    vlan_xlate_user_data_t *vlan_xlate_user_data = user_data;
    bcm_flow_match_config_t info;
    bcmi_ltsw_virtual_vp_info_t vp_info;

    SHR_FUNC_ENTER(unit);

    if (BCMINT_FLOW_VP_RESERVED != cfg->svp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vp_info_get(unit, cfg->svp, &vp_info));
        if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_FLOW)) {
            SHR_EXIT();
        }
    }

    bcm_flow_match_config_t_init(&info);
    if (key_type == bcmVlanTranslateKeyPortGroupOuter) {
        info.criteria = BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN;
        info.valid_elements = BCM_FLOW_MATCH_PORT_VALID |
                              BCM_FLOW_MATCH_VLAN_VALID;
    } else if (key_type == bcmVlanTranslateKeyPortGroupInner) {
        info.criteria = BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_INNER_VLAN;
        info.valid_elements = BCM_FLOW_MATCH_PORT_VALID |
                              BCM_FLOW_MATCH_INNER_VLAN_VALID;
    } else if (key_type == bcmVlanTranslateKeyPortGroupDouble) {
        info.criteria = BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN_STACKED;
        info.valid_elements = BCM_FLOW_MATCH_PORT_VALID |
                              BCM_FLOW_MATCH_VLAN_VALID |
                              BCM_FLOW_MATCH_INNER_VLAN_VALID;
    }
    info.vlan = outer_vlan;
    info.inner_vlan = inner_vlan;
    info.port = port;
    if (BCMINT_FLOW_VP_RESERVED != cfg->svp) {
        BCM_GPORT_FLOW_PORT_ID_SET(info.flow_port, cfg->svp);
    }
    if (BCMINT_FLOW_VFI_RESERVED != cfg->vfi) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, cfg->vfi, &(info.vpn)));
    }
    if (BCMINT_FLOW_L3_IIF_RESERVED != cfg->l3_iif) {
        info.intf_id = cfg->l3_iif;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (vlan_xlate_user_data->cb(unit, &info, 0, NULL,
                                  vlan_xlate_user_data->user_data));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all entries in ingress translation tables.
 *
 * This function is used to traverse all ingress translation entries and
 * call callback function.
 *
 * \param [in] unit              Unit number.
 * \param [in] cb                Callback function of flow match traverse.
 * \param [in] user_data         User data to a call back.
 *
 * \retval SHR_E_NONE            No errors.
 * \retval !SHR_E_NONE           Failure.
 */
static int
xfs_flow_match_vlan_ing_xlate_traverse(int unit,
                                       bcm_flow_match_traverse_cb cb,
                                       void *user_data)
{
    vlan_xlate_user_data_t vlan_xlate_user_data;

    SHR_FUNC_ENTER(unit);

    vlan_xlate_user_data.cb = cb;
    vlan_xlate_user_data.user_data = user_data;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_ing_xlate_traverse(unit,
                                           xfs_flow_vlan_ing_xlate_traverse_cb,
                                           &vlan_xlate_user_data));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the parameters for port encap configuration.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Egress encap info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_port_encap_param_validation(int unit,
                                     bcmint_flow_hw_opt_type_t opt,
                                     bcm_flow_port_encap_t *info)
{
    int vp = -1;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    int current_cascaded = 0, new_cascaded = 0;

    SHR_FUNC_ENTER(unit);

    vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
    if (vp == -1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    bcmi_ltsw_virtual_vp_info_init(&vp_info);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info));
    if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_FLOW)) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Flow port only!\n")));
    }

    if (info->options & BCM_FLOW_PORT_ENCAP_OPTION_REPLACE) {
        /*
         * CASCADED state could not be updated as the cascaded resource
         * management does not support the case.
         */
        if ((vp_info.flags & BCMI_LTSW_VIRTUAL_VP_CASCADED)) {
            current_cascaded = 1;
        }

        if (info->valid_elements & BCM_FLOW_PORT_ENCAP_FLAGS_VALID) {
            if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_EGRESS_CASCADED) {
                new_cascaded = 1;
            }
        }

        if (current_cascaded != new_cascaded) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    if (info->valid_elements & BCM_FLOW_PORT_ENCAP_FLAGS_VALID) {
        if ((info->flags & BCM_FLOW_PORT_ENCAP_FLAG_EGRESS_CASCADED) &&
            !(info->valid_elements & BCM_FLOW_PORT_ENCAP_EGRESS_IF_VALID)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    /* Validate flow option. */
    if (info->flow_option == BCMINT_FLOW_OPT_ID_IPV6) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Option IPv6 not supported!\n")));
    }

    /* Validate opt vs valid elements. */
    if ((opt == HW_OPT_SET) &&
        (!(info->options & BCM_FLOW_PORT_ENCAP_OPTION_CLEAR))) {
        uint32_t supported_elements = BCM_FLOW_PORT_ENCAP_CLASS_ID_VALID |
                                      BCM_FLOW_PORT_ENCAP_NETWORK_GROUP_VALID |
                                      BCM_FLOW_PORT_ENCAP_DVP_GROUP_VALID |
                                      BCM_FLOW_PORT_ENCAP_EGRESS_IF_VALID |
                                      BCM_FLOW_PORT_ENCAP_IP4_ID_VALID |
                                      BCM_FLOW_PORT_ENCAP_PORT_VALID |
                                      BCM_FLOW_PORT_ENCAP_FLAGS_VALID |
                                      BCM_FLOW_PORT_ENCAP_MTU_VALID |
                                      BCM_FLOW_PORT_ENCAP_VLAN_PRI_MAP_ID_VALID |
                                      BCM_FLOW_PORT_ENCAP_DST_PORT_VALID;
        if (info->valid_elements & (~supported_elements)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "elements:supported(%d)/provided(%d)!\n"),
                                            supported_elements, info->valid_elements));
        }
    }

    /* Validate elements. */
    if (opt == HW_OPT_SET) {
        if (info->valid_elements & BCM_FLOW_PORT_ENCAP_EGRESS_IF_VALID) {
            int nh_idx;
            bcmi_ltsw_l3_egr_obj_type_t nh_type;

            if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_egress_obj_id_resolve(unit,
                                                    info->egress_if,
                                                    &nh_idx,
                                                    &nh_type));
            if ((nh_type != BCMI_LTSW_L3_EGR_OBJ_T_UL) &&
                (nh_type != BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
        if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT) {
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_DST_PORT_VALID) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set IPv4 ID info to LT entry handle.
 *
 * \param [in]  unit           Unit number.
 * \param [in]  info           Egress encap info structure.
 * \param [in]  entry_hd_read  LT handle.
 * \param [in]  entry_hd       LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_port_encap_ipv4_id_set(int unit,
                             bcm_flow_port_encap_t *info,
                             bcmlt_entry_handle_t entry_hd_read,
                             bcmlt_entry_handle_t entry_hd)
{
    bcmi_ltsw_tunnel_encap_seq_profile_t entry;
    int idx = 0;
    int old_idx = 0;
    int vp = -1;
    int seq_num_tab_idx = 0;
    int pipe_num, pipe;
    uint32_t seq_num = 0;
    uint64_t get_val;

    SHR_FUNC_ENTER(unit);

    vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);

    SHR_IF_ERR_VERBOSE_EXIT
       (bcmlt_entry_field_get(entry_hd_read, SEQ_NUM_PROFILE_IDXs,
                              &get_val));
    old_idx = (uint32_t)get_val;
    if (old_idx != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_tunnel_encap_seq_profile_delete(unit, old_idx));
    }

    SHR_IF_ERR_VERBOSE_EXIT
       (bcmlt_entry_field_get(entry_hd_read, SEQ_NUM_COUNTER_IDXs,
                              &get_val));
    old_idx = (uint32_t)get_val;
    if (old_idx != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_tunnel_encap_seq_num_free(unit, ENCAP_SEQ_NUM_TYPE_VP,
                                                 old_idx));
    }

    if (info->options & BCM_FLOW_PORT_ENCAP_OPTION_CLEAR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, SEQ_NUM_PROFILE_IDXs, 0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, SEQ_NUM_COUNTER_IDXs, 0));
    } else {
        if (info->valid_elements & BCM_FLOW_PORT_ENCAP_IP4_ID_VALID) {
            sal_memset(&entry, 0, sizeof(entry));
            entry.enable = 1;
            entry.update_en = 1;
            entry.increment = 1;
            entry.reserved_value = 0xFFFF0000;
            entry.mask = 0xFFFF0000;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_tunnel_encap_seq_profile_add(unit, &entry, &idx));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, SEQ_NUM_PROFILE_IDXs, idx));

            seq_num_tab_idx = vp;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_tunnel_encap_seq_num_alloc(unit, 0,
                                                      ENCAP_SEQ_NUM_TYPE_VP,
                                                      &seq_num_tab_idx));
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_FLAGS_VALID) {
                if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_IP4_ID_SET_FIXED) {
                    seq_num = info->ip4_id;
                } else if (info->flags &
                               BCM_FLOW_PORT_ENCAP_FLAG_IP4_ID_SET_RANDOM) {
                    seq_num = (uint16) (sal_time_usecs() & 0xFFFF);
                } else {
                    seq_num = 0;
                }
            } else {
                seq_num = 0;
            }
            pipe_num = bcmi_ltsw_dev_max_pp_pipe_num(unit);
            for (pipe = 0; pipe < pipe_num; pipe++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_tunnel_encap_seq_num_set(unit, seq_num_tab_idx,
                                                        pipe, seq_num));
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, SEQ_NUM_COUNTER_IDXs,
                                       seq_num_tab_idx));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Determine whether termination is based on Ipv6.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  info      Tunnel termination info structure.
 *
 * \retval TRUE    Terminaiton on IPv6.
 * \retval FALSE   Terminaiton on IPv4.
 */
static int
xfs_flow_tunnel_term_is_ipv6(int unit,
                            bcm_flow_tunnel_terminator_t *info)
{
    if ((info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_VALID) ||
        (info->flow_handle == BCMINT_FLOW_ID_VXLAN)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*!
 * \brief Enable/Disable terminaiton status on loopback port.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  enable    Termination status.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_term_bud_loopback_set(int unit, uint8_t enable)
{
    int port;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t value;
    bcm_pbmp_t pbmp;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(pbmp);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_LB, &pbmp));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_CONTROLs, &entry_hd));
    BCM_PBMP_ITER(pbmp, port) {
        value = enable;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(entry_hd, LOOPBACK_PORTSs, port,
                                         &value, 1));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_port_control_set(unit, port, bcmPortControlVxlanEnable,
                                       enable));
       break;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hd, LOOPBACK_PORTS_MASK_ACTIONs,
                                      ORs));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hd, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the parameters for tunnel termination configuration.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Tunnel termination info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_term_param_validation(int unit, bcmint_flow_hw_opt_type_t opt,
                                      bcm_flow_tunnel_terminator_t *info)
{
    uint32_t supported_items = 0;

    SHR_FUNC_ENTER(unit);

    /* Validate flow option vs criteria. */
    if (info->flow_option == BCMINT_FLOW_OPT_ID_LOOKUP_IPV6_DIP_TERM_TUNNEL) {
        if (!(info->valid_elements  & BCM_FLOW_TUNNEL_TERM_DIP6_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "DIP6 must be valid for \
                                            LOOKUP_IPV6_DIP_TERM_TUNNEL!\n")));
        }
    }

    /* Validate flow handle vs elements. */
    if ((info->flow_handle == BCMINT_FLOW_ID_VXLAN) &&
        (!(info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_VALID))) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "DIP6 must be valid for VXLAN IPv6!\n")));
    }

    if (info->flow_handle == BCMINT_FLOW_ID_VXLAN) {
        supported_items = BCM_FLOW_TUNNEL_TERM_DIP6_VALID;
    } else if (info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN) {
        supported_items = BCM_FLOW_TUNNEL_TERM_DIP_VALID;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Wrong flow handle!\n")));
    }

    if (info->valid_elements & (~supported_items)) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Elements:supported(%d)/provided(%d)!\n"),
                                        supported_items, info->valid_elements));
    }

     /* Validate contorl flags */
     supported_items = BCM_TUNNEL_TERM_USE_OUTER_QOS |
                       BCM_TUNNEL_TERM_RPF_FAIL_DROP  |
                       BCM_TUNNEL_REPLACE;
     if (info->flags & (~supported_items)) {
         SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                             (BSL_META_U(unit, "Flags:supported(%d)/provided(%d)!\n"),
                                         supported_items, info->flags));
     }

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Determine the logical table based on termination configuration.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  info      Tunnel termination info structure.
 * \param [out] lt_name   Logical table for tunnel termination.
 *
 * \retval NONE
 */
static void
xfs_flow_tunnel_term_lt_determine(int unit,
                                  bcm_flow_tunnel_terminator_t *info,
                                  const char **lt_name)
{
    if (xfs_flow_tunnel_term_is_ipv6(unit, info)) {
        *lt_name = L2_TUNNEL_IPV6_DIP_TABLEs;
    } else {
        *lt_name = L2_TUNNEL_IPV4_DIP_TABLEs;
    }
}

/*!
 * \brief Determine the termination criteria based on logical table.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  lt_name   Logical table for tunnel termination.
 * \param [out] info      Tunnel termination info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_term_criteria_determine(int unit,
                                        const char *lt_name,
                                        bcm_flow_tunnel_terminator_t *info)
{
    SHR_FUNC_ENTER(unit);

    if (lt_name == L2_TUNNEL_IPV6_DIP_TABLEs) {
        info->valid_elements = BCM_FLOW_TUNNEL_TERM_DIP6_VALID;
        info->flow_handle = BCMINT_FLOW_ID_VXLAN;
        info->type = bcmTunnelTypeVxlan6;
    } else if (lt_name == L2_TUNNEL_IPV4_DIP_TABLEs) {
        info->valid_elements = BCM_FLOW_TUNNEL_TERM_DIP_VALID;
        info->flow_handle = BCMINT_FLOW_ID_CLASSIC_VXLAN;
        info->type = bcmTunnelTypeVxlan;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad lt:%s!\n"), lt_name));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set key info to LT entry handle.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  info      Tunnel termination info structure.
 * \param [in]  entry_hd  LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_term_key_set(int unit,
                             bcm_flow_tunnel_terminator_t *info,
                             bcmlt_entry_handle_t entry_hd)
{
    uint64_t ipv6_val[2] = {0};

    SHR_FUNC_ENTER(unit);

    if (xfs_flow_tunnel_term_is_ipv6(unit, info)) {
        bcmi_ltsw_util_ip6_to_uint64(ipv6_val, &(info->dip6));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(entry_hd, IP_HDR_DIPs, 0,
                                         ipv6_val, 2));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, IP_HDR_DIPs, info->dip));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get key info from LT entry handle.
 *
 * \param [in]   unit      Unit number.
 * \param [out]  info      Tunnel termination info structure.
 * \param [in]   entry_hd  LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_term_key_get(int unit,
                             bcm_flow_tunnel_terminator_t *info,
                             const bcmlt_entry_handle_t entry_hd)
{
    uint64_t get_val;
    uint64_t ipv6_val[2] = {0};
    uint32_t act_cnt = 0;

    SHR_FUNC_ENTER(unit);

    if (xfs_flow_tunnel_term_is_ipv6(unit, info)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hd, IP_HDR_DIPs, 0,
                                         ipv6_val, 2, &act_cnt));
        bcmi_ltsw_util_uint64_to_ip6(&(info->dip6), ipv6_val);
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, IP_HDR_DIPs, &get_val));
        info->dip = get_val;
    }

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set data info to LT entry handle.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  info      Tunnel termination info structure.
 * \param [in]  entry_hd  LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_term_data_set(int unit,
                              bcm_flow_tunnel_terminator_t *info,
                              bcmlt_entry_handle_t entry_hd)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, ENTRY_VALIDs, 0x1));

    if (info->multicast_flag == BCM_FLOW_MULTICAST_TUNNEL_STATE_BUD_ENABLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, NETWORK_RECEIVERS_PRESENTs, TRUE));
         if ((info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN) ||
            (info->flow_handle == BCMINT_FLOW_ID_VXLAN)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_flow_tunnel_term_bud_loopback_set(unit, TRUE));
        }
    } else if (info->multicast_flag == BCM_FLOW_MULTICAST_TUNNEL_STATE_BUD_DISABLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, NETWORK_RECEIVERS_PRESENTs, FALSE));
    } else {
        /* Do nothing */
    }
    if (info->flags & BCM_TUNNEL_TERM_USE_OUTER_QOS) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, USE_OUTER_HEADER_PHBs, TRUE));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, USE_OUTER_HEADER_PHBs, FALSE));
    }

    if (info->flags & BCM_TUNNEL_TERM_RPF_FAIL_DROP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd,
                                   IPMC_L3_IIF_OR_RPA_ID_CHECK_FAIL_DROPs,
                                   TRUE));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd,
                                   IPMC_L3_IIF_OR_RPA_ID_CHECK_FAIL_DROPs,
                                   FALSE));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get data info from LT entry handle.
 *
 * \param [in]   unit      Unit number.
 * \param [out]  info      Tunnel termination info structure.
 * \param [in]   entry_hd  LT handle.
 * \param [out]  valid     Entry valid status.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_term_data_get(int unit,
                              bcm_flow_tunnel_terminator_t *info,
                              const char *lt_name,
                              const bcmlt_entry_handle_t entry_hd,
                              uint8_t *valid)
{
    uint64_t get_val;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, NETWORK_RECEIVERS_PRESENTs, &get_val));
    if (get_val != 0) {
        info->multicast_flag |= BCM_FLOW_MULTICAST_TUNNEL_STATE_BUD_ENABLE;
    } else {
        info->multicast_flag |= BCM_FLOW_MULTICAST_TUNNEL_STATE_BUD_DISABLE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, USE_OUTER_HEADER_PHBs, &get_val));
    if (get_val != 0) {
        info->flags |= BCM_TUNNEL_TERM_USE_OUTER_QOS;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, IPMC_L3_IIF_OR_RPA_ID_CHECK_FAIL_DROPs,
                               &get_val));
    if (get_val != 0) {
        info->flags |= BCM_TUNNEL_TERM_RPF_FAIL_DROP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, ENTRY_VALIDs, &get_val));
    if (get_val != 0) {
        *valid = TRUE;
    } else {
        *valid = FALSE;
    }

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse HW table based on tunnel terminator.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     cb            User callback function.
 * \param [in]     user_data     User context data.
 * \param [in]     lt_name       LT name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_term_hash_table_traverse(int unit,
                                         bcm_flow_tunnel_terminator_traverse_cb cb,
                                         void *user_data,
                                         const char *lt_name)
{
    int rv = SHR_E_NONE;
    bcm_flow_tunnel_terminator_t info = {0};
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint8_t valid = 0 ;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    while ((rv = bcmi_lt_entry_commit(dunit, entry_hd, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        bcm_flow_tunnel_terminator_t_init(&info);

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_tunnel_term_criteria_determine(unit, lt_name, &info));

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_tunnel_term_key_get(unit, &info, entry_hd));

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_tunnel_term_data_get(unit, &info, lt_name, entry_hd,
                                           &valid));
        if (valid) {
            SHR_IF_ERR_VERBOSE_EXIT
                (cb(unit, &info, 0, NULL, user_data));
        }
    }
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse HW table based on tunnel terminator.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     lt_name       LT name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_term_hash_table_destroy(int unit, const char *lt_name)
{
    int rv = SHR_E_NONE;
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t get_val;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    while ((rv = bcmi_lt_entry_commit(dunit, entry_hd, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, ENTRY_VALIDs, &get_val));
        if (get_val != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_DELETE,
                                      BCMLT_PRIORITY_NORMAL));
        }
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy all flow tunnel terminator entry.
 *
 * \param [in]     unit          Unit Number.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_term_destroy_all(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_tunnel_term_hash_table_destroy(unit,
                                                 L2_TUNNEL_IPV4_DIP_TABLEs));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_tunnel_term_hash_table_destroy(unit,
                                                 L2_TUNNEL_IPV6_DIP_TABLEs));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set tinnel initiator DIP and idx to flow port.
 *
 * \param [in] unit        Unit number.
 * \param [in] flow_port   Flow GPORT.
 * \param [in] tnl_idx     Tunnel index.
 * \param [in] ip6_addr    IPv6 address.
 * \param [in] ip_addr     IPv4 address.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_initiator_dip_idx_set(int unit, bcm_gport_t flow_port,
                                      uint32_t tnl_idx, bcm_ip6_t *ip6_addr,
                                      bcm_ip_t *ip_addr)
{
    int vp;
    int dunit = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t set_val;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_type_vp_get(unit, flow_port, &vp));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_used_get(unit, vp, BCMI_LTSW_VP_TYPE_ANY));

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_DVPs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, DVPs, vp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TUNNEL_IDX_0s, tnl_idx));
    if (ip_addr != NULL) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, IPV6_DIP_LOs, *ip_addr));
    } else if (ip6_addr != NULL) {
        bcmi_ltsw_util_ip6_half_to_uint64(&set_val, ip6_addr, 1);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, IPV6_DIP_LOs, set_val));

    } else {
        set_val = 0;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, IPV6_DIP_LOs, set_val));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));
exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get tinnel initiator DIP and idx from flow port.
 *
 * \param [in]  unit        Unit number.
 * \param [in]  flow_port   Flow GPORT.
 * \param [out] tnl_idx     Tunnel index.
 * \param [out] ip6_addr    IPv6 address.
 * \param [out] ip_addr     IPv4 address.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_initiator_dip_idx_get(int unit, bcm_gport_t flow_port,
                                      uint32_t *tnl_idx, bcm_ip6_t *ip6_addr,
                                      bcm_ip_t *ip_addr)
{
    int vp;
    int dunit = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t get_val;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_type_vp_get(unit, flow_port, &vp));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_used_get(unit, vp, BCMI_LTSW_VP_TYPE_ANY));

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_DVPs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, DVPs, vp));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, TUNNEL_IDX_0s, &get_val));
    if (tnl_idx != NULL) {
        *tnl_idx = (int)get_val;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, IPV6_DIP_LOs, &get_val));
    if (ip_addr != NULL) {
        *ip_addr = (bcm_ip_t)get_val;
    }
    if (ip6_addr != NULL) {
        bcmi_ltsw_util_uint64_to_ip6_half(ip6_addr, &get_val, 1);
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get data info from LT entry handle.
 *
 * \param [in]   unit      Unit number.
 * \param [in]   tnl_idx   Index to tunnel initiator hardware table.
 * \param [out]  info      Tunnel initiator info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_initiator_get(int unit,
                              int tnl_idx,
                              bcm_flow_tunnel_initiator_t *info)
{
    bcmlt_entry_handle_t entry_hdl1 = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t entry_hdl2 = BCMLT_INVALID_HDL;
    int dunit;
    uint8_t ipv6 = 0;
    uint64_t get_val, get_val2;
    uint64_t get_ipv6_val[2];
    uint32_t act_cnt = 0;
    int evpn_ptr;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_0s, &entry_hdl1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_1s, &entry_hdl2));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, EGR_L3_TUNNEL_IDX_0s, tnl_idx));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, EGR_L3_TUNNEL_IDX_0s, tnl_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl1, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl2, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, EDIT_CTRL_IDs, &get_val));
    if (get_val == EGR_L3_TUNNEL_0_EDIT_CTRL_ID_VXLAN_IPV4) {
        info->type = bcmTunnelTypeVxlan;
        info->flow_handle = BCMINT_FLOW_ID_CLASSIC_VXLAN;
        ipv6 = 0;
    } else if (get_val == EGR_L3_TUNNEL_0_EDIT_CTRL_ID_VXLAN_IPV6) {
        info->type = bcmTunnelTypeVxlan6;
        info->flow_handle = BCMINT_FLOW_ID_VXLAN;
        ipv6 = 1;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Unsupported EDIT_CTRL_IDs:%d!\n"),
                                        (int)get_val));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl2, IPV6_DST_ADDR_LOs,
                               &get_val));
    if (ipv6) {
        bcmi_ltsw_util_uint64_to_ip6_half(&(info->dip6), &get_val, 1);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl2, IPV6_DST_ADDR_HI_0s,
                                   &get_val));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl2, IPV6_DST_ADDR_HI_1s,
                                   &get_val2));
        get_val = get_val2 << 32 | get_val;
        bcmi_ltsw_util_uint64_to_ip6_half(&(info->dip6), &get_val, 0);
    } else {
        info->dip = (bcm_ip_t)(get_val);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_get(entry_hdl1, IPV6_SRC_ADDRs, 0,
                                     get_ipv6_val, 2, &act_cnt));
    if (ipv6) {
        bcmi_ltsw_util_uint64_to_ip6(&(info->sip6), get_ipv6_val);
    } else {
        info->sip = (bcm_ip_t)get_ipv6_val[0];
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, TOS_OR_EXP_REMARK_BASE_PTRs,
                               &get_val));
    if (get_val == 0) {
        info->dscp_ecn_sel = bcmTunnelDscpEcnAssign;
    } else {
        info->dscp_ecn_sel = bcmTunnelDscpEcnMap;
        /*
         * Only support bcmiQosMapTypeTnlEcnDscpEgress type.
         */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_construct(unit, get_val,
                                            bcmiQosMapTypeTnlEcnDscpEgress,
                                            &(info->dscp_ecn_map)));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, TTL_VALUEs, &get_val));
    info->ttl = get_val;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, IPV6_FLOW_LABEL_SELs, &get_val));
    if (get_val == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl2, TUNNEL_WORD_0s, &get_val));
        info->flow_label = (get_val >> TUNNEL_WORD_0_FLOW_LABEL_SFT) &
                           TUNNEL_WORD_0_FLOW_LABEL_MSK;
    } else {
        info->flow_option = BCMINT_FLOW_OPT_ID_IPV6_FLOW_LABEL_USE_ENTROPY;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_qos_vxlan_flags_map_ptr_get(unit, 1, 1,
                                               &evpn_ptr));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, TUNNEL_WORD_1s, &get_val));
    get_val >>= TUNNEL_WORD_1_REMAP_PTR_SFT;
    get_val  &= TUNNEL_WORD_1_REMAP_PTR_MSK;
    if (get_val == evpn_ptr) {
        info->flags |= BCM_TUNNEL_INIT_EVPN_ENABLE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl2, TUNNEL_WORD_2s, &get_val));
    info->udp_dst_port = (get_val >> TUNNEL_WORD_2_UDP_DST_PORT_SFT) &
                       TUNNEL_WORD_2_UDP_DST_PORT_MSK;
    info->udp_src_port = (get_val >> TUNNEL_WORD_2_UDP_SRC_PORT_SFT) &
                       TUNNEL_WORD_2_UDP_SRC_PORT_MSK;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, TTL_OR_MPLS_CTRLs, &get_val));
    if ((get_val >> TTL_OR_MPLS_CTRL_FIXED_SRC_PORT_SFT) &
        TTL_OR_MPLS_CTRL_FIXED_SRC_PORT_MSK) {

        info->flags |= BCM_TUNNEL_INIT_FIXED_UDP_SRC_PORT;
    }
    if ((get_val >> TTL_OR_MPLS_CTRL_TTL_SFT) &
        TTL_OR_MPLS_CTRL_TTL_MSK) {

        info->flags |= BCM_TUNNEL_INIT_USE_OUTER_TTL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, IP_HDR_DF_CTRLs, &get_val));
    info->flags |= (get_val & EGR_L3_TUNNEL_0_IP_HDR_DF_CTRL_IP6_PLD) ?
                   BCM_TUNNEL_INIT_IPV6_SET_DF : 0;
    info->flags |= (get_val & EGR_L3_TUNNEL_0_IP_HDR_DF_CTRL_IP4_PLD) ?
                   BCM_TUNNEL_INIT_IPV4_SET_DF : 0;
    info->flags |= (get_val & EGR_L3_TUNNEL_0_IP_HDR_DF_CTRL_INHERIT_IP4_PLD) ?
                   BCM_TUNNEL_INIT_USE_INNER_DF : 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl2, TUNNEL_WORD_0s, &get_val));
    info->flow_label = (get_val >> TUNNEL_WORD_0_FLOW_LABEL_SFT) &
                       TUNNEL_WORD_0_FLOW_LABEL_MSK;
    info->dscp = (get_val >> TUNNEL_WORD_0_DSCP_SFT) & TUNNEL_WORD_0_DSCP_MSK;
    info->ecn  = (get_val >> TUNNEL_WORD_0_ECN_SFT)  & TUNNEL_WORD_0_ECN_MSK;

exit:
    if (entry_hdl1 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl1);
        entry_hdl1 = BCMLT_INVALID_HDL;
    }
    if (entry_hdl2 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl2);
        entry_hdl2 = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the parameters for tunnel initiator configuration.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Tunnel initiator info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_initiator_param_validation(int unit,
                                           bcmint_flow_hw_opt_type_t opt,
                                           bcm_flow_tunnel_initiator_t *info)
{
    uint32_t tnl_idx;
    uint32_t soft_tnl_idx;
    uint32_t supported_items = 0;
    uint32 ref_cnt = 0;
    bcmi_ltsw_tunnel_type_t tnl_type;

    SHR_FUNC_ENTER(unit);

    if (opt == HW_OPT_SET) {
        /* Validate tunnel type. */
        if ((info->type != bcmTunnelTypeVxlan) &&
            (info->type != bcmTunnelTypeVxlan6)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Bad tunnel type:%d!\n"),
                                            info->type));
        }

        /* Validate tunnel type vs flow handle. */
        if (((info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN) &&
            (info->type != bcmTunnelTypeVxlan)) ||
            ((info->flow_handle == BCMINT_FLOW_ID_VXLAN) &&
            (info->type != bcmTunnelTypeVxlan6))) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Type vs handle mismatch:%d,%d!\n"),
                                            info->type, info->flow_handle));
        }

        /* Validate flow handle vs elements. */
        if (info->flow_handle == BCMINT_FLOW_ID_VXLAN) {
            supported_items = BCM_FLOW_TUNNEL_INIT_TTL_VALID |
                              BCM_FLOW_TUNNEL_INIT_SIP6_VALID |
                              BCM_FLOW_TUNNEL_INIT_DIP6_VALID |
                              BCM_FLOW_TUNNEL_INIT_FLOW_LABEL_VALID |
                              BCM_FLOW_TUNNEL_INIT_DSCP_ECN_VALID |
                              BCM_FLOW_TUNNEL_INIT_UDP_DPORT_VALID |
                              BCM_FLOW_TUNNEL_INIT_UDP_SPORT_VALID;
        } else if (info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN) {
            supported_items = BCM_FLOW_TUNNEL_INIT_TTL_VALID |
                              BCM_FLOW_TUNNEL_INIT_DIP_VALID |
                              BCM_FLOW_TUNNEL_INIT_SIP_VALID |
                              BCM_FLOW_TUNNEL_INIT_DSCP_ECN_VALID |
                              BCM_FLOW_TUNNEL_INIT_UDP_DPORT_VALID |
                              BCM_FLOW_TUNNEL_INIT_UDP_SPORT_VALID;
        } else {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Wrong flow handle!\n")));
        }

        if (info->valid_elements & (~supported_items)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Elements:supported(%d)/provided(%d)!\n"),
                                            supported_items, info->valid_elements));
        }

        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_TTL_VALID) {
            if (!BCM_TTL_VALID(info->ttl)) {
                SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                    (BSL_META_U(unit, "Bad TTL:%d!\n"), info->ttl));
            }
        }
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DSCP_VALID) {
            if (info->dscp > 63 || info->dscp < 0) {
                SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                    (BSL_META_U(unit, "Bad dscp:%d!\n"),
                                                info->dscp));
            }
        }

        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DSCP_ECN_VALID) {
            if (info->dscp > 63 || info->dscp < 0) {
                SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                    (BSL_META_U(unit, "Bad dscp:%d!\n"),
                                                info->dscp));
            }

            if (info->ecn > 3) {
                SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                    (BSL_META_U(unit, "Bad ecn:%d!\n"),
                                                info->ecn));
            }

            if ((info->dscp_ecn_sel < bcmTunnelDscpEcnAssign) ||
                (info->dscp_ecn_sel >= bcmTunnelDscpEcnCount)) {
                SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                    (BSL_META_U(unit, "Bad dscp_ecn_sel:%d!\n"),
                                                info->dscp_ecn_sel));
            }
        }

        if (info->flags & BCM_TUNNEL_REPLACE) {
            BCMI_LTSW_GPORT_TUNNEL_ID_GET(info->tunnel_id, tnl_type,
                                          soft_tnl_idx);
            SHR_IF_ERR_VERBOSE_EXIT
                ((tnl_type == bcmiTunnelTypeFlexFlow) ? SHR_E_NONE : SHR_E_PARAM);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_ref_get(unit,
                                                 BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                                 BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                                 tnl_idx, &ref_cnt));
            if (!ref_cnt) {
                SHR_ERR_EXIT(SHR_E_NOT_FOUND);
            }
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_flow_tunnel_initiator_dip_idx_get(unit, info->flow_port,
                                                   &tnl_idx, NULL, NULL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_ref_get(unit,
                                                 BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                                 BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                                 tnl_idx, &ref_cnt));
            if (ref_cnt) {
                SHR_ERR_EXIT(SHR_E_EXISTS);
            }
        }
    } else {
        /* opt = get, clear*/
        BCMI_LTSW_GPORT_TUNNEL_ID_GET(info->tunnel_id, tnl_type, soft_tnl_idx);
        SHR_IF_ERR_VERBOSE_EXIT
            ((tnl_type == bcmiTunnelTypeFlexFlow) ? SHR_E_NONE: SHR_E_PARAM);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
        if (tnl_idx == -1) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Tunnel not provided!\n")));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_get(unit,
                                             BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                             BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                             tnl_idx, &ref_cnt));
        if (!ref_cnt) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_NOT_FOUND,
                                (BSL_META_U(unit, "Tunnel not exist!\n")));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate tunnel initiator entry hash(signature).
 *
 * \param [in]  unit   Unit number.
 * \param [in]  buf    Tunnel initiator entry information.
 * \param [out] hash   Hash(signature) calculated value.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_initiator_hash_calc(int unit, void *buf, uint16_t *hash)
{
    bcm_flow_tunnel_initiator_t tnl_entry;
    bcm_flow_tunnel_initiator_t *info;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(buf, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    info = (bcm_flow_tunnel_initiator_t *)buf;

    bcm_flow_tunnel_initiator_t_init(&tnl_entry);
    tnl_entry.type = info->type;

    if (tnl_entry.type == bcmTunnelTypeVxlan) {
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_SIP_VALID) {
            tnl_entry.sip = info->sip;
        }
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DIP_VALID) {
            tnl_entry.dip = info->dip;
        }
     } else if (tnl_entry.type == bcmTunnelTypeVxlan6) {
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_SIP6_VALID) {
            sal_memcpy(tnl_entry.sip6, info->sip6, sizeof(bcm_ip6_t));
        }
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DIP6_VALID) {
            sal_memcpy(tnl_entry.dip6, info->dip6, sizeof(bcm_ip6_t));
        }

     } else {
         SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                             (BSL_META_U(unit, "Bad tunnel type:%d!\n"),
                                         tnl_entry.type));
     }
     /* Removed. Fixed value. */
     /*
     tnl_entry.udp_dst_port = info->udp_dst_port;
     tnl_entry.udp_src_port = info->udp_src_port;
     */

     /* Calculate hash */
    *hash = _shr_crc16(0, (uint8 *)&tnl_entry,
                       sizeof(bcm_flow_tunnel_initiator_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compares tunnel initiator entry with entry at specified index in chip.
 *
 * \param [in]  unit        Unit number.
 * \param [in]  buf         Tunnel initiator entry to compare.
 * \param [in]  tnl_idx     Entry index in the chip to compare.
 * \param [out] cmp_result  Compare result.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_flow_tunnel_initiator_cmp(int unit, int tnl_idx, void *buf, int *cmp_result)
{
    bcm_flow_tunnel_initiator_t *tnl_init_tmp = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(buf, SHR_E_PARAM);
    SHR_NULL_CHECK(cmp_result, SHR_E_PARAM);

    SHR_ALLOC(tnl_init_tmp, sizeof(bcm_tunnel_initiator_t),
              "tnlInitTmp");
    SHR_NULL_CHECK(tnl_init_tmp, SHR_E_MEMORY);
    sal_memset(tnl_init_tmp, 0, sizeof(bcm_tunnel_initiator_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_tunnel_initiator_get(unit, tnl_idx, tnl_init_tmp));

    *cmp_result = sal_memcmp(buf, tnl_init_tmp,
                             sizeof(bcm_flow_tunnel_initiator_t));

exit:
    SHR_FREE(tnl_init_tmp);

    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert tunnel initiator to given hardware entry.
 *
 * \param [in] unit  Unit number.
 * \param [in] flags Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index Entry index.
 * \param [in] entry Entry content of bcm_flow_tunnel_initiator_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_flow_tunnel_initiator_insert(int unit,
                                 uint32_t flags,
                                 int tnl_idx,
                                 void *entry)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl1 = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t entry_hdl2 = BCMLT_INVALID_HDL;
    int ipv6;
    uint64 set_val = {0};
    uint64 set_ipv6_val[2] = {0};
    bcm_flow_tunnel_initiator_t *info = entry;
    uint64 tunnel_word_0_val = 0;
    uint64 tunnel_word_1_val = 0;
    int remark_base_ptr = 0;
    bcmi_ltsw_qos_map_type_t qos_type;
    bcmi_ltsw_sbr_profile_tbl_hdl_t pth = BCMI_LTSW_SBR_PTH_EGR_L3_TNL;
    bcmi_ltsw_sbr_profile_ent_type_t ent_type;
    int sbr_idx;
    const char *fld_desc = NULL;
    int rv = SHR_E_NONE;
    bool tunnel_word_2_valid = 0;
    uint32 tunnel_word_2_val = 0;
    uint32 ttl_or_mpls_ctrl = 0;
    uint64 get_val;
    int evpn_enable = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (info->type == bcmTunnelTypeVxlan6) {
        ipv6 = 1;
    } else {
        ipv6 = 0;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_0s, &entry_hdl1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_1s, &entry_hdl2));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, EGR_L3_TUNNEL_IDX_0s, tnl_idx));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, EGR_L3_TUNNEL_IDX_0s, tnl_idx));

    rv = bcmlt_field_desc_get(dunit, EGR_L3_TUNNEL_1s,
                              TUNNEL_WORD_2s, &fld_desc);
    if (SHR_SUCCESS(rv)) {
        tunnel_word_2_valid = 1;
    } else {
        tunnel_word_2_valid = 0;
    }

    if (info->flags & BCM_TUNNEL_REPLACE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl1, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl1, TUNNEL_WORD_1s,
                                   &tunnel_word_1_val));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hdl1, TUNNEL_WORD_1s));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl2, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl2, TUNNEL_WORD_0s,
                                   &tunnel_word_0_val));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hdl2, TUNNEL_WORD_0s));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl1, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl1, TTL_OR_MPLS_CTRLs, &get_val));
        ttl_or_mpls_ctrl = (uint32)get_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hdl1, TTL_OR_MPLS_CTRLs));

        if (tunnel_word_2_valid) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hdl2, BCMLT_OPCODE_LOOKUP,
                                      BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl2, TUNNEL_WORD_2s, &get_val));
            tunnel_word_2_val = (uint32)get_val;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_remove(entry_hdl2, TUNNEL_WORD_2s));
        }
    } else {
        if (info->type == bcmTunnelTypeVxlan6) {
            set_val = EGR_L3_TUNNEL_0_EDIT_CTRL_ID_VXLAN_IPV6;
        } else {
            set_val = EGR_L3_TUNNEL_0_EDIT_CTRL_ID_VXLAN_IPV4;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl1, EDIT_CTRL_IDs, set_val));

        tunnel_word_1_val &= ~(TUNNEL_WORD_1_PROTOCOL_MSK <<
                             TUNNEL_WORD_1_PROTOCOL_SFT);
        if ((info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN) ||
            (info->flow_handle == BCMINT_FLOW_ID_VXLAN)) {
            tunnel_word_1_val |= (UDP_PROTOCOL & TUNNEL_WORD_1_PROTOCOL_MSK) <<
                                 TUNNEL_WORD_1_PROTOCOL_SFT;
        }
    }

    sal_memset(set_ipv6_val, 0, sizeof(set_ipv6_val));
    if (ipv6) {
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_SIP6_VALID) {
            bcmi_ltsw_util_ip6_to_uint64(set_ipv6_val, &(info->sip6));
        }
    } else {
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_SIP_VALID) {
            set_ipv6_val[0] = info->sip;
        }
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl1, IPV6_SRC_ADDRs, 0,
                                     set_ipv6_val, 2));

    sal_memset(set_ipv6_val, 0, sizeof(set_ipv6_val));
    if (ipv6) {
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DIP6_VALID) {
            bcmi_ltsw_util_ip6_half_to_uint64(&set_ipv6_val[0], &(info->dip6), 0);
            bcmi_ltsw_util_ip6_half_to_uint64(&set_ipv6_val[1], &(info->dip6), 1);
        }
    } else {
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DIP_VALID) {
            set_ipv6_val[1] = info->dip;
        }
    }
    rv = bcmlt_field_desc_get(dunit, EGR_L3_TUNNEL_1s,
                              IPV6_DST_ADDR_HI_0s, &fld_desc);
    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl2, IPV6_DST_ADDR_HI_0s,
                                   set_ipv6_val[0] & 0xffffffff));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl2, IPV6_DST_ADDR_HI_1s,
                                   (set_ipv6_val[0] >> 32) & 0xffffffff));
    }

    /*
     * I flag is always set.
     * G flag is aways remarked.
     * If GBP is enabled by FP, G FLAG is remarked to 1.
     * If GBP is not enabled by FP, G FLAG is remarked to 0.
	 * BUM flag is not remarked and set to 0 if EVPN is not enabled.
	 * BUM flag is remarked if EVPN is enabled .
     */
    tunnel_word_1_val |= (1 << TUNNEL_WORD_1_I_FLAG_SFT);
    evpn_enable = (info->flags & BCM_TUNNEL_INIT_EVPN_ENABLE) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_qos_vxlan_flags_map_ptr_get(unit, 1, evpn_enable,
                                               &remark_base_ptr));
    remark_base_ptr   &= TUNNEL_WORD_1_REMAP_PTR_MSK;
    tunnel_word_1_val &= ~(TUNNEL_WORD_1_REMAP_PTR_MSK << TUNNEL_WORD_1_REMAP_PTR_SFT);
    tunnel_word_1_val |= (remark_base_ptr << TUNNEL_WORD_1_REMAP_PTR_SFT);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, IPV6_DST_ADDR_LOs, set_ipv6_val[1]));

    if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DSCP_ECN_VALID) {
        if (info->dscp_ecn_sel == bcmTunnelDscpEcnMap) {
            /* Get H/W remarking ptr. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_resolve(unit, info->dscp_ecn_map,
                                              &qos_type, &remark_base_ptr));
            if (qos_type != bcmiQosMapTypeTnlEcnDscpEgress) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (remark_base_ptr == 0) {
                /* Index 0 is used for QoS pipe mode. */
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl1, TOS_OR_EXP_REMARK_BASE_PTRs,
                                       remark_base_ptr));
        } else if (info->dscp_ecn_sel == bcmTunnelDscpEcnAssign) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl1,
                                       TOS_OR_EXP_REMARK_BASE_PTRs, 0));
            tunnel_word_0_val &= ~(TUNNEL_WORD_0_DSCP_MSK <<
                                 TUNNEL_WORD_0_DSCP_SFT);
            tunnel_word_0_val |= (info->dscp & TUNNEL_WORD_0_DSCP_MSK) <<
                                 TUNNEL_WORD_0_DSCP_SFT;
            tunnel_word_0_val &= ~(TUNNEL_WORD_0_ECN_MSK <<
                                 TUNNEL_WORD_0_ECN_SFT);
            tunnel_word_0_val |= (info->ecn & TUNNEL_WORD_0_ECN_MSK) <<
                                 TUNNEL_WORD_0_ECN_SFT;
        } else {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Bad dscp_ecn_sel:%d!\n"),
                                            info->dscp_ecn_sel));
        }
    }

    if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_UDP_SPORT_VALID) {
        tunnel_word_2_val &= ~(TUNNEL_WORD_2_UDP_SRC_PORT_MSK <<
                             TUNNEL_WORD_2_UDP_SRC_PORT_SFT);
        tunnel_word_2_val |= (info->udp_src_port & TUNNEL_WORD_2_UDP_SRC_PORT_MSK)
                             << TUNNEL_WORD_2_UDP_SRC_PORT_SFT;
    }
    if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_UDP_DPORT_VALID) {
        tunnel_word_2_val &= ~(TUNNEL_WORD_2_UDP_DST_PORT_MSK <<
                             TUNNEL_WORD_2_UDP_DST_PORT_SFT);
        tunnel_word_2_val |= ((info->udp_dst_port & TUNNEL_WORD_2_UDP_DST_PORT_MSK)
                             << TUNNEL_WORD_2_UDP_DST_PORT_SFT);
    }
    if (tunnel_word_2_valid) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl2, TUNNEL_WORD_2s,
                                   tunnel_word_2_val));
    }

    if (info->flags & BCM_TUNNEL_INIT_USE_OUTER_TTL) {
        ttl_or_mpls_ctrl &= ~(TTL_OR_MPLS_CTRL_TTL_MSK <<
                             TTL_OR_MPLS_CTRL_TTL_SFT);
        ttl_or_mpls_ctrl |= 1 << TTL_OR_MPLS_CTRL_TTL_SFT;
    } else {
        ttl_or_mpls_ctrl &= ~(TTL_OR_MPLS_CTRL_TTL_MSK <<
                             TTL_OR_MPLS_CTRL_TTL_SFT);
    }
    if (info->flags & BCM_TUNNEL_INIT_FIXED_UDP_SRC_PORT) {
        ttl_or_mpls_ctrl &= ~(1 << TTL_OR_MPLS_CTRL_FIXED_SRC_PORT_SFT);
        ttl_or_mpls_ctrl |= 1 << TTL_OR_MPLS_CTRL_FIXED_SRC_PORT_SFT;
    } else {
        ttl_or_mpls_ctrl &= ~(1 << TTL_OR_MPLS_CTRL_FIXED_SRC_PORT_SFT);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, TTL_OR_MPLS_CTRLs, ttl_or_mpls_ctrl));

    if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_TTL_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl1, TTL_VALUEs, info->ttl));
    }
    if (info->flow_option == BCMINT_FLOW_OPT_ID_IPV6_FLOW_LABEL_USE_ENTROPY) {
        /* Use entropy as flow label. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl1, IPV6_FLOW_LABEL_SELs, 1));
    } else {
        /* Use assigned flow label. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl1, IPV6_FLOW_LABEL_SELs, 0));
    }

    if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_FLOW_LABEL_VALID) {
        tunnel_word_0_val &= ~(TUNNEL_WORD_0_FLOW_LABEL_MSK <<
                             TUNNEL_WORD_0_FLOW_LABEL_SFT);
        tunnel_word_0_val |= (info->flow_label & TUNNEL_WORD_0_FLOW_LABEL_MSK) <<
                            TUNNEL_WORD_0_FLOW_LABEL_SFT;
    }

    set_val= 0;
    set_val |= (info->flags & BCM_TUNNEL_INIT_USE_INNER_DF) ?
                          EGR_L3_TUNNEL_0_IP_HDR_DF_CTRL_INHERIT_IP4_PLD : 0;
    set_val |= (info->flags & BCM_TUNNEL_INIT_IPV4_SET_DF) ?
                          EGR_L3_TUNNEL_0_IP_HDR_DF_CTRL_IP4_PLD : 0;
    set_val |= (info->flags & BCM_TUNNEL_INIT_IPV6_SET_DF) ?
                          EGR_L3_TUNNEL_0_IP_HDR_DF_CTRL_IP6_PLD : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, IP_HDR_DF_CTRLs, set_val));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, TUNNEL_WORD_1s, tunnel_word_1_val));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, TUNNEL_WORD_0s, tunnel_word_0_val));

    if (info->flags & BCM_TUNNEL_REPLACE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl1, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl2, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        rv = bcmlt_field_desc_get(dunit, EGR_L3_TUNNEL_0s,
                                  STRENGTH_PRFL_IDXs, &fld_desc);
        if (SHR_SUCCESS(rv)) {
            pth = BCMI_LTSW_SBR_PTH_EGR_L3_TNL_0;
            ent_type = BCMI_LTSW_SBR_PET_DEF;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                                     &sbr_idx));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl1, STRENGTH_PRFL_IDXs, sbr_idx));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl1, BCMLT_OPCODE_INSERT,
                                  BCMLT_PRIORITY_NORMAL));

        pth = BCMI_LTSW_SBR_PTH_EGR_L3_TNL;
        ent_type = BCMI_LTSW_SBR_PET_NO_IP_DIP_NO_SEQ_NUM;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type, &sbr_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl2, STRENGTH_PRFL_IDXs, sbr_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl2, BCMLT_OPCODE_INSERT,
                                  BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl1 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl1);
        entry_hdl1 = BCMLT_INVALID_HDL;
    }
    if (entry_hdl2 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl2);
        entry_hdl2 = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete specified entry from tunnel table.
 *
 * \param [in] unit     Unit number.
 * \param [in] tnl_idx  Index to tunnel initiator hardware table.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_initiator_delete(int unit, int tnl_idx)
{
    bcmlt_entry_handle_t entry_hdl1 = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t entry_hdl2 = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_0s, &entry_hdl1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, EGR_L3_TUNNEL_IDX_0s, tnl_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_1s, &entry_hdl2));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, EGR_L3_TUNNEL_IDX_0s, tnl_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl1,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl2,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl1 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl1);
        entry_hdl1 = BCMLT_INVALID_HDL;
    }
    if (entry_hdl2 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl2);
        entry_hdl2 = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy all flow tunnel initiator entry.
 *
 * \param [in]     unit          Unit Number.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_tunnel_initiator_delete_all(int unit)
{
    uint32_t tnl_idx = 0;
    uint32_t vp_num = 0;
    uint32_t vp_idx = 0;
    bcm_gport_t flow_port;
    bcmlt_entry_handle_t entry_hdl1 = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t entry_hdl2 = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t get_val;
    bcm_flow_tunnel_initiator_t info;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_0s, &entry_hdl1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_1s, &entry_hdl2));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_num_get(unit, &vp_num));

    for (vp_idx = 0; vp_idx < vp_num; vp_idx++) {
        if (bcmi_ltsw_virtual_vp_used_get(unit, vp_idx,
                                          BCMI_LTSW_VP_TYPE_FLOW)) {
            continue;
        }

        bcm_flow_tunnel_initiator_t_init(&info);
        BCM_GPORT_FLOW_PORT_ID_SET(flow_port, vp_idx);
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_tunnel_initiator_dip_idx_get(unit, flow_port, &tnl_idx,
                                                    NULL, NULL));
        if (tnl_idx == BCMINT_FLOW_EGR_TUNNEL_RESERVED) {
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl1, EGR_L3_TUNNEL_IDX_0s, tnl_idx));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl1,
                                  BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl1, EDIT_CTRL_IDs, &get_val));
        if ((get_val == EGR_L3_TUNNEL_0_EDIT_CTRL_ID_VXLAN_IPV4) ||
            (get_val == EGR_L3_TUNNEL_0_EDIT_CTRL_ID_VXLAN_IPV6)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_free(unit, 0,
                                              BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                              BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                              tnl_idx));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_tunnel_idx_set(unit, vp_idx,
                                        BCMINT_FLOW_EGR_TUNNEL_RESERVED));
    }

exit:
    if (entry_hdl1 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl1);
        entry_hdl1 = BCMLT_INVALID_HDL;
    }
    if (entry_hdl2 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl2);
        entry_hdl2 = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the parameters for flex stat configuration.
 *
 * \param [in] unit   Unit number.
 * \param [in] info   Flow stat config structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_stat_param_validation(int unit, bcm_flow_stat_info_t *info)
{
    int rv = SHR_E_NONE;
    uint32_t supported_items = 0;
    int vp = BCMINT_FLOW_VP_RESERVED;

    SHR_FUNC_ENTER(unit);

    /* Validate element.
     * Currently, only following tables support flex stat.
     * ing_vfi_table, egr_vfi, ing_svp_table, egr_dvp.
     */
    supported_items |= BCM_FLOW_STAT_FLOW_PORT_VALID;
    supported_items |= BCM_FLOW_STAT_VPN_VALID;
    if (info->valid_elements & (~supported_items)) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Elements:supported(%d)/provided(%d)!\n"),
                                        supported_items, info->valid_elements));
    }
    if (info->valid_elements & BCM_FLOW_STAT_VPN_VALID) {
        rv = bcmint_flow_vpn_is_valid(unit, info->vpn);
        if (BCM_FAILURE(rv)) {
            SHR_IF_ERR_MSG_EXIT(rv,
                                (BSL_META_U(unit, "Invalid VPN:%d!\n"),
                                            info->vpn));
        }
    }
    if (info->valid_elements & BCM_FLOW_STAT_FLOW_PORT_VALID) {
        vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
        if (vp == BCMINT_FLOW_VP_RESERVED) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VP 0 reserved for \
                                            internal use!\n")));
        }
        if (bcmi_ltsw_virtual_vp_used_get(unit, vp,
                                          BCMI_LTSW_VP_TYPE_FLOW)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid flow port:%d!\n"),
                                            info->flow_port));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the counter source.
 *
 * \param [in] unit        Unit number.
 * \param [in] stat_info   Flow stat config structure.
 * \param [in] info        Counter action structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_stat_counter_source_validation(int unit,
                                        bcm_flow_stat_info_t *stat_info,
                                        bcmi_ltsw_flexctr_counter_info_t *info)
{
    bcm_flexctr_source_t source = bcmFlexctrSourceCount;

    SHR_FUNC_ENTER(unit);

    if (stat_info->valid_elements & BCM_FLOW_STAT_VPN_VALID) {
        if (info->direction == BCMI_LTSW_FLEXCTR_DIR_INGRESS) {
            source = bcmFlexctrSourceIngVpn;
        } else {
            source = bcmFlexctrSourceEgrVpn;
        }
    }
    if (stat_info->valid_elements & BCM_FLOW_STAT_FLOW_PORT_VALID) {
        if (info->direction == BCMI_LTSW_FLEXCTR_DIR_INGRESS) {
            source = bcmFlexctrSourceSvp;
        } else {
            source = bcmFlexctrSourceDvp;
        }
    }

    if (source != info->source) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected (%d)!\n"),
                                        source, info->source));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set key info to LT entry handle.
 *
 * \param [in]  unit       Unit number.
 * \param [in]  stat_info  Flow stat config structure.
 * \param [in]  info       Counter information.
 * \param [out] entry_hd   LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_stat_key_set(int unit, bcm_flow_stat_info_t *stat_info,
                      bcmi_ltsw_flexctr_counter_info_t *info,
                      bcmlt_entry_handle_t entry_hd)
{
    int vp = BCMINT_FLOW_VP_RESERVED;
    uint32_t vfi = BCMINT_FLOW_VFI_RESERVED;

    SHR_FUNC_ENTER(unit);

    if (stat_info->valid_elements & BCM_FLOW_STAT_VPN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vfi_idx_get(unit, stat_info->vpn, &vfi));

        SHR_IF_ERR_VERBOSE_EXIT
           (bcmlt_entry_field_add(entry_hd, VFIs, vfi));
    }
    if (stat_info->valid_elements & BCM_FLOW_STAT_FLOW_PORT_VALID) {
        vp = BCM_GPORT_FLOW_PORT_ID_GET(stat_info->flow_port);
        if (info->direction == BCMI_LTSW_FLEXCTR_DIR_INGRESS) {
            SHR_IF_ERR_VERBOSE_EXIT
               (bcmlt_entry_field_add(entry_hd, SVPs, vp));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
               (bcmlt_entry_field_add(entry_hd, DVPs, vp));
        }
    }

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Flow stat LT table update.
 *
 * \param [in]  unit           Unit number.
 * \param [in]  stat_info      Flow stat config structure.
 * \param [in]  info           Counter information.
 * \param [in]  flag           TRUE for attach, FALSE for detach.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_stat_update(int unit, bcm_flow_stat_info_t *stat_info,
                     bcmi_ltsw_flexctr_counter_info_t *info,
                     uint8_t flag)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, info->table_name, &entry_hd));

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_stat_key_set(unit, stat_info, info, entry_hd));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, FLEX_CTR_ACTIONs, &flex_ctr_action));

    if (flag) {
        /* Flex counter action must not attached. */
        if (flex_ctr_action != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_BUSY,
                                (BSL_META_U(unit, "%d already attached!\n"),
                                            (int)flex_ctr_action));
        }
    } else {
        /* Flex counter action must already attached. */
        if (flex_ctr_action != (uint64_t)info->action_index) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "%d not expected (%d)!\n"),
                                            (int)flex_ctr_action,
                                            (int)info->action_index));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_clear(entry_hd));

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_stat_key_set(unit, stat_info, info, entry_hd));

    if (flag) {
        flex_ctr_action = (uint64_t)info->action_index;
    } else {
        flex_ctr_action = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, FLEX_CTR_ACTIONs, flex_ctr_action));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Find VP assocaited with given L2 interface ID.
 *
 * \param [in]  unit           Unit number.
 * \param [in]  l2_iif         L2 interface ID.
 *
 * \retval VP or -1 means not found.
 */
static int
xfs_flow_match_vp_find(int unit, uint32_t l2_iif)
{
    xfs_flow_info_t *vi = XFS_FLOW_INFO(unit);
    int idx;

    XFS_FLOW_LOCK(unit);

    for (idx = 0; idx < vi->l2_iif_num; idx++) {
        if (vi->l2_iif_map[idx] == l2_iif ) {
            XFS_FLOW_UNLOCK(unit);

            return idx;
        }
    }
    XFS_FLOW_UNLOCK(unit);

    return -1;
}

/*!
 * \brief Determines whether match is configured on ing vlan xlate table.
 *
 * \param [in]  unit  Unit number.
 * \param [in]  info  Flow match information.
 *
 * \retval TRUE or FALSE.
 */
static int
xfs_flow_match_on_vlan_xlate(int unit,
                             bcm_flow_match_config_t *info)
{
    if ((info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN) ||
        (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_INNER_VLAN) ||
        (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN_STACKED)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*!
 * \brief Validate the parameters for match configuration.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Flow match information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_param_validation(int unit,
                                bcmint_flow_hw_opt_type_t opt,
                                bcm_flow_match_config_t *info)
{
    int vp = -1;
    uint32_t fld_width = 0;
    uint32_t vfi = 0;

    SHR_FUNC_ENTER(unit);

    /* Validate criteria. */
    switch(info->criteria) {
        case BCM_FLOW_MATCH_CRITERIA_PORT:
            break;
        case BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN:
           break;
        case BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_INNER_VLAN:
            break;
        case BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN_STACKED:
            break;
        case BCM_FLOW_MATCH_CRITERIA_VN_ID:
            break;
        case BCM_FLOW_MATCH_CRITERIA_SIP:
            break;
        case BCM_FLOW_MATCH_CRITERIA_SVP_VNID:
            break;
        default:
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "invalid criteria:%d!\n"),
                                            info->criteria));
    }

    /* Validate flow option vs criteria. */
    if (info->flow_option == BCMINT_FLOW_OPT_ID_LOOKUP_VNID_ASSIGN_VFI) {
        if (info->criteria != BCM_FLOW_MATCH_CRITERIA_VN_ID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VNID must be criteria for \
                                            LOOKUP_VNID_ASSIGN_VFI!\n")));
        }
    }
    if (info->flow_option == BCMINT_FLOW_OPT_ID_LOOKUP_IPV6_SIP_ASSIGN_SVP) {
        if (info->criteria != BCM_FLOW_MATCH_CRITERIA_SIP) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "SIP must be criteria for \
                                            LOOKUP_IPV6_SIP_ASSIGN_SVP!\n")));
        }
    }

    /* Validate criteria vs valid elements. */
    if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT) {
        if (!(info->valid_elements & BCM_FLOW_MATCH_PORT_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "port not provided!\n")));
        }
        if (info->port == BCM_PORT_INVALID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid  port:%d!\n"),
                                            info->port));
        }
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN) {
        if (!(info->valid_elements & BCM_FLOW_MATCH_PORT_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit,
                                            "port group not provided!\n")));
        }
        if (!(info->valid_elements & BCM_FLOW_MATCH_VLAN_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit,
                                            "vlan not provided!\n")));
        }
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_INNER_VLAN) {
        if (!(info->valid_elements & BCM_FLOW_MATCH_PORT_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit,
                                            "port group not provided!\n")));
        }
        if (!(info->valid_elements & BCM_FLOW_MATCH_INNER_VLAN_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit,
                                            "inner vlan not provided!\n")));
        }
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN_STACKED) {
        if (!(info->valid_elements & BCM_FLOW_MATCH_PORT_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit,
                                            "port group not provided!\n")));
        }
        if (!(info->valid_elements & BCM_FLOW_MATCH_VLAN_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit,
                                            "vlan not provided!\n")));
        }
        if (!(info->valid_elements & BCM_FLOW_MATCH_INNER_VLAN_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit,
                                            "inner vlan not provided!\n")));
        }
    } else if (info->criteria == BCM_FLOW_MATCH_CRITERIA_VN_ID) {
        if (!(info->valid_elements & BCM_FLOW_MATCH_VNID_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VNID not provided!\n")));
        }
    } else if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SIP) {
        if (!(info->valid_elements &
            (BCM_FLOW_MATCH_SIP_VALID | BCM_FLOW_MATCH_SIP_V6_VALID))) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "SIP not provided!\n")));
        }
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SVP_VNID) {
        if (!(info->valid_elements & BCM_FLOW_MATCH_VNID_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VNID not provided!\n")));
        }
        if (!(info->valid_elements & BCM_FLOW_MATCH_FLOW_PORT_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "flow port not provided!\n")));
        }
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

    /* Validate elements */
    if ((info->valid_elements & BCM_FLOW_MATCH_FLOW_PORT_VALID) &&
        (opt != HW_OPT_GET)) {
        vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
        if (vp == BCMINT_FLOW_VP_RESERVED) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VP 0 reserved for \
                                            internal use!\n")));
        }
        if ((vp == -1) ||
            (bcmi_ltsw_virtual_vp_used_get(unit, vp, BCMI_LTSW_VP_TYPE_VPLAG) &&
             bcmi_ltsw_virtual_vp_used_get(unit, vp, BCMI_LTSW_VP_TYPE_FLOW))) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid flow port:%d!\n"),
                                            info->flow_port));
        }
    }
    if (info->valid_elements & BCM_FLOW_MATCH_VLAN_VALID) {
        if (!BCM_VLAN_VALID(info->vlan)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid vlan:%d!\n"),
                                            info->vlan));
        }
    }
    if (info->valid_elements & BCM_FLOW_MATCH_INNER_VLAN_VALID) {
        if (!BCM_VLAN_VALID(info->inner_vlan)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid inner vlan:%d!\n"),
                                            info->inner_vlan));
        }
    }
    /* Actually port_group */
    if ((info->valid_elements & BCM_FLOW_MATCH_PORT_VALID) &&
         xfs_flow_match_on_vlan_xlate(unit, info)) {
       SHR_IF_ERR_VERBOSE_EXIT
           (bcmi_lt_field_width_get(unit, ING_VLAN_XLATE_1_TABLEs,
                                    L2_IIF_PORT_GROUP_IDs,
                                    &fld_width));
       if (info->port >= (1<<fld_width)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid port_group:%d!\n"),
                                            info->port));
        }
    }
    if ((info->valid_elements & BCM_FLOW_MATCH_VPN_VALID) &&
        (opt != HW_OPT_GET)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vfi_idx_get(unit, info->vpn, &vfi));
        if (vfi == BCMINT_FLOW_VFI_RESERVED) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VFI 0 reserved for \
                                            internal use!\n")));
        }
    }
    if (info->valid_elements & BCM_FLOW_MATCH_IIF_VALID) {
        if (info->intf_id == BCMINT_FLOW_L3_IIF_RESERVED) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Intf 0 reserved for \
                                            internal use!\n")));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Configuration on port/trunk based on match.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Flow match information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_port_ctrl(int unit,
                         bcmint_flow_hw_opt_type_t opt,
                         bcm_flow_match_config_t *info)
{
    xfs_flow_info_t *vi = XFS_FLOW_INFO(unit);
    int vp = -1;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    int l2_iif = 0;
    int old_vp = -1;

    SHR_FUNC_ENTER(unit);

    if (info->valid_elements & BCM_FLOW_MATCH_FLOW_PORT_VALID) {
        vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
        bcmi_ltsw_virtual_vp_info_init(&vp_info);
        if (bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info)) {
            SHR_ERR_EXIT(SHR_E_PORT);
        }
        if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT) {
            SHR_ERR_EXIT(SHR_E_PORT);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_to_l2_if(unit, info->port, &l2_iif));

    if (opt == HW_OPT_GET) {
        vp = xfs_flow_match_vp_find(unit, l2_iif);
        if (vp != -1) {
            BCM_GPORT_FLOW_PORT_ID_SET(info->flow_port, vp);
            info->valid_elements |= BCM_FLOW_MATCH_FLOW_PORT_VALID;
        }
    } else if (opt == HW_OPT_SET) {
        old_vp = xfs_flow_match_vp_find(unit, l2_iif);
        if (old_vp != -1) {
            SHR_ERR_EXIT(SHR_E_EXISTS);
        }
        if (vp != -1) {
            XFS_FLOW_LOCK(unit);
            vi->l2_iif_map[vp] = l2_iif;
            XFS_FLOW_UNLOCK(unit);
        }
    } else if (opt == HW_OPT_CLR) {
        vp = xfs_flow_match_vp_find(unit, l2_iif);
        if (vp != -1) {
            XFS_FLOW_LOCK(unit);
            vi->l2_iif_map[vp] = INVALID_L2_IF;
            XFS_FLOW_UNLOCK(unit);
        }
    } else {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Determine logical table based on match info.
 *
 * \param [in]  unit    Unit number.
 * \param [in]  info    Flow match information.
 * \param [out] lt_name Logical table name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_lt_determine(int unit,
                            bcm_flow_match_config_t *info,
                            const char **lt_name)
{
    SHR_FUNC_ENTER(unit);

    if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT) {
        *lt_name = ING_SYSTEM_PORT_TABLEs;
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN) {
        *lt_name = ING_VLAN_XLATE_1_TABLEs;
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_INNER_VLAN) {
        *lt_name = ING_VLAN_XLATE_2_TABLEs;
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN_STACKED) {
        *lt_name = ING_VLAN_XLATE_3_TABLEs;
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_VN_ID) {
        *lt_name = L2_TUNNEL_VN_ID_TABLEs;
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SIP) {
        if (info->valid_elements & BCM_FLOW_MATCH_SIP_VALID) {
            *lt_name = L2_TUNNEL_IPV4_SIP_TABLEs;
        } else {
            *lt_name = L2_TUNNEL_IPV6_SIP_TABLEs;
        }
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SVP_VNID) {
        *lt_name = L2_TUNNEL_VN_ID_TABLEs;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Determine match criteria based on logical table.
 *
 * \param [in]  unit    Unit number.
 * \param [in]  lt_name Logical table name.
 * \param [out] info    Flow match information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_criteria_determine(int unit,
                                  const char *lt_name,
                                  bcm_flow_match_config_t *info)
{
    SHR_FUNC_ENTER(unit);

    if (lt_name == ING_VLAN_XLATE_1_TABLEs) {
        info->criteria = BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN;
        info->valid_elements = BCM_FLOW_MATCH_PORT_VALID |
                               BCM_FLOW_MATCH_VLAN_VALID;
    } else if (lt_name == ING_VLAN_XLATE_2_TABLEs) {
        info->criteria = BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_INNER_VLAN;
        info->valid_elements = BCM_FLOW_MATCH_PORT_VALID |
                               BCM_FLOW_MATCH_INNER_VLAN_VALID;
    } else if (lt_name == ING_VLAN_XLATE_3_TABLEs) {
        info->criteria = BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN_STACKED;
        info->valid_elements = BCM_FLOW_MATCH_PORT_VALID |
                               BCM_FLOW_MATCH_VLAN_VALID |
                               BCM_FLOW_MATCH_INNER_VLAN_VALID;
    } else if (lt_name == L2_TUNNEL_VN_ID_TABLEs) {
        /* Determined as BCM_FLOW_MATCH_CRITERIA_VN_ID based on SVP value */
        info->criteria = BCM_FLOW_MATCH_CRITERIA_SVP_VNID;
        info->valid_elements = BCM_FLOW_MATCH_VNID_VALID |
                               BCM_FLOW_MATCH_FLOW_PORT_VALID;
    } else if (lt_name == L2_TUNNEL_IPV4_SIP_TABLEs) {
        info->criteria = BCM_FLOW_MATCH_CRITERIA_SIP;
        info->valid_elements = BCM_FLOW_MATCH_SIP_VALID;
    } else if (lt_name == L2_TUNNEL_IPV6_SIP_TABLEs) {
        info->criteria = BCM_FLOW_MATCH_CRITERIA_SIP;
        info->valid_elements = BCM_FLOW_MATCH_SIP_V6_VALID;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad lt:%s!\n"), lt_name));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set key based on match criteria.
 *
 * \param [in]  unit     Unit number.
 * \param [in]  info     Flow match information.
 * \param [in]  entry_hd Logical table entry handle..
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_key_set(int unit,
                       bcm_flow_match_config_t *info,
                       bcmlt_entry_handle_t entry_hd)
{
    uint64_t get_ipv6_val[2] = {0};
    int vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);

    SHR_FUNC_ENTER(unit);

    if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, L2_IIF_PORT_GROUP_IDs,
                                   info->port));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, OVIDs, info->vlan));
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_INNER_VLAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, L2_IIF_PORT_GROUP_IDs,
                                   info->port));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, IVIDs, info->inner_vlan));
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN_STACKED) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, L2_IIF_PORT_GROUP_IDs,
                                   info->port));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, OVIDs, info->vlan));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, IVIDs, info->inner_vlan));
    } else if (info->criteria == BCM_FLOW_MATCH_CRITERIA_VN_ID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VN_IDs, info->vnid));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, SVPs, BCMINT_FLOW_VP_RESERVED));
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SIP) {
        if (info->valid_elements & BCM_FLOW_MATCH_SIP_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, IP_HDR_SIPs, info->sip));
        } else {
            bcmi_ltsw_util_ip6_to_uint64(get_ipv6_val, &(info->sip6));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(entry_hd, IP_HDR_SIPs, 0,
                                             get_ipv6_val, 2));
        }
    } else if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SVP_VNID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VN_IDs, info->vnid));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, SVPs, vp));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get key info based on match criteria.
 *
 * \param [in]       unit     Unit number.
 * \param [in-out]   info     Flow match information.
 * \param [in]       entry_hd Logical table entry handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_key_get(int unit,
                        bcm_flow_match_config_t *info,
                        const bcmlt_entry_handle_t entry_hd)
{
    uint64_t get_val;
    uint32_t act_cnt = 0;
    uint64_t get_ipv6_val[2] = {0};

    SHR_FUNC_ENTER(unit);

    if (info->valid_elements & BCM_FLOW_MATCH_VNID_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, VN_IDs, &get_val));
        info->vnid = (uint32_t)get_val;
    }
    if (info->valid_elements & BCM_FLOW_MATCH_SIP_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, IP_HDR_SIPs, &get_val));
        info->sip = get_val;
    }
    if (info->valid_elements & BCM_FLOW_MATCH_SIP_V6_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hd, IP_HDR_SIPs, 0,
                                         get_ipv6_val, 2,
                                         &act_cnt));
        bcmi_ltsw_util_uint64_to_ip6(&(info->sip6), get_ipv6_val);
    }
    if (info->valid_elements & BCM_FLOW_MATCH_VLAN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OVIDs, &get_val));
        info->vlan = (uint32_t)get_val;
    }
    if (info->valid_elements & BCM_FLOW_MATCH_INNER_VLAN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, IVIDs, &get_val));
        info->inner_vlan = (uint32_t)get_val;
    }
    if (info->valid_elements & BCM_FLOW_MATCH_PORT_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, L2_IIF_PORT_GROUP_IDs,
                                   &get_val));
        info->port = (uint32_t)get_val;
    }
    if (info->valid_elements & BCM_FLOW_MATCH_FLOW_PORT_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hd, SVPs, &get_val));
            BCM_GPORT_FLOW_PORT_ID_SET(info->flow_port, (int)get_val);
    }

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set valid element based on logical table.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   lt_name       Logical table name.
 * \param [out]  valid_element Element valid status.
 */
static void
xfs_flow_match_data_valid_indicator(int unit,
                                    const char *lt_name,
                                    uint32_t *valid_element,
                                    uint32_t *valid_flags)
{
    *valid_element = 0;
    *valid_flags = 0;
    if (lt_name == ING_VLAN_XLATE_1_TABLEs) {
        *valid_element = BCM_FLOW_MATCH_VPN_VALID |
                         BCM_FLOW_MATCH_IIF_VALID;
    } else if (lt_name == ING_VLAN_XLATE_2_TABLEs) {
        *valid_element = BCM_FLOW_MATCH_VPN_VALID |
                         BCM_FLOW_MATCH_IIF_VALID;
    } else if (lt_name == ING_VLAN_XLATE_3_TABLEs) {
        *valid_element = BCM_FLOW_MATCH_VPN_VALID |
                         BCM_FLOW_MATCH_IIF_VALID;
    } else if (lt_name == L2_TUNNEL_VN_ID_TABLEs) {
        *valid_element = BCM_FLOW_MATCH_VPN_VALID |
                         BCM_FLOW_MATCH_FLAGS_VALID;
        *valid_flags = BCM_FLOW_MATCH_FLAG_DROP;
    } else if (lt_name == L2_TUNNEL_IPV4_SIP_TABLEs) {
        *valid_element = BCM_FLOW_MATCH_FLOW_PORT_VALID;
    } else if (lt_name == L2_TUNNEL_IPV6_SIP_TABLEs) {
        *valid_element = BCM_FLOW_MATCH_FLOW_PORT_VALID;
    } else {
       /* Do nothing */
    }
}

/*!
 * \brief Set data portion based on match info.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   info          Flow match information.
 * \param [in]   entry_hd      Logical table entry handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_data_set(int unit,
                        bcm_flow_match_config_t *info,
                        bcmlt_entry_handle_t entry_hd)
{
    int vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
    uint32_t vfi = 0;

    SHR_FUNC_ENTER(unit);

    if (info->valid_elements & BCM_FLOW_MATCH_FLOW_PORT_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, SVPs, vp));
    }

    if (info->valid_elements & BCM_FLOW_MATCH_VPN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vfi_idx_get(unit, info->vpn, &vfi));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VFIs, vfi));
    }

    if (info->valid_elements & BCM_FLOW_MATCH_IIF_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, L3_IIFs, info->intf_id));
    }

    if (info->valid_elements & BCM_FLOW_MATCH_FLAGS_VALID) {
        if (info->flags & BCM_FLOW_MATCH_FLAG_DROP) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, DROPs, 0x1));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, DROPs, 0x0));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get data portion based on match info.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   info          Flow match information.
 * \param [in]   lt_name       Logical table name.
 * \param [in]   entry_hd      Logical table entry handle.
 * \param [out]  valid         Indicate whether valid data found.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_data_get(int unit,
                        bcm_flow_match_config_t *info,
                        const char *lt_name,
                        const bcmlt_entry_handle_t entry_hd,
                        uint8_t *valid)
{
    uint64_t get_val;
    uint32_t valid_element = 0;
    uint32_t valid_flags = 0;

    SHR_FUNC_ENTER(unit);

    xfs_flow_match_data_valid_indicator(unit, lt_name, &valid_element,
                                        &valid_flags);
    *valid = 0;
    if (valid_element & BCM_FLOW_MATCH_FLOW_PORT_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, SVPs, &get_val));
        BCM_GPORT_FLOW_PORT_ID_SET(info->flow_port, (int)get_val);

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_MATCH_VPN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, VFIs, &get_val));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, get_val, &(info->vpn)));

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_MATCH_IIF_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, L3_IIFs, &get_val));
        info->intf_id = (int)get_val;

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_MATCH_FLAGS_VALID) {
        if (valid_flags & BCM_FLOW_MATCH_FLAG_DROP) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hd, DROPs, &get_val));
            if (get_val == 0) {
                info->flags &= (~BCM_FLOW_MATCH_FLAG_DROP);
            } else {
                info->flags |= BCM_FLOW_MATCH_FLAG_DROP;
                *valid = 1;
            }
        }
    }

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Configuration on hash table based on match.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Flow match information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_general_ctrl(int unit,
                            bcmint_flow_hw_opt_type_t opt,
                            bcm_flow_match_config_t *info)
{
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    int rv = SHR_E_NONE;
    uint8_t valid = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_match_lt_determine(unit, info, &lt_name));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_match_key_set(unit, info, entry_hd));
    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                                     BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_match_data_get(unit, info, lt_name, entry_hd, &valid));
    } else if (opt == HW_OPT_SET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_match_data_set(unit, info, entry_hd));
        if (info->options & BCM_FLOW_MATCH_OPTION_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_UPDATE,
                                      BCMLT_PRIORITY_NORMAL));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_INSERT,
                                      BCMLT_PRIORITY_NORMAL));
        }
    } else if (opt == HW_OPT_CLR) {
        rv = bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL);
        if ((rv == SHR_E_NOT_FOUND) &&
             xfs_flow_match_on_vlan_xlate(unit,info)) {
            SHR_EXIT();
        } else {
            if (SHR_SUCCESS(rv)) {
                SHR_EXIT();
            } else {
                SHR_ERR_EXIT(rv);
            }
        }
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hd) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse HW table based with port/trunk as criteria.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     cb            User callback function.
 * \param [in]     user_data     User context data.
 * \param [in]     lt_name       Logical table name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_port_table_traverse(int unit,
                                    bcm_flow_match_traverse_cb cb,
                                    void *user_data,
                                    const char *lt_name)
{
    int rv = SHR_E_NONE;
    int dunit = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t get_val;
    bcm_flow_match_config_t info = {0};
    uint32_t l2_iif = 0;
    int vp = -1;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hdl));

    while ((rv = bcmi_lt_entry_commit(dunit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L2_IIFs, &get_val));
        l2_iif = (int)get_val;
        vp = xfs_flow_match_vp_find(unit, l2_iif);
        if (vp != -1) {
            bcm_flow_match_config_t_init(&info);

            info.criteria = BCM_FLOW_MATCH_CRITERIA_PORT;
            BCM_GPORT_FLOW_PORT_ID_SET(info.flow_port, vp);
            info.valid_elements = BCM_FLOW_MATCH_FLOW_PORT_VALID;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l2_if_to_port(unit, l2_iif, &info.port));

            SHR_IF_ERR_VERBOSE_EXIT
                (cb(unit, &info, 0, NULL, user_data));
        }
    }
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Adjust match criteria.
 *
 * \param [in]  unit           Unit number.
 * \param [in]  lt_name        Logical table name.
 * \param [in]  info           Flow match config structure.
 */
static void
xfs_flow_match_criteria_adjust(int unit,
                               const char *lt_name,
                               bcm_flow_match_config_t *info)
{
    if (lt_name == L2_TUNNEL_VN_ID_TABLEs) {
        bcm_gport_t flow_port_reserved = 0;

        BCM_GPORT_FLOW_PORT_ID_SET(flow_port_reserved, BCMINT_FLOW_VP_RESERVED);
        if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SVP_VNID) {
            if ((info->valid_elements & BCM_FLOW_MATCH_FLOW_PORT_VALID) &&
                (info->flow_port == flow_port_reserved)) {
                info->criteria = BCM_FLOW_MATCH_CRITERIA_VN_ID;
                info->valid_elements &= (~BCM_FLOW_MATCH_FLOW_PORT_VALID);
            }
        }
    }
}

/*!
 * \brief Traverse HW table based with hash key as criteria.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     cb            User callback function.
 * \param [in]     user_data     User context data.
 * \param [in]     lt_name       Logical table name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_match_hash_table_traverse(int unit,
                                   bcm_flow_match_traverse_cb cb,
                                   void *user_data,
                                   const char *lt_name)
{
    int rv = SHR_E_NONE;
    bcm_flow_match_config_t info = {0};
    int dunit = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint8_t valid = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hdl));

    while ((rv = bcmi_lt_entry_commit(dunit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        bcm_flow_match_config_t_init(&info);

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_match_criteria_determine(unit, lt_name, &info));

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_match_key_get(unit, &info, entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_match_data_get(unit, &info, lt_name, entry_hdl, &valid));

        if (valid == 0) {
            continue;
        }
        xfs_flow_match_criteria_adjust(unit, lt_name, &info);

        SHR_IF_ERR_VERBOSE_EXIT
            (cb(unit, &info, 0, NULL, user_data));
    }
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the parameters for encap configuration.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Flow encap information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_param_validation(int unit,
                                bcmint_flow_hw_opt_type_t opt,
                                bcm_flow_encap_config_t *info)
{
    int rv = SHR_E_NONE;
    int vp = -1;
    uint32 supported_elements = 0;

    SHR_FUNC_ENTER(unit);

    if (info->flow_handle == BCMINT_FLOW_ID_INT) {
        if ((info->flow_option != 0) && (info->flow_option !=
            BCMINT_FLOW_OPT_ID_ASSIGN_DEVICE_ID_TEMPLATE_ID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid flow option :%d!\n"),
                                            info->flow_option));

        } else {
            SHR_EXIT();
        }
    }

    /* Validate criteria. */
    switch(info->criteria) {
        case BCM_FLOW_ENCAP_CRITERIA_VFI:
            break;
        case BCM_FLOW_ENCAP_CRITERIA_VFI_DVP_GROUP:
           break;
        default:
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "invalid criteria:%d!\n"),
                                            info->criteria));
    }

    /* Validate flow option vs criteria. */
    if (info->flow_option == BCMINT_FLOW_OPT_ID_LOOKUP_VFI_ASSIGN_VNID) {
        if (info->criteria != BCM_FLOW_ENCAP_CRITERIA_VFI) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VFI must be criteria for \
                                            LOOKUP_VFI_ASSIGN_VNID!\n")));
        }
    }
    if (info->flow_option == BCMINT_FLOW_OPT_ID_LOOKUP_DVP_VFI_ASSIGN_VNID) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "LOOKUP_DVP_VFI_ASSIGN_VNID not \
                                        supported!\n")));
    }

    /* Validate criteria vs valid elements. */
    if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI) {
        if (!(info->valid_elements & BCM_FLOW_ENCAP_VPN_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VPN not provided!\n")));
        }
        supported_elements = BCM_FLOW_ENCAP_VPN_VALID |
                             BCM_FLOW_ENCAP_VNID_VALID |
                             BCM_FLOW_ENCAP_CLASS_ID_VALID;
        if (info->valid_elements & (~supported_elements)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "elements:supported(%d)/provided(%d)!\n"),
                                            supported_elements, info->valid_elements));
        }
    } else  if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI_DVP_GROUP) {
        if (!(info->valid_elements & BCM_FLOW_ENCAP_VPN_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VPN not provided!\n")));
        }
        if (!(info->valid_elements & BCM_FLOW_ENCAP_DVP_GROUP_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "DVP group not provided!\n")));
        }
        supported_elements = BCM_FLOW_ENCAP_VPN_VALID |
                             BCM_FLOW_ENCAP_DVP_GROUP_VALID |
                             BCM_FLOW_ENCAP_VNID_VALID|
                             BCM_FLOW_ENCAP_FLAGS_VALID;
        if (info->valid_elements & (~supported_elements)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "elements:supported(%d)/provided(%d)!\n"),
                                            supported_elements, info->valid_elements));
        }
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

    /* Validate elements */
     if (info->valid_elements & BCM_FLOW_ENCAP_FLOW_PORT_VALID) {
         vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
         if ((vp == -1) ||
             bcmi_ltsw_virtual_vp_used_get(unit, vp,
                                           BCMI_LTSW_VP_TYPE_FLOW)) {
             SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                 (BSL_META_U(unit, "Invalid flow port:%d!\n"),
                                             info->flow_port));
         }
     }
      if (info->valid_elements & BCM_FLOW_ENCAP_VPN_VALID) {
          rv = bcmint_flow_vpn_is_valid(unit, info->vpn);
          if ((BCM_FAILURE(rv))) {
              SHR_IF_ERR_MSG_EXIT(rv,
                                  (BSL_META_U(unit, "Invalid VPN:%d!\n"),
                                              info->vpn));
          }
      }
      if (info->valid_elements & BCM_FLOW_ENCAP_VNID_VALID) {
          if (info->vnid == BCMINT_FLOW_VNID_RESERVED) {
              SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                  (BSL_META_U(unit, "VNID 0 reserved for \
                                              internal use!\n")));
          }
      }
      if (info->valid_elements & BCM_FLOW_ENCAP_CLASS_ID_VALID) {
          if (info->class_id == BCMINT_FLOW_CLASS_ID_RESERVED) {
              SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                  (BSL_META_U(unit, "CLASS ID 0 reserved for \
                                              internal use!\n")));
          }
      }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Determine logical table based on encap info.
 *
 * \param [in]  unit    Unit number.
 * \param [in]  info    Flow encap information.
 * \param [out] lt_name Logical table name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_lt_determine(int unit,
                            bcm_flow_encap_config_t *info,
                            const char **lt_name)
{
    SHR_FUNC_ENTER(unit);

    if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI) {
        *lt_name = EGR_VFIs;
    } else  if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI_DVP_GROUP) {
        *lt_name = EGR_VLAN_TRANSLATION_2s;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Determine encap criteria based on logical table.
 *
 * \param [in]  unit    Unit number.
 * \param [in]  lt_name Logical table name.
 * \param [out] info    Flow encap information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_criteria_determine(int unit,
                                  const char *lt_name,
                                  bcm_flow_encap_config_t *info)
{
    SHR_FUNC_ENTER(unit);

    if (lt_name == EGR_VFIs) {
        info->criteria = BCM_FLOW_ENCAP_CRITERIA_VFI;
        info->valid_elements = BCM_FLOW_ENCAP_VNID_VALID |
                               BCM_FLOW_ENCAP_VPN_VALID;
    } else if (lt_name == EGR_VLAN_TRANSLATION_2s) {
        info->criteria = BCM_FLOW_ENCAP_CRITERIA_VFI_DVP_GROUP;
        info->valid_elements = BCM_FLOW_ENCAP_VNID_VALID |
                               BCM_FLOW_ENCAP_VPN_VALID |
                               BCM_FLOW_ENCAP_DVP_GROUP_VALID;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad lt:%s!\n"), lt_name));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set key based on encap criteria.
 *
 * \param [in]  unit     Unit number.
 * \param [in]  info     Flow encap information.
 * \param [in]  entry_hd Logical table entry handle..
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_key_set(int unit,
                       bcm_flow_encap_config_t *info,
                       bcmlt_entry_handle_t entry_hd)
{
    uint32_t vfi_idx = -1;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_idx_get(unit, info->vpn, &vfi_idx));

    if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI_DVP_GROUP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, GROUP_IDs,
                                   info->dvp_group));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VFIs, vfi_idx));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get key info based on encap criteria.
 *
 * \param [in]  unit     Unit number.
 * \param [in]  info     Flow encap information.
 * \param [in]  entry_hd Logical table entry handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_key_get(int unit,
                        bcm_flow_encap_config_t *info,
                        const bcmlt_entry_handle_t entry_hd)
{
    uint64_t get_val;

    SHR_FUNC_ENTER(unit);

    if (info->valid_elements & BCM_FLOW_ENCAP_VPN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, VFIs, &get_val));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, get_val, &(info->vpn)));

    }
    if (info->valid_elements & BCM_FLOW_ENCAP_DVP_GROUP_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, GROUP_IDs, &get_val));
        info->dvp_group = (uint32_t)get_val;
    }

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set valid element based on logical table.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   entry_hd      Logical table entry handle.
 * \param [in]   lt_name       Logical table name.
 * \param [out]  valid_element Element valid status.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_data_valid_indicator(int unit,
                                    const char *lt_name,
                                    const bcmlt_entry_handle_t entry_hd,
                                    uint32_t *valid_element,
                                    uint32_t *valid_flags)
{
    SHR_FUNC_ENTER(unit);

    *valid_element = 0;
    *valid_flags = 0;
    if (lt_name == EGR_VFIs) {
        const char *view_t_symbol = NULL;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hd, VIEW_Ts,
                                          &view_t_symbol));
        if (sal_strcmp(view_t_symbol, VT_VFI_VSIDs) == 0) {
            *valid_element = BCM_FLOW_ENCAP_VNID_VALID |
                             BCM_FLOW_ENCAP_CLASS_ID_VALID;
        } else {
            *valid_element = BCM_FLOW_ENCAP_CLASS_ID_VALID;
        }
    } else if (lt_name == EGR_VLAN_TRANSLATION_2s) {
        *valid_element = BCM_FLOW_ENCAP_VNID_VALID |
                         BCM_FLOW_ENCAP_FLAGS_VALID;
        *valid_flags = BCM_FLOW_ENCAP_FLAG_DROP |
                       BCM_FLOW_ENCAP_FLAG_HIGIG3_EXTENSION_ADD;
    } else {
       SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
   SHR_FUNC_EXIT();
}

/*!
 * \brief Set data portion based on encap info.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   lt_name       Logical table name.
 * \param [in]   info          Flow encap information.
 * \param [in]   entry_hd      Logical table entry handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_data_set(int unit,
                        const char *lt_name,
                        bcm_flow_encap_config_t *info,
                        bcmlt_entry_handle_t entry_hd)
{
    bcmi_ltsw_sbr_profile_tbl_hdl_t pth;
    bcmi_ltsw_sbr_profile_ent_type_t ent_type;
    int profile_idx = 0;

    SHR_FUNC_ENTER(unit);

    if (info->valid_elements & BCM_FLOW_ENCAP_VNID_VALID) {
        if (lt_name == EGR_VFIs) {
            const char *view_t_symbol = NULL;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_get(entry_hd, VIEW_Ts,
                                              &view_t_symbol));
            if (sal_strcmp(view_t_symbol, VT_VFI_DEFAULTs) == 0) {
                uint64_t f_val;

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hd, VLAN_1s, &f_val));
                if (f_val != 0) {
                    SHR_IF_ERR_MSG_EXIT(SHR_E_CONFIG,
                        (BSL_META_U(unit, "VLAN_1 configured!\n")));
                } else {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_symbol_add(entry_hd, VIEW_Ts,
                                                      VT_VFI_VSIDs));
                }
            }
        }

        if (lt_name == EGR_VLAN_TRANSLATION_2s) {
            pth = BCMI_LTSW_SBR_PTH_EGR_VXLT_2;
            ent_type = BCMI_LTSW_SBR_PET_DEF;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                                     &profile_idx));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, STRENGTH_PRFL_IDXs,
                                       profile_idx));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VSIDs, info->vnid));
    }

    if (info->valid_elements & BCM_FLOW_ENCAP_CLASS_ID_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, CLASS_IDs, info->class_id));
        pth = BCMI_LTSW_SBR_PTH_EGR_VFI;
        ent_type = BCMI_LTSW_SBR_PET_DEF;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                                 &profile_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, STRENGTH_PRFL_IDXs, profile_idx));
    }

    if (info->valid_elements & BCM_FLOW_ENCAP_FLAGS_VALID) {
        if ((info->flags & BCM_FLOW_ENCAP_FLAG_DROP) &&
            !(info->flags & BCM_FLOW_ENCAP_FLAG_HIGIG3_EXTENSION_ADD)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, VXLT_CTRLs, 0x2));
        } else if (!(info->flags & BCM_FLOW_ENCAP_FLAG_DROP) &&
                   !(info->flags & BCM_FLOW_ENCAP_FLAG_HIGIG3_EXTENSION_ADD)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, VXLT_CTRLs, 0x0));
        } else if (!(info->flags & BCM_FLOW_ENCAP_FLAG_DROP) &&
                   (info->flags & BCM_FLOW_ENCAP_FLAG_HIGIG3_EXTENSION_ADD)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, VXLT_CTRLs, 0x4));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, VXLT_CTRLs, 0x6));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get data portion based on encap info.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   info          Flow encap information.
 * \param [in]   lt_name       Logical table name.
 * \param [in]   entry_hd      Logical table entry handle.
 * \param [out]  valid         Indicate whether valid data found.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_data_get(int unit,
                        bcm_flow_encap_config_t *info,
                        const char *lt_name,
                        const bcmlt_entry_handle_t entry_hd,
                        uint8_t *valid)
{
    uint64_t get_val;
    uint32_t valid_element = 0;
    uint32_t valid_flags = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_encap_data_valid_indicator(unit, lt_name, entry_hd,
                                             &valid_element, &valid_flags));

    *valid = 0;
    if (valid_element & BCM_FLOW_ENCAP_VNID_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, VSIDs, &get_val));
        info->vnid = (int)get_val;

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_ENCAP_CLASS_ID_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, CLASS_IDs, &get_val));
        info->class_id = (int)get_val;

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_ENCAP_FLAGS_VALID) {
        if (valid_flags & BCM_FLOW_ENCAP_FLAG_DROP) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hd, VXLT_CTRLs, &get_val));
            if (get_val & 0x2) {
                info->flags |= BCM_FLOW_ENCAP_FLAG_DROP;
                *valid = 1;
            } else {
                info->flags &= (~BCM_FLOW_ENCAP_FLAG_DROP);
            }
        }
        if (valid_flags & BCM_FLOW_ENCAP_FLAG_HIGIG3_EXTENSION_ADD) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hd, VXLT_CTRLs, &get_val));
            if (get_val & 0x4) {
                info->flags |= BCM_FLOW_ENCAP_FLAG_HIGIG3_EXTENSION_ADD;
                *valid = 1;
            } else {
                info->flags &= (~BCM_FLOW_ENCAP_FLAG_HIGIG3_EXTENSION_ADD);
            }
        }
    }

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Configuration of VFI based on encap info.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Flow encap information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_vfi_ctrl(int unit,
                        bcmint_flow_hw_opt_type_t opt,
                        bcm_flow_encap_config_t *info)
{
    int dunit = 0;
    uint32_t vfi_index = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint8_t valid = 0;
    bcmi_ltsw_sbr_profile_tbl_hdl_t pth;
    bcmi_ltsw_sbr_profile_ent_type_t ent_type;
    int profile_idx = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_idx_get(unit, info->vpn, &vfi_index));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_VFIs, &entry_hd));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, VFIs, vfi_index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_encap_data_get(unit, info, EGR_VFIs, entry_hd, &valid));
    } else if (opt == HW_OPT_SET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_encap_data_set(unit, EGR_VFIs, info, entry_hd));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VSIDs, BCMINT_FLOW_VNID_RESERVED));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, CLASS_IDs,
                                   BCMINT_FLOW_CLASS_ID_RESERVED));
        pth = BCMI_LTSW_SBR_PTH_EGR_VFI;
        ent_type = BCMI_LTSW_SBR_PET_NONE;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                                 &profile_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, STRENGTH_PRFL_IDXs,
                                   profile_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hd) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Configuration on hash table based on encap info.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Flow encap information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_general_ctrl(int unit,
                            bcmint_flow_hw_opt_type_t opt,
                            bcm_flow_encap_config_t *info)
{

    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    uint8_t valid = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_encap_lt_determine(unit, info, &lt_name));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_encap_key_set(unit, info, entry_hd));
    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                                     BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_encap_data_get(unit, info, lt_name, entry_hd, &valid));
    } else if (opt == HW_OPT_SET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_encap_data_set(unit, lt_name, info, entry_hd));
        if (info->options & BCM_FLOW_ENCAP_OPTION_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_UPDATE,
                                      BCMLT_PRIORITY_NORMAL));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_INSERT,
                                      BCMLT_PRIORITY_NORMAL));
        }
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hd) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse VIF table for encap info.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     cb            User callback function.
 * \param [in]     user_data     User context data.
 * \param [in]     lt_name       Logical table name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_vfi_table_traverse(int unit,
                                  bcm_flow_encap_traverse_cb cb,
                                  void *user_data,
                                  const char *lt_name)
{
    int rv = SHR_E_NONE;
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t get_val;
    bcm_flow_encap_config_t info = {0};
    uint8_t valid = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    while ((rv = bcmi_lt_entry_commit(dunit, entry_hd, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {

        bcm_flow_encap_config_t_init(&info);
        valid = 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_encap_data_get(unit, &info, EGR_VFIs, entry_hd, &valid));

        if (valid) {
            info.criteria = BCM_FLOW_ENCAP_CRITERIA_VFI;
            info.valid_elements |= BCM_FLOW_ENCAP_VPN_VALID;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hd, VFIs, &get_val));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vpnid_get(unit, get_val, &(info.vpn)));

            SHR_IF_ERR_VERBOSE_EXIT
                (cb(unit, &info, 0, NULL, user_data));
        }
    }
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse hash table for encap info.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     cb            User callback function.
 * \param [in]     user_data     User context data.
 * \param [in]     lt_name       Logical table name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_hash_table_traverse(int unit,
                                   bcm_flow_encap_traverse_cb cb,
                                   void *user_data,
                                   const char *lt_name)
{
    int rv = SHR_E_NONE;
    bcm_flow_encap_config_t info = {0};
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint8_t valid = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    while ((rv = bcmi_lt_entry_commit(dunit, entry_hd, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        bcm_flow_encap_config_t_init(&info);

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_encap_criteria_determine(unit, lt_name, &info));

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_encap_key_get(unit, &info, entry_hd));

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_encap_data_get(unit, &info, lt_name, entry_hd, &valid));

        if (valid == 0) {
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (cb(unit, &info, 0, NULL, user_data));
    }
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Configuration on INT parameter based on encap info.
 *
 * \param [in] unit            Unit number.
 * \param [in] opt             Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info            Flow encap information.
 * \param [in] num_of_fields   Number of logical fieldsn.
 * \param [in-out] field       Logical field array.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_ltsw_flow_encap_int_ctrl(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_encap_config_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field)
{
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    int idx;
    uint64_t get_val;
    char lt_name[BCMINT_FLOW_LT_NAME_LEN_MAX];
    char field_name[BCMINT_FLOW_LF_NAME_LEN_MAX];

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    sal_memset(lt_name, 0, BCMINT_FLOW_LT_NAME_LEN_MAX);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flow_option_logical_table_name_get(unit, info->flow_handle,
                                                      info->flow_option,
                                                      lt_name));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                                     BCMLT_PRIORITY_NORMAL));
        for (idx = 0; idx < num_of_fields; idx++) {
            sal_memset(field_name, 0, BCMINT_FLOW_LF_NAME_LEN_MAX);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_flow_logical_field_name_get(unit, info->flow_handle,
                                                       field[idx].id,
                                                       field_name));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hd, field_name, &get_val));

            field[idx].value = (uint32_t)get_val;
        }
        if (num_of_fields) {
            info->valid_elements |= BCM_FLOW_ENCAP_FLEX_DATA_VALID;
        }
    } else if (opt == HW_OPT_SET) {
        if (info->valid_elements & BCM_FLOW_ENCAP_FLEX_DATA_VALID) {
            for (idx = 0; idx < num_of_fields; idx++) {
                sal_memset(field_name, 0, BCMINT_FLOW_LF_NAME_LEN_MAX);
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_flow_logical_field_name_get(unit,
                                                           info->flow_handle,
                                                           field[idx].id,
                                                           field_name));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hd, field_name,
                                           field[idx].value));
            }
        }
        if (info->options & BCM_FLOW_ENCAP_OPTION_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_UPDATE,
                                      BCMLT_PRIORITY_NORMAL));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_INSERT,
                                      BCMLT_PRIORITY_NORMAL));
        }
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hd) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse INT register for encap info.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     cb            User callback function.
 * \param [in]     user_data     User context data.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_encap_int_traverse(int unit,
                            bcm_flow_encap_traverse_cb cb,
                            void *user_data)
{
    int rv = SHR_E_NONE;
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t get_val;
    bcm_flow_encap_config_t info = {0};
    uint32 num_of_fields = 0;
    bcm_flow_logical_field_t field[3];
    char lt_name[BCMINT_FLOW_LT_NAME_LEN_MAX];
    char field_name[BCMINT_FLOW_LF_NAME_LEN_MAX];
    uint32 field_id = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    info.flow_handle = BCMINT_FLOW_ID_INT;
    info.flow_option = BCMINT_FLOW_OPT_ID_ASSIGN_DEVICE_ID_TEMPLATE_ID;
    sal_memset(lt_name, 0, BCMINT_FLOW_LT_NAME_LEN_MAX);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flow_option_logical_table_name_get(unit, info.flow_handle,
                                                      info.flow_option,
                                                      lt_name));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    rv = bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }
    if (rv == SHR_E_NONE) {
        sal_memset(field, 0, 3*sizeof(bcm_flow_logical_field_t));
        num_of_fields = 0;

        sal_memset(field_name, 0, BCMINT_FLOW_LF_NAME_LEN_MAX);
        field_id = BCMINT_FLOW_LF_ID_INT_DEVICE_ID;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_flow_logical_field_name_get(unit, info.flow_handle,
                                                   field_id, field_name));

        rv = bcmlt_entry_field_get(entry_hd, field_name, &get_val);
        if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
            SHR_ERR_EXIT(rv);
        }
        if (rv == SHR_E_NONE) {
            field[num_of_fields].id = field_id;
            field[num_of_fields].value = (uint32_t)get_val;
            num_of_fields++;
        }

        if (num_of_fields) {
            info.valid_elements |= BCM_FLOW_ENCAP_FLEX_DATA_VALID;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (cb(unit, &info, num_of_fields, field, user_data));
    }

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the default VXLAN UDP destination port for termination.
 *
 * \param [in]     unit          Unit Number.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xfs_flow_default_udp_dport_set(
    int unit)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int rv;
    const char *tbl_desc;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    rv = bcmlt_table_desc_get(unit, R_VXLAN_UDP_DST_PORTs, &tbl_desc);
    if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, R_VXLAN_UDP_DST_PORTs, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_field_add(ent_hdl, PORTs, VXLAN_UDP_DST_PORT));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, ent_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover index table mgmt bookkeepings for tunnel initiator.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_flow_tunnel_initiator_recover(int unit, int index)
{
    bcm_flow_tunnel_initiator_t info;
    uint32 ref_cnt;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_get(unit,
                                         BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                         BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                         index, &ref_cnt));
    if (ref_cnt == 0) {
        bcm_flow_tunnel_initiator_t_init(&info);
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_tunnel_initiator_get(unit, index, &info));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_hash_update(unit,
                                                 BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                                 BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                                 &info, index));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_increase(unit,
                                              BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                              BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                              index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover egress encapsulation sequence number profile.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_flow_encap_seq_profile_recover(int unit)
{
    int idx, dvp;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_DVPs, &entry_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, DVPs, &data));
        dvp = data;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, SEQ_NUM_PROFILE_IDXs, &data));
        idx = data;
        /* Skip index 0. */
        if (dvp == 0 && idx == 0) {
            continue;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_tunnel_encap_seq_profile_recover(unit, idx));
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_flow_init(int unit)
{
    xfs_flow_info_t *vi = XFS_FLOW_INFO(unit);
    uint32_t table_num;
    uint64_t min, max;
    bcmi_ltsw_idx_tbl_user_info_t user_info;
    bcmi_ltsw_idx_tbl_lt_info_t lt_info;
    uint32_t ha_alloc_size = 0, ha_req_size = 0;
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    if (vi->xfs_flow_mutex == NULL) {
        vi->xfs_flow_mutex = sal_mutex_create("xfsFlowMutex");
        if (vi->xfs_flow_mutex == NULL) {
            SHR_ERR_EXIT(SHR_E_MEMORY);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_l2_iif_num_get(unit, &table_num));
    vi->l2_iif_num = table_num;

    ha_req_size = table_num * sizeof(uint32_t);
    ha_alloc_size = ha_req_size;
    vi->l2_iif_map = bcmi_ltsw_ha_mem_alloc(unit,
                                            BCMI_HA_COMP_ID_FLOW,
                                            bcmintFlowHaL2iifMap,
                                            "bcmFlowL2iifMap",
                                            &ha_alloc_size);
    SHR_NULL_CHECK(vi->l2_iif_map, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT((ha_alloc_size < ha_req_size) ?
                            SHR_E_MEMORY : SHR_E_NONE);
    if (!warm) {
        sal_memset(vi->l2_iif_map, 0xff, ha_alloc_size);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, EGR_L3_TUNNEL_0s,
                                       EGR_L3_TUNNEL_IDX_0s, &min, &max));
    sal_memset(&lt_info, 0, sizeof(lt_info));
    /* Max number of users of this LT. */
    lt_info.user_cnt  = BCMI_EGR_L3_TNL_USER_ID_CNT;
    lt_info.tbl_name  = EGR_L3_TUNNEL_0s;
    lt_info.idx_field = EGR_L3_TUNNEL_IDX_0s;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = (uint32_t)min;
    user_info.idx_max     = (uint32_t)max;
    user_info.func_hash   = xfs_flow_tunnel_initiator_hash_calc;
    user_info.func_cmp    = xfs_flow_tunnel_initiator_cmp;
    user_info.func_insert = xfs_flow_tunnel_initiator_insert;
    user_info.func_del    = xfs_flow_tunnel_initiator_delete;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                    BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                    &lt_info, &user_info));

    /* Recover tunnel initiator s/w status. */
    if (warm) {
        int tmp_rv;
        uint32_t idx, idx_min, idx_max, tnl_idx;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_tnl_range_get(unit, &idx_min, &idx_max));

        for (idx = idx_min; idx <= idx_max; idx++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_flow_warmboot_tunnel_idx_get(unit, idx, &tnl_idx));
            if (tnl_idx == 0) {
                /* No tunnel configured. */
                continue;
            }
            tmp_rv = xfs_flow_tunnel_initiator_recover(unit, tnl_idx);
            if (SHR_FAILURE(tmp_rv)) {
                if (tmp_rv != SHR_E_NOT_FOUND) {
                    SHR_IF_ERR_VERBOSE_EXIT(tmp_rv);
                }
                continue;
            }
        }

        /* Recover egress encapsulation sequence number profile. */
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_encap_seq_profile_recover(unit));
    }

    /* Set the default Vxlan UDP destination port. */
    if (!warm) {
       SHR_IF_ERR_EXIT_EXCEPT_IF
            (xfs_flow_default_udp_dport_set(unit), SHR_E_UNAVAIL);
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (!warm && (vi->l2_iif_map)) {
            (void)bcmi_ltsw_ha_mem_free(unit, vi->l2_iif_map);
        }

        SHR_IF_ERR_CONT
            (xfs_ltsw_flow_detach(unit));
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_detach(int unit)
{
    xfs_flow_info_t *vi = XFS_FLOW_INFO(unit);
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    if (bcmi_warmboot_get(unit)) {
        SHR_EXIT();
    }

    if (vi->xfs_flow_mutex) {
        sal_mutex_destroy(vi->xfs_flow_mutex);
        vi->xfs_flow_mutex = NULL;
    }

    sal_memset(vi, 0, sizeof(xfs_flow_info_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_tunnel_initiator_delete_all(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_tunnel_term_destroy_all(unit));

    rv = bcmi_ltsw_idx_tbl_unregister(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                      BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    rv = xfs_flow_tunnel_term_bud_loopback_set(unit, FALSE);
    if (SHR_SUCCESS(rv)) {
        SHR_EXIT();
    } else {
        SHR_ERR_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_vpn_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_vpn_t vpn,
    bcm_flow_vpn_config_t *info)
{
    int dunit = 0;
    uint32_t vfi_index = 0;
    const char *dest_type_symbol = NULL;
    uint32_t dest_val = 0;
    uint32_t group_type = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_idx_get(unit, vpn, &vfi_index));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_VFI_TABLEs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, VFIs, vfi_index));

    if (opt == HW_OPT_SET) {
        if ((info->broadcast_group != info->unknown_multicast_group) ||
            (info->broadcast_group != info->unknown_unicast_group)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        group_type = _BCM_MULTICAST_TYPE_GET(info->broadcast_group);
        if (group_type == _BCM_MULTICAST_TYPE_FLOW) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, DESTINATION_TYPEs,
                                              L3MC_GROUPs));
        } else if (group_type == _BCM_MULTICAST_TYPE_L2) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, DESTINATION_TYPEs,
                                              L2MC_GROUPs));
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        dest_val = _BCM_MULTICAST_ID_GET(info->broadcast_group);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, DESTINATIONs, dest_val));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    } else if (opt == HW_OPT_GET) {
        uint64_t f_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, DESTINATION_TYPEs,
                                          &dest_type_symbol));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, DESTINATIONs, &f_val));
        dest_val = (uint32_t)f_val;

        if (sal_strcmp(L3MC_GROUPs, dest_type_symbol) == 0) {
            _BCM_MULTICAST_GROUP_SET(info->broadcast_group,
                                     _BCM_MULTICAST_TYPE_FLOW, dest_val);
        } else if (sal_strcmp(L2MC_GROUPs, dest_type_symbol) == 0) {
            _BCM_MULTICAST_GROUP_SET(info->broadcast_group,
                                     _BCM_MULTICAST_TYPE_L2, dest_val);
        } else {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
        info->unknown_multicast_group = info->broadcast_group;
        info->unknown_unicast_group = info->broadcast_group;

    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_vp_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_port_t *flow_port)
{
    int dunit = 0;
    int vp = -1;
    int field_val = 0;
    uint8_t network_group = 0;
    uint32_t fld_width = 0;
    uint64_t get_val;
    bcmlt_entry_handle_t ent_hd_ing_svp = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t ent_hd_ing_dvp = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t ent_hd_egr_dvp = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t ent_hd_def_svp = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t hd_egr_dvp_get = BCMLT_INVALID_HDL;
    int local_rv = SHR_E_NOT_FOUND;
    bcmi_ltsw_sbr_profile_tbl_hdl_t pth = BCMI_LTSW_SBR_PTH_COUNT;
    bcmi_ltsw_sbr_profile_ent_type_t ent_type = BCMI_LTSW_SBR_PET_COUNT;
    int profile_idx = 0;
    bcmi_ltsw_qos_map_type_t qos_type;
    int qos_base_ptr;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    uint32_t vp_user_bmp = 0;

    SHR_FUNC_ENTER(unit);

    vp = BCM_GPORT_FLOW_PORT_ID_GET(flow_port->flow_port_id);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_SVP_TABLEs, &ent_hd_ing_svp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hd_ing_svp, SVPs, vp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_DVP_TABLEs, &ent_hd_ing_dvp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hd_ing_dvp, DVPs, vp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_DVPs, &ent_hd_egr_dvp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hd_egr_dvp, DVPs, vp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, R_L2_TUNNEL_DEFAULT_NETWORK_SVPs,
                              &ent_hd_def_svp));

    if (opt == HW_OPT_SET) {
        bcmlt_opcode_t opcode = (flow_port->flags & BCM_FLOW_PORT_REPLACE)?
                                 BCMLT_OPCODE_UPDATE:BCMLT_OPCODE_INSERT;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_width_get(unit, ING_SVP_TABLEs,
                                     OPAQUE_CTRL_IDs,
                                     &fld_width));
        if ((flow_port->ingress_opaque_ctrl_id < 0) ||
            (flow_port->ingress_opaque_ctrl_id > (1 << fld_width))) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_width_get(unit, ING_SVP_TABLEs,
                                     NETWORK_GROUP_BITMAPs,
                                     &fld_width));
        /* NETWORK_GROUP_BITMAP Bit 0 is reserved. */
        if (flow_port->network_group_id > (fld_width - 1)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        if (flow_port->flags & BCM_FLOW_PORT_SERVICE_TAGGED) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        if (flow_port->network_group_id == 0) {
            field_val = 0;
        } else {
            field_val = 1 << flow_port->network_group_id;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hd_ing_svp, NETWORK_GROUP_BITMAPs,
                                   field_val));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hd_ing_svp, CLASS_IDs,
                                   flow_port->if_class));

        if (flow_port->dscp_map_id != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_resolve(unit, flow_port->dscp_map_id,
                                              &qos_type, &qos_base_ptr));
            if (qos_type != bcmiQosMapTypeL3Ingress) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        } else {
            qos_base_ptr = 0;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hd_ing_svp, DSCP_PTRs, qos_base_ptr));

        if (flow_port->vlan_pri_map_id != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_resolve(unit, flow_port->vlan_pri_map_id,
                                              &qos_type, &qos_base_ptr));
            if (qos_type != bcmiQosMapTypeL2Ingress) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        } else {
            qos_base_ptr = 0;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hd_ing_svp, DOT1P_PTRs, qos_base_ptr));

        if (flow_port->flags & BCM_FLOW_PORT_NETWORK) {
            if (flow_port->drop_mode > bcmFlowPortSplitHorizonDropL2) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }

            if (flow_port->flags & BCM_FLOW_PORT_REPLACE) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(dunit, EGR_DVPs, &hd_egr_dvp_get));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(hd_egr_dvp_get, DVPs, vp));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_lt_entry_commit(unit, hd_egr_dvp_get,
                                          BCMLT_OPCODE_LOOKUP,
                                          BCMLT_PRIORITY_NORMAL));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(hd_egr_dvp_get, SPLIT_HORIZON_CTRLs,
                                           &get_val));
                field_val = (int)get_val;
            } else {
                /* Enable split horizon check. */
                field_val = 1 << VP_SHC_EN_SFT;
            }

            if (flow_port->drop_mode == bcmFlowPortSplitHorizonDropL2) {
                field_val |= 1 << VP_SHC_L2_ONLY_SFT;
            } else {
                field_val &= ~(1 << VP_SHC_L2_ONLY_SFT);
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp, SPLIT_HORIZON_CTRLs,
                                       field_val));
        }

        field_val = 0;
        if (flow_port->flags & BCM_FLOW_PORT_MULTICAST_GROUP_REMAP) {
            field_val = 1;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hd_ing_svp, IPMC_REMAP_ENABLEs,
                                   field_val));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hd_ing_svp, OPAQUE_CTRL_IDs,
                                   flow_port->ingress_opaque_ctrl_id));

        /* Below are default configuraion which are not controlled by API. */
        if (!(flow_port->flags & BCM_FLOW_PORT_REPLACE)) {
            /* ING_SVP_TABLE configuration. */
            field_val = BCMI_XFS_CML_FLAGS_LEARN;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_ing_svp, CML_FLAGS_NEWs,
                                       field_val));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_ing_svp, CML_FLAGS_MOVEs,
                                       field_val));

            field_val = BCMI_XFS_VLAN_TAG_PRESERVE_CTRL_DEF;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_ing_svp, VLAN_TAG_PRESERVE_CTRLs,
                                       field_val));
            field_val = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_ing_svp, DEFAULT_OTAG_DOT1P_CFIs,
                                       field_val));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_ing_svp, DEFAULT_ITAG_DOT1P_CFIs,
                                       field_val));

            /* ING_DVP_TABLE configuration. */
            /* Disable cut through. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_ing_dvp, NO_CUT_THRUs, 0x1));

            pth = BCMI_LTSW_SBR_PTH_ING_DVP;
            if (flow_port->flags & BCM_FLOW_PORT_NETWORK) {
                ent_type = BCMI_LTSW_SBR_PET_NO_DESTINATION_NO_L2MC_L3MC_L2_OIF_SYS_DST_VALID;
            } else {
                ent_type = BCMI_LTSW_SBR_PET_NO_NO_CUT_THRU;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                                     &profile_idx));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_ing_dvp, STRENGTH_PROFILE_INDEXs,
                                       profile_idx));

            /* EGR_DVP configuration. */
            if (flow_port->flags & BCM_FLOW_PORT_NETWORK) {
                /* Enable egr_vlan_translation_2 for VNID assignment. */
                field_val = 1 << BCMI_XFS_VP_PROCESS_CTRL_EVXLT2_EN_SFT;
                /* Delete payload vlan. */
                field_val |= 1 << BCMI_XFS_VP_PROCESS_CTRL_ITAG_DEL_SFT;
                /* Disable egr_vlan_translation. */
                field_val |= 1 << BCMI_XFS_VP_PROCESS_CTRL_EVXLT1_DISABLE_SFT;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, PROCESS_CTRLs,
                                           field_val));

                /* Enable L2 tunnel init. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, EDIT_CTRL_IDs,
                                           VP_EDIT_CTRL_INIT_L2_TUNNEL));
                field_val = VP_OBJ_TABLE_SEL_1_L2_OIF |
                            VP_OBJ_TABLE_SEL_1_L3_OIF_2 |
                            VP_OBJ_TABLE_SEL_1_EGR_L3_TUNNEEL;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, OBJ_TABLE_SEL_1s,
                                           field_val));
            } else {
                /* Egr_vlan_translation_1 select for Access VP. */
                field_val = 1 << BCMI_XFS_VP_PROCESS_CTRL_EVXLT1_SELECT_SFT;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, PROCESS_CTRLs,
                                           field_val));
            }

            pth = BCMI_LTSW_SBR_PTH_EGR_DVP;
            ent_type = BCMI_LTSW_SBR_PET_NO_CLASSID;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                                     &profile_idx));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp, STRENGTH_PRFL_IDXs,
                                       profile_idx));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_ing_svp, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        if (flow_port->flags & BCM_FLOW_PORT_DEFAULT) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_def_svp, SVPs, vp));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_set_commit(unit, ent_hd_def_svp,
                                          BCMLT_PRIORITY_NORMAL));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_ing_dvp, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_egr_dvp, opcode,
                                  BCMLT_PRIORITY_NORMAL));
    } else if (opt == HW_OPT_GET) {
        uint64_t get_val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_ing_svp, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_ing_svp, NETWORK_GROUP_BITMAPs,
                                   &get_val));
        field_val = (uint32_t)get_val;
        while (field_val > 1) {
            field_val = field_val >> 1;
            network_group++;
        }
        flow_port->network_group_id = network_group;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_ing_svp, CLASS_IDs,
                                   &get_val));
        flow_port->if_class = (uint32_t)get_val;

        flow_port->dscp_map_id = 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_ing_svp, DSCP_PTRs, &get_val));
        qos_base_ptr = (uint32_t)get_val;
        if (qos_base_ptr != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_construct(unit, qos_base_ptr,
                                                bcmiQosMapTypeL3Ingress,
                                                &(flow_port->dscp_map_id)));
        }

        flow_port->vlan_pri_map_id = 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_ing_svp, DOT1P_PTRs, &get_val));
        qos_base_ptr = (uint32_t)get_val;
        if (qos_base_ptr != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_construct(unit, qos_base_ptr,
                                                bcmiQosMapTypeL2Ingress,
                                                &(flow_port->vlan_pri_map_id)));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_ing_svp,
                                   IPMC_REMAP_ENABLEs, &get_val));
        if (get_val) {
            flow_port->flags |= BCM_FLOW_PORT_MULTICAST_GROUP_REMAP;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_ing_svp,
                                   OPAQUE_CTRL_IDs, &get_val));
        flow_port->ingress_opaque_ctrl_id = (int)get_val;

        /* Default SVP handling */
        local_rv = bcmi_lt_entry_commit(unit, ent_hd_def_svp,
                                        BCMLT_OPCODE_LOOKUP,
                                        BCMLT_PRIORITY_NORMAL);
        if (local_rv == SHR_E_NONE) {
            /* default SVP configured */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(ent_hd_def_svp, SVPs,
                                       &get_val));
            if ((int)get_val == vp){
                flow_port->flags |= BCM_FLOW_PORT_DEFAULT;
            }
        } else if (local_rv == SHR_E_NOT_FOUND) {
            /* default SVP not configured */
        } else {
            /* something wrong internally */
            SHR_ERR_EXIT(local_rv);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_egr_dvp, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_egr_dvp, SPLIT_HORIZON_CTRLs,
                                   &get_val));
        if ((get_val >> VP_SHC_L2_ONLY_SFT) & VP_SHC_L2_ONLY_MSK) {
            flow_port->drop_mode = bcmFlowPortSplitHorizonDropL2;
        } else {
            flow_port->drop_mode = bcmFlowPortSplitHorizonDropAll;
        }
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_ing_svp, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_ing_dvp, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_egr_dvp, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));

        /* Default SVP handling */
        local_rv = bcmi_lt_entry_commit(unit, ent_hd_def_svp,
                                        BCMLT_OPCODE_LOOKUP,
                                        BCMLT_PRIORITY_NORMAL);
        if (local_rv == SHR_E_NONE) {
            /* default SVP configured */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(ent_hd_def_svp, SVPs,
                                       &get_val));
            if ((int)get_val == vp){
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_lt_entry_commit(unit, ent_hd_def_svp,
                                          BCMLT_OPCODE_DELETE,
                                          BCMLT_PRIORITY_NORMAL));
            }
        } else if (local_rv == SHR_E_NOT_FOUND) {
            /* default SVP not configured */
        } else {
            /* something wrong internally */
            SHR_ERR_EXIT(local_rv);
        }
        bcmi_ltsw_virtual_vp_info_init(&vp_info);
        vp_user_bmp = (1 << BCMI_LTSW_VIRTUAL_VP_USER_DVP_PG) |
                      (1 << BCMI_LTSW_VIRTUAL_VP_USER_L2_OIF);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vp_info_update(unit, vp, 0,
                                              vp_user_bmp, &vp_info));
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hd_ing_svp) {
        (void) bcmlt_entry_free(ent_hd_ing_svp);
    }
    if (BCMLT_INVALID_HDL != ent_hd_ing_dvp) {
        (void) bcmlt_entry_free(ent_hd_ing_dvp);
    }
    if (BCMLT_INVALID_HDL != ent_hd_egr_dvp) {
        (void) bcmlt_entry_free(ent_hd_egr_dvp);
    }
    if (BCMLT_INVALID_HDL != ent_hd_def_svp) {
        (void) bcmlt_entry_free(ent_hd_def_svp);
    }
    if (BCMLT_INVALID_HDL != hd_egr_dvp_get) {
        (void) bcmlt_entry_free(hd_egr_dvp_get);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_match_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_match_config_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_match_param_validation(unit, opt, info));

    if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_match_port_ctrl(unit, opt, info));
    } else if (xfs_flow_match_on_vlan_xlate(unit, info)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_match_ing_xlate_ctrl(unit, opt, info));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_match_general_ctrl(unit, opt, info));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_match_traverse(
    int unit,
    bcm_flow_match_traverse_cb cb,
    void *user_data)
{
    const char *lt_list[] = {L2_TUNNEL_VN_ID_TABLEs,
                             L2_TUNNEL_IPV4_SIP_TABLEs,
                             L2_TUNNEL_IPV6_SIP_TABLEs};
    int lt_num = COUNTOF(lt_list);
    int idx = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_match_port_table_traverse(unit, cb, user_data,
                                            ING_SYSTEM_PORT_TABLEs));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_match_vlan_ing_xlate_traverse(unit, cb, user_data));

    for (idx = 0; idx < lt_num; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_match_hash_table_traverse(unit, cb, user_data,
                                                lt_list[idx]));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_encap_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_encap_config_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_encap_param_validation(unit, opt, info));

    if (info->flow_handle == BCMINT_FLOW_ID_INT) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_flow_encap_int_ctrl(unit, opt, info,
                                          num_of_fields, field));
    } else if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_encap_vfi_ctrl(unit, opt, info));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_encap_general_ctrl(unit, opt, info));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_encap_traverse(
    int unit,
    bcm_flow_encap_traverse_cb cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_encap_vfi_table_traverse(unit, cb, user_data, EGR_VFIs));

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_encap_hash_table_traverse(unit, cb, user_data,
                                            EGR_VLAN_TRANSLATION_2s));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_encap_int_traverse(unit, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_port_encap_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_port_encap_t *info)
{
    int dunit = 0;
    int vp = -1;
    bcmlt_entry_handle_t ent_hd_egr_dvp = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t ent_hd_egr_dvp_read = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t ent_hd_ing_dvp = BCMLT_INVALID_HDL;
    uint64_t get_val;
    uint32_t set_val;
    uint32_t seq_num, vp_user_bmp = 0;
    bcmi_ltsw_sbr_profile_tbl_hdl_t pth = BCMI_LTSW_SBR_PTH_EGR_DVP;
    bcmi_ltsw_sbr_profile_ent_type_t ent_type = BCMI_LTSW_SBR_PET_NO_CLASSID;
    int profile_idx = 0;
    bcmi_ltsw_qos_map_type_t qos_type;
    int qos_base_ptr;
    bcmi_ltsw_virtual_vp_info_t vp_info, vp_info_update;
    bcmi_ltsw_ecmp_member_dest_info_t dest_info;
    const bcmint_flow_lt_t *variant_egr_dvp = NULL;
    int rv;
    const char *fld_name;
    const bcmint_flow_fld_t *flds;
    int fid;
    int modid = 0, is_local = 0;
    uint64_t value, dest;
    int l2_if, if_type = 0;
    bcm_port_group_range_t range;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_port_encap_param_validation(unit, opt, info));

    dunit = bcmi_ltsw_dev_dunit(unit);

    vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_DVPs, &ent_hd_egr_dvp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hd_egr_dvp, DVPs, vp));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_DVPs, &ent_hd_egr_dvp_read));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hd_egr_dvp_read, DVPs, vp));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_DVP_TABLEs, &ent_hd_ing_dvp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hd_ing_dvp, DVPs, vp));

    rv = bcmint_flow_lt_get(unit, BCMINT_LTSW_FLOW_LT_EGR_DVP,
                            &variant_egr_dvp);
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_UNAVAIL);

    bcmi_ltsw_virtual_vp_info_init(&vp_info);
    bcmi_ltsw_virtual_vp_info_init(&vp_info_update);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info));

    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_egr_dvp, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_ing_dvp, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_egr_dvp, CLASS_IDs, &get_val));
        info->class_id = (int)get_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_egr_dvp, GROUP_IDs, &get_val));
        info->dvp_group = (int)get_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_egr_dvp, SPLIT_HORIZON_CTRLs, &get_val));
        info->network_group = (int)get_val & VP_SHC_DOMAIN_ID_MSK;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_egress_obj_get(unit, info->flow_port,
                                                   &info->egress_if));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_egr_dvp, SEQ_NUM_PROFILE_IDXs,
                                   &get_val));
        if (get_val != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(ent_hd_egr_dvp, SEQ_NUM_COUNTER_IDXs,
                                       &get_val));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_tunnel_encap_seq_num_get(unit, (int)get_val, 0,
                                                    &seq_num));
            info->ip4_id = seq_num;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_egr_dvp, DOT1P_REMARK_BASE_PTRs,
                                   &get_val));
        qos_base_ptr = (int)get_val;
        if (qos_base_ptr != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_construct(unit, qos_base_ptr,
                                                bcmiQosMapTypeL2Egress,
                                                &(info->vlan_pri_map_id)));
        }

        if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_CASCADED) {
            info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_EGRESS_CASCADED;
        }
        if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(ent_hd_ing_dvp,
                                       L2MC_L3MC_L2_OIF_SYS_DST_VALIDs,
                                       &value));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(ent_hd_ing_dvp, DESTINATIONs, &dest));
            if (value == DEST_TYPE_L2_OIF) {
                l2_if = (int)dest;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_l2_if_to_port(unit, l2_if, &info->dst_port));
            }
        }

        if (variant_egr_dvp != NULL) {
            flds = variant_egr_dvp->flds;
            fid  = BCMINT_LTSW_FLOW_FLD_EGR_DVP_L2_MTU_VALUE;
            if (variant_egr_dvp->fld_bmp & (1 << fid)) {
                fld_name = flds[fid].name;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(ent_hd_egr_dvp, fld_name, &get_val));
                info->mtu = (int)get_val;
            }
        }
    } else if (opt == HW_OPT_SET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_egr_dvp_read,
                                  BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        if (info->options & BCM_FLOW_PORT_ENCAP_OPTION_CLEAR) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp, CLASS_IDs,
                                       BCMINT_FLOW_CLASS_ID_RESERVED));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                                     &profile_idx));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp, STRENGTH_PRFL_IDXs,
                                       profile_idx));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp, GROUP_IDs,
                                       BCMINT_FLOW_VP_GROUP_DEF));
            vp_user_bmp |= 1 << BCMI_LTSW_VIRTUAL_VP_USER_DVP_PG;
            vp_info_update.dvp_pg = BCMINT_FLOW_VP_GROUP_DEF;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(ent_hd_egr_dvp_read,
                                       SPLIT_HORIZON_CTRLs,
                                       &get_val));
            set_val = get_val & (~VP_SHC_DOMAIN_ID_MSK);
            set_val |= BCMINT_FLOW_NETWORK_GROUP_DEF << VP_SHC_DOMAIN_ID_SFT;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp, SPLIT_HORIZON_CTRLs,
                                       set_val));
            if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, EDIT_CTRL_IDs,
                                           VP_EDIT_CTRL_INIT_L2_TUNNEL));
                set_val = VP_OBJ_TABLE_SEL_1_L2_OIF |
                          VP_OBJ_TABLE_SEL_1_L3_OIF_2 |
                          VP_OBJ_TABLE_SEL_1_EGR_L3_TUNNEEL;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, OBJ_TABLE_SEL_1s,
                                           set_val));
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp,
                                       DOT1P_REMARK_BASE_PTRs, 0));

            if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_CASCADED)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_port_egress_obj_set(unit,
                                                           info->flow_port,
                                                           0x0));
            }
            if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT)) {
                dest = 0;
                value = 0;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_ing_dvp, DESTINATIONs, dest));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_ing_dvp,
                                           L2MC_L3MC_L2_OIF_SYS_DST_VALIDs,
                                           value));
                vp_user_bmp |= 1 << BCMI_LTSW_VIRTUAL_VP_USER_L2_OIF;
                vp_info_update.l2_oif = value;
            }

            if (variant_egr_dvp != NULL) {
                flds = variant_egr_dvp->flds;
                fid  = BCMINT_LTSW_FLOW_FLD_EGR_DVP_L2_MTU_VALUE;
                if (variant_egr_dvp->fld_bmp & (1 << fid)) {
                    fld_name = flds[fid].name;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(ent_hd_egr_dvp, fld_name, 0));
                }
                fid  = BCMINT_LTSW_FLOW_FLD_EGR_DVP_PROCESS_CTRL_2;
                if (variant_egr_dvp->fld_bmp & (1 << fid)) {
                    fld_name = flds[fid].name;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(ent_hd_egr_dvp, fld_name, 0));
                }
            }
        } else {
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_FLAGS_VALID) {
                if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_EGRESS_CASCADED) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_virtual_port_cascaded_set(unit,
                                                             info->flow_port,
                                                             1));
                    sal_memset(&dest_info, 0, sizeof(dest_info));
                    dest_info.type = BCMI_LTSW_ECMP_MEMBER_DEST_T_L2_CASCADED;
                    dest_info.ul_egr_obj = info->egress_if;
                    dest_info.dvp        = vp;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_ecmp_member_dest_update(unit, &dest_info));
                }
            }
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_DST_PORT_VALID) {
                if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT)) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_port_to_l2_if(unit, info->dst_port, &l2_if));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(ent_hd_ing_dvp,
                                               DESTINATIONs, l2_if));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(ent_hd_ing_dvp,
                                               L2MC_L3MC_L2_OIF_SYS_DST_VALIDs,
                                               DEST_TYPE_L2_OIF));
                    vp_user_bmp |= 1 << BCMI_LTSW_VIRTUAL_VP_USER_L2_OIF;
                    vp_info_update.l2_oif = l2_if;
                    if (BCM_GPORT_IS_TRUNK(info->dst_port)) {
                        if_type = BCMI_LTSW_VIRTUAL_VP_USER_FLAG_TRUNK;
                    } else if (BCM_GPORT_IS_MODPORT(info->dst_port)){
                        modid = BCM_GPORT_MODPORT_MODID_GET(info->dst_port);
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_modid_is_local(unit, modid, &is_local));
                        if (!is_local) {
                            if_type = BCMI_LTSW_VIRTUAL_VP_USER_FLAG_REMOTE;
                        }
                    }
                }
            }

            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_CLASS_ID_VALID) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, CLASS_IDs,
                                           info->class_id));
                ent_type = BCMI_LTSW_SBR_PET_DEF;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                                         &profile_idx));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, STRENGTH_PRFL_IDXs,
                                           profile_idx));
            }
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_DVP_GROUP_VALID) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_port_group_range_get(unit,
                                                   bcmPortGroupDvp, &range));
                if ((info->dvp_group) &&
                    (info->dvp_group > range.max || info->dvp_group < range.min)) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, GROUP_IDs,
                                           info->dvp_group));
                vp_user_bmp |= 1 << BCMI_LTSW_VIRTUAL_VP_USER_DVP_PG;
                vp_info_update.dvp_pg = info->dvp_group;
            }
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_MTU_VALID) {
                if (variant_egr_dvp != NULL) {
                    flds = variant_egr_dvp->flds;
                    fid  = BCMINT_LTSW_FLOW_FLD_EGR_DVP_L2_MTU_VALUE;
                    fld_name = flds[fid].name;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(ent_hd_egr_dvp, fld_name,
                                               info->mtu));
                    fid  = BCMINT_LTSW_FLOW_FLD_EGR_DVP_PROCESS_CTRL_2;
                    fld_name = flds[fid].name;
                    set_val = 0;
                    if (info->mtu > 0) {
                        set_val |= EGR_DVP_PROCESS_CTRL_2_MTU_CHK_EN;
                    }
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(ent_hd_egr_dvp, fld_name,
                                               set_val));
                } else {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }
            }
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_NETWORK_GROUP_VALID) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(ent_hd_egr_dvp_read,
                                           SPLIT_HORIZON_CTRLs,
                                           &get_val));
                set_val= get_val & (~VP_SHC_DOMAIN_ID_MSK);
                set_val |= info->network_group << VP_SHC_DOMAIN_ID_SFT;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, SPLIT_HORIZON_CTRLs,
                                           set_val));
            }
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_EGRESS_IF_VALID) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_port_egress_obj_set(unit, info->flow_port,
                                                           info->egress_if));
            }

            if (info->valid_elements &
                BCM_FLOW_PORT_ENCAP_VLAN_PRI_MAP_ID_VALID) {
                if (info->vlan_pri_map_id != 0) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_qos_map_id_resolve(unit,
                                                      info->vlan_pri_map_id,
                                                      &qos_type,
                                                      &qos_base_ptr));
                    if (qos_type != bcmiQosMapTypeL2Egress) {
                        SHR_ERR_EXIT(SHR_E_PARAM);
                    }
                } else {
                    qos_base_ptr = 0;
                }

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp,
                                           DOT1P_REMARK_BASE_PTRs,
                                           qos_base_ptr));
            }

            /* Default configuration not controled by API. */
            if ((info->flow_handle == 0) ||
                (info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN) ||
                (info->flow_handle == BCMINT_FLOW_ID_VXLAN)) {
                if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT) {
                    /* Enable tunnel init on network port. */
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(ent_hd_egr_dvp, EDIT_CTRL_IDs,
                                               VP_EDIT_CTRL_INIT_L2_TUNNEL));

                    set_val = VP_OBJ_TABLE_SEL_1_L2_OIF |
                              VP_OBJ_TABLE_SEL_1_L3_OIF_2 |
                              VP_OBJ_TABLE_SEL_1_EGR_L3_TUNNEEL;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(ent_hd_egr_dvp, OBJ_TABLE_SEL_1s,
                                               set_val));
                }
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vp_info_update(unit, vp, if_type,
                                              vp_user_bmp, &vp_info_update));

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_port_encap_ipv4_id_set(unit, info, ent_hd_egr_dvp_read,
                                             ent_hd_egr_dvp));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_egr_dvp, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_ing_dvp, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hd_egr_dvp) {
        (void) bcmlt_entry_free(ent_hd_egr_dvp);
    }
    if (BCMLT_INVALID_HDL != ent_hd_egr_dvp_read) {
        (void) bcmlt_entry_free(ent_hd_egr_dvp_read);
    }
    if (BCMLT_INVALID_HDL != ent_hd_ing_dvp) {
        (void) bcmlt_entry_free(ent_hd_ing_dvp);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_l2_if_to_port(
    int unit,
    int l2_if,
    bcm_port_t *port)
{
    int vp = -1;

    SHR_FUNC_ENTER(unit);

    vp = xfs_flow_match_vp_find(unit, l2_if);
    if (vp != -1) {
        BCM_GPORT_FLOW_PORT_ID_SET(*port, vp);
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_NOT_FOUND,
                            (BSL_META_U(unit, "Make sure port match added!\n")));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_port_to_l2_if(
    int unit,
    bcm_port_t port,
    int *l2_if)
{
    int vp = -1;
    uint8_t type = 0;
    int l2_iif = 0;
    xfs_flow_info_t *vi = XFS_FLOW_INFO(unit);

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flow_port_type(unit, port, &type));
    if (!type) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Access port only!\n")));
    }

    vp = BCM_GPORT_FLOW_PORT_ID_GET(port);
    XFS_FLOW_LOCK(unit);
    l2_iif = vi->l2_iif_map[vp];
    XFS_FLOW_UNLOCK(unit);
    if (l2_iif == INVALID_L2_IF) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_NOT_FOUND,
                            (BSL_META_U(unit, "Make sure port match added!\n")));
    } else {
        *l2_if = l2_iif;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_tunnel_term_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_tunnel_terminator_t *info)
{
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    uint8_t valid = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_tunnel_term_param_validation(unit, opt, info));

    dunit = bcmi_ltsw_dev_dunit(unit);

    xfs_flow_tunnel_term_lt_determine(unit, info, &lt_name);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_tunnel_term_key_set(unit, info, entry_hd));
    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_tunnel_term_criteria_determine(unit, lt_name, info));

        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                                     BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_tunnel_term_data_get(unit, info, lt_name, entry_hd,
                                           &valid));
    } else if (opt == HW_OPT_SET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_tunnel_term_data_set(unit, info, entry_hd));
        if (info->flags & BCM_TUNNEL_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_UPDATE,
                                      BCMLT_PRIORITY_NORMAL));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_INSERT,
                                      BCMLT_PRIORITY_NORMAL));
        }
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hd) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();

}

int
xfs_ltsw_flow_tunnel_term_traverse(
    int unit,
    bcm_flow_tunnel_terminator_traverse_cb cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_tunnel_term_hash_table_traverse(unit, cb, user_data,
                                                  L2_TUNNEL_IPV4_DIP_TABLEs));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_tunnel_term_hash_table_traverse(unit, cb, user_data,
                                                  L2_TUNNEL_IPV6_DIP_TABLEs));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_tunnel_initiator_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_tunnel_initiator_t *info)
{
    uint32_t tnl_idx = 0;
    uint32_t soft_tnl_idx = 0;
    uint8_t tnl_allocated = 0;
    bcmi_ltsw_tunnel_type_t tnl_type;

    SHR_FUNC_ENTER(unit);

    if (!((opt == HW_OPT_SET) && !(info->flags & BCM_TUNNEL_REPLACE))) {
        BCMI_LTSW_GPORT_TUNNEL_ID_GET(info->tunnel_id, tnl_type, soft_tnl_idx);
        SHR_IF_ERR_VERBOSE_EXIT
            ((tnl_type == bcmiTunnelTypeFlexFlow) ? SHR_E_NONE: SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_tunnel_initiator_param_validation(unit, opt, info));

    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_tunnel_initiator_get(unit, tnl_idx, info));
        BCM_GPORT_FLOW_PORT_ID_SET(info->flow_port, soft_tnl_idx);
    } else if (opt == HW_OPT_SET) {
        uint32 flag;

        flag = BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO;
        if (info->flags & BCM_TUNNEL_REPLACE) {
           flag |= BCMI_LTSW_IDX_TBL_OP_REPLACE | BCMI_LTSW_IDX_TBL_OP_WITH_ID;
           SHR_IF_ERR_VERBOSE_EXIT
               (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_alloc(unit, flag,
                                           BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                           BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                           info,  (int *)(&tnl_idx)));
        tnl_allocated = 1;
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DIP6_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_flow_tunnel_initiator_dip_idx_set(unit, info->flow_port,
                                                       tnl_idx, &(info->dip6),
                                                       NULL));
        } else if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DIP_VALID){
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_flow_tunnel_initiator_dip_idx_set(unit, info->flow_port,
                                                       tnl_idx, NULL,
                                                       &(info->dip)));
        } else {
          /* Do nothing */
        }
        if (!(info->flags & BCM_TUNNEL_REPLACE)) {
            soft_tnl_idx = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
            BCMI_LTSW_GPORT_TUNNEL_ID_SET(info->tunnel_id,
                                          bcmiTunnelTypeFlexFlow,
                                          soft_tnl_idx);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_flow_tunnel_idx_set(unit, soft_tnl_idx, tnl_idx));
        }
    } else if (opt == HW_OPT_CLR) {
        bcm_gport_t flow_port;

        BCM_GPORT_FLOW_PORT_ID_SET(flow_port, soft_tnl_idx);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_free(unit, 0,
                                          BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                          BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                          tnl_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_tunnel_initiator_dip_idx_set(unit, flow_port,
                                                   BCMINT_FLOW_EGR_TUNNEL_RESERVED,
                                                   NULL,
                                                   NULL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_tunnel_idx_set(unit, soft_tnl_idx,
                                        BCMINT_FLOW_EGR_TUNNEL_RESERVED));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:
    if (SHR_FUNC_ERR() && tnl_allocated) {
        (void)bcmi_ltsw_idx_tbl_entry_free(unit, 0,
                                           BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                           BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                           tnl_idx);
        (void)xfs_flow_tunnel_initiator_dip_idx_set(unit, info->flow_port,
                                                     0, 0 ,0);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_tunnel_initiator_traverse(
    int unit,
    bcm_flow_tunnel_initiator_traverse_cb cb,
    void *user_data)
{
    uint32_t vp_num = 0;
    uint32_t vp_idx = 0;
    bcm_flow_tunnel_initiator_t info;
    uint32_t tnl_idx;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_num_get(unit, &vp_num));

    for (vp_idx = 0; vp_idx < vp_num; vp_idx++) {
        if (bcmi_ltsw_virtual_vp_used_get(unit, vp_idx,
                                          BCMI_LTSW_VP_TYPE_FLOW)) {
            continue;
        }

        bcm_flow_tunnel_initiator_t_init(&info);
        BCM_GPORT_FLOW_PORT_ID_SET(info.flow_port, vp_idx);

        BCMI_LTSW_GPORT_TUNNEL_ID_SET(info.tunnel_id,
                                      bcmiTunnelTypeFlexFlow, vp_idx);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_tunnel_idx_get(unit, vp_idx, &tnl_idx));
        if (tnl_idx == BCMINT_FLOW_EGR_TUNNEL_RESERVED) {
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_flow_tunnel_initiator_get(unit, tnl_idx, &info));

        if((info.type != bcmTunnelTypeVxlan) &&
            (info.type != bcmTunnelTypeVxlan6)) {
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (cb(unit, &info, 0, NULL, user_data));
   }

   if (SHR_FUNC_VAL_IS(SHR_E_NOT_FOUND)) {
       SHR_EXIT();
   }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_stat_attach(
    int unit,
    bcm_flow_stat_info_t *info,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_stat_param_validation(unit, info));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_stat_counter_source_validation(unit, info,
                                                 &counter_info));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_attach_counter_id_status_update(unit,
                                                           stat_counter_id));

    SHR_IF_ERR_CONT
        (xfs_flow_stat_update(unit, info, &counter_info, TRUE));

    if (SHR_FUNC_ERR()) {
        (void)
        bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                          stat_counter_id);
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_stat_detach(
    int unit,
    bcm_flow_stat_info_t *info,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_stat_param_validation(unit, info));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_stat_counter_source_validation(unit, info,
                                                 &counter_info));

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_flow_stat_update(unit, info, &counter_info, FALSE));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                           stat_counter_id));
exit:
    SHR_FUNC_EXIT();
}

void
xfs_ltsw_flow_sw_dump(int unit)
{
    xfs_flow_info_t *fi = XFS_FLOW_INFO(unit);
    uint32_t l2_iif_num = 0, l2_iif;
    int acc_vp;
    int prints_per_line = 0;

    if (SHR_FAILURE(bcmi_ltsw_virtual_l2_iif_num_get(unit, &l2_iif_num))) {
        return;
    }

    LOG_CLI((BSL_META_U(unit,
                        "L2_IIF count: %#x\n"), fi->l2_iif_num));

    for (acc_vp = 0; acc_vp < l2_iif_num; acc_vp++) {
        l2_iif = fi->l2_iif_map[acc_vp];
        if (l2_iif == 0xffffffff) {
            continue;
        }
        prints_per_line++;
        if(prints_per_line % 2 == 0) {
            prints_per_line = 0;
            LOG_CLI((BSL_META_U(unit, "\n")));
        }
        LOG_CLI((BSL_META_U(unit,
                            "      VP %#x: L2_IIF %#x"), acc_vp, l2_iif));
    }
    LOG_CLI((BSL_META_U(unit, "\n")));

    return;
}

int
xfs_ltsw_flow_evpn_enable_set(
    int unit,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_flow_evpn_enable_get(
    int unit,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);

exit:
    SHR_FUNC_EXIT();
}

