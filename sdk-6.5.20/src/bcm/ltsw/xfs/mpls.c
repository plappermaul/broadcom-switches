/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>
#include <bcm_int/common/multicast.h>
#include <bcm_int/ltsw/generated/mpls_ha.h>
#include <bcm_int/ltsw/issu.h>
#include <bcm_int/ltsw/xfs/l3_intf.h>

#include <bcm_int/ltsw/xfs/mpls.h>
#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/ecn.h>
#include <bcm_int/ltsw/failover.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/l3_intf_int.h>
#include <bcm_int/ltsw/xfs/types.h>
#include <bcm_int/ltsw/types.h>
#include <bcm_int/ltsw/mpls_int.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/qos.h>
#include <bcm_int/ltsw/sbr.h>
#include <bcm_int/ltsw/index_table_mgmt.h>
#include <bcm_int/ltsw/l3_egress.h>
#include <bcm_int/ltsw/tunnel.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/vlan.h>
#include <bcm_int/ltsw/l2.h>
#include <bcm_int/ltsw/l3_intf.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/trunk.h>
#include <bcm_int/ltsw/dev.h>

#include <shr/shr_bitop.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_MPLS

/******************************************************************************
 * Private functions
 */


/* XFS MPLS information. */
typedef struct xfs_mpls_info_s {

    /* TNL_PW_DECAP_SEQUENCE_NUMBER LT size. */
    uint32_t pw_term_cnt_sz;

    /* TNL_PW_DECAP_SEQUENCE_NUMBER index bitmap. */
    SHR_BITDCL  *pw_term_bmp;

    /* VP information. */
    xfs_mpls_vp_info_t *vp_info;

    /*! l2_iif mapping for VP with port/trunk as match criteria. */
    uint32_t      *l2_iif_map;

    /*! Special label control. */
    xfs_mpls_special_label_control_t *special_label_ctrl;

    /*! TNL_MPLS_SPECIAL_LABEL size. */
    uint32_t special_lbl_tbl_sz;

    /*! Lookup label count. */
    uint32_t lookup_label_cnt;

    /*! Mutex. */
    sal_mutex_t mpls_tnl_mutex;

} xfs_mpls_info_t;

#define XFS_TNL_EDIT_CTRL_ID_MPLS   6

/* Enum type for Tunnel push label count. */
typedef enum xfs_tnl_push_label_cnt_s {
    
    /* Push 0 label. */
    XFS_TNL_PUSH_LABEL_CNT_0 = 0x0,

    /* Push 1 label. */
    XFS_TNL_PUSH_LABEL_CNT_1 = 0x80,

    /* Push 2 labels. */
    XFS_TNL_PUSH_LABEL_CNT_2 = 0xC0,

    /* Push 3 labels. */
    XFS_TNL_PUSH_LABEL_CNT_3 = 0xE0,

    /* Push 4 labels. */
    XFS_TNL_PUSH_LABEL_CNT_4 = 0xF0,

    /* Push 5 labels. */
    XFS_TNL_PUSH_LABEL_CNT_5 = 0xF8,

    /* Push 6 labels. */
    XFS_TNL_PUSH_LABEL_CNT_6 = 0xFC,

    /* Push 7 labels. */
    XFS_TNL_PUSH_LABEL_CNT_7 = 0xFE,

    /* Push 8 labels. */
    XFS_TNL_PUSH_LABEL_CNT_8 = 0xFF

} xfs_tnl_push_label_cnt_t;

/* Tunnel push label count. */
static xfs_tnl_push_label_cnt_t
    push_bitmap[] = {XFS_TNL_PUSH_LABEL_CNT_0, XFS_TNL_PUSH_LABEL_CNT_1,
                     XFS_TNL_PUSH_LABEL_CNT_2, XFS_TNL_PUSH_LABEL_CNT_3,
                     XFS_TNL_PUSH_LABEL_CNT_4, XFS_TNL_PUSH_LABEL_CNT_5,
                     XFS_TNL_PUSH_LABEL_CNT_6, XFS_TNL_PUSH_LABEL_CNT_7,
                     XFS_TNL_PUSH_LABEL_CNT_8};


/* Software bookkeeping for MPLS information. */
static xfs_mpls_info_t xfs_mpls_info[BCM_MAX_NUM_UNITS];

/* XFS MPLS info. */
#define XFS_MPLS_INFO(_u_) (&xfs_mpls_info[_u_])

/* Take MPLS TNL Lock. */
#define MPLS_TNL_LOCK(_u)     \
    sal_mutex_take(xfs_mpls_info[_u].mpls_tnl_mutex, SAL_MUTEX_FOREVER)

/* Give MPLS TNL Lock. */
#define MPLS_TNL_UNLOCK(_u)   \
    sal_mutex_give(xfs_mpls_info[_u].mpls_tnl_mutex)

/* XFS vp info. */
#define XFS_VP_INFO(_u_) (XFS_MPLS_INFO(_u_)->vp_info)

/* "Pseudo-wire termination counters" usage bitmap operations. */
#define XFS_MPLS_PW_TERM_USED_GET(_u_, _pt_) \
    SHR_BITGET(XFS_MPLS_INFO(_u_)->pw_term_bmp, (_pt_))

#define XFS_MPLS_PW_TERM_USED_SET(_u_, _pt_) \
    SHR_BITSET(XFS_MPLS_INFO((_u_))->pw_term_bmp, (_pt_))

#define XFS_MPLS_PW_TERM_USED_CLR(_u_, _pt_) \
    SHR_BITCLR(XFS_MPLS_INFO((_u_))->pw_term_bmp, (_pt_))

/* TNL_PW_DECAP_SEQUENCE_NUMBER LT size. */
#define XFS_MPLS_PW_TERM_CNT_SZ(_u_)     (XFS_MPLS_INFO((_u_))->pw_term_cnt_sz)

#define MATCH_COUNT_UPDATE(_u_, _vp_, _step_) \
    (((XFS_VP_INFO(_u_))[_vp_]).match_count += _step_)

#define MATCH_COUNT(_u_, _vp_)   (((XFS_VP_INFO(_u_))[_vp_]).match_count)

/* XFS MPLS VP to L2_IF. */
#define XFS_VP_2_L2IF_SET(_u_, _vp_, l2_if) \
    (XFS_MPLS_INFO((_u_))->l2_iif_map[_vp_] = l2_if)

#define XFS_VP_2_L2IF(_u_, _vp_) \
    (XFS_MPLS_INFO((_u_))->l2_iif_map[_vp_])

#define XFS_VPLESS_EGRESS_IF_SET(_u_, _vp_, _if_) \
    (((XFS_VP_INFO(_u_))[_vp_]).vpless_egress_if = _if_)

#define XFS_VPLESS_EGRESS_IF_GET(_u_, _vp_, _if_) \
    (_if_ = ((XFS_VP_INFO(_u_))[_vp_].vpless_egress_if))

#define XFS_SPECIAL_LABEL_CTRL(_u_) \
    (XFS_MPLS_INFO(_u_)->special_label_ctrl)

#define XFS_SPECIAL_LABEL_TBL_SZ(_u_) \
    (XFS_MPLS_INFO(_u_)->special_lbl_tbl_sz)

#define XFS_LOOKUP_LABEL_CNT(_u_) \
    (XFS_MPLS_INFO(_u_)->lookup_label_cnt)

/* Max count of encap labels. */
#define     XFS_ENCAP_LABEL_CNT_MAX         8

/* Min tunnel index. */
#define     XFS_MPLS_TNL_IDX_MIN          1

/* Data structure for EGR_L3_TUNNEL_0/1 entry. */
typedef struct lt_egr_l3_tnl_entry_s {

#define MPLS_CTRL_USE_PLD_TTL       (1 << 0)
#define MPLS_CTRL_ENTROPY_ENABLE    (1 << 1)

    uint32_t tnl_idx;
    uint32_t edit_ctrl_id;
    uint32_t mpls_hdr[XFS_ENCAP_LABEL_CNT_MAX];
    uint32_t exp_remark_ptr;
    uint32_t mpls_ctrl;
    uint32_t mpls_push_bitmap;

} lt_egr_l3_tnl_entry_t;

#define EGR_LABL_CTRL_ENTROPY_LABL     (1 << 0)
#define EGR_LABL_CTRL_CW               (1 << 1)
#define EGR_LABL_CTRL_CW_SEQUENCED     (1 << 2)
#define EGR_LABL_CTRL_USE_PLD_TTL      (1 << 3)

/* Data structure for encap label info entry. */
typedef struct encap_label_info_s {

    bcm_mpls_label_t      vc_label;
    uint8 exp;
    uint8 ttl;
    uint32_t proc_ctrl;

} encap_label_info_t;

/* Data structure for EGR_MPLS_VPN entry. */
typedef struct lt_egr_mpls_vpn_entry_s {

    uint32_t vpn_label_index;

#define VIEW_MPLS                         0
#define VIEW_INT                          1
    uint32_t view;

    uint32_t process_ctrl;

    uint32_t vpn_label_hdr;

} lt_egr_mpls_vpn_entry_t;

/* Data structure for ING_SVP_TABLE entry. */
typedef struct lt_ing_svp_table_entry_s {

    uint32_t vp;

    uint32_t dscp_ptr;

    uint32_t dot1p_ptr;

    uint32_t cml_flags_new;

    uint32_t cml_flags_move;

    uint32_t nw_grp_bmp;

    uint32_t def_itag_dot1p_cfi;

    uint32_t def_otag_dot1p_cfi;

    uint32_t opaque_ctrl_id;

    uint32_t vlan_tag_preserve_ctrl;

    uint32_t use_otag_dot1p_cfi;

    uint32_t use_itag_dot1p_cfi;

    uint32_t use_dscp;

    uint32_t pvlan_check_enable;

    uint32_t mirror_enable;

    uint32_t mirror_index_0;

    uint32_t mirror_index_1;

    uint32_t mirror_index_2;

    uint32_t mirror_index_3;

    uint32_t ipmc_remap_enable;

    /* Bitmap of ING_SVP_TABLE fields to be operated. */
    uint64_t fld_bmp;
#define SVP_FLD_DSCP_PTR                   (1 << 1)
#define SVP_FLD_DOT1P_PTR                  (1 << 2)
#define SVP_FLD_CML_FLAGS_NEW              (1 << 3)
#define SVP_FLD_CML_FLAGS_MOVE             (1 << 4)
#define SVP_FLD_EXPECTED_VFI               (1 << 5)
#define SVP_FLD_NW_GRP_BMP                 (1 << 6)
#define SVP_FLD_DEF_ITAG_DOT1P_CFI         (1 << 7)
#define SVP_FLD_DEF_OTAG_DOT1P_CFI         (1 << 8)
#define SVP_FLD_OPAQUE_CTRL_ID             (1 << 9)
#define SVP_FLD_VLAN_TAG_PRESERVE_CTRL     (1 << 10)
#define SVP_FLD_USE_OTAG_DOT1P_CFI         (1 << 11)
#define SVP_FLD_USE_ITAG_DOT1P_CFI         (1 << 12)
#define SVP_FLD_USE_DSCP                   (1 << 13)
#define SVP_FLD_PVLAN_CHECK_ENABLE         (1 << 14)
#define SVP_FLD_FLEX_CTR_ACTION            (1 << 15)
#define SVP_FLD_MIRROR_IDX_0               (1 << 16)
#define SVP_FLD_MIRROR_IDX_1               (1 << 17)
#define SVP_FLD_MIRROR_IDX_2               (1 << 18)
#define SVP_FLD_MIRROR_IDX_3               (1 << 29)

} lt_ing_svp_table_entry_t;

/* Data structure for ING_DVP_TABLE entry. */
typedef struct lt_ing_dvp_table_entry_s {

    uint32_t dvp;

    uint32_t no_cut_thru;

    uint32_t network_group;

    uint32_t str_prfl_idx;

    uint32_t destination;

    uint32_t dst_bmp_valid;

} lt_ing_dvp_table_entry_t;

#define TNL_MPLS_CTRL_PKT_FLOW_NONE          0
#define TNL_MPLS_CTRL_PKT_FLOW_L3TERM      (1 << 0)
#define TNL_MPLS_CTRL_PKT_FLOW_L2TERM      (1 << 1)
#define TNL_MPLS_CTRL_PKT_FLOW_TRANSIT     (1 << 2)
#define TNL_MPLS_CTRL_PKT_FLOW_PHP         (1 << 3)
#define TNL_MPLS_CTRL_PKT_MSK_ALL          (0xf)
#define TNL_MPLS_CTRL_PKT_MSK_L3_ONLY       \
             (TNL_MPLS_CTRL_PKT_MSK_ALL & ~TNL_MPLS_CTRL_PKT_FLOW_PHP)
#define TNL_MPLS_CTRL_PKT_MSK_TRANSIT_ONLY  \
             (TNL_MPLS_CTRL_PKT_MSK_ALL & ~TNL_MPLS_CTRL_PKT_FLOW_PHP)
#define TNL_MPLS_CTRL_PKT_MSK_PHP_ONLY      \
        (TNL_MPLS_CTRL_PKT_MSK_ALL & ~TNL_MPLS_CTRL_PKT_FLOW_L3TERM & \
         ~TNL_MPLS_CTRL_PKT_FLOW_TRANSIT)

/* Data structure for ING_VFI_TABLE entry. */
typedef struct lt_tnl_mpls_control_pkt_entry_s {

    uint32_t tnl_mpls_control_pkt_id_0;

    uint32_t tnl_mpls_control_pkt_id_0_mask;

    uint32_t tnl_mpls_control_pkt_id_1;

    uint32_t tnl_mpls_control_pkt_id_1_mask;

    uint32_t tnl_mpls_control_pkt_id_2;

    uint32_t tnl_mpls_control_pkt_id_2_mask;

    uint32_t tnl_mpls_control_pkt_id_3;

    uint32_t tnl_mpls_control_pkt_id_3_mask;

    uint32_t tnl_mpls_control_pkt_id_4;

    uint32_t tnl_mpls_control_pkt_id_4_mask;

    uint32_t tnl_mpls_control_pkt_id_5;

    uint32_t tnl_mpls_control_pkt_id_5_mask;

    uint32_t entry_priority;

    uint32_t seq_num_check;

    uint32_t cw_present;

    uint32_t control_packet;

    uint32_t control_packet_type;

    uint32_t copy_to_cpu;

    uint32_t drop;

} lt_tnl_mpls_control_pkt_entry_t;

/* Data structure for EGR_DVP entry. */
typedef struct lt_egr_dvp_entry_s {

    uint32_t dvp;

    uint32_t process_ctrl;

    uint32_t group_id;

    uint32_t tunnel_idx_0;

    uint32_t class_id;

    uint32_t vc_label_idx;

    uint32_t str_prfl_idx;

    uint32_t l2_mtu_value;

    uint32_t seq_num_prof_idx;

    uint32_t seq_num_cnt_idx;

    uint32_t network_group_id;

} lt_egr_dvp_entry_t;

/* Data structure for ING_VFI_TABLE entry. */
typedef struct lt_ing_vfi_table_entry_s {

    uint32_t vfi;

    uint32_t dest;

} lt_ing_vfi_table_entry_t;

/* Data structure for TNL_MPLS_SPECIAL_LABEL entry. */
typedef struct lt_tnl_mpls_special_label_entry_s {
    /* TNL_MPLS_SPECIAL_LABEL_ID. */
    uint32_t index;

    uint32_t mpls_header;

    uint32_t mpls_header_mask;

    uint32_t ignore_next_act;

    uint32_t skip_next_hash;

    uint32_t skip_hash;

    uint32_t skip_next_lkup;

    uint32_t skip_lkup;

    uint32_t rsvd_lbl;

} lt_tnl_mpls_special_label_entry_t;

/* Data structure for TNL_PW_DECAP_SEQUENCE_NUMBER entry. */
typedef struct lt_tnl_pw_decap_seq_num_entry_s {

    /* LT field TNL_PW_DECAP_SEQUENCE_NUMBER_ID. */
    uint32_t index;

    /* Pipe number. */
    uint32_t pipe;

    /* LT field SEQUENCE_NUMBER. */
    uint32_t seq_num;

} lt_tnl_pw_decap_seq_num_entry_t;


/* Data structure for MPLS_ENTRY_1/2/3 entry. */
typedef struct lt_mpls_entry_s {

    uint32_t label;

    uint32_t label_conext_id;

    uint32_t dest_type;

    uint32_t dest;

    uint32_t svp;

    uint32_t p2p_flow;

    uint32_t label_action;

    uint32_t l3_iif_vfi_nh2;

    uint32_t vfi;

    uint32_t class_id;

    uint32_t cw_check_ctrl;

    uint32_t drop_en;

    uint32_t pw_term_num;

    uint32_t pw_term_num_valid;

    uint32_t exp_mapping_ptr;

    uint32_t exp2ecn_mapping_ptr;

    uint32_t el_present;

    uint32_t pw_cc_type;

    uint32_t exp_qos_ctrl_id;

    uint32_t ttl_mode;

    /* Bitmap of MPLS_ENTRY_x fields to be operated. */
    uint64_t fld_bmp;
#define ME_FLD_LABEL                         (1 << 0)
#define ME_FLD_CONTEXT_ID                    (1 << 1)
#define ME_FLD_DEST                          (1 << 2)
#define ME_FLD_LABEL_ACTION                  (1 << 3)
#define ME_FLD_L3_IIF_VFI_NH2                (1 << 4)
#define ME_FLD_CLASS_ID                      (1 << 5)
#define ME_FLD_DROP_EN                       (1 << 6)
#define ME_FLD_PW_TERM_NUM_VALID             (1 << 7)
#define ME_FLD_SVP                           (1 << 8)
#define ME_FLD_P2P_FLOW                      (1 << 9)
#define ME_FLD_CW_CHECK_CTRL                 (1 << 10)
#define ME_FLD_EXP_MAPPING_PTR               (1 << 11)
#define ME_FLD_EXP_TO_ECN_MAPPING_PTR        (1 << 12)
#define ME_FLD_EL_PRESENT                    (1 << 13)
#define ME_FLD_PW_CC_TYPE                    (1 << 14)
#define ME_FLD_TTL_MODE                      (1 << 15)

#define ME_TNL_FLD_BMP     (ME_FLD_LABEL | ME_FLD_CONTEXT_ID | ME_FLD_DEST |  \
                            ME_FLD_LABEL_ACTION | ME_FLD_L3_IIF_VFI_NH2 |     \
                            ME_FLD_CLASS_ID |ME_FLD_DROP_EN |                 \
                            ME_FLD_PW_TERM_NUM_VALID | ME_FLD_CW_CHECK_CTRL | \
                            ME_FLD_EXP_MAPPING_PTR |  ME_FLD_TTL_MODE |       \
                            ME_FLD_EXP_TO_ECN_MAPPING_PTR)

#define ME_MPLS_PORT_FLD_BMP (ME_FLD_LABEL | ME_FLD_CONTEXT_ID | ME_FLD_SVP | \
                              ME_FLD_LABEL_ACTION | ME_FLD_CLASS_ID |         \
                              ME_FLD_PW_TERM_NUM_VALID | ME_FLD_DROP_EN |     \
                              ME_FLD_CW_CHECK_CTRL | ME_FLD_EXP_MAPPING_PTR | \
                              ME_FLD_EXP_TO_ECN_MAPPING_PTR |                 \
                              ME_FLD_EL_PRESENT | ME_FLD_PW_CC_TYPE)

} lt_mpls_entry_t;

/* Construct a 64-bit variable from two 32-bit variables. */
#define  DATA_64_FROM_32(_d64_, _hi_, _lo_)     \
    _d64_  = _hi_;                              \
    _d64_  = _d64_ << 32;                       \
    _d64_ |= _lo_

/* Convert a 64-bit variable to two 32-bit variables. */
#define  DATA_64_TO_32(_d64_, _hi_, _lo_)     \
    _lo_  = (uint32_t)_d64_;                  \
    _hi_  = (uint32_t)(_d64_ >> 32)

/* Label offset in MPLS header. */
#define MPLS_LABEL_OFFSET    12

/* Traffic class offset in MPLS header. */
#define MPLS_TC_OFFSET       9

/* BOS offset in MPLS header. */
#define MPLS_BOS_OFFSET      8

/* Build MPLS header. */
#define BUILD_MPLS_HDR(_hdr_, _label_, _tc_, _bos_, _ttl_)   \
    _hdr_ = (_label_ << MPLS_LABEL_OFFSET)                 | \
            (_tc_    << MPLS_TC_OFFSET)                    | \
            (_bos_   << MPLS_BOS_OFFSET)                   | \
            _ttl_

/* Traffic label mask. */
#define MPLS_LABEL_MASK       0xFFFFF

/* MAX MPLS label. */
#define MPLS_LABEL_MAX        0xFFFFF

/* Traffic class mask. */
#define MPLS_TC_MASK          0x7

/* BOS mask. */
#define MPLS_BOS_MASK         0x1

/* TTL mask. */
#define MPLS_TTL_MASK        0xFF

/* Parse MPLS header. */
#define PARSE_MPLS_HDR_NO_BOS(_hdr_, _label_, _tc_, _ttl_)         \
        _label_ = (_hdr_ >> MPLS_LABEL_OFFSET) & MPLS_LABEL_MASK;  \
        _tc_    = (_hdr_ >> MPLS_TC_OFFSET) & MPLS_TC_MASK;        \
        _ttl_   = _hdr_ & MPLS_TTL_MASK

#define PARSE_MPLS_HDR(_hdr_, _label_, _tc_, _bos_, _ttl_)         \
        _label_ = (_hdr_ >> MPLS_LABEL_OFFSET) & MPLS_LABEL_MASK;  \
        _tc_    = (_hdr_ >> MPLS_TC_OFFSET) & MPLS_TC_MASK;        \
        _bos_   = (_hdr_ >> MPLS_BOS_OFFSET) & MPLS_BOS_MASK;      \
        _ttl_   = _hdr_ & MPLS_TTL_MASK

/* Depth of TNL_MPLS_LABEL_DECAP_POLICY.POLICY_CMD_SELECT. */
#define POLICY_CMD_SELECT_FLD_DEPTH   12

/* Depth of TNL_MPLS_LABEL_DECAP_POLICY.POLICY_OBJ_SELECT. */
#define POLICY_OBJ_SELECT_FLD_DEPTH   6

/*
 * Encoding for ecmp_and_prot_swt_sfc_profile_index.
 * [1:0]: BITP/BOTP Profile Table index for ECMP and Protection Switching SF
 * [2:2]: If set, nhop_2_or_ecmp_group_index_1 is ECMP Group 2 Table index
 *                                             else Next hop 2 table index
 */
/* ECMP group 2 and no protection. */
#define ECMP_AND_NO_PROT         (1 << 2 | 0 << 0)

/* Next hop 2 and protect UnderLay NH. */
#define NH_AND_PROT_UL           (0 << 2 | 1 << 0)

#define EGR_DVP_PROCESS_CTRL_2_MTU_ENABLE      (1 << 0)

/*! Field definition of split_horizon_ctrl in egr_dvp. */
#define VP_SHC_DOMAIN_ID_SFT 0x0
#define VP_SHC_DOMAIN_ID_MSK 0x3
#define VP_SHC_EN_SFT 0x2
#define VP_SHC_EN_MSK 0x1

/*! Field definition of L2MC_L3MC_L2_OIF_SYS_DST_VALID in ING_DVP_TABLE. */
#define DEST_TYPE_VALID_L2_OIF  (1 << 2)

typedef struct mpls_ing_vxlate_user_data_s {
    /* Matched vpn index. */
    int match_vpn_idx;

    /* Source VP count. */
    int svp_cnt;

    /* SVP bitmap. */
    int *svp_bmp;
} mpls_ing_vxlate_user_data_t;

typedef struct mpls_port_match_ivxlate_user_data_s {
    /* Match vp. */
    int match_vp;

    /* Match array size. */
    int size;

    /* Match array. */
    bcmi_ltsw_mpls_port_match_t *array;

    /* Match count. */
    int count;
} mpls_port_match_ivxlate_user_data_t;

typedef struct exp_qos_sel_policy_s {
    /* Selection ID 1. */
    int selection_id_1;

    /* Selection ID 2. */
    int selection_id_2;

    /* Selection ID 3. */
    int selection_id_3;

    /* EXP qos source. */
    const char *src;

} exp_qos_sel_policy_t;

#define EXP_QOS_CTRL_ID_NONE     0
#define EXP_QOS_CTRL_ID_SEL      0x1
#define EXP_REMARK_CTRL_ID_SEL   0x1

/******************************************************************************
 * Private functions
 */
/*!
 * \brief Convert entry to handle for the LT MPLS_ENTTRY_x (x is 1,2,3).
 *
 * \param [in]  unit       Unit number.
 * \param [in]  entry      Entry info.
 * \param [out] ent_hdl    Entry handle.
 *
 * \retval SHR_E_NONE      No errors.
 * \retval !SHR_E_NONE     Failure.
 */
static int
lt_mpls_entry_x_entry_to_hdl(
    int unit,
    lt_mpls_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;
    const char *str_value;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_1, &lt_info));
    flds = lt_info->flds;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_ENTRY_VALID].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, 1));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_LABEL].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->label));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_LABEL_CONTEXT_ID].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->label_conext_id));

    if (entry->fld_bmp & ME_FLD_DEST) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_DESTINATION].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->dest));

        fid = BCMINT_LTSW_MPLS_FLD_ME_1_DESTINATION_TYPE;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].scalar_to_symbol(unit, entry->dest_type, &str_value));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(ent_hdl, fld_name, str_value));
    }

    if (entry->fld_bmp & ME_FLD_SVP) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_SVP].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->svp));
    }

    if (entry->fld_bmp & ME_FLD_P2P_FLOW) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_POINT2POINT_FLOW].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->p2p_flow));
    }

    if (entry->fld_bmp & ME_FLD_LABEL_ACTION) {
        fid = BCMINT_LTSW_MPLS_FLD_ME_1_LABEL_ACTION;
        fld_name = flds[fid].name;

        SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].scalar_to_symbol(unit, entry->label_action, &str_value));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add( ent_hdl, fld_name, str_value));
    }

    if (entry->fld_bmp & ME_FLD_L3_IIF_VFI_NH2) {
        fid = BCMINT_LTSW_MPLS_FLD_ME_1_VFI_L3_IIF_NHOP_2_ECMP_GROUP_INDEX_1;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->l3_iif_vfi_nh2));
    }

    if (entry->fld_bmp & ME_FLD_CLASS_ID) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_CLASS_ID].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->class_id));
    }

    if (entry->fld_bmp & ME_FLD_DROP_EN) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_DROP_DATA_ENABLE].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->drop_en));
    }

    if (entry->fld_bmp & ME_FLD_PW_TERM_NUM_VALID) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_PW_TERM_NUM_VALID].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name,
                                   entry->pw_term_num_valid));

        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_PW_TERM_NUM].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->pw_term_num));
    }

    if (entry->fld_bmp & ME_FLD_CW_CHECK_CTRL) {
        fid = BCMINT_LTSW_MPLS_FLD_ME_1_CW_CHECK_CTRL;
        fld_name = flds[fid].name;

        SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].scalar_to_symbol(unit,
                                        entry->cw_check_ctrl, &str_value));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add( ent_hdl, fld_name, str_value));
    }

    if (entry->fld_bmp & ME_FLD_PW_CC_TYPE) {
        fid = BCMINT_LTSW_MPLS_FLD_ME_1_PW_CC_TYPE;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->pw_cc_type));
    }

    if (entry->fld_bmp & ME_FLD_EXP_MAPPING_PTR) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_EXP_MAPPING_PTR].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->exp_mapping_ptr));
    }

    if (entry->fld_bmp & ME_FLD_EXP_TO_ECN_MAPPING_PTR) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_EXP_TO_ECN_MAPPING_PTR].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name,
                                   entry->exp2ecn_mapping_ptr));
    }

    if (entry->fld_bmp & ME_FLD_EL_PRESENT) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_ENTROPY_LABEL_PRESENT].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->el_present));
    }

    if (entry->fld_bmp & ME_FLD_TTL_MODE) {
        fid = BCMINT_LTSW_MPLS_FLD_ME_1_TTL_MODE;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].scalar_to_symbol(unit, entry->ttl_mode, &str_value));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add( ent_hdl, fld_name, str_value));
    }

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_EXP_QOS_CTRL_ID].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->exp_qos_ctrl_id));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_EXP_REMARK_CTRL_ID].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, EXP_REMARK_CTRL_ID_SEL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct entry of the LT MPLS_ENTTRY_x (x is 1,2,3) from handle.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mpls_entry_x_entry_from_hdl(
    int unit,
    lt_mpls_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    uint64_t value = 0;
    const char *str_value;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_1, &lt_info));
    flds = lt_info->flds;

    if (entry->fld_bmp & ME_FLD_LABEL) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_LABEL].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->label = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_CONTEXT_ID) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_LABEL_CONTEXT_ID].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->label_conext_id = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_DEST) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_DESTINATION].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->dest = (uint32_t)value;

        fid = BCMINT_LTSW_MPLS_FLD_ME_1_DESTINATION_TYPE;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(ent_hdl, fld_name, &str_value));

        SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].symbol_to_scalar(unit, str_value, &value));

        entry->dest_type = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_LABEL_ACTION) {
        fid = BCMINT_LTSW_MPLS_FLD_ME_1_LABEL_ACTION;
        fld_name = flds[fid].name;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(ent_hdl, fld_name, &str_value));

        SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].symbol_to_scalar(unit, str_value, &value));
        entry->label_action = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_L3_IIF_VFI_NH2) {
        fid = BCMINT_LTSW_MPLS_FLD_ME_1_VFI_L3_IIF_NHOP_2_ECMP_GROUP_INDEX_1;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->l3_iif_vfi_nh2 = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_CLASS_ID) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_CLASS_ID].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->class_id = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_DROP_EN) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_DROP_DATA_ENABLE].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->drop_en = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_SVP) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_SVP].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->svp = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_PW_TERM_NUM_VALID) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_PW_TERM_NUM_VALID].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->pw_term_num_valid = (uint32_t)value;

        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_PW_TERM_NUM].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->pw_term_num = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_CW_CHECK_CTRL) {
        fid = BCMINT_LTSW_MPLS_FLD_ME_1_CW_CHECK_CTRL;
        fld_name = flds[fid].name;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(ent_hdl, fld_name, &str_value));

        SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].symbol_to_scalar(unit, str_value, &value));

        entry->cw_check_ctrl = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_PW_CC_TYPE) {
        fid = BCMINT_LTSW_MPLS_FLD_ME_1_PW_CC_TYPE;
        fld_name = flds[fid].name;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));

        entry->pw_cc_type = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_TTL_MODE) {
        fid = BCMINT_LTSW_MPLS_FLD_ME_1_TTL_MODE;
        fld_name = flds[fid].name;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(ent_hdl, fld_name, &str_value));

        SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].symbol_to_scalar(unit, str_value, &value));

        entry->ttl_mode = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_EXP_MAPPING_PTR) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_EXP_MAPPING_PTR].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->exp_mapping_ptr = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_EXP_TO_ECN_MAPPING_PTR) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_EXP_TO_ECN_MAPPING_PTR].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->exp2ecn_mapping_ptr = (uint32_t)value;
    }

    if (entry->fld_bmp & ME_FLD_EL_PRESENT) {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_ENTROPY_LABEL_PRESENT].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->el_present = (uint32_t)value;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT MPLS_ENTTRY_x (x is 1,2,3).
 *
 * \param [in] unit       Unit number.
 * \param [in] opcode     Operation code.
 * \param [in] ent_hdl    Entry handle.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mpls_entry_x_op(
    int unit,
    bcmlt_opcode_t opcode,
    bcmlt_entry_handle_t ent_hdl,
    lt_mpls_entry_t *entry)
{
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_1, &lt_info));
    flds = lt_info->flds;
    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_LABEL].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->label));

        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_LABEL_CONTEXT_ID].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->label_conext_id));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_x_entry_from_hdl(unit, entry, ent_hdl));
        break;
    case BCMLT_OPCODE_INSERT:
    case BCMLT_OPCODE_UPDATE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_x_entry_to_hdl(unit, entry, ent_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_LABEL].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->label));

        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ME_1_LABEL_CONTEXT_ID].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->label_conext_id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
}

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT MPLS_ENTTRY_x (x is 1,2,3).
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mpls_entry_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_mpls_entry_t *entry)
{
    int dunit, i;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    bcmint_mpls_lt_id_t mpls_entry_id[] = {
                                   BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_1,
                                   BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_2,
                                   BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_3};
    const bcmint_mpls_lt_t *lt_info;


    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    for (i = 0; i < XFS_LOOKUP_LABEL_CNT(unit); i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_mpls_lt_get(unit, mpls_entry_id[i], &lt_info));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, lt_info->name, &ent_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_x_op(unit, opcode, ent_hdl, entry));

        (void)bcmlt_entry_free(ent_hdl);
        ent_hdl = BCMLT_INVALID_HDL;
        if (opcode == BCMLT_OPCODE_LOOKUP) {
            /*
             * Read data from MPLS_ENTRY_1 as the three LTs
             * have the identical configuration.
             */
            break;
        }
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert entry to handle for the LT EGR_L3_TUNNEL_0/1.
 *
 * \param [in]  unit         Unit number.
 * \param [in]  entry        Entry info.
 * \param [out] ent_hdl_0    Entry handle for EGR_L3_TUNNEL_0.
 * \param [out] ent_hdl_1    Entry handle for EGR_L3_TUNNEL_1.
 *
 * \retval SHR_E_NONE        No errors.
 * \retval !SHR_E_NONE       Failure.
 */
static int
lt_egr_l3_tnl_entry_to_hdl(
    int unit,
    lt_egr_l3_tnl_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl_0,
    bcmlt_entry_handle_t ent_hdl_1)
{
    uint64_t val_array[2];
    uint32_t *mpls_hdr = entry->mpls_hdr;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;
    bcmi_ltsw_sbr_profile_tbl_hdl_t pth = BCMI_LTSW_SBR_PTH_COUNT;
    bcmi_ltsw_sbr_profile_ent_type_t ent_type = BCMI_LTSW_SBR_PET_COUNT;
    int profile_idx;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit,
                            BCMINT_LTSW_MPLS_LT_EGR_L3_TUNNEL_0, &lt_info));
    flds = lt_info->flds;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_EGR_L3_TUNNEL_IDX_0].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl_0, fld_name, entry->tnl_idx));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_EDIT_CTRL_ID].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl_0, fld_name, entry->edit_ctrl_id));

    DATA_64_FROM_32(val_array[0], mpls_hdr[1], mpls_hdr[0]);
    DATA_64_FROM_32(val_array[1], mpls_hdr[3], mpls_hdr[2]);
    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_IPV6_SRC_ADDR].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(ent_hdl_0, fld_name, 0, val_array, 2));

    fid = BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_TOS_OR_EXP_REMARK_BASE_PTR;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl_0, fld_name, entry->exp_remark_ptr));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_TTL_OR_MPLS_CTRL].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl_0, fld_name, entry->mpls_ctrl));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_MPLS_PUSH_BITMAP].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl_0, fld_name, entry->mpls_push_bitmap));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit,
                            BCMINT_LTSW_MPLS_LT_EGR_L3_TUNNEL_1, &lt_info));

    flds = lt_info->flds;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_1_EGR_L3_TUNNEL_IDX_0].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl_1, fld_name, entry->tnl_idx));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_1_IPV6_DST_ADDR_HI_0].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl_1, fld_name, mpls_hdr[6]));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_1_IPV6_DST_ADDR_HI_1].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl_1, fld_name, mpls_hdr[7]));

    DATA_64_FROM_32(val_array[0], mpls_hdr[5], mpls_hdr[4]);
    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_1_IPV6_DST_ADDR_LO].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl_1, fld_name, val_array[0]));

    pth = BCMI_LTSW_SBR_PTH_EGR_L3_TNL;
    ent_type = BCMI_LTSW_SBR_PET_NO_SEQ_NUM_NO_TNL_WORD_2;
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                             &profile_idx));
    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_1_STRENGTH_PRFL_IDX].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl_1, fld_name, profile_idx));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct entry of the LT EGR_L3_TUNNEL_0/1 from handle.
 *
 * \param [in] unit         Unit number.
 * \param [in] entry        Entry info.
 * \param [in] ent_hdl_0    Entry handle for EGR_L3_TUNNEL_0.
 * \param [in] ent_hdl_1    Entry handle for EGR_L3_TUNNEL_1.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
static int
lt_egr_l3_tnl_entry_from_hdl(
    int unit,
    lt_egr_l3_tnl_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl_0,
    bcmlt_entry_handle_t ent_hdl_1)
{
    uint64_t value = 0;
    uint64_t val_array[2];
    uint32_t r_elem_cnt;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit,
                            BCMINT_LTSW_MPLS_LT_EGR_L3_TUNNEL_0, &lt_info));
    flds = lt_info->flds;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_EGR_L3_TUNNEL_IDX_0].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl_0, fld_name, &value));
    entry->tnl_idx = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_EDIT_CTRL_ID].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl_0, fld_name, &value));
    entry->edit_ctrl_id = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_IPV6_SRC_ADDR].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_get(ent_hdl_0, fld_name, 0,
                                     val_array, 2, &r_elem_cnt));
    entry->mpls_hdr[0] = (uint32_t)val_array[0];
    entry->mpls_hdr[1] = (uint32_t)(val_array[0] >> 32);
    entry->mpls_hdr[2] = (uint32_t)val_array[1];
    entry->mpls_hdr[3] = (uint32_t)(val_array[1] >> 32);

    fid = BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_TOS_OR_EXP_REMARK_BASE_PTR;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl_0, fld_name, &value));
    entry->exp_remark_ptr = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_MPLS_PUSH_BITMAP].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl_0, fld_name, &value));
    entry->mpls_push_bitmap = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_TTL_OR_MPLS_CTRL].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl_0, fld_name, &value));
    entry->mpls_ctrl = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit,
                            BCMINT_LTSW_MPLS_LT_EGR_L3_TUNNEL_1, &lt_info));
    flds = lt_info->flds;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_1_IPV6_DST_ADDR_HI_1].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl_1, fld_name, &value));
    entry->mpls_hdr[7] = (uint32_t)(value);

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_1_IPV6_DST_ADDR_HI_0].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl_1, fld_name, &value));
    entry->mpls_hdr[6] = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_1_IPV6_DST_ADDR_LO].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl_1, fld_name, &value));
    entry->mpls_hdr[4] = (uint32_t)value;
    entry->mpls_hdr[5] = (uint32_t)(value >> 32);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT EGR_L3_TUNNLE_0/1.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_l3_tnl_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_egr_l3_tnl_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl_0 = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t ent_hdl_1 = BCMLT_INVALID_HDL;
    const bcmint_mpls_lt_t *lt_info;
    bcmint_mpls_lt_id_t egr_l3_tnl_id[] = {
        BCMINT_LTSW_MPLS_LT_EGR_L3_TUNNEL_0,
        BCMINT_LTSW_MPLS_LT_EGR_L3_TUNNEL_1
        };
    const bcmint_mpls_lt_t *egr_l3_tnl_0_info, *egr_l3_tnl_1_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_1, &lt_info));


    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, egr_l3_tnl_id[0], &egr_l3_tnl_0_info));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, egr_l3_tnl_0_info->name, &ent_hdl_0));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, egr_l3_tnl_id[1], &egr_l3_tnl_1_info));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, egr_l3_tnl_1_info->name, &ent_hdl_1));

    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        flds = egr_l3_tnl_0_info->flds;
        fid = BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_EGR_L3_TUNNEL_IDX_0;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl_0, fld_name, entry->tnl_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl_0, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        flds = egr_l3_tnl_1_info->flds;
        fid = BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_1_EGR_L3_TUNNEL_IDX_0;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl_1, fld_name, entry->tnl_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl_1, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_egr_l3_tnl_entry_from_hdl(unit, entry, ent_hdl_0, ent_hdl_1));

        break;
    case BCMLT_OPCODE_INSERT:
    case BCMLT_OPCODE_UPDATE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_egr_l3_tnl_entry_to_hdl(unit, entry, ent_hdl_0, ent_hdl_1));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl_0, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl_1, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        flds = egr_l3_tnl_0_info->flds;
        fid = BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_EGR_L3_TUNNEL_IDX_0;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl_0, fld_name, entry->tnl_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl_0, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        flds = egr_l3_tnl_0_info->flds;
        fid = BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_1_EGR_L3_TUNNEL_IDX_0;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl_1, fld_name, entry->tnl_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl_1, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
}
exit:
    if (BCMLT_INVALID_HDL != ent_hdl_0) {
        (void)bcmlt_entry_free(ent_hdl_0);
    }

    if (BCMLT_INVALID_HDL != ent_hdl_1) {
        (void)bcmlt_entry_free(ent_hdl_1);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert entry to handle for the LT EGR_MPLS_VPN.
 *
 * \param [in]  unit       Unit number.
 * \param [in]  entry      Entry info.
 * \param [out] ent_hdl    Entry handle for EGR_MPLS_VPN.
 *
 * \retval SHR_E_NONE      No errors.
 * \retval !SHR_E_NONE     Failure.
 */
static int
lt_egr_mpls_vpn_entry_to_hdl(
    int unit,
    lt_egr_mpls_vpn_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;
    const char *str_value;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EGR_MPLS_VPN, &lt_info));

    flds = lt_info->flds;

    fid = BCMINT_LTSW_MPLS_FLD_EGR_MPLS_VPN_MPLS_VPN_OR_INT_INDEX;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->vpn_label_index));

    fid = BCMINT_LTSW_MPLS_FLD_EGR_MPLS_VPN_VIEW_T;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (flds[fid].scalar_to_symbol(unit, entry->view, &str_value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(ent_hdl, fld_name, str_value));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_MPLS_VPN_VPN_LABEL].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->vpn_label_hdr));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_MPLS_VPN_PROCESS_CTRL].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->process_ctrl));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct entry of the LT EGR_MPLS_VPN from handle.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for EGR_MPLS_VPN.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_mpls_vpn_entry_from_hdl(
    int unit, lt_egr_mpls_vpn_entry_t *entry, bcmlt_entry_handle_t ent_hdl)
{
    uint64_t value = 0;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;
    const char *str_value;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EGR_MPLS_VPN, &lt_info));

    flds = lt_info->flds;

    fid = BCMINT_LTSW_MPLS_FLD_EGR_MPLS_VPN_MPLS_VPN_OR_INT_INDEX;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->vpn_label_index = (uint32_t)value;

    fid = BCMINT_LTSW_MPLS_FLD_EGR_MPLS_VPN_VIEW_T;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(ent_hdl, fld_name, &str_value));
    SHR_IF_ERR_VERBOSE_EXIT
        (flds[fid].symbol_to_scalar(unit, str_value, &value));
    entry->view = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_MPLS_VPN_PROCESS_CTRL].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->process_ctrl = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_MPLS_VPN_VPN_LABEL].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->vpn_label_hdr= (uint32_t)value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT EGR_MPLS_VPN.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_mpls_vpn_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_egr_mpls_vpn_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EGR_MPLS_VPN, &lt_info));


    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &ent_hdl));

    flds = lt_info->flds;

    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        fid = BCMINT_LTSW_MPLS_FLD_EGR_MPLS_VPN_MPLS_VPN_OR_INT_INDEX;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->vpn_label_index));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_egr_mpls_vpn_entry_from_hdl(unit, entry, ent_hdl));

        break;
    case BCMLT_OPCODE_INSERT:
    case BCMLT_OPCODE_UPDATE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_egr_mpls_vpn_entry_to_hdl(unit, entry, ent_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        fid = BCMINT_LTSW_MPLS_FLD_EGR_MPLS_VPN_MPLS_VPN_OR_INT_INDEX;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->vpn_label_index));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
}
exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}


/*!
 * \brief Construct mpls port info from
 * entry of the LT EGR_MPLS_VPN.
 *
 * \param [in] unit         Unit number.
 * \param [in] mpls_port    mpls port info.
 * \param [in] entry        entry info.
 *
 * \return Nothing.
 */
static void
mpls_port_from_egr_mpls_vpn_entry(
    int unit, bcm_mpls_port_t *mpls_port, lt_egr_mpls_vpn_entry_t *entry)
{
    uint32_t vpn_label_hdr;
    uint32_t process_ctrl;
    uint32_t label_flags = 0;

    vpn_label_hdr = entry->vpn_label_hdr;
    PARSE_MPLS_HDR_NO_BOS(vpn_label_hdr,
                          mpls_port->egress_label.label,
                          mpls_port->egress_label.exp,
                          mpls_port->egress_label.ttl);

    process_ctrl = entry->process_ctrl;

    if (process_ctrl & EGR_LABL_CTRL_ENTROPY_LABL) {
        label_flags |= BCM_MPLS_EGRESS_LABEL_ENTROPY_ENABLE;
    }

    if (process_ctrl & EGR_LABL_CTRL_USE_PLD_TTL) {
        label_flags |= BCM_MPLS_EGRESS_LABEL_TTL_COPY;
    } else {
        label_flags |= BCM_MPLS_EGRESS_LABEL_TTL_SET;
    }
    mpls_port->egress_label.flags |= label_flags;

    if (process_ctrl & EGR_LABL_CTRL_CW_SEQUENCED) {
        mpls_port->flags |= BCM_MPLS_PORT_SEQUENCED;
    } else if (process_ctrl & EGR_LABL_CTRL_CW) {
        mpls_port->flags |= BCM_MPLS_PORT_CONTROL_WORD;
    }

    return;
}

/*!
 * \brief Convert entry to handle for the LT ING_SVP_TABLE.
 *
 * \param [in]  unit       Unit number.
 * \param [in]  entry      Entry info.
 * \param [out] ent_hdl    Entry handle for ING_SVP_TABLE.
 *
 * \retval SHR_E_NONE      No errors.
 * \retval !SHR_E_NONE     Failure.
 */
static int
lt_ing_svp_table_entry_to_hdl(
    int unit,
    lt_ing_svp_table_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_ING_SVP_TABLE, &lt_info));

    flds = lt_info->flds;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_SVP].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->vp));

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_NETWORK_GROUP_BITMAP;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->nw_grp_bmp));

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_VLAN_TAG_PRESERVE_CTRL;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name,
                               entry->vlan_tag_preserve_ctrl));

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_CML_FLAGS_NEW;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, BCMI_XFS_CML_FLAGS_LEARN));

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_CML_FLAGS_MOVE;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, BCMI_XFS_CML_FLAGS_LEARN));

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_IPMC_REMAP_ENABLE;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->ipmc_remap_enable));

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_DOT1P_PTR;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->dot1p_ptr));

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_DSCP_PTR;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->dscp_ptr));

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_USE_DSCP_FOR_PHB;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->use_dscp));

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_USE_OTAG_DOT1P_CFI_FOR_PHB;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->use_otag_dot1p_cfi));

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_USE_ITAG_DOT1P_CFI_FOR_PHB;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->use_itag_dot1p_cfi));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct entry of the LT EGR_MPLS_VPN from handle.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for EGR_MPLS_VPN.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_ing_svp_table_entry_from_hdl(
    int unit, lt_ing_svp_table_entry_t *entry, bcmlt_entry_handle_t ent_hdl)
{
    uint64_t value = 0;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_ING_SVP_TABLE, &lt_info));

    flds = lt_info->flds;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_SVP].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->vp = (uint32_t)value;

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_NETWORK_GROUP_BITMAP;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->nw_grp_bmp = (uint32_t)value;

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_IPMC_REMAP_ENABLE;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->ipmc_remap_enable= (uint32_t)value;

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_DSCP_PTR;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->dscp_ptr = (uint32_t)value;

    fid = BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_DOT1P_PTR;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->dot1p_ptr= (uint32_t)value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT ING_SVP_TABLE.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_ing_svp_table_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_ing_svp_table_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_ING_SVP_TABLE, &lt_info));

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &ent_hdl));

    flds = lt_info->flds;

    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_SVP].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->vp));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_ing_svp_table_entry_from_hdl(unit, entry, ent_hdl));

        break;
    case BCMLT_OPCODE_INSERT:
    case BCMLT_OPCODE_UPDATE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_ing_svp_table_entry_to_hdl(unit, entry, ent_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_SVP_TABLE_SVP].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->vp));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
}
exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT ING_DVP_TABLE.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_ing_dvp_table_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_ing_dvp_table_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    uint64_t  value;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_ING_DVP_TABLE, &lt_info));

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &ent_hdl));

    flds = lt_info->flds;

    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_DVP_TABLE_DVP].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->dvp));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_DVP_TABLE_NO_CUT_THRU].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->no_cut_thru = (uint32_t)value;

        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_DVP_TABLE_DESTINATION].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->destination = (uint32_t)value;

        fid = BCMINT_LTSW_MPLS_FLD_ING_DVP_TABLE_L2MC_L3MC_L2_OIF_SYS_DST_VALID;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->dst_bmp_valid = (uint32_t)value;
        break;
    case BCMLT_OPCODE_INSERT:
    case BCMLT_OPCODE_UPDATE:
        if (opcode == BCMLT_OPCODE_INSERT) {
            fid = BCMINT_LTSW_MPLS_FLD_ING_DVP_TABLE_STRENGTH_PROFILE_INDEX;
            fld_name = flds[fid].name;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hdl, fld_name, entry->str_prfl_idx));
        }

        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_DVP_TABLE_DVP].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->dvp));

        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_DVP_TABLE_DESTINATION].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->destination));

        fid = BCMINT_LTSW_MPLS_FLD_ING_DVP_TABLE_L2MC_L3MC_L2_OIF_SYS_DST_VALID;
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->dst_bmp_valid));

        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_DVP_TABLE_NO_CUT_THRU].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->no_cut_thru));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_DVP_TABLE_DVP].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->dvp));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
}
exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert entry to handle for the LT EGR_DVP.
 *
 * \param [in]  unit       Unit number.
 * \param [in]  entry      Entry info.
 * \param [out] ent_hdl    Entry handle for EGR_DVP.
 *
 * \retval SHR_E_NONE      No errors.
 * \retval !SHR_E_NONE     Failure.
 */
static int
lt_egr_dvp_entry_to_hdl(
    int unit,
    lt_egr_dvp_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;
    uint64_t   value;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EGR_DVP, &lt_info));
    flds = lt_info->flds;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_DVP].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->dvp));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_OBJ_TABLE_SEL_1].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, 0xf));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_EDIT_CTRL_ID].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, 0xc));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_TUNNEL_IDX_0].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->tunnel_idx_0));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_VC_LABEL_INDEX].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->vc_label_idx));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_CLASS_ID].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->class_id));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_SPLIT_HORIZON_CTRL].name;
    value    = entry->network_group_id & VP_SHC_DOMAIN_ID_MSK;
    value    = value << VP_SHC_DOMAIN_ID_SFT;
    value   |= (1 << VP_SHC_EN_SFT);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, value));

    fid =  BCMINT_LTSW_MPLS_FLD_EGR_DVP_L2_MTU_VALUE;
    if (lt_info->fld_bmp & (1 << fid)) {
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->l2_mtu_value));
    }

    fid =  BCMINT_LTSW_MPLS_FLD_EGR_DVP_PROCESS_CTRL_2;
    if (lt_info->fld_bmp & (1 << fid)) {
        value = 0;
        if (entry->l2_mtu_value > 0) {
            value |= EGR_DVP_PROCESS_CTRL_2_MTU_ENABLE;
        }
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, value));
    }

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_STRENGTH_PRFL_IDX].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->str_prfl_idx));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_SEQ_NUM_PROFILE_IDX].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->seq_num_prof_idx));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_SEQ_NUM_COUNTER_IDX].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->seq_num_cnt_idx));

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Construct entry of the LT EGR_DVP from handle.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for EGR_DVP.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_dvp_entry_from_hdl(
    int unit, lt_egr_dvp_entry_t *entry, bcmlt_entry_handle_t ent_hdl)
{
    uint64_t value = 0;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    bcmi_ltsw_sbr_profile_tbl_hdl_t pth = BCMI_LTSW_SBR_PTH_COUNT;
    bcmi_ltsw_sbr_profile_ent_type_t ent_type = BCMI_LTSW_SBR_PET_COUNT;
    int profile_idx = 0;
    int fid;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EGR_DVP, &lt_info));

    flds = lt_info->flds;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_DVP].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->dvp = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_TUNNEL_IDX_0].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->tunnel_idx_0 = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_VC_LABEL_INDEX].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->vc_label_idx = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_SEQ_NUM_PROFILE_IDX].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->seq_num_prof_idx = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_SEQ_NUM_COUNTER_IDX].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->seq_num_cnt_idx = (uint32_t)value;

    fid =  BCMINT_LTSW_MPLS_FLD_EGR_DVP_L2_MTU_VALUE;
    if (lt_info->fld_bmp & (1 << fid)) {
        fld_name = flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->l2_mtu_value = (uint32_t)value;
    }

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_STRENGTH_PRFL_IDX].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    pth = BCMI_LTSW_SBR_PTH_EGR_DVP;
    ent_type = BCMI_LTSW_SBR_PET_NO_CLASSID;
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                             &profile_idx));
    if (profile_idx == value) {
        entry->class_id = BCM_CLASS_ID_INVALID;
    } else {
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_CLASS_ID].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
        entry->class_id = (uint32_t)value;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT EGR_DVP.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_dvp_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_egr_dvp_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EGR_DVP, &lt_info));

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &ent_hdl));

    flds = lt_info->flds;
    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_DVP].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->dvp));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_egr_dvp_entry_from_hdl(unit, entry, ent_hdl));

        break;
    case BCMLT_OPCODE_INSERT:
    case BCMLT_OPCODE_UPDATE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_egr_dvp_entry_to_hdl(unit, entry, ent_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_DVP_DVP].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->dvp));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }
exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}


/*!
 * \brief Convert entry to handle for the LT ING_VFI_TABLE.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for ING_VFI_TABLE.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_ing_vfi_table_entry_to_hdl(
    int unit,
    lt_ing_vfi_table_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;
    const char *str_value;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_ING_VFI_TABLE, &lt_info));

    flds = lt_info->flds;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_VFI_TABLE_VFI].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->vfi));

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_VFI_TABLE_DESTINATION].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, fld_name, entry->dest));

    fid = BCMINT_LTSW_MPLS_FLD_ING_VFI_TABLE_DESTINATION_TYPE;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].scalar_to_symbol(unit, BCMI_XFS_DEST_TYPE_L3MC_GROUP,
                                        &str_value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(ent_hdl, fld_name, str_value));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct entry of the LT ING_VFI_TABLE from handle.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for ING_VFI_TABLE.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_ing_vfi_table_entry_from_hdl(
    int unit,
    lt_ing_vfi_table_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    uint64_t value = 0;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_ING_VFI_TABLE, &lt_info));
    flds = lt_info->flds;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_VFI_TABLE_VFI].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->vfi = (uint32_t)value;

    fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_VFI_TABLE_DESTINATION].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, fld_name, &value));
    entry->dest = (uint32_t)value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT ING_VFI_TABLE.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_ing_vfi_table_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_ing_vfi_table_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const bcmint_mpls_lt_t *lt_info;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_ING_VFI_TABLE, &lt_info));

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &ent_hdl));

    flds = lt_info->flds;

    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        fld_name = flds[BCMINT_LTSW_MPLS_FLD_ING_VFI_TABLE_VFI].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, fld_name, entry->vfi));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_ing_vfi_table_entry_from_hdl(unit, entry, ent_hdl));

        break;
    case BCMLT_OPCODE_UPDATE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_ing_vfi_table_entry_to_hdl(unit, entry, ent_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
}
exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert entry to handle for the LT TNL_PW_DECAP_SEQUENCE_NUMBER.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for TNL_PW_DECAP_SEQUENCE_NUMBER.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_itnl_pw_decap_seq_num_entry_to_hdl(
    int unit,
    lt_tnl_pw_decap_seq_num_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, SEQUENCE_NUMBERs, entry->seq_num));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct entry of the LT TNL_PW_DECAP_SEQUENCE_NUMBER from handle.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for TNL_PW_DECAP_SEQUENCE_NUMBER.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_tnl_pw_decap_seq_num_entry_from_hdl(
    int unit,
    lt_tnl_pw_decap_seq_num_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, SEQUENCE_NUMBERs, &value));
    entry->seq_num = (uint32_t)value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT TNL_PW_DECAP_SEQUENCE_NUMBER.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_tnl_pw_decap_seq_num_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_tnl_pw_decap_seq_num_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_PW_DECAP_SEQUENCE_NUMBERs, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_PW_DECAP_SEQUENCE_NUMBER_IDs,
                               entry->index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, PIPEs, entry->pipe));

    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tnl_pw_decap_seq_num_entry_from_hdl(unit, entry, ent_hdl));

        break;
    case BCMLT_OPCODE_INSERT:
    case BCMLT_OPCODE_UPDATE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_itnl_pw_decap_seq_num_entry_to_hdl(unit, entry, ent_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
}
exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Create a pw term counter entry.
 *
 * \param [in] unit         Unit number.
 * \param [in] index        Pw term counter entry index.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
static int
xfs_pw_term_counter_create(
    int unit,
    int *index)
{
    int i = -1;
    lt_tnl_pw_decap_seq_num_entry_t entry;
    uint32_t pipe;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < XFS_MPLS_PW_TERM_CNT_SZ(unit); i++) {
        if (!XFS_MPLS_PW_TERM_USED_GET(unit, i)) {
            *index = i;
            break;
        }
    }

    if (i == XFS_MPLS_PW_TERM_CNT_SZ(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_RESOURCE);
    }
    XFS_MPLS_PW_TERM_USED_SET(unit, i);

    sal_memset(&entry, 0, sizeof(entry));
    entry.index = i;
    for (pipe = 0; pipe < bcmi_ltsw_dev_max_pp_pipe_num(unit); pipe++) {
        entry.pipe = pipe;
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tnl_pw_decap_seq_num_op(unit, BCMLT_OPCODE_INSERT, &entry));
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a pw term counter entry.
 *
 * \param [in] unit         Unit number.
 * \param [in] index        Pw term counter entry index.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
static int
xfs_pw_term_counter_destroy(
    int unit,
    int index)
{
    lt_tnl_pw_decap_seq_num_entry_t entry;
    uint32_t pipe;

    SHR_FUNC_ENTER(unit);

    sal_memset(&entry, 0, sizeof(entry));
    entry.index = index;
    for (pipe = 0; pipe < bcmi_ltsw_dev_max_pp_pipe_num(unit); pipe++) {
        entry.pipe = pipe;
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tnl_pw_decap_seq_num_op(unit, BCMLT_OPCODE_DELETE, &entry));
    }

    XFS_MPLS_PW_TERM_USED_CLR(unit, index);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert tunnel switch info to
 * entry of the LT MPLS_ENTTRY_x (x is 1,2,3).
 *
 * \param [in] unit                    Unit number.
 * \param [in] info                    Tunnel terminator information.
 * \param [in] entry                   Entry info.
 * \param [in] old_pw_term_num    Existing pw_term_num.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
static int
tnl_switch_info_to_mpls_entry(
    int unit,
    bcm_mpls_tunnel_switch_t *info,
    lt_mpls_entry_t *entry,
    int old_pw_term_num)
{
    bcmi_ltsw_l3_egr_obj_type_t type;
    int nh_idx;
    int pw_cnt = -1;
    bcmi_ltsw_qos_map_type_t qos_type;
    int ecn_map_type = 0;

    SHR_FUNC_ENTER(unit);

    entry->fld_bmp  |= ME_TNL_FLD_BMP;

    entry->label     = info->label;

    if (info->port != BCM_GPORT_INVALID) {
        entry->label_conext_id = info->port;
    } else {
        entry->label_conext_id = 0;
    }

    entry->class_id  = info->class_id;

    if (info->flags & BCM_MPLS_SWITCH_DROP) {
        entry->drop_en   =  1;
    }

    switch (info->action) {
    case BCM_MPLS_SWITCH_ACTION_SWAP:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_resolve(unit, info->egress_if,
                                                &nh_idx, &type));
        if (type == BCMI_LTSW_L3_EGR_OBJ_T_OL) {
            entry->dest_type    = BCMI_XFS_DEST_TYPE_NHOP;
        } else if (type == BCMI_LTSW_L3_EGR_OBJ_T_ECMP_OL) {
            entry->dest_type    = BCMI_XFS_DEST_TYPE_ECMP;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        entry->label_action = bcmintLtswMplsFwdLabelActionSwap;
        entry->dest         = nh_idx;
        break;
    case BCM_MPLS_SWITCH_ACTION_POP:
        /*
         * If the lable is BOS, assign an L3_IIF.
         * If the label is not BOS, the L3_IIF assignment is
         * overrided by the next label.
         */
        entry->label_action = bcmintLtswMplsFwdLabelActionPopRoute;
        if ((info->ingress_if == 0) ||
            SHR_SUCCESS(bcmi_ltsw_l3_ing_intf_id_validate(unit,
                                                          info->ingress_if))) {
            entry->l3_iif_vfi_nh2           = info->ingress_if;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        break;
    case BCM_MPLS_SWITCH_ACTION_PHP:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_resolve(unit, info->egress_if,
                                                &nh_idx, &type));
        if (type == BCMI_LTSW_L3_EGR_OBJ_T_OL) {
            entry->dest_type    = BCMI_XFS_DEST_TYPE_NHOP;
        } else if (type == BCMI_LTSW_L3_EGR_OBJ_T_ECMP_OL) {
            entry->dest_type    = BCMI_XFS_DEST_TYPE_ECMP;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        entry->label_action = bcmintLtswMplsFwdLabelActionPhp;
        entry->dest         = nh_idx;
        break;
    default:
        return BCM_E_PARAM;
    }

    entry->pw_term_num       = 0;
    entry->pw_term_num_valid = 0;
    if ((info->flags & BCM_MPLS_SWITCH_COUNTED)) {
        if (old_pw_term_num >=0) {
            /* Old counter index exists. */
            entry->pw_term_num       = old_pw_term_num;
        } else {
            /* Allocate a new counter index. */
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_pw_term_counter_create(unit, &pw_cnt));

            entry->pw_term_num = pw_cnt;
        }

        entry->pw_term_num_valid = 1;
    }
    entry->cw_check_ctrl = bcmintLtswMplsCwCheckCtrlNotPresent;

    entry->exp_qos_ctrl_id = EXP_QOS_CTRL_ID_NONE;
    if (info->flags & BCM_MPLS_SWITCH_INT_PRI_MAP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_resolve(unit, info->exp_map, &qos_type,
                                          (int *)&entry->exp_mapping_ptr));
        if (qos_type != bcmiQosMapTypeMplsIngress) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        entry->exp_qos_ctrl_id = EXP_QOS_CTRL_ID_SEL;
    }

    if (info->flags & BCM_MPLS_SWITCH_INGRESS_ECN_MAP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_ecn_map_id_resolve(unit, info->ecn_map_id, &ecn_map_type,
                                          &entry->exp2ecn_mapping_ptr));

        if (ecn_map_type != BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

    entry->ttl_mode = bcmintLtswMplsTtlModeUniform;
    if (info->flags & BCM_MPLS_SWITCH_INNER_TTL) {
        entry->ttl_mode = bcmintLtswMplsTtlModePipe;
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (pw_cnt != -1) {
            (void)xfs_pw_term_counter_destroy(unit, pw_cnt);
        }
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct tunnel switch info from
 * entry of the LT MPLS_ENTTRY_x (x is 1,2,3).
 *
 * \param [in] unit       Unit number.
 * \param [in] info       Tunnel terminator information.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
tnl_switch_info_from_mpls_entry(
    int unit,
    bcm_mpls_tunnel_switch_t *info,
    lt_mpls_entry_t *entry)
{
    bcmi_ltsw_l3_egr_obj_type_t type;
    int nh_idx = -1;
    int rv;
    int  min_label_0, max_label_0, min_label_1, max_label_1;
    int ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN;

    SHR_FUNC_ENTER(unit);

    info->class_id = entry->class_id;
    info->label    = entry->label;
    info->port     = entry->label_conext_id;

    if (entry->label_conext_id == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_mpls_global_label_range_get(unit, 0,
                                                  &min_label_0, &max_label_0));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_mpls_global_label_range_get(unit, 1,
                                                  &min_label_1, &max_label_1));

        if (((info->label >= min_label_0) && (info->label <= max_label_0)) ||
            ((info->label >= min_label_1) && (info->label <= max_label_1)) ) {
            info->port = BCM_GPORT_INVALID;
        }
    }

    if (entry->drop_en) {
        info->flags |= BCM_MPLS_SWITCH_DROP;
    }

    if (entry->pw_term_num_valid) {
        info->flags |= BCM_MPLS_SWITCH_COUNTED;
    }

    switch (entry->label_action) {
    case bcmintLtswMplsFwdLabelActionSwap:
        if (entry->dest_type == BCMI_XFS_DEST_TYPE_NHOP) {
            type   = BCMI_LTSW_L3_EGR_OBJ_T_OL;
            nh_idx = entry->dest;
        } else if (entry->dest_type == BCMI_XFS_DEST_TYPE_ECMP) {
            type   = BCMI_LTSW_L3_EGR_OBJ_T_ECMP_OL;
            nh_idx = entry->dest;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_construct(unit, nh_idx, type,
                                                  &info->egress_if));
        info->action = BCM_MPLS_SWITCH_ACTION_SWAP;
        break;
    case bcmintLtswMplsFwdLabelActionPopRoute:
        info->action = BCM_MPLS_SWITCH_ACTION_POP;
        info->ingress_if = entry->l3_iif_vfi_nh2;
        break;
    case bcmintLtswMplsFwdLabelActionPhp:
        if (entry->dest_type == BCMI_XFS_DEST_TYPE_NHOP) {
            type   = BCMI_LTSW_L3_EGR_OBJ_T_OL;
            nh_idx = entry->dest;
        } else if (entry->dest_type == BCMI_XFS_DEST_TYPE_ECMP) {
            type   = BCMI_LTSW_L3_EGR_OBJ_T_ECMP_OL;
            nh_idx = entry->dest;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_construct(unit, nh_idx, type,
                                                  &info->egress_if));
        info->action = BCM_MPLS_SWITCH_ACTION_PHP;
        break;
    default:
        return BCM_E_PARAM;
    }

    if (entry->exp_mapping_ptr) {
        rv = bcmi_ltsw_qos_map_id_construct(unit,
                                            (int)entry->exp_mapping_ptr,
                                            bcmiQosMapTypeMplsIngress,
                                            &info->exp_map);
        if(SHR_SUCCESS(rv)) {
            info->flags |= BCM_MPLS_SWITCH_INT_PRI_MAP;
        }
    }

    rv = bcmi_ltsw_ecn_map_id_construct(unit, ecn_map_type,
                                        entry->exp2ecn_mapping_ptr,
                                        &info->ecn_map_id);
    if(SHR_SUCCESS(rv)) {
        info->flags |= BCM_MPLS_SWITCH_INGRESS_ECN_MAP;
    }

    if (entry->ttl_mode == bcmintLtswMplsTtlModePipe) {
        info->flags |= BCM_MPLS_SWITCH_INNER_TTL;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse mpls tunnel switch entries and call the callback.
 *
 * \param [in] unit             Unit number.
 * \param [in] cb_err_abort     Abort if callback reports error.
 * \param [in] cb               callback function.
 * \param [in] user_data        User data.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
tnl_switch_traverse(
    int unit,
    int cb_err_abort,
    bcm_mpls_tunnel_switch_traverse_cb cb,
    void *user_data)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    int rv = SHR_E_NONE, rv1 = SHR_E_NONE;
    lt_mpls_entry_t entry;
    bcm_mpls_tunnel_switch_t info;
    const bcmint_mpls_lt_t *lt_info;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_1, &lt_info));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &ent_hdl));

    rv = bcmi_lt_entry_commit(unit, ent_hdl, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);

    while (rv == SHR_E_NONE) {
        sal_memset(&entry, 0, sizeof(lt_mpls_entry_t));

        entry.fld_bmp |= ME_FLD_LABEL_ACTION;
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_x_entry_from_hdl(unit, &entry, ent_hdl));

        if (entry.label_action == bcmintLtswMplsFwdLabelActionPopSwitch) {
            /* Programmed via bcm_mpls_port_xxx APIs. */
            continue;
        }

        entry.fld_bmp = ME_TNL_FLD_BMP;
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_x_entry_from_hdl(unit, &entry, ent_hdl));

        sal_memset(&info, 0, sizeof(bcm_mpls_tunnel_switch_t));
        SHR_IF_ERR_VERBOSE_EXIT
            (tnl_switch_info_from_mpls_entry(unit, &info, &entry));

        /* Traverse to next entry */
        rv = bcmi_lt_entry_commit(unit, ent_hdl, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        rv1 = cb(unit, &info, user_data);
        if (SHR_FAILURE(rv1) && cb_err_abort) {
            SHR_IF_ERR_VERBOSE_EXIT(rv1);
        }
    }

    if ((rv != SHR_E_NOT_FOUND) && SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }


exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    MPLS_TNL_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Call back function for deleting all mpls tunnel switch entries.
 *
 * \param [in] unit             Unit number.
 * \param [in] cb_err_abort     Abort if callback reports error.
 * \param [in] cb               callback function.
 * \param [in] user_data        User data.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
tnl_switch_delete_all_trav_cb(
    int unit,
    bcm_mpls_tunnel_switch_t *info,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_mpls_tnl_switch_delete(unit, info));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert mpls port info to
 * entry of the LT MPLS_ENTTRY_x (x is 1,2,3).
 *
 * \param [in] unit                      Unit number.
 * \param [in] vpn                       VPN ID.
 * \param [in] vp                        VP ID.
 * \param [in] mpls_port                 mpls port info.
 * \param [in] entry                     entry info.
 * \param [in] old_pw_term_num      Existing pw_term_num.
 *
 * \return Nothing.
 */
static int
mpls_port_to_mpls_entry(
    int unit,
    bcm_vpn_t vpn,
    int vp,
    bcm_mpls_port_t *mpls_port,
    lt_mpls_entry_t *entry,
    int old_pw_term_num)
{
    int vpn_idx;
    int pw_cnt;
    bcmi_ltsw_qos_map_type_t qos_type;
    int ecn_map_type;

    SHR_FUNC_ENTER(unit);

    if (mpls_port->vccv_type > bcmMplsPortControlChannelAch) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    entry->fld_bmp        |= ME_FLD_LABEL;
    entry->label           = mpls_port->match_label;
    entry->fld_bmp        |= ME_FLD_CONTEXT_ID;
    if (mpls_port->criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
        entry->label_conext_id = mpls_port->port_group;
    }

    entry->svp          = vp;
    entry->label_action = bcmintLtswMplsFwdLabelActionPopSwitch;
    entry->fld_bmp        |= ME_FLD_SVP;
    entry->fld_bmp        |= ME_FLD_LABEL_ACTION;

    if (BCMI_LTSW_VIRTUAL_VPN_IS_VPWS(vpn)) {
        entry->p2p_flow = 1;
        entry->fld_bmp |= ME_FLD_P2P_FLOW;
    } else if (BCMI_LTSW_VIRTUAL_VPN_IS_VPLS(vpn)) {
        BCMI_LTSW_VIRTUAL_VPN_GET(vpn_idx, BCM_VPN_TYPE_MPLS_VPLS, vpn);
        entry->l3_iif_vfi_nh2 = vpn_idx;
        entry->fld_bmp |= ME_FLD_L3_IIF_VFI_NH2;
    } else {
        entry->l3_iif_vfi_nh2 = vpn;
        entry->fld_bmp |= ME_FLD_L3_IIF_VFI_NH2;
    }

    if (mpls_port->class_id > 0) {
        entry->class_id = mpls_port->class_id;
        entry->fld_bmp        |= ME_FLD_CLASS_ID;
    }

    entry->fld_bmp        |= ME_FLD_DROP_EN;
    entry->drop_en = 0;
    if (mpls_port->flags & BCM_MPLS_PORT_DROP) {
        entry->drop_en = 1;
    }

    entry->pw_term_num       = 0;
    entry->pw_term_num_valid = 0;
    entry->fld_bmp        |= ME_FLD_PW_TERM_NUM_VALID;
    if ((mpls_port->flags & BCM_MPLS_PORT_SEQUENCED) ||
        (mpls_port->flags & BCM_MPLS_PORT_COUNTED)) {
        if (old_pw_term_num >= 0) {
            /* Old counter index exists. */
            entry->pw_term_num       = old_pw_term_num;
        } else {
            /* Allocate a new counter index. */
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_pw_term_counter_create(unit, &pw_cnt));

            entry->pw_term_num = pw_cnt;
        }

        entry->pw_term_num_valid = 1;
    }

    entry->cw_check_ctrl = bcmintLtswMplsCwCheckCtrlNotPresent;
    entry->fld_bmp        |= ME_FLD_CW_CHECK_CTRL;
    if (mpls_port->flags & BCM_MPLS_PORT_SEQUENCED) {
        entry->cw_check_ctrl = bcmintLtswMplsCwCheckCtrlLoose;
    } else if (mpls_port->flags & BCM_MPLS_PORT_CONTROL_WORD) {
        entry->cw_check_ctrl = bcmintLtswMplsCwCheckCtrlDisable;
    }

    entry->exp_qos_ctrl_id = EXP_QOS_CTRL_ID_NONE;
    entry->fld_bmp        |= ME_FLD_EXP_MAPPING_PTR;
    if (mpls_port->flags & BCM_MPLS_PORT_INT_PRI_MAP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_resolve(unit, mpls_port->exp_map, &qos_type,
                                          (int *)&entry->exp_mapping_ptr));
        if (qos_type != bcmiQosMapTypeMplsIngress) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        entry->exp_qos_ctrl_id = EXP_QOS_CTRL_ID_SEL;
    }

    entry->fld_bmp   |= ME_FLD_EL_PRESENT;
    entry->el_present = 0;
    if ((mpls_port->flags & BCM_MPLS_PORT_ENTROPY_ENABLE) ||
        (mpls_port->flags2 & BCM_MPLS_PORT2_INGRESS_ENTROPY_ENABLE)) {
        entry->el_present = 1;
    }


    entry->pw_cc_type = mpls_port->vccv_type;
    entry->fld_bmp        |= ME_FLD_PW_CC_TYPE;

    entry->exp2ecn_mapping_ptr = 0;
    entry->fld_bmp        |= ME_FLD_EXP_TO_ECN_MAPPING_PTR;
    if (mpls_port->flags2 & BCM_MPLS_PORT2_INGRESS_ECN_MAP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_ecn_map_id_resolve(unit, mpls_port->ecn_map_id,
                                          &ecn_map_type,
                                          &entry->exp2ecn_mapping_ptr));
        if (ecn_map_type != BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (pw_cnt != -1) {
            (void)xfs_pw_term_counter_destroy(unit, pw_cnt);
        }
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct mpls port info from
 * entry of the LT MPLS_ENTTRY_x (x is 1,2,3).
 *
 * \param [in] unit         Unit number.
 * \param [in] vp           Virtual port.
 * \param [in] mpls_port    mpls port info.
 * \param [in] entry        entry info.
 *
 * \return Nothing.
 */
static void
mpls_port_from_mpls_entry(
    int unit, int vp, bcm_mpls_port_t *mpls_port, lt_mpls_entry_t *entry)
{
    int rv;
    int  min_label_0, max_label_0, min_label_1, max_label_1;
    bcm_mpls_label_t label;
    int ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN;

    mpls_port->class_id    = entry->class_id;
    mpls_port->match_label = entry->label;
    mpls_port->port_group  = entry->label_conext_id;

    label                  = entry->label;
    rv = xfs_ltsw_mpls_global_label_range_get(unit, 0,
                                              &min_label_0, &max_label_0);
    if (SHR_SUCCESS(rv)) {
        rv = xfs_ltsw_mpls_global_label_range_get(unit, 1,
                                                  &min_label_1, &max_label_1);
        if (SHR_SUCCESS(rv)) {
            if (((label >= min_label_0) && (label <= max_label_0)) ||
                ((label >= min_label_1) && (label <= max_label_1))) {
                mpls_port->port_group = BCM_PORT_INVALID;
            }
        }
    }

    if (entry->pw_term_num_valid) {
        mpls_port->flags |= BCM_MPLS_PORT_COUNTED;
    }

    if (entry->cw_check_ctrl == bcmintLtswMplsCwCheckCtrlLoose) {
        mpls_port->flags |= BCM_MPLS_PORT_SEQUENCED;
    } else if (entry->cw_check_ctrl == bcmintLtswMplsCwCheckCtrlDisable) {
        mpls_port->flags |= BCM_MPLS_PORT_CONTROL_WORD;
    }

    if (entry->drop_en) {
         mpls_port->flags |= BCM_MPLS_PORT_DROP;
    }

    if (entry->exp_mapping_ptr) {
        rv = bcmi_ltsw_qos_map_id_construct(unit,
                                            (int)entry->exp_mapping_ptr,
                                            bcmiQosMapTypeMplsIngress,
                                            &mpls_port->exp_map);
        if(SHR_SUCCESS(rv)) {
            mpls_port->flags |= BCM_MPLS_PORT_INT_PRI_MAP;
        }
    }

    if (entry->el_present) {
         mpls_port->flags2 |= BCM_MPLS_PORT2_INGRESS_ENTROPY_ENABLE;
    }

    mpls_port->vccv_type = entry->pw_cc_type;

    rv = bcmi_ltsw_ecn_map_id_construct(unit, ecn_map_type,
                                        entry->exp2ecn_mapping_ptr,
                                        &mpls_port->ecn_map_id);
    if(SHR_SUCCESS(rv)) {
        mpls_port->flags2 |= BCM_MPLS_PORT2_INGRESS_ECN_MAP;
    }

    
    return;
}

/*!
 * \brief Convert tunnel initiator info to
 * entry of the LT EGR_L3_TUNNEL_0 and EGR_L3_TUNNEL_1.
 *
 * \param [in] unit            Unit number.
 * \param [in] tunnel_encap    Tunnel encap information.
 * \param [in] entry           Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
tnl_encap_to_egr_l3_tnl_entry(
    int unit,
    bcm_mpls_tunnel_encap_t *tunnel_encap,
    lt_egr_l3_tnl_entry_t *entry)
{
    bcm_mpls_tunnel_encap_t *te = tunnel_encap;
    int hdr_idx = 0, i;
    uint32_t flags;
    bcmi_ltsw_qos_map_type_t qos_type;

    SHR_FUNC_ENTER(unit);

    entry->edit_ctrl_id = XFS_TNL_EDIT_CTRL_ID_MPLS;

    entry->mpls_push_bitmap = push_bitmap[te->num_labels];

    if (te->num_labels < 1) {
        SHR_EXIT();
    }

    hdr_idx = 0;
    for (i = te->num_labels - 1; i >= 0; i--) {
        BUILD_MPLS_HDR(entry->mpls_hdr[hdr_idx],
                       te->label_array[i].label,
                       te->label_array[i].exp, 0,
                       te->label_array[i].ttl);
        hdr_idx++;
    }

    flags = te->label_array[te->num_labels - 1].flags;
    entry->mpls_ctrl = 0;
    if (!(flags & BCM_MPLS_EGRESS_LABEL_TTL_SET)) {
        entry->mpls_ctrl |= MPLS_CTRL_USE_PLD_TTL;
    }

    if (tunnel_encap->flags & BCM_MPLS_TUNNEL_ENCAP_ENTROPY_ENABLE) {
        entry->mpls_ctrl |= MPLS_CTRL_ENTROPY_ENABLE;
    }

    if (tunnel_encap->flags & BCM_MPLS_TUNNEL_ENCAP_QOS_EXP_REMARK) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_resolve(unit, tunnel_encap->qos_map_id ,
                                          &qos_type,
                                          (int *)&entry->exp_remark_ptr));
        if (qos_type != bcmiQosMapTypeMplsTnlEgress) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

    
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct tunnel initiator info from
 * entry of the LT EGR_L3_TUNNEL_0 and EGR_L3_TUNNEL_1.
 *
 * \param [in] unit            Unit number.
 * \param [in] tunnel_encap    Tunnel encap information.
 * \param [in] entry           Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
tnl_encap_from_egr_l3_tnl_entry(
    int unit,
    bcm_mpls_tunnel_encap_t *tunnel_encap,
    lt_egr_l3_tnl_entry_t *entry)
{
    bcm_mpls_tunnel_encap_t *te = tunnel_encap;
    int hdr_idx = 0, i;
    int num_labels;
    uint32_t flags;

    SHR_FUNC_ENTER(unit);

    if (entry->edit_ctrl_id != XFS_TNL_EDIT_CTRL_ID_MPLS) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    }

    for (num_labels = 0; num_labels <= XFS_ENCAP_LABEL_CNT_MAX; num_labels++) {
        if (push_bitmap[num_labels] == entry->mpls_push_bitmap) {
            te->num_labels = num_labels;
            break;
        }
    }

    if (te->num_labels < 1) {
        SHR_EXIT();
    }

    hdr_idx = 0;
    for (i = te->num_labels - 1; i >= 0; i--) {
        PARSE_MPLS_HDR_NO_BOS(entry->mpls_hdr[hdr_idx],
                              te->label_array[i].label,
                              te->label_array[i].exp,
                              te->label_array[i].ttl);
        hdr_idx++;
    }

    flags = 0;
    if (entry->mpls_ctrl & MPLS_CTRL_USE_PLD_TTL) {
        flags |= BCM_MPLS_EGRESS_LABEL_TTL_DECREMENT;
    } else {
        flags |= BCM_MPLS_EGRESS_LABEL_TTL_SET;
    }
    te->label_array[te->num_labels - 1].flags |= flags;

    for (i = 0; i < te->num_labels - 1; i++) {
        te->label_array[i].flags |= BCM_MPLS_EGRESS_LABEL_TTL_SET;
    }

    if (entry->mpls_ctrl & MPLS_CTRL_ENTROPY_ENABLE) {
        tunnel_encap->flags |= BCM_MPLS_TUNNEL_ENCAP_ENTROPY_ENABLE;
    }

    if (entry->exp_remark_ptr != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_construct(unit, entry->exp_remark_ptr,
                                            bcmiQosMapTypeMplsTnlEgress,
                                            &(tunnel_encap->qos_map_id)));
        tunnel_encap->flags |= BCM_MPLS_TUNNEL_ENCAP_QOS_EXP_REMARK;
    }

    
exit:
    SHR_FUNC_EXIT();

}

/*!
 * \brief Convert vpn info to entry of the LT ING_VFI_TABLE.
 *
 * \param [in] unit       Unit number.
 * \param [in] vfi_idx    VFI index.
 * \param [in] info       VPN information.
 * \param [in] entry      Entry info.
 *
 * \return Nothing.
 */
static void
vpn_info_to_ing_vfi_table_entry(
    int unit,
    int vfi_idx,
    bcm_mpls_vpn_config_t *info,
    lt_ing_vfi_table_entry_t *entry)
{
    entry->vfi  = vfi_idx;
    entry->dest = _BCM_MULTICAST_ID_GET(info->broadcast_group);

    
    return;
}

/*!
 * \brief Construct vpn info from entry of the LT ING_VFI_TABLE.
 *
 * \param [in] unit     Unit number.
 * \param [in] info     VPN information.
 * \param [in] entry    Entry info.
 *
 * \return Nothing.
 */
static void
vpn_info_from_ing_vfi_table_entry(
    int unit,
    bcm_mpls_vpn_config_t *info,
    lt_ing_vfi_table_entry_t *entry)
{
    _BCM_MULTICAST_GROUP_SET(info->broadcast_group,
                             _BCM_MULTICAST_TYPE_VPLS, entry->dest);
    info->unknown_multicast_group = info->broadcast_group;
    info->unknown_unicast_group   = info->broadcast_group;

    
    return;
}

/*!
 * \brief Construct entry of the LT TNL_MPLS_SPECIAL_LABEL from handle.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for TNL_MPLS_SPECIAL_LABEL.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_tnl_mpls_special_label_entry_from_hdl(
    int unit,
    lt_tnl_mpls_special_label_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, MPLS_HEADERs, &value));
    entry->mpls_header = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, MPLS_HEADER_MASKs, &value));
    entry->mpls_header_mask = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, IGNORE_NEXT_LABEL_ACTIONs, &value));
    entry->ignore_next_act = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, SKIP_NEXT_LABEL_HASHs, &value));
    entry->skip_next_hash = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, SKIP_LABEL_HASHs, &value));
    entry->skip_hash = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, SKIP_NEXT_LABEL_LOOKUPs, &value));
    entry->skip_next_lkup = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, SKIP_LABEL_LOOKUPs, &value));
    entry->skip_lkup = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, RESERVED_LABELs, &value));
    entry->rsvd_lbl = (uint32_t)value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert entry to handle for the LT TNL_MPLS_SPECIAL_LABEL.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for TNL_MPLS_SPECIAL_LABEL.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_tnl_mpls_special_label_entry_to_hdl(
    int unit,
    lt_tnl_mpls_special_label_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, MPLS_HEADERs, entry->mpls_header));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, MPLS_HEADER_MASKs,
                               entry->mpls_header_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, IGNORE_NEXT_LABEL_ACTIONs,
                               entry->ignore_next_act));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, SKIP_NEXT_LABEL_HASHs,
                               entry->skip_next_hash));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, SKIP_LABEL_HASHs, entry->skip_hash));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, SKIP_NEXT_LABEL_LOOKUPs,
                               entry->skip_next_lkup));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, SKIP_LABEL_LOOKUPs, entry->skip_lkup));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, RESERVED_LABELs, entry->rsvd_lbl));


exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT TNL_MPLS_SPECIAL_LABEL.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_tnl_mpls_special_label_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_tnl_mpls_special_label_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_SPECIAL_LABELs, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_SPECIAL_LABEL_IDs,
                               entry->index));

    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tnl_mpls_special_label_entry_from_hdl(unit, entry, ent_hdl));

        break;
    case BCMLT_OPCODE_INSERT:
    case BCMLT_OPCODE_UPDATE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tnl_mpls_special_label_entry_to_hdl(unit, entry, ent_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
}
exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert special label identifier info to
 * entry of the LT TNL_MPLS_SPECIAL_LABEL.
 *
 * \param [in] unit          Unit number.
 * \param [in] index         Entry index.
 * \param [in] label_info    Label information.
 * \param [in] entry         Entry info.
 *
 * \return Nothing.
 */
static void
label_identifier_to_tnl_mpls_special_label_entry(
    int unit,
    int index,
    bcm_mpls_special_label_t *label_info,
    lt_tnl_mpls_special_label_entry_t *entry)
{
    bcm_mpls_special_label_t *li = label_info;

    sal_memset(entry, 0, sizeof(lt_tnl_mpls_special_label_entry_t));

    entry->index = index;

    BUILD_MPLS_HDR(entry->mpls_header,
                   li->label_value, li->exp,
                   !!(li->flags & BCM_MPLS_SPECIAL_LABEL_BOS_PRESENT),
                   li->ttl);

    BUILD_MPLS_HDR(entry->mpls_header_mask,
                   li->label_mask, li->exp_mask,
                   !!(li->flags & BCM_MPLS_SPECIAL_LABEL_BOS_MASKED),
                   li->ttl_mask);

    if (li->flags & BCM_MPLS_SPECIAL_LABEL_NEXT_LABEL_ACTION_CANCEL) {
        entry->ignore_next_act = 1;
    }

    if (li->flags & BCM_MPLS_SPECIAL_LABEL_NEXT_LABEL_EXCLUDE_HASH) {
        entry->skip_next_hash = 1;
    }

    if (li->flags & BCM_MPLS_SPECIAL_LABEL_CURR_LABEL_EXCLUDE_HASH) {
        entry->skip_hash = 1;
    }

    if (li->flags & BCM_MPLS_SPECIAL_LABEL_NEXT_LABEL_EXCLUDE_LKUP) {
        entry->skip_next_lkup = 1;
    }

    if (li->flags & BCM_MPLS_SPECIAL_LABEL_CURR_LABEL_EXCLUDE_LKUP) {
        entry->skip_lkup = 1;
    }

    if (li->flags & BCM_MPLS_SPECIAL_LABEL_CURR_LABEL_RESERVE) {
        entry->rsvd_lbl = 1;
    }

    return;
}

/*!
 * \brief Construct special label identifier info from
 * entry of the LT TNL_MPLS_SPECIAL_LABEL.
 *
 * \param [in] unit          Unit number.
 * \param [in] label_info    Label information.
 * \param [in] entry         Entry info.
 *
 * \return Nothing.
 */
static void
label_identifier_from_tnl_mpls_special_label_entry(
    int unit,
    bcm_mpls_special_label_t *label_info,
    lt_tnl_mpls_special_label_entry_t *entry)
{
    bcm_mpls_special_label_t *li = label_info;
    int bos = 0, bos_mask = 0;

    li->flags = 0;
    PARSE_MPLS_HDR(entry->mpls_header, li->label_value, li->exp, bos, li->ttl);
    if (bos) {
        li->flags |= BCM_MPLS_SPECIAL_LABEL_BOS_PRESENT;
    }

    PARSE_MPLS_HDR(entry->mpls_header_mask,
                   li->label_mask, li->exp_mask, bos_mask, li->ttl_mask);
    if (bos_mask) {
        li->flags |= BCM_MPLS_SPECIAL_LABEL_BOS_MASKED;
    }

    if (entry->ignore_next_act) {
         li->flags |= BCM_MPLS_SPECIAL_LABEL_NEXT_LABEL_ACTION_CANCEL;
    }

    if (entry->skip_next_hash) {
        li->flags |= BCM_MPLS_SPECIAL_LABEL_NEXT_LABEL_EXCLUDE_HASH;
    }

    if (entry->skip_hash) {
        li->flags |= BCM_MPLS_SPECIAL_LABEL_CURR_LABEL_EXCLUDE_HASH;
    }

    if (entry->skip_next_lkup) {
        li->flags |= BCM_MPLS_SPECIAL_LABEL_NEXT_LABEL_EXCLUDE_LKUP;
    }

    if (entry->skip_lkup) {
        li->flags |= BCM_MPLS_SPECIAL_LABEL_CURR_LABEL_EXCLUDE_LKUP;
    }

    if (entry->rsvd_lbl) {
        li->flags |= BCM_MPLS_SPECIAL_LABEL_CURR_LABEL_RESERVE;
    }

    return;
}

static int
ctrl_pkt_match_validate(
    int unit,
    bcm_mpls_control_pkt_match_t *match)
{
    SHR_FUNC_ENTER(unit);

    if ((match->bos_after_lookup_labels > 1) ||
        (match->bos_after_lookup_labels_mask > 1) ||
        (match->gal_after_lookup_labels > 1) ||
        (match->gal_after_lookup_labels_mask > 1) ||
        (match->eli_after_lookup_labels > 1) ||
        (match->eli_after_lookup_labels_mask > 1) ||
        (match->el_bos_after_lookup_labels > 1) ||
        (match->el_bos_after_lookup_labels_mask > 1) ||
        (match->gal_valid > 1) ||
        (match->gal_valid_mask > 1) ||
        (match->el_valid > 1) ||
        (match->el_valid_mask > 1) ||
        (match->stat_enable > 1) ||
        (match->stat_enable_mask > 1) ||
        (match->control_word_ach_indicator > 0xf) ||
        (match->control_word_ach_indicator_mask > 0xf) ||
        (match->flow > bcmMplsFlowPhp) ||
        (match->flow_mask > 0xf) ||
        (match->control_word_check > bcmMplsControlWordCheckStrict) ||
        (match->control_word_check_mask > 0x3) ||
        (match->vccv_type > bcmMplsPortControlChannelAch) ||
        (match->vccv_type_mask> 1) ||
        (match->flow_mask > 1)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct entry key from handle for the LT TNL_MPLS_CONTROL_PKT.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for TNL_MPLS_CONTROL_PKT.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_tnl_mpls_control_pkt_entry_key_from_hdl(
    int unit,
    lt_tnl_mpls_control_pkt_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    uint64_t value;
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, ENTRY_PRIORITYs, &value));
    entry->entry_priority = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_0s, &value));
    entry->tnl_mpls_control_pkt_id_0 = (uint32_t)value;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_0_MASKs,
                               &value));
    entry->tnl_mpls_control_pkt_id_0_mask = (uint32_t)value;


    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_1s, &value));
    entry->tnl_mpls_control_pkt_id_1 = (uint32_t)value;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_1_MASKs,
                               &value));
    entry->tnl_mpls_control_pkt_id_1_mask = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_2s, &value));
    entry->tnl_mpls_control_pkt_id_2 = (uint32_t)value;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_2_MASKs,
                               &value));
    entry->tnl_mpls_control_pkt_id_2_mask = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_3s, &value));
    entry->tnl_mpls_control_pkt_id_3 = (uint32_t)value;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_3_MASKs,
                               &value));
    entry->tnl_mpls_control_pkt_id_3_mask = (uint32_t)value;

    /* tnl_mpls_control_pkt_id_4 Not used in DNA. */

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_5s, &value));
    entry->tnl_mpls_control_pkt_id_5 = (uint32_t)value;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_5_MASKs,
                               &value));
    entry->tnl_mpls_control_pkt_id_5_mask = (uint32_t)value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct entry field from handle for the LT TNL_MPLS_CONTROL_PKT.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for TNL_MPLS_CONTROL_PKT.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_tnl_mpls_control_pkt_entry_field_from_hdl(
    int unit,
    lt_tnl_mpls_control_pkt_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, ENTRY_PRIORITYs, &value));
    entry->entry_priority = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, SEQ_NUM_CHECKs, &value));
    entry->seq_num_check = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, CW_PRESENTs, &value));
    entry->cw_present = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, CONTROL_PKTs, &value));
    entry->control_packet = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, CONTROL_PKT_TYPEs, &value));
    entry->control_packet_type = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, COPY_TO_CPUs, &value));
    entry->copy_to_cpu = (uint32_t)value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, DROPs, &value));
    entry->drop = (uint32_t)value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert entry key to handle for the LT TNL_MPLS_CONTROL_PKT.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for TNL_MPLS_CONTROL_PKT.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_tnl_mpls_control_pkt_entry_key_to_hdl(
    int unit,
    lt_tnl_mpls_control_pkt_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, ENTRY_PRIORITYs,
                               entry->entry_priority));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_0s,
                               entry->tnl_mpls_control_pkt_id_0));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_0_MASKs,
                               entry->tnl_mpls_control_pkt_id_0_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_1s,
                               entry->tnl_mpls_control_pkt_id_1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_1_MASKs,
                               entry->tnl_mpls_control_pkt_id_1_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_2s,
                               entry->tnl_mpls_control_pkt_id_2));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_2_MASKs,
                               entry->tnl_mpls_control_pkt_id_2_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_3s,
                               entry->tnl_mpls_control_pkt_id_3));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_3_MASKs,
                               entry->tnl_mpls_control_pkt_id_3_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_4s,
                               entry->tnl_mpls_control_pkt_id_4));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_4_MASKs,
                               entry->tnl_mpls_control_pkt_id_4_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_5s,
                               entry->tnl_mpls_control_pkt_id_5));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_CONTROL_PKT_ID_5_MASKs,
                               entry->tnl_mpls_control_pkt_id_5_mask));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert entry fields to handle for the LT TNL_MPLS_CONTROL_PKT.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for TNL_MPLS_CONTROL_PKT.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_tnl_mpls_control_pkt_entry_field_to_hdl(
    int unit,
    lt_tnl_mpls_control_pkt_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, SEQ_NUM_CHECKs, entry->seq_num_check));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, CW_PRESENTs, entry->cw_present));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, CONTROL_PKTs, entry->control_packet));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, CONTROL_PKT_TYPEs,
                               entry->control_packet_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, COPY_TO_CPUs,
                               entry->copy_to_cpu));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, DROPs, entry->drop));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT TNL_MPLS_CONTROL_PKT.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_tnl_mpls_control_pkt_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_tnl_mpls_control_pkt_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_CONTROL_PKTs, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_tnl_mpls_control_pkt_entry_key_to_hdl(unit, entry, ent_hdl));

    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tnl_mpls_control_pkt_entry_field_from_hdl(unit, entry,
                                                          ent_hdl));
        break;
    case BCMLT_OPCODE_INSERT:
    case BCMLT_OPCODE_UPDATE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tnl_mpls_control_pkt_entry_field_to_hdl(unit, entry, ent_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
}
exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct MPLS control packet match from TNL_MPLS_CONTROL_PKT entry.
 *
 * \param [in] unit                      Unit number.
 * \param [in] match                     MPLS control packet match.
 * \param [out] entry                    TNL_MPLS_CONTROL_PKT entry.
 *
 * \return Nothing.
 */
static void
ctrl_pkt_match_from_tnl_mpls_control_pkt_entry(
    int unit,
    bcm_mpls_control_pkt_match_t *match,
    lt_tnl_mpls_control_pkt_entry_t *entry)
{
    uint32_t id, id_mask, i;

    match->priority = entry->entry_priority;

    id = entry->tnl_mpls_control_pkt_id_0;
    if (id == TNL_MPLS_CTRL_PKT_FLOW_NONE) {
       match->flow = bcmMplsFlowNone;
    } else if (id == TNL_MPLS_CTRL_PKT_FLOW_L2TERM) {
        match->flow = bcmMplsFlowL2Term;
    } else if (id == TNL_MPLS_CTRL_PKT_FLOW_L3TERM) {
        match->flow = bcmMplsFlowL3Term;
    } else if (id == TNL_MPLS_CTRL_PKT_FLOW_TRANSIT) {
        match->flow = bcmMplsFlowTransit;
    } else if (id == TNL_MPLS_CTRL_PKT_FLOW_PHP) {
        match->flow = bcmMplsFlowPhp;
    }
    match->flow_mask = !!entry->tnl_mpls_control_pkt_id_0_mask;

    i        = 0;
    id       = entry->tnl_mpls_control_pkt_id_1;
    id_mask  = entry->tnl_mpls_control_pkt_id_1_mask;
    match->bos_after_lookup_labels         = (id      >> i) &  0x1;
    match->bos_after_lookup_labels_mask    = (id_mask >> i) &  0x1;
    i++;
    match->gal_after_lookup_labels         = (id      >> i) &  0x1;
    match->gal_after_lookup_labels_mask    = (id_mask >> i) &  0x1;
    i++;
    match->eli_after_lookup_labels         = (id      >> i) &  0x1;
    match->eli_after_lookup_labels_mask    = (id_mask >> i) &  0x1;
    i++;
    match->el_bos_after_lookup_labels      = (id      >> i) &  0x1;
    match->el_bos_after_lookup_labels_mask = (id_mask >> i) &  0x1;


    /* tnl_mpls_control_pkt_id_2[0:0] is mpls_processing_enable, ignored. */
    i        = 1;
    id       = entry->tnl_mpls_control_pkt_id_2;
    id_mask  = entry->tnl_mpls_control_pkt_id_2_mask;
    match->gal_valid                       = (id      >> i) &  0x1;
    match->gal_valid_mask                  = (id_mask >> i) &  0x1;
    i++;
    match->el_valid                        = (id      >> i) &  0x1;
    match->el_valid_mask                   = (id_mask >> i) &  0x1;

    i        = 0;
    id       = entry->tnl_mpls_control_pkt_id_3;
    id_mask  = entry->tnl_mpls_control_pkt_id_3_mask;
    match->stat_enable                     = (id      >> i) &  0x1;
    match->stat_enable_mask                = (id_mask >> i) &  0x1;
    i++;
    match->vccv_type                       = (id      >> i) &  0x1;
    match->vccv_type_mask                  = (id_mask >> i) &  0x1;
    i++;
    match->control_word_check              = (id      >> i) &  0x3;
    match->control_word_check_mask         = (id_mask >> i) &  0x3;

    id       = entry->tnl_mpls_control_pkt_id_5;
    id_mask  = entry->tnl_mpls_control_pkt_id_5_mask;
    match->control_word_ach_indicator      = id;
    match->control_word_ach_indicator_mask = id_mask;

    return;
}

/*!
 * \brief Construct MPLS control packet action from TNL_MPLS_CONTROL_PKT entry.
 *
 * \param [in] unit                      Unit number.
 * \param [in] action                    MPLS control packet match.
 * \param [out] entry                    TNL_MPLS_CONTROL_PKT entry.
 *
 * \return Nothing.
 */
static void
ctrl_pkt_action_from_tnl_mpls_control_pkt_entry(
    int unit,
    bcm_mpls_control_pkt_action_t *action,
    lt_tnl_mpls_control_pkt_entry_t *entry)
{
    action->drop               = entry->drop;
    action->copy_to_cpu        = entry->copy_to_cpu;
    action->seq_num_check      = entry->seq_num_check;
    action->control_packet      = entry->control_packet;
    action->control_packet_type = entry->control_packet_type;

    return;
}

/*!
 * \brief Convert MPLS control packet match to TNL_MPLS_CONTROL_PKT entry.
 *
 * \param [in] unit                      Unit number.
 * \param [in] match                     MPLS control packet match.
 * \param [out] entry                    TNL_MPLS_CONTROL_PKT entry.
 *
 * \return Nothing.
 */
static void
ctrl_pkt_match_to_tnl_mpls_control_pkt_entry(
    int unit,
    bcm_mpls_control_pkt_match_t *match,
    lt_tnl_mpls_control_pkt_entry_t *entry)
{
    uint32_t id, id_mask, i;

    entry->entry_priority = match->priority;
    id_mask = 0;
    if (match->flow == bcmMplsFlowNone) {
       entry->tnl_mpls_control_pkt_id_0 = TNL_MPLS_CTRL_PKT_FLOW_NONE;
       id_mask = match->flow_mask ? TNL_MPLS_CTRL_PKT_MSK_ALL : 0;
    } else if (match->flow == bcmMplsFlowL2Term) {
        entry->tnl_mpls_control_pkt_id_0 = TNL_MPLS_CTRL_PKT_FLOW_L2TERM;
        id_mask = match->flow_mask ? TNL_MPLS_CTRL_PKT_MSK_ALL : 0;
    } else if (match->flow == bcmMplsFlowL3Term) {
        entry->tnl_mpls_control_pkt_id_0 = TNL_MPLS_CTRL_PKT_FLOW_L3TERM;
        id_mask  = match->flow_mask ? TNL_MPLS_CTRL_PKT_MSK_L3_ONLY : 0;
    } else if (match->flow == bcmMplsFlowTransit) {
        entry->tnl_mpls_control_pkt_id_0 = TNL_MPLS_CTRL_PKT_FLOW_TRANSIT;
        id_mask  = match->flow_mask ? TNL_MPLS_CTRL_PKT_MSK_TRANSIT_ONLY : 0;
    } else if (match->flow == bcmMplsFlowPhp) {
        entry->tnl_mpls_control_pkt_id_0 = TNL_MPLS_CTRL_PKT_FLOW_PHP;
        id_mask  = match->flow_mask ? TNL_MPLS_CTRL_PKT_MSK_PHP_ONLY : 0;
    }
    entry->tnl_mpls_control_pkt_id_0_mask = id_mask;

    i        = 0;
    id       = 0;
    id_mask  = 0;
    id      |= match->bos_after_lookup_labels          << i;
    id_mask |= match->bos_after_lookup_labels_mask     << i;
    i++;
    id      |= match->gal_after_lookup_labels          << i;
    id_mask |= match->gal_after_lookup_labels_mask     << i;
    i++;
    id      |= match->eli_after_lookup_labels          << i;
    id_mask |= match->eli_after_lookup_labels_mask     << i;
    i++;
    id      |= match->el_bos_after_lookup_labels       << i;
    id_mask |= match->el_bos_after_lookup_labels_mask  << i;
    entry->tnl_mpls_control_pkt_id_1      = id;
    entry->tnl_mpls_control_pkt_id_1_mask = id_mask;

    /* tnl_mpls_control_pkt_id_2[0:0] is mpls_processing_enable, ignored. */
    i        = 1;
    id       = 0;
    id_mask  = 0;
    id      |= match->gal_valid                        << i;
    id_mask |= match->gal_valid_mask                   << i;
    i++;
    id      |= match->el_valid                         << i;
    id_mask |= match->el_valid_mask                    << i;
    entry->tnl_mpls_control_pkt_id_2      = id;
    entry->tnl_mpls_control_pkt_id_2_mask = id_mask;

    i        = 0;
    id       = 0;
    id_mask  = 0;
    id      |= match->stat_enable                      << i;
    id_mask |= match->stat_enable_mask                 << i;
    i++;
    id      |= match->vccv_type                        << i;
    id_mask |= match->vccv_type_mask                   << i;
    i++;
    id      |= match->control_word_check               << i;
    id_mask |= match->control_word_check_mask          << i;
    entry->tnl_mpls_control_pkt_id_3      = id;
    entry->tnl_mpls_control_pkt_id_3_mask = id_mask;

    entry->tnl_mpls_control_pkt_id_4      = 0;
    entry->tnl_mpls_control_pkt_id_4_mask = 0;

    id       = match->control_word_ach_indicator;
    id_mask  = match->control_word_ach_indicator_mask;
    entry->tnl_mpls_control_pkt_id_5      = id;
    entry->tnl_mpls_control_pkt_id_5_mask = id_mask;

    return;
}

/*!
 * \brief Convert MPLS control packet action to TNL_MPLS_CONTROL_PKT entry.
 *
 * \param [in] unit                      Unit number.
 * \param [in] action                    MPLS control packet match.
 * \param [out] entry                    TNL_MPLS_CONTROL_PKT entry.
 *
 * \return Nothing.
 */
static void
ctrl_pkt_action_to_tnl_mpls_control_pkt_entry(
    int unit,
    bcm_mpls_control_pkt_action_t *action,
    lt_tnl_mpls_control_pkt_entry_t *entry)
{
    entry->drop               = action->drop;
    entry->copy_to_cpu        = action->copy_to_cpu;
    entry->seq_num_check      = action->seq_num_check;
    entry->control_packet      = action->control_packet;
    entry->control_packet_type = action->control_packet_type;

    return;
}

/*!
 * \brief Traverse callback for delete TNL_MPLS_CONTROL_PKT.
 *
 * \param [in] unit                      Unit number.
 * \param [in] match                     MPLS control packet match.
 * \param [in] action                    MPLS control packet match.
 * \param [out] user_data                User data.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
ctrl_pkt_delete_all_trav_cb(
    int unit,
    bcm_mpls_control_pkt_match_t *match,
    bcm_mpls_control_pkt_action_t *action,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_mpls_control_pkt_delete(unit, match));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all MPLS control packet entries and call user's callback.
 *
 * \param [in] unit                      Unit number.
 * \param [in] cb_err_abort              Abort if callback returns error.
 * \param [in] cb                        Callback function.
 * \param [out] user_data                User data.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
ctrl_pkt_traverse(
    int unit,
    int cb_err_abort,
    bcm_mpls_control_pkt_traverse_cb cb,
    void *user_data)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    int rv = SHR_E_NONE, rv1 = SHR_E_NONE;
    lt_tnl_mpls_control_pkt_entry_t entry;
    bcm_mpls_control_pkt_match_t match;
    bcm_mpls_control_pkt_action_t action;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_CONTROL_PKTs, &ent_hdl));

    rv = bcmi_lt_entry_commit(unit, ent_hdl, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);

    while (rv == SHR_E_NONE) {
        sal_memset(&entry, 0, sizeof(entry));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tnl_mpls_control_pkt_entry_key_from_hdl(unit, &entry, ent_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tnl_mpls_control_pkt_entry_field_from_hdl(unit, &entry,
                                                          ent_hdl));

        sal_memset(&match, 0, sizeof(match));
        sal_memset(&action, 0, sizeof(action));
        ctrl_pkt_match_from_tnl_mpls_control_pkt_entry(unit, &match, &entry);
        ctrl_pkt_action_from_tnl_mpls_control_pkt_entry(unit, &action, &entry);
        /* Traverse to next entry */
        rv = bcmi_lt_entry_commit(unit, ent_hdl, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        rv1 = cb(unit, &match, &action, user_data);
        if (SHR_FAILURE(rv1) && cb_err_abort) {
            SHR_IF_ERR_VERBOSE_EXIT(rv1);
        }
    }

    if ((rv != SHR_E_NOT_FOUND) && SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    MPLS_TNL_UNLOCK(unit);

    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash of egr_l3_tunnel_0 and egr_l3_tunnel_1 for MPLS view.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info of bcm_mpls_tunnel_encap_t type.
 * \param [out] hash      Hash value.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_l3_tnl_hash(int unit, void *entry, uint16_t *hash)
{
    lt_egr_l3_tnl_entry_t tnl_entry;

    SHR_FUNC_ENTER(unit);

    sal_memset(&tnl_entry, 0, sizeof(tnl_entry));
    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_encap_to_egr_l3_tnl_entry(unit,
                                       (bcm_mpls_tunnel_encap_t *)entry,
                                       &tnl_entry));

    *hash = shr_crc16(0, (uint8*)&tnl_entry, sizeof(tnl_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare egr_l3_tunnel_0 and egr_l3_tunnel_1 entries.
 *
 * \param [in] unit       Unit number.
 * \param [in] index      Index of entry to be compared.
 * \param [in] entry      Entry content of bcm_mpls_tunnel_encap_t type.
 * \param [out] result    Compare result. 0 if equal, 1 not equal.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_l3_tnl_cmp(int unit, int index, void *entry, int *result)
{
    lt_egr_l3_tnl_entry_t src_entry, dst_entry;
    int hdr_idx = 0;
    int num_labels;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_encap_to_egr_l3_tnl_entry(unit,
                                       (bcm_mpls_tunnel_encap_t *)entry,
                                       &src_entry));

    sal_memset(&dst_entry, 0, sizeof(dst_entry));
    dst_entry.tnl_idx = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_l3_tnl_op(unit, BCMLT_OPCODE_LOOKUP, &dst_entry));

    *result = 1;

    if (src_entry.edit_ctrl_id != dst_entry.edit_ctrl_id) {
        SHR_EXIT();
    }

    if (src_entry.mpls_push_bitmap != dst_entry.mpls_push_bitmap) {
        SHR_EXIT();
    }

    for (num_labels = 0; num_labels <= XFS_ENCAP_LABEL_CNT_MAX; num_labels++) {
        if (push_bitmap[num_labels] == dst_entry.mpls_push_bitmap) {
            break;
        }
    }

    for (hdr_idx = 0; hdr_idx < num_labels; num_labels++) {
        if (src_entry.mpls_hdr[hdr_idx] != dst_entry.mpls_hdr[hdr_idx]) {
            SHR_EXIT();
        }
    }

    *result = 0;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert egr_l3_tunnel_0 and egr_l3_tunnel_1 entry.
 *
 * \param [in] unit       Unit number.
 * \param [in] flags      Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index      Index of entry to be inserted.
 * \param [in] entry      Entry content of bcm_mpls_tunnel_encap_t type.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_l3_tnl_insert(int unit, uint32_t flags, int index, void *entry)
{
    lt_egr_l3_tnl_entry_t tnl_entry;
    bcmlt_opcode_t opcode = BCMLT_OPCODE_INSERT;

    SHR_FUNC_ENTER(unit);

    sal_memset(&tnl_entry, 0, sizeof(tnl_entry));
    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_encap_to_egr_l3_tnl_entry(unit,
                                       (bcm_mpls_tunnel_encap_t *)entry,
                                       &tnl_entry));
    tnl_entry.tnl_idx = index;

    if (flags & BCMI_LTSW_IDX_TBL_OP_REPLACE) {
        opcode = BCMLT_OPCODE_UPDATE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_l3_tnl_op(unit, opcode, &tnl_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete egr_l3_tunnel_0 and egr_l3_tunnel_1 entry.
 *
 * \param [in] unit       Unit number.
 * \param [in] index      Index of entry to be deleted.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_l3_tnl_delete(int unit, int index)
{
    lt_egr_l3_tnl_entry_t tnl_entry;

    SHR_FUNC_ENTER(unit);

    sal_memset(&tnl_entry, 0, sizeof(tnl_entry));
    tnl_entry.tnl_idx = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_l3_tnl_op(unit, BCMLT_OPCODE_DELETE, &tnl_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash of EGR_MPLS_VPN for MPLS view.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info of EGR_MPLS_VPN.
 * \param [out] hash      Hash value.
 *
 * \retval SHR_E_NONE     No errors.
 */
static int
lt_egr_mpls_vpn_hash(int unit, void *entry, uint16_t *hash)
{
    encap_label_info_t *label_info = (encap_label_info_t *)entry;

    *hash = shr_crc16(0, (uint8*)label_info, sizeof(encap_label_info_t));
    return SHR_E_NONE;
}

/*!
 * \brief Compare EGR_MPLS_VPN entries.
 *
 * \param [in] unit       Unit number.
 * \param [in] index      Index of entry to be compared.
 * \param [in] entry      Entry content of EGR_MPLS_VPN.
 * \param [out] result    Compare result. 0 if equal, 1 not equal.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_mpls_vpn_cmp(int unit, int index, void *entry, int *result)
{
    lt_egr_mpls_vpn_entry_t dst_entry;
    encap_label_info_t *label_info = (encap_label_info_t *)entry;
    uint32_t process_ctrl = 0;
    uint32_t mpls_hdr;
    int bos = 1;

    SHR_FUNC_ENTER(unit);

    sal_memset(&dst_entry, 0, sizeof(dst_entry));
    dst_entry.vpn_label_index = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_mpls_vpn_op(unit, BCMLT_OPCODE_LOOKUP, &dst_entry));

    *result = 1;

    if (dst_entry.view != VIEW_MPLS) {
        SHR_EXIT();
    }

    process_ctrl = label_info->proc_ctrl;
    if (label_info->proc_ctrl & EGR_LABL_CTRL_ENTROPY_LABL) {
       bos = 0;
    }

    if (process_ctrl != dst_entry.process_ctrl) {
        SHR_EXIT();
    }

    BUILD_MPLS_HDR(mpls_hdr,
                   label_info->vc_label, label_info->exp, bos, label_info->ttl);

    if (mpls_hdr != dst_entry.vpn_label_hdr) {
        SHR_EXIT();
    }

    *result = 0;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert EGR_MPLS_VPN entry.
 *
 * \param [in] unit       Unit number.
 * \param [in] flags      Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index      Index of entry to be inserted.
 * \param [in] entry      Entry content of bcm_mpls_tunnel_encap_t type.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_mpls_vpn_insert(int unit, uint32_t flags, int index, void *entry)
{
    lt_egr_mpls_vpn_entry_t vpn_entry;
    encap_label_info_t *label_info = (encap_label_info_t *)entry;
    bcmlt_opcode_t opcode = BCMLT_OPCODE_INSERT;
    int bos = 1;
    uint32_t mpls_hdr;

    SHR_FUNC_ENTER(unit);

    sal_memset(&vpn_entry, 0, sizeof(vpn_entry));
    vpn_entry.vpn_label_index = index;
    vpn_entry.view            = VIEW_MPLS;
    vpn_entry.process_ctrl    = label_info->proc_ctrl;
    if (label_info->proc_ctrl & EGR_LABL_CTRL_ENTROPY_LABL) {
       bos = 0;
    }

    BUILD_MPLS_HDR(mpls_hdr,
                   label_info->vc_label, label_info->exp, bos, label_info->ttl);
    vpn_entry.vpn_label_hdr  = mpls_hdr;

    if (flags & BCMI_LTSW_IDX_TBL_OP_REPLACE) {
        opcode = BCMLT_OPCODE_UPDATE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_mpls_vpn_op(unit, opcode, &vpn_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete EGR_MPLS_VPN entry.
 *
 * \param [in] unit       Unit number.
 * \param [in] index      Index of entry to be deleted.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_egr_mpls_vpn_delete(int unit, int index)
{
    lt_egr_mpls_vpn_entry_t vpn_entry;

    SHR_FUNC_ENTER(unit);

    sal_memset(&vpn_entry, 0, sizeof(vpn_entry));
    vpn_entry.vpn_label_index = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_mpls_vpn_op(unit, BCMLT_OPCODE_DELETE, &vpn_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the match key for the VP.
 *
 * \param [in] unit       Unit number.
 * \param [in] vp         VP ID.
 * \param [in] vp_info    VP information.
 *
 * \return Nothing.
 */
static void
mpls_vp_info_set(
    int unit, int vp, xfs_mpls_vp_info_t vp_info)
{
    xfs_mpls_info_t *xi = XFS_MPLS_INFO(unit);
    xi->vp_info[vp]   = vp_info;
    return;
}

/*!
 * \brief Get the match key for the VP.
 *
 * \param [in] uni        Unit number.
 * \param [in] vp         VP ID.
 * \param [in] vp_info    VP information.
 *
 * \return Nothing.
 */
static void
mpls_vp_info_get(int unit, int vp, xfs_mpls_vp_info_t *vp_info)
{
    xfs_mpls_info_t *xi = XFS_MPLS_INFO(unit);
    *vp_info          = xi->vp_info[vp];
    return;
}

/*!
 * \brief Validate the mpls port.
 *
 * \param [in] unit             Unit number.
 * \param [in] mpls_port_id     mpls port ID.
 *
 * \retval SHR_E_NONE           Mpls port is valid.
 * \retval !SHR_E_NONE          Mpls port is not valid.
 */
static int
mpls_port_validate(int unit, bcm_gport_t mpls_port_id)
{
    int vp_used = 0, vp = -1;
    uint32_t vp_start = 0, vp_end = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_range_get(unit, &vp_start, &vp_end));

    vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);
    if (vp == -1) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
        vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp);
    }

    if (vp < vp_start || vp > vp_end) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_BADID);
    }

    vp_used = !bcmi_ltsw_virtual_vp_used_get(unit, vp,
                                             BCMI_LTSW_VP_TYPE_MPLS);
    if (!vp_used) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Allocate a logic VP for the mpls port.
 *
 * \param [in] unit         Unit number.
 * \param [in] vpn          VPN ID.
 * \param [in] mpls_port    mpls port info.
 * \param [in] vp_id        VP ID.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
static int
mpls_port_vp_alloc(
    int unit, int vpn, bcm_mpls_port_t *mpls_port, int *vp_id)
{
    int vp_used = 0, vp = -1;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    uint32_t vp_start = 0, vp_end = 0;
    int vpless_vp = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_range_get(unit, &vp_start, &vp_end));

    if (mpls_port->flags & BCM_MPLS_PORT_REPLACE) {
        vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port->mpls_port_id);
        *vp_id = vp;
        SHR_EXIT();
    }

    /* Create case. */
    /* VPless case. */
    if (mpls_port->flags & BCM_MPLS_PORT_FAILOVER) {
        if (!(mpls_port->flags & BCM_MPLS_PORT_NETWORK)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port->failover_port_id);
        vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_SET(vp);
        *vp_id = vp;
        SHR_EXIT();
    }

    /* None vpless case. */
    if (mpls_port->flags & BCM_MPLS_PORT_WITH_ID) {
        vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port->mpls_port_id);
        if (vp == -1) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
            vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp);
            vpless_vp = 1;
        }

        if (vp < vp_start || vp > vp_end) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_BADID);
        }

        vp_used = !bcmi_ltsw_virtual_vp_used_get(unit, vp,
                                                 BCMI_LTSW_VP_TYPE_MPLS);
        if (vpless_vp) {
            if (!vp_used) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
            }
        } else {
            if (vp_used) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_EXISTS);
            }
        }

        bcmi_ltsw_virtual_vp_info_init(&vp_info);
        vp_info.flags |= BCMI_LTSW_VIRTUAL_VP_TYPE_MPLS;
        if (mpls_port->flags & BCM_MPLS_PORT_NETWORK) {
            vp_info.flags |= BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT;
        }
        vp_info.vpn = vpn;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vp_used_set(unit, vp, vp_info));
    } else {
        bcmi_ltsw_virtual_vp_info_init(&vp_info);
        vp_info.flags |= BCMI_LTSW_VIRTUAL_VP_TYPE_MPLS;
        if (mpls_port->flags & BCM_MPLS_PORT_NETWORK) {
            vp_info.flags |= BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT;
        }
        vp_info.vpn = vpn;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vp_alloc(unit, vp_start, (int)vp_end,
                                            1, vp_info, &vp));
    }
    *vp_id = vp;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the VC label index.
 *
 * \param [in] unit            Unit number.
 * \param [in] vp              VPN ID.
 * \param [in] vc_label_idx    vc label index.
 *
 * \retval SHR_E_NONE          No errors.
 * \retval !SHR_E_NONE         Failure.
 */
static int
mpls_port_vc_label_idx_get(int unit, int vp, int *vc_label_idx)
{
    lt_egr_dvp_entry_t egr_dvp_entry;

    SHR_FUNC_ENTER(unit);

    sal_memset(&egr_dvp_entry, 0, sizeof(egr_dvp_entry));
    egr_dvp_entry.dvp          = vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_dvp_op(unit, BCMLT_OPCODE_LOOKUP, &egr_dvp_entry));
    *vc_label_idx = egr_dvp_entry.vc_label_idx;

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Add ING_SVP_TABLE/ING_DVP_TABLE/EGR_DVP entry.
 *
 * \param [in] unit       Unit number.
 * \param [in] index      Index of entry to be added.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mpls_port_vp_add(
    int unit, int vpn, int vp, bcm_mpls_port_t *mpls_port,
    int vc_label_idx, int tnl_idx)
{
    lt_ing_svp_table_entry_t svp_entry;
    lt_ing_dvp_table_entry_t dvp_entry;
    lt_egr_dvp_entry_t egr_dvp_entry;
    bcmlt_opcode_t opcode;
    bcmi_ltsw_sbr_profile_tbl_hdl_t pth = BCMI_LTSW_SBR_PTH_COUNT;
    bcmi_ltsw_sbr_profile_ent_type_t ent_type = BCMI_LTSW_SBR_PET_COUNT;
    int profile_idx = 0;
    bcmi_ltsw_tunnel_encap_seq_profile_t entry;
    int seq_num_idx = -1, seq_num_cnt_idx = -1;
    int pipe;
    int l2_if = 0;
    uint32 value;
    bcm_l3_egress_t l3_egr_obj;
    bcm_port_t port_out;
    bcmi_ltsw_qos_map_type_t qos_type;

    SHR_FUNC_ENTER(unit);

    if (mpls_port->flags & BCM_MPLS_PORT_REPLACE) {
        opcode = BCMLT_OPCODE_UPDATE;
    } else {
        opcode = BCMLT_OPCODE_INSERT;
    }

    sal_memset(&svp_entry, 0, sizeof(svp_entry));
    svp_entry.vp = vp;
    svp_entry.vlan_tag_preserve_ctrl = BCMI_XFS_VLAN_TAG_PRESERVE_CTRL_DEF;
    if (mpls_port->flags2 & BCM_MPLS_PORT2_MULTICAST_GROUP_REMAP) {
        svp_entry.ipmc_remap_enable = 1;
    }

    if (mpls_port->flags & BCM_MPLS_PORT_NETWORK) {
        if (mpls_port->network_group_id) {
            svp_entry.nw_grp_bmp = 1 << mpls_port->network_group_id;
        }
    }  else {
        if (!(mpls_port->flags2 & BCM_MPLS_PORT2_QOS_NONE)) {
            if (mpls_port->dscp_map_id) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_qos_map_id_resolve(unit, mpls_port->dscp_map_id,
                                                  &qos_type,
                                                  (int *)&svp_entry.dscp_ptr));
                if (qos_type != bcmiQosMapTypeL3Ingress) {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }
            } else {
                if (!BCM_GPORT_IS_TRUNK(mpls_port->port)) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_port_tab_get(unit, mpls_port->port,
                                                BCMI_PT_DSCP_PHB,
                                                (int *)&svp_entry.dscp_ptr));
                }
            }

            if (mpls_port->vlan_pri_map_id) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_qos_map_id_resolve(unit,
                                                  mpls_port->vlan_pri_map_id,
                                                  &qos_type,
                                                 (int *)&svp_entry.dot1p_ptr));
                if (qos_type != bcmiQosMapTypeL2Ingress) {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }
            } else {
                if (!BCM_GPORT_IS_TRUNK(mpls_port->port)) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_port_tab_get(unit, mpls_port->port,
                                                BCMI_PT_VLAN_PHB,
                                                (int *)&svp_entry.dot1p_ptr));
                }
           }

           if (!BCM_GPORT_IS_TRUNK(mpls_port->port)) {
               SHR_IF_ERR_VERBOSE_EXIT
                   (bcmi_ltsw_port_tab_get(unit, mpls_port->port,
                                           BCMI_PT_DSCP_MAP_TO_PHB,
                                           (int *)&svp_entry.use_dscp));
           }
        }
        svp_entry.use_otag_dot1p_cfi = 1;
        svp_entry.use_itag_dot1p_cfi = 0;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_ing_svp_table_op(unit, opcode, &svp_entry));

    sal_memset(&dvp_entry, 0, sizeof(dvp_entry));
    dvp_entry.dvp = vp;
    if (opcode == BCMLT_OPCODE_INSERT) {
        pth = BCMI_LTSW_SBR_PTH_ING_DVP;
        ent_type = BCMI_LTSW_SBR_PET_NO_DESTINATION_NO_L2MC_L3MC_L2_OIF_SYS_DST_VALID;
        dvp_entry.no_cut_thru  = 1;
        if (!(mpls_port->flags & BCM_MPLS_PORT_NETWORK)) {
            ent_type = BCMI_LTSW_SBR_PET_NO_NO_CUT_THRU;
            dvp_entry.no_cut_thru  = 0;
        }
        SHR_IF_ERR_EXIT
            (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                                 &profile_idx));
        dvp_entry.str_prfl_idx = profile_idx;
    }

    if (!(mpls_port->flags & BCM_MPLS_PORT_NETWORK)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_to_l2_if(unit, mpls_port->port, &l2_if));
        dvp_entry.destination      = l2_if;
        dvp_entry.dst_bmp_valid    = DEST_TYPE_VALID_L2_OIF;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_ing_dvp_table_op(unit, opcode, &dvp_entry));

    sal_memset(&egr_dvp_entry, 0, sizeof(egr_dvp_entry));
    egr_dvp_entry.dvp          = vp;

    if (mpls_port->flags & BCM_MPLS_PORT_REPLACE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_egr_dvp_op(unit, opcode, &egr_dvp_entry));
    }

    if (mpls_port->flags & BCM_MPLS_PORT_NETWORK) {
        egr_dvp_entry.vc_label_idx = vc_label_idx;
        egr_dvp_entry.tunnel_idx_0 = tnl_idx;
        egr_dvp_entry.l2_mtu_value = mpls_port->mtu;

        if ((mpls_port->flags & BCM_MPLS_PORT_COUNTED) ||
            (mpls_port->flags & BCM_MPLS_PORT_SEQUENCED)) {
            if (egr_dvp_entry.seq_num_prof_idx == 0) {
                sal_memset(&entry, 0, sizeof(entry));
                entry.enable = 1;
                entry.update_en = 1;
                entry.increment = 1;
                entry.reserved_value = 0xFFFF0000;
                entry.mask = 0xFFFF0000;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_tunnel_encap_seq_profile_add(unit, &entry,
                                                                 &seq_num_idx));
                egr_dvp_entry.seq_num_prof_idx |= seq_num_idx;

                seq_num_cnt_idx = vp;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_tunnel_encap_seq_num_alloc(
                         unit, 0, ENCAP_SEQ_NUM_TYPE_VP, &seq_num_cnt_idx));
                bcm_l3_egress_t_init(&l3_egr_obj);
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_l3_egress_get(unit, mpls_port->encap_id,
                                            &l3_egr_obj));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_port_gport_validate(unit, l3_egr_obj.port,
                                                   &port_out));
                pipe = bcmi_ltsw_dev_logic_port_pp_pipe(unit, port_out);
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_tunnel_encap_seq_num_set(unit,
                                                        seq_num_cnt_idx,
                                                        pipe,
                                                     mpls_port->pw_seq_number));
                egr_dvp_entry.seq_num_cnt_idx |= seq_num_cnt_idx;
            }
        } else {
            if (egr_dvp_entry.seq_num_prof_idx != 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_tunnel_encap_seq_profile_delete(
                                         unit, egr_dvp_entry.seq_num_prof_idx));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_tunnel_encap_seq_num_free(unit,
                                                          ENCAP_SEQ_NUM_TYPE_VP,
                                                egr_dvp_entry.seq_num_cnt_idx));
            }
        }
        egr_dvp_entry.network_group_id = mpls_port->network_group_id;
    } else {
        /* Egr_vlan_translation_1 select for Access VP. */
        value = 1 << BCMI_XFS_VP_PROCESS_CTRL_EVXLT1_SELECT_SFT;
        egr_dvp_entry.process_ctrl = value;
    }

    pth = BCMI_LTSW_SBR_PTH_EGR_DVP;
    ent_type = BCMI_LTSW_SBR_PET_NO_CLASSID;
    if (mpls_port->egress_class_id != BCM_CLASS_ID_INVALID) {
        egr_dvp_entry.class_id     = mpls_port->egress_class_id;
        ent_type = BCMI_LTSW_SBR_PET_DEF;
    }
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                             &profile_idx));

    egr_dvp_entry.str_prfl_idx = profile_idx;

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_dvp_op(unit, opcode, &egr_dvp_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete ING_SVP_TABLE/ING_DVP_TABLE/EGR_DVP entry.
 *
 * \param [in] unit       Unit number.
 * \param [in] index      Index of entry to be deleted.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mpls_port_vp_delete(int unit, int vp)
{
    lt_ing_svp_table_entry_t svp_entry;
    lt_ing_dvp_table_entry_t dvp_entry;
    lt_egr_dvp_entry_t egr_dvp_entry;
    bcmlt_opcode_t opcode = BCMLT_OPCODE_DELETE;

    SHR_FUNC_ENTER(unit);

    if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
        vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp);
    }

    sal_memset(&svp_entry, 0, sizeof(svp_entry));
    svp_entry.vp = vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_ing_svp_table_op(unit, opcode, &svp_entry));

    sal_memset(&dvp_entry, 0, sizeof(dvp_entry));
    dvp_entry.dvp = vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_ing_dvp_table_op(unit, opcode, &dvp_entry));

    sal_memset(&egr_dvp_entry, 0, sizeof(egr_dvp_entry));
    egr_dvp_entry.dvp = vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_dvp_op(unit, opcode, &egr_dvp_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mpls port info from ING_SVP_TABLE/ING_DVP_TABLE/EGR_DVP entry.
 *
 * \param [in] unit         Unit number.
 * \param [in] vp           VP ID.
 * \param [in] mpls_port    mpls port info.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
static int
mpls_port_vp_get(
    int unit, int vp, bcm_mpls_port_t *mpls_port)
{
    lt_ing_svp_table_entry_t ing_svp_entry;
    lt_egr_dvp_entry_t egr_dvp_entry;
    lt_egr_mpls_vpn_entry_t vpn_entry;
    int i;
    int vpless_vp = 0;
    bcm_gport_t mpls_port_id;
    xfs_mpls_vp_info_t vp_info;
    bcmi_ltsw_virtual_vp_info_t virtual_vp_info;

    SHR_FUNC_ENTER(unit);

    if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
        vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp);
        vpless_vp = 1;
    }
    mpls_vp_info_get(unit, vp, &vp_info);

    if (vp_info.criteria == BCM_MPLS_PORT_MATCH_PORT) {
        SHR_EXIT();
    }

    sal_memset(&ing_svp_entry, 0, sizeof(ing_svp_entry));
    ing_svp_entry.vp = vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_ing_svp_table_op(unit, BCMLT_OPCODE_LOOKUP, &ing_svp_entry));
    i = 0;
    while (ing_svp_entry.nw_grp_bmp) {
        if (ing_svp_entry.nw_grp_bmp & (1 << i)) {
            break;
        }
        i++;
    }
    mpls_port->network_group_id = i;

    if (ing_svp_entry.ipmc_remap_enable) {
        mpls_port->flags2 |= BCM_MPLS_PORT2_MULTICAST_GROUP_REMAP;
    }

    if (ing_svp_entry.dscp_ptr) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_construct(unit, ing_svp_entry.dscp_ptr,
                                            bcmiQosMapTypeL3Ingress,
                                            &mpls_port->dscp_map_id));
    }

    if (ing_svp_entry.dot1p_ptr) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_construct(unit, ing_svp_entry.dot1p_ptr,
                                            bcmiQosMapTypeL2Ingress,
                                            &mpls_port->vlan_pri_map_id));
    }

    sal_memset(&egr_dvp_entry, 0, sizeof(egr_dvp_entry));
    egr_dvp_entry.dvp          = vp;

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_dvp_op(unit, BCMLT_OPCODE_LOOKUP, &egr_dvp_entry));
    mpls_port->egress_class_id = egr_dvp_entry.class_id;
    mpls_port->mtu             = egr_dvp_entry.l2_mtu_value;

    if ((vp_info.criteria == BCM_MPLS_PORT_MATCH_SHARE) ||
        (vp_info.criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_VLAN) ||
        (vp_info.criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_INNER_VLAN) ||
        (vp_info.criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_VLAN_STACKED)) {
        SHR_EXIT();
    }

    /* Network port properties. */
    sal_memset(&vpn_entry, 0, sizeof(lt_egr_mpls_vpn_entry_t));
    vpn_entry.vpn_label_index = egr_dvp_entry.vc_label_idx;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_mpls_vpn_op(unit, BCMLT_OPCODE_LOOKUP, &vpn_entry));
    mpls_port_from_egr_mpls_vpn_entry(unit, mpls_port, &vpn_entry);

    BCMI_LTSW_GPORT_TUNNEL_ID_SET(mpls_port->tunnel_id, bcmiTunnelTypeMpls,
                                  egr_dvp_entry.tunnel_idx_0);

    if (vpless_vp) {
        XFS_VPLESS_EGRESS_IF_GET(unit,
                                 BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp),
                                 mpls_port->encap_id);
        mpls_port->flags |= BCM_MPLS_PORT_FAILOVER;
        mpls_port->flags |= BCM_MPLS_PORT_NETWORK;
        BCM_GPORT_MPLS_PORT_ID_SET(mpls_port->failover_port_id,
                                   BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp));
    } else {
        BCM_GPORT_MPLS_PORT_ID_SET(mpls_port_id, vp);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                   mpls_port_id,
                                                   &(mpls_port->encap_id)));
        SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_info_get(unit, vp, &virtual_vp_info));
        if (virtual_vp_info.flags & BCMI_LTSW_VIRTUAL_VP_CASCADED) {
            mpls_port->flags2 |= BCM_MPLS_PORT2_ENCAP_CASCADED;
        }

        if (virtual_vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT) {
            mpls_port->flags |= BCM_MPLS_PORT_NETWORK;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate if the label matches with the port group.
 *
 * \param [in] unit          Unit number.
 * \param [in] label         mpls label.
 * \param [in] port_group    port group.
 *
 * \retval SHR_E_NONE       Matched.
 * \retval !SHR_E_CONFIG    Not matched.
 */
static int
mpls_label_range_validate(int unit, int label, int port_group)
{
    int  min_label_0, max_label_0, min_label_1, max_label_1;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_mpls_global_label_range_get(unit, 0,
                                              &min_label_0, &max_label_0));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_mpls_global_label_range_get(unit, 1,
                                              &min_label_1, &max_label_1));

    if (((label >= min_label_0) && (label <= max_label_0)) ||
        ((label >= min_label_1) && (label <= max_label_1)) ) {
        if (port_group == BCM_PORT_INVALID) {
            SHR_EXIT();
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_CONFIG);
        }
    } else {
        if (port_group == BCM_PORT_INVALID) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_CONFIG);
        } else {
            SHR_EXIT();
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add the match rue for the access mpls port.
 *
 * \param [in] unit          Unit number.
 * \param [in] vpn           VPN ID.
 * \param [in] mpls_port     mpls port information.
 * \param [in] vp            VP ID.
 *
 * \retval SHR_E_NONE        No errors.
 * \retval !SHR_E_NONE       Failure.
 */
static int
mpls_port_match_add_acc(
    int unit, int vpn, bcm_mpls_port_t *mpls_port, int vp)
{
    int l2_if;
    xfs_mpls_vp_info_t vp_info;
    bcm_vlan_translate_key_t key_type;
    bcm_gport_t port_group;
    bcm_vlan_t outer_vlan;
    bcm_vlan_t inner_vlan;
    bcmi_ltsw_vlan_ing_xlate_cfg_t cfg;
    uint32_t vfi = 0;
    bcm_mpls_port_match_t criteria;

    SHR_FUNC_ENTER(unit);

    sal_memset(&vp_info, 0, sizeof(xfs_mpls_vp_info_t));

    if (mpls_port->criteria == BCM_MPLS_PORT_MATCH_SHARE) {
        vp_info.criteria = BCM_MPLS_PORT_MATCH_SHARE;
        vp_info.vpn      = vpn;
        mpls_vp_info_set(unit, vp, vp_info);
        SHR_EXIT();
    }

    outer_vlan = mpls_port->match_vlan;
    inner_vlan = mpls_port->match_inner_vlan;
    sal_memset(&cfg, 0, sizeof(cfg));

    if (mpls_port->criteria == BCM_MPLS_PORT_MATCH_PORT) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_to_l2_if(unit, mpls_port->port, &l2_if));
        XFS_VP_2_L2IF_SET(unit, vp, l2_if);
        vp_info.port     = mpls_port->port;
        vp_info.criteria = mpls_port->criteria;
        vp_info.vpn      = vpn;

        mpls_vp_info_set(unit, vp, vp_info);
        SHR_EXIT();
    }

    criteria = mpls_port->criteria;
    if (criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_VLAN) {
        key_type = bcmVlanTranslateKeyPortGroupOuter;
    } else if (criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_INNER_VLAN) {
        key_type = bcmVlanTranslateKeyPortGroupInner;
    } else if (criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_VLAN_STACKED) {
        key_type = bcmVlanTranslateKeyPortGroupDouble;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    port_group         = mpls_port->port_group;
    cfg.fld_bmp |= BCMI_LTSW_VLAN_ING_XLATE_FLD_SVP;
    cfg.svp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port->mpls_port_id);
    if (BCMI_LTSW_VIRTUAL_VPN_IS_VPLS(vpn)) {
        BCMI_LTSW_VIRTUAL_VPN_GET(vfi, BCM_VPN_TYPE_MPLS_VPLS, vpn);
    }
    cfg.fld_bmp |= BCMI_LTSW_VLAN_ING_XLATE_FLD_VFI;
    cfg.vfi      = vfi;

    if (mpls_port->flags & BCM_MPLS_PORT_REPLACE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_vlan_ing_xlate_update(unit, key_type, port_group,
                                             outer_vlan, inner_vlan, &cfg));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_vlan_ing_xlate_add(unit, key_type, port_group,
                                          outer_vlan, inner_vlan, &cfg));
    }

    vp_info.port_group = mpls_port->port_group;
    vp_info.port       = mpls_port->port;
    vp_info.criteria   = mpls_port->criteria;
    vp_info.outer_vlan = mpls_port->match_vlan;
    vp_info.inner_vlan = mpls_port->match_inner_vlan;
    vp_info.vpn        = vpn;
    mpls_vp_info_set(unit, vp, vp_info);

exit:
    SHR_FUNC_EXIT();
}
/*!
 * \brief Replace vp value in mpls port id's match entry.
 *
 * \param [in] unit          Unit number.
 * \param [in] mpls_port     mpls port ID.
 * \param [in] new_vp        New VP.
 *
 * \retval SHR_E_NONE        No errors.
 * \retval !SHR_E_NONE       Failure.
 */
static int
mpls_port_match_vp_replace(
    int unit, bcm_gport_t mpls_port_id, int new_vp)
{
    int vpless_vp = 0;
    xfs_mpls_vp_info_t vp_info;
    int vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);
    lt_mpls_entry_t mpls_entry;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_validate(unit, mpls_port_id));

    sal_memset(&vp_info, 0, sizeof(xfs_mpls_vp_info_t));

    if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(new_vp)) {
        new_vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(new_vp);
    }

    if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
        vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp);
        vpless_vp = 1;
    }

    mpls_vp_info_get(unit, vp, &vp_info);

    if (vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL) {
        sal_memset(&mpls_entry, 0, sizeof(mpls_entry));
        mpls_entry.label   = vp_info.label;
        mpls_entry.svp     = new_vp;
        mpls_entry.fld_bmp = ME_FLD_SVP;

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_op(unit, BCMLT_OPCODE_UPDATE, &mpls_entry));
    } else if (vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
        sal_memset(&mpls_entry, 0, sizeof(mpls_entry));
        mpls_entry.label   = vp_info.label;
        mpls_entry.svp     = new_vp;
        mpls_entry.fld_bmp = ME_FLD_SVP;
        if (vpless_vp) {
            mpls_entry.label_conext_id = vp_info.vpless_port_group;
        } else {
            mpls_entry.label_conext_id = vp_info.port_group;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_op(unit, BCMLT_OPCODE_UPDATE, &mpls_entry));
    } else {
        
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_CONFIG);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get vp_lag VP in mpls port id's match entry.
 *
 * \param [in] unit          Unit number.
 * \param [in] mpls_port     mpls port ID.
 * \param [out] vp_lag_vp    vp_lag vp.
 *
 * \retval SHR_E_NONE        No errors.
 * \retval !SHR_E_NONE       Failure.
 */
static int
mpls_port_match_vplag_vp_get(
    int unit, bcm_gport_t mpls_port_id, int *vplag_vp)
{
    int vpless_vp = 0;
    xfs_mpls_vp_info_t vp_info;
    int vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);
    lt_mpls_entry_t mpls_entry;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_validate(unit, mpls_port_id));

    sal_memset(&vp_info, 0, sizeof(xfs_mpls_vp_info_t));

    if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
        vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp);
        vpless_vp = 1;
    }

    mpls_vp_info_get(unit, vp, &vp_info);

    if (vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL) {
        sal_memset(&mpls_entry, 0, sizeof(mpls_entry));
        mpls_entry.label   = vp_info.label;
        mpls_entry.fld_bmp = ME_FLD_SVP;

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_op(unit, BCMLT_OPCODE_LOOKUP, &mpls_entry));
    } else if (vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
        sal_memset(&mpls_entry, 0, sizeof(mpls_entry));
        mpls_entry.label   = vp_info.label;
        mpls_entry.fld_bmp = ME_FLD_SVP;
        if (vpless_vp) {
            mpls_entry.label_conext_id = vp_info.vpless_port_group;
        } else {
            mpls_entry.label_conext_id = vp_info.port_group;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_op(unit, BCMLT_OPCODE_LOOKUP, &mpls_entry));
    } else {
        
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_CONFIG);
    }

    if (vplag_vp) {
        if (bcmi_ltsw_virtual_vp_used_get(unit, mpls_entry.svp,
                                          BCMI_LTSW_VP_TYPE_VPLAG)) {
            SHR_ERR_EXIT(SHR_E_NOT_FOUND);
        }
        *vplag_vp = mpls_entry.svp;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add the match rue for the network mpls port.
 *
 * \param [in] unit          Unit number.
 * \param [in] vpn           VPN ID.
 * \param [in] mpls_port     mpls port information.
 * \param [in] vp            VP ID.
 *
 * \retval SHR_E_NONE        No errors.
 * \retval !SHR_E_NONE       Failure.
 */
static int
mpls_port_match_add_nw(
    int unit, int vpn, bcm_mpls_port_t *mpls_port, int vp)
{

    xfs_mpls_vp_info_t vp_info, fo_vp_info;
    lt_mpls_entry_t entry, old_entry, fo_entry;
    int add_new = 0, delete_old = 0, update = 0;
    int vpless_vp = 0;
    int old_pw_term_num = -1;
    int same_match;
    int rv;
    int failover_vp;
    bcm_gport_t fo_mpls_port_id;
    bcmi_ltsw_l3_egr_obj_info_t  egr_obj_info;

    SHR_FUNC_ENTER(unit);

    sal_memset(&vp_info, 0, sizeof(xfs_mpls_vp_info_t));

    if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
        vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp);
        vpless_vp = 1;
    }
    mpls_vp_info_get(unit, vp, &vp_info);

    if (!(mpls_port->flags & BCM_MPLS_PORT_FAILOVER)) {
        fo_mpls_port_id = mpls_port->failover_port_id;
        if (SHR_SUCCESS(mpls_port_validate(unit, fo_mpls_port_id))) {
            /* This is a primary port. */
            failover_vp = BCM_GPORT_MPLS_PORT_ID_GET(fo_mpls_port_id);
            mpls_vp_info_get(unit, failover_vp, &fo_vp_info);

            /*
             * When add the primary match, it needs to delete the LT entry and
             * keep the S/W info of the failover port.
             */
            if (mpls_port->criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
                if ((mpls_port->match_label == fo_vp_info.label) &&
                    (mpls_port->port_group == fo_vp_info.port_group)) {
                    sal_memset(&fo_entry, 0, sizeof(fo_entry));
                    fo_entry.label_conext_id = fo_vp_info.port_group;
                    fo_entry.label           = fo_vp_info.label;
                    SHR_IF_ERR_EXIT_EXCEPT_IF
                        (lt_mpls_entry_op(unit, BCMLT_OPCODE_DELETE, &fo_entry),
                         SHR_E_NOT_FOUND);
                }
            } else if (mpls_port->criteria == BCM_MPLS_PORT_MATCH_LABEL) {
                if (mpls_port->match_label == fo_vp_info.label) {
                    sal_memset(&fo_entry, 0, sizeof(fo_entry));
                    fo_entry.label           = fo_vp_info.label;
                    SHR_IF_ERR_EXIT_EXCEPT_IF
                        (lt_mpls_entry_op(unit, BCMLT_OPCODE_DELETE, &fo_entry),
                         SHR_E_NOT_FOUND);
                 }
            }
        } else {
            rv = bcmi_ltsw_l3_egress_obj_info_get(unit, mpls_port->encap_id,
                                                  &egr_obj_info);
            if (SHR_SUCCESS(rv) &&
                (egr_obj_info.flags & BCMI_LTSW_L3_EGR_OBJ_INFO_F_FAILOVER)) {
                /*
                 * This is a failover port.
                 * The encap ID is a failover egress object,
                 * then the port is a failover port.
                 */
                if (mpls_port->flags & BCM_MPLS_PORT_REPLACE) {
                    /* Replace the failover port. */
                    sal_memset(&entry, 0, sizeof(lt_mpls_entry_t));
                    entry.label_conext_id = vp_info.port_group;
                    entry.label           = vp_info.label;
                    entry.fld_bmp = ME_FLD_SVP;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (lt_mpls_entry_op(unit, BCMLT_OPCODE_LOOKUP,
                                          &entry));
                    if (entry.svp != vp) {
                        /*
                         * If the corresponding LT entry is present and
                         * used by the primary port, do not update the match.
                         */
                        SHR_EXIT();
                    }
                } else {
                    /* Add a failover port. */
                    sal_memset(&entry, 0, sizeof(lt_mpls_entry_t));
                    entry.label           = mpls_port->match_label;
                    if (mpls_port->criteria ==
                                         BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
                        entry.label_conext_id = mpls_port->port_group;
                    }

                    rv = lt_mpls_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry);
                    if (SHR_SUCCESS(rv)) {
                        /* Used by the primary port. */
                        vp_info.criteria = mpls_port->criteria;
                        vp_info.label    = mpls_port->match_label;
                        if (mpls_port->criteria ==
                                         BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
                            vp_info.port_group = mpls_port->port_group;
                        }
                        mpls_vp_info_set(unit, vp, vp_info);
                        SHR_EXIT();
                    }
                }
            }
        }
    }

    if (mpls_port->flags & BCM_MPLS_PORT_REPLACE) {
        sal_memset(&old_entry, 0, sizeof(old_entry));
        old_entry.label = vp_info.label;

        if (vpless_vp || vp_info.vpless) {
            if (vp_info.criteria != mpls_port->criteria) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }

            if (mpls_port->match_label != vp_info.label) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }

            if (mpls_port->criteria == BCM_MPLS_PORT_MATCH_LABEL) {
                SHR_EXIT();
            }

            if (mpls_port->criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
                if (vpless_vp && (mpls_port->port_group == vp_info.port_group)) {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }

                if (vp_info.vpless &&
                    (mpls_port->port_group == vp_info.vpless_port_group)) {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }
            }
        }

        if (vpless_vp) {
            old_entry.label_conext_id = vp_info.vpless_port_group;
        } else {
            old_entry.label_conext_id = vp_info.port_group;
        }

        same_match = 0;
        if (mpls_port->criteria == vp_info.criteria) {
            if (vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
                if ((mpls_port->match_label == old_entry.label) &&
                    (mpls_port->port_group == old_entry.label_conext_id)) {
                    same_match = 1;
                }
            } else if (vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL) {
                if (mpls_port->match_label == old_entry.label) {
                    same_match = 1;
                }
            }
        }

        if (same_match) {
            update = 1;
        } else {
            delete_old = 1;
            add_new    = 1;
        }

        old_entry.fld_bmp = ME_MPLS_PORT_FLD_BMP;
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_op(unit, BCMLT_OPCODE_LOOKUP, &old_entry));
    } else { /* Create. */
        if (vpless_vp) {
            if (vp_info.criteria != mpls_port->criteria) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }

            if (mpls_port->match_label != vp_info.label) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }

            if (mpls_port->criteria == BCM_MPLS_PORT_MATCH_LABEL) {
                SHR_EXIT();
            }

            if (mpls_port->criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
                if (mpls_port->port_group == vp_info.port_group) {
                    vp_info.vpless_port_group = mpls_port->port_group;
                    mpls_vp_info_set(unit, vp, vp_info);
                    SHR_EXIT();
                }
            }
        }
        add_new = 1;
    }

    if ((delete_old || update) && old_entry.pw_term_num_valid) {
        old_pw_term_num = old_entry.pw_term_num;
    }

    sal_memset(&entry, 0, sizeof(lt_mpls_entry_t));
    mpls_port_to_mpls_entry(unit, vpn, vp, mpls_port, &entry, old_pw_term_num);

    if (update) {
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_op(unit, BCMLT_OPCODE_UPDATE, &entry));
    } else if (add_new) {
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_op(unit, BCMLT_OPCODE_INSERT, &entry));
    }

    if (delete_old) {
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_op(unit, BCMLT_OPCODE_DELETE, &old_entry));
        if (old_entry.pw_term_num_valid)
            if (!(mpls_port->flags & BCM_MPLS_PORT_SEQUENCED) &&
                !(mpls_port->flags & BCM_MPLS_PORT_COUNTED)) {
            /* Clear the counter if used by the MPLS port. */
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_pw_term_counter_destroy(unit, entry.pw_term_num));
        }
    }

    if (mpls_port->criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
        if (vpless_vp) {
            vp_info.vpless_port_group = mpls_port->port_group;
        } else {
            vp_info.port_group = mpls_port->port_group;
        }
    }
    vp_info.label    = mpls_port->match_label;
    vp_info.criteria = mpls_port->criteria;
    vp_info.vpn      = vpn;

    if (mpls_port->flags & BCM_MPLS_PORT_FAILOVER) {
        vp_info.vpless = 1;
    } else {
        rv = mpls_port_validate(unit, mpls_port->failover_port_id);
        if (SHR_SUCCESS(rv)) {
            vp_info.failover_vp =
                        BCM_GPORT_MPLS_PORT_ID_GET(mpls_port->failover_port_id);
        }
    }

    mpls_vp_info_set(unit, vp, vp_info);

exit:
    if (SHR_FUNC_ERR()) {
        if ((old_pw_term_num == -1) && (entry.pw_term_num_valid == 1)) {
            /* clean-up newly created TNL_PW_DECAP entry */
           (void)xfs_pw_term_counter_destroy(unit, entry.pw_term_num);
        }
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add the match rue for the mpls port.
 *
 * \param [in] unit          Unit number.
 * \param [in] vpn           VPN ID.
 * \param [in] mpls_port     mpls port information.
 * \param [in] vp            VP ID.
 *
 * \retval SHR_E_NONE        No errors.
 * \retval !SHR_E_NONE       Failure.
 */
static int
mpls_port_match_add(
    int unit, int vpn, bcm_mpls_port_t *mpls_port, int vp)
{
    SHR_FUNC_ENTER(unit);

    if (mpls_port->flags & BCM_MPLS_PORT_NETWORK) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_port_match_add_nw(unit, vpn, mpls_port, vp));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_port_match_add_acc(unit, vpn, mpls_port, vp));
    }

exit:
    SHR_FUNC_EXIT();
}
/*!
 * \brief Delete the match rue for the VP.
 *
 * \param [in] unit       Unit number.
 * \param [in] vp         VP ID.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mpls_port_match_delete(int unit, int vp)
{
    int l2_if;
    xfs_mpls_vp_info_t vp_info;
    lt_mpls_entry_t entry;
    int vpless_vp = 0;
    bcm_mpls_port_match_t criteria;
    bcm_vlan_translate_key_t key_type;
    int rv;

    SHR_FUNC_ENTER(unit);

    if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
        vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp);
        vpless_vp = 1;
    }

    sal_memset(&vp_info, 0, sizeof(xfs_mpls_vp_info_t));
    mpls_vp_info_get(unit, vp, &vp_info);

    if (vp_info.match_count > 0) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_BUSY);
    }

    if (vp_info.criteria == BCM_MPLS_PORT_MATCH_SHARE) {
        SHR_EXIT();
    }

    criteria = vp_info.criteria;
    if (vpless_vp) {
        if ((criteria == BCM_MPLS_PORT_MATCH_LABEL) ||
            ((criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) &&
             (vp_info.port_group == vp_info.vpless_port_group))) {
            vp_info.vpless = 0;
            vp_info.vpless_egress_if = 0;
            vp_info.vpless_port = 0;
            vp_info.vpless_port_group = 0;
            mpls_vp_info_set(unit, vp, vp_info);
            SHR_EXIT();
        }
    }

    if (criteria == BCM_MPLS_PORT_MATCH_PORT) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_to_l2_if(unit, vp_info.port, &l2_if));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_set(unit, l2_if, BCMI_PT_L2_DEST_TYPE,
                                        DEST_TYPE_NO_OP));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_set(unit, l2_if, BCMI_PT_L2_DEST, 0));
        XFS_VP_2_L2IF_SET(unit, vp, 0);
        sal_memset(&vp_info, 0, sizeof(xfs_mpls_vp_info_t));
        mpls_vp_info_set(unit, vp, vp_info);
        SHR_EXIT();
    }

    if ((vp_info.criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_VLAN) ||
        (vp_info.criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_INNER_VLAN) ||
        (vp_info.criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_VLAN_STACKED)) {

        key_type = bcmVlanTranslateKeyPortGroupOuter;
        if (criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_INNER_VLAN) {
            key_type = bcmVlanTranslateKeyPortGroupInner;
        } else if (criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_VLAN_STACKED) {
            key_type = bcmVlanTranslateKeyPortGroupDouble;
        }

        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_ltsw_vlan_ing_xlate_delete(unit, key_type,
                                                vp_info.port_group,
                                                vp_info.outer_vlan,
                                                vp_info.inner_vlan));
        sal_memset(&vp_info, 0, sizeof(xfs_mpls_vp_info_t));
        mpls_vp_info_set(unit, vp, vp_info);
        SHR_EXIT();
    }

    if ((vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL) ||
        (vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP)) {
        sal_memset(&entry, 0, sizeof(lt_mpls_entry_t));
        entry.label = vp_info.label;
        if (vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
            entry.label_conext_id = vp_info.port_group;  /* Port group. */
            if (vpless_vp) {
                entry.label_conext_id = vp_info.vpless_port_group;
            }
        }

        entry.fld_bmp |= ME_FLD_PW_TERM_NUM_VALID;
        entry.fld_bmp |= ME_FLD_SVP;
        rv = lt_mpls_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry);
        if (SHR_SUCCESS(rv) && (entry.svp == vp)) {
            /* Clear the counter if used by the MPLS port. */
            if (entry.pw_term_num_valid) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (xfs_pw_term_counter_destroy(unit, entry.pw_term_num));
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (lt_mpls_entry_op(unit, BCMLT_OPCODE_DELETE, &entry));
        }

        if (vpless_vp) {
            vp_info.vpless = 0;
            vp_info.vpless_egress_if = 0;
            vp_info.vpless_port = 0;
            vp_info.vpless_port_group = 0;
            mpls_vp_info_set(unit, vp, vp_info);
        } else {
            sal_memset(&vp_info, 0, sizeof(xfs_mpls_vp_info_t));
        }
        mpls_vp_info_set(unit, vp, vp_info);
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
mpls_port_match_param_validate(
    int unit,
    bcm_gport_t mpls_port_id,
    bcmi_ltsw_mpls_port_match_t *match)
{
    int vp;
    xfs_mpls_vp_info_t  vp_info;

    SHR_FUNC_ENTER(unit);

    if ((match->criteria != bcmiLtswMplsPortMatchPortGrpVlan) &&
        (match->criteria != bcmiLtswMplsPortMatchPortGrpInnerVlan) &&
        (match->criteria != bcmiLtswMplsPortMatchPortGrpVlanStacked)){
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if(!BCMI_LTSW_VIRTUAL_VPN_IS_VPLS(match->vpn)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_validate(unit, mpls_port_id));

    vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);
    mpls_vp_info_get(unit, vp, &vp_info);
    if (vp_info.criteria != BCM_MPLS_PORT_MATCH_SHARE) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT()
}

static void
mpls_port_match_criteria_to_vlan_xlate_key_type(
    int unit,
    bcmi_ltsw_mpls_port_match_criteria_t criteria,
    bcm_vlan_translate_key_t *key_type)
{
    if (criteria == bcmiLtswMplsPortMatchPortGrpVlan) {
        *key_type = bcmVlanTranslateKeyPortGroupOuter;
    } else if (criteria == bcmiLtswMplsPortMatchPortGrpInnerVlan) {
        *key_type = bcmVlanTranslateKeyPortGroupInner;
    } else if (criteria == bcmiLtswMplsPortMatchPortGrpVlanStacked) {
        *key_type = bcmVlanTranslateKeyPortGroupDouble;
    }

    return;
}

/*!
 * \brief ING_VXLATE talbes traverse Callback for deleting all entries added
 *        via bcm_port_match_add.
 *
 * \param [in] unit              Unit number.
 * \param [in] key_type          Key Type - bcmVlanTranslateKey*.
 * \param [in] port              Port group.
 * \param [in] outer_vlan        Outer VLAN ID.
 * \param [in] inner_vlan        Inner VLAN ID.
 * \param [in] cfg               Ingress xlate configuration.
 * \param [in] user_data         User data to a call back.
 *
 * \retval SHR_E_NONE            No errors.
 * \retval !SHR_E_NONE           Failure.
 */
static int
mpls_port_match_delete_all_trav_cb(
    int unit,
    bcm_vlan_translate_key_t key_type,
    bcm_gport_t port,
    bcm_vlan_t outer_vlan,
    bcm_vlan_t inner_vlan,
    bcmi_ltsw_vlan_ing_xlate_cfg_t *cfg,
    void *user_data)
{
    int vp_used;
    xfs_mpls_vp_info_t vp_info;

    SHR_FUNC_ENTER(unit);

    if (cfg->svp == 0) {
        SHR_EXIT();
    }

    if (cfg->vfi == 0) {
        SHR_EXIT();
    }

    if (!bcmi_ltsw_virtual_vfi_used_get(unit, cfg->vfi,
                                        BCMI_LTSW_VFI_TYPE_MPLS)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    }

    vp_used = !bcmi_ltsw_virtual_vp_used_get(unit, cfg->svp,
                                             BCMI_LTSW_VP_TYPE_MPLS);
    if (!vp_used) {
        SHR_EXIT();
    }

    mpls_vp_info_get(unit, cfg->svp, &vp_info);
    if (vp_info.criteria != BCM_MPLS_PORT_MATCH_SHARE) {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
       (bcmi_ltsw_vlan_ing_xlate_delete(unit, key_type, port,
                                        outer_vlan, inner_vlan));
    MATCH_COUNT_UPDATE(unit, cfg->svp, -1);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief ING_VXLATE talbes traverse Callback for getting all entries added
 *        via bcm_port_match_add.
 *
 * \param [in] unit              Unit number.
 * \param [in] key_type          Key Type - bcmVlanTranslateKey*.
 * \param [in] port              Port group.
 * \param [in] outer_vlan        Outer VLAN ID.
 * \param [in] inner_vlan        Inner VLAN ID.
 * \param [in] cfg               Ingress xlate configuration.
 * \param [in] user_data         User data to a call back.
 *
 * \retval SHR_E_NONE            No errors.
 * \retval !SHR_E_NONE           Failure.
 */
static int
mpls_port_match_multi_get_trav_cb(int unit, bcm_vlan_translate_key_t key_type,
                             bcm_gport_t port,  bcm_vlan_t outer_vlan,
                             bcm_vlan_t inner_vlan,
                             bcmi_ltsw_vlan_ing_xlate_cfg_t *cfg,
                             void *user_data)
{
    mpls_port_match_ivxlate_user_data_t *ud;
    bcmi_ltsw_mpls_port_match_t match;
    int i;

    SHR_FUNC_ENTER(unit);

    ud = (mpls_port_match_ivxlate_user_data_t *)user_data;

    if (ud->match_vp != cfg->svp) {
        SHR_EXIT();
    }

    if (ud->size > 0) {
        if (ud->count >= ud->size) {
            SHR_EXIT();
        }
        i = ud->count;
        match.match_vlan = 0;
        match.match_inner_vlan = 0;
        if (key_type == bcmVlanTranslateKeyPortGroupOuter) {
            match.criteria   = bcmiLtswMplsPortMatchPortGrpVlan;
            match.match_vlan = outer_vlan;
        } else if (key_type == bcmVlanTranslateKeyPortGroupInner) {
            match.criteria = bcmiLtswMplsPortMatchPortGrpInnerVlan;
            match.match_inner_vlan = inner_vlan;
        } else if (key_type == bcmVlanTranslateKeyPortGroupDouble) {
            match.criteria = bcmiLtswMplsPortMatchPortGrpVlanStacked;
            match.match_vlan       = outer_vlan;
            match.match_inner_vlan = inner_vlan;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        ud->array[i].criteria         = match.criteria;
        ud->array[i].match_vlan       = match.match_vlan;
        ud->array[i].match_inner_vlan = match.match_inner_vlan;
        ud->array[i].port_group       = port;
        ud->array[i].action.outer_tag = cfg->otag_action;
        ud->array[i].action.inner_tag = cfg->itag_action;
        BCMI_LTSW_VIRTUAL_VPN_SET(ud->array[i].vpn,
                                  BCM_VPN_TYPE_MPLS_VPLS, cfg->vfi);
        ud->count++;
    } else {
        ud->count++;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the match rue for the mpls port.
 *
 * \param [in] unit             Unit number.
 * \param [in] vp               VP ID.
 * \param [in] mpls_port        mpls port information.
 * \param [in] match_added      Match rule is added.
 *
 * \retval SHR_E_NONE           No errors.
 * \retval !SHR_E_NONE          Failure.
 */
static int
mpls_port_match_get(
    int unit, int vp, bcm_mpls_port_t *mpls_port)
{
    xfs_mpls_vp_info_t vp_info;
    lt_mpls_entry_t entry;
    int vpless_vp = 0;
    bcm_gport_t  fo_port_id;

    SHR_FUNC_ENTER(unit);

    if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
        vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp);
        vpless_vp = 1;
    }

    sal_memset(&vp_info, 0, sizeof(xfs_mpls_vp_info_t));
    mpls_vp_info_get(unit, vp, &vp_info);

    mpls_port->criteria = vp_info.criteria;

    if (vpless_vp) {
        BCM_GPORT_MPLS_PORT_ID_SET(fo_port_id, vp);
    } else {
        BCM_GPORT_MPLS_PORT_ID_SET(fo_port_id, vp_info.failover_vp);
        if (SHR_SUCCESS(mpls_port_validate(unit, fo_port_id))) {
            mpls_port->failover_port_id = fo_port_id;
        }
    }

    if ((vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL) ||
        (vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP)) {

        sal_memset(&entry, 0, sizeof(lt_mpls_entry_t));
        entry.label = vp_info.label;
        if (vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
            if (vpless_vp) {
                entry.label_conext_id = vp_info.vpless_port_group;
            } else {
                entry.label_conext_id = vp_info.port_group;
            }
        }
        entry.fld_bmp = ME_MPLS_PORT_FLD_BMP;

        if (SHR_SUCCESS(lt_mpls_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry))) {
            mpls_port_from_mpls_entry(unit, vp, mpls_port, &entry);
        }
    } else if (vp_info.criteria == BCM_MPLS_PORT_MATCH_PORT) {
        mpls_port->port = vp_info.port;
    } else if (vp_info.criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_VLAN) {
        mpls_port->match_vlan       = vp_info.outer_vlan;
        mpls_port->port_group       = vp_info.port_group;
        mpls_port->port             = vp_info.port;
    } else if (vp_info.criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_INNER_VLAN) {
        mpls_port->match_inner_vlan = vp_info.inner_vlan;
        mpls_port->port_group       = vp_info.port_group;
        mpls_port->port             = vp_info.port;
    } else if (vp_info.criteria == BCM_MPLS_PORT_MATCH_PORT_GROUP_VLAN_STACKED) {
        mpls_port->match_vlan       = vp_info.outer_vlan;
        mpls_port->match_inner_vlan = vp_info.inner_vlan;
        mpls_port->port_group       = vp_info.port_group;
        mpls_port->port             = vp_info.port;
    } else if (vp_info.criteria != BCM_MPLS_PORT_MATCH_SHARE) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the mpls port matches the VPLESS condition.
 *
 * \param [in] unit             Unit number.
 * \param [in] vpn              VPN ID.
 * \param [in] mpls_port_id     mpls port ID.
 *
 * \retval SHR_E_NONE           Mpls port matches the VPLESS condition.
 * \retval !SHR_E_NONE          Mpls port does not match the VPLESS condition.
 */
static int
mpls_port_vpless_validate(
    int unit, bcm_vpn_t vpn, bcm_mpls_port_t *mpls_port)
{
    bcm_mpls_port_t fo_mpls_port;
    int not_same_label = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_validate(unit, mpls_port->failover_port_id));

    bcm_mpls_port_t_init(&fo_mpls_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_mpls_port_get(unit, vpn,
                                mpls_port->failover_port_id,
                                &fo_mpls_port));

    if (mpls_port->egress_label.label != fo_mpls_port.egress_label.label) {
        not_same_label = 1;
    }
    if (not_same_label||
        (mpls_port->tunnel_id != fo_mpls_port.tunnel_id) ||
        (mpls_port->egress_class_id != fo_mpls_port.egress_class_id) ||
        (mpls_port->network_group_id != fo_mpls_port.network_group_id)) {
        
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate mpls port parameters.
 *
 * \param [in] unit          Unit number.
 * \param [in] mpls_port     mpls port information.
 *
 * \retval SHR_E_NONE        No errors.
 * \retval !SHR_E_NONE       Failure.
 */
static int
mpls_port_param_validate(
    int unit, bcm_vpn_t vpn, bcm_mpls_port_t *mpls_port)
{
    bcm_gport_t  mpls_port_id;
    bcm_mpls_port_match_t criteria = mpls_port->criteria;
    int rv;
    bcm_gport_t fo_mpls_port_id;
    int encap_id, fo_encap_id;
    bcmi_ltsw_l3_egr_obj_info_t  egr_obj_info;
    lt_mpls_entry_t entry;
    xfs_mpls_vp_info_t vp_info;
    int vp;

    SHR_FUNC_ENTER(unit);

    mpls_port_id = mpls_port->mpls_port_id;
    if (mpls_port->flags & BCM_MPLS_PORT_NETWORK) {
        if ((criteria != BCM_MPLS_PORT_MATCH_LABEL) &&
            (criteria != BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        if (mpls_port->egress_label.label > MPLS_LABEL_MAX) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    } else {
        if (BCMI_LTSW_VIRTUAL_VPN_IS_VPWS(vpn)) {
            /* VPWS supports only PORT-based ports. */
            if (criteria != BCM_MPLS_PORT_MATCH_PORT) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        } else {
            /*
             * VPLS does not support BCM_MPLS_PORT_MATCH_PORT access port.
             * Use physical port for VPLS PORT-based access port
             * as the resources for the access port same as the physical port.
             */
            if ((criteria != BCM_MPLS_PORT_MATCH_SHARE) &&
                (criteria != BCM_MPLS_PORT_MATCH_PORT_GROUP_VLAN) &&
                (criteria != BCM_MPLS_PORT_MATCH_PORT_GROUP_INNER_VLAN) &&
                (criteria != BCM_MPLS_PORT_MATCH_PORT_GROUP_VLAN_STACKED)){
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        }
    }

    if (criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
        if (mpls_port->port_group == 0) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

    if (mpls_port->flags & BCM_MPLS_PORT_REPLACE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_port_validate(unit, mpls_port_id));
    } else {
        if (mpls_port->flags & BCM_MPLS_PORT_FAILOVER) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mpls_port_validate(unit, mpls_port->failover_port_id));
        }
    }

    if ((mpls_port->flags & BCM_MPLS_PORT_FAILOVER) &&
        (mpls_port->flags2 & BCM_MPLS_PORT2_ENCAP_CASCADED)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if ((mpls_port->flags & BCM_MPLS_PORT_CONTROL_WORD) &&
        (mpls_port->flags & BCM_MPLS_PORT_SEQUENCED)) {
        return BCM_E_PARAM;
    }

    if (mpls_port->criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_label_range_validate(unit, mpls_port->match_label,
                                       mpls_port->port_group));
    }

    if ((mpls_port->flags & BCM_MPLS_PORT_NETWORK) &&
        !(mpls_port->flags & BCM_MPLS_PORT_FAILOVER)) {
        fo_mpls_port_id = mpls_port->failover_port_id;
        /* This is a primary port. */
        if (SHR_SUCCESS(mpls_port_validate(unit, fo_mpls_port_id))) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                       fo_mpls_port_id,
                                                       &(fo_encap_id)));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_failover_validate(unit, mpls_port->encap_id,
                                             fo_encap_id));
        } else {
            rv = bcmi_ltsw_l3_egress_obj_info_get(unit, mpls_port->encap_id,
                                                  &egr_obj_info);
            if (SHR_SUCCESS(rv) &&
                (egr_obj_info.flags & BCMI_LTSW_L3_EGR_OBJ_INFO_F_FAILOVER)) {
                /*
                 * This is a failover port.
                 * The encap ID is a failover egress object,
                 * then the port is a failover port.
                 */
                if (mpls_port->flags & BCM_MPLS_PORT_REPLACE) {
                    sal_memset(&entry, 0, sizeof(lt_mpls_entry_t));
                    vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port->mpls_port_id);
                    mpls_vp_info_get(unit, vp, &vp_info);

                    entry.fld_bmp = ME_FLD_SVP;
                    entry.label_conext_id = vp_info.port_group;
                    entry.label           = vp_info.label;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (lt_mpls_entry_op(unit, BCMLT_OPCODE_LOOKUP,
                                          &entry));
                    /*
                     * If the corresponding LT entry is used by the primary port.
                     * Do not allow to change the match.
                     */
                    if (entry.svp != vp) {
                        BCM_GPORT_MPLS_PORT_ID_SET(mpls_port_id, entry.svp);
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                                   mpls_port_id,
                                                                  &(encap_id)));
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_failover_validate(unit, encap_id,
                                                         mpls_port->encap_id));

                        if (mpls_port->criteria != vp_info.criteria) {
                            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                        }

                        if (mpls_port->match_label != vp_info.label) {
                            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                        }

                        if (mpls_port->criteria ==
                                         BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
                            if (mpls_port->port_group != vp_info.port_group) {
                                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                            }
                        }
                    }
                }
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable/disable the connection between the acc port and primary port.
 *
 * \param [in] unit            Unit number.
 * \param [in] src_port_id     Source port ID.
 * \param [in] dst_port_id     Destination port ID.
 * \param [in] enable          Enable indicator.
 *
 * \retval SHR_E_NONE          No errors.
 * \retval !SHR_E_NONE         Failure.
 */
static int
mpls_port_connection_enable(
    int unit, bcm_gport_t src_port_id, bcm_gport_t dst_port_id, int enable)
{
    xfs_mpls_vp_info_t src_key, dst_key;
    int  src_vp = 0, dst_vp = 0, vpless_vp = 0;
    lt_mpls_entry_t mpls_entry;
    uint32_t l2_if;
    bcm_if_t egr_if;
    int nh_idx, ecmp_prot_mode;
    bcmi_ltsw_l3_egr_obj_type_t type;
    bcmi_ltsw_port_tab_t fld_type;
    int dest_type, destination;
    bcmi_ltsw_virtual_vp_info_t vp_info;

    SHR_FUNC_ENTER(unit);

    sal_memset(&src_key, 0, sizeof(dst_key));
    if (src_port_id != BCM_GPORT_INVALID) {
        src_vp = BCM_GPORT_MPLS_PORT_ID_GET(src_port_id);
        if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(src_vp)) {
            src_vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(src_vp);
            vpless_vp = 1;
        }
        mpls_vp_info_get(unit, src_vp, &src_key);
    }

    sal_memset(&dst_key, 0, sizeof(dst_key));
    if (dst_port_id != BCM_GPORT_INVALID) {
        dst_vp = BCM_GPORT_MPLS_PORT_ID_GET(dst_port_id);
        if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(dst_vp)) {
            dst_vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(dst_vp);
            vpless_vp = 1;
        }
        mpls_vp_info_get(unit, dst_vp, &dst_key);
    }

    if (src_key.criteria == BCM_MPLS_PORT_MATCH_PORT) {
        dest_type   = DEST_TYPE_VP;
        destination = dst_vp;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vp_info_get(unit, dst_vp, &vp_info));
        if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT)) {
            dest_type   = DEST_TYPE_L2_OIF;
            destination = XFS_VP_2_L2IF(unit, dst_vp);
        }
        l2_if = XFS_VP_2_L2IF(unit, src_vp);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_set(unit, l2_if,
                                        BCMI_PT_L2_DEST_TYPE,
                                        enable ? dest_type : 0));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_set(unit, l2_if,
                                        BCMI_PT_L2_DEST,
                                        enable ? destination : 0));
        if (enable) {
        /* When disabled, user needs to restore the fields via PORT APIs. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_tab_raw_set(unit, l2_if,
                                            BCMI_PT_DEFAULT_VFI, 0));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_tab_raw_set(unit, l2_if,
                                            BCMI_PT_VLAN_MAP_TO_VFI, 0));
        }

        if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT)) {
            SHR_EXIT();
        }

        if (enable) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                       dst_port_id, &egr_if));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_egress_obj_id_resolve(unit, egr_if, &nh_idx,
                                                    &type));
            if (type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
                ecmp_prot_mode = NH_AND_PROT_UL;
            } else if (type == BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL) {
                ecmp_prot_mode = ECMP_AND_NO_PROT;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        } else {
            nh_idx = 0;
            ecmp_prot_mode = 0;
        }
        fld_type = BCMI_PT_NHOP_2_OR_ECMP_GROUP_INDEX_1;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_set(unit, l2_if, fld_type, nh_idx));

        fld_type = BCMI_PT_ECMP_AND_PROT_SWT_SFC_PROFILE_INDEX;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_set(unit, l2_if, fld_type, ecmp_prot_mode));
    }

    if ((src_key.criteria == BCM_MPLS_PORT_MATCH_LABEL) ||
        (src_key.criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP)) {
        sal_memset(&mpls_entry, 0, sizeof(mpls_entry));
        mpls_entry.label = src_key.label;

        if (src_key.criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) {
            if (vpless_vp) {
                mpls_entry.label_conext_id = src_key.vpless_port_group;
            } else {
                mpls_entry.label_conext_id = src_key.port_group;
            }
        }
        mpls_entry.fld_bmp = ME_FLD_DEST;
        if (enable) {
            mpls_entry.dest = XFS_VP_2_L2IF(unit, dst_vp);
            mpls_entry.dest_type = BCMI_XFS_DEST_TYPE_L2_OIF;
        } else {
            mpls_entry.dest = 0;
            mpls_entry.dest_type = BCMI_XFS_DEST_TYPE_NO_OP;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_op(unit, BCMLT_OPCODE_UPDATE, &mpls_entry));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Move the special label entries between 'from' and 'to' - 1.
 *        Move the target entries down by one entry if from < to.
 *        Move the target entries up by one entry if from > to.
 *
 * \param [in] unit         Unit number.
 * \param [in] from         Start entries to be moved.
 * \param [in] to           Start entry which moved to.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
int
tnl_mpls_special_label_entries_move(int unit, int from, int to)
{
    int i = 0;
    uint32 total_moves = 0;
    lt_tnl_mpls_special_label_entry_t entry;
    int src_slot  = 0, dst_slot = 0;

    xfs_mpls_special_label_control_t *lbl_ctrl = XFS_SPECIAL_LABEL_CTRL(unit);

    SHR_FUNC_ENTER(unit);

    if ((from == -1) || (to == -1)) {
        SHR_EXIT();
    }

    total_moves = ((to > from) ? (to - from) : (from - to));

    while (total_moves) {
        if (to < from) {
            src_slot = to + i + 1;
            dst_slot = to + i;
        } else {
            src_slot = to - i - 1;
            dst_slot = to - i;
        }

        if (lbl_ctrl[src_slot].used) {
            entry.index = src_slot;

            SHR_IF_ERR_VERBOSE_EXIT
                (lt_tnl_mpls_special_label_op(unit, BCMLT_OPCODE_LOOKUP,
                                              &entry));
            SHR_IF_ERR_VERBOSE_EXIT
                (lt_tnl_mpls_special_label_op(unit, BCMLT_OPCODE_DELETE,
                                              &entry));
            entry.index = dst_slot;
            SHR_IF_ERR_VERBOSE_EXIT
                (lt_tnl_mpls_special_label_op(unit, BCMLT_OPCODE_INSERT,
                                              &entry));
        }

        sal_memcpy((&(lbl_ctrl[dst_slot])), (&(lbl_ctrl[src_slot])),
                    sizeof(xfs_mpls_special_label_control_t));
        total_moves--;
        i++;
    }
    sal_memset((&(lbl_ctrl[from])), 0,
                sizeof(xfs_mpls_special_label_control_t));
exit:
   SHR_FUNC_EXIT();
}

/*!
 * \brief Alloc the entry index for the spefied mpls header and mpls header mask.
 *
 * \param [in] unit              Unit number.
 * \param [in] mpls_hdr          Mpls header.
 * \param [in] mpls_hdr_mask     Mpls header.
 * \param [out] existed          Entry is already created.
 * \param [out] index            Entry index.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
static int
tnl_mpls_special_label_index_alloc(
    int unit,
    uint32_t mpls_hdr,
    uint32_t mpls_hdr_mask,
    int *existed,
    int *index)
{
    xfs_mpls_special_label_control_t *lbl_ctrl = XFS_SPECIAL_LABEL_CTRL(unit);
    uint32_t    num_entry = XFS_SPECIAL_LABEL_TBL_SZ(unit);
    int i;
    int free_slot = -1, move_start = -1;

    SHR_FUNC_ENTER(unit);
    for (i = 0; i < num_entry; i++) {
        if (!(lbl_ctrl[i].used)) {
            continue;
        }

        if ((mpls_hdr == lbl_ctrl[i].mpls_hdr) &&
            (mpls_hdr_mask == lbl_ctrl[i].mpls_hdr_mask)) {
            *index = i;
            *existed = 1;
            SHR_EXIT();
        }
    }

    /* First get the slot where it should go. */
    for (i = 0; i < num_entry; i++) {
        if (!(lbl_ctrl[i].used)) {
            if (free_slot == -1) {
                free_slot = i;
            }
            continue;
        }

        if ((mpls_hdr & mpls_hdr_mask) <
            (lbl_ctrl[i].mpls_hdr &  lbl_ctrl[i].mpls_hdr_mask)) {
            continue;
        }

        if ((mpls_hdr & mpls_hdr_mask) ==
            (lbl_ctrl[i].mpls_hdr & lbl_ctrl[i].mpls_hdr_mask)) {
            if (mpls_hdr < lbl_ctrl[i].mpls_hdr_mask) {
                continue;
            }
        }

        /* It means some entries need movement. */
        if (move_start == -1) {
            move_start = i;
            if (free_slot != -1) {
                break;
            }
        }
    }

    if (free_slot == -1) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }

    /*
     * If there is nothing to be moved,
     * then just return the free index as the priority.
     */
    if (move_start == -1) {
        *index = free_slot;
        *existed = 0;
        lbl_ctrl[free_slot].used = 1;
        lbl_ctrl[free_slot].mpls_hdr = mpls_hdr;
        lbl_ctrl[free_slot].mpls_hdr_mask = mpls_hdr_mask;
        SHR_EXIT();
    }

    /*
     * When free index is lower than move index, then it needs to move
     * one less entry as logic will give index to smaller entry.
     * In case free index is greater than move index, it will have to move
     * entries from move index.
     */
    move_start = ((free_slot < move_start)? (move_start - 1) : move_start);
    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_mpls_special_label_entries_move(unit, move_start, free_slot));
    *index = move_start;
    *existed = 0;
    lbl_ctrl[move_start].used = 1;
    lbl_ctrl[move_start].mpls_hdr = mpls_hdr;
    lbl_ctrl[move_start].mpls_hdr_mask = mpls_hdr_mask;
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Free entry index of the spefied mpls header and mpls header mask.
 *
 * \param [in] unit         Unit number.
 * \param [in] index            Entry index.
 *
 * \return Nothing.
 */
static void
tnl_mpls_special_label_index_free(
    int unit,
    int index)
{
    xfs_mpls_special_label_control_t *lbl_ctrl = XFS_SPECIAL_LABEL_CTRL(unit);

    sal_memset(&lbl_ctrl[index],
               0,
               sizeof(xfs_mpls_special_label_control_t));

    return;
}

/*!
 * \brief Get entry index of the spefied mpls header and mpls header mask.
 *
 * \param [in] unit         Unit number.
 * \param [in] mpls_hdr          Mpls header.
 * \param [in] mpls_hdr_mask     Mpls header.
 * \param [out] index            Entry index.
 *
 * \retval SHR_E_NONE          Found.
 * \retval !SHR_E_NOT_FOUND     Not found.
 */
static int
tnl_mpls_special_label_index_get(
    int unit,
    uint32_t mpls_hdr,
    uint32_t mpls_hdr_mask,
    int *index)
{
    xfs_mpls_special_label_control_t *lbl_ctrl = XFS_SPECIAL_LABEL_CTRL(unit);
    uint32_t    num_entry = XFS_SPECIAL_LABEL_TBL_SZ(unit);
    int i;
    int found = 0;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < num_entry; i++) {
        if (!(lbl_ctrl[i].used)) {
            continue;
        }

        if ((mpls_hdr == lbl_ctrl[i].mpls_hdr) &&
            (mpls_hdr_mask == lbl_ctrl[i].mpls_hdr_mask)) {
            *index = i;
            SHR_EXIT();
        }
    }

    if (!found) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert global control type to lt field.
 *
 * \param [in] unit            Unit number.
 * \param [in] control_type    Control type.
 * \param [out] field_name     Field name.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mpls_global_ctrl_type_to_lt_field(
    int unit,
    bcmi_ltsw_mpls_global_ctrl_t control_type,
    const char **field_name)
{
    SHR_FUNC_ENTER(unit);

    switch (control_type) {
    case bcmiMplsGlobalCwLowerClear:
        *field_name = CW_LOWER_CLEARs;
        break;
    case bcmiMplsGlobalCwUpperClear:
        *field_name = CW_UPPER_CLEARs;
        break;
    case bcmiMplsGlobalGalLabel:
        *field_name = GAL_LABELs;
        break;
    case bcmiMplsGlobalEliLabel:
        *field_name = ELI_LABELs;
        break;
    case bcmiMplsGlobalPwDecapSeqNumRange:
        *field_name = PW_DECAP_SEQUENCE_NUMBER_RANGEs;
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Resolve initiator tunnel ID.
 *
 * \param [in] unit         Unit number.
 * \param [in] tunnel_id    Tunnel ID.
 * \param [in] type         Tunnel type.
 * \param [out] index       Tunnel index of EGR_L3_TUNNEL_0/1.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
static int
encap_tnl_id_resolve(
    int unit,
    bcm_gport_t tunnel_id,
    bcmi_ltsw_tunnel_type_t *type,
    int *index)
{
    int tnl_idx;
    bcmi_ltsw_tunnel_type_t xfs_tnl_type;

    SHR_FUNC_ENTER(unit);

    BCMI_LTSW_GPORT_TUNNEL_ID_GET(tunnel_id, xfs_tnl_type, tnl_idx);

    if (xfs_tnl_type != bcmiTunnelTypeMpls) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (tnl_idx < XFS_MPLS_TNL_IDX_MIN) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    *type  = xfs_tnl_type;
    *index = tnl_idx;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Notify the other modules encap ID of an MPLS port is changed.
 *
 * \param [in]   unit       Unit number.
 * \param [in]   mpls_port  MPLS port.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
mpls_encap_id_notify(int unit, bcm_mpls_port_t *mpls_port)
{
    int rv;
    int vplag_vp = 0;
    int vp;
    bcmi_ltsw_l2_virtual_info_t l2_info;
    bcmi_ltsw_virtual_vp_info_t vp_info;

    SHR_FUNC_ENTER(unit);

    /* Notify TRUNK module about the update. */
    rv = mpls_port_match_vplag_vp_get(unit, mpls_port->mpls_port_id, &vplag_vp);
    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_trunk_vp_lag_member_update(unit,
                                                  vplag_vp,
                                                  mpls_port->mpls_port_id));
    }

    /* Notify L2 module about the update. */
    vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port->mpls_port_id);
    SHR_IF_ERR_VERBOSE_EXIT(
        bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info));
    if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_CASCADED)) {
        sal_memset(&l2_info, 0, sizeof(l2_info));
        l2_info.egress_if = mpls_port->encap_id;
        l2_info.gport     = mpls_port->mpls_port_id;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l2_virtual_info_update(unit, &l2_info));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the TNL_MPLS_EXP_REMARK_SELECTION.
 *
 * \param [in] unit    Unit number.
 * \param [in] init    Init/De-init TNL_MPLS_EXP_REMARK_SELECTION.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
xfs_lt_tnl_mpls_exp_remark_selection_set(int unit, int init)
{
    int dunit;
    int i;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int selection_id_1[] = {EXP_REMARK_CTRL_ID_SEL,
                            EXP_REMARK_CTRL_ID_SEL,
                            EXP_REMARK_CTRL_ID_SEL};
    int selection_id_2[] = {0, EXP_REMARK_CTRL_ID_SEL, EXP_REMARK_CTRL_ID_SEL};
    int selection_id_3[] = {0, 0, EXP_REMARK_CTRL_ID_SEL};
    const char *qos_select[] = {SEL_MPLS_EXP_LOOKUP_1s,
                                SEL_MPLS_EXP_LOOKUP_2s,
                                SEL_MPLS_EXP_LOOKUP_3s};
    bcmlt_opcode_t  opcode;
    int rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_EXP_REMARK_SELECTIONs, &ent_hdl));

    for (i = 0; i < COUNTOF(selection_id_1); i++) {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl,
                                    TNL_MPLS_EXP_REMARK_SELECTION_ID_1s,
                                    selection_id_1[i]));

        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl,
                                    TNL_MPLS_EXP_REMARK_SELECTION_ID_2s,
                                    selection_id_2[i]));

        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl,
                                    TNL_MPLS_EXP_REMARK_SELECTION_ID_3s,
                                    selection_id_3[i]));

        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl, EFFECTIVE_EXP_REMARKs, 0));

        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_symbol_add(ent_hdl,
                                           EXP_REMARK_SELECTs, qos_select[i]));

        opcode = init ? BCMLT_OPCODE_INSERT : BCMLT_OPCODE_DELETE;
        rv = bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL);
        if (!init && (rv == SHR_E_NOT_FOUND)) {
            rv = SHR_E_NONE;
        }
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the TNL_MPLS_EXP_QOS_SELECTION.
 *
 * \param [in] unit    Unit number.
 * \param [in] init    Init/De-init TNL_MPLS_EXP_QOS_SELECTION.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
xfs_lt_tnl_mpls_exp_qos_selection_set(int unit, int init)
{
    int dunit;
    int i;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    bcmlt_opcode_t  opcode;
    int rv;
    exp_qos_sel_policy_t sel_policy[] = {
                           {EXP_QOS_CTRL_ID_NONE, EXP_QOS_CTRL_ID_NONE,
                            EXP_QOS_CTRL_ID_NONE, SEL_MPLS_EXP_POLICY_NONEs},
                           {EXP_QOS_CTRL_ID_SEL,  EXP_QOS_CTRL_ID_NONE,
                            EXP_QOS_CTRL_ID_NONE, SEL_MPLS_EXP_LOOKUP_1s},
                           {EXP_QOS_CTRL_ID_SEL,  EXP_QOS_CTRL_ID_NONE,
                            EXP_QOS_CTRL_ID_SEL,  SEL_MPLS_EXP_LOOKUP_1s},
                           {EXP_QOS_CTRL_ID_SEL,  EXP_QOS_CTRL_ID_SEL,
                            EXP_QOS_CTRL_ID_NONE, SEL_MPLS_EXP_LOOKUP_1s},
                           {EXP_QOS_CTRL_ID_SEL,  EXP_QOS_CTRL_ID_SEL,
                            EXP_QOS_CTRL_ID_SEL,  SEL_MPLS_EXP_LOOKUP_1s},
                           {EXP_QOS_CTRL_ID_NONE, EXP_QOS_CTRL_ID_SEL,
                            EXP_QOS_CTRL_ID_NONE, SEL_MPLS_EXP_LOOKUP_2s},
                           {EXP_QOS_CTRL_ID_NONE, EXP_QOS_CTRL_ID_SEL,
                            EXP_QOS_CTRL_ID_SEL,  SEL_MPLS_EXP_LOOKUP_2s},
                           {EXP_QOS_CTRL_ID_NONE, EXP_QOS_CTRL_ID_NONE,
                            EXP_QOS_CTRL_ID_SEL,  SEL_MPLS_EXP_LOOKUP_3s}
                          };

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_EXP_QOS_SELECTIONs, &ent_hdl));

    for (i = 0; i < COUNTOF(sel_policy); i++) {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl,
                                    TNL_MPLS_EXP_QOS_SELECTION_ID_1s,
                                    sel_policy[i].selection_id_1));

        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl,
                                    TNL_MPLS_EXP_QOS_SELECTION_ID_2s,
                                    sel_policy[i].selection_id_2));

        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl,
                                    TNL_MPLS_EXP_QOS_SELECTION_ID_3s,
                                    sel_policy[i].selection_id_3));

        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl, EFFECTIVE_EXP_QOSs, 0));

        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_symbol_add(ent_hdl,
                                           EXP_QOS_SELECTs,
                                           sel_policy[i].src));

        opcode = init ? BCMLT_OPCODE_INSERT : BCMLT_OPCODE_DELETE;

        rv = bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL);
        if (!init && (rv == SHR_E_NOT_FOUND)) {
            rv = SHR_E_NONE;
        }
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the TNL_MPLS_LABEL_DECAP_POLICY.
 *
 * \param [in] unit      Unit number.
 * \param [in] init    Init or de-init TNL_MPLS_LABEL_DECAP_POLICY.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
static int
xfs_lt_tnl_mpls_label_decap_policy_set(
    int unit,
    int init,
    int lkup_labels)
{
    int dunit;
    int i;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const char *cmd_array[POLICY_CMD_SELECT_FLD_DEPTH];
    const char *obj_array[POLICY_OBJ_SELECT_FLD_DEPTH];
    const char *sel_symbol[] = {"invalid",
                                SEL_LOOKUP_1s, SEL_LOOKUP_2s, SEL_LOOKUP_3s};
    int rv;
    bcmlt_opcode_t  opcode;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (lkup_labels < 1 || lkup_labels > 3) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_LABEL_DECAP_POLICYs, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_field_add(ent_hdl, TNL_MPLS_LABEL_DECAP_POLICY_IDs,
                                lkup_labels - 1));

    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_field_add(ent_hdl, LABEL_FWD_CTRL_1s, 1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, LABEL_FWD_CTRL_1_MASKs, 0xf));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, POP_LOOKUP_LABEL_1s,
                               (lkup_labels >= 2) ? 1 : 0));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, LABEL_FWD_CTRL_2s,
                               (lkup_labels >= 2) ? 1 : 0));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, LABEL_FWD_CTRL_2_MASKs, 0xf));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, POP_LOOKUP_LABEL_2s,
                               (lkup_labels >= 3) ? 1 : 0));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, LABEL_FWD_CTRL_3s,
                               (lkup_labels == 3) ? 1 : 0));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, LABEL_FWD_CTRL_3_MASKs, 0xf));

    for (i = 0; i < POLICY_CMD_SELECT_FLD_DEPTH; i++) {
        cmd_array[i] = sel_symbol[lkup_labels];
    }
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_symbol_add(ent_hdl, POLICY_CMD_SELECTs,
                                            0, cmd_array,
                                            POLICY_CMD_SELECT_FLD_DEPTH));
    for (i = 0; i < POLICY_OBJ_SELECT_FLD_DEPTH; i++) {
        obj_array[i] = sel_symbol[lkup_labels];
    }
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_symbol_add(ent_hdl, POLICY_OBJ_SELECTs,
                                            0, obj_array,
                                            POLICY_OBJ_SELECT_FLD_DEPTH));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, DECAP_LOOKUP_LABELs, lkup_labels));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, TRUST_FWD_POLICYs, 1));

    opcode = init ? BCMLT_OPCODE_INSERT : BCMLT_OPCODE_DELETE;
    rv = bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                              BCMLT_PRIORITY_NORMAL);
    if (!init && (rv == SHR_E_NOT_FOUND)) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the MPLS LTs.
 *
 * \param [in] unit      Unit number.
 * \param [in] init    Init or de-init MPLS LTs.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
xfs_mpls_lt_init(
    int unit,
    int init)
{
    SHR_FUNC_ENTER(unit);

    /* One lookup label case. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_lt_tnl_mpls_label_decap_policy_set(unit, init, 1));

    /* Two lookup labels case. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_lt_tnl_mpls_label_decap_policy_set(unit, init, 2));

    /* Three lookup labels case. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_lt_tnl_mpls_label_decap_policy_set(unit, init, 3));

    /* Set LT TNL_MPLS_EXP_QOS_SELECTION . */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_lt_tnl_mpls_exp_qos_selection_set(unit, init));

    /* Set LT TNL_MPLS_EXP_REMARK_SELECTION . */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_lt_tnl_mpls_exp_remark_selection_set(unit, init));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clean up XFS MPLS info.
 *
 * \param [in] unit    Unit number.
 *
 * \return Nothing.
 */
static void
xfs_mpls_info_cleanup(int unit)
{
    xfs_mpls_info_t *xmi = XFS_MPLS_INFO(unit);

    xmi->pw_term_cnt_sz     = 0;
    xmi->special_lbl_tbl_sz = 0;
    xmi->lookup_label_cnt   = 0;

    /* Destroy MPLS Tnl Mutex */
    if (xmi->mpls_tnl_mutex) {
        sal_mutex_destroy(xmi->mpls_tnl_mutex);
        xmi->mpls_tnl_mutex = NULL;
    }

    return;
}

/*!
 * \brief Recover index table mgmt bookkeepings for EGR_MPLS_VPN LT.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_mpls_egr_mpls_vpn_recover(int unit)
{
    lt_egr_mpls_vpn_entry_t vpn_entry;
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN;
    uint8_t user_id = BCMI_EGR_MPLS_VPN_USER_ID_MPLS;
    const char *fld_name;
    int fid;
    const bcmint_mpls_lt_t *lt_info;
    uint64_t idx_min, idx_max;
    uint32 ent_idx;
    uint32 ref_cnt;
    int rv;
    encap_label_info_t label_info;
    lt_egr_dvp_entry_t dvp_entry;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EGR_DVP,
                            &lt_info));

    fid  = BCMINT_LTSW_MPLS_FLD_EGR_DVP_DVP;
    fld_name = lt_info->flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, lt_info->name, fld_name,
                                       &idx_min, &idx_max));
    for (ent_idx = idx_min; ent_idx <= idx_max; ent_idx++) {
        sal_memset(&dvp_entry, 0, sizeof(dvp_entry));
        dvp_entry.dvp = ent_idx;
        rv = lt_egr_dvp_op(unit, BCMLT_OPCODE_LOOKUP, &dvp_entry);
        if (rv == SHR_E_NOT_FOUND) {
            continue;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        sal_memset(&vpn_entry, 0, sizeof(vpn_entry));
        vpn_entry.vpn_label_index = dvp_entry.vc_label_idx;
        rv = lt_egr_mpls_vpn_op(unit, BCMLT_OPCODE_LOOKUP, &vpn_entry);
        if (rv == SHR_E_NOT_FOUND) {
            continue;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }

        if (vpn_entry.view != VIEW_MPLS) {
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id,
                                             vpn_entry.vpn_label_index,
                                             &ref_cnt));
        if (ref_cnt == 0) {
            sal_memset(&label_info, 0, sizeof(label_info));
            PARSE_MPLS_HDR_NO_BOS(vpn_entry.vpn_label_hdr,
                                  label_info.vc_label,
                                  label_info.exp,
                                  label_info.ttl);
            label_info.proc_ctrl = vpn_entry.process_ctrl;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_hash_update(unit, tbl_id, user_id,
                                                     &label_info,
                                                     vpn_entry.vpn_label_index));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_increase(unit, tbl_id, user_id,
                                                  vpn_entry.vpn_label_index));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover index table mgmt bookkeepings for EGR_MPLS_VPN from L3 intf.
 *
 * \param [in] unit Unit number.
 * \param [in] mpls_info MPLS info.
 * \param [in] user_data User data for callback.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_mpls_l3_vpn_recover(int unit,
                        bcmi_ltsw_l3_intf_mpls_t *mpls_info,
                        void *user_data)
{
    lt_egr_mpls_vpn_entry_t vpn_entry;
    uint32 ref_cnt;
    encap_label_info_t label_info;

    SHR_FUNC_ENTER(unit);

    sal_memset(&vpn_entry, 0, sizeof(vpn_entry));
    vpn_entry.vpn_label_index = mpls_info->vc_label_index;
    SHR_IF_ERR_EXIT
        (lt_egr_mpls_vpn_op(unit, BCMLT_OPCODE_LOOKUP, &vpn_entry));

    if (vpn_entry.view != VIEW_MPLS) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    SHR_IF_ERR_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_get(unit,
                                         BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN,
                                         BCMI_EGR_MPLS_VPN_USER_ID_MPLS,
                                         vpn_entry.vpn_label_index,
                                         &ref_cnt));
    if (ref_cnt == 0) {
        sal_memset(&label_info, 0, sizeof(label_info));
        PARSE_MPLS_HDR_NO_BOS(vpn_entry.vpn_label_hdr,
                              label_info.vc_label,
                              label_info.exp,
                              label_info.ttl);
        label_info.proc_ctrl = vpn_entry.process_ctrl;

        SHR_IF_ERR_EXIT
            (bcmi_ltsw_idx_tbl_entry_hash_update(unit,
                                              BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN,
                                              BCMI_EGR_MPLS_VPN_USER_ID_MPLS,
                                              &label_info,
                                              vpn_entry.vpn_label_index));
    }

    SHR_IF_ERR_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_increase(unit,
                                              BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN,
                                              BCMI_EGR_MPLS_VPN_USER_ID_MPLS,
                                              vpn_entry.vpn_label_index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover index table mgmt bookkeepings for tunnel initiator.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_mpls_tunnel_encap_recover(int unit)
{
    lt_egr_l3_tnl_entry_t entry;
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
    uint8_t user_id = BCMI_EGR_L3_TNL_USER_ID_MPLS;
    const char *fld_name;
    int fid;
    const bcmint_mpls_lt_t *lt_info;
    uint64_t idx_min, idx_max;
    uint32 ent_idx;
    uint32 ref_cnt;
    int rv;
    bcm_mpls_tunnel_encap_t tunnel_encap;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EGR_L3_TUNNEL_0,
                            &lt_info));

    fid  = BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_EGR_L3_TUNNEL_IDX_0;
    fld_name = lt_info->flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, lt_info->name, fld_name,
                                       &idx_min, &idx_max));
    for (ent_idx = idx_min; ent_idx <= idx_max; ent_idx++) {
        sal_memset(&entry, 0, sizeof(entry));
        entry.tnl_idx = ent_idx;
        rv = lt_egr_l3_tnl_op(unit, BCMLT_OPCODE_LOOKUP, &entry);
        if (rv == SHR_E_NOT_FOUND) {
            continue;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }

        if (entry.edit_ctrl_id != XFS_TNL_EDIT_CTRL_ID_MPLS) {
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id,
                                             ent_idx, &ref_cnt));
        if (ref_cnt == 0) {
            bcm_mpls_tunnel_encap_t_init(&tunnel_encap);
            BCMI_LTSW_GPORT_TUNNEL_ID_SET(tunnel_encap.tunnel_id,
                                          bcmiTunnelTypeMpls, ent_idx);
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ltsw_mpls_tnl_encap_get(unit, &tunnel_encap));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_hash_update(unit, tbl_id, user_id,
                                                     &tunnel_encap, ent_idx));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_increase(unit, tbl_id, user_id,
                                                  ent_idx));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover the XFS information during warmboot.
 *
 * \param [in] unit       Unit number.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
xfs_mpls_recover(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Recover the reference of tunnel entries. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_mpls_tunnel_encap_recover(unit));

    /* Recover the reference of EGR_MPLS_VPN LT. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_mpls_egr_mpls_vpn_recover(unit));

    /* Recover the reference of EGR_MPLS_VPN from L3 INTF. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_intf_mpls_recover_all(unit,
                                            xfs_mpls_l3_vpn_recover,
                                            NULL));

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Initialize XFS MPLS info.
 *
 * \param [in] unit       Unit number.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
xfs_mpls_info_init(int unit)
{
    xfs_mpls_info_t *xmi = XFS_MPLS_INFO(unit);
    uint32_t vp_num = 0;
    uint64_t  min, max;
    uint32_t entry_num;
    uint32_t ha_alloc_size = 0, ha_req_size = 0;
    int warm = bcmi_warmboot_get(unit);
    const bcmint_mpls_lt_t *lt_info;
    int rv;
    uint32_t ha_instance_size;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, TNL_PW_DECAP_SEQUENCE_NUMBERs,
                              &(xmi->pw_term_cnt_sz)));

    ha_req_size      = SHR_BITALLOCSIZE(xmi->pw_term_cnt_sz);
    ha_alloc_size    = ha_req_size;
    xmi->pw_term_bmp = bcmi_ltsw_ha_mem_alloc(unit,
                                              BCMI_HA_COMP_ID_MPLS,
                                              bcmLtswMplsHaXmiPwTermBmp,
                                              "bcmLtswMplsHaXmiPwTermBmp",
                                              &ha_alloc_size);
    SHR_NULL_CHECK(xmi->pw_term_bmp, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT((ha_alloc_size < ha_req_size) ?
                            SHR_E_MEMORY : SHR_E_NONE);
    if (!warm) {
        sal_memset(xmi->pw_term_bmp, 0, ha_alloc_size);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_num_get(unit, &vp_num));
    ha_req_size      = sizeof(xfs_mpls_vp_info_t) * vp_num;
    ha_alloc_size    = ha_req_size;
    xmi->vp_info     = bcmi_ltsw_ha_mem_alloc(unit,
                                              BCMI_HA_COMP_ID_MPLS,
                                              bcmLtswMplsHaXmiVpInfo,
                                              "bcmLtswMplsHaXmiVpInfo",
                                              &ha_alloc_size);
    SHR_NULL_CHECK(xmi->vp_info, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT((ha_alloc_size < ha_req_size) ?
                            SHR_E_MEMORY : SHR_E_NONE);
    if (!warm) {
        sal_memset(xmi->vp_info, 0, ha_alloc_size);
    }

    rv = bcmi_ltsw_issu_struct_info_report(unit,
                                           BCMI_HA_COMP_ID_MPLS,
                                           bcmLtswMplsHaXmiVpInfo,
                                           0, sizeof(xfs_mpls_vp_info_t),
                                           vp_num,
                                           XFS_MPLS_VP_INFO_T_ID);
    if (rv != SHR_E_EXISTS) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, ING_L2_IIF_TABLEs,
                                       L2_IIFs, &min, &max));
    ha_req_size      = sizeof(uint32_t) * (max + 1 - min);
    ha_alloc_size    = ha_req_size;
    xmi->l2_iif_map  = bcmi_ltsw_ha_mem_alloc(unit,
                                              BCMI_HA_COMP_ID_MPLS,
                                              bcmLtswMplsHaXmiL2iifMap,
                                              "bcmLtswMplsHaXmiL2iifMap",
                                              &ha_alloc_size);
    SHR_NULL_CHECK(xmi->l2_iif_map, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT((ha_alloc_size < ha_req_size) ?
                            SHR_E_MEMORY : SHR_E_NONE);
    if (!warm) {
        sal_memset(xmi->l2_iif_map, 0, ha_alloc_size);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, TNL_MPLS_SPECIAL_LABELs, &entry_num));
    xmi->special_lbl_tbl_sz = entry_num;
    ha_instance_size = sizeof(xfs_mpls_special_label_control_t);
    ha_req_size      = ha_instance_size * entry_num;
    ha_alloc_size    = ha_req_size;
    xmi->special_label_ctrl  = bcmi_ltsw_ha_mem_alloc(unit,
                                              BCMI_HA_COMP_ID_MPLS,
                                              bcmLtswMplsHaXmiSpecLablCtrl,
                                              "bcmLtswMplsHaXmiSpecLablCtrl",
                                              &ha_alloc_size);
    SHR_NULL_CHECK(xmi->special_label_ctrl, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT((ha_alloc_size < ha_req_size) ?
                            SHR_E_MEMORY : SHR_E_NONE);
    if (!warm) {
        sal_memset(xmi->special_label_ctrl, 0, ha_alloc_size);
    }

    rv = bcmi_ltsw_issu_struct_info_report(unit,
                                           BCMI_HA_COMP_ID_MPLS,
                                           bcmLtswMplsHaXmiSpecLablCtrl,
                                           0,
                                           ha_instance_size,
                                           entry_num,
                                           XFS_MPLS_SPECIAL_LABEL_CONTROL_T_ID);
    if (rv != SHR_E_EXISTS) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_2, &lt_info));

    xmi->lookup_label_cnt = 3;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, lt_info->name, &entry_num));
    /* When uat_mode = 1, MPLS_ENTRY_2 is 0 in size, support one lookup. */
    if (entry_num == 0) {
        xmi->lookup_label_cnt = 1;
    }

    if (xmi->mpls_tnl_mutex == NULL) {
        xmi->mpls_tnl_mutex = sal_mutex_create("ltswMPLSTnlMutex");
        SHR_NULL_CHECK(xmi->mpls_tnl_mutex, SHR_E_MEMORY);
    }


exit:
    if (SHR_FUNC_ERR()) {
        if (!warm) {
            if (xmi->pw_term_bmp) {
                (void)bcmi_ltsw_ha_mem_free(unit, xmi->pw_term_bmp);
            }

            if (xmi->vp_info) {
                (void)bcmi_ltsw_ha_mem_free(unit, xmi->vp_info);
            }

            if (xmi->l2_iif_map) {
                (void)bcmi_ltsw_ha_mem_free(unit, xmi->l2_iif_map);
            }

            if (xmi->special_label_ctrl) {
                (void)bcmi_ltsw_ha_mem_free(unit, xmi->special_label_ctrl);
            }
        }
        xfs_mpls_info_cleanup(unit);
    }

    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_mpls_sw_dump(int unit)
{
    xfs_mpls_info_t *xi = XFS_MPLS_INFO(unit);
    int i = 0, count;
    xfs_mpls_vp_info_t *vp_info;
    uint32_t  vp_num = 0, vp;
    uint64_t min = 0, max = 0;
    xfs_mpls_special_label_control_t *lbl_ctrl = xi->special_label_ctrl;

    SHR_FUNC_ENTER(unit);

    LOG_CLI((BSL_META_U(unit,
                        "\nSW Information XFS MPLS - Unit %d\n"), unit));
    LOG_CLI((BSL_META_U(unit,
                        "  pw_term_cnt_sz       : %4d\n"), xi->pw_term_cnt_sz));

    LOG_CLI((BSL_META_U(unit,
                        "  PW term bmp:\n")));
    count = 0;
    for (i = 0; i < xi->pw_term_cnt_sz; i++) {
        if (!SHR_BITGET(xi->pw_term_bmp, i)) {
            continue;
        }

        LOG_CLI((BSL_META_U(unit, "  %4d"), i));
        count++;
        if (count % 10 == 0) {
            LOG_CLI((BSL_META_U(unit, "\n")));
        }
    }

    LOG_CLI((BSL_META_U(unit,
                        "\n Logical VP to L2_IIF map:\n")));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, ING_L2_IIF_TABLEs,
                                       L2_IIFs, &min, &max));
    count = 0;
    for (i = min; i <= max; i++) {
        if (xi->l2_iif_map[i] == 0) {
            continue;
        }
        LOG_CLI((BSL_META_U(unit,
                     "  VP %4d : L2_IF %4d "), i, xi->l2_iif_map[i]));

        count++;
        if (count % 4 == 0) {
            LOG_CLI((BSL_META_U(unit, "\n")));
        }
    }
    LOG_CLI((BSL_META_U(unit,
                        "\n")));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_num_get(unit, &vp_num));
    LOG_CLI((BSL_META_U(unit,
                        "\n Logical VP match key info:\n")));
    LOG_CLI((BSL_META_U(unit,
             "    VP     criteria match_label port pg vpless_port vpless_pg vpless")));
    LOG_CLI((BSL_META_U(unit,
             " vpless_egr_intf\n")));
    for (vp = 0; vp < vp_num; vp++) {
        vp_info = &(xi->vp_info[vp]);
        if (vp_info->criteria == BCM_MPLS_PORT_MATCH_INVALID) {
            continue;
        }

        LOG_CLI((BSL_META_U(unit,
                     "  %#4x   "), vp));

        LOG_CLI((BSL_META_U(unit,
                     "   %#2x     "), vp_info->criteria));

        LOG_CLI((BSL_META_U(unit,
                     " %#4x "), vp_info->label));

        LOG_CLI((BSL_META_U(unit,
                     "  %#4x "), vp_info->port));

        LOG_CLI((BSL_META_U(unit,
                     "  %#4x "), vp_info->port_group));

        LOG_CLI((BSL_META_U(unit,
                     "    %#4x "), vp_info->vpless_port));

        LOG_CLI((BSL_META_U(unit,
                     "    %#4x "), vp_info->vpless_port_group));

        LOG_CLI((BSL_META_U(unit,
                     "      %#x "), vp_info->vpless));

        LOG_CLI((BSL_META_U(unit,
                     "       %#4x "), vp_info->vpless_egress_if));

        LOG_CLI((BSL_META_U(unit,
                            "\n")));
    }

    LOG_CLI((BSL_META_U(unit,
                        "Special label information:\n")));
    for (i = 0; i < xi->special_lbl_tbl_sz; i++) {
        if (!(lbl_ctrl[i].used)) {
            continue;
        }

        LOG_CLI((BSL_META_U(unit,
                     " slot = %#4x mpls_hdr=%4x mpls_hdr_mask = %#4x\n"),
                     i, lbl_ctrl[i].mpls_hdr, lbl_ctrl[i].mpls_hdr_mask));
    }
    LOG_CLI((BSL_META_U(unit,
                        "\n")));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_init(int unit)
{
    uint64_t idx_max;
    bcmi_ltsw_idx_tbl_user_info_t user_info;
    bcmi_ltsw_idx_tbl_lt_info_t lt_info;
    bcmi_ltsw_idx_tbl_id_t tbl_id;
    int egr_l3_tunnel_registered = 0, egr_mpls_vpn_registered = 0;
    uint8_t user_id;
    const bcmint_mpls_lt_t *lt_db;
    const char *fld_name;
    const bcmint_mpls_fld_t *flds;
    int fid;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
       (xfs_mpls_info_init(unit));

    /* Register callbacks for EGR_L3_TUNNEL_0/1 LT. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EGR_L3_TUNNEL_0, &lt_db));
    flds = lt_db->flds;
    fld_name = flds[BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_EGR_L3_TUNNEL_IDX_0].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, lt_db->name,
                                       fld_name, NULL, &idx_max));
    sal_memset(&lt_info, 0, sizeof(lt_info));
    lt_info.user_cnt  = BCMI_EGR_L3_TNL_USER_ID_CNT;
    lt_info.tbl_name  = lt_db->name;
    lt_info.idx_field = fld_name;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = XFS_MPLS_TNL_IDX_MIN;
    user_info.idx_max     = (int)idx_max;
    user_info.func_hash   = lt_egr_l3_tnl_hash;
    user_info.func_cmp    = lt_egr_l3_tnl_cmp;
    user_info.func_insert = lt_egr_l3_tnl_insert;
    user_info.func_del    = lt_egr_l3_tnl_delete;

    tbl_id  = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
    user_id = BCMI_EGR_L3_TNL_USER_ID_MPLS;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit, tbl_id, user_id,
                                    &lt_info, &user_info));
    egr_l3_tunnel_registered = 1;

    /* Register callbacks for EGR_MPLS_VPN LT. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EGR_MPLS_VPN, &lt_db));
    flds = lt_db->flds;
    fid  = BCMINT_LTSW_MPLS_FLD_EGR_MPLS_VPN_MPLS_VPN_OR_INT_INDEX;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, lt_db->name,
                                       fld_name,
                                       NULL, &idx_max));
    sal_memset(&lt_info, 0, sizeof(lt_info));
    lt_info.user_cnt  = BCMI_EGR_MPLS_VPN_USER_ID_CNT;
    lt_info.tbl_name  = lt_db->name;
    lt_info.idx_field = fld_name;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = 1;
    user_info.idx_max     = (int)idx_max;
    user_info.func_hash   = lt_egr_mpls_vpn_hash;
    user_info.func_cmp    = lt_egr_mpls_vpn_cmp;
    user_info.func_insert = lt_egr_mpls_vpn_insert;
    user_info.func_del    = lt_egr_mpls_vpn_delete;

    tbl_id  = BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN;
    user_id = BCMI_EGR_MPLS_VPN_USER_ID_MPLS;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit, tbl_id, user_id,
                                    &lt_info, &user_info));
    egr_mpls_vpn_registered = 1;

    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_mpls_lt_init(unit, 1));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_mpls_recover(unit));
    }

exit:
    if (SHR_FUNC_ERR()) {

        xfs_mpls_info_cleanup(unit);

        if (egr_l3_tunnel_registered) {
            tbl_id  = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
            user_id = BCMI_EGR_L3_TNL_USER_ID_MPLS;
            (void)bcmi_ltsw_idx_tbl_unregister(unit, tbl_id, user_id);
        }

        if (egr_mpls_vpn_registered) {
            tbl_id  = BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN;
            user_id = BCMI_EGR_MPLS_VPN_USER_ID_MPLS;
            (void)bcmi_ltsw_idx_tbl_unregister(unit, tbl_id, user_id);
        }
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_detach(int unit)
{
    bcmi_ltsw_idx_tbl_id_t tbl_id;
    uint8_t user_id;

    SHR_FUNC_ENTER(unit);

    

    xfs_mpls_info_cleanup(unit);

    tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
    user_id = BCMI_EGR_L3_TNL_USER_ID_MPLS;
    (void)bcmi_ltsw_idx_tbl_unregister(unit, tbl_id, user_id);

    tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN;
    user_id = BCMI_EGR_MPLS_VPN_USER_ID_MPLS;
    (void)bcmi_ltsw_idx_tbl_unregister(unit, tbl_id, user_id);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_mpls_lt_init(unit, 0));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_tnl_switch_add(
    int unit,
    bcm_mpls_tunnel_switch_t *info)
{
    int rv = SHR_E_NONE;
    int entry_exists = 0;
    lt_mpls_entry_t entry, old_entry;
    bcmlt_opcode_t opcode;
    int old_pw_term_num = -1;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);

    sal_memset(&entry, 0, sizeof(lt_mpls_entry_t));
    sal_memset(&old_entry, 0, sizeof(lt_mpls_entry_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_range_validate(unit, info->label, info->port));

    /* Check if the label exists. */
    old_entry.label = info->label;

    if (info->port != BCM_GPORT_INVALID) {
        old_entry.label_conext_id = info->port;
    }

    old_entry.fld_bmp = ME_TNL_FLD_BMP;
    old_entry.fld_bmp &= ~(ME_FLD_LABEL | ME_FLD_CONTEXT_ID);
    rv = lt_mpls_entry_op(unit, BCMLT_OPCODE_LOOKUP, &old_entry);
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_NOT_FOUND);
    if (rv == SHR_E_NONE) {
        entry_exists = 1;
    }

    if (old_entry.pw_term_num_valid &&
        (info->flags & BCM_MPLS_SWITCH_COUNTED)) {
        old_pw_term_num = old_entry.pw_term_num;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_switch_info_to_mpls_entry(unit, info, &entry,
                                       old_pw_term_num));

    opcode = entry_exists ? BCMLT_OPCODE_UPDATE : BCMLT_OPCODE_INSERT;
    rv = lt_mpls_entry_op(unit, opcode, &entry);
    if (SHR_FAILURE(rv)) {
        if (!entry_exists) {
            (void)lt_mpls_entry_op(unit, BCMLT_OPCODE_DELETE, &entry);
        }
        SHR_IF_ERR_EXIT(rv);
    }

    if (entry_exists) {
        /* Clean up the old counter if not used. */
        if ((old_entry.pw_term_num_valid) &&
             !(info->flags & BCM_MPLS_SWITCH_COUNTED)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_pw_term_counter_destroy(unit, old_entry.pw_term_num));
        }
    }

exit:
    MPLS_TNL_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_tnl_switch_delete(
    int unit,
    bcm_mpls_tunnel_switch_t *info)
{
    lt_mpls_entry_t entry;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);

    sal_memset(&entry, 0, sizeof(lt_mpls_entry_t));

    entry.label = info->label;

    if (info->port != BCM_GPORT_INVALID) {
        entry.label_conext_id = info->port;
    }

    entry.fld_bmp |= ME_FLD_PW_TERM_NUM_VALID;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_mpls_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_mpls_entry_op(unit, BCMLT_OPCODE_DELETE, &entry));

    /* Clear the counter if used by the terminator. */
    if (entry.pw_term_num_valid) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_pw_term_counter_destroy(unit, entry.pw_term_num));
    }

exit:
    MPLS_TNL_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_tnl_switch_get(
    int unit,
    bcm_mpls_tunnel_switch_t *info)
{
    lt_mpls_entry_t entry;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);

    sal_memset(&entry, 0, sizeof(lt_mpls_entry_t));

    entry.label = info->label;

    if (info->port != BCM_GPORT_INVALID) {
        entry.label_conext_id = info->port;
    }

    entry.fld_bmp  |= ME_TNL_FLD_BMP;

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_mpls_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_switch_info_from_mpls_entry(unit, info, &entry));

exit:
    MPLS_TNL_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_tnl_switch_traverse(
    int unit,
    bcm_mpls_tunnel_switch_traverse_cb cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_switch_traverse(unit,
                             bcmi_ltsw_dev_cb_err_abort(unit), cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_tnl_switch_delete_all(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_switch_traverse(unit, 1, tnl_switch_delete_all_trav_cb, NULL));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_tnl_encap_create(
    int unit,
    uint32_t options,
    bcm_mpls_tunnel_encap_t *tunnel_encap)
{
    uint32_t ref_cnt, flags;
    bcm_mpls_tunnel_encap_t *te = tunnel_encap;
    int num_labels = te->num_labels;
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
    uint8_t user_id = BCMI_EGR_L3_TNL_USER_ID_MPLS;
    int tnl_idx;
    bcmi_ltsw_tunnel_type_t xfs_tnl_type;
    int i;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);

    /*
     * num_labels == 0 means dummy tunnel entry.
     * In this case, VC label will be added without tunnel label added.
     * Without dummy tunnel entry, VC label could not be added.
     */
    if (num_labels < 0 || num_labels > XFS_ENCAP_LABEL_CNT_MAX) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* BCM_MPLS_EGRESS_LABEL_TTL_SET must be set except the outmost label. */
    for (i = 0; i < num_labels - 1; i++) {
        flags = tunnel_encap->label_array[i].flags;
        if (!(flags & BCM_MPLS_EGRESS_LABEL_TTL_SET)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

    if (options & BCM_MPLS_TUNNEL_ENCAP_OPTIONS_REPLACE) {
        if (!(options & BCM_MPLS_TUNNEL_ENCAP_OPTIONS_WITH_ID)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (encap_tnl_id_resolve(unit, te->tunnel_id,
                                  &xfs_tnl_type, &tnl_idx));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id,
                                             tnl_idx, &ref_cnt));
        if (ref_cnt == 0) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
        }

        flags = BCMI_LTSW_IDX_TBL_OP_WITH_ID | BCMI_LTSW_IDX_TBL_OP_REPLACE;
    } else {
        if (options & BCM_MPLS_TUNNEL_ENCAP_OPTIONS_WITH_ID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (encap_tnl_id_resolve(unit, te->tunnel_id,
                                      &xfs_tnl_type, &tnl_idx));
            flags = BCMI_LTSW_IDX_TBL_OP_WITH_ID;
        } else {
            /* Allocate a new index exclusively. */
            flags = BCMI_LTSW_IDX_TBL_OP_MATCH_DISABLE;
        }
    }


    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_alloc(unit, flags, tbl_id, user_id,
                                       tunnel_encap, &tnl_idx));

    BCMI_LTSW_GPORT_TUNNEL_ID_SET(te->tunnel_id, bcmiTunnelTypeMpls, tnl_idx);

exit:
    MPLS_TNL_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_tnl_encap_get(
    int unit,
    bcm_mpls_tunnel_encap_t *tunnel_encap)
{
    int tnl_idx;
    lt_egr_l3_tnl_entry_t l3_tnl_entry;
    bcmi_ltsw_tunnel_type_t xfs_tnl_type;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (encap_tnl_id_resolve(unit, tunnel_encap->tunnel_id,
                               &xfs_tnl_type, &tnl_idx));

    sal_memset(&l3_tnl_entry, 0, sizeof(l3_tnl_entry));
    l3_tnl_entry.tnl_idx = tnl_idx;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_l3_tnl_op(unit, BCMLT_OPCODE_LOOKUP, &l3_tnl_entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_encap_from_egr_l3_tnl_entry(unit, tunnel_encap, &l3_tnl_entry));

exit:
    MPLS_TNL_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_tnl_encap_destroy(
    int unit,
    bcm_gport_t tunnel_id)
{
    int tnl_idx;
    bcmi_ltsw_tunnel_type_t xfs_tnl_type;
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
    uint8_t user_id = BCMI_EGR_L3_TNL_USER_ID_MPLS;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (encap_tnl_id_resolve(unit, tunnel_id, &xfs_tnl_type, &tnl_idx));


    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_free(unit, 0, tbl_id, user_id, tnl_idx));

exit:
    MPLS_TNL_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_tnl_encap_destroy_all(int unit)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    int rv = SHR_E_NONE;
    uint64_t value = 0;
    lt_egr_l3_tnl_entry_t entry;
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
    uint8_t user_id = BCMI_EGR_L3_TNL_USER_ID_MPLS;
    const char *fld_name;
    int fid;
    const bcmint_mpls_lt_t *lt_info;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EGR_L3_TUNNEL_0,
                            &lt_info));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &ent_hdl));

    rv = bcmi_lt_entry_commit(unit, ent_hdl, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);

    while (rv == SHR_E_NONE) {
        sal_memset(&entry, 0, sizeof(entry));

        fid  = BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_EDIT_CTRL_ID;
        fld_name = lt_info->flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));

        if (value != XFS_TNL_EDIT_CTRL_ID_MPLS) {
            rv = bcmi_lt_entry_commit(unit, ent_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL);
            continue;
        }

        fid  = BCMINT_LTSW_MPLS_FLD_EGR_L3_TNL_0_EGR_L3_TUNNEL_IDX_0;
        fld_name = lt_info->flds[fid].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, fld_name, &value));

        /* Traverse to next entry */
        rv = bcmi_lt_entry_commit(unit, ent_hdl, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_free(unit, 0, tbl_id,
                                          user_id, (uint32_t)value));
    }

    if ((rv != SHR_E_NOT_FOUND) && SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    MPLS_TNL_UNLOCK(unit);

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_vfi_op(
    int unit,
    bcmlt_opcode_t opcode,
    int vfi_idx,
    bcm_mpls_vpn_config_t *info)
{
    uint32_t group_type = 0;
    lt_ing_vfi_table_entry_t entry;

    SHR_FUNC_ENTER(unit);

    if (opcode == BCMLT_OPCODE_UPDATE) {
        if (!((info->broadcast_group == info->unknown_multicast_group) &&
               (info->broadcast_group == info->unknown_unicast_group))) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        group_type = _BCM_MULTICAST_TYPE_GET(info->broadcast_group);
        if (group_type != _BCM_MULTICAST_TYPE_VPLS) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        sal_memset(&entry, 0, sizeof(entry));
        vpn_info_to_ing_vfi_table_entry(unit, vfi_idx, info, &entry);

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_ing_vfi_table_op(unit, opcode, &entry));
    } else if (opcode == BCMLT_OPCODE_LOOKUP) {
        sal_memset(&entry, 0, sizeof(entry));
        entry.vfi = vfi_idx;
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_ing_vfi_table_op(unit, opcode, &entry));

        vpn_info_from_ing_vfi_table_entry(unit, info, &entry);
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_vpws_info_get(
    int unit,
    int *idx_min,
    int *idx_max)
{
    uint64_t   min, max;
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, ING_L2_IIF_TABLEs,
                                       L2_IIFs, &min, &max));
    *idx_min = (int)min;
    *idx_max = (int)max;
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_port_add(
    int unit,
    bcm_vpn_t vpn,
    bcm_mpls_port_t *mpls_port)
{
    int vp = -1, vp_configured = 0;
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN;
    uint8_t user_id = BCMI_EGR_MPLS_VPN_USER_ID_MPLS;
    int vc_label_idx = 0, vc_label_idx_added = 0, old_vc_label_idx = -1;
    int match_added = 0;
    bcm_gport_t mpls_port_id;
    int tnl_idx = 0;
    bcmi_ltsw_tunnel_type_t xfs_tnl_type;
    encap_label_info_t label_info;
    uint32_t  flags;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    bcm_if_t old_encap_id = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_param_validate(unit, vpn, mpls_port));

    if ((mpls_port->flags & BCM_MPLS_PORT_NETWORK) &&
        (mpls_port->flags & BCM_MPLS_PORT_REPLACE) &&
         !(mpls_port->flags & BCM_MPLS_PORT_FAILOVER)) {
        vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port->mpls_port_id);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info));
        /* Don't support CASCADED replace operation. */
        if ((vp_info.flags & BCMI_LTSW_VIRTUAL_VP_CASCADED) !=
            (mpls_port->flags2 & BCM_MPLS_PORT2_ENCAP_CASCADED)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                   mpls_port->mpls_port_id,
                                                   &old_encap_id));
    }

    if (mpls_port->flags & BCM_MPLS_PORT_NETWORK) {
        SHR_IF_ERR_VERBOSE_EXIT
            (encap_tnl_id_resolve(unit, mpls_port->tunnel_id,
                                  &xfs_tnl_type, &tnl_idx));
    }

    if (mpls_port->flags & BCM_MPLS_PORT_FAILOVER) {
        /*
         * The vp and vpless vp should have the same vp-based properties
         * as they have a same vp.
         */
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_port_vpless_validate(unit, vpn, mpls_port));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_vp_alloc(unit, vpn, mpls_port, &vp));
    BCM_GPORT_MPLS_PORT_ID_SET(mpls_port_id, vp);

    mpls_port->mpls_port_id = mpls_port_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_match_add(unit, vpn, mpls_port, vp));
    match_added = 1;

    if ((mpls_port->flags & BCM_MPLS_PORT_NETWORK) &&
        (!(mpls_port->flags & BCM_MPLS_PORT_FAILOVER))) {
        if (mpls_port->flags & BCM_MPLS_PORT_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mpls_port_vc_label_idx_get(unit, vp, &old_vc_label_idx));
        }

        sal_memset(&label_info, 0, sizeof(label_info));
        label_info.vc_label = mpls_port->egress_label.label;
        label_info.exp      = mpls_port->egress_label.exp;
        label_info.ttl      = mpls_port->egress_label.ttl;
        flags               = mpls_port->egress_label.flags;
        if ((flags & BCM_MPLS_EGRESS_LABEL_ENTROPY_ENABLE) ||
            (mpls_port->flags & BCM_MPLS_PORT_ENTROPY_ENABLE)){
           label_info.proc_ctrl |=  EGR_LABL_CTRL_ENTROPY_LABL;
        }

        if (mpls_port->flags & BCM_MPLS_PORT_SEQUENCED) {
           label_info.proc_ctrl |=  EGR_LABL_CTRL_CW |
                                    EGR_LABL_CTRL_CW_SEQUENCED;
        } else if (mpls_port->flags & BCM_MPLS_PORT_CONTROL_WORD) {
            label_info.proc_ctrl |=  EGR_LABL_CTRL_CW;
        }

        if (!(flags & BCM_MPLS_EGRESS_LABEL_TTL_SET)) {
            label_info.proc_ctrl |=  EGR_LABL_CTRL_USE_PLD_TTL;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_alloc(unit, 0, tbl_id, user_id,
                                           (void *)&label_info,
                                           &vc_label_idx));
        vc_label_idx_added = 1;

        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_port_vp_add(unit, vpn, vp, mpls_port, vc_label_idx, tnl_idx));
        vp_configured = 1;

        if (mpls_port->flags & BCM_MPLS_PORT_REPLACE) {
            (void)bcmi_ltsw_idx_tbl_entry_free(unit, 0, tbl_id,
                                               user_id, old_vc_label_idx);
        }

    }

    if (!(mpls_port->flags & BCM_MPLS_PORT_NETWORK)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_port_vp_add(unit, vpn, vp, mpls_port, 0, 0));
        vp_configured = 1;
    }
    if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_dvp_set(unit, mpls_port->encap_id,
                                  BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp)));
        XFS_VPLESS_EGRESS_IF_SET(unit,
                                 BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp),
                                 mpls_port->encap_id);
    } else if (mpls_port->flags & BCM_MPLS_PORT_NETWORK) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_egress_obj_set(unit, mpls_port_id,
                                                   mpls_port->encap_id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_dvp_set(unit, mpls_port->encap_id, vp));
    }

    if (mpls_port->flags2 & BCM_MPLS_PORT2_ENCAP_CASCADED) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_cascaded_set(unit,
                                                 mpls_port->mpls_port_id,
                                                 1));
    }

    if ((mpls_port->flags & BCM_MPLS_PORT_NETWORK) &&
        (mpls_port->flags & BCM_MPLS_PORT_REPLACE) &&
        !(mpls_port->flags & BCM_MPLS_PORT_FAILOVER)) {
        if (old_encap_id != mpls_port->encap_id) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mpls_encap_id_notify(unit, mpls_port));
        }
    }

exit:
    if (SHR_FUNC_ERR() && !(mpls_port->flags & BCM_MPLS_PORT_REPLACE)) {
        if (vp != -1) {
            if (!BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
                (void)bcmi_ltsw_virtual_vp_free(unit,
                                                BCMI_LTSW_VP_TYPE_MPLS, 1, vp);
            }
        }

        if (match_added) {
            (void)mpls_port_match_delete(unit, vp);
        }

        if (vc_label_idx_added) {
            (void)bcmi_ltsw_idx_tbl_entry_free(unit, 0, tbl_id,
                                               user_id, vc_label_idx);
        }

        if (vp_configured) {
            (void)mpls_port_vp_delete(unit, vp);
        }
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_port_get(
    int unit,
    bcm_vpn_t vpn,
    bcm_gport_t mpls_port_id,
    bcm_mpls_port_t *mpls_port)
{
    int vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);

    SHR_FUNC_ENTER(unit);

    bcm_mpls_port_t_init(mpls_port);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_validate(unit, mpls_port_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_match_get(unit, vp, mpls_port));

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_vp_get(unit, vp, mpls_port));

    mpls_port->mpls_port_id = mpls_port_id;

    if ((mpls_port->flags2 & BCM_MPLS_PORT2_INGRESS_ENTROPY_ENABLE) &&
       (mpls_port->egress_label.flags & BCM_MPLS_EGRESS_LABEL_ENTROPY_ENABLE)) {
       mpls_port->flags |= BCM_MPLS_PORT_ENTROPY_ENABLE;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_vpls_port_get_all(
    int unit,
    bcm_vpn_t vpn,
    int port_max,
    bcm_mpls_port_t *port_array,
    int *port_count)
{
    uint32_t vp_start = 0, vp_end = 0;
    int vp, vpless_vp;
    int vp_used;
    int count = 0;
    bcm_gport_t mpls_port_id;
    xfs_mpls_vp_info_t vp_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_range_get(unit, &vp_start, &vp_end));

    for (vp = vp_start; vp <= vp_end; vp++) {
        vp_used = !bcmi_ltsw_virtual_vp_used_get(unit, vp,
                                                 BCMI_LTSW_VP_TYPE_MPLS);
        if (!vp_used) {
            continue;
        }

        mpls_vp_info_get(unit, vp, &vp_info);
        if (vp_info.vpn != vpn) {
            continue;
        }

        if (vp_info.vpless) {
            if (count < port_max) {
                vpless_vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_SET(vp);
                BCM_GPORT_MPLS_PORT_ID_SET(mpls_port_id, vpless_vp);
                SHR_IF_ERR_VERBOSE_EXIT
                    (xfs_ltsw_mpls_port_get(unit, vpn,
                                            mpls_port_id, &port_array[count]));
            }
            count++;
        }

        if (count < port_max) {
            BCM_GPORT_MPLS_PORT_ID_SET(mpls_port_id, vp);
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ltsw_mpls_port_get(unit, vpn,
                                        mpls_port_id, &port_array[count]));
        }
        count++;
    }
    *port_count = count;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_port_delete(
    int unit,
    bcm_vpn_t vpn,
    bcm_gport_t mpls_port_id)
{
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN;
    uint8_t user_id = BCMI_EGR_MPLS_VPN_USER_ID_MPLS;
    int vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);
    xfs_mpls_vp_info_t vp_info;
    int vpless_vp = 0, fo_vp;
    int vc_label_idx;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_validate(unit, mpls_port_id));

    if (BCMINT_MPLS_GPORT_FAILOVER_VPLESS_GET(vp)) {
        vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_CLEAR(vp);
        vpless_vp = 1;
    }

    sal_memset(&vp_info, 0, sizeof(xfs_mpls_vp_info_t));

    mpls_vp_info_get(unit, vp, &vp_info);

    if (!vpless_vp && vp_info.vpless) {
        /*
         * For a vp which has a vpless port,
         * the vpless port should be deleted first.
         */
        fo_vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_SET(vp);
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_port_match_delete(unit, fo_vp));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_match_delete(unit,
                                BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id)));

    if (vpless_vp) {
        /* The vp and vpless vp share the vp-based properties. */
        SHR_EXIT();
    }

    if ((vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL) ||
        (vp_info.criteria == BCM_MPLS_PORT_MATCH_LABEL_PORT_GROUP) ) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_port_vc_label_idx_get(unit, vp, &vc_label_idx));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_egress_obj_set(unit, mpls_port_id, 0));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_free(unit, 0, tbl_id,
                                          user_id, vc_label_idx));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_vp_delete(unit, vp));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_free(unit, BCMI_LTSW_VP_TYPE_MPLS, 1, vp));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_vpls_port_delete_by_vpn(
    int unit,
    bcm_vpn_t vpn)
{
    uint32_t vp_start = 0, vp_end = 0;
    int vp, vpless_vp;
    int vp_used;
    bcm_gport_t mpls_port_id;
    xfs_mpls_vp_info_t vp_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_range_get(unit, &vp_start, &vp_end));

    for (vp = vp_start; vp <= vp_end; vp++) {
        vp_used = !bcmi_ltsw_virtual_vp_used_get(unit, vp,
                                                 BCMI_LTSW_VP_TYPE_MPLS);
        if (!vp_used) {
            continue;
        }

        mpls_vp_info_get(unit, vp, &vp_info);
        if (vp_info.vpn != vpn) {
            continue;
        }

        if (vp_info.vpless) {
            /* Delete the vpless port first. */
            vpless_vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_SET(vp);
            BCM_GPORT_MPLS_PORT_ID_SET(mpls_port_id, vpless_vp);
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ltsw_mpls_port_delete(unit, vpn, mpls_port_id));
        }

        BCM_GPORT_MPLS_PORT_ID_SET(mpls_port_id, vp);
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_mpls_port_delete(unit, vpn, mpls_port_id));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_vpls_port_delete_all(int unit)
{
    uint32_t vp_start = 0, vp_end = 0;
    int vp, vpless_vp;
    int vp_used;
    bcm_gport_t mpls_port_id;
    xfs_mpls_vp_info_t vp_info;
    bcm_vpn_t vpn;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_range_get(unit, &vp_start, &vp_end));

    for (vp = vp_start; vp <= vp_end; vp++) {
        vp_used = !bcmi_ltsw_virtual_vp_used_get(unit, vp,
                                                 BCMI_LTSW_VP_TYPE_MPLS);
        if (!vp_used) {
            continue;
        }

        mpls_vp_info_get(unit, vp, &vp_info);
        if(!BCMI_LTSW_VIRTUAL_VPN_IS_VPLS(vp_info.vpn)) {
            continue;
        }

        vpn = vp_info.vpn;
        if (vp_info.vpless) {
            /* Delete the vpless port first. */
            vpless_vp = BCMINT_MPLS_GPORT_FAILOVER_VPLESS_SET(vp);
            BCM_GPORT_MPLS_PORT_ID_SET(mpls_port_id, vpless_vp);
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ltsw_mpls_port_delete(unit, vpn, mpls_port_id));
        }

        BCM_GPORT_MPLS_PORT_ID_SET(mpls_port_id, vp);
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_mpls_port_delete(unit, vpn, mpls_port_id));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_port_attach(
    int unit,
    bcm_gport_t src_port_id,
    bcm_gport_t dst_port_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_connection_enable(unit, src_port_id, dst_port_id, 1));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_port_detach(
    int unit,
    bcm_gport_t mpls_port_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_connection_enable(unit, BCM_GPORT_INVALID, mpls_port_id, 0));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_port_validate(
    int unit,
    bcm_gport_t mpls_port_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_validate(unit, mpls_port_id));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_vlan_list_get(
    int unit,
    int *vlan_cnt,
    int *vlan_list)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    int rv = SHR_E_NONE;
    lt_mpls_entry_t entry;
    int count = 0;
    const bcmint_mpls_lt_t *lt_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_1, &lt_info));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &ent_hdl));

    while ((rv = bcmi_lt_entry_commit(
                     unit, ent_hdl,
                     BCMLT_OPCODE_TRAVERSE,
                     BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        sal_memset(&entry, 0, sizeof(lt_mpls_entry_t));

        entry.fld_bmp |= ME_FLD_LABEL_ACTION | ME_FLD_L3_IIF_VFI_NH2;
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_x_entry_from_hdl(unit, &entry, ent_hdl));

        if (entry.label_action != bcmintLtswMplsFwdLabelActionPopSwitch) {
            continue;
        }

        if ((entry.l3_iif_vfi_nh2 == 0) ||
            (entry.l3_iif_vfi_nh2 > BCM_VLAN_MAX))  {
            continue;
        }

        if (vlan_list[entry.l3_iif_vfi_nh2] == 0) {
            count++;
            vlan_list[entry.l3_iif_vfi_nh2] = 1;
        }
    }

    *vlan_cnt = count;

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_special_label_identifier_add(
    int unit,
    bcm_mpls_special_label_t label_info)
{
    uint32_t mpls_hdr, mpls_hdr_mask;
    lt_tnl_mpls_special_label_entry_t entry;
    int  existed = 0, index = -1;
    bcm_mpls_special_label_t curr_li;

    SHR_FUNC_ENTER(unit);

    /*
     * Not supported in all NPL devices due to container limitation
     * but could be supported by a new NPL in the future.
     */
    if (label_info.flags & BCM_MPLS_SPECIAL_LABEL_NEXT_LABEL_EXCLUDE_HASH ||
        label_info.flags & BCM_MPLS_SPECIAL_LABEL_CURR_LABEL_EXCLUDE_HASH) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    BUILD_MPLS_HDR(mpls_hdr,
                   label_info.label_value, label_info.exp,
                   !!(label_info.flags & BCM_MPLS_SPECIAL_LABEL_BOS_PRESENT),
                   label_info.ttl);

    BUILD_MPLS_HDR(mpls_hdr_mask,
                   label_info.label_mask, label_info.exp_mask,
                   !!(label_info.flags & BCM_MPLS_SPECIAL_LABEL_BOS_MASKED),
                   label_info.ttl_mask);

    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_mpls_special_label_index_alloc(unit,
                                            mpls_hdr,
                                            mpls_hdr_mask,
                                            &existed,
                                            &index));

    if (existed) {
        sal_memcpy(&curr_li, &label_info, sizeof(label_info));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_mpls_special_label_identifier_get(unit, &curr_li));
        if (curr_li.flags != label_info.flags) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_EXISTS);
        }
        SHR_EXIT();
    }


    label_identifier_to_tnl_mpls_special_label_entry(unit,
                                                     index,
                                                     &label_info,
                                                     &entry);

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_tnl_mpls_special_label_op(unit, BCMLT_OPCODE_INSERT, &entry));

exit:
    if (SHR_FUNC_ERR()) {
        if (!existed && (index != -1)) {
            tnl_mpls_special_label_index_free(unit, index);
        }
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_special_label_identifier_get(
    int unit,
    bcm_mpls_special_label_t *label_info)
{
    lt_tnl_mpls_special_label_entry_t entry;
    int index;

    SHR_FUNC_ENTER(unit);

    sal_memset(&entry, 0, sizeof(lt_tnl_mpls_special_label_entry_t));

    BUILD_MPLS_HDR(entry.mpls_header,
                   label_info->label_value, label_info->exp,
                   !!(label_info->flags & BCM_MPLS_SPECIAL_LABEL_BOS_PRESENT),
                   label_info->ttl);

    BUILD_MPLS_HDR(entry.mpls_header_mask,
                   label_info->label_mask, label_info->exp_mask,
                   !!(label_info->flags & BCM_MPLS_SPECIAL_LABEL_BOS_MASKED),
                   label_info->ttl_mask);

    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_mpls_special_label_index_get(unit, entry.mpls_header,
                                          entry.mpls_header_mask,
                                          &index));

    entry.index = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_tnl_mpls_special_label_op(unit, BCMLT_OPCODE_LOOKUP, &entry));

    label_identifier_from_tnl_mpls_special_label_entry(unit,
                                                       label_info,
                                                       &entry);
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_special_label_identifier_delete(
    int unit,
    bcm_mpls_special_label_t label_info)
{
    lt_tnl_mpls_special_label_entry_t entry;
    int index;

    SHR_FUNC_ENTER(unit);

    sal_memset(&entry, 0, sizeof(lt_tnl_mpls_special_label_entry_t));

    BUILD_MPLS_HDR(entry.mpls_header,
                   label_info.label_value, label_info.exp,
                   !!(label_info.flags & BCM_MPLS_SPECIAL_LABEL_BOS_PRESENT),
                   label_info.ttl);

    BUILD_MPLS_HDR(entry.mpls_header_mask,
                   label_info.label_mask, label_info.exp_mask,
                   !!(label_info.flags & BCM_MPLS_SPECIAL_LABEL_BOS_MASKED),
                   label_info.ttl_mask);

    SHR_IF_ERR_VERBOSE_EXIT
        (tnl_mpls_special_label_index_get(unit, entry.mpls_header,
                                          entry.mpls_header_mask,
                                          &index));
    entry.index = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_tnl_mpls_special_label_op(unit, BCMLT_OPCODE_DELETE, &entry));

    tnl_mpls_special_label_index_free(unit, index);
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_special_label_identifier_delete_all(int unit)
{
    xfs_mpls_special_label_control_t *lbl_ctrl = XFS_SPECIAL_LABEL_CTRL(unit);
    uint32_t    num_entry = XFS_SPECIAL_LABEL_TBL_SZ(unit);
    int i;
    lt_tnl_mpls_special_label_entry_t entry;

    SHR_FUNC_ENTER(unit);

    sal_memset(&entry, 0, sizeof(lt_tnl_mpls_special_label_entry_t));
    for (i = 0; i < num_entry; i++) {
        if (!(lbl_ctrl[i].used)) {
            continue;
        }

        entry.index = i;
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tnl_mpls_special_label_op(unit, BCMLT_OPCODE_DELETE, &entry));

        sal_memset(&lbl_ctrl[i],
                   0,
                   sizeof(xfs_mpls_special_label_control_t));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_special_label_identifier_traverse(
    int unit,
    bcm_mpls_special_label_identifier_traverse_cb cb,
    void *user_data)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    int rv = SHR_E_NONE;
    lt_tnl_mpls_special_label_entry_t entry;
    bcm_mpls_special_label_t label_info;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_SPECIAL_LABELs, &ent_hdl));

    while ((rv = bcmi_lt_entry_commit(
                     unit, ent_hdl,
                     BCMLT_OPCODE_TRAVERSE,
                     BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        sal_memset(&entry, 0, sizeof(lt_tnl_mpls_special_label_entry_t));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tnl_mpls_special_label_entry_from_hdl(unit, &entry, ent_hdl));

        sal_memset(&label_info, 0, sizeof(label_info));
        label_identifier_from_tnl_mpls_special_label_entry(unit,
                                                           &label_info,
                                                           &entry);

        rv = cb(unit, NULL, &label_info, user_data);
        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_global_label_range_set(
    int unit,
    int range_num,
    int range_min,
    int label_val)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (range_num < 0 || range_num > 2) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_GLOBAL_LABEL_RANGEs, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_field_add(ent_hdl,
                                TNL_MPLS_GLOBAL_LABEL_RANGE_IDs,
                                range_num));

    if (range_min) {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl, MIN_LABELs, label_val));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl, MAX_LABELs, label_val));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, ent_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_global_label_range_get(
    int unit,
    int range_num,
    int *min_label,
    int *max_label)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    uint64_t value = 0;
    int rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (range_num < 0 || range_num > 2) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_GLOBAL_LABEL_RANGEs, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_field_add(ent_hdl,
                                TNL_MPLS_GLOBAL_LABEL_RANGE_IDs,
                                range_num));

    rv = bcmi_lt_entry_commit(unit, ent_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);

    if (rv == SHR_E_NOT_FOUND) {
        if (min_label) {
            *min_label = 0;
        }

        if (max_label) {
            *max_label = 0;
        }
        SHR_EXIT();
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (min_label) {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_get(ent_hdl, MIN_LABELs, &value));
        *min_label = (int)value;
    }

    if (max_label) {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_get(ent_hdl, MAX_LABELs, &value));
        *max_label = (int)value;
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_global_control_set(
    int unit,
    bcmi_ltsw_mpls_global_ctrl_t control_type,
    int value)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const char *field_name;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_global_ctrl_type_to_lt_field(unit, control_type, &field_name));

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_CONTROLs, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_field_add(ent_hdl, field_name, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, ent_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_global_control_get(
    int unit,
    bcmi_ltsw_mpls_global_ctrl_t control_type,
    int *value)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const char *field_name;
    uint64_t fld_val = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_global_ctrl_type_to_lt_field(unit, control_type, &field_name));

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_CONTROLs, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, ent_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_field_get(ent_hdl, field_name, &fld_val));

    if (value) {
        *value = (int)fld_val;
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_encap_label_add(
    int unit,
    bcmi_ltsw_mpls_encap_label_info_t *label_info,
    int *label_index)
{
    encap_label_info_t encap_info;
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN;
    uint8_t user_id = BCMI_EGR_MPLS_VPN_USER_ID_MPLS;
    int vc_label_idx;

    SHR_FUNC_ENTER(unit);

    sal_memset(&encap_info, 0, sizeof(encap_info));
    encap_info.vc_label = label_info->vc_label;
    encap_info.exp      = label_info->exp;
    encap_info.ttl      = label_info->ttl;

    if (label_info->flags & BCMI_LTSW_MPLS_ENCAP_LABL_ENTROPY_LABL) {
       encap_info.proc_ctrl |=  EGR_LABL_CTRL_ENTROPY_LABL;
    }

    if (label_info->flags & BCMI_LTSW_MPLS_ENCAP_LABL_USE_PLD_TTL) {
       encap_info.proc_ctrl |=  EGR_LABL_CTRL_USE_PLD_TTL;
    }

    if (label_info->flags & BCMI_LTSW_MPLS_ENCAP_LABL_CW) {
       encap_info.proc_ctrl |=  EGR_LABL_CTRL_CW;
       if (label_info->flags & BCMI_LTSW_MPLS_ENCAP_LABL_CW_SEQUENCED) {
          encap_info.proc_ctrl |=  EGR_LABL_CTRL_CW_SEQUENCED;
       }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_alloc(unit, 0, tbl_id, user_id,
                                       (void *)&encap_info,
                                       &vc_label_idx));
    if (label_index) {
        *label_index = vc_label_idx;
    }

exit:
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_encap_label_get(
    int unit,
    int label_index,
    bcmi_ltsw_mpls_encap_label_info_t *label_info)
{
    lt_egr_mpls_vpn_entry_t vpn_entry;
    uint32_t vpn_label_hdr;
    uint32_t process_ctrl;

    SHR_FUNC_ENTER(unit);

    sal_memset(&vpn_entry, 0, sizeof(lt_egr_mpls_vpn_entry_t));
    vpn_entry.vpn_label_index = label_index;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_egr_mpls_vpn_op(unit, BCMLT_OPCODE_LOOKUP, &vpn_entry));


    vpn_label_hdr = vpn_entry.vpn_label_hdr;
    PARSE_MPLS_HDR_NO_BOS(vpn_label_hdr,
                          label_info->vc_label,
                          label_info->exp,
                          label_info->ttl);

    process_ctrl = vpn_entry.process_ctrl;

    if (process_ctrl & EGR_LABL_CTRL_ENTROPY_LABL) {
        label_info->flags |= BCMI_LTSW_MPLS_ENCAP_LABL_ENTROPY_LABL;
    }

    if (process_ctrl & EGR_LABL_CTRL_USE_PLD_TTL) {
        label_info->flags |= BCMI_LTSW_MPLS_ENCAP_LABL_USE_PLD_TTL;
    }

    if (process_ctrl & EGR_LABL_CTRL_CW_SEQUENCED) {
        label_info->flags |= BCMI_LTSW_MPLS_ENCAP_LABL_CW_SEQUENCED;
    } else if (process_ctrl & EGR_LABL_CTRL_CW) {
        label_info->flags |= BCMI_LTSW_MPLS_ENCAP_LABL_CW;
        if (process_ctrl & EGR_LABL_CTRL_CW_SEQUENCED) {
            label_info->flags |= BCMI_LTSW_MPLS_ENCAP_LABL_CW_SEQUENCED;
        }
    }

exit:
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_encap_label_delete(
    int unit,
    int label_index)
{
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN;
    uint8_t user_id = BCMI_EGR_MPLS_VPN_USER_ID_MPLS;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_free(unit, 0, tbl_id, user_id, label_index));

exit:
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_encap_label_ref_inc(
    int unit,
    int label_index)
{
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_MPLS_VPN;
    uint8_t user_id = BCMI_EGR_MPLS_VPN_USER_ID_MPLS;
    uint32_t ref_cnt;
    encap_label_info_t label_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id,
                                         label_index, &ref_cnt));
    if (ref_cnt == 0) {
        sal_memset(&label_info, 0, sizeof(label_info));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_hash_update(unit, tbl_id, user_id,
                                                 &label_info, label_index));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_increase(unit, tbl_id,
                                              user_id, label_index));
exit:
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_port_match_vp_replace(
    int unit,
    bcm_gport_t mpls_port_id,
    int new_vp)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_match_vp_replace(unit, mpls_port_id, new_vp));
exit:
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_port_match_vp_get(
    int unit,
    bcm_gport_t mpls_port_id,
    int *new_vp)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_match_vplag_vp_get(unit, mpls_port_id, new_vp));
exit:
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_control_pkt_add(
    int unit,
    uint32_t options,
    bcm_mpls_control_pkt_match_t *match,
    bcm_mpls_control_pkt_action_t *action)
{
    lt_tnl_mpls_control_pkt_entry_t entry;
    bcmlt_opcode_t opcode;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ctrl_pkt_match_validate(unit, match));

    sal_memset(&entry, 0, sizeof(entry));
    ctrl_pkt_match_to_tnl_mpls_control_pkt_entry(unit, match, &entry);

    ctrl_pkt_action_to_tnl_mpls_control_pkt_entry(unit, action, &entry);

    opcode = BCMLT_OPCODE_INSERT;
    if (options & BCM_MPLS_CONTROL_PKT_OPTIONS_REPLACE) {
        opcode = BCMLT_OPCODE_UPDATE;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_tnl_mpls_control_pkt_op(unit, opcode, &entry));

exit:
    MPLS_TNL_UNLOCK(unit);
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_control_pkt_get(
    int unit,
    bcm_mpls_control_pkt_match_t *match,
    bcm_mpls_control_pkt_action_t *action)
{
    lt_tnl_mpls_control_pkt_entry_t entry;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ctrl_pkt_match_validate(unit, match));

    sal_memset(&entry, 0, sizeof(entry));
    ctrl_pkt_match_to_tnl_mpls_control_pkt_entry(unit, match, &entry);

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_tnl_mpls_control_pkt_op(unit, BCMLT_OPCODE_LOOKUP, &entry));

    ctrl_pkt_action_from_tnl_mpls_control_pkt_entry(unit, action, &entry);

exit:
    MPLS_TNL_UNLOCK(unit);
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_control_pkt_delete(
    int unit,
    bcm_mpls_control_pkt_match_t *match)
{
    lt_tnl_mpls_control_pkt_entry_t entry;

    SHR_FUNC_ENTER(unit);
    MPLS_TNL_LOCK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ctrl_pkt_match_validate(unit, match));

    sal_memset(&entry, 0, sizeof(entry));
    ctrl_pkt_match_to_tnl_mpls_control_pkt_entry(unit, match, &entry);

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_tnl_mpls_control_pkt_op(unit, BCMLT_OPCODE_DELETE, &entry));

exit:
    MPLS_TNL_UNLOCK(unit);
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_control_pkt_traverse(
    int unit,
    bcm_mpls_control_pkt_traverse_cb cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ctrl_pkt_traverse(unit, bcmi_ltsw_dev_cb_err_abort(unit),
                           cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_mpls_control_pkt_delete_all(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ctrl_pkt_traverse(unit, 1, ctrl_pkt_delete_all_trav_cb, NULL));

exit:
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_label_stat_get(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t mpls_port,
    bcm_mpls_stat_t stat,
    uint64_t *val)
{
    int dunit;
    const bcmint_mpls_lt_t *lt_info = NULL;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    lt_mpls_entry_t mpls_entry;
    lt_tnl_pw_decap_seq_num_entry_t pw_decap_seq_num_entry;
    lt_egr_dvp_entry_t egr_dvp_entry;
    uint32_t cnt;
    int rv;
    int pipe;

    SHR_FUNC_ENTER(unit);
    switch (stat) {
    case bcmMplsOutPkts:
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_port_validate(unit, mpls_port));
        sal_memset(&egr_dvp_entry, 0, sizeof(egr_dvp_entry));
        egr_dvp_entry.dvp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port);
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_egr_dvp_op(unit, BCMLT_OPCODE_LOOKUP, &egr_dvp_entry));
        for (pipe = 0; pipe < bcmi_ltsw_dev_max_pp_pipe_num(unit); pipe++) {
            rv = bcmi_ltsw_tunnel_encap_seq_num_get(unit,
                                                    egr_dvp_entry.seq_num_cnt_idx,
                                                    pipe,
                                                    &cnt);
            if (rv == SHR_E_NOT_FOUND) {
                cnt = 0;
            } else if (SHR_FAILURE(rv)) {
                SHR_ERR_EXIT(rv);
            }
            *val += cnt;
        }
        break;
    case bcmMplsInPkts:
        sal_memset(&mpls_entry, 0, sizeof(mpls_entry));
        mpls_entry.label = label;

        if (mpls_port != BCM_PORT_INVALID) {
            mpls_entry.label_conext_id = (uint32_t)mpls_port;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_1, &lt_info));

        dunit = bcmi_ltsw_dev_dunit(unit);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, lt_info->name, &ent_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_x_op(unit, BCMLT_OPCODE_LOOKUP, ent_hdl, &mpls_entry));

        for (pipe = 0; pipe < bcmi_ltsw_dev_max_pp_pipe_num(unit); pipe++) {
            sal_memset(&pw_decap_seq_num_entry, 0, sizeof(pw_decap_seq_num_entry));
            pw_decap_seq_num_entry.index = mpls_entry.pw_term_num;
            pw_decap_seq_num_entry.pipe  = pipe;
            rv = lt_tnl_pw_decap_seq_num_op(unit, BCMLT_OPCODE_LOOKUP,
                                            &pw_decap_seq_num_entry);
            if (rv == SHR_E_NOT_FOUND) {
                SHR_ERR_EXIT(SHR_E_CONFIG);
            } else if (SHR_FAILURE(rv)) {
                SHR_ERR_EXIT(rv);
            }
            *val += pw_decap_seq_num_entry.seq_num;
        }
        break;
    default:
        SHR_IF_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    if (ent_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();

}

int
xfs_ltsw_mpls_label_stat_clear(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t mpls_port,
    bcm_mpls_stat_t stat)
{
    const bcmint_mpls_lt_t *lt_info = NULL;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    lt_mpls_entry_t mpls_entry;
    lt_tnl_pw_decap_seq_num_entry_t pw_decap_seq_num_entry;
    lt_egr_dvp_entry_t egr_dvp_entry;
    int dunit;
    int rv;
    int pipe;

    SHR_FUNC_ENTER(unit);
    switch (stat) {
    case bcmMplsOutPkts:
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_port_validate(unit, mpls_port));
        sal_memset(&egr_dvp_entry, 0, sizeof(egr_dvp_entry));
        egr_dvp_entry.dvp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port);
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_egr_dvp_op(unit, BCMLT_OPCODE_LOOKUP, &egr_dvp_entry));
        for (pipe = 0; pipe < bcmi_ltsw_dev_max_pp_pipe_num(unit); pipe++) {
            rv = bcmi_ltsw_tunnel_encap_seq_num_set(unit,
                                                    egr_dvp_entry.seq_num_cnt_idx,
                                                    pipe,
                                                    0);
            if (rv == SHR_E_NOT_FOUND) {
                continue;
            } else if (SHR_FAILURE(rv)) {
                SHR_ERR_EXIT(rv);
            }
        }
        break;
    case bcmMplsInPkts:
        sal_memset(&mpls_entry, 0, sizeof(mpls_entry));
        mpls_entry.label = label;
        mpls_entry.label_conext_id = (uint32_t)mpls_port;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_MPLS_ENTRY_1, &lt_info));

        dunit = bcmi_ltsw_dev_dunit(unit);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, lt_info->name, &ent_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_entry_x_op(unit, BCMLT_OPCODE_LOOKUP, ent_hdl, &mpls_entry));

        sal_memset(&pw_decap_seq_num_entry, 0, sizeof(pw_decap_seq_num_entry));
        pw_decap_seq_num_entry.index = mpls_entry.pw_term_num;
        for (pipe = 0; pipe < bcmi_ltsw_dev_max_pp_pipe_num(unit); pipe++) {
            pw_decap_seq_num_entry.pipe = pipe;
            rv = lt_tnl_pw_decap_seq_num_op(unit,
                                            BCMLT_OPCODE_UPDATE,
                                            &pw_decap_seq_num_entry);
            if (rv == SHR_E_NOT_FOUND) {
                SHR_ERR_EXIT(SHR_E_CONFIG);
            } else if (SHR_FAILURE(rv)) {
                SHR_ERR_EXIT(rv);
            }
        }
        break;
    default:
        SHR_IF_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    if (ent_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(ent_hdl);
    }
    SHR_FUNC_EXIT();

}

int
xfs_ltsw_mpls_port_match_set(
    int unit,
    bcm_gport_t mpls_port_id,
    bcmi_ltsw_mpls_port_match_t *match)
{
    bcmi_ltsw_vlan_ing_xlate_cfg_t cfg;
    bcm_vlan_translate_key_t key_type = bcmiLtswMplsPortMatchPortGrpVlan;
    int rv;
    int vp;
    int update = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_match_param_validate(unit, mpls_port_id, match));

    sal_memset(&cfg, 0, sizeof(cfg));

    mpls_port_match_criteria_to_vlan_xlate_key_type(unit, match->criteria,
                                                    &key_type);

    rv = bcmi_ltsw_vlan_ing_xlate_get(unit, key_type, match->port_group,
                                      match->match_vlan,
                                      match->match_inner_vlan, &cfg);
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_NOT_FOUND);

    cfg.fld_bmp |= BCMI_LTSW_VLAN_ING_XLATE_FLD_SVP;
    cfg.fld_bmp |= BCMI_LTSW_VLAN_ING_XLATE_FLD_VFI;
    cfg.fld_bmp |= BCMI_LTSW_VLAN_ING_XLATE_FLD_TAG_ACTIONS;
    cfg.svp      = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);
    BCMI_LTSW_VIRTUAL_VPN_GET(cfg.vfi, BCM_VPN_TYPE_MPLS_VPLS, match->vpn);
    cfg.otag_action = match->action.outer_tag;
    cfg.itag_action = match->action.inner_tag;

    update = (rv == SHR_E_NONE) ? 1 : 0;
    if (update) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_vlan_ing_xlate_update(unit, key_type, match->port_group,
                                             match->match_vlan,
                                             match->match_inner_vlan, &cfg));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_vlan_ing_xlate_add(unit, key_type, match->port_group,
                                          match->match_vlan,
                                          match->match_inner_vlan, &cfg));
    }

    if (!update) {
        vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);
        MATCH_COUNT_UPDATE(unit, vp, 1);
    }

exit:
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_port_match_clear(
    int unit,
    bcm_gport_t mpls_port_id,
    bcmi_ltsw_mpls_port_match_t *match)
{
    bcmi_ltsw_vlan_ing_xlate_cfg_t cfg;
    bcm_vlan_translate_key_t key_type = bcmiLtswMplsPortMatchPortGrpVlan;
    int vp;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_match_param_validate(unit, mpls_port_id, match));

    sal_memset(&cfg, 0, sizeof(cfg));

    mpls_port_match_criteria_to_vlan_xlate_key_type(unit, match->criteria,
                                                    &key_type);

    SHR_IF_ERR_VERBOSE_EXIT
           (bcmi_ltsw_vlan_ing_xlate_delete(unit, key_type, match->port_group,
                                            match->match_vlan,
                                            match->match_inner_vlan));
    vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);
    MATCH_COUNT_UPDATE(unit, vp, -1);

exit:
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_port_match_multi_get(
    int unit,
    bcm_gport_t mpls_port_id,
    int size,
    bcmi_ltsw_mpls_port_match_t *match_array,
    int *count)
{
    mpls_port_match_ivxlate_user_data_t ud;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_port_validate(unit, mpls_port_id));

    sal_memset(&ud, 0, sizeof(ud));
    ud.array    = match_array;
    ud.size     = size;
    ud.match_vp = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_ing_xlate_traverse(unit,
                                           mpls_port_match_multi_get_trav_cb,
                                           (void *)&ud));
    if (count) {
        *count = ud.count;
    }

exit:
    SHR_FUNC_EXIT()
}

int
xfs_ltsw_mpls_port_match_delete_all(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_ing_xlate_traverse(unit,
                                           mpls_port_match_delete_all_trav_cb,
                                           NULL));


exit:
    SHR_FUNC_EXIT()
}

