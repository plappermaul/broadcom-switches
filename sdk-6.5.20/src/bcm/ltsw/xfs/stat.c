/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/stat.h>
#include <bcm_int/ltsw/stat_int.h>

#include <bcm_int/ltsw/xfs/stat.h>
#include <bcm_int/ltsw/mbcm/stat.h>
#include <bcm_int/ltsw/lt_intf.h>

#include <shr/shr_debug.h>
#include <shr/shr_util.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_STAT

/******************************************************************************
 * Private functions
 */


static bcmi_ltsw_stat_counter_control_t
    *ltsw_counter_control[BCM_MAX_NUM_UNITS];

static int drop_index[BCM_MAX_NUM_UNITS][bcmPktDropEventCount];
static int trace_index[BCM_MAX_NUM_UNITS][bcmPktTraceEventCount];

static int
xfs_stat_drop_event_counter_init(int unit)
{
    bcmint_stat_db_t stat_db = {
        .drop_event_table_info = NULL,
        .num_drop_event = 0,
        .trace_event_table_info = NULL,
        .num_trace_event = 0,
    };
    bcmi_lt_entry_t lt_entry;
    const char *table = NULL;
    const char *event_id = NULL;
    int idx;
    bcmi_lt_field_t fields[] =
    {
        /* 0 */ {NULL, BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    /* Get the per-variant drop event mapping table. */
    SHR_IF_ERR_EXIT
        (mbcm_ltsw_stat_db_get(unit, &stat_db));

    lt_entry.fields = fields;
    lt_entry.nfields = sizeof(fields) / sizeof(fields[0]);
    lt_entry.attr = 0;

    for (idx = 0; idx < stat_db.num_drop_event; idx++) {
        table = stat_db.drop_event_table_info[idx].table;
        event_id = stat_db.drop_event_table_info[idx].field;
        if (sal_strcmp(table, CTR_ING_DROP_EVENTs) == 0) {
            fields[0].fld_name = CTR_ING_DROP_EVENT_IDs;
        } else {
            fields[0].fld_name = CTR_EGR_DROP_EVENT_IDs;
        }
        fields[0].u.sym_val = event_id;
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_insert(unit, table, &lt_entry, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
xfs_stat_trace_event_counter_init(int unit)
{
    bcmint_stat_db_t stat_db = {
        .drop_event_table_info = NULL,
        .num_drop_event = 0,
        .trace_event_table_info = NULL,
        .num_trace_event = 0,
    };
    bcmi_lt_entry_t lt_entry;
    const char *table = NULL;
    const char *event_id = NULL;
    int idx;
    bcmi_lt_field_t fields[] =
    {
        /* 0 */ {NULL, BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    /* Get the per-variant drop event mapping table. */
    SHR_IF_ERR_EXIT
        (mbcm_ltsw_stat_db_get(unit, &stat_db));

    lt_entry.fields = fields;
    lt_entry.nfields = sizeof(fields) / sizeof(fields[0]);
    lt_entry.attr = 0;

    for (idx = 0; idx < stat_db.num_trace_event; idx++) {
        table = stat_db.trace_event_table_info[idx].table;
        event_id = stat_db.trace_event_table_info[idx].field;
        if (sal_strcmp(table, CTR_ING_TRACE_EVENTs) == 0) {
            fields[0].fld_name = CTR_ING_TRACE_EVENT_IDs;
        } else {
            fields[0].fld_name = CTR_EGR_TRACE_EVENT_IDs;
        }
        fields[0].u.sym_val = event_id;
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_insert(unit, table, &lt_entry, NULL));
    }

exit:
    SHR_FUNC_EXIT();

}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_stat_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Insert drop event counter table entries */
    SHR_IF_ERR_EXIT
        (xfs_stat_drop_event_counter_init(unit));

    /* Insert trace event counter table entries */
    SHR_IF_ERR_EXIT
        (xfs_stat_trace_event_counter_init(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stat_detach(int unit)
{
    bcmi_ltsw_stat_counter_control_t *ltsw_ctr_ctrl = NULL;

    SHR_FUNC_ENTER(unit);

    ltsw_ctr_ctrl = ltsw_counter_control[unit];
    if (ltsw_ctr_ctrl != NULL) {
        SHR_FREE(ltsw_ctr_ctrl->counter_non_dma);
        SHR_FREE(ltsw_ctr_ctrl);
        ltsw_counter_control[unit] = NULL;
    }

    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stat_index_init(
    int unit,
    const bcmint_stat_dev_info_t *dev_info)
{
    bcmint_stat_db_t stat_db = {
        .drop_event_table_info = NULL,
        .num_drop_event = 0,
        .trace_event_table_info = NULL,
        .num_trace_event = 0,
    };
    int index;

    SHR_FUNC_ENTER(unit);

    memset(drop_index[unit], -1, sizeof(drop_index[unit]));
    memset(trace_index[unit], -1, sizeof(trace_index[unit]));

    /* Get the per-variant mapping table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_stat_db_get(unit, &stat_db));

    index = 0;
    while (index < stat_db.num_drop_event) {
        drop_index[unit][stat_db.drop_event_table_info[index].type] = index;
        index++;
    }

    index = 0;
    while (index < stat_db.num_trace_event) {
        trace_index[unit][stat_db.trace_event_table_info[index].type] = index;
        index++;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stat_lt_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Remove CTR_ING_DROP_EVENT LT entries */
    SHR_IF_ERR_CONT
        (bcmi_lt_clear(unit, CTR_ING_DROP_EVENTs));

    /* Remove CTR_EGR_DROP_EVENT LT entries */
    SHR_IF_ERR_CONT
        (bcmi_lt_clear(unit, CTR_EGR_DROP_EVENTs));

    /* Remove CTR_ING_TRACE_EVENT LT entries */
    SHR_IF_ERR_CONT
        (bcmi_lt_clear(unit, CTR_ING_TRACE_EVENTs));

    /* Remove CTR_EGR_TRACE_EVENT LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, CTR_EGR_TRACE_EVENTs));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stat_drop_event_counter_get(
    int unit,
    bool sync_mode,
    bcm_pkt_drop_event_t type,
    uint64_t *val)
{
    bcmint_stat_db_t stat_db = {
        .drop_event_table_info = NULL,
        .num_drop_event = 0,
        .trace_event_table_info = NULL,
        .num_trace_event = 0,
    };
    bcmi_lt_entry_t lt_entry;
    const char *table = NULL;
    const char *event_id = NULL;
    int idx;
    bcmi_lt_field_t fields[] =
    {
        /* 0 */ {NULL, BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /* 1 */ {DROP_CNTs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    if (type < 0 || type >= bcmPktDropEventCount) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Invalid drop event(%d).\n"), type));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if ((drop_index[unit][type] < 0) &&
        (type != bcmPktDropEventIngressAllDrops) &&
        (type != bcmPktDropEventEgressAllDrops)) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Unsupported drop event(%d).\n"), type));
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    SHR_NULL_CHECK(val, SHR_E_PARAM);
    *val = 0;

    /* Get the per-variant drop event mapping table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_stat_db_get(unit, &stat_db));

    lt_entry.fields = fields;
    lt_entry.nfields = sizeof(fields) / sizeof(fields[0]);
    lt_entry.attr = sync_mode ? BCMLT_ENT_ATTR_GET_FROM_HW : 0;

    if (type == bcmPktDropEventIngressAllDrops) {
        fields[0].fld_name = CTR_ING_DROP_EVENT_IDs;
        for (idx = 0; idx < stat_db.num_drop_event; idx++) {
            table = stat_db.drop_event_table_info[idx].table;
            event_id = stat_db.drop_event_table_info[idx].field;
            if ((sal_strcmp(table, CTR_ING_DROP_EVENTs) != 0) ||
                (sal_strcmp(event_id, NO_DROPs) == 0)) {
                continue;
            }
            fields[0].u.sym_val = event_id;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_get(unit, table, &lt_entry, NULL, NULL));
            *val += fields[1].u.val;
        }
    } else if (type == bcmPktDropEventEgressAllDrops) {
        fields[0].fld_name = CTR_EGR_DROP_EVENT_IDs;
        for (idx = 0; idx < stat_db.num_drop_event; idx++) {
            table = stat_db.drop_event_table_info[idx].table;
            event_id = stat_db.drop_event_table_info[idx].field;
            if ((sal_strcmp(table, CTR_EGR_DROP_EVENTs) != 0) ||
                (sal_strcmp(event_id, NO_DROPs) == 0)) {
                continue;
            }
            fields[0].u.sym_val = event_id;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_get(unit, table, &lt_entry, NULL, NULL));
            *val += fields[1].u.val;
        }
    } else {
        table = stat_db.drop_event_table_info[drop_index[unit][type]].table;
        event_id = stat_db.drop_event_table_info[drop_index[unit][type]].field;
        fields[0].u.sym_val = event_id;
        if (sal_strcmp(table, CTR_ING_DROP_EVENTs) == 0) {
            fields[0].fld_name = CTR_ING_DROP_EVENT_IDs;
        } else {
            fields[0].fld_name = CTR_EGR_DROP_EVENT_IDs;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_get(unit, table, &lt_entry, NULL, NULL));
        *val = fields[1].u.val;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stat_drop_event_counter_set(
    int unit,
    bcm_pkt_drop_event_t type,
    uint64_t val)
{
    bcmint_stat_db_t stat_db = {
        .drop_event_table_info = NULL,
        .num_drop_event = 0,
        .trace_event_table_info = NULL,
        .num_trace_event = 0,
    };
    bcmi_lt_entry_t lt_entry;
    const char *table = NULL;
    const char *event_id = NULL;
    int idx;
    bcmi_lt_field_t fields[] =
    {
        /* 0 */ {NULL, BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /* 1 */ {DROP_CNTs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    if (type < 0 || type >= bcmPktDropEventCount) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Invalid drop event(%d).\n"), type));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if ((drop_index[unit][type] < 0) &&
        (type != bcmPktDropEventIngressAllDrops) &&
        (type != bcmPktDropEventEgressAllDrops)) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Unsupported drop event(%d).\n"), type));
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Get the per-variant drop event mapping table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_stat_db_get(unit, &stat_db));

    fields[1].u.val = val;
    lt_entry.fields = fields;
    lt_entry.nfields = sizeof(fields) / sizeof(fields[0]);
    lt_entry.attr = 0;

    if (type == bcmPktDropEventIngressAllDrops) {
        fields[0].fld_name = CTR_ING_DROP_EVENT_IDs;
        for (idx = 0; idx < stat_db.num_drop_event; idx++) {
            table = stat_db.drop_event_table_info[idx].table;
            event_id = stat_db.drop_event_table_info[idx].field;
            if ((sal_strcmp(table, CTR_ING_DROP_EVENTs) != 0) ||
                (sal_strcmp(event_id, NO_DROPs) == 0)) {
                continue;
            }
            fields[0].u.sym_val = event_id;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_set(unit, table, &lt_entry, NULL));
        }
    } else if (type == bcmPktDropEventEgressAllDrops) {
        fields[0].fld_name = CTR_EGR_DROP_EVENT_IDs;
        for (idx = 0; idx < stat_db.num_drop_event; idx++) {
            table = stat_db.drop_event_table_info[idx].table;
            event_id = stat_db.drop_event_table_info[idx].field;
            if ((sal_strcmp(table, CTR_EGR_DROP_EVENTs) != 0) ||
                (sal_strcmp(event_id, NO_DROPs) == 0)) {
                continue;
            }
            fields[0].u.sym_val = event_id;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_set(unit, table, &lt_entry, NULL));
        }
    } else {
        table = stat_db.drop_event_table_info[drop_index[unit][type]].table;
        event_id = stat_db.drop_event_table_info[drop_index[unit][type]].field;
        fields[0].u.sym_val = event_id;
        if (sal_strcmp(table, CTR_ING_DROP_EVENTs) == 0) {
            fields[0].fld_name = CTR_ING_DROP_EVENT_IDs;
        } else {
            fields[0].fld_name = CTR_EGR_DROP_EVENT_IDs;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit, table, &lt_entry, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stat_trace_event_counter_get(
    int unit,
    bool sync_mode,
    bcm_pkt_trace_event_t type,
    uint64_t *val)
{
    bcmint_stat_db_t stat_db = {
        .drop_event_table_info = NULL,
        .num_drop_event = 0,
        .trace_event_table_info = NULL,
        .num_trace_event = 0,
    };
    bcmi_lt_entry_t lt_entry;
    const char *table = NULL;
    const char *event_id = NULL;
    bcmi_lt_field_t fields[] =
    {
        /* 0 */ {NULL, BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /* 1 */ {TRACE_CNTs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    if (type < 0 || type >= bcmPktTraceEventCount) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit,
                                "Invalid trace event(%d).\n"), type));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (trace_index[unit][type] < 0) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Unsupported trace event(%d).\n"), type));
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    SHR_NULL_CHECK(val, SHR_E_PARAM);
    *val = 0;

    /* Get the per-variant trace event mapping table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_stat_db_get(unit, &stat_db));

    lt_entry.fields = fields;
    lt_entry.nfields = sizeof(fields) / sizeof(fields[0]);
    lt_entry.attr = sync_mode ? BCMLT_ENT_ATTR_GET_FROM_HW : 0;

    table = stat_db.trace_event_table_info[trace_index[unit][type]].table;
    event_id = stat_db.trace_event_table_info[trace_index[unit][type]].field;
    fields[0].u.sym_val = event_id;
    if (sal_strcmp(table, CTR_ING_TRACE_EVENTs) == 0) {
        fields[0].fld_name = CTR_ING_TRACE_EVENT_IDs;
    } else {
        fields[0].fld_name = CTR_EGR_TRACE_EVENT_IDs;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit, table, &lt_entry, NULL, NULL));
    *val = fields[1].u.val;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stat_trace_event_counter_set(
    int unit,
    bcm_pkt_trace_event_t type,
    uint64_t val)
{
    bcmint_stat_db_t stat_db = {
        .drop_event_table_info = NULL,
        .num_drop_event = 0,
        .trace_event_table_info = NULL,
        .num_trace_event = 0,
    };
    bcmi_lt_entry_t lt_entry;
    const char *table = NULL;
    const char *event_id = NULL;
    bcmi_lt_field_t fields[] =
    {
        /* 0 */ {NULL, BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /* 1 */ {TRACE_CNTs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    if (type < 0 || type >= bcmPktTraceEventCount) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit,
                                "Invalid trace event(%d).\n"), type));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (trace_index[unit][type] < 0) {
        LOG_VERBOSE(BSL_LOG_MODULE,
                    (BSL_META_U(unit, "Unsupported trace event(%d).\n"), type));
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Get the per-variant trace event mapping table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_stat_db_get(unit, &stat_db));

    lt_entry.fields = fields;
    lt_entry.nfields = sizeof(fields) / sizeof(fields[0]);
    lt_entry.attr = 0;

    table = stat_db.trace_event_table_info[trace_index[unit][type]].table;
    event_id = stat_db.trace_event_table_info[trace_index[unit][type]].field;
    fields[0].u.sym_val = event_id;
    if (sal_strcmp(table, CTR_ING_TRACE_EVENTs) == 0) {
        fields[0].fld_name = CTR_ING_TRACE_EVENT_IDs;
    } else {
        fields[0].fld_name = CTR_EGR_TRACE_EVENT_IDs;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, table, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stat_counter_control_init(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmi_ltsw_stat_counter_control_t *ltsw_ctr_ctrl = NULL;
    bcmi_ltsw_stat_counter_non_dma_t *non_dma = NULL;
    int num_ports = 0;
    bcmlt_field_def_t field_def;
    uint32_t num_fields;
    uint32_t total_entries;
    uint32_t alloc_size;

    SHR_FUNC_ENTER(unit);

    ltsw_ctr_ctrl = ltsw_counter_control[unit];
    if (ltsw_ctr_ctrl != NULL) {
        SHR_FREE(ltsw_ctr_ctrl->counter_non_dma);
        SHR_FREE(ltsw_ctr_ctrl);
        ltsw_counter_control[unit] = NULL;
    }

    /* Alloc memory for counter control structure. */
    SHR_ALLOC(ltsw_ctr_ctrl, sizeof(bcmi_ltsw_stat_counter_control_t),
              "bcmLtswStatDefFields");
    SHR_NULL_CHECK(ltsw_ctr_ctrl, SHR_E_MEMORY);
    sal_memset(ltsw_ctr_ctrl, 0, sizeof(bcmi_ltsw_stat_counter_control_t));
    ltsw_counter_control[unit] = ltsw_ctr_ctrl;

    /* Get the number of physical ports. */
    num_ports = bcmi_ltsw_dev_phys_port_num(unit);

    /* Counter CPU port. */
    num_ports++;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(dunit, CTR_MACs, 0, NULL, &num_fields));
    ltsw_ctr_ctrl->entries_perport0 = num_fields;
    total_entries = num_fields * num_ports;

    ltsw_ctr_ctrl->base_index1 = total_entries;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(dunit, CTR_MAC_ERRs, 0, NULL, &num_fields));
    ltsw_ctr_ctrl->entries_perport1 = num_fields;
    total_entries += num_fields * num_ports;

    /* Alloc memory for non-dma counter structure. */
    alloc_size = BCMI_LTSW_COUNTER_NON_DMA_COUNT *
                 sizeof(bcmi_ltsw_stat_counter_non_dma_t);
    SHR_ALLOC(ltsw_ctr_ctrl->counter_non_dma, alloc_size,
              "bcmLtswStatCtrNonDma");
    SHR_NULL_CHECK(ltsw_ctr_ctrl->counter_non_dma, SHR_E_MEMORY);
    sal_memset(ltsw_ctr_ctrl->counter_non_dma, 0, alloc_size);

    /* Init MC queue counter. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_def_get(unit, CTR_EGR_MC_Qs, MC_Qs, &field_def));
    non_dma = &ltsw_ctr_ctrl->counter_non_dma[BCMI_LTSW_COUNTER_NON_DMA_EGR_PERQ_XMT_MC];
    non_dma->id = BCMI_LTSW_COUNTER_NON_DMA_EGR_PERQ_XMT_MC;
    non_dma->table = CTR_EGR_MC_Qs;
    non_dma->key = MC_Qs;
    non_dma->cname_pkt = "MC_PERQ_PKT";
    non_dma->cname_byte = "MC_PERQ_BYTE";
    non_dma->base_index = total_entries;
    /* There are packet counter and byte counter. */
    non_dma->entries_perport = (field_def.max + 1) * 2;
    total_entries += non_dma->entries_perport * num_ports;

    /* Init UC queue counter. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_def_get(unit, CTR_EGR_UC_Qs, UC_Qs, &field_def));
    non_dma = &ltsw_ctr_ctrl->counter_non_dma[BCMI_LTSW_COUNTER_NON_DMA_EGR_PERQ_XMT_UC];
    non_dma->id = BCMI_LTSW_COUNTER_NON_DMA_EGR_PERQ_XMT_UC;
    non_dma->table = CTR_EGR_UC_Qs;
    non_dma->key = UC_Qs;
    non_dma->cname_pkt = "UC_PERQ_PKT";
    non_dma->cname_byte = "UC_PERQ_BYTE";
    non_dma->base_index = total_entries;
    /* There are packet counter and byte counter. */
    non_dma->entries_perport = (field_def.max + 1) * 2;
    total_entries += non_dma->entries_perport * num_ports;

    ltsw_ctr_ctrl->total_counters = total_entries;

exit:
    if (SHR_FUNC_ERR()) {
        if (ltsw_ctr_ctrl != NULL) {
            SHR_FREE(ltsw_ctr_ctrl->counter_non_dma);
            SHR_FREE(ltsw_ctr_ctrl);
            ltsw_counter_control[unit] = NULL;
        }
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_stat_counter_control_get(
    int unit,
    bcmi_ltsw_stat_counter_control_t *info)
{
    bcmi_ltsw_stat_counter_control_t
        *ltsw_ctr_ctrl = ltsw_counter_control[unit];

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(info, SHR_E_PARAM);
    SHR_NULL_CHECK(ltsw_ctr_ctrl, SHR_E_INIT);

    sal_memset(info, 0, sizeof(*info));
    sal_memcpy(info, ltsw_ctr_ctrl, sizeof(*info));

exit:
    SHR_FUNC_EXIT();
}

