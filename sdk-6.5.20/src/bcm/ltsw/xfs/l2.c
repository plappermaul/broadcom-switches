/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/l2.h>
#include <bcm/flexctr.h>
#include <bcm_int/control.h>
#include <bcm_int/common/multicast.h>

#include <bcm_int/ltsw/xfs/l2.h>
#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/l2.h>
#include <bcm_int/ltsw/xfs/types.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/event_mgr.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw/l3_egress.h>
#include <bcm_int/ltsw/vlan.h>
#include <bcm_int/ltsw/multicast.h>
#include <bcm_int/ltsw/sbr.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/init.h>
#include <bcm_int/ltsw/trunk.h>
#include <bcm_int/ltsw/flexctr.h>
#include <bcm_int/ltsw/uft.h>
#include <bcm_int/ltsw/mbcm/l2.h>

#include <bsl/bsl.h>
#include <sal/sal_mutex.h>
#include <sal/sal_time.h>
#include <shr/shr_debug.h>
#include <shr/shr_bitop.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_L2

/******************************************************************************
 * Private functions
 */


/*
 * L2 Learn notify info.
 *
 * In DNA, LEARN_CACHE fields have the following meanings:
 *  CACHE_FIELD0 -- 0-15 bit for source mac address
 *  CACHE_FIELD1 -- 16-31 bit for source mac address
 *  CACHE_FIELD2 -- 32-47 bit for source mac address
 *  CACHE_FIELD3 -- VFI value
 *  CACHE_FIELD4 -- learn source object
 *  CACHE_FIELD5 -- NULL
 *  CACHE_FIELD6 -- learn source type
 *  CACHE_FIELD7 -- zero
 *  LEARN_CACHE_DATA_INFO_ID -- LEARN_CACHE_DATA_CONTROL logical table index.
 */
typedef struct l2_learn_notify_s {
    /* Opcode */
    bcmlt_opcode_t op;

    /* Cache fields. */
    uint16_t cache_field[8];

    /* Start time in us, for debugging usage. */
    sal_usecs_t stime;
} l2_learn_notify_t;

/* PVLAN info structure. */
typedef struct l2_pvlan_info_s {
    /* PVLAN id. */
    bcm_vlan_t vid;

    /* PVLAN port type. */
    bcmint_l2_dst_pvlan_port_type_t type;
} l2_pvlan_info_t;

/*
* L2 table control structure
*/
typedef struct l2_ctrl_s {
    /* This mutex lock is to guarantee operation of L2 table to be atomic operation */
    sal_mutex_t mutex;

    /* L2 Learning enable */
    bool learn_enable;

    /* Station VLAN info */
    bcmi_ltsw_l2_station_vlan_t *vlan_info;

    /*
     * Bitmap of L2 table view for vfi.
     * 0: double wide view, 1: single wide view.
     */
    SHR_BITDCL *l2_view;

    /* PVLAN info. */
    l2_pvlan_info_t *pvlan_info;

    /* L2 host strength profile index. */
    int l2_host_sbr_prf_index;

    /* L2 map database pointer. */
    const bcmint_l2_map_db_t *l2_db;

    /* Flex ctr info. */
    bcmint_l2_flexctr_info_t *flexctr_info;

    /* L2 hitbit enable. */
    bool hitbit_enable;

    /* MY_STATION_TABLE disabled. */
    bool station_disable;

    /* VFI num. */
    uint32_t vfi_num;

    /* L2 host disabled. */
    bool host_disable;
} l2_ctrl_t;

static l2_ctrl_t l2_ctrl[BCM_MAX_NUM_UNITS] = {{ 0 }};

static bool slow_poll_mode[BCM_MAX_NUM_UNITS];

/* Take L2 table lock */
#define L2T_LOCK(u) \
    sal_mutex_take(l2_ctrl[u].mutex, SAL_MUTEX_FOREVER)

/* Release L2 table lock*/
#define L2T_UNLOCK(u) \
    sal_mutex_give(l2_ctrl[u].mutex)

/* This macro indicates if notify L2 event to application */
#define NOTIFY_L2_EVENT(unit) bcmint_l2_callback_num(unit) ? true: false

/* VLAN info used for station */
#define L2_VLAN_INFO(u, vid) (&l2_ctrl[u].vlan_info[vid])

/* The priority for reserved MY_STATION_TABLE entry. */
#define L2_STATION_RSVD_PRI 0

/* The priority offset for user programmed MY_STATION_TABLE entry. */
#define L2_STATION_PRI_OFFSET 1

/* L2 table view bitmap. */
#define L2_VIEW_BMP(unit) \
            (l2_ctrl[unit].l2_view)

/* Set L2 table view used bitmap for given vfi. */
#define L2_VIEW_BMP_USED_SET(unit, vfi) \
            (SHR_BITSET(L2_VIEW_BMP(unit), vfi))

/* Get L2 table view used bitmap for given vfi. */
#define L2_VIEW_BMP_USED_GET(unit, vfi) \
            (SHR_BITGET(L2_VIEW_BMP(unit), vfi))

/* Clear L2 table view used bitmap for given vfi. */
#define L2_VIEW_BMP_USED_CLR(unit, vfi) \
            (SHR_BITCLR(L2_VIEW_BMP(unit), vfi))

/* L2 map database. */
#define L2_MAP_DB(unit) \
            (l2_ctrl[unit].l2_db)

/* L2 map id database. */
#define L2_MAP_ID_DB(unit, hdl) \
            (&(L2_MAP_DB(unit)->id_db[hdl]))

/* L2 id map info. */
#define L2_MAP_ID_INFO(unit, hdl) \
            (L2_MAP_ID_DB(unit, hdl)->info)

/* L2 map string database. */
#define L2_MAP_STR_DB(unit, hdl) \
            (&(L2_MAP_DB(unit)->str_db[hdl]))

/* L2 map string info. */
#define L2_MAP_STR_INFO(unit, hdl) \
            (L2_MAP_STR_DB(unit, hdl)->info)

/* Return directly if L2 host is disabled. */
#define L2_HOST_DISABLE_RETURN(u)                       \
    do {                                                \
        l2_ctrl_t *l2c = &l2_ctrl[u];                   \
        if (l2c->host_disable) {                        \
            SHR_EXIT();                                 \
        }                                               \
    } while(0)

/* Field bitmap of L2 host table. */
#define L2_HOST_FLD_MAC                     (1 << 0)
#define L2_HOST_FLD_VFI                     (1 << 1)
#define L2_HOST_FLD_SBR_IDX                 (1 << 2)
#define L2_HOST_FLD_DST                     (1 << 3)
#define L2_HOST_FLD_DST_TYPE                (1 << 4)
#define L2_HOST_FLD_CLASS_ID                (1 << 5)
#define L2_HOST_FLD_PVLAN_DST_PORT_TYPE     (1 << 6)
#define L2_HOST_FLD_DST_VP_GROUP            (1 << 7)
#define L2_HOST_FLD_PVLAN_ID                (1 << 8)
#define L2_HOST_FLD_NHP_2_ECMP_GROUP_IDX    (1 << 9)
#define L2_HOST_FLD_ECMP_PROT_SWT_PRF_IDX   (1 << 10)
#define L2_HOST_FLD_FLEX_CTR_ACTION         (1 << 11)
#define L2_HOST_FLD_MISC_CTRL_0             (1 << 12)
#define L2_HOST_FLD_MISC_CTRL_1             (1 << 13)
#define L2_HOST_FLD_DST_ENTRY_IDX           (1 << 14)
#define L2_HOST_FLD_SRC_ENTRY_IDX           (1 << 15)
#define L2_HOST_FLD_ALL                     (0xFFFF)

/* Field count of read-only fields in L2 host table. */
#define L2_FIELD_CNT_READ_ONLY 2

/* Field count of L2 learning op in L2_HOST_TABLE. */
#define L2_FIELD_CNT_LEARN_HOST_TABLE 12

/* Field count of L2 learning op in L2_HOST_NARROW_TABLE. */
#define L2_FIELD_CNT_LEARN_HOST_NARROW_TABLE 7

/* Bit offset for MISC_CTRL_0 of L2 forwarding table. */
#define L2_HOST_MISC_CTRL_0_VALID           (0)
#define L2_HOST_MISC_CTRL_0_STATION         (1)
#define L2_HOST_MISC_CTRL_0_OPAQUE_CTRL     (2)

/* Mask for opaque control bits of MISC_CTRL_0. */
#define L2_HOST_MISC_CTRL_0_OPAQUE_CTRL_MASK (0x3)

/* Bit offset for MISC_CTRL_1 of L2 forwarding table. */
#define L2_HOST_MISC_CTRL_1_DA_DROP         (0)
#define L2_HOST_MISC_CTRL_1_DA_COPY_TO_CPU  (1)
#define L2_HOST_MISC_CTRL_1_SA_DROP         (2)
#define L2_HOST_MISC_CTRL_1_STATIC          (3)

/*!
 * \brief Update L2 pvlan info for a port.
 *
 * \param [in] unit Unit number.
 * \param [in] port Port id.
 * \param [in] vlan Pvlan vlan id.
 * \param [in] flags Pvlan vlan flags.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_pvlan_info_update(int unit, bcm_port_t port, bcm_vlan_t vlan,
                     uint32_t flags)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    bcmint_l2_dst_pvlan_port_type_t type;
    bcm_vlan_t pvlan_id;
    int l2_iif;
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_to_l2_if(unit, port, &l2_iif));

    type = BCMINT_L2_DST_PVLAN_PORT_TYPE_PROMISCUOUS;
    if (flags & BCM_PORT_FORCE_VLAN_ENABLE) {
        if ((flags & BCM_PORT_FORCE_VLAN_PORT_TYPE_MASK) ==
                     BCM_PORT_FORCE_VLAN_PROMISCUOUS_PORT) {
            type = BCMINT_L2_DST_PVLAN_PORT_TYPE_PROMISCUOUS;
        } else if ((flags & BCM_PORT_FORCE_VLAN_PORT_TYPE_MASK) ==
                            BCM_PORT_FORCE_VLAN_COMMUNITY_PORT) {
            type = BCMINT_L2_DST_PVLAN_PORT_TYPE_COMMUNITY;
        } else if ((flags & BCM_PORT_FORCE_VLAN_PORT_TYPE_MASK) ==
                            BCM_PORT_FORCE_VLAN_ISOLATED_PORT) {
            type = BCMINT_L2_DST_PVLAN_PORT_TYPE_ISOLATED;
        }

        pvlan_id = vlan;
    } else {
        type = BCMINT_L2_DST_PVLAN_PORT_TYPE_PROMISCUOUS;
        pvlan_id = 0;
    }

    l2c->pvlan_info[l2_iif].type = type;
    l2c->pvlan_info[l2_iif].vid = pvlan_id;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get L2 pvlan info for a port.
 *
 * \param [in] unit Unit number.
 * \param [in] port Port id.
 * \param [out] info Pvlan info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_pvlan_info_get(int unit, bcm_port_t port, l2_pvlan_info_t *info)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    int l2_iif, rv;
    bcm_port_t port_out;
    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_port_gport_validate(unit, port, &port_out);
    if (rv == SHR_E_PORT) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    rv = bcmi_ltsw_port_to_l2_if(unit, port, &l2_iif);
    if (SHR_SUCCESS(rv)) {
        info->type = l2c->pvlan_info[l2_iif].type;
        info->vid = l2c->pvlan_info[l2_iif].vid;
    } else if (rv == SHR_E_PORT) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Dump L2 pvlan information.
 *
 * \param [in] unit Unit Number.
 */
static void
l2_pvlan_info_dump(int unit)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    int rv, i;
    uint32_t l2_iif_num;
    const char *str[] = BCMINT_L2_DST_PVLAN_PORT_TYPE_STR;

    LOG_CLI((BSL_META_U(unit,
                        "  L2 pvlan info:\n")));

    /* Get the table size of L2 iif table. */
    rv = bcmi_lt_capacity_get(unit, ING_L2_IIF_TABLEs, &l2_iif_num);
    if (rv != SHR_E_NONE) {
        return;
    }

    LOG_CLI((BSL_META_U(unit,
                        "  %10s %10s %20s\n"),
                        "L2_IIF",
                        "PVLAN",
                        "Port Type"));
    LOG_CLI((BSL_META_U(unit,
                        "  ------------------------------------------\n")));

    for (i = 0; i < l2_iif_num; i++) {
        if (l2c->pvlan_info[i].vid) {
            LOG_CLI((BSL_META_U(unit,
                                "    %8x   %8x %20s\n"),
                                i,
                                l2c->pvlan_info[i].vid,
                                str[l2c->pvlan_info[i].type]));
        }
    }

    LOG_CLI((BSL_META_U(unit,
                        "\n")));

    return;
}

/*!
 * \brief Set force vlan for L2 table.
 *
 * \param [in] unit Unit number.
 * \param [in] eh Entry handle.
 * \param [in] port Port id.
 *
 * \retval SHE_E_NONE No errors.
 */
static int
l2_pvlan_set(int unit, bcmlt_entry_handle_t eh, bcm_port_t port)
{
    l2_pvlan_info_t info;
    const bcmint_l2_id_map_t *id_map = NULL;
    const bcmint_l2_str_map_t *str_map = NULL;

    SHR_FUNC_ENTER(unit);

    id_map  = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    str_map = L2_MAP_STR_INFO(unit, BCMINT_L2_MAP_SH_DST_PVLAN_PORT_TYPE);
    if (id_map == NULL || str_map == NULL) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    sal_memset(&info, 0, sizeof(l2_pvlan_info_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_pvlan_info_get(unit, port, &info));

    if (info.type >= BCMINT_L2_DST_PVLAN_PORT_TYPE_COUNT) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add_by_id(eh,
             id_map[BCMINT_L2_HOST_FLD_COMMUNITY_PVLAN_ID].val,
             info.vid));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add_by_id(eh,
             id_map[BCMINT_L2_HOST_FLD_DST_PVLAN_PORT_TYPE].val,
             str_map[info.type].str));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Free external resource being used by L2 entry if any.
 *
 * The external resource includes ECMP Level 0 member index.
 *
 * \param [in] unit Unit number
 * \param [in] l2addr L2 address structure.
 * \param [in] eh LT entry handle.
 * \param [in] single True for single wide view(L2_HOST_NARROW_TABLE),
 *                    false for double wide view(L2_HOST_TABLE).
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_external_resource_free(int unit, bcm_l2_addr_t *l2addr,
                          bcmlt_entry_handle_t eh, bool single)
{
    bcm_port_t port_out;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    const char *cdata;
    uint64_t dest = 0LL;
    int member_index;
    const bcmint_l2_id_map_t *id_map = NULL;
    const bcmint_l2_str_map_t *str_map = NULL;
    uint32_t fid;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(l2addr, SHR_E_PARAM);

    id_map  = L2_MAP_ID_INFO(unit, single);
    str_map = L2_MAP_STR_INFO(unit, BCMINT_L2_MAP_SH_DEST_TYPE);
    if (id_map == NULL || str_map == NULL) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    if (BCM_GPORT_IS_MPLS_PORT(l2addr->port) ||
        BCM_GPORT_IS_FLOW_PORT(l2addr->port)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_validate(unit,
                                           l2addr->port,
                                           &port_out));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vp_info_get(unit, port_out, &vp_info));

        /* Skip for non-cascaded VP. */
        if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_CASCADED)) {
            SHR_EXIT();
        }

        fid = single ? id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION_TYPE].val :
                       id_map[BCMINT_L2_HOST_FLD_DESTINATION_TYPE].val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get_by_id(eh, fid, &cdata));

        fid = single ? id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION].val :
                       id_map[BCMINT_L2_HOST_FLD_DESTINATION].val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh, fid, &dest));

        if (sal_strcmp(str_map[BCMINT_L2_DEST_TYPE_ECMP_MEMBER].str,
                       cdata) == 0) {
            member_index = dest;

            /* Free ECMP member index. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_ecmp_member_dest_free(unit, member_index));
        } else if (!single) {
            fid = id_map[BCMINT_L2_HOST_FLD_NHOP_2_OR_ECMP_GROUP_INDEX_1].val;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get_by_id(eh, fid, &dest));

            member_index = dest;

            /* Free ECMP member index. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_ecmp_member_dest_free(unit, member_index));
        }
    } else {
        /* Skip for non-VP. */
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Remove read-only fields of L2 host tables.
 *
 * This function is used in the case of users want to do update operation
 * after a lookup/traverse operation under the same entry handle,
 * to avoid E_ACCESS error caused by updating read-only fields.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_entry_read_only_fields_remove(int unit, bcmlt_entry_handle_t eh)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_remove(eh, SRC_ENTRY_INDEXs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_remove(eh, DST_ENTRY_INDEXs));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set field bitmap of L2 host table.
 *
 * \param [in] unit Unit number.
 * \param [in] l2_op L2 operation.
 * \param [in] notify Notify L2 host table changes to user or not.
 * \param [in] single True for single wide view(L2_HOST_NARROW_TABLE),
 *                    false for double wide view(L2_HOST_TABLE).
 * \param [out] fld_bmp Field bitmap.
 * \param [out] fld_cnt Field element count. NULL for no care.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_field_bmp_set(int unit, bcmint_l2_event_type_t l2_op, bool notify,
                 bool single, uint32_t *fld_bmp, size_t *fld_cnt)
{
    uint32_t field_bmp = 0;
    const bcmint_l2_id_map_t *id_map = NULL;
    size_t fld_cnt_tmp = 0;
    l2_ctrl_t *l2c = &l2_ctrl[unit];

    if (fld_bmp == NULL) {
        return SHR_E_PARAM;
    }

    id_map = L2_MAP_ID_INFO(unit, single);
    if (id_map == NULL) {
        return SHR_E_INIT;
    }

    fld_cnt_tmp = single ? id_map[BCMINT_L2_HOST_NARROW_FLD_ELEMENT_CNT].val :
                           id_map[BCMINT_L2_HOST_FLD_ELEMENT_CNT].val;

    switch (l2_op) {
        case L2_EVENT_ADD:
            if (single) {
                field_bmp = L2_HOST_FLD_MAC | L2_HOST_FLD_VFI |
                            L2_HOST_FLD_SBR_IDX | L2_HOST_FLD_DST |
                            L2_HOST_FLD_DST_TYPE |
                            L2_HOST_FLD_FLEX_CTR_ACTION |
                            L2_HOST_FLD_MISC_CTRL_0 |
                            L2_HOST_FLD_MISC_CTRL_1;
                fld_cnt_tmp -= L2_FIELD_CNT_READ_ONLY;
            } else {
                field_bmp = L2_HOST_FLD_MAC | L2_HOST_FLD_VFI |
                            L2_HOST_FLD_SBR_IDX | L2_HOST_FLD_DST |
                            L2_HOST_FLD_DST_TYPE | L2_HOST_FLD_CLASS_ID |
                            L2_HOST_FLD_PVLAN_DST_PORT_TYPE |
                            L2_HOST_FLD_DST_VP_GROUP |
                            L2_HOST_FLD_PVLAN_ID |
                            L2_HOST_FLD_NHP_2_ECMP_GROUP_IDX |
                            L2_HOST_FLD_ECMP_PROT_SWT_PRF_IDX |
                            L2_HOST_FLD_FLEX_CTR_ACTION |
                            L2_HOST_FLD_MISC_CTRL_0 |
                            L2_HOST_FLD_MISC_CTRL_1;
                fld_cnt_tmp -= L2_FIELD_CNT_READ_ONLY;
            }
            break;
        case L2_EVENT_DELETE:
            field_bmp = L2_HOST_FLD_MAC | L2_HOST_FLD_VFI;
            if (notify) {
                fld_cnt_tmp -= L2_FIELD_CNT_READ_ONLY;
            } else {
                fld_cnt_tmp = 2;
            }
            break;
        case L2_EVENT_UPDATE:
            /*
             * The following fields need no change:
             * 1.Key: MAC, VFI.
             * 2.Strength profile index.
             * 3.Flex ctr action.
             */
            if (single) {
                field_bmp = L2_HOST_FLD_DST |
                            L2_HOST_FLD_DST_TYPE |
                            L2_HOST_FLD_MISC_CTRL_0 |
                            L2_HOST_FLD_MISC_CTRL_1;
                fld_cnt_tmp -= L2_FIELD_CNT_READ_ONLY;
            } else {
                field_bmp = L2_HOST_FLD_DST |
                            L2_HOST_FLD_DST_TYPE | L2_HOST_FLD_CLASS_ID |
                            L2_HOST_FLD_PVLAN_DST_PORT_TYPE |
                            L2_HOST_FLD_DST_VP_GROUP |
                            L2_HOST_FLD_PVLAN_ID |
                            L2_HOST_FLD_NHP_2_ECMP_GROUP_IDX |
                            L2_HOST_FLD_ECMP_PROT_SWT_PRF_IDX |
                            L2_HOST_FLD_MISC_CTRL_0 |
                            L2_HOST_FLD_MISC_CTRL_1;
                fld_cnt_tmp -= L2_FIELD_CNT_READ_ONLY;
            }
            break;
        case L2_EVENT_LEARN:
            if (single) {
                field_bmp = L2_HOST_FLD_MAC | L2_HOST_FLD_VFI |
                            L2_HOST_FLD_SBR_IDX | L2_HOST_FLD_DST |
                            L2_HOST_FLD_DST_TYPE |
                            L2_HOST_FLD_FLEX_CTR_ACTION |
                            L2_HOST_FLD_MISC_CTRL_0;
                fld_cnt_tmp = L2_FIELD_CNT_LEARN_HOST_NARROW_TABLE;
            } else {
                field_bmp = L2_HOST_FLD_MAC | L2_HOST_FLD_VFI |
                            L2_HOST_FLD_SBR_IDX | L2_HOST_FLD_DST |
                            L2_HOST_FLD_DST_TYPE |
                            L2_HOST_FLD_PVLAN_DST_PORT_TYPE |
                            L2_HOST_FLD_DST_VP_GROUP |
                            L2_HOST_FLD_PVLAN_ID |
                            L2_HOST_FLD_NHP_2_ECMP_GROUP_IDX |
                            L2_HOST_FLD_ECMP_PROT_SWT_PRF_IDX |
                            L2_HOST_FLD_FLEX_CTR_ACTION |
                            L2_HOST_FLD_MISC_CTRL_0;
                fld_cnt_tmp = L2_FIELD_CNT_LEARN_HOST_TABLE;
            }
            break;
        case L2_EVENT_MOVE:
            if (single) {
                field_bmp = L2_HOST_FLD_DST |
                            L2_HOST_FLD_DST_TYPE;
                fld_cnt_tmp = L2_FIELD_CNT_LEARN_HOST_NARROW_TABLE;
            } else {
                field_bmp = L2_HOST_FLD_DST |
                            L2_HOST_FLD_DST_TYPE |
                            L2_HOST_FLD_PVLAN_DST_PORT_TYPE |
                            L2_HOST_FLD_DST_VP_GROUP |
                            L2_HOST_FLD_PVLAN_ID |
                            L2_HOST_FLD_NHP_2_ECMP_GROUP_IDX |
                            L2_HOST_FLD_ECMP_PROT_SWT_PRF_IDX;
                fld_cnt_tmp = L2_FIELD_CNT_LEARN_HOST_TABLE;
            }
            break;
        default:
            break;
    }
    /* Enable L2 hitbit by default. */
    if (l2c->hitbit_enable) {
        field_bmp |= L2_HOST_FLD_DST_ENTRY_IDX | L2_HOST_FLD_SRC_ENTRY_IDX;
    }
    *fld_bmp = field_bmp;
    if (fld_cnt) {
        *fld_cnt = fld_cnt_tmp;
    }
    return SHR_E_NONE;
}

/*!
 * \brief Get L2 hitbit of L2_HOST_TABLE.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [out] dst_hit Dest hit or not.
 * \param [out] src_hit Source hit or not.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_host_table_hitbit_get(int unit, bcmlt_entry_handle_t eh,
                         int *dst_hit, int *src_hit)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    bcmint_l2_flexctr_info_t *flexctr_info = NULL;
    const bcmint_l2_id_map_t *id_map = NULL;
    uint64_t data;
    uint32_t fld_enum[2] = {BCMINT_L2_HOST_FLD_DST_ENTRY_INDEX,
                            BCMINT_L2_HOST_FLD_SRC_ENTRY_INDEX};
    uint32 counter_index;
    uint32_t counter_id[2], bit_offset[2];
    bcm_flexctr_counter_value_t counter_value[2];
    int i;

    SHR_FUNC_ENTER(unit);

    flexctr_info = l2c->flexctr_info;
    /* Hitbit collection disabled. */
    if (!flexctr_info) {
        SHR_EXIT();
    }

    id_map  = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /*
     * Use UFT counter action to get hitbit for both UFT and non-UFT
     * entries. This is a trick operation.
     */
    counter_id[0] = flexctr_info->uft_dst_id;
    counter_id[1] = flexctr_info->uft_src_id;
    sal_memset(&counter_value, 0x0, sizeof(counter_value));

    for (i = 0; i < 2; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh, id_map[fld_enum[i]].val, &data));

        /* The lowest 6-bit of data is the offset of hitbit value. */
        bit_offset[i] = ((uint32)data & 0x3F);
        counter_index = ((uint32)data >> 6);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexctr_stat_sync_get(unit, counter_id[i], 1,
                                            &counter_index, &counter_value[i]));
    }

    /* Value[1] is the lower part data of counter value A. */
    if (dst_hit) {
        *dst_hit = (counter_value[0].value[1] >> bit_offset[0]) & 0x1;
    }

    if (src_hit) {
        *src_hit = (counter_value[1].value[1] >> bit_offset[1]) & 0x1;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set L2 hitbit of L2_HOST_TABLE.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] dst Set dest hitbit or not. True for set.
 * \param [in] src Set source hitbit or not. True for set.
 * \param [in] dst_val The value to be set to dest hitbit.
 *                     Valid only when dst=true.
 * \param [in] src_val The value to be set to source hitbit.
 *                     Valid only when src=true.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_host_table_hitbit_set(int unit, bcmlt_entry_handle_t eh,
                         bool dst, bool src, int dst_val, int src_val)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    bcmint_l2_flexctr_info_t *flexctr_info = NULL;
    const bcmint_l2_id_map_t *id_map = NULL;
    uint64_t data;
    uint32 counter_index;
    uint32_t counter_id, bit_offset;
    bcm_flexctr_counter_value_t counter_value;

    SHR_FUNC_ENTER(unit);

    flexctr_info = l2c->flexctr_info;
    /* Hitbit collection disabled. */
    if (!flexctr_info) {
        SHR_EXIT();
    }

    id_map  = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);
    sal_memset(&counter_value, 0x0, sizeof(bcm_flexctr_counter_value_t));

    if (dst) {
        counter_id = flexctr_info->uft_dst_id;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_DST_ENTRY_INDEX].val, &data));

        bit_offset = ((uint32)data & 0x3F);
        counter_index = ((uint32)data >> 6);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexctr_stat_sync_get(unit, counter_id, 1,
                                            &counter_index, &counter_value));

        /* Value[1] is the lower part data of counter value A. */
        if (dst_val) {
            counter_value.value[1] |= 1ULL << bit_offset;
        } else {
            counter_value.value[1] &= ~(1ULL << bit_offset);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexctr_stat_set(unit, counter_id, 1,
                                       &counter_index, &counter_value));
    }

    if (src) {
        counter_id = flexctr_info->uft_src_id;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_SRC_ENTRY_INDEX].val, &data));

        bit_offset = ((uint32)data & 0x3F);
        counter_index = ((uint32)data >> 6);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexctr_stat_sync_get(unit, counter_id, 1,
                                            &counter_index, &counter_value));

        /* Value[1] is the lower part data of counter value A. */
        if (src_val) {
            counter_value.value[1] |= 1ULL << bit_offset;
        } else {
            counter_value.value[1] &= ~(1ULL << bit_offset);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexctr_stat_set(unit, counter_id, 1,
                                       &counter_index, &counter_value));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get L2 hitbit of L2_HOST_NARROW_TABLE.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [out] dst_hit Dest hit or not.
 * \param [out] src_hit Source hit or not.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_host_narrow_table_hitbit_get(int unit, bcmlt_entry_handle_t eh,
                                int *dst_hit, int *src_hit)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    bcmint_l2_flexctr_info_t *flexctr_info = NULL;
    const bcmint_l2_id_map_t *id_map = NULL;
    uint64_t data;
    uint32_t fld_enum[2] = {BCMINT_L2_HOST_NARROW_FLD_DST_ENTRY_INDEX,
                            BCMINT_L2_HOST_NARROW_FLD_SRC_ENTRY_INDEX};
    uint32 counter_index;
    uint32_t counter_id[2], bit_offset[2];
    bcm_flexctr_counter_value_t counter_value[2];
    int i;

    SHR_FUNC_ENTER(unit);

    flexctr_info = l2c->flexctr_info;
    /* Hitbit collection disabled. */
    if (!flexctr_info) {
        SHR_EXIT();
    }

    id_map  = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    counter_id[0] = flexctr_info->uft_dst_id;
    counter_id[1] = flexctr_info->uft_src_id;
    sal_memset(&counter_value, 0x0, sizeof(counter_value));

    for (i = 0; i < 2; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh, id_map[fld_enum[i]].val, &data));

        /* The lowest 6-bit of data is the offset of hitbit value. */
        bit_offset[i] = ((uint32)data & 0x3F);
        counter_index = ((uint32)data >> 6);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexctr_stat_sync_get(unit, counter_id[i], 1,
                                            &counter_index, &counter_value[i]));
    }

    /* Value[1] is the lower part data of counter value A. */
    if (dst_hit) {
        *dst_hit = (counter_value[0].value[1] >> bit_offset[0]) & 0x1;
    }

    if (src_hit) {
        *src_hit = (counter_value[1].value[1] >> bit_offset[1]) & 0x1;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set L2 hitbit of L2_HOST_NARROW_TABLE.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] dst Set dest hitbit or not. True for set.
 * \param [in] src Set source hitbit or not. True for set.
 * \param [in] dst_val The value to be set to dest hitbit.
 *                     Valid only when dst=true.
 * \param [in] src_val The value to be set to source hitbit.
 *                     Valid only when src=true.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_host_narrow_table_hitbit_set(int unit, bcmlt_entry_handle_t eh,
                                bool dst, bool src, int dst_val, int src_val)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    bcmint_l2_flexctr_info_t *flexctr_info = NULL;
    const bcmint_l2_id_map_t *id_map = NULL;
    uint64_t data;
    uint32 counter_index;
    uint32_t counter_id, bit_offset;
    bcm_flexctr_counter_value_t counter_value;

    SHR_FUNC_ENTER(unit);

    flexctr_info = l2c->flexctr_info;
    /* Hitbit collection disabled. */
    if (!flexctr_info) {
        SHR_EXIT();
    }

    id_map  = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);
    sal_memset(&counter_value, 0x0, sizeof(bcm_flexctr_counter_value_t));

    if (dst) {
        counter_id = flexctr_info->uft_dst_id;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_NARROW_FLD_DST_ENTRY_INDEX].val, &data));

        bit_offset = ((uint32)data & 0x3F);
        counter_index = ((uint32)data >> 6);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexctr_stat_sync_get(unit, counter_id, 1,
                                            &counter_index, &counter_value));

        /* Value[1] is the lower part data of counter value A. */
        if (dst_val) {
            counter_value.value[1] |= 1ULL << bit_offset;
        } else {
            counter_value.value[1] &= ~(1ULL << bit_offset);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexctr_stat_set(unit, counter_id, 1,
                                       &counter_index, &counter_value));
    }

    if (src) {
        counter_id = flexctr_info->uft_src_id;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_NARROW_FLD_SRC_ENTRY_INDEX].val, &data));

        bit_offset = ((uint32)data & 0x3F);
        counter_index = ((uint32)data >> 6);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexctr_stat_sync_get(unit, counter_id, 1,
                                            &counter_index, &counter_value));

        /* Value[1] is the lower part data of counter value A. */
        if (src_val) {
            counter_value.value[1] |= 1ULL << bit_offset;
        } else {
            counter_value.value[1] &= ~(1ULL << bit_offset);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexctr_stat_set(unit, counter_id, 1,
                                       &counter_index, &counter_value));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set L2 hitbit according to L2 address structure.
 *
 * \param [in] unit Unit number.
 * \param [in] eh LT entry handle.
 * \param [in] dst Set dest hitbit or not. True for set.
 * \param [in] src Set source hitbit or not. True for set.
 * \param [in] l2addr L2 address structure.
 * \param [in] single True for single wide view(L2_HOST_NARROW_TABLE),
 *                    false for double wide view(L2_HOST_TABLE).
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_hitbit_set(int unit, bcmlt_entry_handle_t eh, bool dst, bool src,
              bcm_l2_addr_t *l2addr, bool single)
{
    int src_val = 0, dst_val = 0;
    SHR_FUNC_ENTER(unit);

    dst_val = (l2addr->flags & (BCM_L2_HIT | BCM_L2_DES_HIT)) ? 1 : 0;
    src_val = (l2addr->flags & (BCM_L2_HIT | BCM_L2_SRC_HIT)) ? 1 : 0;

    if (single) {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_host_narrow_table_hitbit_set(unit, eh, dst, src,
                                             dst_val, src_val));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_host_table_hitbit_set(unit, eh, dst, src,
                                      dst_val, src_val));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get L2 hitbit from LT entry.
 *
 * \param [in] unit Unit number.
 * \param [in] eh LT entry handle.
 * \param [in] single True for single wide view(L2_HOST_NARROW_TABLE),
 *                    false for double wide view(L2_HOST_TABLE).
 * \param [out] dst_hit Dest hit or not.
 * \param [out] src_hit Source hit or not.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_hitbit_get(int unit, bcmlt_entry_handle_t eh, bool single,
              int *dst_hit, int *src_hit)
{
    SHR_FUNC_ENTER(unit);

    if (single) {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_host_narrow_table_hitbit_get(unit, eh, dst_hit, src_hit));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_host_table_hitbit_get(unit, eh, dst_hit, src_hit));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set entry fields of L2_HOST_TABLE.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] l2addr L2 address structure.
 * \param [in] fld_bmp Field bitmap.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
l2_host_table_entry_fields_set(int unit, bcmlt_entry_handle_t eh,
                               bcm_l2_addr_t *l2addr, uint32_t fld_bmp)
{
    uint64_t mac = 0, data = 0;
    bcm_port_t port_out;
    uint32_t vfi = 0;
    bcmi_ltsw_gport_info_t gport_info;
    bcm_gport_t gport = 0;
    int l2_if = 0, my_modid = 0;
    int nexthop = 0, mc_group, prt_idx = 0;
    bcmi_ltsw_l3_egr_obj_type_t type;
    bool l3mc = false, vp_lag = false;
    bcm_multicast_t group;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    int member_index = 0;
    bcm_if_t egress_if = 0;
    bcmi_ltsw_ecmp_member_dest_info_t dest_info;
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    int rv, vp_lag_vp;
    const bcmint_l2_id_map_t *id_map = NULL;
    const bcmint_l2_str_map_t *str_map = NULL;
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    id_map  = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    str_map = L2_MAP_STR_INFO(unit, BCMINT_L2_MAP_SH_DEST_TYPE);
    if (id_map == NULL || str_map == NULL) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    if (fld_bmp & L2_HOST_FLD_MAC) {
        bcmi_ltsw_util_mac_to_uint64(&mac, l2addr->mac);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_MAC_ADDR].val, mac));
    }

    if (fld_bmp & L2_HOST_FLD_VFI) {
        if (l2addr->vid > BCM_VLAN_MAX &&
            !BCMI_LTSW_VIRTUAL_VPN_VFI_IS_SET(l2addr->vid)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        /* Transform vid to vfi */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vfi_idx_get(unit, l2addr->vid, &vfi));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_VFI].val, vfi));
    }

    if (fld_bmp & (L2_HOST_FLD_DST | L2_HOST_FLD_DST_TYPE)) {
        if (BCM_MAC_IS_MCAST(l2addr->mac)) {
            if (_BCM_MULTICAST_IS_SET(l2addr->l2mc_group)) {
                if (!_BCM_MULTICAST_IS_L2(l2addr->l2mc_group)) {
                    l3mc = true;
                }
                mc_group = _BCM_MULTICAST_ID_GET(l2addr->l2mc_group);
            } else {
                mc_group = l2addr->l2mc_group;
            }

            if (l3mc) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_multicast_l3_grp_id_get(unit,
                                                       mc_group,
                                                       &group));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_symbol_add_by_id(eh,
                         id_map[BCMINT_L2_HOST_FLD_DESTINATION_TYPE].val,
                         str_map[BCMINT_L2_DEST_TYPE_L3MC_GROUP].str));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_symbol_add_by_id(eh,
                         id_map[BCMINT_L2_HOST_FLD_DESTINATION_TYPE].val,
                         str_map[BCMINT_L2_DEST_TYPE_L2MC_GROUP].str));
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add_by_id(eh,
                     id_map[BCMINT_L2_HOST_FLD_DESTINATION].val,
                     mc_group));
        } else {
            if (BCM_GPORT_IS_MPLS_PORT(l2addr->port) ||
                BCM_GPORT_IS_FLOW_PORT(l2addr->port)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_port_gport_validate(unit,
                                                   l2addr->port,
                                                   &port_out));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_vp_info_get(unit, port_out, &vp_info));

                if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                               l2addr->port,
                                                               &egress_if));

                    if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_CASCADED) {
                        /* Single-pointer model. */
                        dest_info.type = BCMI_LTSW_ECMP_MEMBER_DEST_T_L2_CASCADED;
                        dest_info.ul_egr_obj = egress_if;
                        dest_info.dvp = port_out;
                        dest_info.prot_swt_prfl_idx =
                                            BCMI_XFS_PROT_SWT_PROFILE_IDX_NHOP2;
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_ecmp_member_dest_alloc(unit,
                                                              &dest_info,
                                                              &member_index));

                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmlt_entry_field_symbol_add_by_id(eh,
                                 id_map[BCMINT_L2_HOST_FLD_DESTINATION_TYPE].val,
                                 str_map[BCMINT_L2_DEST_TYPE_VP].str));
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmlt_entry_field_add_by_id(eh,
                                 id_map[BCMINT_L2_HOST_FLD_DESTINATION].val,
                                 port_out));
                        prt_idx = 1 << 3;
                        nexthop = member_index;
                    } else {
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_l3_egress_obj_id_resolve(unit,
                                                                egress_if,
                                                                &nexthop,
                                                                &type));
                        /* egress_if is only for L2 tunnel use currently */
                        if ((type != BCMI_LTSW_L3_EGR_OBJ_T_UL) &&
                            (type != BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL)) {
                            SHR_ERR_EXIT(SHR_E_PARAM);
                        }

                        if (type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
                            prt_idx = 1;
                        } else {
                            prt_idx = (1 << 2) | 1; /* ECMP indicator. */
                        }

                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmlt_entry_field_symbol_add_by_id(eh,
                                 id_map[BCMINT_L2_HOST_FLD_DESTINATION_TYPE].val,
                                 str_map[BCMINT_L2_DEST_TYPE_VP].str));
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmlt_entry_field_add_by_id(eh,
                                 id_map[BCMINT_L2_HOST_FLD_DESTINATION].val,
                                 port_out));
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmlt_entry_field_add_by_id(eh,
                                 id_map[BCMINT_L2_HOST_FLD_DST_VP_GROUP].val, 0));
                    }
                } else {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_symbol_add_by_id(eh,
                             id_map[BCMINT_L2_HOST_FLD_DESTINATION_TYPE].val,
                             str_map[BCMINT_L2_DEST_TYPE_VP].str));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add_by_id(eh,
                             id_map[BCMINT_L2_HOST_FLD_DESTINATION].val,
                             port_out));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add_by_id(eh,
                             id_map[BCMINT_L2_HOST_FLD_DST_VP_GROUP].val, 0));
                }
            } else {
                bcm_module_t modid = -1;
                bcm_port_t port = -1;
                bcm_trunk_t trunk_id = -1;
                int vp = -1;

                if (BCM_GPORT_IS_MODPORT(l2addr->port)) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcm_ltsw_stk_my_modid_get(unit, &my_modid));
                    modid = BCM_GPORT_MODPORT_MODID_GET(l2addr->port);
                    if (modid == my_modid) {
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_port_gport_validate(unit,
                                                           l2addr->port,
                                                           &port_out));
                    }
                    gport = l2addr->port;
                } else if (BCM_GPORT_IS_SET(l2addr->port)) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_port_gport_resolve(unit,
                                                      l2addr->port,
                                                      &modid,
                                                      &port,
                                                      &trunk_id,
                                                      &vp));

                    if ((trunk_id != -1) && (vp == -1)) {
                        /* No need to validate. */
                    } else {
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_port_gport_validate(unit,
                                                           l2addr->port,
                                                           &port_out));
                    }
                    gport = l2addr->port;
                } else if (l2addr->flags & BCM_L2_TRUNK_MEMBER) {
                    trunk_id = l2addr->tgid;
                } else {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcm_ltsw_stk_my_modid_get(unit, &my_modid));
                    if (l2addr->modid == my_modid) {
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_port_gport_validate(unit,
                                                           l2addr->port,
                                                           &port_out));
                        gport_info.gport_type = _SHR_GPORT_TYPE_LOCAL;
                    } else {
                        gport_info.gport_type = _SHR_GPORT_TYPE_MODPORT;
                        gport_info.modid = l2addr->modid;
                    }
                    gport_info.port = l2addr->port;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_port_gport_construct(unit,
                                                        &gport_info,
                                                        &gport));
                }

                if (trunk_id != -1) {
                    rv = bcmi_ltsw_trunk_tid_to_vp_lag_vp(unit, trunk_id,
                                                          &vp_lag_vp);
                    if (SHR_SUCCESS(rv)) {
                        /* VP lag trunk. */
                        vp_lag = true;
                    } else {
                        /* Transform trunk id to l2 interface */
                        gport_info.gport_type = _SHR_GPORT_TYPE_TRUNK;
                        gport_info.tgid = trunk_id;
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_port_gport_construct(unit,
                                                            &gport_info,
                                                            &gport));
                    }
                }

                if (vp_lag) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_symbol_add_by_id(eh,
                             id_map[BCMINT_L2_HOST_FLD_DESTINATION_TYPE].val,
                             str_map[BCMINT_L2_DEST_TYPE_VP].str));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add_by_id(eh,
                             id_map[BCMINT_L2_HOST_FLD_DESTINATION].val,
                             vp_lag_vp));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add_by_id(eh,
                             id_map[BCMINT_L2_HOST_FLD_DST_VP_GROUP].val, 1));
                } else {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_port_to_l2_if(unit, gport, &l2_if));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_symbol_add_by_id(eh,
                             id_map[BCMINT_L2_HOST_FLD_DESTINATION_TYPE].val,
                             str_map[BCMINT_L2_DEST_TYPE_L2_OIF].str));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add_by_id(eh,
                             id_map[BCMINT_L2_HOST_FLD_DESTINATION].val,
                             l2_if));
                }
            }
        }
    }

    if (fld_bmp & L2_HOST_FLD_MISC_CTRL_1) {
        if (l2addr->flags & BCM_L2_DISCARD_DST) {
            data |= 1 << L2_HOST_MISC_CTRL_1_DA_DROP;
        } else {
            data &= ~(1 << L2_HOST_MISC_CTRL_1_DA_DROP);
        }

        if (l2addr->flags & BCM_L2_COPY_TO_CPU) {
            data |= 1 << L2_HOST_MISC_CTRL_1_DA_COPY_TO_CPU;
        } else {
            data &= ~(1 << L2_HOST_MISC_CTRL_1_DA_COPY_TO_CPU);
        }

        if (l2addr->flags & BCM_L2_DISCARD_SRC) {
            data |= 1 << L2_HOST_MISC_CTRL_1_SA_DROP;
        } else {
            data &= ~(1 << L2_HOST_MISC_CTRL_1_SA_DROP);
        }

        if (l2addr->flags & BCM_L2_STATIC) {
            data |= 1 << L2_HOST_MISC_CTRL_1_STATIC;
        } else {
            data &= ~(1 << L2_HOST_MISC_CTRL_1_STATIC);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_MISC_CTRL_1].val,
                 data));
    }

    if (fld_bmp & L2_HOST_FLD_FLEX_CTR_ACTION) {
        if (l2c->flexctr_info) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_flexctr_counter_id_info_get(unit,
                     l2c->flexctr_info->dst_grp_id,
                      &counter_info));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add_by_id(eh,
                     id_map[BCMINT_L2_HOST_FLD_FLEX_CTR_ACTION].val,
                     counter_info.action_index));
        }
    }

    if (fld_bmp & L2_HOST_FLD_CLASS_ID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_CLASS_ID].val,
                 l2addr->group));
    }

    if (fld_bmp & (L2_HOST_FLD_PVLAN_DST_PORT_TYPE | L2_HOST_FLD_PVLAN_ID)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_pvlan_set(unit, eh, l2addr->port));
    }

    if (fld_bmp & L2_HOST_FLD_MISC_CTRL_0) {
        /* Set my_station bit to add an interface address */
        data = 0;
        if (l2addr->flags & BCM_L2_L3LOOKUP) {
            data |= 1 << L2_HOST_MISC_CTRL_0_STATION;
        } else {
            data &= ~(1 << L2_HOST_MISC_CTRL_0_STATION);
        }

        /* Opaque control bits. */
        data |= l2addr->opaque_ctrl_id << L2_HOST_MISC_CTRL_0_OPAQUE_CTRL;

        /* Set entry_valid bit */
        data |= 1 << L2_HOST_MISC_CTRL_0_VALID;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_MISC_CTRL_0].val, data));
    }

    if (fld_bmp & L2_HOST_FLD_NHP_2_ECMP_GROUP_IDX) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_NHOP_2_OR_ECMP_GROUP_INDEX_1].val,
                 nexthop));
    }

    if (fld_bmp & L2_HOST_FLD_ECMP_PROT_SWT_PRF_IDX) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_ECMP_AND_PROT_SWT_SFC_PROFILE_INDEX].val,
                 prt_idx));
    }

    if (fld_bmp & L2_HOST_FLD_SBR_IDX) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_STRENGTH_PROFILE_INDEX].val,
                 l2c->l2_host_sbr_prf_index));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the entry fields of L2_HOST_TABLE.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] fld_bmp Field bitmap.
 * \param [out] l2addr L2 address structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
l2_host_table_entry_fields_get(int unit, bcmlt_entry_handle_t eh,
                               uint32_t fld_bmp, bcm_l2_addr_t *l2addr)
{
    uint64_t data = 0LL, dest = 0LL, dst_vp_group = 0LL;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    bcmi_ltsw_gport_info_t gport_info;
    bcm_gport_t gport = 0;
    int l2_if = 0, use_gport, ret_type;
    uint32_t ipmc_group = 0;
    const char *cdata;
    bcmi_ltsw_ecmp_member_dest_info_t dest_info;
    const bcmint_l2_id_map_t *id_map = NULL;
    const bcmint_l2_str_map_t *str_map = NULL;
    int dst_hit = 0, src_hit = 0, rv;

    SHR_FUNC_ENTER(unit);

    id_map  = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    str_map = L2_MAP_STR_INFO(unit, BCMINT_L2_MAP_SH_DEST_TYPE);
    if (id_map == NULL || str_map == NULL) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    if (fld_bmp & L2_HOST_FLD_VFI) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh, id_map[BCMINT_L2_HOST_FLD_VFI].val,
                                         &data));
        /* Transform VFI to VPN/vlan */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, data, &l2addr->vid));
    }

    if (fld_bmp & L2_HOST_FLD_MAC) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_MAC_ADDR].val, &data));
        bcmi_ltsw_util_uint64_to_mac(l2addr->mac, &data);
    }

    if (fld_bmp & L2_HOST_FLD_DST_TYPE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_DESTINATION_TYPE].val, &cdata));
    }

    if (fld_bmp & L2_HOST_FLD_DST) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_DESTINATION].val, &dest));
    }

    if ((fld_bmp & L2_HOST_FLD_MAC) && (fld_bmp & L2_HOST_FLD_DST_TYPE) &&
        (fld_bmp & L2_HOST_FLD_DST)) {
        if (BCM_MAC_IS_MCAST(l2addr->mac)) {
            l2addr->flags |= BCM_L2_MCAST;
            if (sal_strcmp(str_map[BCMINT_L2_DEST_TYPE_L2MC_GROUP].str,
                           cdata) == 0) {
                /* L2MC_GROUP */
                l2addr->l2mc_group = (bcm_multicast_t)dest;

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_switch_control_get(unit,
                                                 bcmSwitchL2McIdxRetType,
                                                 &ret_type));
                if (ret_type) {
                    _BCM_MULTICAST_GROUP_SET(l2addr->l2mc_group,
                                             _BCM_MULTICAST_TYPE_L2,
                                             l2addr->l2mc_group);
                }
            } else if (sal_strcmp(str_map[BCMINT_L2_DEST_TYPE_L3MC_GROUP].str,
                                  cdata) == 0) {
                ipmc_group = (uint32_t)dest;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_multicast_l3_grp_id_get(unit,
                                                       ipmc_group,
                                                       &l2addr->l2mc_group));
            }
        } else {
            /* L2_OIF */
            if (sal_strcmp(str_map[BCMINT_L2_DEST_TYPE_L2_OIF].str, cdata) == 0) {
                l2_if = (int)dest;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_l2_if_to_port(unit, l2_if, &gport));

                if (BCM_GPORT_IS_TRUNK(gport)) {
                    l2addr->flags |= BCM_L2_TRUNK_MEMBER;
                    l2addr->tgid = BCM_GPORT_TRUNK_GET(gport);
                } else if (BCM_GPORT_IS_MODPORT(gport)) {
                    l2addr->modid = BCM_GPORT_MODPORT_MODID_GET(gport);
                    l2addr->port = BCM_GPORT_MODPORT_PORT_GET(gport);
                } else {
                    l2addr->port = gport;
                }

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_switch_control_get(unit,
                                                 bcmSwitchUseGport,
                                                 &use_gport));

                if (use_gport) {
                    l2addr->port = gport;
                }
            } else if (sal_strcmp(str_map[BCMINT_L2_DEST_TYPE_VP].str,
                                  cdata) == 0) {
                if (fld_bmp & L2_HOST_FLD_DST_VP_GROUP) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_get_by_id(eh,
                             id_map[BCMINT_L2_HOST_FLD_DST_VP_GROUP].val,
                             &dst_vp_group));
                }

                if (dst_vp_group) {
                    int vp_lag_vp = (int)dest;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_trunk_vp_lag_vp_to_tid(unit, vp_lag_vp,
                                                          &l2addr->tgid));

                    l2addr->flags |= BCM_L2_TRUNK_MEMBER;

                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcm_ltsw_switch_control_get(unit,
                                                     bcmSwitchUseGport,
                                                     &use_gport));

                    if (use_gport) {
                        gport_info.gport_type = _SHR_GPORT_TYPE_TRUNK;
                        gport_info.tgid = l2addr->tgid;
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_port_gport_construct(unit,
                                                            &gport_info,
                                                            &l2addr->port));
                    }
                } else {
                    sal_memset(&vp_info, 0, sizeof(bcmi_ltsw_virtual_vp_info_t));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_virtual_vp_info_get(unit, (int)dest, &vp_info));
                    if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_MPLS) {
                        gport_info.gport_type = _SHR_GPORT_TYPE_MPLS_PORT;
                        gport_info.mpls_id = dest;
                    } else if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_FLOW) {
                        gport_info.gport_type = _SHR_GPORT_TYPE_FLOW_PORT;
                        gport_info.flow_id = dest;
                    }
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_port_gport_construct(unit,
                                                        &gport_info,
                                                        &l2addr->port));
                }
            } else if (sal_strcmp(str_map[BCMINT_L2_DEST_TYPE_ECMP_MEMBER].str,
                                  cdata) == 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_ecmp_member_dest_get(unit, dest, &dest_info));
                sal_memset(&vp_info, 0, sizeof(bcmi_ltsw_virtual_vp_info_t));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_vp_info_get(unit, dest_info.dvp, &vp_info));
                if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_MPLS) {
                    gport_info.gport_type = _SHR_GPORT_TYPE_MPLS_PORT;
                    gport_info.mpls_id = dest_info.dvp;
                } else if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_FLOW) {
                    gport_info.gport_type = _SHR_GPORT_TYPE_FLOW_PORT;
                    gport_info.flow_id = dest_info.dvp;
                } else {
                    SHR_ERR_EXIT(SHR_E_CONFIG);
                }
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_port_gport_construct(unit,
                                                    &gport_info,
                                                    &l2addr->port));
            }
        }
    }

    if (fld_bmp & L2_HOST_FLD_MISC_CTRL_1) {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_get_by_id(eh,
                  id_map[BCMINT_L2_HOST_FLD_MISC_CTRL_1].val, &data));
        if (data & (1 << L2_HOST_MISC_CTRL_1_DA_DROP)) {
            l2addr->flags |= BCM_L2_DISCARD_DST;
        }
        if (data & (1 << L2_HOST_MISC_CTRL_1_DA_COPY_TO_CPU)) {
            l2addr->flags |= BCM_L2_COPY_TO_CPU;
        }
        if (data & (1 << L2_HOST_MISC_CTRL_1_SA_DROP)) {
            l2addr->flags |= BCM_L2_DISCARD_SRC;
        }
        if (data & (1 << L2_HOST_MISC_CTRL_1_STATIC)) {
            l2addr->flags |= BCM_L2_STATIC;
        }
    }

    if (fld_bmp & (L2_HOST_FLD_SRC_ENTRY_IDX | L2_HOST_FLD_DST_ENTRY_IDX)) {
        rv = l2_hitbit_get(unit, eh, false, &dst_hit, &src_hit);
        if (SHR_FAILURE(rv)) {
            /*
             * Because hitbit is a debugging functionality, even though
             * hitbit set/get fails, it shouldn't stop here so that
             * the main functionality fails. Instead, it will alert
             * and continue to finish the main functionality.
             */
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "l2_hitbit_get fails rv(%d)!\n"),
                      rv));
        } else {
            if (dst_hit) {
                l2addr->flags |= BCM_L2_HIT | BCM_L2_DES_HIT;
            }
            if (src_hit) {
                l2addr->flags |= BCM_L2_HIT | BCM_L2_SRC_HIT;
            }
        }
    }

    if (fld_bmp & L2_HOST_FLD_CLASS_ID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_CLASS_ID].val, &data));
        l2addr->group = (int)data;
    }

    if (fld_bmp & L2_HOST_FLD_MISC_CTRL_0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_FLD_MISC_CTRL_0].val, &data));
        if (data & (1 << L2_HOST_MISC_CTRL_0_STATION)) {
            l2addr->flags |= BCM_L2_L3LOOKUP;
        }
        l2addr->opaque_ctrl_id = (data >> L2_HOST_MISC_CTRL_0_OPAQUE_CTRL) &
            L2_HOST_MISC_CTRL_0_OPAQUE_CTRL_MASK;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set entry fields of L2_HOST_NARROW_TABLE.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] l2addr L2 address structure.
 * \param [in] fld_bmp Field bitmap.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
l2_host_narrow_table_entry_fields_set(int unit, bcmlt_entry_handle_t eh,
                                      bcm_l2_addr_t *l2addr, uint32_t fld_bmp)
{
    uint64_t mac = 0, data = 0;
    bcm_port_t port_out;
    uint32_t vfi = 0;
    bcmi_ltsw_gport_info_t gport_info;
    bcm_gport_t gport = 0;
    int l2_if = 0, my_modid = 0, mc_group;
    bool l3mc = false, vp_lag = false;
    bcm_multicast_t group;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    int member_index = 0;
    bcm_if_t egress_if = 0;
    bcmi_ltsw_ecmp_member_dest_info_t dest_info;
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    int rv, vp_lag_vp;
    const bcmint_l2_id_map_t *id_map = NULL;
    const bcmint_l2_str_map_t *str_map = NULL;
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    id_map  = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    str_map = L2_MAP_STR_INFO(unit, BCMINT_L2_MAP_SH_DEST_TYPE);
    if (id_map == NULL || str_map == NULL) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    if (fld_bmp & L2_HOST_FLD_MAC) {
        bcmi_ltsw_util_mac_to_uint64(&mac, l2addr->mac);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_NARROW_FLD_MAC_ADDR].val, mac));
    }

    if (fld_bmp & L2_HOST_FLD_VFI) {
        if (l2addr->vid > BCM_VLAN_MAX &&
            !BCMI_LTSW_VIRTUAL_VPN_VFI_IS_SET(l2addr->vid)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        /* Transform vid to vfi */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vfi_idx_get(unit, l2addr->vid, &vfi));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_NARROW_FLD_VFI].val, vfi));
    }

    if (fld_bmp & (L2_HOST_FLD_DST | L2_HOST_FLD_DST_TYPE)) {
        if (BCM_MAC_IS_MCAST(l2addr->mac)) {
            if (_BCM_MULTICAST_IS_SET(l2addr->l2mc_group)) {
                if (!_BCM_MULTICAST_IS_L2(l2addr->l2mc_group)) {
                    l3mc = true;
                }
                mc_group = _BCM_MULTICAST_ID_GET(l2addr->l2mc_group);
            } else {
                mc_group = l2addr->l2mc_group;
            }

            if (l3mc) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_multicast_l3_grp_id_get(unit,
                                                       mc_group,
                                                       &group));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_symbol_add_by_id(eh,
                         id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION_TYPE].val,
                         str_map[BCMINT_L2_DEST_TYPE_L3MC_GROUP].str));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_symbol_add_by_id(eh,
                         id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION_TYPE].val,
                         str_map[BCMINT_L2_DEST_TYPE_L2MC_GROUP].str));
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add_by_id(eh,
                     id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION].val,
                     mc_group));
        } else {
            if (BCM_GPORT_IS_MPLS_PORT(l2addr->port) ||
                BCM_GPORT_IS_FLOW_PORT(l2addr->port)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_port_gport_validate(unit,
                                                   l2addr->port,
                                                   &port_out));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_vp_info_get(unit, port_out, &vp_info));

                if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                               l2addr->port,
                                                               &egress_if));

                    if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_CASCADED) {
                        /* Single-pointer model. */
                        dest_info.type = BCMI_LTSW_ECMP_MEMBER_DEST_T_L2_CASCADED;
                        dest_info.ul_egr_obj = egress_if;
                        dest_info.dvp = port_out;
                        dest_info.prot_swt_prfl_idx =
                                            BCMI_XFS_PROT_SWT_PROFILE_IDX_NHOP2;
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_ecmp_member_dest_alloc(unit,
                                                              &dest_info,
                                                              &member_index));
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmlt_entry_field_symbol_add_by_id(eh,
                                 id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION_TYPE].val,
                                 str_map[BCMINT_L2_DEST_TYPE_ECMP_MEMBER].str));
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmlt_entry_field_add_by_id(eh,
                                 id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION].val,
                                 member_index));
                    } else {
                        /*
                         * L2_HOST_NARROW_TABLE does not support
                         * double-pointer model.
                         */
                        SHR_ERR_EXIT(SHR_E_PARAM);
                    }
                } else {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_symbol_add_by_id(eh,
                         id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION_TYPE].val,
                         str_map[BCMINT_L2_DEST_TYPE_VP].str));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add_by_id(eh,
                             id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION].val,
                             port_out));
                }
            } else {
                bcm_module_t modid = -1;
                bcm_port_t port = -1;
                bcm_trunk_t trunk_id = -1;
                int vp = -1;

                if (BCM_GPORT_IS_MODPORT(l2addr->port)) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcm_ltsw_stk_my_modid_get(unit, &my_modid));
                    modid = BCM_GPORT_MODPORT_MODID_GET(l2addr->port);
                    if (modid == my_modid) {
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_port_gport_validate(unit,
                                                           l2addr->port,
                                                           &port_out));
                    }
                    gport = l2addr->port;
                } else if (BCM_GPORT_IS_SET(l2addr->port)) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_port_gport_resolve(unit,
                                                      l2addr->port,
                                                      &modid,
                                                      &port,
                                                      &trunk_id,
                                                      &vp));

                    if ((trunk_id != -1) && (vp == -1)) {
                        /* No need to validate. */
                    } else {
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_port_gport_validate(unit,
                                                           l2addr->port,
                                                           &port_out));
                    }
                    gport = l2addr->port;
                } else if (l2addr->flags & BCM_L2_TRUNK_MEMBER) {
                    trunk_id = l2addr->tgid;
                } else {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcm_ltsw_stk_my_modid_get(unit, &my_modid));
                    if (l2addr->modid == my_modid) {
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_port_gport_validate(unit,
                                                           l2addr->port,
                                                           &port_out));
                        gport_info.gport_type = _SHR_GPORT_TYPE_LOCAL;
                    } else {
                        gport_info.gport_type = _SHR_GPORT_TYPE_MODPORT;
                        gport_info.modid = l2addr->modid;
                    }
                    gport_info.port = l2addr->port;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_port_gport_construct(unit,
                                                        &gport_info,
                                                        &gport));
                }

                if (trunk_id != -1) {
                    rv = bcmi_ltsw_trunk_tid_to_vp_lag_vp(unit, trunk_id,
                                                          &vp_lag_vp);
                    if (SHR_SUCCESS(rv)) {
                        /* VP lag trunk. */
                        vp_lag = true;
                    } else {
                        /* Transform trunk id to l2 interface */
                        gport_info.gport_type = _SHR_GPORT_TYPE_TRUNK;
                        gport_info.tgid = trunk_id;
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmi_ltsw_port_gport_construct(unit,
                                                            &gport_info,
                                                            &gport));
                    }
                }

                if (vp_lag) {
                    /* L2_HOST_NARROW_TABLE does not support VP_LAG. */
                    SHR_ERR_EXIT(SHR_E_PARAM);
                } else {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmi_ltsw_port_to_l2_if(unit, gport, &l2_if));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_symbol_add_by_id(eh,
                             id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION_TYPE].val,
                             str_map[BCMINT_L2_DEST_TYPE_L2_OIF].str));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add_by_id(eh,
                             id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION].val,
                             l2_if));
                }
            }
        }
    }

    if (fld_bmp & L2_HOST_FLD_MISC_CTRL_1) {
        if (l2addr->flags & BCM_L2_DISCARD_DST) {
            data |= 1 << L2_HOST_MISC_CTRL_1_DA_DROP;
        } else {
            data &= ~(1 << L2_HOST_MISC_CTRL_1_DA_DROP);
        }

        if (l2addr->flags & BCM_L2_COPY_TO_CPU) {
            data |= 1 << L2_HOST_MISC_CTRL_1_DA_COPY_TO_CPU;
        } else {
            data &= ~(1 << L2_HOST_MISC_CTRL_1_DA_COPY_TO_CPU);
        }

        if (l2addr->flags & BCM_L2_DISCARD_SRC) {
            data |= 1 << L2_HOST_MISC_CTRL_1_SA_DROP;
        } else {
            data &= ~(1 << L2_HOST_MISC_CTRL_1_SA_DROP);
        }

        if (l2addr->flags & BCM_L2_STATIC) {
            data |= 1 << L2_HOST_MISC_CTRL_1_STATIC;
        } else {
            data &= ~(1 << L2_HOST_MISC_CTRL_1_STATIC);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_NARROW_FLD_MISC_CTRL_1].val,
                 data));
    }

    if (fld_bmp & L2_HOST_FLD_FLEX_CTR_ACTION) {
        if (l2c->flexctr_info) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_flexctr_counter_id_info_get(unit,
                     l2c->flexctr_info->dst_grp_id,
                     &counter_info));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add_by_id(eh,
                     id_map[BCMINT_L2_HOST_NARROW_FLD_FLEX_CTR_ACTION].val,
                     counter_info.action_index));
        }
    }

    if (fld_bmp & L2_HOST_FLD_MISC_CTRL_0) {
        /* Set my_station bit to add an interface address */
        data = 0;
        if (l2addr->flags & BCM_L2_L3LOOKUP) {
            data |= 1 << L2_HOST_MISC_CTRL_0_STATION;
        } else {
            data &= ~(1 << L2_HOST_MISC_CTRL_0_STATION);
        }

        /* Opaque control bits. */
        data |= l2addr->opaque_ctrl_id << L2_HOST_MISC_CTRL_0_OPAQUE_CTRL;

        /* Set entry_valid bit */
        data |= 1 << 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add_by_id(eh,
                 id_map[BCMINT_L2_HOST_NARROW_FLD_MISC_CTRL_0].val, data));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the entry fields of L2_HOST_NARROW_TABLE.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] fld_bmp Field bitmap.
 * \param [out] l2addr L2 address structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
l2_host_narrow_table_entry_fields_get(int unit, bcmlt_entry_handle_t eh,
                                      uint32_t fld_bmp, bcm_l2_addr_t *l2addr)
{
    uint64_t data = 0LL, dest = 0LL;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    bcmi_ltsw_gport_info_t gport_info;
    bcm_gport_t gport = 0;
    int l2_if = 0, use_gport, ret_type;
    uint32_t ipmc_group = 0;
    const char *cdata;
    bcmi_ltsw_ecmp_member_dest_info_t dest_info;
    const bcmint_l2_id_map_t *id_map = NULL;
    const bcmint_l2_str_map_t *str_map = NULL;
    int dst_hit = 0, src_hit = 0, rv;

    SHR_FUNC_ENTER(unit);

    id_map  = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    str_map = L2_MAP_STR_INFO(unit, BCMINT_L2_MAP_SH_DEST_TYPE);
    if (id_map == NULL || str_map == NULL) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    if (fld_bmp & L2_HOST_FLD_VFI) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_NARROW_FLD_VFI].val, &data));
        /* Transform VFI to VPN/vlan */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, data, &l2addr->vid));
    }

    if (fld_bmp & L2_HOST_FLD_MAC) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_NARROW_FLD_MAC_ADDR].val, &data));
        bcmi_ltsw_util_uint64_to_mac(l2addr->mac, &data);
    }

    if (fld_bmp & L2_HOST_FLD_DST_TYPE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION_TYPE].val,
                 &cdata));
    }
    if (fld_bmp & L2_HOST_FLD_DST) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_NARROW_FLD_DESTINATION].val, &dest));
    }

    if ((fld_bmp & L2_HOST_FLD_MAC) && (fld_bmp & L2_HOST_FLD_DST_TYPE) &&
        (fld_bmp & L2_HOST_FLD_DST)) {
        if (BCM_MAC_IS_MCAST(l2addr->mac)) {
            l2addr->flags |= BCM_L2_MCAST;
            if (sal_strcmp(str_map[BCMINT_L2_DEST_TYPE_L2MC_GROUP].str,
                           cdata) == 0) {
                /* L2MC_GROUP */
                l2addr->l2mc_group = (bcm_multicast_t)dest;

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_switch_control_get(unit,
                                                 bcmSwitchL2McIdxRetType,
                                                 &ret_type));
                if (ret_type) {
                    _BCM_MULTICAST_GROUP_SET(l2addr->l2mc_group,
                                             _BCM_MULTICAST_TYPE_L2,
                                             l2addr->l2mc_group);
                }
            } else if (sal_strcmp(str_map[BCMINT_L2_DEST_TYPE_L3MC_GROUP].str,
                                  cdata) == 0) {
                ipmc_group = (uint32_t)dest;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_multicast_l3_grp_id_get(unit,
                                                       ipmc_group,
                                                       &l2addr->l2mc_group));
            }
        } else {
            /* L2_OIF */
            if (sal_strcmp(str_map[BCMINT_L2_DEST_TYPE_L2_OIF].str, cdata) == 0) {
                l2_if = (int)dest;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_l2_if_to_port(unit, l2_if, &gport));

                if (BCM_GPORT_IS_TRUNK(gport)) {
                    l2addr->flags |= BCM_L2_TRUNK_MEMBER;
                    l2addr->tgid = BCM_GPORT_TRUNK_GET(gport);
                } else if (BCM_GPORT_IS_MODPORT(gport)) {
                    l2addr->modid = BCM_GPORT_MODPORT_MODID_GET(gport);
                    l2addr->port = BCM_GPORT_MODPORT_PORT_GET(gport);
                } else {
                    l2addr->port = gport;
                }

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_switch_control_get(unit,
                                                 bcmSwitchUseGport,
                                                 &use_gport));

                if (use_gport) {
                    l2addr->port = gport;
                }
            } else if (sal_strcmp(str_map[BCMINT_L2_DEST_TYPE_VP].str,
                                  cdata) == 0) {
                sal_memset(&vp_info, 0, sizeof(bcmi_ltsw_virtual_vp_info_t));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_vp_info_get(unit, (int)dest, &vp_info));
                if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_MPLS) {
                    gport_info.gport_type = _SHR_GPORT_TYPE_MPLS_PORT;
                    gport_info.mpls_id = dest;
                } else if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_FLOW) {
                    gport_info.gport_type = _SHR_GPORT_TYPE_FLOW_PORT;
                    gport_info.flow_id = dest;
                }
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_port_gport_construct(unit,
                                                    &gport_info,
                                                    &l2addr->port));
            } else if (sal_strcmp(str_map[BCMINT_L2_DEST_TYPE_ECMP_MEMBER].str,
                                  cdata) == 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_ecmp_member_dest_get(unit, dest, &dest_info));
                sal_memset(&vp_info, 0, sizeof(bcmi_ltsw_virtual_vp_info_t));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_vp_info_get(unit, dest_info.dvp, &vp_info));
                if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_MPLS) {
                    gport_info.gport_type = _SHR_GPORT_TYPE_MPLS_PORT;
                    gport_info.mpls_id = dest_info.dvp;
                } else if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_FLOW) {
                    gport_info.gport_type = _SHR_GPORT_TYPE_FLOW_PORT;
                    gport_info.flow_id = dest_info.dvp;
                } else {
                    SHR_ERR_EXIT(SHR_E_CONFIG);
                }
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_port_gport_construct(unit,
                                                    &gport_info,
                                                    &l2addr->port));
            }
        }
    }

    if (fld_bmp & L2_HOST_FLD_MISC_CTRL_1) {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_get_by_id(eh,
                  id_map[BCMINT_L2_HOST_NARROW_FLD_MISC_CTRL_1].val, &data));
        if (data & (1 << L2_HOST_MISC_CTRL_1_DA_DROP)) {
            l2addr->flags |= BCM_L2_DISCARD_DST;
        }
        if (data & (1 << L2_HOST_MISC_CTRL_1_DA_COPY_TO_CPU)) {
            l2addr->flags |= BCM_L2_COPY_TO_CPU;
        }
        if (data & (1 << L2_HOST_MISC_CTRL_1_SA_DROP)) {
            l2addr->flags |= BCM_L2_DISCARD_SRC;
        }
        if (data & (1 << L2_HOST_MISC_CTRL_1_STATIC)) {
            l2addr->flags |= BCM_L2_STATIC;
        }
    }

    if (fld_bmp & (L2_HOST_FLD_SRC_ENTRY_IDX | L2_HOST_FLD_DST_ENTRY_IDX)) {
        rv = l2_hitbit_get(unit, eh, true, &dst_hit, &src_hit);
        if (SHR_FAILURE(rv)) {
            /*
             * Because hitbit is a debugging functionality, even though
             * hitbit set/get fails, it shouldn't stop here so that
             * the main functionality fails. Instead, it will alert
             * and continue to finish the main functionality.
             */
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "l2_hitbit_get fails rv(%d)!\n"),
                      rv));
        } else {
            if (dst_hit) {
                l2addr->flags |= BCM_L2_HIT | BCM_L2_DES_HIT;
            }
            if (src_hit) {
                l2addr->flags |= BCM_L2_HIT | BCM_L2_SRC_HIT;
            }
        }
    }

    if (fld_bmp & L2_HOST_FLD_MISC_CTRL_0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get_by_id(eh,
                 id_map[BCMINT_L2_HOST_NARROW_FLD_MISC_CTRL_0].val, &data));
        if (data & (1 << L2_HOST_MISC_CTRL_0_STATION)) {
            l2addr->flags |= BCM_L2_L3LOOKUP;
        }
        l2addr->opaque_ctrl_id = (data >> L2_HOST_MISC_CTRL_0_OPAQUE_CTRL) &
            L2_HOST_MISC_CTRL_0_OPAQUE_CTRL_MASK;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Populate LT entry according to API data structure.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] l2addr L2 address structure.
 * \param [in] fld_bmp Field bitmap.
 * \param [in] single True for single wide view(L2_HOST_NARROW_TABLE),
 *                    false for double wide view(L2_HOST_TABLE).
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
l2_entry_populate(int unit, bcmlt_entry_handle_t eh,
                  bcm_l2_addr_t *l2addr, uint32_t fld_bmp, bool single)
{
    SHR_FUNC_ENTER(unit);

    if (single) {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_host_narrow_table_entry_fields_set(unit, eh, l2addr, fld_bmp));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_host_table_entry_fields_set(unit, eh, l2addr, fld_bmp));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse LT entry and fill API data structure.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] fld_bmp Field bitmap.
 * \param [in] single True for single wide view(L2_HOST_NARROW_TABLE),
 *                    false for double wide view(L2_HOST_TABLE).
 * \param [out] l2addr L2 address structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
l2_entry_parse(int unit, bcmlt_entry_handle_t eh, uint32_t fld_bmp,
               bool single, bcm_l2_addr_t *l2addr)
{
    SHR_FUNC_ENTER(unit);

    if (single) {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_host_narrow_table_entry_fields_get(unit, eh, fld_bmp, l2addr));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_host_table_entry_fields_get(unit, eh, fld_bmp, l2addr));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Populate L2 station entry according to API data structure.
 *
 * \param [in]   unit         Unit number
 * \param [in]   eh           LT entry handle.
 * \param [in]   station      L2 station structure.
 * \param [bool] key_only     Only populate key.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
l2_station_entry_populate(int unit, bcmlt_entry_handle_t eh,
                          bcm_l2_station_t *station, bool key_only)
{
    uint64_t mac = 0, mac_mask = 0;
    bcm_port_t port, port_mask, port_mask_max;
    int mod = -1, mod_mask = -1, id, id_mask;
    bcm_trunk_t tid = BCM_TRUNK_INVALID, tid_mask;
    int l2iif, l2iif_mask;
    bcmi_ltsw_l2_station_vlan_t vlan_info;
    uint32_t vfi;

    SHR_FUNC_ENTER(unit);

    bcmi_ltsw_util_mac_to_uint64(&mac, station->dst_mac);
    bcmi_ltsw_util_mac_to_uint64(&mac_mask, station->dst_mac_mask);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, MACDAs, mac));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, MACDA_MASKs, mac_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_IIF_VFIs, station->vfi));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_IIF_VFI_MASKs, station->vfi_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, OVIDs, station->vlan));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, OVID_MASKs, station->vlan_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, IVIDs, station->inner_vlan));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, IVID_MASKs, station->inner_vlan_mask));

    if (station->src_port_mask == 0) {
        l2iif = 0;
        l2iif_mask = 0;
    } else if (BCM_GPORT_IS_SET(station->src_port)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_resolve(unit,
                                          station->src_port,
                                          &mod,
                                          &port,
                                          &tid,
                                          &id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_resolve(unit,
                                          station->src_port_mask,
                                          &mod_mask,
                                          &port_mask,
                                          &tid_mask,
                                          &id_mask));
        if (BCM_GPORT_IS_TRUNK(station->src_port)) {
            if (tid == BCM_TRUNK_INVALID) {
                SHR_ERR_EXIT(SHR_E_PORT);
            }
        } else {
            if (mod == -1 || port == -1) {
                SHR_ERR_EXIT(SHR_E_PORT);
            }
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_to_l2_if(unit, station->src_port, &l2iif));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_to_l2_if(unit,
                                     station->src_port_mask,
                                     &l2iif_mask));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_validate(unit,
                                           station->src_port,
                                           &station->src_port));

        port_mask_max = bcmi_ltsw_dev_max_port_addr(unit);
        if (station->src_port_mask > port_mask_max) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_to_l2_if(unit, station->src_port, &l2iif));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_mask_to_l2_if_mask(unit,
                                               station->src_port_mask,
                                               &l2iif_mask));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_IIFs, l2iif));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_IIF_MASKs, l2iif_mask));

    if (!key_only) {
        sal_memset(&vlan_info, 0, sizeof(bcmi_ltsw_l2_station_vlan_t));
        if (station->forwarding_domain) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vfi_idx_get(unit,
                                               station->forwarding_domain,
                                               &vfi));
            vlan_info = *L2_VLAN_INFO(unit, vfi);
        } else if ((station->vlan & station->vlan_mask) &&
            (BCM_VLAN_VALID(station->vlan))) {
            vlan_info = *L2_VLAN_INFO(unit, station->vlan);
        } else if ((station->vfi & station->vfi_mask) &&
                   (BCM_VLAN_VALID(station->vfi))) {
            vlan_info = *L2_VLAN_INFO(unit, station->vfi);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh,
                                   MEMBERSHIP_PROFILE_PTRs,
                                   vlan_info.member_prf_ptr));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh,
                                   SPANNING_TREE_GROUPs,
                                   vlan_info.stg));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, VALIDs, true));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh,
                                   ENTRY_PRIORITYs,
                                   station->priority + L2_STATION_PRI_OFFSET));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse LT entry and fill API data structure.
 *
 * \param [in]   unit         Unit number
 * \param [in]   eh           LT entry handle.
 * \param [in]   station      L2 station structure.
 * \param [bool] no_key       Do not parse key.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
l2_station_entry_parse(int unit, bcmlt_entry_handle_t eh,
                       bcm_l2_station_t *station, bool no_key)
{
    uint64_t data = 0LL;
    int l2_if, l2_if_mask, modid, my_modid, use_gport;
    bcm_gport_t gport = 0;
    bcm_port_t port;

    SHR_FUNC_ENTER(unit);

    if (!no_key) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, MACDAs, &data));
        bcmi_ltsw_util_uint64_to_mac(station->dst_mac, &data);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, MACDA_MASKs, &data));
        bcmi_ltsw_util_uint64_to_mac(station->dst_mac_mask, &data);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, L2_IIF_VFIs, &data));
        station->vfi = (bcm_vlan_t)data;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, L2_IIF_VFI_MASKs, &data));
        station->vfi_mask = (bcm_vlan_t)data;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, OVIDs, &data));
        station->vlan = (bcm_vlan_t)data;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, OVID_MASKs, &data));
        station->vlan_mask = (bcm_vlan_t)data;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, IVIDs, &data));
        station->inner_vlan = (bcm_vlan_t)data;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, IVID_MASKs, &data));
        station->inner_vlan_mask = (bcm_vlan_t)data;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_stk_my_modid_get(unit, &my_modid));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, L2_IIFs, &data));
        l2_if = (int)data;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l2_if_to_port(unit, l2_if, &gport));
        if (BCM_GPORT_IS_MODPORT(gport)) {
            modid = BCM_GPORT_MODPORT_MODID_GET(gport);
            port = BCM_GPORT_MODPORT_PORT_GET(gport);

            if (modid == my_modid) {
                station->src_port = port;
            } else {
                station->src_port = gport;
            }
        } else {
            station->src_port = gport;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_switch_control_get(unit, bcmSwitchUseGport, &use_gport));

        if (use_gport) {
            station->src_port = gport;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, L2_IIF_MASKs, &data));
        l2_if_mask = (int)data;

        if (BCM_GPORT_IS_SET(station->src_port)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l2_if_to_port(unit,
                                         l2_if_mask,
                                         &station->src_port_mask));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l2_if_mask_to_port_mask(unit,
                                                   l2_if_mask,
                                                   &station->src_port_mask));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, ENTRY_PRIORITYs, &data));
    station->priority = (int)(data - L2_STATION_PRI_OFFSET);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check station parameters.
 *
 * \param [in]   unit         Unit number
 * \param [in]   station      L2 station structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval !SHR_E_NONE        Failure.
 */
static int
l2_station_params_check(int unit, bcm_l2_station_t *station)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(station, SHR_E_PARAM);

    if (station->flags &
        (BCM_L2_STATION_IPV4 |
         BCM_L2_STATION_IPV6 |
         BCM_L2_STATION_ARP_RARP |
         BCM_L2_STATION_MPLS |
         BCM_L2_STATION_MIM |
         BCM_L2_STATION_TRILL |
         BCM_L2_STATION_FCOE |
         BCM_L2_STATION_OAM |
         BCM_L2_STATION_COPY_TO_CPU |
         BCM_L2_STATION_OLP |
         BCM_L2_STATION_XGS_MAC |
         BCM_L2_STATION_IPV4_MCAST |
         BCM_L2_STATION_IPV6_MCAST |
         BCM_L2_STATION_UNDERLAY |
         BCM_L2_STATION_DISCARD)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (l2c->station_disable) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (station->priority < L2_STATION_RSVD_PRI) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Determine which view for a vlan.
 *
 * \param [in] unit Unit number.
 * \param [in] info L2 table view vlan info.
 *
 * \retval True for single view, false for double view.
 */
static int
l2_vlan_is_single_view(int unit, bcm_vlan_t vlan)
{
    int rv;
    uint32_t vfi;
    bool single = false;

    /* Transform vid to vfi */
    rv = bcmi_ltsw_virtual_vfi_idx_get(unit, vlan, &vfi);
    if (SHR_FAILURE(rv)) {
        return single;
    }

    single = L2_VIEW_BMP_USED_GET(unit, vfi);
    return single;
}

/*!
 * \brief Internal function to transform replace dest structure to destination.
 *
 * \param [in] unit Unit number.
 * \param [in] rep_dest Replace dest structure pointer.
 * \param [out] l2addr L2 address structure pointer.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Invalid parameter.
 */
static int
l2_replace_dest_transform(int unit, bcmint_l2_replace_dest_t *rep_dest,
                          bcm_l2_addr_t *l2addr)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(rep_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(l2addr, SHR_E_PARAM);

    l2addr->flags &= ~BCM_L2_TRUNK_MEMBER;
    l2addr->tgid = 0;
    l2addr->port = 0;
    l2addr->modid = 0;

    if (rep_dest->trunk != -1) {
        l2addr->flags |= BCM_L2_TRUNK_MEMBER;
        l2addr->tgid = rep_dest->trunk;
    } else {
        if (BCM_GPORT_IS_SET(rep_dest->port)) {
            l2addr->port = rep_dest->port;
        } else {
            l2addr->modid = rep_dest->module;
            l2addr->port = rep_dest->port;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Internal callback function for l2 replace op.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  trav_st       Traverse structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
l2_replace_int_cb(int unit, void *trav_st)
{
    bcmint_l2_replace_t      *rep_st = NULL;
    bcmint_l2_traverse_t     *trv = NULL;
    bcmlt_entry_handle_t   eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t          l2addr, l2addr_add;
    bool notify = NOTIFY_L2_EVENT(unit);
    bcm_gport_t gport = 0;
    bool single = false;
    uint32_t fld_bmp = 0;
    const bcmint_l2_id_map_t *id_map = NULL;
    uint32_t tid;
    bool src = false, dst = false;
    int rv;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Determine which view to parse. */
    tid = id_map[BCMINT_L2_HOST_NARROW_TBL].val;
    if (trv->tid == tid) {
        single = true;
    }

    rep_st = trv->user_data;
    if (rep_st == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    eh = trv->eh;
    if (eh == BCMLT_INVALID_HDL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (rep_st->flags & BCM_L2_REPLACE_NO_CALLBACKS) {
        notify = false;
    }

    sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
    if (!notify) {
        if (rep_st->flags & BCM_L2_REPLACE_MATCH_VLAN) {
            fld_bmp |= L2_HOST_FLD_VFI;
        }
        if (rep_st->flags & (BCM_L2_REPLACE_MATCH_MAC | BCM_L2_REPLACE_MATCH_UC
                             | BCM_L2_REPLACE_MATCH_MC)) {
            fld_bmp |= L2_HOST_FLD_MAC;
        }
        if (rep_st->flags & BCM_L2_REPLACE_MATCH_DEST) {
            fld_bmp |= L2_HOST_FLD_MAC | L2_HOST_FLD_DST_TYPE |
                       L2_HOST_FLD_DST;
        }
        if (!(rep_st->flags & BCM_L2_REPLACE_MATCH_STATIC)) {
            fld_bmp |= L2_HOST_FLD_MISC_CTRL_1;
        }
        if (rep_st->flags & BCM_L2_REPLACE_MATCH_CLASS_ID) {
            fld_bmp |= L2_HOST_FLD_CLASS_ID;
        }
    } else {
        fld_bmp = L2_HOST_FLD_ALL;
    }

    rv = l2_entry_parse(unit, eh, fld_bmp, single, &l2addr);
    if (rv == SHR_E_NOT_FOUND) {
        /* Skip the entry which parse fails. */
        SHR_EXIT();
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    if (rep_st->flags & BCM_L2_REPLACE_MATCH_VLAN) {
        if (rep_st->key_vlan != l2addr.vid) {
            SHR_EXIT();
        }
    }

    if (rep_st->flags & BCM_L2_REPLACE_MATCH_MAC) {
        if (sal_memcmp(rep_st->key_mac, l2addr.mac, sizeof(bcm_mac_t))) {
            SHR_EXIT();
        }
    }

    if (rep_st->flags & BCM_L2_REPLACE_MATCH_DEST) {
        if (rep_st->match_dest.trunk != -1) {
            if (rep_st->match_dest.trunk != l2addr.tgid) {
                SHR_EXIT();
            }
        } else if (rep_st->match_dest.vp != -1) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vp_encode_gport(unit,
                                                   rep_st->match_dest.vp,
                                                   &gport));
            if (gport != l2addr.port) {
                SHR_EXIT();
            }
        } else if (BCM_GPORT_IS_SET(rep_st->match_dest.port)) {
            if (rep_st->match_dest.port != l2addr.port) {
                SHR_EXIT();
            }
        } else {
            if (rep_st->int_flags & BCMINT_L2_REPLACE_IGNORE_PORTID) {
                if (rep_st->match_dest.module != l2addr.modid) {
                    SHR_EXIT();
                }
            } else if (rep_st->match_dest.port != l2addr.port ||
                rep_st->match_dest.module != l2addr.modid) {
                SHR_EXIT();
            }
        }
    }

    /* Check if user wants static field matched with the entry's static bit */
    if (!(rep_st->flags & BCM_L2_REPLACE_MATCH_STATIC)) {
        /* BCM_L2_REPLACE_MATCH_STATIC means to replace static as well as
         * non-static entries */
        if (l2addr.flags & BCM_L2_STATIC) {
            SHR_EXIT();
        }
    }

    if ((rep_st->flags & BCM_L2_REPLACE_MATCH_UC &&
         !(rep_st->flags & BCM_L2_REPLACE_MATCH_MC) &&
         BCM_MAC_IS_MCAST(l2addr.mac)) ||
        (rep_st->flags & BCM_L2_REPLACE_MATCH_MC &&
         !(rep_st->flags & BCM_L2_REPLACE_MATCH_UC) &&
         !BCM_MAC_IS_MCAST(l2addr.mac))) {
        SHR_EXIT();
    }

    if (rep_st->flags & BCM_L2_REPLACE_MATCH_CLASS_ID) {
        if (rep_st->key_class_id != l2addr.group) {
            SHR_EXIT();
        }
    }

    if (rep_st->flags & BCM_L2_REPLACE_DELETE) {
        /* Free external resource if any. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_external_resource_free(unit, &l2addr, eh, single));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh,
                                BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL));
    } else {
        if (rep_st->flags & BCM_L2_REPLACE_DES_HIT_CLEAR) {
            dst = true;
        }
        if (rep_st->flags & BCM_L2_REPLACE_SRC_HIT_CLEAR) {
            src = true;
        }

        sal_memcpy(&l2addr_add, &l2addr, sizeof(bcm_l2_addr_t));
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_replace_dest_transform(unit,
                                       &rep_st->new_dest,
                                       &l2addr_add));

        /* Free external resource if any. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_external_resource_free(unit, &l2addr, eh, single));

        SHR_IF_ERR_VERBOSE_EXIT
            (l2_field_bmp_set(unit, L2_EVENT_UPDATE, notify, single,
                              &fld_bmp, NULL));

        /* Set hitbit if needed. */
        if (fld_bmp & (L2_HOST_FLD_DST_ENTRY_IDX | L2_HOST_FLD_SRC_ENTRY_IDX)) {
            if (dst) {
                l2addr_add.flags &= ~(BCM_L2_HIT | BCM_L2_DES_HIT);
            }
            if (src) {
                l2addr_add.flags &= ~(BCM_L2_HIT | BCM_L2_SRC_HIT);
            }
            rv = l2_hitbit_set(unit, eh, dst, src, &l2addr_add, single);
            if (SHR_FAILURE(rv)) {
                /*
                 * Because hitbit is a debugging functionality, even though
                 * hitbit set/get fails, it shouldn't stop here so that
                 * the main functionality fails. Instead, it will alert
                 * and continue to finish the main functionality.
                 */
                LOG_WARN(BSL_LOG_MODULE,
                         (BSL_META_U(unit, "l2_hitbit_set fails rv(%d)!\n"),
                          rv));
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_populate(unit, eh, &l2addr_add, fld_bmp, single));

        /* Remove read-only fields. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_read_only_fields_remove(unit, eh));

        /* Perform replace action on matching entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh,
                                BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    }

    if (notify) {
        if (rep_st->flags & BCM_L2_REPLACE_DELETE) {
            bcmint_l2_event_notify(unit, NULL, &l2addr, L2_EVENT_DELETE);
        } else {
            bcmint_l2_event_notify(unit, &l2addr_add, &l2addr, L2_EVENT_UPDATE);
        }
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Transform learn cache data entry into L2 address structure.
 *
 * \param [in] unit Unit number.
 * \param [in] eh Entry handle, used to traverse L2 learn cache data.
 * \param [in] eh Entry handle, used to delete L2 learn cache data.
 * \param [out] l2addr L2 address structure.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static void
l2_learn_cache_data_to_l2addr(int unit, bcmlt_entry_handle_t eh,
                              bcmlt_entry_handle_t eh_backup,
                              bcm_l2_addr_t *l2addr)
{
    uint64_t data = 0LL;
    int l2_if = 0, vp = 0, rv, i;
    bcm_gport_t gport = 0;
    uint16_t cache[8], fid;
    const bcmint_l2_id_map_t *id_map = NULL;

    if (l2addr == NULL) {
        LOG_WARN(BSL_LOG_MODULE,
                 (BSL_META_U(unit, "Invalid Parameter!\n")));
        return;
    }

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_LEARN_CACHE_DATA_TABLE);
    if (id_map == NULL) {
        return;
    }
    for (i = 0; i < 2; i++) {
        if (i == 0) {
            fid = id_map[BCMINT_L2_LEARN_CACHE_DATA_FLD_PIPE].val;
        } else {
            fid = id_map[BCMINT_L2_LEARN_CACHE_DATA_FLD_LEARN_CACHE_DATA_ID].val;
        }
        rv = bcmlt_entry_field_get_by_id(eh, fid, &data);
        if (SHR_FAILURE(rv)) {
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "Key field add failed (%d)!\n"), rv));
            return;
        }
        rv = bcmlt_entry_field_add_by_id(eh_backup, fid, data);
        if (SHR_FAILURE(rv)) {
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "Key field add failed (%d)!\n"), rv));
            return;
        }
    }
    for (i = 0; i < 8; i++) {
        fid = id_map[BCMINT_L2_LEARN_CACHE_DATA_FLD_CACHE_FIELD0 + i].val;
        rv = bcmlt_entry_field_get_by_id(eh, fid, &data);
        if (SHR_FAILURE(rv)) {
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "Field get failed (%d)!\n"), rv));
            return;
        }
        cache[i] = (uint16_t)data;
    }

    data = 0;
    data |= ((uint64_t)cache[0] & 0xffff);
    data |= ((uint64_t)cache[1] & 0xffff) << 16;
    data |= ((uint64_t)cache[2] & 0xffff) << 32;
    bcmi_ltsw_util_uint64_to_mac(l2addr->mac, &data);

    /* Transform VFI to VPN/vlan */
    rv = bcmi_ltsw_virtual_vpnid_get(unit, cache[3], &l2addr->vid);
    if (SHR_FAILURE(rv)) {
        LOG_WARN(BSL_LOG_MODULE,
                 (BSL_META_U(unit, "VFI transform failed (%d)!\n"), rv));
        return;
    }

    if (cache[6] == BCMI_XFS_DEST_TYPE_L2_OIF) {
        l2_if = cache[4];

        rv = bcmi_ltsw_l2_if_to_port(unit, l2_if, &gport);
        if (SHR_FAILURE(rv)) {
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "L2 interface transform failed (%d)!\n"),
                      rv));
            return;
        }

        if (BCM_GPORT_IS_TRUNK(gport)) {
            l2addr->flags |= BCM_L2_TRUNK_MEMBER;
            l2addr->tgid = BCM_GPORT_TRUNK_GET(gport);
        } else if (BCM_GPORT_IS_MODPORT(gport)) {
            l2addr->modid = BCM_GPORT_MODPORT_MODID_GET(gport);
            l2addr->port = BCM_GPORT_MODPORT_PORT_GET(gport);
        } else {
            l2addr->port = gport;
        }
    } else if (cache[6] == BCMI_XFS_DEST_TYPE_VP) {
        vp = cache[4];

        rv = bcmi_ltsw_virtual_vp_encode_gport(unit, vp, &gport);
        if (SHR_FAILURE(rv)) {
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "VP encode failed (%d)!\n"), rv));
            return;
        }
        if (BCM_GPORT_IS_VPLAG_PORT(gport)) {
            int vp_lag_vp = BCM_GPORT_VPLAG_PORT_ID_GET(gport);

            rv = bcmi_ltsw_trunk_vp_lag_vp_to_tid(unit, vp_lag_vp,
                                                  &l2addr->tgid);
            if (SHR_FAILURE(rv)) {
                LOG_WARN(BSL_LOG_MODULE,
                         (BSL_META_U(unit,
                                     "Can not find VPLAG trunk id (%s)!\n"),
                          shr_errmsg(rv)));
                return;
            }
            l2addr->flags |= BCM_L2_TRUNK_MEMBER;
        } else {
            l2addr->port = gport;
        }
    }
}

/*!
 * \brief L2 module traverse function.
 *
 * \param [in] unit Unit number.
 * \param [in] trav_st Traverse structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_learn_traverse(int unit, bcmint_l2_traverse_t *trav_st)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t eh_backup = BCMLT_INVALID_HDL;
    int dunit;
    int rv = SHR_E_NONE, rv_cb;
    bcm_l2_addr_t l2addr;

    SHR_FUNC_ENTER(unit);

    if (trav_st == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, trav_st->tid,
                                    trav_st->fld_cnt, &eh_backup));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, trav_st->tid,
                                    trav_st->fld_cnt, &eh));
    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_TRAVERSE,
                            BCMLT_PRIORITY_NORMAL);
    while (rv == SHR_E_NONE) {
        /* Get and save data of the current entry */
        sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
        l2_learn_cache_data_to_l2addr(unit, eh, eh_backup, &l2addr);

        trav_st->internal_data = (void *)&l2addr;
        trav_st->eh = eh_backup;

        /* Traverse to the next entry */
        rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_TRAVERSE,
                                BCMLT_PRIORITY_NORMAL);
        /* Delete or update data from or into the current entry */
        rv_cb = trav_st->int_cb(unit, (void *)trav_st);
        if (SHR_FAILURE(rv_cb)) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "int_cb return ERR[%d].\n"),
                      rv_cb));
            break;
        }
    }
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_EXIT(rv);

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    if (eh_backup != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh_backup);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief L2 module traverse function.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  trav_st       Traverse structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
l2_traverse(int unit, bcmint_l2_traverse_t *trav_st)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t eh_next = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t eh_tmp = BCMLT_INVALID_HDL;
    int dunit;
    int rv = SHR_E_NONE, rv_cb = SHR_E_NONE;
    int with_lock;
    uint32_t attrib = 0;
    uint32_t fld_bmp = L2_HOST_FLD_VFI | L2_HOST_FLD_MAC;
    bcm_l2_addr_t l2addr;
    const bcmint_l2_id_map_t *id_map = NULL;
    uint32_t tid;
    bool single = false, locked = false;
    uint32_t count = 0;

    SHR_FUNC_ENTER(unit);

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    if (trav_st == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    with_lock = trav_st->flags & BCMINT_L2_TRAVERSE_WITH_LOCK;

    /* Determine which view to parse. */
    tid = id_map[BCMINT_L2_HOST_NARROW_TBL].val;
    if (trav_st->tid == tid) {
        single = true;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_inuse_cnt_get(unit,
            single ? L2_HOST_NARROW_TABLEs : L2_HOST_TABLEs,
            &count));
    /* No entry, exit. */
    if (count == 0) {
        SHR_EXIT();
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, trav_st->tid,
                                    trav_st->fld_cnt, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, trav_st->tid,
                                    trav_st->fld_cnt, &eh_next));

    if (trav_st->flags & BCMINT_L2_TRAVERSE_HW) {
        attrib = BCMLT_ENT_ATTR_GET_FROM_HW;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_attrib_set(eh, attrib));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_attrib_set(eh_next, attrib));
    if (with_lock) {
        L2T_LOCK(unit);
        locked = true;
    }

    /* GET_FIRST. */
    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_TRAVERSE,
                            BCMLT_PRIORITY_NORMAL);
    eh_tmp = eh;
    while (rv == SHR_E_NONE) {
        sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
        /* Parse key only. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_parse(unit, eh_tmp, fld_bmp, single, &l2addr));

        /* Fill key only. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_populate(unit, eh_next, &l2addr, fld_bmp, single));

        /* GET_NEXT. */
        rv = bcmlt_entry_commit(eh_next, BCMLT_OPCODE_TRAVERSE,
                                BCMLT_PRIORITY_NORMAL);

        /* Invoke callback here if any. */
        if (trav_st->int_cb) {
            trav_st->eh = eh_tmp;
            rv_cb = trav_st->int_cb(unit, (void *)trav_st);
            if (SHR_FAILURE(rv_cb)) {
                break;
            }
        }

        /*
         * Swap eh for GET_NEXT to avoid the last entry
         * being modified unexpectedly.
         */
        eh_tmp = eh_next;
        eh_next = eh;
        eh = eh_tmp;

        if (with_lock) {
            /* Release lock to allow l2_learn_insert */
            L2T_UNLOCK(unit);
            /* Re-take lock to traverse entry */
            L2T_LOCK(unit);
        }
    }
    if (with_lock) {
        L2T_UNLOCK(unit);
        locked = false;
    }

    /* Callback error. */
    SHR_IF_ERR_EXIT(rv_cb);

    /* If not found, it must be the last one */
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_EXIT(rv);
    SHR_EXIT();
exit:
    if (locked) {
        L2T_UNLOCK(unit);
    }
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    if (eh_next != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh_next);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Internal callback function for l2 traverse op.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  trav_st       Traverse structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
l2_traverse_int_cb(int unit, void *trav_st)
{
    bcmint_l2_traverse_t *trv = NULL;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2addr;
    bool single = false;
    const bcmint_l2_id_map_t *id_map = NULL;
    uint32_t tid, fld_bmp = L2_HOST_FLD_ALL;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Determine which view to parse. */
    tid = id_map[BCMINT_L2_HOST_NARROW_TBL].val;
    if (trv->tid == tid) {
        single = true;
    }

    eh = trv->eh;
    if (eh == BCMLT_INVALID_HDL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_parse(unit, eh, fld_bmp, single, &l2addr));

    if (trv->user_cb) {
        SHR_IF_ERR_VERBOSE_EXIT
            (trv->user_cb(unit, &l2addr, trv->user_data));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Internal callback function for l2 age op.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  trav_st       Traverse structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
l2_age_int_cb(int unit, void *trav_st)
{
    bcmint_l2_traverse_t     *trv = NULL;
    bcmlt_entry_handle_t   eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t          l2addr, l2addr_tmp;
    bool notify = NOTIFY_L2_EVENT(unit);
    bool single = false;
    const bcmint_l2_id_map_t *id_map = NULL;
    uint32_t tid, fld_bmp = L2_HOST_FLD_ALL;
    bool src = false, dst = false;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Determine which view to parse. */
    tid = id_map[BCMINT_L2_HOST_NARROW_TBL].val;
    if (trv->tid == tid) {
        single = true;
    }

    eh = trv->eh;
    if (eh == BCMLT_INVALID_HDL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (l2_entry_parse(unit, eh, fld_bmp, single, &l2addr),
         SHR_E_NOT_FOUND);

    /* Skip static entries */
    if (l2addr.flags & BCM_L2_STATIC) {
        SHR_EXIT();
    }

    if (!(l2addr.flags & BCM_L2_HIT)) {
        /* Free external resource if any. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_external_resource_free(unit, &l2addr, eh, single));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh,
                                BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL));
    } else {
        sal_memcpy(&l2addr_tmp, &l2addr, sizeof(bcm_l2_addr_t));
        if (l2addr_tmp.flags & BCM_L2_SRC_HIT) {
            src = true;
            l2addr_tmp.flags &= ~(BCM_L2_HIT | BCM_L2_SRC_HIT);
        }
        if (l2addr_tmp.flags & BCM_L2_DES_HIT) {
            dst = true;
            l2addr_tmp.flags &= ~(BCM_L2_HIT | BCM_L2_DES_HIT);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_hitbit_set(unit, eh, dst, src, &l2addr_tmp, single));
    }

    if (notify) {
        if (!(l2addr.flags & BCM_L2_HIT)) {
            bcmint_l2_event_notify(unit, NULL, &l2addr, L2_EVENT_AGE);
        }
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Internal callback function for l2 delete by (vlan, gport) tuple.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  trav_st       Traverse structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
tuple_match_delete_int_cb(int unit, void *trav_st)
{
    bcmint_l2_tuple_ctrl_t *tuple_ctrl = NULL;
    bcmint_l2_vlan_gport_tuple_t tuple;
    bcmint_l2_traverse_t *trv = NULL;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2addr;
    int vlan, gport;
    bool found = false;
    bool notify = NOTIFY_L2_EVENT(unit);
    bool single = false;
    const bcmint_l2_id_map_t *id_map = NULL;
    uint32_t tid, fld_bmp = 0;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Determine which view to parse. */
    tid = id_map[BCMINT_L2_HOST_NARROW_TBL].val;
    if (trv->tid == tid) {
        single = true;
    }

    tuple_ctrl = (bcmint_l2_tuple_ctrl_t *)trv->user_data;
    if (tuple_ctrl == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    eh = trv->eh;
    if (eh == BCMLT_INVALID_HDL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (tuple_ctrl->flags & BCM_L2_REPLACE_NO_CALLBACKS) {
        notify = false;
    }

    sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
    if (!notify) {
        fld_bmp |= L2_HOST_FLD_MAC | L2_HOST_FLD_DST_TYPE | L2_HOST_FLD_DST |
                   L2_HOST_FLD_VFI;
    } else {
        fld_bmp = L2_HOST_FLD_ALL;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_parse(unit, eh, fld_bmp, single, &l2addr));

    if ((l2addr.flags & BCM_L2_STATIC) &&
        !(tuple_ctrl->flags & BCM_L2_REPLACE_MATCH_STATIC)) {
        SHR_EXIT();
    }

    vlan = l2addr.vid;

    if (l2addr.flags & BCM_L2_TRUNK_MEMBER) {
        BCM_GPORT_TRUNK_SET(gport, l2addr.tgid);
    } else if (BCM_GPORT_IS_SET(l2addr.port)) {
        gport = l2addr.port;
    } else {
        BCM_GPORT_MODPORT_SET(gport, l2addr.modid, l2addr.port);
    }

    tuple.vlan = vlan;
    tuple.gport = gport;
    found = bcmint_l2_tuple_find(unit, tuple_ctrl, tuple);
    if (found == false && (tuple_ctrl->int_flags & BCMINT_L2_DONT_CARE_VLAN)) {
        tuple.vlan = BCM_VLAN_INVALID;
        tuple.gport = gport;
        found = bcmint_l2_tuple_find(unit, tuple_ctrl, tuple);
    }
    if (found == false && (tuple_ctrl->int_flags & BCMINT_L2_DONT_CARE_GPORT)) {
        tuple.vlan = vlan;
        tuple.gport = BCM_GPORT_INVALID;
        found = bcmint_l2_tuple_find(unit, tuple_ctrl, tuple);
    }

    if (found == true) {
        /* Free external resource if any. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_external_resource_free(unit, &l2addr, eh, single));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh,
                                BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL));
        if (notify) {
            bcmint_l2_event_notify(unit, NULL, &l2addr, L2_EVENT_DELETE);
        }
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Dump L2 address.
 *
 * \param [in] l2addr L2 address structure.
 */
void
l2_addr_dump(bcm_l2_addr_t *l2addr)
{
    LOG_CLI((BSL_META("  MAC_ADDR=%02x:%02x:%02x:%02x:%02x:%02x, VID=0x%x " \
                      "MODID=%d, PORT=0x%x, TGID=%d\n"),
                      l2addr->mac[0],l2addr->mac[1],l2addr->mac[2],
                      l2addr->mac[3],l2addr->mac[4],l2addr->mac[5],
                      l2addr->vid, l2addr->modid, l2addr->port, l2addr->tgid));
}

/*!
 * \brief Insert a L2 table entry and notify application a learn event.
 *
 * \param [in] unit    Unit number.
 * \param [in] l2addr  L2 address structure.
 *
 * \retval SHE_E_NONE No errors.
 */
static int
l2_learn_insert(int unit, bcm_l2_addr_t *l2addr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2addr_del;
    int dunit, rv;
    bool update = false, notify = NOTIFY_L2_EVENT(unit);
    bool single = false;
    uint32_t fld_bmp = 0, tid;
    const bcmint_l2_id_map_t *id_map = NULL;
    size_t fld_cnt = 0;

    SHR_FUNC_ENTER(unit);

    L2T_LOCK(unit);

    single = l2_vlan_is_single_view(unit, l2addr->vid);
    id_map = L2_MAP_ID_INFO(unit, single);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);
    tid = single ? id_map[BCMINT_L2_HOST_NARROW_TBL].val :
                   id_map[BCMINT_L2_HOST_TBL].val;

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_field_bmp_set(unit, L2_EVENT_LEARN, notify, single,
                          &fld_bmp, &fld_cnt));
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, tid, fld_cnt, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_populate(unit, eh, l2addr, fld_bmp, single));

    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_INSERT, BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_EXISTS) {
        rv = SHR_E_NONE;
        update = true;

        /* Free external resource of new entry if any. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_external_resource_free(unit, l2addr, eh, single));

        /* First do lookup with key to fetch whole entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh,
                                BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));

        sal_memset(&l2addr_del, 0, sizeof(bcm_l2_addr_t));
        fld_bmp = L2_HOST_FLD_ALL;
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_parse(unit, eh, fld_bmp, single, &l2addr_del));

        /* Dont relearn static MAC */
        if (l2addr_del.flags & BCM_L2_STATIC) {
            SHR_EXIT();
        }

        /* Free external resource of old entry if any. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_external_resource_free(unit, &l2addr_del, eh, single));

        SHR_IF_ERR_VERBOSE_EXIT
            (l2_field_bmp_set(unit, L2_EVENT_MOVE, notify, single,
                              &fld_bmp, NULL));

        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_populate(unit, eh, l2addr, fld_bmp, single));

        /* Remove read-only fields. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_read_only_fields_remove(unit, eh));

        /* Update existing entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    /*
     * Set hitbit if needed. For insert operation, in SDKLT RM module will
     * notify flexctr to update hit bit automatically, so there is no need
     * to explicitly set hit bit for new learned entries here. This change is
     * mainly for the consideration of L2 learn performance improvement.
     */
    if (fld_bmp & (L2_HOST_FLD_DST_ENTRY_IDX | L2_HOST_FLD_SRC_ENTRY_IDX)) {
        l2addr->flags |= BCM_L2_HIT | BCM_L2_SRC_HIT;
        if (update) {
            /* First do lookup with key to fetch whole entry */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(eh,
                                    BCMLT_OPCODE_LOOKUP,
                                    BCMLT_PRIORITY_NORMAL));

            rv = l2_hitbit_set(unit, eh, false, true, l2addr, single);
            if (SHR_FAILURE(rv)) {
                /*
                 * Because hitbit is a debugging functionality, even though
                 * hitbit set/get fails, it shouldn't stop here so that
                 * the main functionality fails. Instead, it will alert
                 * and continue to finish the main functionality.
                 */
                LOG_WARN(BSL_LOG_MODULE,
                         (BSL_META_U(unit, "l2_hitbit_set fails rv(%d)!\n"),
                          rv));
            }
        }
    }

    if (notify) {
        if (update) {
            bcmint_l2_event_notify(unit, l2addr, &l2addr_del, L2_EVENT_MOVE);
        } else {
            bcmint_l2_event_notify(unit, l2addr, NULL, L2_EVENT_LEARN);
        }
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable L2 slow-poll via configuring L2 learn control LT.
 *
 * \param [in] unit    Unit number.
 * \param [in] enable  Enable slow poll.
 *
 * \retval SHE_E_NONE No errors.
 */
static int
l2_learn_slow_poll_enable(int unit, bool slow_poll)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t cache_control_field[] =
    {
        /*0*/ {SLOW_POLLs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    if (slow_poll_mode[unit] == slow_poll) {
        SHR_EXIT();
    }
    LOG_DEBUG(BSL_LOG_MODULE,
              (BSL_META_U(unit,
                          "%s slow poll for L2 learning.\n"),
              slow_poll ? "Enable" : "Disable"));

    lt_entry.fields = cache_control_field;
    lt_entry.nfields = sizeof(cache_control_field)/
                       sizeof(cache_control_field[0]);
    lt_entry.attr = 0;

    cache_control_field[0].u.val = slow_poll ? TRUE : FALSE;

    /* Enable or disable slow poll. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_update(unit,
                              LEARN_CACHE_CONTROLs,
                              &lt_entry,
                              NULL));

    slow_poll_mode[unit] = slow_poll;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse L2 Learn cache entry.
 *
 * \param [in] unit Unit number.
 * \param [in] lt_name Table name.
 * \param [in] eh LT entry handle.
 * \param [out] notif_info Pointer to notification info.
 * \param [out] status Parser callback returned status, NULL for not care.
 *
 * \return none
 */
static void
l2_learn_entry_parse(int unit, const char *lt_name,
                     bcmlt_entry_handle_t eh, void *notif_info,
                     bcmi_ltsw_event_status_t *status)
{
    uint64_t data = 0LL;
    int i, rv;
    l2_learn_notify_t *learn_notify;
    bcmlt_unified_opcode_t op;
    const char *field[] = {CACHE_FIELD0s, CACHE_FIELD1s, CACHE_FIELD2s,
                           CACHE_FIELD3s, CACHE_FIELD4s, CACHE_FIELD5s,
                           CACHE_FIELD6s, CACHE_FIELD7s};
    uint16_t *cache;

    if (notif_info == NULL) {
        LOG_WARN(BSL_LOG_MODULE,
                 (BSL_META_U(unit, "Invalid Parameter!\n")));
        return;
    }

    learn_notify = (l2_learn_notify_t *)notif_info;

    rv = bcmlt_entry_oper_get(eh, &op);
    if (SHR_FAILURE(rv)) {
        LOG_WARN(BSL_LOG_MODULE,
                 (BSL_META_U(unit,
                             "Failed to get %s opcode(%d).\n"),
                  lt_name, rv));
        return;
    }
    learn_notify->op = op.opcode.lt;
    LOG_DEBUG(BSL_LOG_MODULE,
              (BSL_META_U(unit,
                          "Get opcode %d of %s.\n"),
               learn_notify->op, lt_name));
    /* Skip the delete event */
    if (learn_notify->op == BCMLT_OPCODE_DELETE) {
        if (status) {
            *status = bcmiLtswEventStatusDismissNotif;
        }
        return;
    }

    if (LOG_CHECK(BSL_LOG_MODULE | BSL_DEBUG)) {
        learn_notify->stime = sal_time_usecs();

        for (i = 0; i < 8; i++) {
            rv = bcmlt_entry_field_get(eh, field[i], &data);
            if (SHR_FAILURE(rv)) {
                LOG_WARN(BSL_LOG_MODULE,
                         (BSL_META_U(unit,
                                     "Failed to parse %s.%s (%d).\n"),
                          lt_name, field[i], rv));
                return;
            }
            learn_notify->cache_field[i] = (uint16_t)data;
        }

        cache = learn_notify->cache_field;

        LOG_CLI((BSL_META("--------LEARN_BEGIN--------\n")));
        LOG_CLI((BSL_META("LEARN_CACHE(ts:0x%x):\n"), learn_notify->stime));
        LOG_CLI((BSL_META("  0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n"),
                          cache[0], cache[1], cache[2], cache[3],
                          cache[4], cache[5], cache[6], cache[7]));
    }
}

/*!
 * \brief Internal callback function for l2 learning.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  trav_st       Traverse structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
l2_learn_int_cb(int unit, void *trav_st)
{
    bcmint_l2_traverse_t *trv = NULL;
    bcmlt_entry_handle_t eh_backup = BCMLT_INVALID_HDL;
    bcm_l2_addr_t *l2addr;
    uint32_t *count = NULL;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    count = (uint32_t *)trv->user_data;
    if (count == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    eh_backup = trv->eh;
    if (eh_backup == BCMLT_INVALID_HDL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    l2addr = (bcm_l2_addr_t *)trv->internal_data;
    rv = l2_learn_insert(unit, l2addr);
    if (SHR_FAILURE(rv)) {
        LOG_DEBUG(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Failed to insert L2 host table (%d).\n"), rv));
        if (rv == SHR_E_RESOURCE) {
            rv = l2_learn_slow_poll_enable(unit, 1);
            if (SHR_FAILURE(rv)) {
                LOG_ERROR(BSL_LOG_MODULE,
                          (BSL_META_U(unit,
                                      "Failed to enable L2 learn "
                                      "slow poll mode (%d).\n"), rv));
            }
        }
    } else {
        rv = l2_learn_slow_poll_enable(unit, 0);
        if (SHR_FAILURE(rv)) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "Failed to disable L2 learn "
                                  "slow poll mode (%d).\n"), rv));
        }
    }
    /*
     * No matter L2 host table insertion succeeds or not, always delete
     * learn cache entry.
     */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh_backup,
                            BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL));
    *count += 1;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief The callback function to handle L2 learn notification.
 *
 * This function is responsible for L2 learning, it will judge new learn or
 * station move event based on notified event of L2 learn table, insert or
 * update L2 host table entry and delete L2 learn table entry, etc
 *
 * \param [in]   unit         Unit number.
 * \param [in]   event        Event string.
 * \param [in]   notif_info   L2 event info.
 * \param [in]   user_data    User data.
 */
static void
l2_learn_lt_cb(int unit, const char *event, void *notif_info,
               void *user_data)
{
    l2_learn_notify_t *learn_notify;
    bcmint_l2_traverse_t  trav_st;
    sal_usecs_t time, schedule_time = 0;
    uint32_t count = 0;
    const bcmint_l2_id_map_t *id_map = NULL;

    if (notif_info == NULL) {
        return;
    }
    learn_notify = (l2_learn_notify_t *)notif_info;

    /* Skip the delete event */
    if (learn_notify->op == BCMLT_OPCODE_DELETE) {
        return;
    }

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_LEARN_CACHE_DATA_TABLE);
    if (id_map == NULL) {
        return;
    }

    if (LOG_CHECK(BSL_LOG_MODULE | BSL_DEBUG)) {
        schedule_time = sal_time_usecs();
    }

    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.user_data = (void *)&count;
    trav_st.tid = id_map[BCMINT_L2_LEARN_CACHE_DATA_TBL].val;
    trav_st.fld_cnt = id_map[BCMINT_L2_LEARN_CACHE_DATA_FLD_ELEMENT_CNT].val;
    trav_st.int_cb = l2_learn_int_cb;
    (void)l2_learn_traverse(unit, &trav_st);

    if (LOG_CHECK(BSL_LOG_MODULE | BSL_DEBUG)) {
        time = sal_time_usecs();
        LOG_CLI((BSL_META("LEARN_TIME(ts:0x%x): total(%d us) schedule(%d us)" \
                          "process(%d us) count(%d)\n"),
                 learn_notify->stime, time - learn_notify->stime,
                 schedule_time - learn_notify->stime,
                 time - schedule_time, count));
        LOG_CLI((BSL_META("--------LEARN_END--------\n")));
    }
}

/*!
 * \brief Enable L2 learning via configuring L2 learn control LT.
 *
 * \param [in] unit    Unit number.
 * \param [in] enable  Enable.
 *
 * \retval SHE_E_NONE No errors.
 */
static int
l2_learn_enable(int unit, bool enable)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t cache_control_field[] =
    {
        /*0*/ {REPORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    bcmi_lt_field_t cache_control_field_slow_poll[] =
    {
        /*0*/ {SLOW_POLLs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    bcmi_lt_field_t cache_profile_field[] =
    {
        /*0*/ {LEARN_CACHE_DATA_INFO_IDs, BCMI_LT_FIELD_F_SET |
                                          BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*1*/ {LEARN_CACHEs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int warm = bcmi_warmboot_get(unit);
    int rv;

    SHR_FUNC_ENTER(unit);

    if (enable) {
        /* Set parser function for learn cache. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_table_parser_set(unit, LEARN_CACHE_DATAs,
                                      l2_learn_entry_parse,
                                      sizeof(l2_learn_notify_t)));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_event_msg_threshold_set(unit, LEARN_CACHE_DATAs, 2));
        /* Subscribe learn cache LT. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_table_subscribe(unit, LEARN_CACHE_DATAs,
                                     l2_learn_lt_cb, NULL));

        if (!warm) {
            lt_entry.fields = cache_profile_field;
            lt_entry.nfields = sizeof(cache_profile_field)/
                               sizeof(cache_profile_field[0]);
            lt_entry.attr = 0;

            /* DNA use profile 1. */
            cache_profile_field[0].u.sym_val = LEARN_L2_VIEWs;
            cache_profile_field[1].u.val = true;

            /* Add learn cache profile. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_insert(unit,
                                      LEARN_CACHE_DATA_CONTROLs,
                                      &lt_entry,
                                      NULL));

            lt_entry.fields = cache_control_field;
            lt_entry.nfields = sizeof(cache_control_field)/
                               sizeof(cache_control_field[0]);
            lt_entry.attr = 0;

            cache_control_field[0].u.val = true;

            /* Enable reporting entry into learn cache. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_insert(unit,
                                      LEARN_CACHE_CONTROLs,
                                      &lt_entry,
                                      NULL));
        } else {
            lt_entry.fields = cache_control_field_slow_poll;
            lt_entry.nfields = sizeof(cache_control_field_slow_poll)/
                               sizeof(cache_control_field_slow_poll[0]);
            lt_entry.attr = 0;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_get(unit,
                                   LEARN_CACHE_CONTROLs,
                                   &lt_entry,
                                   NULL, NULL));
            slow_poll_mode[unit] = cache_control_field_slow_poll[0].u.val;
        }
    } else {
        if (!warm) {
            lt_entry.fields = cache_control_field;
            lt_entry.nfields = sizeof(cache_control_field)/
                               sizeof(cache_control_field[0]);
            lt_entry.attr = 0;

            cache_control_field[0].u.val = false;

            /* Disable reporting entry into learn cache. */
            rv = bcmi_lt_entry_delete(unit,
                                      LEARN_CACHE_CONTROLs,
                                      &lt_entry,
                                      NULL);
            if (rv == SHR_E_NOT_FOUND) {
                rv = SHR_E_NONE;
            }
            SHR_IF_ERR_VERBOSE_EXIT(rv);

            lt_entry.fields = cache_profile_field;
            lt_entry.nfields = sizeof(cache_profile_field)/
                               sizeof(cache_profile_field[0]);
            lt_entry.attr = 0;

            /* DNA use profile 1. */
            cache_profile_field[0].u.sym_val = LEARN_L2_VIEWs;

            /* Delete learn cache profile. */
            rv = bcmi_lt_entry_delete(unit,
                                      LEARN_CACHE_DATA_CONTROLs,
                                      &lt_entry,
                                      NULL);
            if (rv == SHR_E_NOT_FOUND) {
                rv = SHR_E_NONE;
            }
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }

        /* Unsubscribe learn cache. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_table_unsubscribe(unit, LEARN_CACHE_DATAs,
                                       l2_learn_lt_cb));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Internal callback function to set force vlan for matched entries.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  trav_st       Traverse structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
l2_force_vlan_int_cb(int unit, void *trav_st)
{
    bcmint_l2_traverse_t     *trv = NULL;
    bcmlt_entry_handle_t   eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t          l2addr;
    bcm_port_t *port;
    bool single = false;
    const bcmint_l2_id_map_t *id_map = NULL;
    uint32_t tid, fld_bmp = L2_HOST_FLD_ALL;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Determine which view to parse. */
    tid = id_map[BCMINT_L2_HOST_NARROW_TBL].val;
    if (trv->tid == tid) {
        single = true;
    }
    port = (bcm_port_t *)trv->user_data;

    eh = trv->eh;
    if (eh == BCMLT_INVALID_HDL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_parse(unit, eh, fld_bmp, single, &l2addr));

    if (*port != l2addr.port) {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_pvlan_set(unit, eh, *port));

    /* Remove read-only fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_read_only_fields_remove(unit, eh));

    /* Perform replace action on matching entry */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update station vlan info.
 *
 * \param [in] unit Unit number.
 * \param [in] vid VLAN id.
 * \param [in] flags Flags to indicate update which part of VLAN info.
 * \param [in] vlan_info VLAN info used by station.
 */
static void
l2_station_vlan_info_update(int unit, bcm_vlan_t vlan, int flags,
                               bcmi_ltsw_l2_station_vlan_t *vlan_info)
{
    if (flags & BCMI_LTSW_L2_STATION_VLAN_F_MEMBER_PRF_PTR) {
        L2_VLAN_INFO(unit, vlan)->member_prf_ptr = vlan_info->member_prf_ptr;
    }

    if (flags & BCMI_LTSW_L2_STATION_VLAN_F_STG) {
        L2_VLAN_INFO(unit, vlan)->stg = vlan_info->stg;
    }
}

/*!
 * \brief Internal callback function to update station vlan info database.
 *
 * \param [in] unit Unit number.
 * \param [in] vid VLAN id.
 * \param [in] flags Flags to indicate update which part of VLAN info.
 * \param [in] vlan_info VLAN info used by station.
 * \param [in] user_data User data of callback.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
l2_station_vlan_info_update_cb(int unit, bcm_vlan_t vlan, int flags,
                               bcmi_ltsw_l2_station_vlan_t *vlan_info,
                               void *user_data)
{
    SHR_FUNC_ENTER(unit);

    if (vlan_info == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (vlan >= l2_ctrl[unit].vfi_num) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    l2_station_vlan_info_update(unit, vlan, flags, vlan_info);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Dump L2 station vlan information.
 *
 * \param [in] unit Unit Number.
 */
static void
l2_station_vlan_dump(int unit)
{
    int i;

    LOG_CLI((BSL_META_U(unit,
                        "  L2 Station VLAN info:\n")));
    LOG_CLI((BSL_META_U(unit,
                        "  %10s %20s %20s\n"),
                        "VLAN",
                        "Membership ptr",
                        "STG Group id"));
    LOG_CLI((BSL_META_U(unit,
                        "  -------------------------------"
                        "---------------------\n")));

    for (i = 0; i < l2_ctrl[unit].vfi_num; i++) {
        /* Filter default config. */
        if ((L2_VLAN_INFO(unit, i)->member_prf_ptr != 0 &&
             L2_VLAN_INFO(unit, i)->member_prf_ptr !=
             BCMI_LTSW_VLAN_PROFILE_ING_MSHP_CHK_IDX_DEF) ||
            L2_VLAN_INFO(unit, i)->stg != 0) {
            LOG_CLI((BSL_META_U(unit,
                                "    %8x             %8x             %8x\n"),
                                i,
                                L2_VLAN_INFO(unit, i)->member_prf_ptr,
                                L2_VLAN_INFO(unit, i)->stg));
        }
    }

    LOG_CLI((BSL_META_U(unit,
                        "\n")));
    return;
}

/*!
 * \brief Init MY_STATION_TABLE.
 *
 * It is possible that in DNA some object/command bus container/fields are not
 * initialized properly before using, this will cause unexpected behavior.
 * Thus we need to insert dummy entries to TCAM tables to serve the purpose
 * of initializing these fields.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
l2_station_init(int unit)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MACDAs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MACDA_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {OVIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {OVID_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {IVIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {IVID_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {L2_IIF_VFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {L2_IIF_VFI_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {L2_IIFs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {L2_IIF_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {VALIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {SPANNING_TREE_GROUPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {MEMBERSHIP_PROFILE_PTRs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {ENTRY_PRIORITYs, BCMI_LT_FIELD_F_SET, 0,
                {L2_STATION_RSVD_PRI}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    /* Reserve last entry of my_station_table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit, MY_STATION_TABLEs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init L2_HOST_LOOKUP0_DEFAULT_TABLE.
 *
 * In DNA, flex_hve_iparser1_tpid_bitmap & l2_dst_vp_group_pvlan_port_type are
 * using the same container ing_cmd1__cont_14. So it is possible that
 * flex_hve_iparser1_tpid_bitmap value is wrongly used by
 * l2_dst_vp_group_pvlan_port_type in some cases where L2 dst lookup is not
 * done(MPLS transit) and causes unexpected behavior.
 * In order to fix this issue,  L2_HOST_LOOKUP0_DEFAULT_TABLE and
 * L2_HOST_LOOKUP0_DEFAULT_STRENGTH_PROFILE tables were added in eDNA 4.3.3 to
 * clear the container ing_cmd1__cont_14 in above cases.
 * So in HSDK, L2_HOST_LOOKUP0_DEFAULT_TABLE will be initialized during L2 init.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
l2_host_default_table_init(int unit)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {VALUE_ZEROs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {STRENGTH_PROFILE_INDEXs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {DESTINATIONs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DESTINATION_TYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {CLASS_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {DST_PVLAN_PORT_TYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {COMMUNITY_PVLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {DST_VP_GROUPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {MISC_CTRL_0s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {MISC_CTRL_1s, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    int strength_prf_index;
    uint32_t max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmi_lt_capacity_get(unit, L2_HOST_LOOKUP0_DEFAULT_TABLEs, &max));

    if (!max) {
        SHR_EXIT();
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_sbr_profile_ent_index_get(unit,
             BCMI_LTSW_SBR_PTH_L2_HOST_LOOKUP0_DEFAULT,
             BCMI_LTSW_SBR_PET_DEF,
             &strength_prf_index));

    field[1].u.val = strength_prf_index;

    field[3].flags |= BCMI_LT_FIELD_F_SYMBOL;
    field[3].u.sym_val = NO_OPs;

    field[5].flags |= BCMI_LT_FIELD_F_SYMBOL;
    field[5].u.sym_val = PROMISCUOUSs;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              L2_HOST_LOOKUP0_DEFAULT_TABLEs,
                              &lt_entry,
                              NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Internal callback function for l2 view update op.
 *
 * \param [in] unit Unit number.
 * \param [in] trav_s Traverse structure.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_PARAM Invalid parameter.
 */
static int
l2_view_table_move_int_cb(int unit, void *trav_st)
{
    bcmint_l2_traverse_t *trv = NULL;
    bcmi_ltsw_l2_view_vlan_info_t *info = NULL;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t eh_tmp = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2addr;
    int dunit, rv;
    bool single = false;
    uint32_t fld_bmp = 0, tid;
    const bcmint_l2_id_map_t *id_map = NULL;
    size_t fld_cnt = 0;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Determine which view to parse. */
    tid = id_map[BCMINT_L2_HOST_NARROW_TBL].val;
    if (trv->tid == tid) {
        single = true;
    }

    info = trv->user_data;
    if (info == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    eh = trv->eh;
    if (eh == BCMLT_INVALID_HDL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
    fld_bmp = L2_HOST_FLD_ALL;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_parse(unit, eh, fld_bmp, single, &l2addr));

    if (info->vlan != l2addr.vid) {
        SHR_EXIT();
    }

    id_map = info->l2_view ?
        L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE) :
        L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);
    tid = info->l2_view ?
        id_map[BCMINT_L2_HOST_NARROW_TBL].val :
        id_map[BCMINT_L2_HOST_TBL].val;

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_field_bmp_set(unit, L2_EVENT_ADD, false, info->l2_view,
                          &fld_bmp, &fld_cnt));
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, tid, fld_cnt, &eh_tmp));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_populate(unit, eh_tmp, &l2addr, fld_bmp, info->l2_view));

    /* Insert entry into new view. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh_tmp,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL));

    /* Set hitbit if needed. */
    if (fld_bmp & (L2_HOST_FLD_DST_ENTRY_IDX | L2_HOST_FLD_SRC_ENTRY_IDX)) {
        /* First do lookup with key to fetch whole entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh_tmp,
                                BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));

        rv = l2_hitbit_set(unit, eh_tmp, true, true, &l2addr, info->l2_view);
        if (SHR_FAILURE(rv)) {
            /*
             * Because hitbit is a debugging functionality, even though
             * hitbit set/get fails, it shouldn't stop here so that
             * the main functionality fails. Instead, it will alert
             * and continue to finish the main functionality.
             */
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "l2_hitbit_set fails rv(%d)!\n"), rv));
        }
    }

    /* Free external resource if any. */
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_external_resource_free(unit, &l2addr, eh, info->l2_view));

    /* Delete entry from old view. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh,
                            BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (eh_tmp != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh_tmp);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update L2 table view bitmap for a vlan.
 *
 * \param [in] unit Unit number.
 * \param [in] info L2 table view vlan info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_view_bmp_update(int unit, bcmi_ltsw_l2_view_vlan_info_t *info)
{
    uint32_t vfi;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(info, SHR_E_PARAM);

    /* Transform vid to vfi */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_idx_get(unit, info->vlan, &vfi));

    if (info->l2_view) {
        L2_VIEW_BMP_USED_SET(unit, vfi);
    } else {
        L2_VIEW_BMP_USED_CLR(unit, vfi);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update L2 host entries for a VLAN.
 *
 * \param [in] unit Unit number.
 * \param [in] info L2 table view vlan info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_view_table_update(int unit, bcmi_ltsw_l2_view_vlan_info_t *info)
{
    bool old_view;
    bcmint_l2_traverse_t trav_st;
    const bcmint_l2_id_map_t *id_map = NULL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(info, SHR_E_PARAM);

    old_view = l2_vlan_is_single_view(unit, info->vlan);

    /* Table view has no change, return success. */
    if (old_view == info->l2_view) {
        SHR_EXIT();
    }

    id_map = L2_MAP_ID_INFO(unit, old_view);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Traverse old table view and move entries from old view to new view. */
    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.tid = old_view ? id_map[BCMINT_L2_HOST_NARROW_TBL].val :
                             id_map[BCMINT_L2_HOST_TBL].val;
    trav_st.fld_cnt = old_view ?
        id_map[BCMINT_L2_HOST_NARROW_FLD_ELEMENT_CNT].val :
        id_map[BCMINT_L2_HOST_FLD_ELEMENT_CNT].val;
    trav_st.user_data = (void *)info;
    trav_st.int_cb = l2_view_table_move_int_cb;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Dump L2 view information.
 *
 * \param [in] unit Unit Number.
 */
static void
l2_view_dump(int unit)
{
    int i;
    uint32_t count = 0;

    LOG_CLI((BSL_META_U(unit,
                        "  L2 View info:\n")));
    LOG_CLI((BSL_META_U(unit,
                        "           VFI with Narrow View\n")));
    LOG_CLI((BSL_META_U(unit,
                        "  ---------------------------------------"
                        "-------------------\n")));

    for (i = 0; i < l2_ctrl[unit].vfi_num; i++) {
        if (L2_VIEW_BMP_USED_GET(unit, i)) {
            LOG_CLI((BSL_META_U(unit,
                        "  %4x"), i));
            count++;
            if ((count % 10) == 0) {
                LOG_CLI((BSL_META_U(unit, "\n")));
            }
        }
    }

    LOG_CLI((BSL_META_U(unit, "\n")));

    return;
}

/*!
 * \brief Dump L2 flexctr info for hitbit.
 *
 * \param [in] unit Unit Number.
 */
static void
l2_flexctr_info_dump(int unit)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    bcmint_l2_flexctr_info_t *flexctr_info = NULL;

    flexctr_info = l2c->flexctr_info;
    if (flexctr_info == NULL) {
        return;
    }

    LOG_CLI((BSL_META_U(unit,
                        "  L2 flexctr info:\n")));
    LOG_CLI((BSL_META_U(unit,
                        "           uft_dst_id: %#x\n"),
                        flexctr_info->uft_dst_id));
    LOG_CLI((BSL_META_U(unit,
                        "           uft_src_id: %#x\n"),
                        flexctr_info->uft_src_id));
    LOG_CLI((BSL_META_U(unit,
                        "           dst_id: %#x\n"),
                        flexctr_info->dst_id));
    LOG_CLI((BSL_META_U(unit,
                        "           src_id: %#x\n"),
                        flexctr_info->src_id));
    LOG_CLI((BSL_META_U(unit,
                        "           dst_grp_id: %#x\n"),
                        flexctr_info->dst_grp_id));
    LOG_CLI((BSL_META_U(unit,
                        "           src_grp_id: %#x\n"),
                        flexctr_info->src_grp_id));
    return;
}

/*!
 * \brief Dump L2 module software information.
 *
 * \param [in] unit Unit Number.
 */
static void
l2_sw_dump(int unit)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];

    LOG_CLI((BSL_META_U(unit,
                        "  Table lock          : %p\n"), (void *)l2c->mutex));
    LOG_CLI((BSL_META_U(unit,
                        "  Learn enable        : %8s\n"), l2c->learn_enable ?
                        "True" : "False"));
    LOG_CLI((BSL_META_U(unit,
                        "  VFI num             : %8d\n"), l2c->vfi_num));
    LOG_CLI((BSL_META_U(unit,
                        "\n")));

    /* Dump L2 station VLAN info. */
    l2_station_vlan_dump(unit);

    /* Dump L2 view info. */
    l2_view_dump(unit);

    /* Dump L2 PVLAN info. */
    l2_pvlan_info_dump(unit);

    LOG_CLI((BSL_META_U(unit,
                        "  Hitbit enable        : %8s\n"), l2c->hitbit_enable ?
                        "True" : "False"));

    LOG_CLI((BSL_META_U(unit,
                        "  MY_STATION_TABLE disabled        : %8s\n"),
                        l2c->station_disable ? "True" : "False"));

    LOG_CLI((BSL_META_U(unit,
                        "  L2 host disabled        : %8s\n"),
                        l2c->host_disable ? "True" : "False"));

    /* Dump L2 flexctr info if any. */
    l2_flexctr_info_dump(unit);
}

/*!
 * \brief Internal callback function to update virtual info for matched entries.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  trav_st       Traverse structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
l2_virtual_info_update_int_cb(int unit, void *trav_st)
{
    bcmint_l2_traverse_t     *trv = NULL;
    bcmlt_entry_handle_t   eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t          l2addr;
    bcmi_ltsw_l2_virtual_info_t *info= NULL;
    int nexthop = 0, prt_idx = 0;
    bcmi_ltsw_l3_egr_obj_type_t type;
    const bcmint_l2_id_map_t *id_map = NULL;
    uint32_t fld_bmp = L2_HOST_FLD_ALL;
    int rv;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    info = (bcmi_ltsw_l2_virtual_info_t *)trv->user_data;
    if (info == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    eh = trv->eh;
    if (eh == BCMLT_INVALID_HDL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
    rv = l2_entry_parse(unit, eh, fld_bmp, false, &l2addr);
    if (rv == SHR_E_NOT_FOUND) {
        /* Skip the entry which parse fails. */
        SHR_EXIT();
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    if (info->gport != l2addr.port) {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_egress_obj_id_resolve(unit,
                                            info->egress_if,
                                            &nexthop,
                                            &type));
    /* egress_if is only for L2 tunnel use currently */
    if ((type != BCMI_LTSW_L3_EGR_OBJ_T_UL) &&
        (type != BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
        prt_idx = 1;
    } else {
        prt_idx = (1 << 2) | 1; /* ECMP indicator. */
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add_by_id(eh,
             id_map[BCMINT_L2_HOST_FLD_NHOP_2_OR_ECMP_GROUP_INDEX_1].val,
             nexthop));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add_by_id(eh,
             id_map[BCMINT_L2_HOST_FLD_ECMP_AND_PROT_SWT_SFC_PROFILE_INDEX].val,
             prt_idx));

    /* Remove read-only fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_read_only_fields_remove(unit, eh));

    /* Perform replace action on matching entry */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Detach flex ctr resources for L2 hit.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_hitbit_detach(int unit)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    bcmint_l2_flexctr_info_t *flexctr_info = NULL;

    SHR_FUNC_ENTER(unit);

    flexctr_info = l2c->flexctr_info;
    SHR_NULL_CHECK(flexctr_info, SHR_E_INIT);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_l2_hitbit_detach(unit, flexctr_info));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init flex ctr resources for L2 hit.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_hitbit_init(int unit)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    bcmint_l2_flexctr_info_t *flexctr_info = NULL;

    SHR_FUNC_ENTER(unit);

    flexctr_info = l2c->flexctr_info;
    SHR_NULL_CHECK(flexctr_info, SHR_E_INIT);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_l2_hitbit_init(unit, flexctr_info));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get L2 hitbit enable status.
 *
 * \param [in] unit Unit number.
 * \param [in] enable Enable status returned.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
l2_hitbit_enable_get(int unit, bool *enable)
{
    bcmi_ltsw_flexctr_mode_t mode = bcmiFlexctrModeGlobal;
    uint32_t ena = 0;
    int gnum;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_mode_get(unit, 0, &mode));

    ena = bcmi_ltsw_property_get(unit, BCMI_CPN_L2_HITBIT_ENABLE, true);

    if ((mode == bcmiFlexctrModeGlobal) && ena) {
        *enable = 1;
    } else if ((mode == bcmiFlexctrModePipeUnique) && ena) {
        *enable = 1;
        gnum = bcmi_ltsw_property_get(unit,
                   BCMI_CPN_GLOBAL_FLEXCTR_ING_GROUP_NUM_RESERVED, 0);
        if (gnum < 2) {
            *enable = 0;

            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit,
                                 "To enable L2 hitbit, flexctr reserved " \
                                 "group num should not be less than 2!\n")));
        }
    } else {
        *enable = 0;
    }

exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_l2_init(int unit)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    int warm = bcmi_warmboot_get(unit);
    bool enable;
    uint32_t alloc_size = 0, req_size = 0;
    uint32_t vfi_num = 0, l2_iif_num = 0;
    void *ptr = NULL, *ptr_tmp = NULL, *ptr_flexctr = NULL;
    int bcm_init = bcmi_ltsw_init_state_get(unit);
    int rv, vfp_mode;
    bcmi_ltsw_uft_mode_t uft_mode;

    SHR_FUNC_ENTER(unit);

    if (l2c->mutex == NULL) {
        l2c->mutex = sal_mutex_create("xfsL2TableLock");
        SHR_NULL_CHECK(l2c->mutex, SHR_E_MEMORY);
    }

    vfp_mode = bcmi_ltsw_property_get(unit, BCMI_CPN_VFP_MODE, 0);
    if (vfp_mode == 2) {
        l2c->station_disable = true;
    } else {
        l2c->station_disable = false;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_uft_mode_get(unit, &uft_mode));
    if (uft_mode == bcmiUftMode9 || uft_mode == bcmiUftMode10) {
        l2c->host_disable = true;
    } else {
        l2c->host_disable = false;
    }

    if (!warm) {
        if (!l2c->host_disable) {
            /* Clean up L2 table */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_clear(unit, L2_HOST_TABLEs));

            /* Clean up L2 table */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_clear(unit, L2_HOST_NARROW_TABLEs));

            /* Clean up L2 host default table */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_clear(unit, L2_HOST_LOOKUP0_DEFAULT_TABLEs));
        }

        /* Clean up L2 station table */
        if (!l2c->station_disable) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_clear(unit, MY_STATION_TABLEs));

            /* Init L2 station table. */
            SHR_IF_ERR_VERBOSE_EXIT
                (l2_station_init(unit));
        }

        if (!l2c->host_disable) {
            /* Init L2 host default table */
            SHR_IF_ERR_VERBOSE_EXIT
                (l2_host_default_table_init(unit));
        }
    }

    enable = bcmi_ltsw_property_get(unit, BCMI_CPN_L2_LEARN_ENABLE, true);
    if (enable && !l2c->host_disable) {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_learn_enable(unit, enable));
        l2c->learn_enable = enable;
    }

    /* Get the table size of VFI table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, ING_VFI_TABLEs, &vfi_num));
    l2c->vfi_num = vfi_num;

    /* Initialize VLAN info */
    alloc_size = vfi_num * sizeof(bcmi_ltsw_l2_station_vlan_t);
    l2c->vlan_info = sal_alloc(alloc_size, "ltswL2VlanInfo");
    SHR_NULL_CHECK(l2c->vlan_info, SHR_E_MEMORY);
    sal_memset(l2c->vlan_info, 0, alloc_size);

    rv = bcmi_ltsw_vlan_l2_station_update_all(unit,
                                              l2_station_vlan_info_update_cb,
                                              NULL);
    if (rv == SHR_E_INIT) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    /* Allocate HA memory for L2 table view bitmap. */
    req_size = SHR_BITALLOCSIZE(vfi_num);
    alloc_size = req_size;
    ptr = bcmi_ltsw_ha_mem_alloc(unit,
                                 BCMI_HA_COMP_ID_L2,
                                 BCMINT_L2_SUB_COMP_ID_L2_TABLE_VIEW,
                                 "bcmL2TableView",
                                 &alloc_size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT
        ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);
    /* No need to clear HA during L2-only init. */
    if (!warm && bcm_init) {
        /* Default view is double wide view. */
        sal_memset(ptr, 0, alloc_size);
    }
    l2c->l2_view = ptr;

    /* Get the table size of L2 iif table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, ING_L2_IIF_TABLEs, &l2_iif_num));

    /* Allocate HA memory for L2 pvlan info. */
    req_size = sizeof(l2_pvlan_info_t) * l2_iif_num;
    alloc_size = req_size;
    ptr_tmp = bcmi_ltsw_ha_mem_alloc(unit,
                                     BCMI_HA_COMP_ID_L2,
                                     BCMINT_L2_SUB_COMP_ID_L2_PVLAN_PORT_INFO,
                                     "bcmL2PvlanPortInfo",
                                     &alloc_size);
    SHR_NULL_CHECK(ptr_tmp, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT
        ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);
    /* No need to clear HA during L2-only init. */
    if (!warm && bcm_init) {
        /* Default port type is promiscuous. */
        sal_memset(ptr_tmp, 0, alloc_size);
    }
    l2c->pvlan_info = ptr_tmp;

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_hitbit_enable_get(unit, &enable));
    if (enable && !l2c->host_disable) {
        /* Allocate HA memory for L2 flexctr info. */
        req_size = sizeof(bcmint_l2_flexctr_info_t);
        alloc_size = req_size;
        ptr_flexctr = bcmi_ltsw_ha_mem_alloc(unit,
                                     BCMI_HA_COMP_ID_L2,
                                     BCMINT_L2_SUB_COMP_ID_L2_FLEXCTR_INFO,
                                     "bcmL2FlexCtrInfo",
                                     &alloc_size);
        SHR_NULL_CHECK(ptr_flexctr, SHR_E_MEMORY);
        SHR_IF_ERR_VERBOSE_EXIT
            ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);
        l2c->flexctr_info = ptr_flexctr;
        if (!warm) {
            sal_memset(ptr_flexctr, 0x0, alloc_size);
            SHR_IF_ERR_VERBOSE_EXIT
                (l2_hitbit_init(unit));
        }
        l2c->hitbit_enable = enable;
    } else {
        l2c->hitbit_enable = false;
        l2c->flexctr_info = NULL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_sbr_profile_ent_index_get(unit,
                                             BCMI_LTSW_SBR_PTH_L2_HOST,
                                             BCMI_LTSW_SBR_PET_DEF,
                                             &l2c->l2_host_sbr_prf_index));
    /* Init L2 map database. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_l2_map_db_init(unit, &l2c->l2_db));

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_l2_rsv(unit));
    }

exit:
    if (SHR_FUNC_ERR()) {
        SHR_FREE(l2c->vlan_info);
        if (l2c->mutex) {
            sal_mutex_destroy(l2c->mutex);
            l2c->mutex = NULL;
        }

        if (!warm) {
            if (ptr != NULL) {
                (void)bcmi_ltsw_ha_mem_free(unit, ptr);
                l2c->l2_view = NULL;
            }

            if (ptr_tmp != NULL) {
                (void)bcmi_ltsw_ha_mem_free(unit, ptr_tmp);
                l2c->pvlan_info = NULL;
            }

            if (ptr_flexctr != NULL) {
                (void)bcmi_ltsw_ha_mem_free(unit, ptr_flexctr);
                l2c->flexctr_info = NULL;
            }
        }
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_detach(int unit)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    int warm = bcmi_warmboot_get(unit);
    SHR_FUNC_ENTER(unit);

    if (l2c->vlan_info) {
        sal_free(l2c->vlan_info);
        l2c->vlan_info = NULL;
    }

    if (l2c->learn_enable) {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_learn_enable(unit, false));
        l2c->learn_enable = false;
    }

    if (l2c->flexctr_info && !warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_hitbit_detach(unit));
    }

    /* Clear L2 tables which use UFT banks. */
    if (!warm) {
        if (!l2c->host_disable) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_clear(unit, L2_HOST_TABLEs));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_clear(unit, L2_HOST_NARROW_TABLEs));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_clear(unit, L2_HOST_LOOKUP0_DEFAULT_TABLEs));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MY_STATION_TABLEs));
    }

    if (l2c->mutex) {
        sal_mutex_destroy(l2c->mutex);
        l2c->mutex = NULL;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_addr_add(
    int unit,
    bcm_l2_addr_t *l2addr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2addr_del;
    int dunit, rv;
    bool update = false, notify = NOTIFY_L2_EVENT(unit);
    bool single = false;
    uint32_t fld_bmp = 0, tid;
    const bcmint_l2_id_map_t *id_map = NULL;
    size_t fld_cnt = 0;
    int cb_suppress = false;

    SHR_FUNC_ENTER(unit);

    L2T_LOCK(unit);

    single = l2_vlan_is_single_view(unit, l2addr->vid);
    id_map = L2_MAP_ID_INFO(unit, single);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);
    tid = single ? id_map[BCMINT_L2_HOST_NARROW_TBL].val :
                   id_map[BCMINT_L2_HOST_TBL].val;

    /* Check if suppress callbacks of L2 add/delete. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_switch_control_get(unit,
                                     bcmSwitchL2ApplCallbackSuppress,
                                     &cb_suppress));
    notify = cb_suppress ? false : notify;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_field_bmp_set(unit, L2_EVENT_ADD, notify, single,
                          &fld_bmp, &fld_cnt));
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, tid, fld_cnt, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_populate(unit, eh, l2addr, fld_bmp, single));

    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_INSERT, BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_EXISTS) {
        rv = SHR_E_NONE;
        update = true;

        /* Free external resource of new entry if any. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_external_resource_free(unit, l2addr, eh, single));

        /* First do lookup with key to fetch whole entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh,
                                BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));

        sal_memset(&l2addr_del, 0, sizeof(bcm_l2_addr_t));
        fld_bmp = L2_HOST_FLD_ALL;
        rv = l2_entry_parse(unit, eh, fld_bmp, single, &l2addr_del);
        if (SHR_SUCCESS(rv)) {
            /* Free external resource of old entry if any. */
            SHR_IF_ERR_VERBOSE_EXIT
                (l2_external_resource_free(unit, &l2addr_del, eh, single));
        } else if (rv == SHR_E_NOT_FOUND) {
            rv = SHR_E_NONE;
        }
        SHR_IF_ERR_VERBOSE_EXIT(rv);

        SHR_IF_ERR_VERBOSE_EXIT
            (l2_field_bmp_set(unit, L2_EVENT_UPDATE, notify, single,
                              &fld_bmp, NULL));

        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_populate(unit, eh, l2addr, fld_bmp, single));

        /* Remove read-only fields. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_read_only_fields_remove(unit, eh));

        /* Update existing entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    /* Set hitbit if needed. */
    if (fld_bmp & (L2_HOST_FLD_DST_ENTRY_IDX | L2_HOST_FLD_SRC_ENTRY_IDX)) {
        /* First do lookup with key to fetch whole entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh,
                                BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));

        rv = l2_hitbit_set(unit, eh, true, true, l2addr, single);
        if (SHR_FAILURE(rv)) {
            /*
             * Because hitbit is a debugging functionality, even though
             * hitbit set/get fails, it shouldn't stop here so that
             * the main functionality fails. Instead, it will alert
             * and continue to finish the main functionality.
             */
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "l2_hitbit_set fails rv(%d)!\n"), rv));
        }
    }

    if (notify) {
        if (update) {
            bcmint_l2_event_notify(unit, l2addr, &l2addr_del, L2_EVENT_UPDATE);
        } else {
            bcmint_l2_event_notify(unit, l2addr, NULL, L2_EVENT_ADD);
        }
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_addr_get(
    int unit,
    bcm_mac_t mac,
    bcm_vlan_t vid,
    bcm_l2_addr_t *l2addr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2_addr;
    int dunit;
    bool single = false;
    uint32_t fld_bmp = 0, tid;
    const bcmint_l2_id_map_t *id_map = NULL;
    size_t fld_cnt = 0;

    SHR_FUNC_ENTER(unit);

    bcm_l2_addr_t_init(&l2_addr, mac, vid);

    L2T_LOCK(unit);

    single = l2_vlan_is_single_view(unit, vid);
    id_map = L2_MAP_ID_INFO(unit, single);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);
    tid = single ? id_map[BCMINT_L2_HOST_NARROW_TBL].val :
                   id_map[BCMINT_L2_HOST_TBL].val;

    /* No GET event, so use DELETE event to set key only. */
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_field_bmp_set(unit, L2_EVENT_DELETE, true, single,
                          &fld_bmp, &fld_cnt));
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, tid, fld_cnt, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_populate(unit, eh, &l2_addr, fld_bmp, single));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

    fld_bmp = L2_HOST_FLD_ALL;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_parse(unit, eh, fld_bmp, single, &l2_addr));
    sal_memcpy(l2addr, &l2_addr, sizeof(bcm_l2_addr_t));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_addr_delete(
    int unit,
    bcm_mac_t mac,
    bcm_vlan_t vid)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2addr, l2addr_del;
    int dunit;
    bool notify = NOTIFY_L2_EVENT(unit);
    bool single = false;
    uint32_t fld_bmp = 0, tid;
    const bcmint_l2_id_map_t *id_map = NULL;
    size_t fld_cnt = 0;
    int rv = SHR_E_NONE, cb_suppress = false;

    SHR_FUNC_ENTER(unit);

    L2T_LOCK(unit);

    bcm_l2_addr_t_init(&l2addr, mac, vid);

    single = l2_vlan_is_single_view(unit, vid);
    id_map = L2_MAP_ID_INFO(unit, single);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);
    tid = single ? id_map[BCMINT_L2_HOST_NARROW_TBL].val :
                   id_map[BCMINT_L2_HOST_TBL].val;

    /* Check if suppress callbacks of L2 add/delete. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_switch_control_get(unit,
                                     bcmSwitchL2ApplCallbackSuppress,
                                     &cb_suppress));
    notify = cb_suppress ? false : notify;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_field_bmp_set(unit, L2_EVENT_DELETE, notify, single,
                          &fld_bmp, &fld_cnt));
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, tid, fld_cnt, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_populate(unit, eh, &l2addr, fld_bmp, single));

    /* First do lookup with key to fetch whole entry */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    sal_memset(&l2addr_del, 0, sizeof(bcm_l2_addr_t));
    fld_bmp = L2_HOST_FLD_ALL;
    rv = l2_entry_parse(unit, eh, fld_bmp, single, &l2addr_del);
    if (SHR_SUCCESS(rv)) {
        /* Free external resource if any. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_external_resource_free(unit, &l2addr_del, eh, single));
    } else if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh, BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

    if (notify) {
        bcmint_l2_event_notify(unit, NULL, &l2addr_del, L2_EVENT_DELETE);
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_addr_replace(
    int unit,
    bcmint_l2_replace_t *rep_st)
{
    bcmint_l2_traverse_t  trav_st;
    const bcmint_l2_id_map_t *id_map = NULL;

    SHR_FUNC_ENTER(unit);

    L2T_LOCK(unit);

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.user_data = (void *)rep_st;
    trav_st.tid = id_map[BCMINT_L2_HOST_TBL].val;
    trav_st.fld_cnt = id_map[BCMINT_L2_HOST_FLD_ELEMENT_CNT].val;
    trav_st.int_cb = l2_replace_int_cb;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st));

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Traverse narrow table. */
    trav_st.tid = id_map[BCMINT_L2_HOST_NARROW_TBL].val;
    trav_st.fld_cnt = id_map[BCMINT_L2_HOST_NARROW_FLD_ELEMENT_CNT].val;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st));

exit:
    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_addr_traverse(
    int unit,
    bcm_l2_traverse_cb trav_fn,
    void *user_data)
{
    bcmint_l2_traverse_t trav_st;
    bool locked = false;
    const bcmint_l2_id_map_t *id_map = NULL;

    SHR_FUNC_ENTER(unit);

    if (trav_fn == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    L2T_LOCK(unit);
    locked = true;

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.user_cb = trav_fn;
    trav_st.user_data = user_data;
    trav_st.tid = id_map[BCMINT_L2_HOST_TBL].val;
    trav_st.fld_cnt = id_map[BCMINT_L2_HOST_FLD_ELEMENT_CNT].val;
    trav_st.int_cb = l2_traverse_int_cb;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st));

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Traverse narrow table. */
    trav_st.tid = id_map[BCMINT_L2_HOST_NARROW_TBL].val;
    trav_st.fld_cnt = id_map[BCMINT_L2_HOST_NARROW_FLD_ELEMENT_CNT].val;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st));

exit:
    if (locked) {
        L2T_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_addr_del_by_tuple(
    int unit,
    bcmint_l2_tuple_ctrl_t *tuple_ctrl)
{
    bcmint_l2_traverse_t trav_st;
    const bcmint_l2_id_map_t *id_map = NULL;

    SHR_FUNC_ENTER(unit);

    L2T_LOCK(unit);

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.user_data = (void *)tuple_ctrl;
    trav_st.tid = id_map[BCMINT_L2_HOST_TBL].val;
    trav_st.fld_cnt = id_map[BCMINT_L2_HOST_FLD_ELEMENT_CNT].val;
    trav_st.int_cb = tuple_match_delete_int_cb;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st));

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Traverse narrow table. */
    trav_st.tid = id_map[BCMINT_L2_HOST_NARROW_TBL].val;
    trav_st.fld_cnt = id_map[BCMINT_L2_HOST_NARROW_FLD_ELEMENT_CNT].val;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st));

exit:
    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_station_size_get(
    int unit,
    uint32_t *tbl_sz)
{
    uint32_t size = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TABLE_IDs, BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*1*/ {ENTRY_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    int vfp_mode;

    SHR_FUNC_ENTER(unit);

    /* Check vfp_mode in case of calling during init. */
    vfp_mode = bcmi_ltsw_property_get(unit, BCMI_CPN_VFP_MODE, 0);
    if (vfp_mode == 2) {
        *tbl_sz = 0;
        SHR_EXIT();
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.sym_val = MY_STATION_TABLEs;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           TABLE_INFOs,
                           &lt_entry,
                           NULL, NULL));
    size = field[1].u.val;

    /*
     * Two tables share the same hardware TCAM table. The total size of
     * hardware TCAM is 1K, besides following entries are reserved:
     * 1.One entry reserved for atomicity of MY_STATION_DEFAULT_TABLE.
     * 2.One entry reserved for atomicity of MY_STATION_TABLE.
     * 3.One dummy entry of MY_STATION_DEFAULT_TABLE is programmed to
     * initialize bus container.
     * 4.One dummy entry of MY_STATION_TABLE is programmed to initialize bus
     * container.
     */
    *tbl_sz = size - 1;


exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_age(int unit)
{
    bcmint_l2_traverse_t  trav_st;
    const bcmint_l2_id_map_t *id_map = NULL;

    SHR_FUNC_ENTER(unit);

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.user_data = (void *)&unit;
    trav_st.flags = BCMINT_L2_TRAVERSE_WITH_LOCK;
    trav_st.tid = id_map[BCMINT_L2_HOST_TBL].val;
    trav_st.fld_cnt = id_map[BCMINT_L2_HOST_FLD_ELEMENT_CNT].val;
    trav_st.int_cb = l2_age_int_cb;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st));

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_NARROW_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Traverse narrow table. */
    trav_st.tid = id_map[BCMINT_L2_HOST_NARROW_TBL].val;
    trav_st.fld_cnt = id_map[BCMINT_L2_HOST_NARROW_FLD_ELEMENT_CNT].val;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_station_add(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcmlt_opcode_t opcode;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_station_params_check(unit, station));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MY_STATION_TABLEs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_station_entry_populate(unit, eh, station, false));

    if (station->flags & BCM_L2_STATION_REPLACE) {
        opcode = BCMLT_OPCODE_UPDATE;
    } else {
        opcode = BCMLT_OPCODE_INSERT;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh, opcode, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_station_get(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    l2_ctrl_t *l2c = &l2_ctrl[unit];

    SHR_FUNC_ENTER(unit);

    if (l2c->station_disable) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MY_STATION_TABLEs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_station_entry_populate(unit, eh, station, true));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_station_entry_parse(unit, eh, station, true));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_station_delete(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    l2_ctrl_t *l2c = &l2_ctrl[unit];

    SHR_FUNC_ENTER(unit);

    if (l2c->station_disable) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MY_STATION_TABLEs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_station_entry_populate(unit, eh, station, true));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh, BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_force_vlan_set(
    int unit,
    bcm_port_t port,
    bcm_vlan_t vlan,
    uint32_t flags)
{
    bcmint_l2_traverse_t  trav_st;
    const bcmint_l2_id_map_t *id_map = NULL;

    SHR_FUNC_ENTER(unit);

    L2T_LOCK(unit);

    L2_HOST_DISABLE_RETURN(unit);

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    /* Update L2 pvlan info. */
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_pvlan_info_update(unit, port, vlan, flags));

    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.user_data = (void *)&port;
    trav_st.tid = id_map[BCMINT_L2_HOST_TBL].val;
    trav_st.fld_cnt = id_map[BCMINT_L2_HOST_FLD_ELEMENT_CNT].val;
    trav_st.int_cb = l2_force_vlan_int_cb;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st));
exit:
    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_learn_set(
    int unit,
    int enable)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_learn_enable(unit, enable));
    l2c->learn_enable = enable;
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_learn_get(
    int unit,
    int *enable)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];

    *enable = l2c->learn_enable;
    return SHR_E_NONE;
}

int
xfs_ltsw_l2_station_vlan_update(
    int unit,
    int vid,
    int flags,
    bcmi_ltsw_l2_station_vlan_t *vlan_info)
{
    SHR_FUNC_ENTER(unit);

    if (vlan_info == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (vid >= l2_ctrl[unit].vfi_num) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    l2_station_vlan_info_update(unit, vid, flags, vlan_info);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_size_get(
    int unit,
    int *size)
{
    uint32_t size_tmp = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, L2_HOST_TABLEs, &size_tmp));
    *size = size_tmp;
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_count_get(
    int unit,
    int *count)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0, cnt = 0;
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Check the current number of entries inserted in this LT. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_INFOs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs, L2_HOST_TABLEs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit,
                              entry_hdl,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, ENTRY_INUSE_CNTs, &value));

    cnt = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl,
                                      TABLE_IDs,
                                      L2_HOST_NARROW_TABLEs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit,
                              entry_hdl,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, ENTRY_INUSE_CNTs, &value));

    cnt += value;
    *count = cnt;

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_l2_view_vlan_update(
    int unit,
    bcmi_ltsw_l2_view_vlan_info_t *info)
{
    bool locked = false;
    SHR_FUNC_ENTER(unit);

    L2T_LOCK(unit);
    locked = true;

    L2_HOST_DISABLE_RETURN(unit);

    /* Update L2 table entries. */
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_view_table_update(unit, info));

    /* Update L2 table view bitmap. */
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_view_bmp_update(unit, info));

    L2T_UNLOCK(unit);
    locked = false;

exit:
    if (locked) {
        L2T_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

void
xfs_ltsw_l2_sw_dump(int unit)
{
    l2_sw_dump(unit);
    return;
}

int
xfs_ltsw_l2_virtual_info_update(
    int unit,
    bcmi_ltsw_l2_virtual_info_t *info)
{
    bcmint_l2_traverse_t  trav_st;
    const bcmint_l2_id_map_t *id_map = NULL;

    SHR_FUNC_ENTER(unit);

    L2T_LOCK(unit);

    L2_HOST_DISABLE_RETURN(unit);

    id_map = L2_MAP_ID_INFO(unit, BCMINT_L2_MAP_IH_HOST_TABLE);
    SHR_NULL_CHECK(id_map, SHR_E_INIT);

    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.user_data = (void *)info;
    trav_st.tid = id_map[BCMINT_L2_HOST_TBL].val;
    trav_st.fld_cnt = id_map[BCMINT_L2_HOST_FLD_ELEMENT_CNT].val;
    trav_st.int_cb = l2_virtual_info_update_int_cb;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st));

exit:
    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

