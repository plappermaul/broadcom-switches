/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm/switch.h>
#include <bcm_int/control.h>
#include <bcm_int/ltsw_dispatch.h>

#include <bcm_int/ltsw/xfs/ecn.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/cosq.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/ecn.h>
#include <bcm_int/ltsw/ecn_int.h>
#include <bcm_int/ltsw/qos.h>
#include <bcm_int/ltsw/flexstate.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/mbcm/ecn.h>

#include <shr/shr_bitop.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_COSQ

/******************************************************************************
 * Private functions
 */


/* Entry number per set. */
#define XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET 32

typedef struct xfs_ecn_bookkeeping_s {
    /* Ingress MPLS EXP to ECN map usage bitmap. */
    SHR_BITDCL *ing_exp_to_ip_ecn_map_bitmap;

    /* Actual profile index used. */
    uint32_t *ing_exp_to_ip_ecn_map_hw_idx;

    /* Latency-based ECN associated flex stat status, 1 to enable LB_ECN. */
    uint32_t lb_ecn_enable;

    /* Latency-based ECN associated flex stat IDs. One for each pipe. */
    uint32_t *lb_ecn_flex_stat_id;
} xfs_ecn_bookkeeping_t;

xfs_ecn_bookkeeping_t xfs_ecn_bookkeeping[BCM_MAX_NUM_UNITS];

#define XFS_ECN_BK(unit) xfs_ecn_bookkeeping[unit]

#define XFS_ECN_ING_EXP_TO_IP_ECN_MAP_BITMAP(unit) \
            (XFS_ECN_BK(unit).ing_exp_to_ip_ecn_map_bitmap)
#define XFS_ECN_ING_EXP_TO_ECN_MAP_USED_GET(unit, map_id) \
            SHR_BITGET(XFS_ECN_ING_EXP_TO_IP_ECN_MAP_BITMAP(unit), map_id)
#define XFS_ECN_ING_EXP_TO_ECN_MAP_USED_SET(unit, map_id) \
            SHR_BITSET(XFS_ECN_ING_EXP_TO_IP_ECN_MAP_BITMAP(unit), map_id)
#define XFS_ECN_ING_EXP_TO_ECN_MAP_USED_CLR(unit, map_id) \
            SHR_BITCLR(XFS_ECN_ING_EXP_TO_IP_ECN_MAP_BITMAP(unit), map_id)

#define XFS_ECN_ING_EXP_TO_ECN_MAP_HW_IDX(unit, map_id) \
            (*((XFS_ECN_BK(unit).ing_exp_to_ip_ecn_map_hw_idx) + map_id))

#define XFS_LB_ECN_ENABLE(unit) \
            (XFS_ECN_BK(unit).lb_ecn_enable)

#define XFS_LB_ECN_FLEX_STAT_ID(unit, pipe) \
            (XFS_ECN_BK(unit).lb_ecn_flex_stat_id[pipe])

#define XFS_ECN_TRAFFIC_NON_TNL_BASE_PTR 0
#define XFS_ECN_TRAFFIC_L2_TNL_BASE_PTR  1
#define XFS_ECN_TRAFFIC_L3_TNL_BASE_PTR  2
#define XFS_ECN_TRAFFIC_MPLS_BASE_PTR    3

/* 2-bit payload ECN. */
#define XFS_ECN_MAX_VALUE 3
/* 2-bit int ECN. */
#define XFS_INT_CN_MAX_VALUE 3

/*!
 * \brief Set a ING_MPLS_EXP_TO_ECN entry.
 *
 * \param [in] unit Unit number.
 * \param [in] prof_id Profile ID of the corresponding mapping profile.
 * \param [in] entry Entry configured.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_ing_mpls_exp_to_ecn_entry_set(
    int unit,
    int prof_id,
    bcm_ecn_map_t *entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_MPLS_EXP_TO_IP_ECNs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, ECN_MPLS_EXP_TO_IP_ECN_IDs, prof_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, LAST_DERIVED_ECNs, entry->ecn));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, EXPs, entry->exp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, ECNs, entry->new_ecn));

    data = (entry->action_flags & BCM_ECN_TRAFFIC_ACTION_INGRESS_DROP) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, DROPs, data));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_INSERT,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve a ING_MPLS_EXP_TO_ECN entry.
 *
 * \param [in] unit Unit number.
 * \param [in] prof_id Profile ID of the corresponding mapping profile.
 * \param [out] entry Entry returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_ing_mpls_exp_to_ecn_entry_get(
    int unit,
    int prof_id,
    bcm_ecn_map_t *entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_MPLS_EXP_TO_IP_ECNs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, ECN_MPLS_EXP_TO_IP_ECN_IDs, prof_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, LAST_DERIVED_ECNs, entry->ecn));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, EXPs, entry->exp));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, ECNs, &data));
    entry->new_ecn = (uint8)data;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, DROPs, &data));
    if (data) {
        entry->action_flags |= BCM_ECN_TRAFFIC_ACTION_INGRESS_DROP;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete a ING_MPLS_EXP_TO_ECN entry.
 *
 * \param [in] unit Unit number.
 * \param [in] prof_id Profile ID of the corresponding mapping profile.
 * \param [in] entry Entry to be removed.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_ing_mpls_exp_to_ecn_entry_del(
    int unit,
    int prof_id,
    bcm_ecn_map_t *entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_MPLS_EXP_TO_IP_ECNs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, ECN_MPLS_EXP_TO_IP_ECN_IDs, prof_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, LAST_DERIVED_ECNs, entry->ecn));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, EXPs, entry->exp));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize a ING_MPLS_EXP_TO_ECN profile entries.
 *
 * \param [in] unit Unit number.
 * \param [out] prof_entries Profile entries initialized.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_ing_mpls_exp_to_ecn_profile_entries_init(
    int unit,
    bcm_ecn_map_t *prof_entries)
{
    int exp, ecn;
    int idx;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entries, SHR_E_PARAM);
    sal_memset(prof_entries, 0, sizeof(bcm_ecn_map_t) *
               XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET);

    idx = 0;
    /* 3-bit EXP, 2-bit ECN. */
    for (exp = 0; exp < 8; exp++) {
        for (ecn = 0; ecn < 4; ecn++) {
            prof_entries[idx].exp = exp;
            prof_entries[idx].ecn = ecn;
            prof_entries[idx].new_ecn = ecn;
            prof_entries[idx].action_flags = 0;
            idx++;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve a ING_MPLS_EXP_TO_ECN profile.
 *
 * \param [in] unit Unit number.
 * \param [in] prof_id Profile ID of the corresponding mapping profile.
 * \param [out] prof_entry Profile returned, caller allocates enough space.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_ing_mpls_exp_to_ecn_profile_get(
    int unit,
    int prof_id,
    bcm_ecn_map_t *prof_entries)
{
    int idx;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entries, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_profile_entries_init(unit, prof_entries));

    for (idx = 0; idx < XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_ing_mpls_exp_to_ecn_entry_get(unit, prof_id,
                                                   prof_entries + idx));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a ING_MPLS_EXP_TO_ECN profile.
 *
 * \param [in] unit Unit number.
 * \param [in] prof_entries Profile entries to be added.
 * \param [out] prof_id Profile ID of the corresponding mapping profile.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_ing_mpls_exp_to_ecn_profile_add(
    int unit,
    bcm_ecn_map_t *prof_entries,
    int *prof_id)
{
    int idx;
    bcmi_ltsw_profile_hdl_t prof_hdl = BCMI_LTSW_PROFILE_ECN_ING_MPLS_EXP_TO_ECN;
    int profile_idx;
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entries, SHR_E_PARAM);
    SHR_NULL_CHECK(prof_id, SHR_E_PARAM);

    rv = bcmi_ltsw_profile_index_allocate(unit, prof_hdl, prof_entries,
             BCMI_LTSW_PROFILE_F_MATACH_DISABLE,
             XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET, &profile_idx);
    if (rv == SHR_E_EXISTS) {
        *prof_id = profile_idx / XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET;
        SHR_EXIT();
    }
    if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }

    *prof_id = profile_idx / XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET;
    for (idx = 0; idx < XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_ing_mpls_exp_to_ecn_entry_set(unit, *prof_id,
                                                   prof_entries + idx));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete a ING_MPLS_EXP_TO_ECN profile.
 *
 * \param [in] unit Unit number.
 * \param [in] prof_id Profile ID of the corresponding mapping profile.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_ing_mpls_exp_to_ecn_profile_del(
    int unit,
    int prof_id)
{
    int idx;
    int rv;
    int profile_idx = prof_id * XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET;
    bcm_ecn_map_t prof_entries[XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET];
    bcmi_ltsw_profile_hdl_t prof_hdl = BCMI_LTSW_PROFILE_ECN_ING_MPLS_EXP_TO_ECN;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_free(unit, prof_hdl, profile_idx);

    if (rv == SHR_E_BUSY) {
        SHR_EXIT();
    }

    if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_profile_entries_init(unit, prof_entries));

    for (idx = 0; idx < XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_ing_mpls_exp_to_ecn_entry_del(unit, prof_id,
                                                   prof_entries + idx));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Comparison callback function for ING_MPLS_EXP_TO_ECN profile.
 *
 * \param [in] unit Unit number.
 * \param [in] entries Profile entry.
 * \param [in] entries_per_set Number of entries per set.
 * \param [in] index Index of LT entry.
 * \param [out] cmp_result Comparison result.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_ing_mpls_exp_to_ecn_profile_cmp_cb(
    int unit,
    void *entries,
    int entries_per_set,
    int index,
    int *cmp_result)
{
    bcm_ecn_map_t prof_entries[XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET];
    int prof_id;

    SHR_FUNC_ENTER(unit);

    if (entries_per_set != XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(cmp_result, SHR_E_PARAM);

    prof_id = index / XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET;

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_profile_entries_init(unit, prof_entries));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_profile_get(unit, prof_id, prof_entries));

    *cmp_result = sal_memcmp(entries, prof_entries, sizeof(prof_entries));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Hash callback function for ING_MPLS_EXP_TO_ECN profile.
 *
 * \param [in] unit Unit number.
 * \param [in] entries ING_MPLS_EXP_TO_ECN profile entry.
 * \param [in] entries_per_set Number of entries per set.
 * \param [out] hash Hash value returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_ing_mpls_exp_to_ecn_profile_hash_cb(
    int unit,
    void *prof_entries,
    int entries_per_set,
    uint32_t *hash)
{
    SHR_FUNC_ENTER(unit);

    if (entries_per_set != XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(prof_entries, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    *hash = shr_crc32(0, prof_entries,
                      entries_per_set * sizeof(bcm_ecn_map_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Max number of ING_MPLS_EXP_TO_ECN profile.
 *
 * \param [in] unit Unit number.
 * \param [out] prof_num Max number of profiles available in LT.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_ing_mpls_exp_to_ecn_prof_num_get(
    int unit,
    int *prof_num)
{
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_num, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, ECN_MPLS_EXP_TO_IP_ECNs,
                                       ECN_MPLS_EXP_TO_IP_ECN_IDs,
                                       &idx_min, &idx_max));
    *prof_num = idx_max - idx_min + 1;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover ING_MPLS_EXP_TO_ECN profile.
 *
 * \param [in] unit Unit number.
 * \param [in] prof_id Id of ING_MPLS_EXP_TO_ECN profile.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
int
xfs_ecn_ing_mpls_exp_to_ecn_profile_recover(
    int unit,
    int prof_id)
{
    uint32_t ref_cnt;
    uint64_t idx_min, idx_max;
    int index;
    bcm_ecn_map_t exp_to_ecn_prof[XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET];

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, ECN_MPLS_EXP_TO_IP_ECNs,
                                       ECN_MPLS_EXP_TO_IP_ECN_IDs,
                                       &idx_min, &idx_max));

    if ((prof_id < idx_min) || (prof_id > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    index = prof_id * XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_get(unit,
                                         BCMI_LTSW_PROFILE_ECN_ING_MPLS_EXP_TO_ECN,
                                         index, &ref_cnt));
    if (ref_cnt == 0) {
        /* If profile entry has not been initialized. */
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_ing_mpls_exp_to_ecn_profile_entries_init(unit,
                                                              exp_to_ecn_prof));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_ing_mpls_exp_to_ecn_profile_get(unit, prof_id,
                                                     exp_to_ecn_prof));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_hash_update(unit,
                                           BCMI_LTSW_PROFILE_ECN_ING_MPLS_EXP_TO_ECN,
                                           exp_to_ecn_prof,
                                           XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET,
                                           index));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_increase(unit,
                                              BCMI_LTSW_PROFILE_ECN_ING_MPLS_EXP_TO_ECN,
                                              XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET,
                                              index,
                                              1));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initial ING_MPLS_EXP_TO_ECN profile status.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_ing_mpls_exp_to_ecn_profile_init(
    int unit)
{
    uint64_t idx_max, idx_min;
    int prof_id, prof_num;
    int map_id;
    int ent_idx_max, ent_idx_min;
    bcmi_ltsw_profile_hdl_t prof_hdl = BCMI_LTSW_PROFILE_ECN_ING_MPLS_EXP_TO_ECN;
    bcm_ecn_map_t exp_to_ecn_prof[XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET];
    int index;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, ECN_MPLS_EXP_TO_IP_ECNs,
                                       ECN_MPLS_EXP_TO_IP_ECN_IDs,
                                       &idx_min, &idx_max));

    /* Convert profile ID to LT index. */
    ent_idx_max =
        (idx_max + 1) * XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET - 1;
    ent_idx_min = idx_min * XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit, &prof_hdl,
                                    &ent_idx_min, &ent_idx_max, 1,
                                    xfs_ecn_ing_mpls_exp_to_ecn_profile_hash_cb,
                                    xfs_ecn_ing_mpls_exp_to_ecn_profile_cmp_cb));

    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, ECN_MPLS_EXP_TO_IP_ECNs));
        /* Profile 0 reserved. */
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_ing_mpls_exp_to_ecn_profile_entries_init(unit,
                                                              exp_to_ecn_prof));

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_ing_mpls_exp_to_ecn_profile_add(unit, exp_to_ecn_prof,
                                                     &index));
        if (index != 0) {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
    } else {
        /* Recover the reserved profile 0. */
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_ing_mpls_exp_to_ecn_profile_recover(unit, 0));

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_ing_mpls_exp_to_ecn_prof_num_get(unit, &prof_num));
        for (map_id = 0; map_id < prof_num; map_id++) {
            if (!XFS_ECN_ING_EXP_TO_ECN_MAP_USED_GET(unit, map_id)) {
                continue;
            }
            prof_id = XFS_ECN_ING_EXP_TO_ECN_MAP_HW_IDX(unit, map_id);
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ecn_ing_mpls_exp_to_ecn_profile_recover(unit, prof_id));
        }
    }

exit:
    if (SHR_FUNC_ERR()) {
        (void) bcmi_ltsw_profile_unregister(unit,
                   BCMI_LTSW_PROFILE_ECN_ING_MPLS_EXP_TO_ECN);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize SFC QoS PHB with regard to ECN module.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_sfc_qos_phb_init(
    int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_ecn_sfc_qos_phb_setup(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize FLEX_QOS_ING_ECN table.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_traffic_map_init(
    int unit)
{
    bcm_ecn_traffic_map_info_t traffic_map;
    bcm_ecn_traffic_map_tunnel_type_t tnl_type;
    int ecn, tnl_ecn;

    SHR_FUNC_ENTER(unit);

    tnl_type = bcmEcnTrafficMapNonTunnel;
    for ( ; tnl_type < bcmEcnTrafficMapCount; tnl_type++) {
        for (ecn = 0; ecn <= XFS_ECN_MAX_VALUE; ecn++) {
            for (tnl_ecn = 0; tnl_ecn <= XFS_ECN_MAX_VALUE; tnl_ecn++) {
                bcm_ecn_traffic_map_info_t_init(&traffic_map);
                traffic_map.tunnel_type = tnl_type;
                traffic_map.ecn = ecn;
                traffic_map.tunnel_ecn = tnl_ecn;
                traffic_map.flags = 0;
                traffic_map.int_cn = 0;
                SHR_IF_ERR_VERBOSE_EXIT
                    (xfs_ltsw_ecn_traffic_map_set(unit, &traffic_map));

                traffic_map.flags = BCM_ECN_TRAFFIC_MAP_RESPONSIVE;
                SHR_IF_ERR_VERBOSE_EXIT
                    (xfs_ltsw_ecn_traffic_map_set(unit, &traffic_map));
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize ECN_CNG_TO_WRED table.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_action_enqueue_init(
    int unit)
{
    bcm_ecn_traffic_action_config_t ecn_config;
    int int_cn;

    SHR_FUNC_ENTER(unit);

    for (int_cn = 0; int_cn <= XFS_INT_CN_MAX_VALUE; int_cn++) {
        bcm_ecn_traffic_action_config_t_init(&ecn_config);
        ecn_config.int_cn = int_cn;
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_ecn_action_enqueue_set(unit, &ecn_config));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize ECN_WRED_UPDATE table.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_action_dequeue_init(
    int unit)
{
    bcm_ecn_traffic_action_config_t ecn_config;
    int int_cn;
    bcm_color_t color;

    SHR_FUNC_ENTER(unit);

    for (int_cn = 0; int_cn <= XFS_INT_CN_MAX_VALUE; int_cn++) {
        for (color = bcmColorGreen; color <= bcmColorRed; color++) {
            bcm_ecn_traffic_action_config_t_init(&ecn_config);
            ecn_config.int_cn = int_cn;
            ecn_config.color = color;
            ecn_config.responsive = 0;
            ecn_config.non_congested_int_cn = 0;
            ecn_config.congested_int_cn = 0;
            ecn_config.action_flags =
                BCM_ECN_TRAFFIC_ACTION_DEQUEUE_NON_CONGESTION_INT_CN_UPDATE |
                BCM_ECN_TRAFFIC_ACTION_DEQUEUE_CONGESTION_INT_CN_UPDATE;
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ltsw_ecn_action_dequeue_set(unit, &ecn_config));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize latency based ECN.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_ecn_latency_based_mode_init(
    int unit)
{
    int max_pipe, pipe;
    bcm_flexstate_action_t action = {0};
    uint32_t stat_counter_id = 0;
    bcm_flexstate_trigger_t *trigger = NULL;
    bcm_flexstate_index_operation_t *index_op = NULL;
    bcm_flexstate_value_operation_t *value_a_comp_op = NULL;
    bcm_flexstate_value_operation_t *value_a_true_op = NULL;
    bcm_flexstate_value_operation_t *value_a_false_op = NULL;
    bcm_flexstate_value_operation_t *value_b_true_op = NULL;
    int options;

    SHR_FUNC_ENTER(unit);

    max_pipe = bcmi_ltsw_dev_max_pp_pipe_num(unit);

    for (pipe = 0; pipe < max_pipe; pipe++) {
        action.flags = BCM_FLEXSTATE_ACTION_FLAGS_TRIGGER | BCM_FLEXSTATE_ACTION_FLAGS_HINT_OUTPUT;
        BCM_PBMP_PORT_SET(action.ports, pipe);
        action.source = bcmiFlexstateSourceEcnState;
        /* Output to flexstate object 0. */
        action.hint = 0;
        action.mode = bcmFlexstateCounterModeNormal;
        action.index_num = 2048;

        trigger = &action.trigger;
        trigger->trigger_type = bcmFlexstateTriggerTypeTime;
        trigger->period_num = 1;
        trigger->interval = bcmFlexstateTriggerIntervalUnlimited;

        /* port[11:6] + queue[5:0] */
        index_op = &action.index_operation;
        index_op->object[0] = bcmFlexstateObjectEgrPipePortQueueNum;
        index_op->mask_size[0] = 16;
        index_op->shift[0] = 8;
        index_op->object[1] = bcmFlexstateObjectEgrPipePortQueueNum;
        index_op->mask_size[1] = 6;
        index_op->shift[1] = 6;

        /* bcmSwitchLatencyEcnMarkAverage mode. */
        action.operation_a.update_compare = bcmFlexstateUpdateCompareLess;
        /* Compare value is EgrResidenceTime */
        value_a_comp_op = &action.operation_a.compare_operation;
        value_a_comp_op->select = bcmFlexstateValueSelectCounterValue;
        value_a_comp_op->object[0] = bcmFlexstateObjectEgrResidenceTimeRaw0;
        value_a_comp_op->mask_size[0] = 16;
        value_a_comp_op->shift[0] = 0;
        value_a_comp_op->object[1] = bcmFlexstateObjectEgrResidenceTimeRaw;
        value_a_comp_op->mask_size[1] = 16;
        value_a_comp_op->shift[1] = 16;
        value_a_comp_op->type = bcmFlexstateValueOperationTypeNoop;

        /* True value for average mode */
        value_a_true_op = &action.operation_a.operation_true;
        value_a_true_op->select = bcmFlexstateValueSelectCounterValue;
        value_a_true_op->object[0] = bcmFlexstateObjectEgrResidenceTimeRaw0;
        value_a_true_op->mask_size[0] = 16;
        value_a_true_op->shift[0] = 0;
        value_a_true_op->object[1] = bcmFlexstateObjectEgrResidenceTimeRaw;
        value_a_true_op->mask_size[1] = 16;
        value_a_true_op->shift[1] = 16;
        value_a_true_op->type = bcmFlexstateValueOperationTypeAverage;

        /* False value for average mode */
        value_a_false_op = &action.operation_a.operation_false;
        value_a_false_op->select = bcmFlexstateValueSelectCounterValue;
        value_a_false_op->object[0] = bcmFlexstateObjectEgrResidenceTimeRaw0;
        value_a_false_op->mask_size[0] = 16;
        value_a_false_op->shift[0] = 0;
        value_a_false_op->object[1] = bcmFlexstateObjectEgrResidenceTimeRaw;
        value_a_false_op->mask_size[1] = 16;
        value_a_false_op->shift[1] = 16;
        value_a_false_op->type = bcmFlexstateValueOperationTypeAverage;

        action.operation_b.update_compare = bcmFlexstateUpdateCompareAlwaysTrue;
        /* True value for average mode */
        value_b_true_op = &action.operation_b.operation_true;
        value_b_true_op->select = bcmFlexstateValueSelectPairedCounter;
        value_b_true_op->type = bcmFlexstateValueOperationTypeNoop;

        /* Must be the flexstate action 1. */
        options = BCM_FLEXSTATE_OPTIONS_WITH_ID |
                  BCMI_LTSW_FLEXSTATE_OPTIONS_INTERNAL |
                  BCMI_LTSW_FLEXSTATE_OPTIONS_PIPE_BMP;
        stat_counter_id = 1;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexstate_action_create(unit, options, &action,
                                              &stat_counter_id));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexstate_trigger_enable_set(unit, stat_counter_id, TRUE));

        XFS_LB_ECN_FLEX_STAT_ID(unit, pipe) = stat_counter_id;
    }

exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_ecn_deinit(int unit)
{
    int rv = SHR_E_NONE;
    int max_pipe, pipe;
    uint32_t stat_counter_id;
    int warm = bcmi_warmboot_get(unit);

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_unregister(unit,
                                      BCMI_LTSW_PROFILE_ECN_ING_MPLS_EXP_TO_ECN);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (warm) {
        SHR_EXIT();
    }

    max_pipe = bcmi_ltsw_dev_max_pp_pipe_num(unit);
    /* Try to destroy existing flex state action. */
    for (pipe = 0; pipe < max_pipe; pipe++) {
        stat_counter_id = XFS_LB_ECN_FLEX_STAT_ID(unit, pipe);
        if (stat_counter_id != BCMI_LTSW_FLEXSTATE_ACTION_INVALID) {
            /*
             * It is possible that these resources have been freed at flex
             * stat module init time.
             */
            (void)bcm_ltsw_flexstate_action_destroy(unit, stat_counter_id);
            XFS_LB_ECN_FLEX_STAT_ID(unit, pipe) =
                BCMI_LTSW_FLEXSTATE_ACTION_INVALID;
        }
    }

    if (xfs_ecn_bookkeeping[unit].ing_exp_to_ip_ecn_map_bitmap != NULL) {
        (void)bcmi_ltsw_ha_mem_free(unit,
                  xfs_ecn_bookkeeping[unit].ing_exp_to_ip_ecn_map_bitmap);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_init(int unit)
{
    uint64_t idx_max, idx_min;
    uint32_t ha_req_size, ha_alloc_size;
    uint32_t ing_exp_bmp_size;
    uint32_t ing_exp_idx_size;
    void *ptr = NULL;
    void *start_ptr = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, ECN_MPLS_EXP_TO_IP_ECNs,
                                       ECN_MPLS_EXP_TO_IP_ECN_IDs,
                                       &idx_min, &idx_max));

    /* Size of ing_exp_to_ip_ecn_map_bitmap. */
    ing_exp_bmp_size = SHR_BITALLOCSIZE((idx_max - idx_min + 1));
    /* Size of ing_exp_to_ip_ecn_map_hw_idx. */
    ing_exp_idx_size = (idx_max - idx_min + 1) * sizeof(uint32_t);
    ha_req_size = ing_exp_bmp_size + ing_exp_idx_size;
    /* Size of lb_ecn_stat_counter_id, one for each pipe. */
    ha_req_size += sizeof(uint32_t) * bcmi_ltsw_dev_max_pp_pipe_num(unit);
    ha_alloc_size = ha_req_size;
    ptr = bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_ECN, 0,
                                 "bcmEcn", &ha_alloc_size);
    start_ptr = ptr;
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);
    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }
    xfs_ecn_bookkeeping[unit].ing_exp_to_ip_ecn_map_bitmap = ptr;
    ptr += ing_exp_bmp_size;
    xfs_ecn_bookkeeping[unit].ing_exp_to_ip_ecn_map_hw_idx = ptr;
    ptr += ing_exp_idx_size;
    xfs_ecn_bookkeeping[unit].lb_ecn_flex_stat_id = ptr;
    ptr += sizeof(uint32_t) * bcmi_ltsw_dev_max_pp_pipe_num(unit);

    xfs_ecn_bookkeeping[unit].lb_ecn_enable =
        bcmi_ltsw_property_get(unit,
            BCMI_CPN_LB_ECN_FLEXSTATE_ACTION_RESERVE_MODE, 0) ? 0 : 1;

    if (!bcmi_warmboot_get(unit)) {
        sal_memset(start_ptr, 0, ha_req_size);

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_sfc_qos_phb_init(unit));

        /*
         * Simply clear all LTs.
         * Note that currently there are no recommended default values,
         * users are required to configure these LTs as their needs.
         */
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_traffic_map_init(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_action_enqueue_init(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_action_dequeue_init(unit));

        /* To enable LB_ECN, FLEX STATE EGR should work in pipe unique mode. */
        if (XFS_LB_ECN_ENABLE(unit)) {
            /* By default config LB ECN as average mode. */
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ecn_latency_based_mode_init(unit));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_ecn_responsive_default_set(unit, 0));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_profile_init(unit));

exit:
    if (SHR_FUNC_ERR()) {
        (void)xfs_ltsw_ecn_deinit(unit);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_map_create(
    int unit,
    uint32_t flags,
    int *ecn_map_id)
{
    bcm_ecn_map_t ecn_prof[XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET];
    int ecn_map_type;
    int prof_num;
    int prof_id;
    int map_id;

    SHR_FUNC_ENTER(unit);

    if (!(flags & BCM_ECN_MAP_INGRESS) || !(flags & BCM_ECN_MAP_MPLS)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(ecn_map_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_prof_num_get(unit, &prof_num));

    if (flags & BCM_ECN_MAP_WITH_ID) {
        ecn_map_type = (*ecn_map_id) & BCMINT_ECN_MAP_TYPE_MASK;
        if (ecn_map_type != BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        map_id = (*ecn_map_id) & BCMINT_ECN_MAP_ID_MASK;
        if (map_id >= prof_num) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        if (XFS_ECN_ING_EXP_TO_ECN_MAP_USED_GET(unit, map_id)) {
            SHR_ERR_EXIT(SHR_E_EXISTS);
        }
    } else {
        for (map_id = 0; map_id < prof_num; map_id++) {
            if (!XFS_ECN_ING_EXP_TO_ECN_MAP_USED_GET(unit, map_id)) {
                break;
            }
        }

        if (map_id == prof_num) {
            SHR_ERR_EXIT(SHR_E_FULL);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_profile_entries_init(unit, ecn_prof));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_profile_add(unit, ecn_prof, &prof_id));

    *ecn_map_id = map_id | BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN;
    XFS_ECN_ING_EXP_TO_ECN_MAP_USED_SET(unit, map_id);
    XFS_ECN_ING_EXP_TO_ECN_MAP_HW_IDX(unit, map_id) = (uint32_t)(prof_id);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_map_destroy(
    int unit,
    int ecn_map_id)
{
    int ecn_map_type;
    int prof_num;
    int map_id;
    int prof_id;

    SHR_FUNC_ENTER(unit);

    if ((ecn_map_id & BCMINT_ECN_MAP_TYPE_MASK) !=
            BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    ecn_map_type = ecn_map_id & BCMINT_ECN_MAP_TYPE_MASK;
    if (ecn_map_type != BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    map_id = ecn_map_id & BCMINT_ECN_MAP_ID_MASK;
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_prof_num_get(unit, &prof_num));
    if (map_id >= prof_num) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (!XFS_ECN_ING_EXP_TO_ECN_MAP_USED_GET(unit, map_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    prof_id = XFS_ECN_ING_EXP_TO_ECN_MAP_HW_IDX(unit, map_id);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_profile_del(unit, prof_id));

    XFS_ECN_ING_EXP_TO_ECN_MAP_USED_CLR(unit, map_id);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_map_set(
    int unit,
    uint32_t options,
    int ecn_map_id,
    bcm_ecn_map_t *ecn_map)
{
    int ecn_map_type;
    int map_id;
    bcm_ecn_map_t ecn_prof[XFS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET];
    int entry_idx;
    uint32_t prof_id;
    int new_prof_id;
    int prof_num;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_map, SHR_E_PARAM);

    if ((ecn_map_id & BCMINT_ECN_MAP_TYPE_MASK) !=
            BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((ecn_map->ecn > 3) || (ecn_map->exp > 7) || (ecn_map->new_ecn > 3)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    ecn_map_type = ecn_map_id & BCMINT_ECN_MAP_TYPE_MASK;
    if (ecn_map_type != BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    map_id = ecn_map_id & BCMINT_ECN_MAP_ID_MASK;
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_prof_num_get(unit, &prof_num));
    if (map_id >= prof_num) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (!XFS_ECN_ING_EXP_TO_ECN_MAP_USED_GET(unit, map_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    prof_id = XFS_ECN_ING_EXP_TO_ECN_MAP_HW_IDX(unit, map_id);
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_profile_get(unit, prof_id, ecn_prof));
    entry_idx = (ecn_map->exp << 2) + (ecn_map->ecn);
    ecn_prof[entry_idx].action_flags = ecn_map->action_flags;
    ecn_prof[entry_idx].new_ecn = ecn_map->new_ecn;

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_profile_del(unit, prof_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_profile_add(unit, ecn_prof, &new_prof_id));

    XFS_ECN_ING_EXP_TO_ECN_MAP_HW_IDX(unit, map_id) = new_prof_id;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_map_get(
    int unit,
    int ecn_map_id,
    bcm_ecn_map_t *ecn_map)
{
    int ecn_map_type;
    int map_id;
    int prof_id;
    int prof_num;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_map, SHR_E_PARAM);

    if ((ecn_map_id & BCMINT_ECN_MAP_TYPE_MASK) !=
            BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((ecn_map->ecn > 3) || (ecn_map->exp > 7)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    ecn_map_type = ecn_map_id & BCMINT_ECN_MAP_TYPE_MASK;
    if (ecn_map_type != BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    map_id = ecn_map_id & BCMINT_ECN_MAP_ID_MASK;
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_prof_num_get(unit, &prof_num));
    if (map_id >= prof_num) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (!XFS_ECN_ING_EXP_TO_ECN_MAP_USED_GET(unit, map_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    prof_id = XFS_ECN_ING_EXP_TO_ECN_MAP_HW_IDX(unit, map_id);
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_entry_get(unit, prof_id, ecn_map));
exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_latency_based_mode_set(
    int unit,
    bcm_switch_latency_ecn_mark_mode_t mode)
{
    int max_pipe, pipe, options;
    bcm_flexstate_action_t action = {0};
    uint32_t stat_counter_id;
    bcm_flexstate_trigger_t *trigger = NULL;
    bcm_flexstate_index_operation_t *index_op = NULL;
    bcm_flexstate_value_operation_t *value_a_comp_op = NULL;
    bcm_flexstate_value_operation_t *value_a_true_op = NULL;
    bcm_flexstate_value_operation_t *value_a_false_op = NULL;
    bcm_flexstate_value_operation_t *value_b_true_op = NULL;

    SHR_FUNC_ENTER(unit);

    if (!XFS_LB_ECN_ENABLE(unit)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if ((mode < bcmSwitchLatencyEcnMarkInstant) ||
        (mode >= bcmSwitchLatencyEcnMarkCount)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    max_pipe = bcmi_ltsw_dev_max_pp_pipe_num(unit);

    /* Destroy previous flex state action. */
    for (pipe = 0; pipe < max_pipe; pipe++) {
        stat_counter_id = XFS_LB_ECN_FLEX_STAT_ID(unit, pipe);
        if (stat_counter_id != BCMI_LTSW_FLEXSTATE_ACTION_INVALID) {
            (void)bcm_ltsw_flexstate_action_destroy(unit, stat_counter_id);
        }
    }

    for (pipe = 0; pipe < max_pipe; pipe++) {
        action.flags = BCM_FLEXSTATE_ACTION_FLAGS_TRIGGER | BCM_FLEXSTATE_ACTION_FLAGS_HINT_OUTPUT;
        BCM_PBMP_PORT_SET(action.ports, pipe);
        action.source = bcmiFlexstateSourceEcnState;
        /* Output to flexstate object 0. */
        action.hint = 0;
        action.mode = bcmFlexstateCounterModeNormal;
        action.index_num = 2048;

        trigger = &action.trigger;
        trigger->trigger_type = bcmFlexstateTriggerTypeTime;
        trigger->period_num = 1;
        trigger->interval = bcmFlexstateTriggerIntervalUnlimited;

        /* port[9:4] + queue[3:0] */
        index_op = &action.index_operation;
        index_op->object[0] = bcmFlexstateObjectEgrPipePortQueueNum;
        index_op->mask_size[0] = 16;
        index_op->shift[0] = 8;
        index_op->object[1] = bcmFlexstateObjectEgrPipePortQueueNum;
        index_op->mask_size[1] = 6;
        index_op->shift[1] = 4;

        if (mode == bcmSwitchLatencyEcnMarkAverage) {
            action.operation_a.update_compare = bcmFlexstateUpdateCompareLess;
            /* Compare value is EgrResidenceTime */
            value_a_comp_op = &action.operation_a.compare_operation;
            value_a_comp_op->select = bcmFlexstateValueSelectCounterValue;
            value_a_comp_op->object[0] = bcmFlexstateObjectEgrResidenceTimeRaw0;
            value_a_comp_op->mask_size[0] = 16;
            value_a_comp_op->shift[0] = 0;
            value_a_comp_op->object[1] = bcmFlexstateObjectEgrResidenceTimeRaw;
            value_a_comp_op->mask_size[1] = 16;
            value_a_comp_op->shift[1] = 16;
            value_a_comp_op->type = bcmFlexstateValueOperationTypeNoop;

            /* True value for average mode */
            value_a_true_op = &action.operation_a.operation_true;
            value_a_true_op->select = bcmFlexstateValueSelectCounterValue;
            value_a_true_op->object[0] = bcmFlexstateObjectEgrResidenceTimeRaw0;
            value_a_true_op->mask_size[0] = 16;
            value_a_true_op->shift[0] = 0;
            value_a_true_op->object[1] = bcmFlexstateObjectEgrResidenceTimeRaw;
            value_a_true_op->mask_size[1] = 16;
            value_a_true_op->shift[1] = 16;
            value_a_true_op->type = bcmFlexstateValueOperationTypeAverage;

            /* False value for average mode */
            value_a_false_op = &action.operation_a.operation_false;
            value_a_false_op->select = bcmFlexstateValueSelectCounterValue;
            value_a_false_op->object[0] = bcmFlexstateObjectEgrResidenceTimeRaw0;
            value_a_false_op->mask_size[0] = 16;
            value_a_false_op->shift[0] = 0;
            value_a_false_op->object[1] = bcmFlexstateObjectEgrResidenceTimeRaw;
            value_a_false_op->mask_size[1] = 16;
            value_a_false_op->shift[1] = 16;
            value_a_false_op->type = bcmFlexstateValueOperationTypeAverage;

            action.operation_b.update_compare = bcmFlexstateUpdateCompareAlwaysTrue;
            /* True value for average mode */
            value_b_true_op = &action.operation_b.operation_true;
            value_b_true_op->select = bcmFlexstateValueSelectPairedCounter;
            value_b_true_op->type = bcmFlexstateValueOperationTypeNoop;
        } else {
            /* bcmSwitchLatencyEcnMarkInstant mode */
            action.operation_a.update_compare = bcmFlexstateUpdateCompareLess;
            /* Compare value is EgrResidenceTime */
            value_a_comp_op = &action.operation_a.compare_operation;
            value_a_comp_op->select = bcmFlexstateValueSelectCounterValue;
            value_a_comp_op->object[0] = bcmFlexstateObjectEgrResidenceTimeRaw0;
            value_a_comp_op->mask_size[0] = 16;
            value_a_comp_op->shift[0] = 0;
            value_a_comp_op->object[1] = bcmFlexstateObjectEgrResidenceTimeRaw;
            value_a_comp_op->mask_size[1] = 16;
            value_a_comp_op->shift[1] = 16;
            value_a_comp_op->type = bcmFlexstateValueOperationTypeNoop;

            /* True value for instantaneous mode */
            value_a_true_op = &action.operation_a.operation_true;
            value_a_true_op->select = bcmFlexstateValueSelectPairedCounter;
            value_a_true_op->type = bcmFlexstateValueOperationTypeNoop;

            /* False value for instantaneous mode */
            value_a_false_op = &action.operation_a.operation_false;
            value_a_false_op->select = bcmFlexstateValueSelectPairedCounter;
            value_a_false_op->type = bcmFlexstateValueOperationTypeNoop;

            action.operation_b.update_compare = bcmFlexstateUpdateCompareAlwaysTrue;
            /* True value for instantaneous mode */
            value_b_true_op = &action.operation_b.operation_true;
            value_b_true_op->select = bcmFlexstateValueSelectPairedCounter;
            value_b_true_op->type = bcmFlexstateValueOperationTypeNoop;
        }

        /* Must be the flexstate action 1. */
        options = BCM_FLEXSTATE_OPTIONS_WITH_ID |
                  BCMI_LTSW_FLEXSTATE_OPTIONS_INTERNAL |
                  BCMI_LTSW_FLEXSTATE_OPTIONS_PIPE_BMP;
        stat_counter_id = 1;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexstate_action_create(unit, options, &action,
                                              &stat_counter_id));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexstate_trigger_enable_set(unit, stat_counter_id, TRUE));

        XFS_LB_ECN_FLEX_STAT_ID(unit, pipe) = stat_counter_id;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_latency_based_mode_get(
    int unit,
    bcm_switch_latency_ecn_mark_mode_t *mode)
{
    bcm_flexstate_action_t action = {0};
    bcm_flexstate_value_operation_t *value_a_true_op = NULL;

    SHR_FUNC_ENTER(unit);

    if (!XFS_LB_ECN_ENABLE(unit)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_NULL_CHECK(mode, SHR_E_PARAM);

    if (XFS_LB_ECN_FLEX_STAT_ID(unit, 0) != BCMI_LTSW_FLEXSTATE_ACTION_INVALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_flexstate_action_get(unit, XFS_LB_ECN_FLEX_STAT_ID(unit, 0),
                                         &action));
    } else {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    value_a_true_op = &action.operation_a.operation_true;
    if (value_a_true_op->type == bcmFlexstateValueOperationTypeAverage) {
        *mode = bcmSwitchLatencyEcnMarkAverage;
    } else {
        *mode = bcmSwitchLatencyEcnMarkInstant;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_latency_based_threshold_set(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    bcm_switch_latency_ecn_mark_mode_t mode,
    uint32_t threshold)
{
    /* 32-bit threshold is enough since the latency timer is 32-bit. */
    bcm_flexstate_counter_value_t counter_value = {{threshold, 0}};
    uint32_t counter_index;
    int modid, trunk_id, id;
    bcm_port_t local_port = 0;
    int pipe_local_port;
    int num_ucq, pp_pipe = 0;
    bcm_switch_latency_ecn_mark_mode_t cur_mode;

    SHR_FUNC_ENTER(unit);

    if (!XFS_LB_ECN_ENABLE(unit)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (mode != bcmSwitchLatencyEcnMarkInstant) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_ecn_latency_based_mode_get(unit, &cur_mode));
    if (cur_mode != bcmSwitchLatencyEcnMarkInstant) {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    if (BCM_GPORT_IS_SET(gport)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_resolve(unit, gport, &modid, &local_port,
                                          &trunk_id, &id));
    } else {
        local_port = gport;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, NULL));
    if ((cosq < -1) || (cosq >= num_ucq)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    pipe_local_port = bcmi_ltsw_dev_logic_port_pp_pipe_port(unit, local_port);
    counter_index = ((pipe_local_port & 0x3F) << 4) | (cosq & 0xF);

    pp_pipe = bcmi_ltsw_dev_logic_port_pp_pipe(unit, local_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexstate_stat_set(unit, XFS_LB_ECN_FLEX_STAT_ID(unit, pp_pipe),
                                   1, &counter_index, &counter_value));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_latency_based_threshold_get(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    bcm_switch_latency_ecn_mark_mode_t mode,
    uint32_t *threshold)
{
    bcm_flexstate_counter_value_t counter_value;
    uint32_t counter_index;
    int modid, trunk_id, id;
    bcm_port_t local_port = 0;
    int pipe_local_port;
    int num_ucq, pp_pipe = 0;
    bcm_switch_latency_ecn_mark_mode_t cur_mode;

    SHR_FUNC_ENTER(unit);

    if (!XFS_LB_ECN_ENABLE(unit)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_NULL_CHECK(threshold, SHR_E_PARAM);

    if (mode != bcmSwitchLatencyEcnMarkInstant) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_ecn_latency_based_mode_get(unit, &cur_mode));
    if (cur_mode != bcmSwitchLatencyEcnMarkInstant) {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    if (BCM_GPORT_IS_SET(gport)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_resolve(unit, gport, &modid, &local_port,
                                          &trunk_id, &id));
    } else {
        local_port = gport;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_ucq, NULL));
    if ((cosq < -1) || (cosq >= num_ucq)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    pipe_local_port = bcmi_ltsw_dev_logic_port_pp_pipe_port(unit, local_port);
    counter_index = ((pipe_local_port & 0x3F) << 4) | (cosq & 0xF);

    pp_pipe = bcmi_ltsw_dev_logic_port_pp_pipe(unit, local_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_flexstate_stat_get(unit, XFS_LB_ECN_FLEX_STAT_ID(unit, pp_pipe),
                                   1, &counter_index, &counter_value));
    *threshold = counter_value.value[0];

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_map_id_resolve(
    int unit,
    int ecn_map_id,
    int *ecn_map_type,
    uint32_t *prof_id)
{
    int map_id;
    int prof_num;
    int type;

    SHR_FUNC_ENTER(unit);

    type = ecn_map_id & BCMINT_ECN_MAP_TYPE_MASK;
    if (type != BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
        /* Currently only supports ingress MPLS EXP2ECN mapping. */
        SHR_ERR_EXIT(SHR_E_PARAM);
    } else if (ecn_map_type != NULL){
        *ecn_map_type = type;
    }

    if (prof_id != NULL) {
        map_id = ecn_map_id & BCMINT_ECN_MAP_ID_MASK;

        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ecn_ing_mpls_exp_to_ecn_prof_num_get(unit, &prof_num));
        if (map_id >= prof_num) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        if (!XFS_ECN_ING_EXP_TO_ECN_MAP_USED_GET(unit, map_id)) {
            SHR_ERR_EXIT(SHR_E_NOT_FOUND);
        }

        *prof_id = XFS_ECN_ING_EXP_TO_ECN_MAP_HW_IDX(unit, map_id);

        if (*prof_id >= prof_num) {
            SHR_ERR_EXIT(SHR_E_NOT_FOUND);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_map_id_construct(
    int unit,
    int ecn_map_type,
    uint32_t prof_id,
    int *ecn_map_id)
{
    int map_id;
    int prof_num;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_map_id, SHR_E_PARAM);

    if (ecn_map_type != BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
        /* Currently only supports ingress MPLS EXP2ECN mapping. */
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ecn_ing_mpls_exp_to_ecn_prof_num_get(unit, &prof_num));

    for (map_id = 0; map_id < prof_num; map_id++) {
        if (XFS_ECN_ING_EXP_TO_ECN_MAP_USED_GET(unit, map_id)) {
            if (prof_id == XFS_ECN_ING_EXP_TO_ECN_MAP_HW_IDX(unit, map_id)) {
                *ecn_map_id = ecn_map_type | map_id;
                break;
            }
        }
    }

    if (map_id == prof_num) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_traffic_map_set(
    int unit,
    bcm_ecn_traffic_map_info_t *map)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int32_t idx;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(map, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (map->tunnel_type >= bcmEcnTrafficMapCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if ((map->ecn > XFS_ECN_MAX_VALUE) || (map->tunnel_ecn > XFS_ECN_MAX_VALUE)
        || (map->int_cn > XFS_INT_CN_MAX_VALUE) || (map->int_cn < 0)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if ((map->flags & ~BCM_ECN_TRAFFIC_MAP_RESPONSIVE) != 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* base_ptr (3-bit) | inner_ecn(2-bit) | outer_ecn(2-bit) | res.(1-bit). */
    switch (map->tunnel_type) {
    case bcmEcnTrafficMapNonTunnel:
        idx = XFS_ECN_TRAFFIC_NON_TNL_BASE_PTR << 5;
        idx |= (map->ecn << 1) |
               (map->flags & BCM_ECN_TRAFFIC_MAP_RESPONSIVE);
        break;

    case bcmEcnTrafficMapL2Tunnel:
        idx = XFS_ECN_TRAFFIC_L2_TNL_BASE_PTR << 5;
        idx |= (map->ecn << 3) | (map->tunnel_ecn << 1) |
               (map->flags & BCM_ECN_TRAFFIC_MAP_RESPONSIVE);
        break;

    case bcmEcnTrafficMapL3Tunnel:
        idx = XFS_ECN_TRAFFIC_L3_TNL_BASE_PTR << 5;
        idx |= (map->ecn << 3) | (map->tunnel_ecn << 1) |
               (map->flags & BCM_ECN_TRAFFIC_MAP_RESPONSIVE);
        break;

    case bcmEcnTrafficMapMpls:
        idx = XFS_ECN_TRAFFIC_MPLS_BASE_PTR << 5;
        idx |= (map->tunnel_ecn << 1) |
               (map->flags & BCM_ECN_TRAFFIC_MAP_RESPONSIVE);
        break;

    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, FLEX_QOS_ING_ECNs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, BASE_INDEXs, idx););

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, map->int_cn));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_traffic_map_get(
    int unit,
    bcm_ecn_traffic_map_info_t *map)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t data;
    int32_t idx;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(map, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (map->tunnel_type >= bcmEcnTrafficMapCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if ((map->ecn > XFS_ECN_MAX_VALUE) ||
        (map->tunnel_ecn > XFS_ECN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if ((map->flags & ~BCM_ECN_TRAFFIC_MAP_RESPONSIVE) != 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* base_ptr (3-bit) | inner_ecn(2-bit) | outer_ecn(2-bit) | res.(1-bit). */
    switch (map->tunnel_type) {
    case bcmEcnTrafficMapNonTunnel:
        idx = XFS_ECN_TRAFFIC_NON_TNL_BASE_PTR << 5;
        idx |= (map->ecn << 1) |
               (map->flags & BCM_ECN_TRAFFIC_MAP_RESPONSIVE);
        break;

    case bcmEcnTrafficMapL2Tunnel:
        idx = XFS_ECN_TRAFFIC_L2_TNL_BASE_PTR << 5;
        idx |= (map->ecn << 3) | (map->tunnel_ecn << 1) |
               (map->flags & BCM_ECN_TRAFFIC_MAP_RESPONSIVE);
        break;

    case bcmEcnTrafficMapL3Tunnel:
        idx = XFS_ECN_TRAFFIC_L3_TNL_BASE_PTR << 5;
        idx |= (map->ecn << 3) | (map->tunnel_ecn << 1) |
               (map->flags & BCM_ECN_TRAFFIC_MAP_RESPONSIVE);
        break;

    case bcmEcnTrafficMapMpls:
        idx = XFS_ECN_TRAFFIC_MPLS_BASE_PTR << 5;
        idx |= (map->tunnel_ecn << 1) |
               (map->flags & BCM_ECN_TRAFFIC_MAP_RESPONSIVE);
        break;

    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, FLEX_QOS_ING_ECNs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, BASE_INDEXs, idx););

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, INT_ECN_CNGs, &data));

    map->int_cn = data;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_action_enqueue_set(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XFS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_CNG_TO_WREDs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    data = (ecn_config->action_flags
            & BCM_ECN_TRAFFIC_ACTION_ENQUEUE_WRED_RESPONSIVE) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, data));
    data = (ecn_config->action_flags
            & BCM_ECN_TRAFFIC_ACTION_ENQUEUE_MARK_ELIGIBLE) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MARKs, data));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_action_enqueue_get(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XFS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_CNG_TO_WREDs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, RESPONSIVEs, &data));
    if (data) {
        ecn_config->action_flags |=
            BCM_ECN_TRAFFIC_ACTION_ENQUEUE_WRED_RESPONSIVE;
    } else {
        ecn_config->action_flags &=
            ~BCM_ECN_TRAFFIC_ACTION_ENQUEUE_WRED_RESPONSIVE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, MARKs, &data));
    if (data) {
        ecn_config->action_flags |=
            BCM_ECN_TRAFFIC_ACTION_ENQUEUE_MARK_ELIGIBLE;
    } else {
        ecn_config->action_flags &=
            ~BCM_ECN_TRAFFIC_ACTION_ENQUEUE_MARK_ELIGIBLE;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_action_dequeue_set(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t data;
    int cng;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->color != bcmColorGreen)
        && (ecn_config->color != bcmColorYellow)
        && (ecn_config->color != bcmColorRed)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XFS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    cng = BCMI_LTSW_QOS_COLOR_ENCODING(ecn_config->color);
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_WRED_UPDATEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    /* Update the int_cn value when congestion is not experienced. */
    /* CE = 0. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TM_CONGESTIONs, 0));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PACKET_CNGs, cng));

   if ((ecn_config->action_flags &
        BCM_ECN_TRAFFIC_ACTION_DEQUEUE_NON_CONGESTION_INT_CN_UPDATE) &&
        (ecn_config->non_congested_int_cn != ecn_config->int_cn)) {
        if ((ecn_config->non_congested_int_cn < 0) ||
            (ecn_config->non_congested_int_cn > XFS_INT_CN_MAX_VALUE)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        data = ecn_config->non_congested_int_cn;
    } else {
        data = ecn_config->int_cn;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, NEW_INT_ECN_CNGs, data));
    data = ecn_config->responsive ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, data));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    /* Update the int_cn value when congestion is experienced. */
    /* CE = 1. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TM_CONGESTIONs, 1));

   if ((ecn_config->action_flags &
        BCM_ECN_TRAFFIC_ACTION_DEQUEUE_CONGESTION_INT_CN_UPDATE) &&
        (ecn_config->congested_int_cn != ecn_config->int_cn)) {
        if ((ecn_config->congested_int_cn < 0) ||
            (ecn_config->congested_int_cn > XFS_INT_CN_MAX_VALUE)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        data = ecn_config->congested_int_cn;
    } else {
        data = ecn_config->int_cn;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, NEW_INT_ECN_CNGs, data));
    data = ecn_config->responsive ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, data));

    if (ecn_config->int_cn == 2) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CONGESTION_MARKEDs, 1));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_action_dequeue_get(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t data;
    int cng;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->color != bcmColorGreen)
        && (ecn_config->color != bcmColorYellow)
        && (ecn_config->color != bcmColorRed)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XFS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    cng = BCMI_LTSW_QOS_COLOR_ENCODING(ecn_config->color);
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_WRED_UPDATEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    /* Get the updated int_cn value when congestion is not experienced. */
    /* CE = 0. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TM_CONGESTIONs, 0));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PACKET_CNGs, cng));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NEW_INT_ECN_CNGs, &data));
    if (data != ecn_config->int_cn) {
        ecn_config->action_flags |=
            BCM_ECN_TRAFFIC_ACTION_DEQUEUE_NON_CONGESTION_INT_CN_UPDATE;
        ecn_config->non_congested_int_cn = data;
    } else {
        ecn_config->action_flags &=
            ~BCM_ECN_TRAFFIC_ACTION_DEQUEUE_NON_CONGESTION_INT_CN_UPDATE;
    }

    /* Get the updated int_cn value when congestion is experienced. */
    /* CE = 1. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TM_CONGESTIONs, 1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NEW_INT_ECN_CNGs, &data));
    if (data != ecn_config->int_cn) {
        ecn_config->action_flags |=
            BCM_ECN_TRAFFIC_ACTION_DEQUEUE_CONGESTION_INT_CN_UPDATE;
        ecn_config->congested_int_cn = data;
    } else {
        ecn_config->action_flags &=
            ~BCM_ECN_TRAFFIC_ACTION_DEQUEUE_CONGESTION_INT_CN_UPDATE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, RESPONSIVEs, &data));
    ecn_config->responsive = data;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_responsive_default_set(
    int unit,
    int value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    if ((value != 0) && (value != 1)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, R_ECN_CONTROLs, &entry_hdl));
    /* This value applies to all Non-TCP (including Non-IP) packets. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, RESPONSIVE_DEFAULTs, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_ecn_responsive_default_get(
    int unit,
    int *value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(value, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, R_ECN_CONTROLs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, RESPONSIVE_DEFAULTs, &data));

    *value = data ? 1 : 0;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

