/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>

#include <bcm_int/ltsw/xfs/tunnel.h>
#include <bcm_int/ltsw/tunnel.h>
#include <bcm_int/ltsw/mbcm/tunnel.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/l3.h>
#include <bcm_int/ltsw/l3_intf.h>
#include <bcm_int/ltsw/index_table_mgmt.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/sbr.h>
#include <bcm_int/ltsw/qos.h>
#include <bcm_int/ltsw/types.h>

#include <shr/shr_debug.h>
#include <shr/shr_crc.h>
#include <sal/sal_time.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_TUNNEL

/******************************************************************************
 * Private functions
 */


#define XFS_EGR_TNL_INIT_LAYER_MASK  1
#define XFS_EGR_TNL_INIT_LAYER_OFFSET  3
#define XFS_EGR_TNL_INIT_TYPE_MASK 0x3
#define XFS_EGR_TNL_INIT_TYPE_OFFSET 1
#define XFS_EGR_TNL_INIT_IP_VERSION_MASK 1
#define XFS_EGR_TNL_INIT_IP_VERSION_OFFSET 0

#define XFS_EGR_TNL_INIT_L3_TYPE_IPIP    1
#define XFS_EGR_TNL_INIT_L3_TYPE_L3GRE   2
#define XFS_EGR_TNL_INIT_L3_TYPE_MPLS    3

#define XFS_EGR_TNL_INIT_L2_TYPE_VXLAN   1
#define XFS_EGR_TNL_INIT_L2_TYPE_MPLS    3

#define XFS_EGR_TNL_INIT_DF_VALUE_IF_PLD_IPV6_OFFSET 0
#define XFS_EGR_TNL_INIT_DF_VALUE_IF_PLD_IPV4_OFFSET 1
#define XFS_EGR_TNL_INIT_INHERIT_DF_IF_PLD_IPV4_OFFSET 2
#define XFS_EGR_TNL_INIT_L3_PROTOCOL_OFFSET 0

#define XFS_EGR_TNL_INIT_TNL_HDR_DSCP_OFFSET 22
#define XFS_EGR_TNL_INIT_TNL_HDR_ECN_OFFSET 20

/* Compare result equal. */
#define BCM_L3_CMP_EQUAL     0
/* Compare result NOT equal. */
#define BCM_L3_CMP_NOT_EQUAL 2

typedef struct xfs_ltsw_tnl_term_type_s {
    /* Tunnel outer header is IPv6. */
    int tnl_outer_hdr_ipv6;
    /* Tunnel outer IP header protocol. */
#define XFS_TNL_PAYLOAD_PROTOCOL_IP4 0x4
#define XFS_TNL_PAYLOAD_PROTOCOL_IP6 0x29
#define XFS_TNL_PAYLOAD_PROTOCOL_GRE 0x2F
    int tnl_protocol;
} xfs_ltsw_tnl_term_type_t;

#define XFS_TNL_DFL_PRIORITY 0x1

typedef struct xfs_ltsw_tnl_info_s {
    /* Capacity of l3_ipv4_tunnel_table. */
    uint32_t ipv4_tunnel_term_cap;

    /* Capacity of l3_ipv6_tunnel_table. */
    uint32_t ipv6_tunnel_term_cap;

    /* Capacity of L3 tunnel initiator LT. */
    uint32_t tunnel_init_cap;
} xfs_ltsw_tnl_info_t;
static xfs_ltsw_tnl_info_t xfs_ltsw_tnl_info[BCM_MAX_NUM_UNITS];
#define XFS_TNL_INFO_V4_TNL_TERM_CAP(unit) \
            xfs_ltsw_tnl_info[unit].ipv4_tunnel_term_cap
#define XFS_TNL_INFO_V6_TNL_TERM_CAP(unit) \
            xfs_ltsw_tnl_info[unit].ipv6_tunnel_term_cap
#define XFS_TNL_INFO_TNL_INIT_CAP(unit) \
            xfs_ltsw_tnl_info[unit].tunnel_init_cap

typedef struct xfs_tnl_encap_seq_info_s {
    /* Min index. */
    uint32_t idx_min;

    /* Max index. */
    uint32_t idx_max;

    /* Sequence number inuse bit map. */
    SHR_BITDCL *seq_num_bmp;

    /* Sequence number used by IP tunnel. */
    SHR_BITDCL *tnl_seq_num_bmp;

    /* Sequence number used by virtual port. */
    SHR_BITDCL *vp_seq_num_bmp;

    /* Sequence number used by mirror. */
    SHR_BITDCL *mirror_seq_num_bmp;
} xfs_tnl_encap_seq_info_t;

static xfs_tnl_encap_seq_info_t xfs_tnl_encap_seq_info[BCM_MAX_NUM_UNITS];

#define XFS_SEQ_INFO(unit)               xfs_tnl_encap_seq_info[unit]
#define XFS_SEQ_NUM_BMP(unit)            XFS_SEQ_INFO(unit).seq_num_bmp
#define XFS_SEQ_NUM_TNL_BMP(unit)        XFS_SEQ_INFO(unit).tnl_seq_num_bmp
#define XFS_SEQ_NUM_VP_BMP(unit)         XFS_SEQ_INFO(unit).vp_seq_num_bmp
#define XFS_SEQ_NUM_MIRROR_BMP(unit)     XFS_SEQ_INFO(unit).mirror_seq_num_bmp
#define XFS_SEQ_NUM_IDX_MIN(unit)        XFS_SEQ_INFO(unit).idx_min
#define XFS_SEQ_NUM_IDX_MAX(unit)        XFS_SEQ_INFO(unit).idx_max

/******************************************************************************
 * Private functions
 */

/*!
 * \brief Tunnel initiator LT edit_ctrl_id field encoder.
 *
 * \param [in] unit Unit number.
 * \param [in] tnl_type Tunnel initiator type.
 * \param [out] edit_ctrl_id LT field.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_tnl_init_edit_ctrl_id_encode(int unit, bcm_tunnel_type_t tnl_type,
                                 int *edit_ctrl_id)
{
    /* L3 tunnel or L2 tunnel */
    /* IPv4 tunnel or IPv6 tunnel */
    int ip6 = 0;
    int type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(edit_ctrl_id, SHR_E_PARAM);

    switch (tnl_type) {
    case bcmTunnelTypeIp4In4:
    case bcmTunnelTypeIp6In4:
    case bcmTunnelTypeIpAnyIn4:
        type = XFS_EGR_TNL_INIT_L3_TYPE_IPIP;
        break;

    case bcmTunnelTypeIp4In6:
    case bcmTunnelTypeIp6In6:
    case bcmTunnelTypeIpAnyIn6:
        ip6 = 1;
        type = XFS_EGR_TNL_INIT_L3_TYPE_IPIP;
        break;

    case bcmTunnelTypeGre4In4:
    case bcmTunnelTypeGre6In4:
    case bcmTunnelTypeGreAnyIn4:
        type = XFS_EGR_TNL_INIT_L3_TYPE_L3GRE;
        break;

    case bcmTunnelTypeGre4In6:
    case bcmTunnelTypeGre6In6:
    case bcmTunnelTypeGreAnyIn6:
        ip6 = 1;
        type = XFS_EGR_TNL_INIT_L3_TYPE_L3GRE;
        break;

    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *edit_ctrl_id = 0;
    if (ip6) {
        *edit_ctrl_id |= 1 << XFS_EGR_TNL_INIT_IP_VERSION_OFFSET;
    }
    *edit_ctrl_id |= type << XFS_EGR_TNL_INIT_TYPE_OFFSET;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Tunnel initiator LT edit_ctrl_id field decoder.
 *
 * \param [in] unit Unit number.
 * \param [out] tnl_type Tunnel initiator type.
 * \param [in] edit_ctrl_id LT field.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_tnl_init_edit_ctrl_id_decode(int unit, bcm_tunnel_type_t *tnl_type,
                                 int edit_ctrl_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_type, SHR_E_PARAM);

    if (((edit_ctrl_id >> XFS_EGR_TNL_INIT_LAYER_OFFSET) &
            XFS_EGR_TNL_INIT_LAYER_MASK) == 0) {
        /* L3 tunnels */
        if ((edit_ctrl_id >> XFS_EGR_TNL_INIT_IP_VERSION_OFFSET)
            & XFS_EGR_TNL_INIT_IP_VERSION_MASK) {
            /* IPv6 */
            switch ((edit_ctrl_id >> XFS_EGR_TNL_INIT_TYPE_OFFSET)
                    & XFS_EGR_TNL_INIT_TYPE_MASK) {
            case XFS_EGR_TNL_INIT_L3_TYPE_IPIP:
                *tnl_type = bcmTunnelTypeIpAnyIn6;
                break;

            case XFS_EGR_TNL_INIT_L3_TYPE_L3GRE:
                *tnl_type = bcmTunnelTypeGreAnyIn6;
                break;

            default:
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        } else {
            /* IPv4 */
            switch ((edit_ctrl_id >> XFS_EGR_TNL_INIT_TYPE_OFFSET)
                    & XFS_EGR_TNL_INIT_TYPE_MASK) {
            case XFS_EGR_TNL_INIT_L3_TYPE_IPIP:
                *tnl_type = bcmTunnelTypeIpAnyIn4;
                break;

            case XFS_EGR_TNL_INIT_L3_TYPE_L3GRE:
                *tnl_type = bcmTunnelTypeGreAnyIn4;
                break;

            default:
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash of egr_l3_tunnel_0 and egr_l3_tunnel_1 entries.
 *
 * \param [in] unit Unit number.
 * \param [in] entry Entry info of bcm_tunnel_initiator_t type.
 * \param [out] hash Hash value.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_tunnel_init_hash(int unit, void *entry, uint16_t *hash)
{
    bcm_tunnel_initiator_t tnl_entry;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    /* Copy to local structure. */
    sal_memcpy(&tnl_entry, entry, sizeof(bcm_tunnel_initiator_t));

    /* Ignore flow label for not V6 tunnels or flow label not specified. */
    if (!BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_entry.type) ||
        (tnl_entry.flow_label_sel != bcmTunnelFlowLabelAssign)) {
       tnl_entry.flow_label = 0;
    }

    /* Mask fields we don't want to include in hash. */
    tnl_entry.flags = 0;

    switch (tnl_entry.type) {
    case bcmTunnelTypeIp4In4:
    case bcmTunnelTypeIp6In4:
        tnl_entry.type = bcmTunnelTypeIpAnyIn4;
        break;

    case bcmTunnelTypeIp4In6:
    case bcmTunnelTypeIp6In6:
        tnl_entry.type = bcmTunnelTypeIpAnyIn6;
        break;

    case bcmTunnelTypeGre4In4:
    case bcmTunnelTypeGre6In4:
        tnl_entry.type = bcmTunnelTypeGreAnyIn4;
        break;

    case bcmTunnelTypeGre4In6:
    case bcmTunnelTypeGre6In6:
        tnl_entry.type = bcmTunnelTypeGreAnyIn6;
        break;

    default:
        break;
    }

    *hash = shr_crc16(0, (uint8*)&tnl_entry, sizeof(bcm_tunnel_initiator_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get egr_l3_tunnel_0 and egr_l3_tunnel_1 entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 * \param [out] entry Entry returned of bcm_tunnel_initiator_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_tunnel_init_get(int unit, int index, void *entry)
{
    bcm_tunnel_initiator_t *tnl_init_info = entry;
    bcmlt_entry_handle_t entry_hdl1 = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t entry_hdl2 = BCMLT_INVALID_HDL;
    uint64_t edit_ctrl_id;
    int dunit;
    int ip6;
    uint64_t val[2];
    int seq_num_counter_idx;
    uint32 r_elem_cnt;
    uint32 num;
    uint64_t idx_min, idx_max;
    uint64_t ip_addr;
    const char *fld_desc = NULL;
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, EGR_L3_TUNNEL_0s, EGR_L3_TUNNEL_IDX_0s,
                                       &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_0s, &entry_hdl1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_1s, &entry_hdl2));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, EGR_L3_TUNNEL_IDX_0s, index));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, EGR_L3_TUNNEL_IDX_0s, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl1, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl2, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

     /* Parse LT entry content. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, EDIT_CTRL_IDs, &edit_ctrl_id));
    rv = xfs_tnl_init_edit_ctrl_id_decode(unit, &(tnl_init_info->type),
                                          edit_ctrl_id);
    if (rv != SHR_E_NONE) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    ip6 = BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_init_info->type);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_get(entry_hdl1, IPV6_SRC_ADDRs, 0,
                                     val, 2, &r_elem_cnt));
    if (ip6) {
        bcmi_ltsw_util_uint64_to_ip6(&(tnl_init_info->sip6), val);
    } else {
        /* IPv4 */
        tnl_init_info->sip = val[0] & 0xFFFFFFFF;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, TOS_OR_EXP_REMARK_BASE_PTRs,
                               &val[0]));
    if (val[0] == 0) {
        tnl_init_info->dscp_ecn_sel = bcmTunnelDscpEcnAssign;
    } else {
        tnl_init_info->dscp_ecn_sel = bcmTunnelDscpEcnMap;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_construct(unit, (int)val[0],
                                            bcmiQosMapTypeTnlEcnDscpEgress,
                                            &(tnl_init_info->dscp_ecn_map)));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, IPV6_FLOW_LABEL_SELs,
                               &val[0]));
    if (val[0] == 0) {
        tnl_init_info->flow_label_sel = bcmTunnelFlowLabelAssign;
    } else {
        tnl_init_info->flow_label_sel = bcmTunnelFlowLabelEntropy;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, TTL_VALUEs, &val[0]));
    tnl_init_info->ttl = val[0];

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl1, IP_HDR_DF_CTRLs, &val[0]));
    tnl_init_info->flags |=
        ((val[0] >> XFS_EGR_TNL_INIT_DF_VALUE_IF_PLD_IPV6_OFFSET) & 0x1)
                                ? BCM_TUNNEL_INIT_IPV6_SET_DF : 0;
    tnl_init_info->flags |=
        ((val[0] >> XFS_EGR_TNL_INIT_DF_VALUE_IF_PLD_IPV4_OFFSET) & 0x1)
                                ? BCM_TUNNEL_INIT_IPV4_SET_DF : 0;
    tnl_init_info->flags |=
        ((val[0] >> XFS_EGR_TNL_INIT_INHERIT_DF_IF_PLD_IPV4_OFFSET) & 0x1)
                                ? BCM_TUNNEL_INIT_USE_INNER_DF : 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl2, IPV6_DST_ADDR_LOs, &val[1]));

    if (ip6) {
        bcmi_ltsw_util_uint64_to_ip6_half(&(tnl_init_info->dip6), &val[1], 1);
        rv = bcmlt_field_desc_get(dunit, EGR_L3_TUNNEL_1s,
                                  IPV6_DST_ADDR_HI_1s, &fld_desc);
        if (SHR_SUCCESS(rv)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl2, IPV6_DST_ADDR_HI_0s,
                                       &val[0]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl2, IPV6_DST_ADDR_HI_1s,
                                       &ip_addr));
            val[0] = (ip_addr << 32) | val[0];
            bcmi_ltsw_util_uint64_to_ip6_half(&(tnl_init_info->dip6), &val[0],
                                              0);
        }
        if (rv != SHR_E_NOT_FOUND){
           SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    } else {
        /* IPv4 */
        tnl_init_info->dip = val[1] & 0xFFFFFFFF;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl2, SEQ_NUM_COUNTER_IDXs, &val[0]));
    seq_num_counter_idx = val[0];
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_tunnel_encap_seq_num_get(unit, seq_num_counter_idx, 0,
                                           &num));
    tnl_init_info->ip4_id = num;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl2, TUNNEL_WORD_0s, &val[0]));
    tnl_init_info->flow_label = val[0] & 0xFFFFF;
    tnl_init_info->dscp = (val[0] >> XFS_EGR_TNL_INIT_TNL_HDR_DSCP_OFFSET) & 0x3F;
    tnl_init_info->ecn = (val[0] >> XFS_EGR_TNL_INIT_TNL_HDR_ECN_OFFSET) & 0x3;

exit:
    if (entry_hdl1 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl1);
        entry_hdl1 = BCMLT_INVALID_HDL;
    }
    if (entry_hdl2 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl2);
        entry_hdl2 = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare egr_l3_tunnel_0 and egr_l3_tunnel_1 entries.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of entry to be compared.
 * \param [in] entry Entry content of bcm_tunnel_initiator_t type.
 * \param [out] result 0 if equal, otherwise not equal.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_tunnel_init_cmp(int unit, int index, void *entry, int *result)
{
    bcm_tunnel_initiator_t tnl_init_tmp;
    bcm_tunnel_initiator_t *tnl_entry;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, EGR_L3_TUNNEL_0s, EGR_L3_TUNNEL_IDX_0s,
                                       &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(result, SHR_E_PARAM);

    sal_memset(&tnl_init_tmp, 0, sizeof(bcm_tunnel_initiator_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_tunnel_init_get(unit, index, &tnl_init_tmp));

    tnl_entry = (bcm_tunnel_initiator_t*)entry;

    /* Compare source & destination IP. */
    if (BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_entry->type)) {
        if((sal_memcmp(tnl_entry->dip6, tnl_init_tmp.dip6, sizeof(bcm_ip6_t))) ||
           (sal_memcmp(tnl_entry->sip6, tnl_init_tmp.sip6, sizeof(bcm_ip6_t))) ||
           (tnl_entry->flow_label_sel != tnl_init_tmp.flow_label_sel) ||
           (tnl_entry->flow_label != tnl_init_tmp.flow_label)) {
            *result = BCM_L3_CMP_NOT_EQUAL;
            SHR_EXIT();
        }

        if ((tnl_entry->flags & BCM_TUNNEL_INIT_IPV6_SET_DF) !=
            (tnl_init_tmp.flags & BCM_TUNNEL_INIT_IPV6_SET_DF)) {
            *result = BCM_L3_CMP_NOT_EQUAL;
            SHR_EXIT();
        }
    } else {
        if ((tnl_entry->dip != tnl_init_tmp.dip) ||
            (tnl_entry->sip != tnl_init_tmp.sip)) {
            *result = BCM_L3_CMP_NOT_EQUAL;
            SHR_EXIT();
        }

        if ((tnl_entry->flags & BCM_TUNNEL_INIT_IPV4_SET_DF) !=
            (tnl_init_tmp.flags & BCM_TUNNEL_INIT_IPV4_SET_DF)) {
            *result = BCM_L3_CMP_NOT_EQUAL;
            SHR_EXIT();
        }
    }

    if ((tnl_entry->dscp_ecn_sel != tnl_init_tmp.dscp_ecn_sel) ||
        (tnl_entry->dscp != tnl_init_tmp.dscp) ||
        (tnl_entry->ecn != tnl_init_tmp.ecn)) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    /* Compare tunnel type / ttl */
    /* Tunnel type comparison.                                  */
    /* Note: Only outer header matters in tunnel initialization */
    if (tnl_entry->type != tnl_init_tmp.type) {
        switch (tnl_entry->type) {
        case bcmTunnelTypeIp4In4:
        case bcmTunnelTypeIp6In4:
            if (bcmTunnelTypeIpAnyIn4 != tnl_init_tmp.type) {
                *result = BCM_L3_CMP_NOT_EQUAL;
                SHR_EXIT();
            }
            break;

        case bcmTunnelTypeIp4In6:
        case bcmTunnelTypeIp6In6:
            if (bcmTunnelTypeIpAnyIn6 != tnl_init_tmp.type) {
                *result = BCM_L3_CMP_NOT_EQUAL;
                SHR_EXIT();
            }
            break;

        case bcmTunnelTypeGre4In4:
        case bcmTunnelTypeGre6In4:
        case bcmTunnelTypeGreAnyIn4:
            if (bcmTunnelTypeGreAnyIn4 != tnl_init_tmp.type) {
                *result = BCM_L3_CMP_NOT_EQUAL;
                SHR_EXIT();
            }
            break;

        case bcmTunnelTypeGre4In6:
        case bcmTunnelTypeGre6In6:
        case bcmTunnelTypeGreAnyIn6:
            if (bcmTunnelTypeGreAnyIn6 != tnl_init_tmp.type) {
                *result = BCM_L3_CMP_NOT_EQUAL;
                SHR_EXIT();
            }
            break;

        default:
            *result = BCM_L3_CMP_NOT_EQUAL;
            SHR_EXIT();
        }
    }

    if (tnl_entry->ttl != tnl_init_tmp.ttl) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    /* Compare destination mac. */
    if (sal_memcmp(tnl_entry->dmac, tnl_init_tmp.dmac,
                   sizeof(bcm_mac_t))) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    *result = BCM_L3_CMP_EQUAL;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert egr_l3_tunnel_0 and egr_l3_tunnel_1 entries into LT.
 *
 * \param [in] unit Unit number.
 * \param [in] flags Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index Entry index.
 * \param [in] entry Entry content of bcm_tunnel_initiator_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_tunnel_init_insert(int unit, uint32_t flags, int index, void *entry)
{
    bcm_tunnel_initiator_t *tnl_init_info = entry;
    bcmlt_entry_handle_t entry_hdl1 = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t entry_hdl2 = BCMLT_INVALID_HDL;
    int ip6;
    int dunit;
    int edit_ctrl_id;
    uint64 val[2] = {0};
    int seq_num_profile_idx = -1;
    int seq_num_counter_idx = -1;
    int pipe, pipe_num;
    bcmi_ltsw_tunnel_encap_seq_profile_t profile;
    uint32_t num;
    uint64_t idx_min, idx_max;
    bcmi_ltsw_sbr_profile_tbl_hdl_t pth;
    bcmi_ltsw_sbr_profile_ent_type_t ent_type = BCMI_LTSW_SBR_PET_DEF;
    int sbr_idx;
    int remark_base_ptr;
    const char *fld_desc = NULL;
    bcmi_ltsw_qos_map_type_t qos_type;
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, EGR_L3_TUNNEL_0s, EGR_L3_TUNNEL_IDX_0s,
                                       &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    ip6 = BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_init_info->type);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_0s, &entry_hdl1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_1s, &entry_hdl2));

    /*  Add EGR_L3_TUNNEL_0 fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, EGR_L3_TUNNEL_IDX_0s, index));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_tnl_init_edit_ctrl_id_encode(unit, tnl_init_info->type, &edit_ctrl_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, EDIT_CTRL_IDs, edit_ctrl_id));
    /* IPv6 src addr or IPv4 src addr or MPLS mpls_4..7_label */
    sal_memset(val, 0, sizeof(val));
    if (ip6) {
        bcmi_ltsw_util_ip6_to_uint64(val, &(tnl_init_info->sip6));
    } else {
        /* IPv4 */
        val[0] = tnl_init_info->sip;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl1, IPV6_SRC_ADDRs, 0,
                                     val, 2));

    if (tnl_init_info->dscp_ecn_sel == bcmTunnelDscpEcnMap) {
        /* Get H/W remarking ptr. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_resolve(unit, tnl_init_info->dscp_ecn_map,
                                          &qos_type, &remark_base_ptr));
        if (qos_type != bcmiQosMapTypeTnlEcnDscpEgress) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        if (remark_base_ptr == 0) {
            /* Index 0 is used for QoS pipe mode. */
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl1, TOS_OR_EXP_REMARK_BASE_PTRs,
                                   remark_base_ptr));
    } else if (tnl_init_info->dscp_ecn_sel == bcmTunnelDscpEcnAssign) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl1, TOS_OR_EXP_REMARK_BASE_PTRs, 0));
    } else {
        /* NPL currently not supported. */
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (ip6) {
        if ((tnl_init_info->flow_label_sel == bcmTunnelFlowLabelAssign) ||
            (tnl_init_info->flow_label_sel == bcmTunnelFlowLabelEntropy)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl1, IPV6_FLOW_LABEL_SELs,
                                       tnl_init_info->flow_label_sel));
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, TTL_VALUEs, tnl_init_info->ttl));
    if (tnl_init_info->ttl == 0) {
        /* Use payload TTL. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl1, TTL_OR_MPLS_CTRLs, 1));
    } else {
        /* Use configured TTL. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl1, TTL_OR_MPLS_CTRLs, 0));
    }

    val[0] = 0;
    if (!ip6) {
        if (tnl_init_info->flags & BCM_TUNNEL_INIT_USE_INNER_DF) {
            val[0] |= 1 << XFS_EGR_TNL_INIT_INHERIT_DF_IF_PLD_IPV4_OFFSET;
        } else if (tnl_init_info->flags & BCM_TUNNEL_INIT_IPV4_SET_DF) {
            val[0] |= 1 << XFS_EGR_TNL_INIT_DF_VALUE_IF_PLD_IPV4_OFFSET;
        }

        if (tnl_init_info->flags & BCM_TUNNEL_INIT_IPV6_SET_DF) {
            val[0] |= 1 << XFS_EGR_TNL_INIT_DF_VALUE_IF_PLD_IPV6_OFFSET;
        }
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, IP_HDR_DF_CTRLs, val[0]));

    val[0] = 0;
    if (tnl_init_info->type == bcmTunnelTypeVxlan) {
        /* UDP */
        val[0] |= 0x11 << XFS_EGR_TNL_INIT_L3_PROTOCOL_OFFSET;
    } else if ((tnl_init_info->type == bcmTunnelTypeGre4In4) ||
               (tnl_init_info->type == bcmTunnelTypeGre6In4) ||
               (tnl_init_info->type == bcmTunnelTypeGreAnyIn4) ||
               (tnl_init_info->type == bcmTunnelTypeGreAnyIn6) ||
               (tnl_init_info->type == bcmTunnelTypeGre4In6) ||
               (tnl_init_info->type == bcmTunnelTypeGre6In6)) {
        /* GRE */
        val[0] |= 0x2F << XFS_EGR_TNL_INIT_L3_PROTOCOL_OFFSET;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, TUNNEL_WORD_1s, val[0]));

    rv = bcmlt_field_desc_get(dunit, EGR_L3_TUNNEL_0s, STRENGTH_PRFL_IDXs,
                              &fld_desc);
    if (SHR_SUCCESS(rv)) {
        pth = BCMI_LTSW_SBR_PTH_EGR_L3_TNL_0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type, &sbr_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl1, STRENGTH_PRFL_IDXs, sbr_idx));
    }
    if (rv != SHR_E_NOT_FOUND){
       SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    /* Add EGR_L3_TUNNEL_1 fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, EGR_L3_TUNNEL_IDX_0s, index));
    sal_memset(val, 0, sizeof(val));
    /* IPv6 dst addr or IPv4 dst addr or MPLS 0..3 label */
    if (ip6) {
        bcmi_ltsw_util_ip6_half_to_uint64(&val[0], &(tnl_init_info->dip6), 0);
        bcmi_ltsw_util_ip6_half_to_uint64(&val[1], &(tnl_init_info->dip6), 1);
    } else {
        /* IPv4 */
        val[1] = tnl_init_info->dip;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, IPV6_DST_ADDR_LOs, val[1]));

    rv = bcmlt_field_desc_get(dunit, EGR_L3_TUNNEL_1s,
                              IPV6_DST_ADDR_HI_1s, &fld_desc);
    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl2, IPV6_DST_ADDR_HI_0s,
                                   val[0] & 0xFFFFFFFF));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl2, IPV6_DST_ADDR_HI_1s,
                                   (val[0] >> 32) & 0xFFFFFFFF));
    }
    if (rv != SHR_E_NOT_FOUND){
       SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_tunnel_encap_seq_num_alloc(unit, 0, ENCAP_SEQ_NUM_TYPE_TNL,
                                              &seq_num_counter_idx));
    if (tnl_init_info->flags & BCM_TUNNEL_INIT_IP4_ID_SET_FIXED) {
        num = tnl_init_info->ip4_id;
    } else if (tnl_init_info->flags & BCM_TUNNEL_INIT_IP4_ID_SET_RANDOM) {
        num = (uint16) (sal_time_usecs() & 0xFFFF);
    } else {
        /* Default is random. */
        num = (uint16) (sal_time_usecs() & 0xFFFF);
    }
    pipe_num = bcmi_ltsw_dev_max_pp_pipe_num(unit);
    for (pipe = 0; pipe < pipe_num; pipe++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_tunnel_encap_seq_num_set(unit, seq_num_counter_idx,
                                                pipe, num));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, SEQ_NUM_COUNTER_IDXs,
                               seq_num_counter_idx));

    sal_memset(&profile, 0, sizeof(profile));
    profile.enable = 1;
    profile.update_en = 1;
    profile.increment = 1;
    /* reserved_val is configured as a value larger than 0xFFFF thus never matched. */
    profile.reserved_value = 0xFFFF0000;
    /* IPv4 header only uses 16-bit ID (i.e. 0~0xFFFF)*/
    profile.mask = 0xFFFF0000;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_tunnel_encap_seq_profile_add(unit, &profile,
                                                &seq_num_profile_idx));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, SEQ_NUM_PROFILE_IDXs,
                               seq_num_profile_idx));

    val[0] = 0;
    if (ip6) {
        if (tnl_init_info->flow_label_sel == bcmTunnelFlowLabelAssign) {
            val[0] |= tnl_init_info->flow_label & 0xFFFFF;
        }
    }
    if (tnl_init_info->dscp_ecn_sel == bcmTunnelDscpEcnAssign) {
        val[0] |= (tnl_init_info->dscp & 0x3f) <<
                  XFS_EGR_TNL_INIT_TNL_HDR_DSCP_OFFSET;
        val[0] |= (tnl_init_info->ecn & 0x3) <<
                  XFS_EGR_TNL_INIT_TNL_HDR_ECN_OFFSET;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, TUNNEL_WORD_0s, val[0]));

    pth = BCMI_LTSW_SBR_PTH_EGR_L3_TNL;
    ent_type = BCMI_LTSW_SBR_PET_NO_TNL_WORD_2;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type, &sbr_idx));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, STRENGTH_PRFL_IDXs, sbr_idx));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl1, BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl2, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl1 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl1);
        entry_hdl1 = BCMLT_INVALID_HDL;
    }
    if (entry_hdl2 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl2);
        entry_hdl2 = BCMLT_INVALID_HDL;
    }
    if (SHR_FUNC_ERR()) {
        if (seq_num_counter_idx != -1) {
            (void)bcmi_ltsw_tunnel_encap_seq_num_free(unit,
                                                      ENCAP_SEQ_NUM_TYPE_TNL,
                                                      seq_num_counter_idx);
        }
        if (seq_num_profile_idx != -1)  {
            (void)bcmi_ltsw_tunnel_encap_seq_profile_delete(unit,
                                                      seq_num_profile_idx);
        }
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete egr_l3_tunnel_0 and egr_l3_tunnel_1 entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_tunnel_init_del(int unit, int index)
{
    bcmlt_entry_handle_t entry_hdl1 = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t entry_hdl2 = BCMLT_INVALID_HDL;
    uint64_t data;
    int dunit = 0;
    int profile_idx;
    int seq_num_counter_idx;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, EGR_L3_TUNNEL_0s, EGR_L3_TUNNEL_IDX_0s,
                                       &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_0s, &entry_hdl1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl1, EGR_L3_TUNNEL_IDX_0s, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_1s, &entry_hdl2));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl2, EGR_L3_TUNNEL_IDX_0s, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl2,
                              BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl2, SEQ_NUM_PROFILE_IDXs, &data));
    profile_idx = (int)data;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_tunnel_encap_seq_profile_delete(unit, profile_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl2, SEQ_NUM_PROFILE_IDXs, &data));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl2, SEQ_NUM_COUNTER_IDXs, &data));
    seq_num_counter_idx = (int)data;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_tunnel_encap_seq_num_free(unit, ENCAP_SEQ_NUM_TYPE_TNL,
                                             seq_num_counter_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl1,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl2,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl1 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl1);
        entry_hdl1 = BCMLT_INVALID_HDL;
    }
    if (entry_hdl2 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl2);
        entry_hdl2 = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover index table mgmt bookkeepings for tunnel initiator.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_tunnel_init_recover(int unit, int index)
{
    bcm_tunnel_initiator_t tnl_init_info;
    uint32 ref_cnt;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_get(unit,
                                         BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                         BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                                         index, &ref_cnt));
    if (ref_cnt == 0) {
        bcm_gport_t tunnel_id;
        BCMI_LTSW_GPORT_TUNNEL_ID_SET(tunnel_id, bcmiTunnelTypeIpL3, index);
        bcm_tunnel_initiator_t_init(&tnl_init_info);
        SHR_IF_ERR_VERBOSE_EXIT
            (mbcm_ltsw_tunnel_initiator_get(unit, NULL, tunnel_id,
                                            &tnl_init_info));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_hash_update(unit,
                                                 BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                                 BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                                                 &tnl_init_info, index));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_increase(unit,
                                              BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                              BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                                              index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set tunnel terminator H/W protocol type.
 *
 * \param [in] unit Unit number.
 * \param [in] tnl_term_info Tunnel terminator information.
 * \param [out] tnl_type Tunnel type.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_tunnel_term_type_set(int unit, bcm_tunnel_terminator_t *tnl_term_info,
                              xfs_ltsw_tnl_term_type_t *tnl_type)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);
    SHR_NULL_CHECK(tnl_type, SHR_E_PARAM);

    sal_memset(tnl_type, 0, sizeof(*tnl_type));

    tnl_type->tnl_outer_hdr_ipv6 =
        BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_term_info->type);

    switch (tnl_term_info->type) {
    case bcmTunnelTypeIp4In4:
    case bcmTunnelTypeIp4In6:
        /* IP in IP */
        tnl_type->tnl_protocol = XFS_TNL_PAYLOAD_PROTOCOL_IP4;
        break;

    case bcmTunnelTypeIp6In4:
    case bcmTunnelTypeIp6In6:
        /* IPv6 */
        tnl_type->tnl_protocol = XFS_TNL_PAYLOAD_PROTOCOL_IP6;
        break;

    case bcmTunnelTypeIpAnyIn4:
    case bcmTunnelTypeIpAnyIn6:
        /* IP in IP */
        tnl_type->tnl_protocol = XFS_TNL_PAYLOAD_PROTOCOL_IP4;
        break;

    case bcmTunnelTypeGreAnyIn4:
    case bcmTunnelTypeGreAnyIn6:
        /* Protocol GRE */
        tnl_type->tnl_protocol = XFS_TNL_PAYLOAD_PROTOCOL_GRE;
        break;

    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get tunnel terminator API layer protocol type.
 *
 * \param [in] unit Unit number.
 * \param [in] tnl_term_info Tunnel terminator information.
 * \param [in/out] tnl_type Tunnel type.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_tunnel_term_type_get(int unit, bcm_tunnel_terminator_t *tnl_term_info,
                              xfs_ltsw_tnl_term_type_t *tnl_type)
{
    /* Outer header is ipv6. */
    int v6;

    /* Input parameters check. */
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);
    SHR_NULL_CHECK(tnl_type, SHR_E_PARAM);

    /* Read outer header IP version. */
    v6 = tnl_type->tnl_outer_hdr_ipv6;

    switch (tnl_type->tnl_protocol) {
    case 0x0:
        tnl_term_info->type = (v6) ? bcmTunnelTypeIpAnyIn6 :
                                     bcmTunnelTypeIpAnyIn4;
        break;

    case XFS_TNL_PAYLOAD_PROTOCOL_IP4:
        tnl_term_info->type = (v6) ? bcmTunnelTypeIp4In6 :
                                     bcmTunnelTypeIp4In4;
        break;

    case XFS_TNL_PAYLOAD_PROTOCOL_IP6:
        tnl_term_info->type = (v6) ? bcmTunnelTypeIp6In6 :
                                     bcmTunnelTypeIp6In4;
        break;

    case XFS_TNL_PAYLOAD_PROTOCOL_GRE:
        tnl_term_info->type = (v6) ? bcmTunnelTypeGreAnyIn6 :
                                     bcmTunnelTypeGreAnyIn4;
        break;

    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct tunnel terminator LT field with given fields.
 *
 * \param [in] unit Unit number.
 * \param [in] tnl_term_info Tunnel terminator info.
 * \param [in] entry_hdl LT entry handler.
 * \param [in] key Construct key or not.
 * \param [in] data Construct data or not.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_tunnel_term_entry_init(int unit,
                                bcm_tunnel_terminator_t *tnl_term_info,
                                bcmlt_entry_handle_t entry_hdl,
                                bool key, bool data)
{
    xfs_ltsw_tnl_term_type_t tnl_type;
    uint64_t sip_data[2];
    uint64_t sip_mask[2];
    uint64_t dip_data[2];
    uint64_t dip_mask[2];
    uint64_t tmp_val;
    bcmi_ltsw_sbr_fld_type_t fld_type = BCMI_LTSW_SBR_FT_L3_IIF;
    bcmi_ltsw_sbr_tbl_hdl_t th;
    int stren;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_tunnel_term_type_set(unit, tnl_term_info, &tnl_type));

    if (key) {
        if (tnl_type.tnl_outer_hdr_ipv6) {
            /* IPv6 */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_mask6_apply(tnl_term_info->sip6_mask,
                                          tnl_term_info->sip6));
            bcmi_ltsw_util_ip6_to_uint64(sip_data, &(tnl_term_info->sip6));
            bcmi_ltsw_util_ip6_to_uint64(sip_mask,
                                         &(tnl_term_info->sip6_mask));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_mask6_apply(tnl_term_info->dip6_mask,
                                          tnl_term_info->dip6));
            bcmi_ltsw_util_ip6_to_uint64(dip_data, &(tnl_term_info->dip6));
            bcmi_ltsw_util_ip6_to_uint64(dip_mask,
                                         &(tnl_term_info->dip6_mask));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(entry_hdl, IP_HDR_SIPs, 0,
                                             sip_data, 2));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(entry_hdl, IP_HDR_SIP_MASKs, 0,
                                             sip_mask, 2));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(entry_hdl, IP_HDR_DIPs, 0,
                                             dip_data, 2));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(entry_hdl, IP_HDR_DIP_MASKs, 0,
                                             dip_mask, 2));
        } else {
            /* IPv4 */
            tnl_term_info->sip &= tnl_term_info->sip_mask;
            sip_data[1] = tnl_term_info->sip;
            sip_mask[1] = tnl_term_info->sip_mask;

            dip_data[1] = tnl_term_info->dip;
            dip_mask[1] = tnl_term_info->dip_mask;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_HDR_SIPs, sip_data[1]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_HDR_SIP_MASKs, sip_mask[1]));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_HDR_DIPs, dip_data[1]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_HDR_DIP_MASKs, dip_mask[1]));
        }


        if (tnl_term_info->type == bcmTunnelTypeIpAnyIn4 ||
            tnl_term_info->type == bcmTunnelTypeIpAnyIn6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_HDR_PROTOCOLs, 0x0));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_HDR_PROTOCOL_MASKs, 0x0));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_HDR_PROTOCOLs,
                                       tnl_type.tnl_protocol));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_HDR_PROTOCOL_MASKs, 0xFF));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, L4_SRC_PORTs, 0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, L4_SRC_PORT_MASKs, 0x0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, L4_DST_PORTs, 0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, L4_DST_PORT_MASKs, 0x0));
    }

    if (data) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ENTRY_VALIDs, 1));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ENTRY_PRIORITYs,
                                   XFS_TNL_DFL_PRIORITY));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, L3_IIFs, tnl_term_info->vlan));
        if (tnl_type.tnl_outer_hdr_ipv6) {
            th = BCMI_LTSW_SBR_TH_L3_IPV6_TUNNEL_TABLE;
        } else {
            th = BCMI_LTSW_SBR_TH_L3_IPV4_TUNNEL_TABLE;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_sbr_fld_value_get(unit, th, fld_type, &stren));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, L3_IIF_STRENGTHs, (uint64_t)stren));

        tmp_val = tnl_term_info->flags & BCM_TUNNEL_TERM_USE_OUTER_DSCP ? 1 : 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, USE_OUTER_HEADER_PHBs, tmp_val));

        tmp_val = tnl_term_info->flags & BCM_TUNNEL_TERM_USE_OUTER_TTL ? 1 : 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, USE_OUTER_HDR_TTLs, tmp_val));

    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse tunnel terminator LT field.
 *
 * \param [in] unit Unit number.
 * \param [out] tnl_term_info Tunnel terminator info.
 * \param [in] entry_hdl LT entry handler.
 * \param [in] ip6 IPv6 entry or not.
 * \param [in] key Parse key or not.
 * \param [in] data Parse data or not.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_tunnel_term_entry_parse(int unit,
                                 bcm_tunnel_terminator_t *tnl_term_info,
                                 bcmlt_entry_handle_t entry_hdl, bool ip6,
                                 bool key_parse, bool data_parse)
{
    xfs_ltsw_tnl_term_type_t tnl_type;
    uint64_t sip_data[2];
    uint64_t sip_mask[2];
    uint64_t dip_data[2];
    uint64_t dip_mask[2];
    uint64_t tmp_val;
    uint32_t elem_cnt;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    if (key_parse) {
        if (ip6) {
            /* IPv6 */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(entry_hdl, IP_HDR_SIPs, 0, sip_data,
                                             2, &elem_cnt));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(entry_hdl, IP_HDR_SIP_MASKs, 0,
                                            sip_mask, 2, &elem_cnt));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(entry_hdl, IP_HDR_DIPs, 0, dip_data,
                                             2, &elem_cnt));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(entry_hdl, IP_HDR_DIP_MASKs, 0,
                                            dip_mask, 2, &elem_cnt));

            bcmi_ltsw_util_uint64_to_ip6(&(tnl_term_info->sip6), sip_data);
            bcmi_ltsw_util_uint64_to_ip6(&(tnl_term_info->sip6_mask), sip_mask);

            bcmi_ltsw_util_uint64_to_ip6(&(tnl_term_info->dip6), dip_data);
            bcmi_ltsw_util_uint64_to_ip6(&(tnl_term_info->dip6_mask), dip_mask);
        } else {
            /* IPv4 */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, IP_HDR_SIPs, &sip_data[1]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, IP_HDR_SIP_MASKs, &sip_mask[1]));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, IP_HDR_DIPs, &dip_data[1]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, IP_HDR_DIP_MASKs, &dip_mask[1]));

            tnl_term_info->sip = sip_data[1];
            tnl_term_info->sip_mask = sip_mask[1];

            tnl_term_info->dip = dip_data[1];
            tnl_term_info->dip_mask = dip_mask[1];
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, IP_HDR_PROTOCOLs,
                                   &tmp_val));
        tnl_type.tnl_protocol = tmp_val;
        tnl_type.tnl_outer_hdr_ipv6 = ip6;
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_term_type_get(unit, tnl_term_info, &tnl_type));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L4_SRC_PORTs, &tmp_val));
        tnl_term_info->udp_src_port = tmp_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L4_SRC_PORT_MASKs, &tmp_val));
        tnl_term_info->udp_src_port &= tmp_val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L4_DST_PORTs, &tmp_val));
        tnl_term_info->udp_dst_port = tmp_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L4_DST_PORT_MASKs, &tmp_val));
        tnl_term_info->udp_dst_port &= tmp_val;
    }

    if (data_parse) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L3_IIFs, &tmp_val));
        tnl_term_info->vlan = tmp_val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, USE_OUTER_HEADER_PHBs, &tmp_val));
        if (tmp_val) {
            tnl_term_info->flags |= BCM_TUNNEL_TERM_USE_OUTER_DSCP;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, USE_OUTER_HDR_TTLs, &tmp_val));
        if (tmp_val) {
            tnl_term_info->flags |= BCM_TUNNEL_TERM_USE_OUTER_TTL;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize tunnel initiator table.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_tunnel_initiator_init(
    int unit)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmi_ltsw_sbr_profile_tbl_hdl_t pth = BCMI_LTSW_SBR_PTH_EGR_L3_TNL;
    bcmi_ltsw_sbr_profile_ent_type_t ent_type = BCMI_LTSW_SBR_PET_NONE;
    int sbr_idx;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (XFS_TNL_INFO_TNL_INIT_CAP(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_sbr_profile_ent_index_get(unit, pth, ent_type,
                                                 &sbr_idx));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_1s, &entry_hdl));
        /* SBR profile for tunnel initiator 0 should be NULL. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, EGR_L3_TUNNEL_IDX_0s, 0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, STRENGTH_PRFL_IDXs, sbr_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize tunnel terminator tables.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_tunnel_terminator_init(
    int unit)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    bcm_tunnel_terminator_t tnl_term_info;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /*
     * In DNA, some of the containers holding TCAM LTs' output are invalid if
     * table lookup miss, resulting in misinterpreting of these signals in
     * following processing. Thus we need to add dummy entries at the end of
     * these LTs to make sure these containers are always initalized properly
     * before use.
     */

    if (XFS_TNL_INFO_V4_TNL_TERM_CAP(unit)) {
        bcm_tunnel_terminator_t_init(&tnl_term_info);
        /* Both key and data are zeros. */
        tnl_term_info.type = bcmTunnelTypeIpAnyIn4;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, L3_IPV4_TUNNEL_TABLEs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_term_entry_init(unit, &tnl_term_info, entry_hdl,
                                             TRUE, FALSE));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ENTRY_PRIORITYs, 0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_free(entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    if (XFS_TNL_INFO_V6_TNL_TERM_CAP(unit)) {
        bcm_tunnel_terminator_t_init(&tnl_term_info);
        /* Both key and data are zeros. */
        tnl_term_info.type = bcmTunnelTypeIpAnyIn6;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, L3_IPV6_TUNNEL_TABLEs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_term_entry_init(unit, &tnl_term_info, entry_hdl,
                                             TRUE, FALSE));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ENTRY_PRIORITYs, 0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_free(entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct tunnel terminator EM LT field with given fields.
 *
 * \param [in] unit Unit number.
 * \param [in] tnl_term_info Tunnel terminator info.
 * \param [in] entry_hdl LT entry handler.
 * \param [in] key Construct key or not.
 * \param [in] data Construct data or not.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_tunnel_term_em_entry_init(int unit,
                                   bcm_tunnel_terminator_t *tnl_term_info,
                                   bcmlt_entry_handle_t entry_hdl,
                                   bool key, bool data)
{
    xfs_ltsw_tnl_term_type_t tnl_type;
    uint64_t sip_data[2];
    uint64_t dip_data[2];
    uint64_t tmp_val;
    bcmi_ltsw_sbr_fld_type_t fld_type = BCMI_LTSW_SBR_FT_L3_IIF;
    bcmi_ltsw_sbr_tbl_hdl_t th;
    int stren;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    if (tnl_term_info->type == bcmTunnelTypeIpAnyIn4) {
        tnl_type.tnl_outer_hdr_ipv6 = 0;
    } else if (tnl_term_info->type == bcmTunnelTypeIpAnyIn6) {
        tnl_type.tnl_outer_hdr_ipv6 = 1;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (key) {
        if (tnl_type.tnl_outer_hdr_ipv6) {
            /* IPv6 */
            bcmi_ltsw_util_ip6_to_uint64(sip_data, &(tnl_term_info->sip6));
            bcmi_ltsw_util_ip6_to_uint64(dip_data, &(tnl_term_info->dip6));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(entry_hdl, IP_HDR_SIPs, 0,
                                             sip_data, 2));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(entry_hdl, IP_HDR_DIPs, 0,
                                             dip_data, 2));
        } else {
            /* IPv4 */
            sip_data[1] = tnl_term_info->sip;
            dip_data[1] = tnl_term_info->dip;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_HDR_SIPs, sip_data[1]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_HDR_DIPs, dip_data[1]));
        }
    }

    if (data) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ENTRY_VALIDs, 1));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, L3_IIFs, tnl_term_info->vlan));
        if (tnl_type.tnl_outer_hdr_ipv6) {
            th = BCMI_LTSW_SBR_TH_L3_IPV6_TUNNEL_TABLE;
        } else {
            th = BCMI_LTSW_SBR_TH_L3_IPV4_TUNNEL_TABLE;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_sbr_fld_value_get(unit, th, fld_type, &stren));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, L3_IIF_STRENGTHs, (uint64_t)stren));

        tmp_val = tnl_term_info->flags & BCM_TUNNEL_TERM_USE_OUTER_DSCP ? 1 : 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, USE_OUTER_HEADER_PHBs, tmp_val));

        tmp_val = tnl_term_info->flags & BCM_TUNNEL_TERM_USE_OUTER_TTL ? 1 : 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, USE_OUTER_HDR_TTLs, tmp_val));

    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse tunnel terminator EM LT field.
 *
 * \param [in] unit Unit number.
 * \param [out] tnl_term_info Tunnel terminator info.
 * \param [in] entry_hdl LT entry handler.
 * \param [in] ip6 IPv6 entry or not.
 * \param [in] key Parse key or not.
 * \param [in] data Parse data or not.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
ltsw_xfs_tunnel_term_em_entry_parse(int unit,
                                    bcm_tunnel_terminator_t *tnl_term_info,
                                    bcmlt_entry_handle_t entry_hdl, bool ip6,
                                    bool key_parse, bool data_parse)
{
    uint64_t sip_data[2];
    uint64_t dip_data[2];
    uint64_t tmp_val;
    uint32_t elem_cnt;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    if (key_parse) {
        if (ip6) {
            /* IPv6 */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(entry_hdl, IP_HDR_SIPs, 0, sip_data,
                                             2, &elem_cnt));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(entry_hdl, IP_HDR_DIPs, 0, dip_data,
                                             2, &elem_cnt));
            bcmi_ltsw_util_uint64_to_ip6(&(tnl_term_info->sip6), sip_data);
            bcmi_ltsw_util_uint64_to_ip6(&(tnl_term_info->dip6), dip_data);
        } else {
            /* IPv4 */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, IP_HDR_SIPs, &sip_data[1]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, IP_HDR_DIPs, &dip_data[1]));
            tnl_term_info->sip = sip_data[1];
            tnl_term_info->dip = dip_data[1];
        }

        if (ip6) {
           tnl_term_info->type = bcmTunnelTypeIpAnyIn6;
        } else  {
           tnl_term_info->type = bcmTunnelTypeIpAnyIn4;
        }
    }

    if (data_parse) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L3_IIFs, &tmp_val));
        tnl_term_info->vlan = tmp_val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, USE_OUTER_HEADER_PHBs, &tmp_val));
        if (tmp_val) {
            tnl_term_info->flags |= BCM_TUNNEL_TERM_USE_OUTER_DSCP;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, USE_OUTER_HDR_TTLs, &tmp_val));
        if (tmp_val) {
            tnl_term_info->flags |= BCM_TUNNEL_TERM_USE_OUTER_TTL;
        }
    }

    tnl_term_info->flags |= BCM_TUNNEL_TERM_EM;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Hash callback function for tunnel encap sequence profile.
 *
 * \param [in] unit Unit number.
 * \param [in] entries Tunnel encap sequence profile entry.
 * \param [in] entries_per_set Number of entries per set.
 * \param [out] hash Hash value returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_tunnel_encap_seq_profile_entry_hash_cb(
    int unit,
    void *entries,
    int entries_per_set,
    uint32_t *hash)
{
    SHR_FUNC_ENTER(unit);

    if (entries_per_set != 1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    *hash = shr_crc32(0, entries,
                      entries_per_set * sizeof(bcmi_ltsw_tunnel_encap_seq_profile_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve a tunnel encap sequence profile.
 *
 * \param [in] unit Unit number.
 * \param [in] idx Index.
 * \param [out] prof_entry Profile entry returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_tunnel_encap_seq_profile_entry_get(
    int unit,
    int idx,
    bcmi_ltsw_tunnel_encap_seq_profile_t *prof_entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_ENCAP_SEQUENCE_PROFILEs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_ENCAP_SEQUENCE_PROFILE_IDs, idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, SEQUENCEs, &data));
    prof_entry->enable = (bool) data;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, SEQUENCE_UPDATEs, &data));
    prof_entry->update_en = (bool) data;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, INCREMENTs, &data));
    prof_entry->increment = (uint32_t) data;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, RESERVED_VALUEs, &data));
    prof_entry->reserved_value = (uint32_t) data;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, MASKs, &data));
    prof_entry->mask = (uint32_t) data;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Comparison callback function for tunnel encap sequence profile.
 *
 * \param [in] unit Unit number.
 * \param [in] entries Tunnel encap sequence profile entry.
 * \param [in] entries_per_set Number of entries per set.
 * \param [index] Index of LT entry.
 * \param [out] cmp_result Comparison result.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_tunnel_encap_seq_profile_entry_cmp_cb(
    int unit,
    void *entries,
    int entries_per_set,
    int index,
    int *cmp_result)
{
    bcmi_ltsw_tunnel_encap_seq_profile_t prof_entry;

    SHR_FUNC_ENTER(unit);

    if (entries_per_set != 1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(cmp_result, SHR_E_PARAM);

    sal_memset(&prof_entry, 0, sizeof(prof_entry));
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_tunnel_encap_seq_profile_entry_get(unit, index, &prof_entry));

    *cmp_result = sal_memcmp(entries, &prof_entry, sizeof(prof_entry));

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Set a tunnel encap sequence profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] idx Index.
 * \param [out] prof_entry Profile entry returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_tunnel_encap_seq_profile_entry_set(
    int unit,
    int idx,
    bcmi_ltsw_tunnel_encap_seq_profile_t *prof_entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_ENCAP_SEQUENCE_PROFILEs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_ENCAP_SEQUENCE_PROFILE_IDs, idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, SEQUENCEs, prof_entry->enable));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, SEQUENCE_UPDATEs, prof_entry->update_en));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INCREMENTs, prof_entry->increment));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, RESERVED_VALUEs,
                               prof_entry->reserved_value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MASKs, prof_entry->mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete a tunnel encap sequence profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] idx Index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xfs_tunnel_encap_seq_profile_entry_del(
    int unit,
    int idx)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_ENCAP_SEQUENCE_PROFILEs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_ENCAP_SEQUENCE_PROFILE_IDs, idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int xfs_tunnel_encap_seq_num_init(int unit)
{
    uint64_t idx_min, idx_max;
    uint32_t ha_req_size, ha_alloc_size, seq_num_bmp_size;
    void *ha_ptr = NULL;
    void *ha_base_ptr = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_ENCAP_SEQUENCE_NUMBERs,
                                       TNL_ENCAP_SEQUENCE_NUMBER_IDs,
                                       &idx_min, &idx_max));
    /* Index 0 reserved. */
    xfs_tnl_encap_seq_info[unit].idx_min = (idx_min == 0) ? 1 : idx_min;
    xfs_tnl_encap_seq_info[unit].idx_max = idx_max;

    seq_num_bmp_size = SHR_BITALLOCSIZE(idx_max + 1);
    ha_req_size = 4 * seq_num_bmp_size;
    ha_alloc_size = ha_req_size;
    ha_base_ptr = bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_SEQ_NUM, 0,
                                         "bcmTnlEncapSeqNum", &ha_alloc_size);
    SHR_NULL_CHECK(ha_base_ptr, SHR_E_MEMORY);
    if (ha_alloc_size < ha_req_size) {
        SHR_ERR_EXIT(SHR_E_MEMORY);
    }

    ha_ptr = ha_base_ptr;
    XFS_SEQ_INFO(unit).seq_num_bmp = ha_ptr;
    ha_ptr += seq_num_bmp_size;
    XFS_SEQ_INFO(unit).tnl_seq_num_bmp = ha_ptr;
    ha_ptr += seq_num_bmp_size;
    XFS_SEQ_INFO(unit).vp_seq_num_bmp = ha_ptr;
    ha_ptr += seq_num_bmp_size;
    XFS_SEQ_INFO(unit).mirror_seq_num_bmp = ha_ptr;
    /* Point to the end of this HA. */
    ha_ptr += seq_num_bmp_size;

    if (!bcmi_warmboot_get(unit)) {
        sal_memset(ha_base_ptr, 0, ha_alloc_size);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_ENCAP_SEQUENCE_NUMBERs));
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (!bcmi_warmboot_get(unit) && (ha_base_ptr != NULL)) {
            bcmi_ltsw_ha_mem_free(unit, ha_base_ptr);
        }
    }

    SHR_FUNC_EXIT();
}

int xfs_tunnel_encap_seq_num_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (!bcmi_warmboot_get(unit)) {
        if (XFS_SEQ_INFO(unit).seq_num_bmp != NULL) {
            /* seq_num_bmp points to the starting HA address. */
            bcmi_ltsw_ha_mem_free(unit, XFS_SEQ_INFO(unit).seq_num_bmp);
            XFS_SEQ_INFO(unit).seq_num_bmp = NULL;
        }
    }

    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_tunnel_init(int unit)
{
    int warmboot; /* during warmboot */
    uint64_t idx_min, idx_max;
    bcmi_ltsw_idx_tbl_user_info_t user_info;
    bcmi_ltsw_idx_tbl_lt_info_t lt_info;
    int idx;
    int rv;
    uint32_t cap;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, L3_IPV4_TUNNEL_TABLEs, &cap));
    xfs_ltsw_tnl_info[unit].ipv4_tunnel_term_cap = cap;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, L3_IPV6_TUNNEL_TABLEs, &cap));
    xfs_ltsw_tnl_info[unit].ipv6_tunnel_term_cap = cap;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, EGR_L3_TUNNEL_0s, &cap));
    xfs_ltsw_tnl_info[unit].tunnel_init_cap = cap;

    warmboot = bcmi_warmboot_get(unit);

    if (!warmboot) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_terminator_init(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_initiator_init(unit));
    }

    if (XFS_TNL_INFO_TNL_INIT_CAP(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, EGR_L3_TUNNEL_0s,
                                           EGR_L3_TUNNEL_IDX_0s,
                                           &idx_min, &idx_max));
        sal_memset(&lt_info, 0, sizeof(lt_info));
        /* Max number of users of this LT. */
        lt_info.user_cnt  = BCMI_EGR_L3_TNL_USER_ID_CNT;
        lt_info.tbl_name  = EGR_L3_TUNNEL_0s;
        lt_info.idx_field = EGR_L3_TUNNEL_IDX_0s;

        sal_memset(&user_info, 0, sizeof(user_info));
        user_info.valid       = 1;
        user_info.idx_min     = (uint32_t)idx_min;
        user_info.idx_max     = (uint32_t)idx_max;
        user_info.func_hash   = ltsw_xfs_tunnel_init_hash;
        user_info.func_cmp    = ltsw_xfs_tunnel_init_cmp;
        user_info.func_insert = ltsw_xfs_tunnel_init_insert;
        user_info.func_del    = ltsw_xfs_tunnel_init_del;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_register(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                        BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                                        &lt_info, &user_info));

        /* Recover tunnel initiator s/w status. */
        if (warmboot) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_field_value_range_get(unit, EGR_L3_TUNNEL_0s,
                                               EGR_L3_TUNNEL_IDX_0s,
                                               &idx_min, &idx_max));

            for (idx = idx_min; idx <= idx_max; idx++) {
                if (idx == 0) {
                    /* No tunnel configured. */
                    continue;
                }

                rv = xfs_tunnel_init_recover(unit, idx);
                if (SHR_FAILURE(rv)) {
                    if (rv != SHR_E_NOT_FOUND) {
                        SHR_IF_ERR_VERBOSE_EXIT(rv);
                    }
                    continue;
                }
            }
        }
    }

exit:
    if (SHR_FUNC_ERR()) {
        SHR_IF_ERR_CONT
            (xfs_ltsw_tunnel_free_resource(unit));
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_free_resource(int unit)
{
    int rv;
    int warmboot;

    SHR_FUNC_ENTER(unit);

    warmboot = bcmi_warmboot_get(unit);
    /* Do not clear LT entries when "exit clean". */
    if (!warmboot) {
        /* Reset all LTs */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, L3_IPV4_TUNNEL_TABLEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, L3_IPV6_TUNNEL_TABLEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, L3_IPV4_TUNNEL_EM_TABLEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, L3_IPV6_TUNNEL_EM_TABLEs));

        if (XFS_TNL_INFO_TNL_INIT_CAP(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_clear(unit, EGR_L3_TUNNEL_0s));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_clear(unit, EGR_L3_TUNNEL_1s));
        }
    }

    rv = bcmi_ltsw_idx_tbl_unregister(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                      -1);
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_initiator_create(
    int unit,
    uint32_t flags,
    bcm_tunnel_initiator_t *tnl_info)
{
    int index;
    bcmi_ltsw_tunnel_type_t tnl_type;

    SHR_FUNC_ENTER(unit);

    if (XFS_TNL_INFO_TNL_INIT_CAP(unit) == 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_NULL_CHECK(tnl_info, SHR_E_PARAM);

    if (tnl_info->flags & BCM_TUNNEL_WITH_ID) {
        BCMI_LTSW_GPORT_TUNNEL_ID_GET(tnl_info->tunnel_id, tnl_type,
                                      index);
        if (tnl_type != bcmiTunnelTypeIpL3) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_alloc(unit, flags,
                                       BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                       BCMI_EGR_L3_TNL_USER_ID_IP_TNL, tnl_info,
                                       &index));

    BCMI_LTSW_GPORT_TUNNEL_ID_SET(tnl_info->tunnel_id, bcmiTunnelTypeIpL3,
                                  index);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_initiator_del(
    int unit,
    uint32_t flags,
    bcm_gport_t tunnel_id)
{
    bcmi_ltsw_tunnel_type_t tnl_type;
    int tnl_idx;

    SHR_FUNC_ENTER(unit);

    if (XFS_TNL_INFO_TNL_INIT_CAP(unit) == 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    BCMI_LTSW_GPORT_TUNNEL_ID_GET(tunnel_id, tnl_type, tnl_idx);
    if (tnl_type != bcmiTunnelTypeIpL3) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_free(unit, flags, BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                      BCMI_EGR_L3_TNL_USER_ID_IP_TNL, tnl_idx));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_initiator_get(
    int unit,
    bcm_l3_intf_t *intf,
    bcm_gport_t tunnel_id,
    bcm_tunnel_initiator_t *tnl_info)
{
    bcmi_ltsw_tunnel_type_t tnl_type;
    int tnl_idx;

    SHR_FUNC_ENTER(unit);

    if (XFS_TNL_INFO_TNL_INIT_CAP(unit) == 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_NULL_CHECK(tnl_info, SHR_E_PARAM);

    if (intf != NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    BCMI_LTSW_GPORT_TUNNEL_ID_GET(tunnel_id, tnl_type, tnl_idx);
    if (tnl_type != bcmiTunnelTypeIpL3) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (tnl_idx == 0) {
        /* Entry 0 is reserved. */
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_tunnel_init_get(unit, tnl_idx, tnl_info));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_initiator_used_get(
    int unit,
    bcm_gport_t tunnel_id)
{
    bcmi_ltsw_tunnel_type_t tnl_type;
    int tnl_idx;

    SHR_FUNC_ENTER(unit);

    if (XFS_TNL_INFO_TNL_INIT_CAP(unit) == 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    BCMI_LTSW_GPORT_TUNNEL_ID_GET(tunnel_id, tnl_type, tnl_idx);
    if (tnl_type != bcmiTunnelTypeIpL3) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit,
                                            BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO,
                                            BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                            BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                                            NULL, tnl_idx));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_initiator_traverse(
    int unit,
    bcm_tunnel_initiator_traverse_cb cb,
    void *user_data)
{
    bcm_tunnel_initiator_t tnl_init_info;
    uint64_t idx_min, idx_max;
    int idx;
    int rv = SHR_E_NONE;
    bcm_gport_t tunnel_id;

    SHR_FUNC_ENTER(unit);

    if (XFS_TNL_INFO_TNL_INIT_CAP(unit) == 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, EGR_L3_TUNNEL_0s,
                                       EGR_L3_TUNNEL_IDX_0s,
                                       &idx_min, &idx_max));

    for (idx = idx_min; idx <= idx_max; idx++) {
        BCMI_LTSW_GPORT_TUNNEL_ID_SET(tunnel_id, bcmiTunnelTypeIpL3, idx);
        if (xfs_ltsw_tunnel_initiator_used_get(unit, tunnel_id) != SHR_E_NONE) {
            continue;
        }

        bcm_tunnel_initiator_t_init(&tnl_init_info);
        tnl_init_info.tunnel_id = tunnel_id;
        rv = xfs_ltsw_tunnel_initiator_get(unit, NULL, tunnel_id,
                                           &tnl_init_info);
        if (SHR_FAILURE(rv)) {
            if (rv != SHR_E_NOT_FOUND) {
                break;
            }
            continue;
        }
        if (cb) {
            rv = (*cb) (unit, &tnl_init_info, user_data);
            if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                break;
            }
        }
    }

    if (rv == SHR_E_NOT_FOUND) {
        SHR_EXIT();
    } else {
        SHR_ERR_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_terminator_add(
    int unit,
    bcm_tunnel_terminator_t *tnl_term_info)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    /* Outer header is IPv6. */
    int ip6;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    ip6 = BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_term_info->type);

    if (tnl_term_info->flags & BCM_TUNNEL_TERM_EM) {
        /* EM tables. */
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV6_TUNNEL_EM_TABLEs, &entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV4_TUNNEL_EM_TABLEs, &entry_hdl));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_term_em_entry_init(unit, tnl_term_info, entry_hdl,
                                                TRUE, TRUE));
    } else {
        if (ip6) {
            if (XFS_TNL_INFO_V6_TNL_TERM_CAP(unit) == 0) {
                SHR_ERR_EXIT(SHR_E_UNAVAIL);
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV6_TUNNEL_TABLEs, &entry_hdl));
        } else {
            if (XFS_TNL_INFO_V4_TNL_TERM_CAP(unit) == 0) {
                SHR_ERR_EXIT(SHR_E_UNAVAIL);
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV4_TUNNEL_TABLEs, &entry_hdl));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_term_entry_init(unit, tnl_term_info, entry_hdl,
                                             TRUE, TRUE));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_terminator_get(
    int unit,
    bcm_tunnel_terminator_t *tnl_term_info)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    /* Outer header is IPv6. */
    int ip6;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    ip6 = BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_term_info->type);

    if (tnl_term_info->flags & BCM_TUNNEL_TERM_EM) {
        /* EM tables. */
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV6_TUNNEL_EM_TABLEs, &entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV4_TUNNEL_EM_TABLEs, &entry_hdl));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_term_em_entry_init(unit, tnl_term_info, entry_hdl,
                                                TRUE, FALSE));
    } else {
        if (ip6) {
            if (XFS_TNL_INFO_V6_TNL_TERM_CAP(unit) == 0) {
                SHR_ERR_EXIT(SHR_E_UNAVAIL);
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV6_TUNNEL_TABLEs, &entry_hdl));
        } else {
            if (XFS_TNL_INFO_V4_TNL_TERM_CAP(unit) == 0) {
                SHR_ERR_EXIT(SHR_E_UNAVAIL);
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV4_TUNNEL_TABLEs, &entry_hdl));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_term_entry_init(unit, tnl_term_info, entry_hdl,
                                             TRUE, FALSE));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    if (tnl_term_info->flags & BCM_TUNNEL_TERM_EM) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_term_em_entry_parse(unit, tnl_term_info, entry_hdl,
                                                 ip6, FALSE, TRUE));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_term_entry_parse(unit, tnl_term_info, entry_hdl,
                                              ip6, FALSE, TRUE));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_terminator_delete(
    int unit,
    bcm_tunnel_terminator_t *tnl_term_info)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    /* Outer header is IPv6. */
    int ip6;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    ip6 = BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_term_info->type);

    if (tnl_term_info->flags & BCM_TUNNEL_TERM_EM) {
        /* EM tables. */
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV6_TUNNEL_EM_TABLEs, &entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV4_TUNNEL_EM_TABLEs, &entry_hdl));
        }
        /* Prepare lookup key. */
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_term_em_entry_init(unit, tnl_term_info, entry_hdl,
                                               TRUE, FALSE));
    } else {
        if (ip6) {
            if (XFS_TNL_INFO_V6_TNL_TERM_CAP(unit) == 0) {
                SHR_ERR_EXIT(SHR_E_UNAVAIL);
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV6_TUNNEL_TABLEs, &entry_hdl));
        } else {
            if (XFS_TNL_INFO_V4_TNL_TERM_CAP(unit) == 0) {
                SHR_ERR_EXIT(SHR_E_UNAVAIL);
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, L3_IPV4_TUNNEL_TABLEs, &entry_hdl));
        }
        /* Prepare lookup key. */
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_tunnel_term_entry_init(unit, tnl_term_info, entry_hdl,
                                            TRUE, FALSE));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_terminator_traverse(
    int unit,
    bcm_tunnel_terminator_traverse_cb cb,
    void *user_data)
{
    bcm_tunnel_terminator_t tnl_term_info;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int mask_len;
    int dunit;
    int rv;
    int rv1;

    SHR_FUNC_ENTER(unit);

    bcm_tunnel_terminator_t_init(&tnl_term_info);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (XFS_TNL_INFO_V4_TNL_TERM_CAP(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, L3_IPV4_TUNNEL_TABLEs, &entry_hdl));

        rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        /* Traverse L3_IPV4_TUNNEL table. */
        while (rv == SHR_E_NONE) {
            if (cb) {
                bcm_tunnel_terminator_t_init(&tnl_term_info);
                SHR_IF_ERR_VERBOSE_EXIT
                    (ltsw_xfs_tunnel_term_entry_parse(unit, &tnl_term_info, entry_hdl,
                                                      FALSE, TRUE, TRUE));
            }

            /* Traverse to the next entry */
            rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL);

            /* Bypass the reserved dummy entry. */
            if (tnl_term_info.vlan == 0) {
                /* IPv4.*/
                if (tnl_term_info.dip_mask == 0) {
                    continue;
                }
            }

            if (cb) {
                rv1 = (*cb) (unit, &tnl_term_info, user_data);
                if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                    SHR_ERR_EXIT(rv1);
                }
            }
        }

        if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
            SHR_ERR_EXIT(rv);
        }

        if (entry_hdl != BCMLT_INVALID_HDL) {
            (void)bcmlt_entry_free(entry_hdl);
            entry_hdl = BCMLT_INVALID_HDL;
        }
    }

    if (XFS_TNL_INFO_V6_TNL_TERM_CAP(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, L3_IPV6_TUNNEL_TABLEs, &entry_hdl));

        rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        /* Traverse L3_IPV6_TUNNEL table. */
        while (rv == SHR_E_NONE) {
            if (cb) {
                bcm_tunnel_terminator_t_init(&tnl_term_info);
                SHR_IF_ERR_VERBOSE_EXIT
                    (ltsw_xfs_tunnel_term_entry_parse(unit, &tnl_term_info, entry_hdl,
                                                      TRUE, TRUE, TRUE));
            }

            /* Traverse to the next entry */
            rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL);

            /* Bypass the reserved dummy entry. */
            if (tnl_term_info.vlan == 0) {
                mask_len = bcm_ip6_mask_length(tnl_term_info.dip6_mask);
                if (mask_len == 0) {
                    continue;
                }
            }

            if (cb) {
                rv1 = (*cb) (unit, &tnl_term_info, user_data);
                if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                    SHR_ERR_EXIT(rv1);
                }
            }
        }

        if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
            SHR_ERR_EXIT(rv);
        }

        if (entry_hdl != BCMLT_INVALID_HDL) {
            (void)bcmlt_entry_free(entry_hdl);
            entry_hdl = BCMLT_INVALID_HDL;
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L3_IPV4_TUNNEL_EM_TABLEs, &entry_hdl));


    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);

    /* Traverse L3_IPV4_TUNNEL_EM table. */
    while (rv == SHR_E_NONE) {
        if (cb) {
            bcm_tunnel_terminator_t_init(&tnl_term_info);
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_tunnel_term_em_entry_parse(unit, &tnl_term_info, entry_hdl,
                                                     FALSE, TRUE, TRUE));
        }

        /* Traverse to the next entry */
        rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        if (cb) {
            rv1 = (*cb) (unit, &tnl_term_info, user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L3_IPV6_TUNNEL_EM_TABLEs, &entry_hdl));


    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);

    /* Traverse L3_IPV6_TUNNEL_EM table. */
    while (rv == SHR_E_NONE) {
        if (cb) {
            bcm_tunnel_terminator_t_init(&tnl_term_info);
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_tunnel_term_em_entry_parse(unit, &tnl_term_info, entry_hdl,
                                                     TRUE, TRUE, TRUE));
        }
        /* Traverse to the next entry */
        rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        if (cb) {
            rv1 = (*cb) (unit, &tnl_term_info, user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_encap_seq_profile_init(int unit)
{
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_TNL_ENCAP_SEQUENCE;
    uint64_t idx_max, idx_min;
    int ent_idx_min, ent_idx_max;
    int idx;
    bcmi_ltsw_tunnel_encap_seq_profile_t profile;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    /* Initialize sequence profiles. */
    rv = bcmi_ltsw_profile_unregister(unit, profile_hdl);
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_ENCAP_SEQUENCE_PROFILEs,
                                       TNL_ENCAP_SEQUENCE_PROFILE_IDs,
                                       &idx_min, &idx_max));
    ent_idx_min = (int)idx_min;
    ent_idx_max = (int)idx_max;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit, &profile_hdl,
                                    &ent_idx_min, &ent_idx_max, 1,
                                    xfs_tunnel_encap_seq_profile_entry_hash_cb,
                                    xfs_tunnel_encap_seq_profile_entry_cmp_cb));

    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_ENCAP_SEQUENCE_PROFILEs));
    }

    /* Reserve profile 0 for those that disable encap sequence number. */
    sal_memset(&profile, 0, sizeof(profile));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_index_allocate(unit, profile_hdl, &profile, 0, 1, &idx));
    if (idx != 0) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }
    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_tunnel_encap_seq_profile_entry_set(unit, idx, &profile));
    }

    /* Reserve another profile for EGR_L3_TUNNEL_1, IP4 ID. */
    sal_memset(&profile, 0, sizeof(profile));

    profile.enable = 1;
    profile.update_en = 1;
    profile.increment = 1;
    /* reserved_val is configured as a value larger than 0xFFFF thus never matched. */
    profile.reserved_value = 0xFFFF0000;
    /* IPv4 header only uses 16-bit ID (i.e. 0~0xFFFF)*/
    profile.mask = 0xFFFF0000;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_index_allocate(unit, profile_hdl, &profile, 0, 1, &idx));
    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_tunnel_encap_seq_profile_entry_set(unit, idx, &profile));
    }

    if (bcmi_warmboot_get(unit)) {
        int tnl_idx;
        /* Recover */
        dunit = bcmi_ltsw_dev_dunit(unit);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, EGR_L3_TUNNEL_1s, &entry_hdl));
        while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                          BCMLT_OPCODE_TRAVERSE,
                                          BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, EGR_L3_TUNNEL_IDX_0s, &data));
            tnl_idx = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, SEQ_NUM_PROFILE_IDXs, &data));
            idx = data;
            /* Skip index 0. */
            if (tnl_idx == 0 && idx == 0) {
                continue;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ltsw_tunnel_encap_seq_profile_recover(unit, idx));
        }

        if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
            SHR_ERR_EXIT(rv);
        }
    }

    /* Initialize sequence numbers. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_tunnel_encap_seq_num_init(unit));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_encap_seq_profile_deinit(int unit)
{
    int rv;
    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_unregister(unit, BCMI_LTSW_PROFILE_TNL_ENCAP_SEQUENCE);
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_tunnel_encap_seq_num_deinit(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_encap_seq_num_alloc(
    int unit,
    uint32_t flags,
    bcmi_ltsw_tunnel_encap_seq_num_type_t type,
    int *index)
{
    int idx;
    int found = 0;

    SHR_FUNC_ENTER(unit);

    if (flags != 0) {
        /* May be used for with ID (and replace) in the future. */
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(index, SHR_E_PARAM);

    for (idx = XFS_SEQ_NUM_IDX_MIN(unit); idx <= XFS_SEQ_NUM_IDX_MAX(unit);
         idx++) {
        if (SHR_BITGET(XFS_SEQ_NUM_BMP(unit), idx) == 0) {
            found = 1;
            /* First ununsed idx. */
            break;
        }
    }

    if (found == 0) {
       SHR_ERR_EXIT(SHR_E_RESOURCE);
    }

    switch(type) {
        case ENCAP_SEQ_NUM_TYPE_TNL:
            SHR_BITSET(XFS_SEQ_NUM_TNL_BMP(unit), idx);
        break;

        case ENCAP_SEQ_NUM_TYPE_VP:
            SHR_BITSET(XFS_SEQ_NUM_VP_BMP(unit), idx);
        break;

        case ENCAP_SEQ_NUM_TYPE_MIRROR:
            SHR_BITSET(XFS_SEQ_NUM_MIRROR_BMP(unit), idx);
        break;

        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_BITSET(XFS_SEQ_NUM_BMP(unit), idx);
    *index = idx;

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_encap_seq_num_free(
    int unit,
    bcmi_ltsw_tunnel_encap_seq_num_type_t type,
    int index)
{
    SHR_BITDCL *seq_num_bmp;

    SHR_FUNC_ENTER(unit);

    if ((index < XFS_SEQ_NUM_IDX_MIN(unit)) ||
        (index > XFS_SEQ_NUM_IDX_MAX(unit))) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (SHR_BITGET(XFS_SEQ_NUM_BMP(unit), index) == 0) {
        SHR_ERR_EXIT(SHR_E_EMPTY);
    }

    switch(type) {
        case ENCAP_SEQ_NUM_TYPE_TNL:
            seq_num_bmp = XFS_SEQ_NUM_TNL_BMP(unit);
        break;

        case ENCAP_SEQ_NUM_TYPE_VP:
            seq_num_bmp = XFS_SEQ_NUM_VP_BMP(unit);
        break;

        case ENCAP_SEQ_NUM_TYPE_MIRROR:
            seq_num_bmp = XFS_SEQ_NUM_MIRROR_BMP(unit);
        break;

        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (SHR_BITGET(seq_num_bmp, index) == 0) {
        SHR_ERR_EXIT(SHR_E_EMPTY);
    }

    SHR_BITCLR(seq_num_bmp, index);
    SHR_BITCLR(XFS_SEQ_NUM_BMP(unit), index);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_encap_seq_num_set(
    int unit,
    int idx,
    int pipe,
    uint32_t number)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_ENCAP_SEQUENCE_NUMBERs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_ENCAP_SEQUENCE_NUMBER_IDs, idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PIPEs, pipe));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, SEQUENCE_NUMBERs, number));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_encap_seq_num_get(
    int unit,
    int idx,
    int pipe,
    uint32_t *number)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(number, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_ENCAP_SEQUENCE_NUMBERs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_ENCAP_SEQUENCE_NUMBER_IDs, idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PIPEs, pipe));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, SEQUENCE_NUMBERs, &data));
    *number = data;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_encap_seq_profile_add(
    int unit,
    bcmi_ltsw_tunnel_encap_seq_profile_t *entry,
    int *index)
{
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    rv = bcmi_ltsw_profile_index_allocate(unit, BCMI_LTSW_PROFILE_TNL_ENCAP_SEQUENCE,
                                          entry, 0, 1, index);
    if (rv == SHR_E_EXISTS) {
        /* the same profile already exists */
        SHR_EXIT();
    }

    if (SHR_FAILURE(rv)) {
       SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_tunnel_encap_seq_profile_entry_set(unit, *index, entry));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_encap_seq_profile_get(
    int unit,
    bcmi_ltsw_tunnel_encap_seq_profile_t *entry,
    int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_tunnel_encap_seq_profile_entry_get(unit, index, entry));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_encap_seq_profile_delete(
    int unit,
    int index)
{
    int rv;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_free(unit, BCMI_LTSW_PROFILE_TNL_ENCAP_SEQUENCE,
                                      index);

    if (rv == SHR_E_BUSY) {
        /* profile entry is still inused */
       SHR_EXIT();
    }

    if (rv != SHR_E_NONE) {
        SHR_ERR_EXIT(rv);
    }

    /* empty the profile entry */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_tunnel_encap_seq_profile_entry_del(unit, index));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_encap_seq_profile_recover(
    int unit,
    int index)
{
    uint32_t ref_cnt;
    uint64_t idx_min, idx_max;
    bcmi_ltsw_tunnel_encap_seq_profile_t profile;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_ENCAP_SEQUENCE_PROFILEs,
                                       TNL_ENCAP_SEQUENCE_PROFILE_IDs,
                                       &idx_min, &idx_max));

    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_get(unit, BCMI_LTSW_PROFILE_TNL_ENCAP_SEQUENCE,
                                         index, &ref_cnt));
    if (ref_cnt == 0) {
        /* If profile entry has not been initialized. */
        sal_memset(&profile, 0, sizeof(profile));
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_tunnel_encap_seq_profile_get(unit, &profile, index));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_hash_update(unit,
                                           BCMI_LTSW_PROFILE_TNL_ENCAP_SEQUENCE,
                                           &profile, 1, index));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_increase(unit,
                                              BCMI_LTSW_PROFILE_TNL_ENCAP_SEQUENCE,
                                              1, index, 1));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_tunnel_type_support_check(
    int unit,
    bcm_tunnel_type_t tnl_type,
    int *tunnel_term,
    int *tunnel_init)
{
    /* Tunnel terminator supported. */
    int term;
    /* Tunnel initiator supported. */
    int init;

    switch (tnl_type) {
    case bcmTunnelTypeNone:
    case bcmTunnelTypeIp4In4:
    case bcmTunnelTypeIp6In4:
        term = init = TRUE;
        break;

    case bcmTunnelType6In4Uncheck:
        init = term = FALSE;
        break;

    case bcmTunnelTypeIpAnyIn4:
        init = TRUE;
        if (!(bcmi_ltsw_property_get(unit,
                                     BCMI_CPN_BCM_TUNNEL_TERM_COMPATIBLE_MODE,
                                     0))) {
            term = FALSE;
        } else {
            term = TRUE;
        }
        break;

    case bcmTunnelTypeIp4In6:
    case bcmTunnelTypeIp6In6:
        term = init = TRUE;
        break;

    case bcmTunnelTypeIpAnyIn6:
        init = TRUE;
        if (!(bcmi_ltsw_property_get(unit,
                                     BCMI_CPN_BCM_TUNNEL_TERM_COMPATIBLE_MODE,
                                     0))) {
            term = FALSE;
        } else {
            term = TRUE;
        }
        break;

    case bcmTunnelType6In4:
        init = term = FALSE;
        break;

    case bcmTunnelTypePim6SmDr1:
    case bcmTunnelTypePim6SmDr2:
        init = term = FALSE;
        break;

    case bcmTunnelTypeGre4In4:
    case bcmTunnelTypeGre6In4:
        init = term = FALSE;
        break;

    case bcmTunnelTypeGreAnyIn4:
        term = init = TRUE;
        break;

    case bcmTunnelTypeGre4In6:
    case bcmTunnelTypeGre6In6:
        init = term = FALSE;
        break;

    case bcmTunnelTypeGreAnyIn6:
        term = init = TRUE;
        break;

    case bcmTunnelTypeUdp:
    case bcmTunnelTypeMpls:
        init = term = FALSE;
        break;

    case bcmTunnelTypeWlanWtpToAc:
    case bcmTunnelTypeWlanWtpToAc6:
    case bcmTunnelTypeWlanAcToAc:
    case bcmTunnelTypeWlanAcToAc6:
        term = init = FALSE;
        break;

    case bcmTunnelTypeAutoMulticast:
    case bcmTunnelTypeAutoMulticast6:
        init = term = FALSE;
        break;

    default:
        term = init = FALSE;
    }

    if (tunnel_term != NULL) {
        *tunnel_term = term;
    }
    if (tunnel_init != NULL) {
        *tunnel_init = init;
    }

    return (SHR_E_NONE);
}

