/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/port.h>
#include <bcm/flow.h>
#include <bcm_int/ltsw_dispatch.h>

#include <bcm_int/ltsw/xfs/trunk.h>
#include <bcm_int/ltsw/flow.h>
#include <bcm_int/ltsw/mpls.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/dlb.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/xfs/types.h>
#include <bcm_int/ltsw/l3_egress.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/vlan.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_TRUNK

/******************************************************************************
 * Private functions
 */


/*!
 * \brief Get L2 egress interface by system port Id.
 *
 * \param [in] unit Unit Number.
 * \param [in] system_port System Port Number.
 * \param [out] l2_eif Trunk L2 egress interface.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_member_l2_eif_resolve(
    int unit,
    int system_port,
    int *l2_eif)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit, rv, local_system_port;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(l2_eif, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_EIF_SYSTEM_DESTINATIONs, &lte_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, lte_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, IS_TRUNKs, &value));
        if (value) {
            continue;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, SYSTEM_PORTs, &value));
        local_system_port = value & 0xffffffff;

        if (local_system_port == system_port) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, L2_EIF_IDs, &value));
            *l2_eif = value & 0xffffffff;
            SHR_EXIT();
        }
    }

    SHR_ERR_EXIT(SHR_E_NOT_FOUND);

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Resolve virtual port gport to virtual port.
 *
 * \param [in] unit Unit Number.
 * \param [in] gport Generic Port Number.
 * \param [out] modid Module ID.
 * \param [out] port Port Number.
 * \param [out] system_port System Port Number.
 * \param [out] l2_eif Trunk L2 egress interface.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_gport_virtual_port_resolve(
    int unit,
    bcm_gport_t gport,
    int *vp)
{
    int local_vp;
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_type_vp_get(unit, gport, &local_vp));

    if (vp != NULL) {
        *vp = local_vp;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct gport by virtual port.
 *
 * \param [in] unit Unit Number.
 * \param [in] system_port System Port Number.
 * \param [out] gport Generic Port Number.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_gport_virtual_port_construct(
    int unit,
    int vp,
    bcm_gport_t *gport)
{
    bcm_gport_t local_gport;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(gport, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_encode_gport(unit, vp, &local_gport));

    if (gport) {
        *gport = local_gport;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Judge the gport is channelized access port or not.
 *
 * \param [in] unit Device unit number.
 * \param [in] gport Member gport.
 *
 * \retval true Gport is a channelized access port.
 * \retval false Gport is not a channelized access port.
 */
static bool
ltsw_xfs_trunk_gport_is_channelized_access_port(
    int unit,
    bcm_gport_t gport)
{
    int rv, vp = -1;
    bcmi_ltsw_virtual_vp_info_t vp_info;

    rv = ltsw_xfs_trunk_gport_virtual_port_resolve(unit, gport, &vp);
    if (SHR_FAILURE(rv)) {
        return false;
    }

    bcmi_ltsw_virtual_vp_info_init(&vp_info);
    if (bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info)) {
        return false;
    }
    if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_VALID)) {
        return false;
    }
    if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT) {
        return false;
    }

    return true;
}

/*!
 * \brief Resolve channelized access port to modport gport.
 *
 * \param [in] unit Unit Number.
 * \param [in] cap_gport Channelized access port Gport.
 * \param [out]  gport Physical port gport.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_gport_channelized_access_port_resolve(
    int unit,
    bcm_gport_t cap_gport,
    bcm_gport_t *gport)
{
    int l2_iif;

    SHR_FUNC_ENTER(unit);

    if (BCM_GPORT_IS_FLOW_PORT(cap_gport)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_flow_port_to_l2_if(unit, cap_gport, &l2_iif));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l2_if_to_port(unit, l2_iif, &cap_gport));
        if (!BCM_GPORT_IS_SET(cap_gport)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_port_gport_get(unit, cap_gport, &cap_gport));
        }
    }

    *gport = cap_gport;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Resolve gport to system port and L2 egress interface.
 *
 * \param [in] unit Unit Number.
 * \param [in] gport Generic Port Number.
 * \param [out] modid Module ID.
 * \param [out] port Port Number.
 * \param [out] system_port System Port Number.
 * \param [out] l2_eif Trunk L2 egress interface.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_gport_resolve(
    int unit,
    bcm_gport_t gport,
    int *modid,
    int *port,
    int *system_port,
    int *l2_eif)
{
    int local_modid, local_port, local_system_port;
    int tgid, id;

    SHR_FUNC_ENTER(unit);

    if (ltsw_xfs_trunk_gport_is_channelized_access_port(unit, gport)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_gport_channelized_access_port_resolve(unit, gport,
                                                                  &gport));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_resolve(unit, gport,
                                      &local_modid, &local_port, &tgid, &id));
    if ((tgid != -1) || (id != -1)) {
        SHR_ERR_EXIT(SHR_E_PORT);
    }
    if (modid != NULL) {
        *modid = local_modid;
    }
    if (port != NULL) {
        *port = local_port;
    }
    if (system_port != NULL || l2_eif != NULL) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_to_sys_port(unit, gport, &local_system_port));
    }
    if (system_port != NULL) {
        *system_port = local_system_port;
    }
    if (l2_eif != NULL) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_member_l2_eif_resolve(unit, local_system_port,
                                                  l2_eif));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct gport by system port.
 *
 * \param [in] unit Unit Number.
 * \param [in] system_port System Port Number.
 * \param [out] gport Generic Port Number.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_gport_construct(
    int unit,
    int system_port,
    int *gport)
{
    bcm_gport_t local_gport;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(gport, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_sys_port_to_port(unit, system_port, &local_gport));

    if (gport) {
        *gport = local_gport;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check whehter virtual port is network port.
 *
 * \param [in]   unit     Unit number.
 * \param [in]   vp     Virtual port.
 *
 * \retval TRUE   Virtual port is network port.
 * \retval FALSE  Virtual port is access port.
 */
static int
ltsw_xfs_trunk_virtual_port_is_network(int unit, int vp)
{
    bcmi_ltsw_virtual_vp_info_t vp_info;

    bcmi_ltsw_virtual_vp_info_init(&vp_info);
    if (bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info)) {
        return FALSE;
    }
    if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT) {
        return TRUE;
    }
    return FALSE;
}

/*!
 * \brief Convert trunk Id to L2 egress interface.
 *
 * \param [in] unit Device unit number.
 * \param [in] t_id The front panel trunk ID.
 * \param [in] t_priv Trunk private information.
 * \param [out] l2_eif L2 egress interface Id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_type_id_to_l2_eif(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    int *l2_eif)
{
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    if (t_info->tid == BCM_TRUNK_INVALID) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }
    if (t_info->l2_dest < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    *l2_eif = t_info->l2_dest;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert L2 egress interface to trunk type Id.
 *
 * \param [in] unit Device unit number.
 * \param [in] l2_eif L2 egress interface Id.
 * \param [out] t_type Trunk Type.
 * \param [out] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_l2_eif_to_type_id(
    int unit,
    int l2_eif,
    bcmint_trunk_type_t *t_type,
    bcmint_trunk_id_t *t_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit = 0;
    int is_trunk = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_EIF_SYSTEM_DESTINATIONs, &lte_hdl));

    value = l2_eif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_EIF_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, IS_TRUNKs, &value));
    is_trunk = value & 0xffffffff;

    if (is_trunk) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, TRUNK_IDs, &value));
        *t_id = value & 0xffffffff;
        *t_type = bcmintTrunkTypeFrontPanel;
    } else {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get TRUNK module public infomation.
 *
 * \param [in] unit Unit Number.
 * \param [out] t_pub Trunk public information.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_pub_info_get(
    int unit,
    bcmint_trunk_pub_info_t *t_pub)
{
    uint64_t min, max;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(t_pub, SHR_E_MEMORY);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNKs, TRUNK_IDs,
                                       &min, &max));
    t_pub->ngroups_fp = (int)max + 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNKs, UC_MAX_MEMBERSs,
                                       &min, &max));
    t_pub->nports_fp = (int)max;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNK_FAILOVERs, FAILOVER_CNTs,
                                       &min, &max));
    t_pub->nftports_fp = (int)max;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNK_SYSTEMs, TRUNK_SYSTEM_IDs,
                                       &min, &max));
    t_pub->ngroups_fabric = (int)max + 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNK_SYSTEMs, MAX_MEMBERSs,
                                       &min, &max));
    t_pub->nports_fabric = (int)max;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNK_SYSTEM_FAILOVERs,
                                       FAILOVER_CNTs,
                                       &min, &max));
    t_pub->nftports_fabric = (int)max;

    if (ltsw_feature(unit, LTSW_FT_VPLAG)) {
        int max_vplag_groups, num_vplag_groups;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, TRUNK_VPs, TRUNK_VP_IDs,
                                           &min, &max));
        /* Vp group index zero is reserved. */
        if (min == 0) {
            min = 1;
        }
        max_vplag_groups = (int)max - (int)min + 1;
        num_vplag_groups = bcmi_ltsw_property_get(unit, BCMI_CPN_MAX_VP_LAGS,
                                                  0);
        if (num_vplag_groups > max_vplag_groups) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "Unsupported max_vp_lags value - %d, "
                                  "should be less than - %d\n"),
                                  num_vplag_groups,
                                  max_vplag_groups));
            LOG_CLI(("INFO : The number of vplag groups is reduced to - %d \n",
                     max_vplag_groups));
            num_vplag_groups = max_vplag_groups;
        }
        t_pub->ngroups_vplag = num_vplag_groups;
        t_pub->base_vplag_idx = min;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, TRUNK_VPs, MEMBER_CNTs,
                                           &min, &max));
        t_pub->nvps_vplag = num_vplag_groups ? (int)max : 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, TRUNK_VP_WEIGHTEDs,
                                           MEMBER_CNTs,
                                           &min, &max));
        t_pub->nvps_weighted_vplag = num_vplag_groups ? (int)max : 0;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Psc decode to HW load balance mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] psc Port Selection Criteria.
 * \param [out] lb_mode Load Balance Mode.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_psc_decode(
    int unit,
    int psc,
    const char **lb_mode)
{
    const char *local_lb_mode;

    SHR_FUNC_ENTER(unit);

    switch (psc) {
        case BCM_TRUNK_PSC_PORTFLOW:
            local_lb_mode = REG_HASHs;
            break;
        case BCM_TRUNK_PSC_RANDOMIZED:
            local_lb_mode = RANDOMs;
            break;
        case BCM_TRUNK_PSC_DYNAMIC:
        case BCM_TRUNK_PSC_DYNAMIC_ASSIGNED:
        case BCM_TRUNK_PSC_DYNAMIC_OPTIMAL:
            local_lb_mode = REG_HASHs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (lb_mode) {
        *lb_mode = local_lb_mode;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Psc encode from HW load balance mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] lb_mode Load Balance Mode.
 * \param [out] psc Port Selection Criteria.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_psc_encode(
    int unit,
    const char *lb_mode,
    int *psc)
{
    const char *local_lb_mode;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(psc, SHR_E_PARAM);


    if (lb_mode == NULL) {
        local_lb_mode = REG_HASHs;
    } else {
        local_lb_mode = lb_mode;
    }

    if (sal_strcmp(local_lb_mode, REG_HASHs) == 0) {
        *psc = BCM_TRUNK_PSC_PORTFLOW;
    } else if (sal_strcmp(local_lb_mode, RANDOMs) == 0) {
        *psc = BCM_TRUNK_PSC_RANDOMIZED;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare two psc values and return the result.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_type Trunk Type.
 * \param [in] psc0 First Port Selection Criteria.
 * \param [in] psc1 Second Port Selection Criteria.
 * \param [in] exact Exact match.
 * \param [out] result TRUE/False: Same or Not.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_psc_compare(
    int unit,
    int psc0,
    int psc1,
    int exact,
    bool *result)
{
    const char *lb_mode = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(result, SHR_E_PARAM);

    *result = false;

    if (psc0 == psc1) {
        *result = true;
    } else {
        if (exact) {
            SHR_EXIT();
        }

        if (psc0 < 0 || psc1 < 0) {
            *result = true;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_psc_decode(unit, psc0, &lb_mode));

            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_psc_encode(unit, lb_mode, &psc0));

            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_psc_decode(unit, psc1, &lb_mode));

            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_psc_encode(unit, lb_mode, &psc1));

            if (psc0 == psc1) {
                *result = true;
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief weighted size decode to HW configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] member_count The member count.
 * \param [out] weighted_size Weighted group member size.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_virtual_weighted_size_decode(
    int unit,
    int member_count,
    const char **weighted_size)
{
    const char *local_weighted_size;

    SHR_FUNC_ENTER(unit);

    switch (member_count) {
        case 256:
            local_weighted_size = WEIGHTED_SIZE_256s;
            break;
        case 512:
            local_weighted_size = WEIGHTED_SIZE_512s;
            break;
        case 1024:
            local_weighted_size = WEIGHTED_SIZE_1Ks;
            break;
        case 2048:
            local_weighted_size = WEIGHTED_SIZE_2Ks;
            break;
        case 4096:
            local_weighted_size = WEIGHTED_SIZE_4Ks;
            break;
        case 8192:
            local_weighted_size = WEIGHTED_SIZE_8Ks;
            break;
        case 16384:
            local_weighted_size = WEIGHTED_SIZE_16Ks;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (weighted_size) {
        *weighted_size = local_weighted_size;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Psc encode from HW load balance mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] weighted_size Weighted group member size.
 * \param [out] member_count The member count.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_virtual_weighted_size_encode(
    int unit,
    const char *weighted_size,
    int *member_count)
{
    const char *local_weighted_size;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(member_count, SHR_E_PARAM);


    if (weighted_size == NULL) {
        local_weighted_size = WEIGHTED_SIZE_256s;
    } else {
        local_weighted_size = weighted_size;
    }

    if (sal_strcmp(local_weighted_size, WEIGHTED_SIZE_256s) == 0) {
        *member_count = 256;
    } else if (sal_strcmp(local_weighted_size, WEIGHTED_SIZE_512s) == 0) {
        *member_count = 512;
    } else if (sal_strcmp(local_weighted_size, WEIGHTED_SIZE_1Ks) == 0) {
        *member_count = 1024;
    } else if (sal_strcmp(local_weighted_size, WEIGHTED_SIZE_2Ks) == 0) {
        *member_count = 2048;
    } else if (sal_strcmp(local_weighted_size, WEIGHTED_SIZE_4Ks) == 0) {
        *member_count = 4096;
    } else if (sal_strcmp(local_weighted_size, WEIGHTED_SIZE_8Ks) == 0) {
        *member_count = 8192;
    } else if (sal_strcmp(local_weighted_size, WEIGHTED_SIZE_16Ks) == 0) {
        *member_count = 16384;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Psc decode to DLB member assignment mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] psc Port Selection Criteria.
 * \param [out] assignment_mode Dynamic Load Balance member assignment mode.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_psc_to_dlb_assignment_mode(
    int unit,
    int psc,
    int *assignment_mode)
{
    SHR_FUNC_ENTER(unit);

    switch (psc) {
        case BCM_TRUNK_PSC_DYNAMIC:
            *assignment_mode = BCMI_LTSW_DLB_ASSIGNMENT_MODE_TIME_ELIGIBILITY;
            break;
        case BCM_TRUNK_PSC_DYNAMIC_ASSIGNED:
            *assignment_mode = BCMI_LTSW_DLB_ASSIGNMENT_MODE_FIXED;
            break;
        case BCM_TRUNK_PSC_DYNAMIC_OPTIMAL:
            *assignment_mode = BCMI_LTSW_DLB_ASSIGNMENT_MODE_PACKET_SPRAY;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}
/*!
 * \brief Validate whether the device support DLB or not.
 *
 * \param [in] unit Device unit number.
 *
 * \return true for support.
 * \return false for not support.
 */
static bool
ltsw_xfs_trunk_dlb_validate_feature(int unit)
{
    return ltsw_feature(unit, LTSW_FT_DLB) ? true : false;
}

/*!
 * \brief Validate whether the device support DLB DGM or not.
 *
 * \param [in] unit Device unit number.
 *
 * \return true for support.
 * \return false for not support.
 */
static bool
ltsw_xfs_trunk_dlb_validate_dgm_feature(int unit)
{
    return ltsw_feature(unit, LTSW_FT_DLB_DGM) ? true : false;
}

/*!
 * \brief Validate whether the device support DLB DGM or not.
 *
 * \param [in] unit Device unit number.
 * \param [in] psc Port Selection Criteria.
 *
 * \return true for configured.
 * \return false for not configured.
 */
static bool
ltsw_xfs_trunk_dlb_is_configured(
    int unit,
    int psc)
{
    bool configured = false;

    COMPILER_REFERENCE(unit);

    switch (psc) {
        case BCM_TRUNK_PSC_DYNAMIC:
        case BCM_TRUNK_PSC_DYNAMIC_ASSIGNED:
        case BCM_TRUNK_PSC_DYNAMIC_OPTIMAL:
            configured = true;
            break;
        default:
            break;
    }

    return configured;
}

/*!
 * \brief Find DLB Id.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_type Trunk Type.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 * \param [out] dlb_id DLB Id.
 *
 * \return true for configured.
 * \return false for not configured.
 */
static int
ltsw_xfs_trunk_dlb_find_dlb_id(
    int unit,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    int *dlb_id)
{
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    if (!ltsw_xfs_trunk_dlb_is_configured(unit, t_info->psc)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    if (t_info->dlb_id == -1) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    } else {
        *dlb_id = t_info->dlb_id;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB Id by L2 egress interface Id.
 *
 * \param [in] unit Device unit number.
 * \param [in] l2_eif L2 egress interface Id.
 * \param [in] dlb_id DLB Id.
 *
 * \return true for configured.
 * \return false for not configured.
 */
static int
ltsw_xfs_trunk_dlb_set_dlb_id_by_l2_eif(
    int unit,
    int l2_eif,
    int dlb_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_EIF_SYSTEM_DESTINATIONs, &lte_hdl));

    value = l2_eif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_EIF_IDs, value));

    value = dlb_id < 0 ? 0 : 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_ID_VALIDs, value));

    value = dlb_id < 0 ? 0 : dlb_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB Id by system port.
 *
 * \param [in] unit Device unit number.
 * \param [in] tid System Trunk Id.
 * \param [in] dlb_id DLB Id.
 *
 * \return true for configured.
 * \return false for not configured.
 */
static int
ltsw_xfs_trunk_dlb_set_dlb_id_by_system_trunk_id(
    int unit,
    int tid,
    int dlb_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int rv, is_system_trunk, t_id;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SYSTEM_DESTINATIONs, &lte_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, lte_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, IS_TRUNK_SYSTEMs, &value));
        is_system_trunk = value & 0xffffffff;

        if (is_system_trunk) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, TRUNK_SYSTEM_IDs, &value));
            t_id = value & 0xffffffff;
            if (tid == t_id) {
                value = dlb_id < 0 ? 0 : 1;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(lte_hdl, DLB_ID_VALIDs, value));

                value = dlb_id < 0 ? 0 : dlb_id;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(lte_hdl, DLB_IDs, value));
                SHR_IF_ERR_CONT
                    (bcmi_lt_entry_commit(unit, lte_hdl,
                                          BCMLT_OPCODE_UPDATE,
                                          BCMLT_PRIORITY_NORMAL));
            }
        }
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB Id.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_type Trunk Type.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] t_priv Trunk private information.
 * \param [in] dlb_id DLB Id.
 *
 * \return true for configured.
 * \return false for not configured.
 */
static int
ltsw_xfs_trunk_dlb_set_dlb_id(
    int unit,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    int dlb_id)
{
    int l2_eif;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    switch (t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_type_id_to_l2_eif(unit, t_id, t_priv, &l2_eif));

            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_dlb_set_dlb_id_by_l2_eif(unit, l2_eif,
                                                         dlb_id));
            break;
        case bcmintTrunkTypeFabric:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_dlb_set_dlb_id_by_system_trunk_id(unit, t_id,
                                                                  dlb_id));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Record the DLB Id. */
    t_info->dlb_id = dlb_id;

exit:
    SHR_FUNC_EXIT();
}

int
ltsw_xfs_trunk_init(int unit)
{
    int rv;
    bcmint_trunk_pub_info_t t_pub;

    SHR_FUNC_ENTER(unit);

    sal_memset(&t_pub, 0, sizeof(t_pub));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_pub_info_get(unit, &t_pub));
    if (t_pub.ngroups_vplag > 0) {
        rv = bcmi_ltsw_virtual_vp_used_get(unit, t_pub.base_vplag_idx,
                                           BCMI_LTSW_VP_TYPE_VPLAG);
        if (rv == SHR_E_NOT_FOUND) {
            int start, end, base_vp;
            bcmi_ltsw_virtual_vp_info_t vp_info;

            start = t_pub.base_vplag_idx;
            end = t_pub.base_vplag_idx + t_pub.ngroups_vplag - 1;
            bcmi_ltsw_virtual_vp_info_init(&vp_info);
            vp_info.flags |= BCMI_LTSW_VIRTUAL_VP_TYPE_VPLAG;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vp_alloc(unit, start, end,
                                            t_pub.ngroups_vplag,
                                            vp_info, &base_vp));
            if (t_pub.base_vplag_idx != base_vp) {
                SHR_ERR_EXIT(SHR_E_INTERNAL);
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
ltsw_xfs_trunk_detach(int unit)
{
    int rv;
    bcmint_trunk_pub_info_t t_pub;

    SHR_FUNC_ENTER(unit);

    sal_memset(&t_pub, 0, sizeof(t_pub));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_pub_info_get(unit, &t_pub));
    if (t_pub.ngroups_vplag > 0) {
        rv = bcmi_ltsw_virtual_vp_used_get(unit, t_pub.base_vplag_idx,
                                           BCMI_LTSW_VP_TYPE_VPLAG);
        if (rv == SHR_E_NONE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vp_free(unit,
                                           BCMI_LTSW_VP_TYPE_VPLAG,
                                           t_pub.ngroups_vplag,
                                           t_pub.base_vplag_idx));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create L2 ingress interface for the front panel trunk.
 *
 * \param [in] unit Device unit number.
 * \param [in] t_id The front panel trunk ID.
 * \param [in] l2_iif Trunk L2 ingress interface.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_create_fp_l2_iif(
    int unit,
    bcmint_trunk_id_t t_id,
    int l2_iif)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_L2_IIF_TABLEs, &lte_hdl));

    value = l2_iif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_IIFs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_free(lte_hdl));
    lte_hdl = BCMLT_INVALID_HDL;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_L2_IIF_ATTRIBUTES_TABLEs, &lte_hdl));

    value = l2_iif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_IIFs, value));

    value = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, IS_SRC_LAGs, value));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SRC_LAG_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create L2 egress interface for the front panel trunk.
 *
 * \param [in] unit Device unit number.
 * \param [in] t_id The front panel trunk ID.
 * \param [in] l2_eif Trunk L2 egress interface.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_create_fp_l2_eif(
    int unit,
    bcmint_trunk_id_t t_id,
    int l2_eif)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_EIF_SYSTEM_DESTINATIONs, &lte_hdl));

    value = l2_eif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_EIF_IDs, value));

    value = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, IS_TRUNKs, value));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create egress L2 outgoing interface for the front panel trunk.
 *
 * \param [in] unit Device unit number.
 * \param [in] t_id The front panel trunk ID.
 * \param [in] egr_l2_oif Egress L2 Outgoing Interface.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_create_fp_egr_l2_oif(
    int unit,
    bcmint_trunk_id_t t_id,
    int egr_l2_oif)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L2_OIFs, &lte_hdl));

    value = egr_l2_oif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_OIFs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create the front panel trunk.
 *
 * \param [in] unit Device unit number.
 * \param [in] t_id The front panel trunk ID.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_create_fp(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    int l2_eif;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l2_if_alloc(unit, &l2_eif));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_create_fp_l2_iif(unit, t_id, l2_eif));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_create_fp_l2_eif(unit, t_id, l2_eif));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_create_fp_egr_l2_oif(unit, t_id, l2_eif));

    t_info->l2_dest = l2_eif;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create source virtual port for the virtual port link aggregation group.
 *
 * \param [in] unit Device unit number.
 * \param [in] svp Source virtual port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_create_virtual_svp(
    int unit,
    int svp)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_SVP_TABLEs, &lte_hdl));

    value = svp;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SVPs, value));

    value = BCMI_XFS_CML_FLAGS_LEARN;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, CML_FLAGS_NEWs, value));

    value = BCMI_XFS_CML_FLAGS_LEARN;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, CML_FLAGS_MOVEs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create the virtual port link aggregation group.
 *
 * \param [in] unit Device unit number.
 * \param [in] t_id The front panel trunk ID.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_create_virtual(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    int svp, dvp;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    dvp = svp = t_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_create_virtual_svp(unit, svp));

    t_info->l2_dest = dvp;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Extract front panel trunk failover flags from trunk configuration flags.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags Trunk Configuration Flags.
 * \param [in] fail_flags Trunk Failover Flags.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_failover_fp_flags_extract(
    int unit,
    uint32_t flags,
    uint32_t *fail_flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(fail_flags, SHR_E_PARAM);

    *fail_flags = 0;

    if (flags & BCM_TRUNK_FLAG_FAILOVER_NEXT) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_NEXT;
    } else if (flags & BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL;
    } else if (flags & BCM_TRUNK_FLAG_FAILOVER_ALL) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_ALL;
    } else if (flags & BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set front panel trunk failover members to a specific port member.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [in] psc Port Selection Criteria.
 * \param [in] ftp_count Failto Port Count.
 * \param [in] ftp Failto Port Array.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_failover_fp_set(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_gport_t fail_port,
    int psc,
    int ftp_count,
    bcm_gport_t *ftp)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    uint64_t value;
    int pre_lt_count, i, dunit, system_port;

    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(psc);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FAILOVERs, &lte_hdl));

    value = BCM_GPORT_MODPORT_PORT_GET(fail_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    if (ftp_count == 0) {
        rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL);

        if (SHR_SUCCESS(rv) || rv == SHR_E_NOT_FOUND) {
            SHR_EXIT();
        } else {
            SHR_ERR_EXIT(rv);
        }
    }

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);

    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, FAILOVER_CNTs, &value));
        pre_lt_count = value & 0xffffffff;

        for (i = 0; i < ftp_count; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_resolve(unit, ftp[i],
                                              NULL, NULL, &system_port, NULL));
            value = system_port;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_PORT_SYSTEMs,
                                             i, &value, 1));
        }

        if (pre_lt_count != ftp_count) {
            value = ftp_count;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, FAILOVER_CNTs, value));
        }

        if (pre_lt_count > 0 && ftp_count < pre_lt_count) {
            for (i = ftp_count; i < pre_lt_count; i++) {
                value = 0;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_PORT_SYSTEMs,
                                                 i, &value, 1));
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    } else if (rv == SHR_E_NOT_FOUND) {
        pre_lt_count = 0;
        for (i = 0; i < ftp_count; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_resolve(unit, ftp[i],
                                              NULL, NULL, &system_port, NULL));
            value = system_port;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_PORT_SYSTEMs,
                                             i, &value, 1));
        }

        if (pre_lt_count != ftp_count) {
            value = ftp_count;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, FAILOVER_CNTs, value));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get front panel trunk failover members of a specific port member.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [out] psc Port Selection Criteria.
 * \param [in] ftp_max Failto Port Max Count.
 * \param [out] ftp Failto Port Array.
 * \param [out] ftp_count Failto Port Count.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_failover_fp_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_gport_t fail_port,
    int *psc,
    int ftp_max,
    bcm_gport_t *ftp,
    int *ftp_count)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    uint32_t cnt;
    int lt_count, i, dunit, system_port;

    SHR_FUNC_ENTER(unit);

    if (ftp_max < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (ftp_count) {
        *ftp_count = 0;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FAILOVERs, &lte_hdl));

    value = BCM_GPORT_MODPORT_PORT_GET(fail_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    if (psc) {
        *psc = -1;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, FAILOVER_CNTs, &value));
    lt_count = value & 0xffffffff;

    if ((lt_count > ftp_max) && (ftp_max > 0)) {
        lt_count = ftp_max;
    }

    if (ftp_count) {
        *ftp_count = lt_count;
    }

    if (ftp_max == 0) {
        SHR_EXIT();
    }

    for (i = 0; i < lt_count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(lte_hdl, FAILOVER_PORT_SYSTEMs,
                                         i, &value, 1, &cnt));
        system_port = value & 0xffffffff;
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_gport_construct(unit, system_port, &ftp[i]));
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable/Disable the fabric trunk port failover.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [in] enable True is enable the fabric trunk failover per port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_failover_fabric_enable_set(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_gport_t fail_port,
    int enable)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    uint64_t value;
    int modid, modid_is_local, failover_enable, dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    modid = BCM_GPORT_MODPORT_MODID_GET(fail_port);
    SHR_IF_ERR_CONT
        (bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local));
    if (SHR_FUNC_ERR() || !modid_is_local) {
        SHR_ERR_EXIT(SHR_E_PORT);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_TRUNKs, &lte_hdl));

    value = BCM_GPORT_MODPORT_PORT_GET(fail_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, TRUNK_SYSTEM_FAILOVERs, &value));
        failover_enable = value & 0xffffffff;
        if (failover_enable != enable) {
            if (enable) {
                value = enable;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(lte_hdl, TRUNK_SYSTEM_FAILOVERs,
                                           value));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                                        BCMLT_PRIORITY_NORMAL));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                        BCMLT_PRIORITY_NORMAL));
            }
        }
    } else if (rv == SHR_E_NOT_FOUND) {
        if (enable) {
            value = enable;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, TRUNK_SYSTEM_FAILOVERs, value));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_INSERT,
                                    BCMLT_PRIORITY_NORMAL));
        } else {
            SHR_EXIT();
        }
    } else {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the enable/disable status of the fabric trunk port failover.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [in] enable True is enable the fabric trunk failover per port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_failover_fabric_enable_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_gport_t fail_port,
    int *enable)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    uint64_t value;
    int modid, modid_is_local, dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    modid = BCM_GPORT_MODPORT_MODID_GET(fail_port);
    SHR_IF_ERR_CONT
        (bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local));
    if (SHR_FUNC_ERR() || !modid_is_local) {
        SHR_ERR_EXIT(SHR_E_PORT);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_TRUNKs, &lte_hdl));

    value = BCM_GPORT_MODPORT_PORT_GET(fail_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, TRUNK_SYSTEM_FAILOVERs, &value));
        *enable = value & 0xffffffff;
        SHR_EXIT();
    } else if (rv == SHR_E_NOT_FOUND) {
        *enable = 0;
        SHR_EXIT();
    } else {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}


/*!
 * \brief Extract fabric trunk failover flags from trunk configuration flags.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags Trunk Configuration Flags.
 * \param [in] fail_flags Trunk Failover Flags.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_failover_fabric_flags_extract(
    int unit,
    uint32_t flags,
    uint32_t *fail_flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(fail_flags, SHR_E_PARAM);

    *fail_flags = 0;

    if (flags & BCM_TRUNK_FLAG_FAILOVER_ALL) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_ALL;
    } else if (flags & BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set fabric trunk port failover port.
 *
 * \param [in] unit Unit Number.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [in] port Failto port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_failover_fabric_port_set(
    int unit,
    bcm_gport_t fail_port,
    int port)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    uint64_t value;
    int modid, modid_is_local, dunit;
    bcmlt_opcode_t opcode;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    modid = BCM_GPORT_MODPORT_MODID_GET(fail_port);
    SHR_IF_ERR_CONT
        (bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local));
    if (SHR_FUNC_ERR() || !modid_is_local) {
        SHR_ERR_EXIT(SHR_E_PORT);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_SYSTEM_FAILOVER_PORTs, &lte_hdl));

    value = BCM_GPORT_MODPORT_PORT_GET(fail_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (SHR_SUCCESS(rv)) {
        if (port < 0) {
            opcode = BCMLT_OPCODE_DELETE;
        } else {
            value = port;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, FAILOVER_PORT_IDs, value));
            opcode = BCMLT_OPCODE_UPDATE;
        }
    } else if (rv == SHR_E_NOT_FOUND) {
        if (port < 0) {
            SHR_EXIT();
        } else {
            value = port;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, FAILOVER_PORT_IDs, value));
            opcode = BCMLT_OPCODE_INSERT;
        }
    } else {
        SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, opcode, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set fabric trunk failover members to a specific port member.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [in] psc Port Selection Criteria.
 * \param [in] ftp_count Failto Port Count.
 * \param [in] ftp Failto Port Array.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_failover_fabric_set(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_gport_t fail_port,
    int psc,
    int ftp_count,
    bcm_gport_t *ftp)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    uint64_t value;
    int pre_lt_count, i, dunit, modid, port, modid_is_local;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_SYSTEM_FAILOVERs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_SYSTEM_IDs, value));

    if (ftp_count == 0) {
        rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL);
        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        SHR_EXIT();
    }

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);

    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, FAILOVER_CNTs, &value));
        pre_lt_count = value & 0xffffffff;

        for (i = 0; i < ftp_count; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_resolve(unit, ftp[i],
                                              &modid, &port, NULL, NULL));
            SHR_IF_ERR_CONT
                (bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local));
            if (SHR_FUNC_ERR() || !modid_is_local) {
                SHR_ERR_EXIT(SHR_E_PORT);
            }
            value = port;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_PORT_IDs,
                                             i, &value, 1));
        }

        if (pre_lt_count != ftp_count) {
            value = ftp_count;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, FAILOVER_CNTs, value));
        }

        if (pre_lt_count > 0 && ftp_count < pre_lt_count) {
            for (i = ftp_count; i < pre_lt_count; i++) {
                value = 0;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_PORT_IDs,
                                                 i, &value, 1));
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    } else if (rv == SHR_E_NOT_FOUND) {
        pre_lt_count = 0;
        for (i = 0; i < ftp_count; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_resolve(unit, ftp[i],
                                              &modid, &port, NULL, NULL));
            SHR_IF_ERR_CONT
                (bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local));
            if (SHR_FUNC_ERR() || !modid_is_local) {
                SHR_ERR_EXIT(SHR_E_PORT);
            }
            value = port;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_PORT_IDs,
                                             i, &value, 1));
        }

        if (pre_lt_count != ftp_count) {
            value = ftp_count;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, FAILOVER_CNTs, value));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get fabric trunk failover members of a specific port member.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [out] psc Port Selection Criteria.
 * \param [in] ftp_max Failto Port Max Count.
 * \param [out] ftp Failto Port Array.
 * \param [out] ftp_count Failto Port Count.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_failover_fabric_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_gport_t fail_port,
    int *psc,
    int ftp_max,
    bcm_gport_t *ftp,
    int *ftp_count)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int lt_count, i, dunit, port;
    uint32_t count;

    SHR_FUNC_ENTER(unit);

    if (ftp_max < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (ftp_count) {
        *ftp_count = 0;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_SYSTEM_FAILOVERs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_SYSTEM_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    if (psc) {
        *psc = -1;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, FAILOVER_CNTs, &value));
    lt_count = value & 0xffffffff;

    if ((lt_count > ftp_max) && (ftp_max > 0)) {
        lt_count = ftp_max;
    }

    if (ftp_count) {
        *ftp_count = lt_count;
    }

    if (ftp_max == 0) {
        SHR_EXIT();
    }

    for (i = 0; i < lt_count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(lte_hdl, FAILOVER_PORT_IDs,
                                         i, &value, 1, &count));
        port = value & 0xffffffff;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_port_gport_get(unit, port, &ftp[i]));
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update front panel trunk failover configuration for a specific trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_type Trunk Type.
 * \param [in] psc Port Selection Criteria.
 * \param [in] fail_flags Failover Configuration Flags.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [in] ftp_max Failto Port Max Number.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_failover_update_fp(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    int psc,
    uint32_t fail_flags,
    bcm_gport_t fail_port,
    int ftp_max,
    int member_count,
    bcm_trunk_member_t *member_array)
{
    int i, j;
    int local, next, hw_count, modid, modid_is_local;
    bcm_gport_t *ftp = NULL;
    int rv;

    SHR_FUNC_ENTER(unit);

    /* Where is failover port in the trunk member list? */
    for (i = 0; i < member_count; i++) {
        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            continue;
        }
        if (member_array[i].gport == fail_port) {
            break;
        }
    }

    /* Port is not in the trunk member list! */
    if ((0 != member_count) && (i == member_count)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    if (member_count == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_trunk_failover_set(unit, t_id, t_type,
                                         fail_port, psc, 0, NULL));
        SHR_EXIT();
    }

    if (fail_flags) {
        switch (fail_flags) {
            case BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL:
                next = TRUE;
                local = TRUE;
                break;
            case BCM_TRUNK_FLAG_FAILOVER_NEXT:
                next = TRUE;
                local = FALSE;
                break;
            case BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL:
                next = FALSE;
                local = TRUE;
                break;
            case BCM_TRUNK_FLAG_FAILOVER_ALL:
                next = FALSE;
                local = FALSE;
                break;
            default:
                /* Illegal flags setting */
                SHR_ERR_EXIT(SHR_E_PARAM);
        }

        SHR_ALLOC(ftp, sizeof(bcm_gport_t) * member_count, "bcmTrunkGport");
        SHR_NULL_CHECK(ftp, SHR_E_MEMORY);

        hw_count = 0;

        for (j = ((i + 1) % member_count);
             j != i;
             j = ((j + 1) % member_count)) {
            modid = BCM_GPORT_MODPORT_MODID_GET(member_array[j].gport);

            if (local) {
                rv = bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local);
                if (SHR_FAILURE(rv) || !modid_is_local) {
                    continue;
                }
            }

            if (member_array[j].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }

            if (hw_count == ftp_max) {
                break;
            }

            ftp[hw_count++] = member_array[j].gport;

            if (next) {
                break;
            }
        }

        SHR_IF_ERR_CONT
            (xfs_ltsw_trunk_failover_set(unit, t_id, t_type,
                                         fail_port, psc, hw_count, ftp));

        SHR_FREE(ftp);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update front panel trunk failover configuration for a specific trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_type Trunk Type.
 * \param [in] psc Port Selection Criteria.
 * \param [in] fail_flags Failover Configuration Flags.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [in] ftp_max Failto Port Max Number.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_failover_update_fabric(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    int psc,
    uint32_t fail_flags,
    bcm_gport_t fail_port,
    int ftp_max,
    int member_count,
    bcm_trunk_member_t *member_array)
{
    int i, hw_count;
    bcm_gport_t *ftp = NULL;

    SHR_FUNC_ENTER(unit);

    if (member_count == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_trunk_failover_set(unit, t_id, t_type,
                                         fail_port, psc, 0, NULL));
        SHR_EXIT();
    }

    if (fail_flags) {
        switch (fail_flags) {
            case BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL:
            case BCM_TRUNK_FLAG_FAILOVER_ALL:
                break;
            default:
                /* Illegal flags setting */
                SHR_ERR_EXIT(SHR_E_PARAM);
        }

        SHR_ALLOC(ftp, sizeof(bcm_gport_t) * member_count, "bcmTrunkGport");
        SHR_NULL_CHECK(ftp, SHR_E_MEMORY);

        hw_count = 0;
        for (i = 0; i < member_count; i++) {
            if (member_array[i].flags &
                BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }
            if (hw_count == ftp_max) {
                break;
            }
            ftp[hw_count++] = member_array[i].gport;
        }

        SHR_IF_ERR_CONT
            (xfs_ltsw_trunk_failover_set(unit, t_id, t_type,
                                         fail_port, psc, hw_count, ftp));

        SHR_FREE(ftp);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the front panel trunk member before setting the trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] member Trunk Member.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_params_validate_fp_member(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_member_t *member)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit, system_port, src_t_id;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_gport_resolve(unit, member->gport,
                                      NULL, NULL, &system_port, NULL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_SYSTEM_PORT_TABLEs, &lte_hdl));

    value = system_port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SYSTEM_SOURCEs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, L2_IIFs, &value));

    (void)bcmlt_entry_free(lte_hdl);
    lte_hdl = BCMLT_INVALID_HDL;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_L2_IIF_ATTRIBUTES_TABLEs, &lte_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_IIFs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, IS_SRC_LAGs, &value));

    if (value) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, SRC_LAG_IDs, &value));
        src_t_id = value & 0xffffffff;
        if (src_t_id != t_id) {
            SHR_ERR_EXIT(SHR_E_PORT);
        }
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the front panel trunk parameters before setting the trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_params_validate_fp(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member)
{
    int i;

    SHR_FUNC_ENTER(unit);

    /* Validate the PSC value */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_psc_decode(unit, trunk_info->psc, NULL));

    /* Validate the member flags */
    for (i = 0; i < member_count; i++) {
        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            if (member_array[i].flags & BCM_TRUNK_MEMBER_INGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_UNICAST_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_IPMC_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_L2MC_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_BCAST_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_DLF_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_IPMC_EGRESS_DISABLE) {
            if (trunk_info->ipmc_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_L2MC_EGRESS_DISABLE) {
            if (trunk_info->mc_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_BCAST_EGRESS_DISABLE) {
            if (trunk_info->dlf_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_DLF_EGRESS_DISABLE) {
            if (trunk_info->dlf_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_DGM_ALTERNATE) {
            if (!ltsw_xfs_trunk_dlb_validate_dgm_feature(unit)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
    }

    /* Validate the trunk information */
    if (member_count > 0 && trunk_info->dlf_index >= member_count) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Validate the trunk member l2_if */
    for (i = 0; i < member_count; i++) {
        if (ltsw_xfs_trunk_gport_is_channelized_access_port(unit,
                                                      member_array[i].gport)) {
            if (ltsw_xfs_trunk_dlb_is_configured(unit, trunk_info->psc)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_params_validate_fp_member(unit, t_id,
                                                      &member_array[i]));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the fabric trunk member before setting the trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] member Trunk Member.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_params_validate_fabric_member(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_member_t *member)
{
    int modid, modid_is_local = 0;
    int port, is_higig_port = 0;
    int tgid, id;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_resolve(unit, member->gport,
                                      &modid, &port, &tgid, &id));
    if ((tgid != -1) || (id != -1)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local));

    if (!modid_is_local) {
        SHR_ERR_EXIT(SHR_E_PORT);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &port));
    is_higig_port = bcmi_ltsw_port_is_type(unit,
                                           port,
                                           BCMI_LTSW_PORT_TYPE_HG);
    if (!is_higig_port) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the fabric trunk parameters before setting the trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_params_validate_fabric(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member)
{
    int i;

    SHR_FUNC_ENTER(unit);

    /* Validate the PSC value */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_psc_decode(unit, trunk_info->psc, NULL));

    /* Validate the trunk member flags */
    for (i = 0; i < member_count; i++) {
        if (member_array[i].flags & BCM_TRUNK_MEMBER_DGM_ALTERNATE) {
            if (!ltsw_xfs_trunk_dlb_validate_dgm_feature(unit)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
    }

    /* Do not support next and next_local flags in TD4. */
    if ((trunk_info->flags & BCM_TRUNK_FLAG_FAILOVER_NEXT) ||
        (trunk_info->flags & BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    /* Validate the trunk member l2_if */
    for (i = 0; i < member_count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_params_validate_fabric_member(unit, t_id,
                                                          &member_array[i]));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the virtual port link aggregation group member before setting.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] member Trunk Member.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_params_validate_virtual_member(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_member_t *member)
{
    int vp;
    bcm_if_t egress_if;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_gport_virtual_port_resolve(unit, member->gport, &vp));

    if (ltsw_xfs_trunk_virtual_port_is_network(unit, vp)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_egress_obj_get(unit, member->gport,
                                                   &egress_if));
        if (egress_if <= 0) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the virtual port link aggregation group parameters before setting.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_params_validate_virtual(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member)
{
    int i;

    SHR_FUNC_ENTER(unit);

    /* Validate the PSC value */
    switch (trunk_info->psc) {
        case BCM_TRUNK_PSC_PORTFLOW:
        case BCM_TRUNK_PSC_RANDOMIZED:
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (trunk_info->flags & BCM_TRUNK_FLAG_WEIGHTED) {
        if (trunk_info->flags & ~BCM_TRUNK_FLAG_WEIGHTED) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_virtual_weighted_size_decode(unit, member_count,
                                                         NULL));
        /* Validate the trunk member flags */
        for (i = 0; i < member_count; i++) {
            if (member_array[i].flags) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
    } else {
        if (trunk_info->flags) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    /* Validate the trunk member l2_if */
    for (i = 0; i < member_count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_params_validate_virtual_member(unit, t_id,
                                                           &member_array[i]));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the front panel trunk group configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_type Trunk Type.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 * \param [out] trunk_info Trunk Information.
 * \param [in] member_max Max Number of Trunk Members.
 * \param [out] member_array Trunk Member Array.
 * \param [inout] member_count Trunk Member Count.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_get_dlb(
    int unit,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    bcm_trunk_info_t *trunk_info,
    int member_max,
    bcm_trunk_member_t *member_array,
    int *member_count)
{
    bcmi_ltsw_dlb_type_t dlb_type;
    bcmi_ltsw_dlb_id_t dlb_id;
    bcmint_trunk_info_t *t_info = t_priv->t_info;
    bcmi_ltsw_dlb_config_t dlb_config;
    int rv;

    SHR_FUNC_ENTER(unit);

    sal_memset(&dlb_config, 0, sizeof(dlb_config));

    if (trunk_info) {
        switch (t_type) {
            case bcmintTrunkTypeFrontPanel:
                dlb_type = bcmi_dlb_type_fp_trunk;
                break;
            case bcmintTrunkTypeFabric:
                dlb_type = bcmi_dlb_type_fabric_trunk;
                break;
            default:
                SHR_ERR_EXIT(SHR_E_PARAM);
        }
        dlb_id = t_info->dlb_id;
        rv = bcmi_ltsw_dlb_config_get(unit, dlb_type, dlb_id, &dlb_config);
        if (SHR_SUCCESS(rv)) {
            trunk_info->dgm.bias =
                        dlb_config.alternate_config.alternate_path_bias;
            trunk_info->dgm.cost =
                        dlb_config.alternate_config.alternate_path_cost;
            trunk_info->dgm.threshold =
                        dlb_config.alternate_config.primary_path_threshold;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the front panel trunk group configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 * \param [out] trunk_info Trunk Information.
 * \param [in] member_max Max Number of Trunk Members.
 * \param [out] member_array Trunk Member Array.
 * \param [inout] member_count Trunk Member Count.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_get_fp(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    bcm_trunk_info_t *trunk_info,
    int member_max,
    bcm_trunk_member_t *member_array,
    int *member_count)
{
    bcmint_trunk_type_t t_type = bcmintTrunkTypeFrontPanel;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    if (t_info && ltsw_xfs_trunk_dlb_is_configured(unit, t_info->psc)) {
        if (trunk_info) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_get_dlb(unit, t_type, t_id, t_priv, trunk_info,
                                        member_max, member_array,
                                        member_count));
        }
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the fabric trunk group configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 * \param [out] trunk_info Trunk Information.
 * \param [in] member_max Max Number of Trunk Members.
 * \param [out] member_array Trunk Member Array.
 * \param [inout] member_count Trunk Member Count.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_get_fabric(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    bcm_trunk_info_t *trunk_info,
    int member_max,
    bcm_trunk_member_t *member_array,
    int *member_count)
{
    bcmint_trunk_type_t t_type = bcmintTrunkTypeFabric;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    if (t_info && ltsw_xfs_trunk_dlb_is_configured(unit, t_info->psc)) {
        if (trunk_info) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_get_dlb(unit, t_type, t_id, t_priv, trunk_info,
                                        member_max, member_array,
                                        member_count));
        }
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the virtual port link aggregation group configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 * \param [out] trunk_info Trunk Information.
 * \param [in] member_max Max Number of Trunk Members.
 * \param [out] member_array Trunk Member Array.
 * \param [inout] member_count Trunk Member Count.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_get_virtual(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    bcm_trunk_info_t *trunk_info,
    int member_max,
    bcm_trunk_member_t *member_array,
    int *member_count)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    bcmint_trunk_info_t *t_info = t_priv->t_info;
    int i, dunit, rv;
    uint64_t value;
    const char *symbol;
    int weighted_size, dvp;
    uint32_t count;
    bcm_gport_t gport;

    SHR_FUNC_ENTER(unit);

    if (member_max > 0) {
        dunit = bcmi_ltsw_dev_dunit(unit);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TRUNK_VP_WEIGHTEDs, &lte_hdl));
        value = t_info->l2_dest;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, TRUNK_VP_IDs, value));
        rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL);
        if (SHR_SUCCESS(rv)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_get(lte_hdl, WEIGHTED_SIZEs,
                                              &symbol));
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_virtual_weighted_size_encode(unit, symbol,
                                                             &weighted_size));
            if (member_count && *member_count > weighted_size) {
                SHR_ERR_EXIT(SHR_E_INTERNAL);
            }
            for (i = 0; i < *member_count; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_get(lte_hdl, DVPs, i,
                                                 &value, 1, &count));
                dvp = value & 0xffffffff;
                SHR_IF_ERR_VERBOSE_EXIT
                    (ltsw_xfs_trunk_gport_virtual_port_construct(unit, dvp,
                                                                 &gport));
                member_array[i].flags = 0;
                member_array[i].gport = gport;
                member_array[i].dynamic_scaling_factor = 0;
                member_array[i].dynamic_load_weight = 0;
                member_array[i].dynamic_queue_size_weight = 0;
            }
            (void)bcmlt_entry_free(lte_hdl);
            lte_hdl = BCMLT_INVALID_HDL;
            SHR_EXIT();
        } else {
            if (rv != SHR_E_NOT_FOUND) {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
        }
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the dynamic load balance configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_type Trunk Type.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_dlb(
    int unit,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    int dlb_old = 0, dlb_new = 0;
    int dlb_add = 0, dlb_delete = 0, dlb_update = 0;
    int assignment_mode;
    int i, local_port, member_cnt;
    bool dlb_id_is_created = false;
    bcmi_ltsw_dlb_type_t dlb_type;
    bcmi_ltsw_dlb_id_t dlb_id;
    bcmi_ltsw_dlb_config_t dlb_config;
    bcmi_ltsw_dlb_member_attribute_t attribute;
    bcmi_ltsw_dlb_member_t *dlb_member = NULL;
    bcmint_trunk_info_t *t_info = NULL;
    int rv;

    SHR_FUNC_ENTER(unit);

    if (t_priv) {
        t_info = t_priv->t_info;
        if (t_info && ltsw_xfs_trunk_dlb_is_configured(unit, t_info->psc)) {
            if (t_info->member_count > 0) {
                dlb_old = 1;
            }
        }
    }
    if (trunk_info && ltsw_xfs_trunk_dlb_is_configured(unit, trunk_info->psc)) {
        if (member_count > 0) {
            dlb_new = 1;
        }
    }

    if (dlb_old && dlb_new) {
        dlb_update = 1;
    } else if (dlb_new) {
        dlb_add = 1;
    } else if (dlb_old) {
        dlb_delete = 1;
    } else {
        SHR_EXIT();
    }

    switch (t_type) {
        case bcmintTrunkTypeFrontPanel:
            dlb_type = bcmi_dlb_type_fp_trunk;
            break;
        case bcmintTrunkTypeFabric:
            dlb_type = bcmi_dlb_type_fabric_trunk;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (dlb_add) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_dlb_id_create(unit, 0, dlb_type, &dlb_id));
        dlb_id_is_created = true;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_dlb_find_dlb_id(unit, t_type, t_id, t_priv,
                                            &dlb_id));
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_dlb_set_dlb_id(unit, t_type, t_id, t_priv, -1));
    }

    if (dlb_add || dlb_update) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_psc_to_dlb_assignment_mode(unit, trunk_info->psc,
                                                       &assignment_mode));
        dlb_config.inactivity_time = trunk_info->dynamic_age;
        dlb_config.assignment_mode = assignment_mode;
        dlb_config.flowset_size = trunk_info->dynamic_size;

        SHR_ALLOC(dlb_member, sizeof(bcmi_ltsw_dlb_member_t) * member_count,
                  "bcmXfsTrunkDlbMbr");
        SHR_NULL_CHECK(dlb_member, SHR_E_MEMORY);

        member_cnt = 0;
        for (i = 0; i < member_count; i++) {
            if (member_array[i].flags &
                BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }
            if (member_array[i].flags &
                BCM_TRUNK_MEMBER_UNICAST_EGRESS_DISABLE) {
                continue;
            }
            if (member_array[i].flags &
                BCM_TRUNK_MEMBER_DGM_ALTERNATE) {
                continue;
            }

            rv = bcmi_ltsw_port_gport_validate(unit, member_array[i].gport,
                                               &local_port);
            /* If it is not local member, continue */
            if (SHR_FAILURE(rv)) {
                continue;
            }
            dlb_member[member_cnt++].port_id = local_port;
        }
        dlb_config.num_paths = member_cnt;
        dlb_config.member = &dlb_member[0];

        if (ltsw_xfs_trunk_dlb_validate_dgm_feature(unit)) {
            for (i = 0; i < member_count; i++) {
                if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                    continue;
                }
                if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_UNICAST_EGRESS_DISABLE) {
                    continue;
                }
                if (!(member_array[i].flags &
                    BCM_TRUNK_MEMBER_DGM_ALTERNATE)) {
                    continue;
                }

                rv = bcmi_ltsw_port_gport_validate(unit, member_array[i].gport,
                                                   &local_port);
                /* If it is not local member, continue */
                if (SHR_FAILURE(rv)) {
                    continue;
                }
                dlb_member[member_cnt++].port_id = local_port;
            }
            dlb_config.alternate_num_paths = member_cnt - dlb_config.num_paths;
            dlb_config.alternate_member = &dlb_member[dlb_config.num_paths];

            dlb_config.alternate_config.primary_path_threshold =
                                                trunk_info->dgm.threshold;
            dlb_config.alternate_config.alternate_path_cost =
                                                trunk_info->dgm.cost;
            dlb_config.alternate_config.alternate_path_bias =
                                                trunk_info->dgm.bias;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_dlb_config_set(unit, dlb_type, dlb_id, &dlb_config));
    } else if (dlb_delete) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_dlb_config_set(unit, dlb_type, dlb_id, NULL));
    }

    if (dlb_update || dlb_delete) {
        for (i = 0; i < t_info->member_count; i++) {
            if (t_priv->member_array[i].flags &
                BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }
            if (t_priv->member_array[i].flags &
                BCM_TRUNK_MEMBER_UNICAST_EGRESS_DISABLE) {
                continue;
            }
            rv = bcmi_ltsw_port_gport_validate(unit,
                                               t_priv->member_array[i].gport,
                                               &local_port);
            /* If it is not local member, continue */
            if (SHR_FAILURE(rv)) {
                continue;
            }
            attribute.scaling_factor = BCMI_LTSW_DLB_SCALING_FACTOR_INVALID;
            attribute.load_weight = BCMI_LTSW_DLB_LOAD_WEIGHT_INVALID;
            attribute.qsize_weight = BCMI_LTSW_DLB_QUEUE_SIZE_WEIGHT_INVALID;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_dlb_member_attribute_set(unit, local_port, dlb_type,
                                                    &attribute));
        }
    }

    if (dlb_update || dlb_add) {
        for (i = 0; i < member_count; i++) {
            if (member_array[i].flags &
                BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }
            if (member_array[i].flags &
                BCM_TRUNK_MEMBER_UNICAST_EGRESS_DISABLE) {
                continue;
            }
            rv = bcmi_ltsw_port_gport_validate(unit,
                                               member_array[i].gport,
                                               &local_port);
            /* If it is not local member, continue */
            if (SHR_FAILURE(rv)) {
                continue;
            }
            attribute.scaling_factor = member_array[i].dynamic_scaling_factor;
            attribute.load_weight = member_array[i].dynamic_load_weight;
            attribute.qsize_weight = member_array[i].dynamic_queue_size_weight;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_dlb_member_attribute_set(unit, local_port, dlb_type,
                                                    &attribute));
        }
    }

    if (dlb_add || dlb_update) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_dlb_set_dlb_id(unit, t_type, t_id, t_priv, dlb_id));
    } else if (dlb_delete) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_dlb_id_destroy(unit, dlb_type, dlb_id));
    }

exit:
    if (dlb_id_is_created && SHR_FUNC_ERR()) {
        (void)bcmi_ltsw_dlb_id_destroy(unit, dlb_type, dlb_id);
    }
    if (dlb_member) {
        SHR_FREE(dlb_member);
        dlb_member = NULL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk group configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fp_group(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int i, dunit;
    const char *lb_mode = NULL;
    uint64_t value;
    int member_cnt;
    bool member_disabled;
    int system_port, l2_eif;
    bcmint_trunk_info_t *t_info = t_priv->t_info;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNKs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));

    if (member_count <= 0) {
        rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL);
        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_psc_decode(unit, trunk_info->psc, &lb_mode));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(lte_hdl, LB_MODEs, lb_mode));

    member_cnt = 0;

    for (i = 0; i < member_count; i++) {
        member_disabled = false;

        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            member_disabled = true;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_UNICAST_EGRESS_DISABLE) {
            member_disabled = true;
        }

        value = member_disabled ? 1 : 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(lte_hdl, UC_EGR_BLOCKs,
                                         member_cnt, &value, 1));

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_gport_resolve(unit, member_array[i].gport,
                                          NULL, NULL,
                                          &system_port, &l2_eif));
        value = system_port;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(lte_hdl, UC_MEMBER_PORT_SYSTEMs,
                                         member_cnt, &value, 1));
        if (ltsw_xfs_trunk_gport_is_channelized_access_port(unit,
                                                       member_array[i].gport)) {
            value = l2_eif;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, MEMBER_L2_EIFs,
                                             member_cnt, &value, 1));
        }
        member_cnt++;
    }

    if ((member_cnt >= 0) && (member_cnt < t_info->member_count)) {
        for (i = member_cnt; i < t_info->member_count; i++) {
            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, UC_EGR_BLOCKs,
                                             i, &value, 1));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, UC_MEMBER_PORT_SYSTEMs,
                                             i, &value, 1));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, MEMBER_L2_EIFs,
                                             i, &value, 1));
        }
    }

    value = member_cnt;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, UC_MEMBER_CNTs, value));
    if (value < 1) {
        value = 1;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, UC_MAX_MEMBERSs, value));

    member_cnt = 0;

    for (i = 0; i < member_count; i++) {
        member_disabled = false;

        if (trunk_info->dlf_index != BCM_TRUNK_UNSPEC_INDEX &&
            trunk_info->dlf_index != i) {
            member_disabled = true;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            member_disabled = true;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_IPMC_EGRESS_DISABLE) {
            member_disabled = true;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_L2MC_EGRESS_DISABLE) {
            member_disabled = true;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_BCAST_EGRESS_DISABLE) {
            member_disabled = true;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_DLF_EGRESS_DISABLE) {
            member_disabled = true;
        }

        value = member_disabled ? 1 : 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(lte_hdl, NONUC_EGR_BLOCKs,
                                         member_cnt, &value, 1));

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_gport_resolve(unit, member_array[i].gport,
                                          NULL, NULL,
                                          &system_port, NULL));
        value = system_port;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(lte_hdl, NONUC_MEMBER_PORT_SYSTEMs,
                                         member_cnt, &value, 1));

        member_cnt++;
    }

    if ((member_cnt >= 0) && (member_cnt < t_info->member_count)) {
        for (i = member_cnt; i < t_info->member_count; i++) {
            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, NONUC_EGR_BLOCKs,
                                             i, &value, 1));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, NONUC_MEMBER_PORT_SYSTEMs,
                                             i, &value, 1));
        }
    }

    value = member_cnt;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, NONUC_MEMBER_CNTs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Migrate L2 ingress interface attributes to front panel trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] from_l2_iif Migrate from L2 ingress interface.
 * \param [in] to_l2_iif Migrate to L2 ingress interface.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fp_attr_migrate_l2_iif(
    int unit,
    bcmint_trunk_id_t t_id,
    int from_l2_iif,
    int to_l2_iif)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_L2_IIF_TABLEs, &lte_hdl));

    value = from_l2_iif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_IIFs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    value = to_l2_iif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_IIFs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Migrate L2 ingress interface attributes to front panel trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] from_l2_iif Migrate from L2 ingress interface.
 * \param [in] to_l2_iif Migrate to L2 ingress interface.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fp_attr_migrate_l2_iif_attribute(
    int unit,
    bcmint_trunk_id_t t_id,
    int from_l2_iif,
    int to_l2_iif)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_L2_IIF_ATTRIBUTES_TABLEs, &lte_hdl));

    value = from_l2_iif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_IIFs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    value = to_l2_iif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_IIFs, value));

    value = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, IS_SRC_LAGs, value));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SRC_LAG_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Migrate L2 ingress interface attributes to front panel trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] from_l2_iif Migrate from L2 ingress interface.
 * \param [in] to_l2_iif Migrate to L2 ingress interface.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fp_attr_migrate_egr_l2_oif(
    int unit,
    bcmint_trunk_id_t t_id,
    int from_egr_l2_oif,
    int to_egr_l2_oif)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L2_OIFs, &lte_hdl));

    value = from_egr_l2_oif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_OIFs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    value = to_egr_l2_oif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_OIFs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Migrate front panel trunk attribute to new joining members.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fp_attr_migrate(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    bcm_gport_t gport;
    int trunk_l2_eif, l2_eif, new_trunk = 0;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    if (t_update->num_leaving > 0) {
        gport = t_update->leaving_members[0];
    } else if (t_update->num_staying > 0) {
        gport = t_update->staying_members[0];
    } else if (t_update->num_joining > 0) {
        gport = t_update->joining_members[0];
        /*Both num_leaving and num_staying are zeroes. This is a newly
         * created trunk group. There is no range properties to migrate.*/
        new_trunk = 1;
    } else {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_gport_resolve(unit, gport, NULL, NULL, NULL, &l2_eif));

    trunk_l2_eif = t_info->l2_dest;

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_fp_attr_migrate_l2_iif(unit, t_id,
                                                      l2_eif, trunk_l2_eif));
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_fp_attr_migrate_l2_iif_attribute(unit, t_id,
                                                      l2_eif, trunk_l2_eif));
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_fp_attr_migrate_egr_l2_oif(unit, t_id,
                                                      l2_eif, trunk_l2_eif));
    if (!new_trunk) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_vlan_range_update(unit, gport,
                 t_update->num_joining, t_update->joining_members,
                 t_update->num_leaving, t_update->leaving_members));
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk port attributes.
 *
 * \param [in] unit Unit Number.
 * \param [in] modid Module Number.
 * \param [in] port Port Number.
 * \param [in] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fp_port_attr(
    int unit,
    int system_port,
    int l2_eif)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit, l2_iif;

    SHR_FUNC_ENTER(unit);

    /* Get PORT_SYSTEM_ID for specific modid */
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_SYSTEM_PORT_TABLEs, &lte_hdl));

    value = system_port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SYSTEM_SOURCEs, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, L2_IIFs, &value));
    l2_iif = value & 0xffffffff;
    if (l2_iif != l2_eif) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, L2_IIFs, l2_eif));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, lte_hdl,
                                      BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk member configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fp_member(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    int i, system_port, l2_eif;
    bcmint_trunk_info_t *t_info;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < member_count; i++) {
        if (member_array[i].flags & BCM_TRUNK_MEMBER_INGRESS_DISABLE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_resolve(unit, member_array[i].gport,
                                              NULL, NULL, &system_port, &l2_eif));
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_update_fp_port_attr(unit, system_port, l2_eif));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_resolve(unit, member_array[i].gport,
                                              NULL, NULL, &system_port, NULL));
            t_info = t_priv->t_info;
            l2_eif = t_info->l2_dest;
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_update_fp_port_attr(unit, system_port, l2_eif));
        }
    }

    for (i = 0; i < t_update->num_leaving; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_gport_resolve(unit, t_update->leaving_members[i],
                                          NULL, NULL, &system_port, &l2_eif));
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_update_fp_port_attr(unit, system_port, l2_eif));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk failover configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fp_failover(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    int i;
    bcm_gport_t fail_port;
    int modid, modid_is_local;
    uint32_t fail_flags;
    bcmint_trunk_info_t *t_info = t_priv->t_info;
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_trunk_failover_flags_extract(unit, trunk_info->flags,
                                               bcmintTrunkTypeFrontPanel,
                                               &fail_flags));

    if (fail_flags != 0 || member_count == 0) {
        /* Disable hardware failover for old trunk ports */
        for (i = 0; i < t_info->member_count; i++) {
            fail_port = t_priv->member_array[i].gport;
            modid = BCM_GPORT_MODPORT_MODID_GET(fail_port);

            rv = bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local);
            if (SHR_FAILURE(rv) || !modid_is_local) {
                continue;
            }

            if (t_priv->member_array[i].flags &
                BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_lag_failover_enable_set(unit, fail_port, 0));

            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ltsw_trunk_failover_update(unit, t_id,
                                                bcmintTrunkTypeFrontPanel,
                                                0, 0, fail_port, 0, 0, NULL));
        }
    }

    if (fail_flags != 0) {
        for (i = 0; i < member_count; i++) {
            fail_port = member_array[i].gport;
            modid = BCM_GPORT_MODPORT_MODID_GET(fail_port);

            rv = bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local);
            if (SHR_FAILURE(rv) || !modid_is_local) {
                continue;
            }

            if (member_array[i].flags &
                BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ltsw_trunk_failover_update(unit, t_id,
                                                bcmintTrunkTypeFrontPanel,
                                                0, fail_flags,
                                                fail_port, t_update->ftp_max,
                                                member_count, member_array));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_lag_failover_enable_set(unit, fail_port, 1));
        }
    } else if (member_count != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_trunk_failover_flags_extract(unit, t_info->flags,
                                                   bcmintTrunkTypeFrontPanel,
                                                   &fail_flags));
        if (fail_flags != 0) {
            trunk_info->flags |= fail_flags;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk dynamic load balance configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fp_dlb(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    bcmint_trunk_type_t t_type = bcmintTrunkTypeFrontPanel;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_dlb(unit, t_type, t_id, trunk_info,
                                   member_count, member_array,
                                   t_priv, t_update));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk configuration.
 *
 * \param [in] unit     Unit Number.
 * \param [in] l2_dest  L2 dest of trunk.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_pipe_sync(int unit, int l2_dest,
                                bcmint_trunk_update_info_t *t_update)
{
    int i, j, modid, port, system_port, l2_if, num[3];
    bcm_gport_t *gport_array[3];
    uint32_t pbmp[3] = {0}, tmp_pbmp;
    SHR_FUNC_ENTER(unit);

    /* Delet this trunk when update info is NULL. */
    if (t_update == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_trunk_pipe_update(unit, l2_dest, 1, 0, 0, 0));
        SHR_EXIT();
    }

    gport_array[0] = t_update->leaving_members;
    gport_array[1] = t_update->staying_members;
    gport_array[2] = t_update->joining_members;
    num[0] = t_update->num_leaving;
    num[1] = t_update->num_staying;
    num[2] = t_update->num_joining;

    /* Get pipe of leaving, staying, joining ports respectively. */
    for (i = 0; i < 3; i++) {
        for (j = 0; j < num[i]; j++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_resolve(unit, gport_array[i][j], &modid,
                                              &port, &system_port, &l2_if));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l2_if_to_pipes(unit, l2_if, &tmp_pbmp));
            pbmp[i] |= tmp_pbmp;
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_trunk_pipe_update(unit, l2_dest, 0,
                                             pbmp[0], pbmp[1], pbmp[2]));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fp(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_pipe_sync(unit,
                                         t_priv->t_info->l2_dest, t_update));

    if (ltsw_xfs_trunk_dlb_validate_feature(unit)) {
        /* Configure dynamic load balancing */
        rv = ltsw_xfs_trunk_update_fp_dlb(unit, t_id, trunk_info,
                                          member_count, member_array,
                                          t_priv, t_update);
        if (rv != SHR_E_UNAVAIL) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

    /* Configure static load balancing */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_fp_group(unit, t_id, trunk_info,
                                        member_count, member_array,
                                        t_priv, t_update));

    /* Update source trunk map configuration */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_fp_member(unit, t_id, trunk_info,
                                         member_count, member_array,
                                         t_priv, t_update));

    /* Harware trunk failover */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_fp_failover(unit, t_id, trunk_info,
                                           member_count, member_array,
                                           t_priv, t_update));

    /* Migrate trunk attributes */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_fp_attr_migrate(unit, t_id, t_priv, t_update));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the fabric trunk group configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fabric_group(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int i, dunit;
    const char *lb_mode = NULL;
    uint64_t value;
    int member_cnt;
    int port;
    bcmint_trunk_info_t *t_info = t_priv->t_info;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_SYSTEMs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_SYSTEM_IDs, value));

    if (member_count <= 0) {
        rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL);
        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_psc_decode(unit, trunk_info->psc, &lb_mode));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(lte_hdl, LB_MODEs, lb_mode));

    member_cnt = 0;

    for (i = 0; i < member_count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_gport_resolve(unit, member_array[i].gport,
                                          NULL, &port, NULL, NULL));
        value = port;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(lte_hdl, MEMBER_PORT_IDs,
                                         member_cnt, &value, 1));
        member_cnt++;
    }

    if ((member_cnt >= 0) && (member_cnt < t_info->member_count)) {
        for (i = member_cnt; i < t_info->member_count; i++) {
            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, MEMBER_PORT_IDs,
                                             i, &value, 1));
        }
    }

    value = member_cnt;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, MEMBER_CNTs, value));
    if (value < 1) {
        value = 1;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, MAX_MEMBERSs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the fabric trunk failover configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fabric_failover(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    int i, j;
    int fail_port, next = 1, failto_port;
    uint32_t fail_flags;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_trunk_failover_flags_extract(unit, trunk_info->flags,
                                               bcmintTrunkTypeFabric,
                                               &fail_flags));

    if (fail_flags != 0 || member_count == 0) {
        /* Disable hardware failover for old trunk ports */
        for (i = 0; i < t_info->member_count; i++) {
            fail_port = t_priv->member_array[i].gport;
            if (t_priv->member_array[i].flags &
                BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_fabric_enable_set(unit, t_id,
                                                           fail_port, 0));
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_fabric_port_set(unit, fail_port, -1));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_failover_fabric_set(unit, t_id, -1, 0, 0, NULL));
    }

    if (fail_flags != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_trunk_failover_update(unit, t_id,
                                            bcmintTrunkTypeFabric,
                                            0, fail_flags,
                                            -1, t_update->ftp_max,
                                            member_count, member_array));
        for (i = 0; i < member_count; i++) {
            fail_port = member_array[i].gport;
            if (member_array[i].flags &
                BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_fabric_enable_set(unit, t_id,
                                                           fail_port, 1));
            for (j = ((i + 1) % member_count);
                 j != i;
                 j = ((j + 1) % member_count)) {
                if (member_array[j].flags &
                    BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                    continue;
                }
                failto_port = BCM_GPORT_MODPORT_PORT_GET(member_array[j].gport);

                SHR_IF_ERR_VERBOSE_EXIT
                    (ltsw_xfs_trunk_failover_fabric_port_set(unit, fail_port,
                                                             failto_port));
                if (next) {
                    break;
                }
            }
        }
    } else if (member_count != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_trunk_failover_flags_extract(unit, t_info->flags,
                                                   bcmintTrunkTypeFabric,
                                                   &fail_flags));
        if (fail_flags != 0) {
            trunk_info->flags |= fail_flags;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the fabric trunk dynamic load balance configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fabric_dlb(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    bcmint_trunk_type_t t_type = bcmintTrunkTypeFabric;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_dlb(unit, t_type, t_id, trunk_info,
                                   member_count, member_array,
                                   t_priv, t_update));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the fabric trunk configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_fabric(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    if (ltsw_xfs_trunk_dlb_validate_feature(unit)) {
        /* Configure dynamic load balancing */
        rv = ltsw_xfs_trunk_update_fabric_dlb(unit, t_id, trunk_info,
                                              member_count, member_array,
                                              t_priv, t_update);
        if (rv != SHR_E_UNAVAIL) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

    /* Configure static load balancing */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_fabric_group(unit, t_id, trunk_info,
                                            member_count, member_array,
                                            t_priv, t_update));
    /* Harware trunk failover */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_fabric_failover(unit, t_id, trunk_info,
                                               member_count, member_array,
                                               t_priv, t_update));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the virtual port link aggregation group configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_virtual_group(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int i, dunit, rv;
    const char *lb_mode = NULL;
    const char *weighted_size;
    uint64_t value;
    int member_cnt;
    int vp;
    bcmint_trunk_info_t *t_info = t_priv->t_info;
    bcm_if_t egress_if;
    int nexthop2OrEcmpIndex1 = 0, prot_idx = 0;
    bcmi_ltsw_l3_egr_obj_type_t egress_type;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (!(t_info->flags & BCM_TRUNK_FLAG_WEIGHTED) &&
        (trunk_info->flags & BCM_TRUNK_FLAG_WEIGHTED)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TRUNK_VPs, &lte_hdl));
        value = t_info->l2_dest;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, TRUNK_VP_IDs, value));
        rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL);
        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TRUNK_VP_WEIGHTEDs, &lte_hdl));
        value = t_info->l2_dest;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, TRUNK_VP_IDs, value));

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_virtual_weighted_size_decode(unit, member_count,
                                                         &weighted_size));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(lte_hdl, WEIGHTED_SIZEs,
                                          weighted_size));
        value = member_count;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, MEMBER_CNTs, value));

        member_cnt = 0;
        for (i = 0; i < member_count; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_virtual_port_resolve(unit,
                                                           member_array[i].gport,
                                                           &vp));
            value = vp;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, DVPs,
                                             member_cnt, &value, 1));

            if (ltsw_xfs_trunk_virtual_port_is_network(unit, vp)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                           member_array[i].gport,
                                                           &egress_if));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_l3_egress_obj_id_resolve(unit, egress_if,
                                                        &nexthop2OrEcmpIndex1,
                                                        &egress_type));
                /* egress_if is only for L2 tunnel use currently */
                if ((egress_type != BCMI_LTSW_L3_EGR_OBJ_T_UL) &&
                    (egress_type != BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL)) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }

                if (egress_type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
                    prot_idx = 1;
                } else {
                    prot_idx = (1 << 2) | 1; /* ECMP indicator. */
                }
            } else {
                nexthop2OrEcmpIndex1 = 0;
                prot_idx = 0;
            }

            value = nexthop2OrEcmpIndex1;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             NHOP_2_OR_ECMP_GROUP_INDEX_1s,
                                             member_cnt, &value, 1));
            value = prot_idx;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,
                                             member_cnt, &value, 1));
            member_cnt++;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    } else if (!(trunk_info->flags & BCM_TRUNK_FLAG_WEIGHTED) &&
               (t_info->flags & BCM_TRUNK_FLAG_WEIGHTED)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TRUNK_VP_WEIGHTEDs, &lte_hdl));
        value = t_info->l2_dest;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, TRUNK_VP_IDs, value));
        rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL);
        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TRUNK_VPs, &lte_hdl));
        value = t_info->l2_dest;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, TRUNK_VP_IDs, value));

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_psc_decode(unit, trunk_info->psc, &lb_mode));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(lte_hdl, LB_MODEs, lb_mode));

        value = member_count;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, MEMBER_CNTs, value));
        if (value < 1) {
            value = 1;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, MAX_MEMBERSs, value));

        member_cnt = 0;
        for (i = 0; i < member_count; i++) {
            if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_virtual_port_resolve(unit,
                                                           member_array[i].gport,
                                                           &vp));
            value = vp;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, DVPs,
                                             member_cnt, &value, 1));
            if (ltsw_xfs_trunk_virtual_port_is_network(unit, vp)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                           member_array[i].gport,
                                                           &egress_if));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_l3_egress_obj_id_resolve(unit, egress_if,
                                                        &nexthop2OrEcmpIndex1,
                                                        &egress_type));
                /* egress_if is only for L2 tunnel use currently */
                if ((egress_type != BCMI_LTSW_L3_EGR_OBJ_T_UL) &&
                    (egress_type != BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL)) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }

                if (egress_type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
                    prot_idx = 1;
                } else {
                    prot_idx = (1 << 2) | 1; /* ECMP indicator. */
                }
            } else {
                nexthop2OrEcmpIndex1 = 0;
                prot_idx = 0;
            }

            value = nexthop2OrEcmpIndex1;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             NHOP_2_OR_ECMP_GROUP_INDEX_1s,
                                             member_cnt, &value, 1));
            value = prot_idx;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,
                                             member_cnt, &value, 1));
            member_cnt++;
        }

        if ((member_cnt >= 0) && (member_cnt < t_info->member_count)) {
            for (i = member_cnt; i < t_info->member_count; i++) {
                value = 0;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl,
                                                 DVPs,
                                                 i, &value, 1));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl,
                                                 NHOP_2_OR_ECMP_GROUP_INDEX_1s,
                                                 i, &value, 1));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl,
                                                 ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,
                                                 i, &value, 1));
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    } else if (!(t_info->flags & BCM_TRUNK_FLAG_WEIGHTED) &&
               !(trunk_info->flags & BCM_TRUNK_FLAG_WEIGHTED)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TRUNK_VPs, &lte_hdl));
        value = t_info->l2_dest;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, TRUNK_VP_IDs, value));

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_psc_decode(unit, trunk_info->psc, &lb_mode));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(lte_hdl, LB_MODEs, lb_mode));

        value = member_count;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, MEMBER_CNTs, value));
        if (value < 1) {
            value = 1;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, MAX_MEMBERSs, value));

        member_cnt = 0;
        for (i = 0; i < member_count; i++) {
            if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_virtual_port_resolve(unit,
                                                           member_array[i].gport,
                                                           &vp));
            value = vp;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, DVPs,
                                             member_cnt, &value, 1));
            if (ltsw_xfs_trunk_virtual_port_is_network(unit, vp)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                           member_array[i].gport,
                                                           &egress_if));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_l3_egress_obj_id_resolve(unit, egress_if,
                                                        &nexthop2OrEcmpIndex1,
                                                        &egress_type));
                /* egress_if is only for L2 tunnel use currently */
                if ((egress_type != BCMI_LTSW_L3_EGR_OBJ_T_UL) &&
                    (egress_type != BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL)) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }

                if (egress_type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
                    prot_idx = 1;
                } else {
                    prot_idx = (1 << 2) | 1; /* ECMP indicator. */
                }
            } else {
                nexthop2OrEcmpIndex1 = 0;
                prot_idx = 0;
            }

            value = nexthop2OrEcmpIndex1;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             NHOP_2_OR_ECMP_GROUP_INDEX_1s,
                                             member_cnt, &value, 1));
            value = prot_idx;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,
                                             member_cnt, &value, 1));
            member_cnt++;
        }

        if ((member_cnt >= 0) && (member_cnt < t_info->member_count)) {
            for (i = member_cnt; i < t_info->member_count; i++) {
                value = 0;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl,
                                                 DVPs,
                                                 i, &value, 1));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl,
                                                 NHOP_2_OR_ECMP_GROUP_INDEX_1s,
                                                 i, &value, 1));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl,
                                                 ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,
                                                 i, &value, 1));
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    } else if ((t_info->flags & BCM_TRUNK_FLAG_WEIGHTED) &&
               (trunk_info->flags & BCM_TRUNK_FLAG_WEIGHTED)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TRUNK_VP_WEIGHTEDs, &lte_hdl));
        value = t_info->l2_dest;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, TRUNK_VP_IDs, value));

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_virtual_weighted_size_decode(unit, member_count,
                                                         &weighted_size));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(lte_hdl, WEIGHTED_SIZEs,
                                          weighted_size));
        value = member_count;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, MEMBER_CNTs, value));

        member_cnt = 0;
        for (i = 0; i < member_count; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_virtual_port_resolve(unit,
                                                           member_array[i].gport,
                                                           &vp));
            value = vp;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, DVPs,
                                             member_cnt, &value, 1));
            if (ltsw_xfs_trunk_virtual_port_is_network(unit, vp)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                           member_array[i].gport,
                                                           &egress_if));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_l3_egress_obj_id_resolve(unit, egress_if,
                                                        &nexthop2OrEcmpIndex1,
                                                        &egress_type));
                /* egress_if is only for L2 tunnel use currently */
                if ((egress_type != BCMI_LTSW_L3_EGR_OBJ_T_UL) &&
                    (egress_type != BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL)) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }

                if (egress_type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
                    prot_idx = 1;
                } else {
                    prot_idx = (1 << 2) | 1; /* ECMP indicator. */
                }
            } else {
                nexthop2OrEcmpIndex1 = 0;
                prot_idx = 0;
            }

            value = nexthop2OrEcmpIndex1;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             NHOP_2_OR_ECMP_GROUP_INDEX_1s,
                                             member_cnt, &value, 1));
            value = prot_idx;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,
                                             member_cnt, &value, 1));
            member_cnt++;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Migrate virtual port attributes to virtual port link aggregation group.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] from_vp Migrate from virtual port.
 * \param [in] to_vp Migrate to virtual port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_virtual_attr_migrate_svp(
    int unit,
    bcmint_trunk_id_t t_id,
    int from_vp,
    int to_vp)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_SVP_TABLEs, &lte_hdl));

    value = from_vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SVPs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    value = to_vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SVPs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Migrate virtual port link aggregation group attribute to new joining members.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_virtual_attr_migrate(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    bcm_gport_t gport;
    int trunk_vp, vp;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    if (t_update->num_leaving > 0) {
        gport = t_update->leaving_members[0];
    } else if (t_update->num_staying > 0) {
        gport = t_update->staying_members[0];
    } else if (t_update->num_joining > 0) {
        gport = t_update->joining_members[0];
    } else {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_gport_virtual_port_resolve(unit, gport, &vp));

    trunk_vp = t_info->l2_dest;

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_virtual_attr_migrate_svp(unit, t_id,
                                                        vp, trunk_vp));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the virtual port link aggregation group port attributes.
 *
 * \param [in] unit Unit Number.
 * \param [in] gport The generic port number.
 * \param [in] vp The mapping-to virtual port.
 * \param [in] vp_lag_vp The VPLAG virtual port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_virtual_port_attr(
    int unit,
    bcm_gport_t gport,
    int vp,
    int vp_lag_vp)
{
    int tmp_vp;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_gport_virtual_port_resolve(unit, gport, &tmp_vp));

    if (vp == vp_lag_vp) {
        if (BCM_GPORT_IS_FLOW_PORT(gport)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_flow_port_source_vp_lag_set(unit, gport, vp_lag_vp));
        } else if (BCM_GPORT_IS_MPLS_PORT(gport)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_mpls_port_source_vp_lag_set(unit, gport, vp_lag_vp));
        } else {
            return BCM_E_PORT;
        }
    } else if (vp == tmp_vp) {
        if (BCM_GPORT_IS_FLOW_PORT(gport)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_flow_port_source_vp_lag_clr(unit, gport, vp_lag_vp));
        } else if (BCM_GPORT_IS_MPLS_PORT(gport)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_mpls_port_source_vp_lag_clr(unit, gport, vp_lag_vp));
        } else {
            return BCM_E_PORT;
        }
    } else {
        return BCM_E_PORT;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the virtual port link aggregation group member configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_virtual_member(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    int i, vp, vp_lag_vp;
    bcm_gport_t gport;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    vp_lag_vp = t_info->l2_dest;

    for (i = 0; i < member_count; i++) {
        gport = member_array[i].gport;
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_gport_virtual_port_resolve(unit, gport, &vp));
        if (member_array[i].flags & BCM_TRUNK_MEMBER_INGRESS_DISABLE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_update_virtual_port_attr(unit, gport, vp,
                                                         vp_lag_vp));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_update_virtual_port_attr(unit, gport, vp_lag_vp,
                                                         vp_lag_vp));
        }
    }

    for (i = 0; i < t_update->num_leaving; i++) {
        gport = t_update->leaving_members[i];
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_gport_virtual_port_resolve(unit, gport, &vp));
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_update_virtual_port_attr(unit, gport, vp,
                                                     vp_lag_vp));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the virtual port link aggregation group configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_update_virtual(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    SHR_FUNC_ENTER(unit);

    /* Configure static load balancing */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_virtual_group(unit, t_id, trunk_info,
                                             member_count, member_array,
                                             t_priv, t_update));
    /* Migrate trunk attributes */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_virtual_attr_migrate(unit, t_id,
                                                    t_priv, t_update));
    /* Update source virtual trunk map configuration */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_virtual_member(unit, t_id, trunk_info,
                                              member_count, member_array,
                                              t_priv, t_update));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a front panel trunk group with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fp_group(
    int unit,
    bcmint_trunk_id_t t_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNKs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a front panel trunk member attributes with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fp_port_attr(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    int i, member_count;
    int system_port, l2_eif;
    bcmint_trunk_member_t *member_array;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    member_count = t_info->member_count;
    member_array = t_priv->member_array;

    for (i = 0; i < member_count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_gport_resolve(unit, member_array[i].gport,
                                          NULL, NULL, &system_port, &l2_eif));
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_update_fp_port_attr(unit, system_port, l2_eif));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy L2 ingress interface for the front panel trunk.
 *
 * \param [in] unit Device unit number.
 * \param [in] t_id The front panel trunk ID.
 * \param [in] l2_iif Trunk L2 ingress interface.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fp_l2_iif(
    int unit,
    bcmint_trunk_id_t t_id,
    int l2_iif)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_L2_IIF_TABLEs, &lte_hdl));

    value = l2_iif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_IIFs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_free(lte_hdl));
    lte_hdl = BCMLT_INVALID_HDL;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_L2_IIF_ATTRIBUTES_TABLEs, &lte_hdl));

    value = l2_iif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_IIFs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy L2 egress interface for the front panel trunk.
 *
 * \param [in] unit Device unit number.
 * \param [in] t_id The front panel trunk ID.
 * \param [in] l2_eif Trunk L2 egress interface.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fp_l2_eif(
    int unit,
    bcmint_trunk_id_t t_id,
    int l2_eif)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_EIF_SYSTEM_DESTINATIONs, &lte_hdl));

    value = l2_eif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_EIF_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy L2 ingress interface for the front panel trunk.
 *
 * \param [in] unit Device unit number.
 * \param [in] t_id The front panel trunk ID.
 * \param [in] egr_l2_oif Trunk Egress L2 Outgoing interface.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fp_egr_l2_oif(
    int unit,
    bcmint_trunk_id_t t_id,
    int egr_l2_oif)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, EGR_L2_OIFs, &lte_hdl));

    value = egr_l2_oif;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, L2_OIFs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}


/*!
 * \brief Destroy a front panel trunk failover attributes with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fp_failover(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    int i, member_count;
    int modid, port;
    bcmint_trunk_member_t *member_array;
    bcmint_trunk_info_t *t_info;
    uint32_t fail_flags;
    bcm_gport_t fail_port;
    int modid_is_local = 0;
    int rv;

    SHR_FUNC_ENTER(unit);

    t_info = t_priv->t_info;
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_trunk_failover_flags_extract(unit, t_info->flags,
                                               bcmintTrunkTypeFrontPanel,
                                               &fail_flags));
    member_count = t_info->member_count;
    member_array = t_priv->member_array;

    for (i = 0; i < member_count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_gport_resolve(unit, member_array[i].gport,
                                          &modid, &port, NULL, NULL));
        rv = bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local);
        if (SHR_FAILURE(rv) || !modid_is_local) {
            continue;
        }
        fail_port = member_array[i].gport;

        if (fail_flags != 0 ||
            member_array[i].fail_flags != 0 ||
            member_array[i].failover_psc != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_lag_failover_enable_set(unit, fail_port, 0));

            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ltsw_trunk_failover_update(unit, t_id,
                                                bcmintTrunkTypeFrontPanel,
                                                0, 0, fail_port, 0, 0, NULL));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a front panel trunk dynamic loadbalance configurations.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fp_dlb(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    bcmint_trunk_type_t t_type = bcmintTrunkTypeFrontPanel;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_dlb(unit, t_type, t_id, NULL,
                                   0, NULL,
                                   t_priv, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a front panel trunk with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fp(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    bcmint_trunk_info_t *t_info = t_priv->t_info;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_pipe_sync(unit, t_info->l2_dest, NULL));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_destroy_fp_port_attr(unit, t_id, t_priv));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_destroy_fp_group(unit, t_id));

    if (ltsw_xfs_trunk_dlb_validate_feature(unit)) {
        /* Destroy dynamic load balancing */
        rv = ltsw_xfs_trunk_destroy_fp_dlb(unit, t_id, t_priv);
        if (rv != SHR_E_UNAVAIL) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_destroy_fp_l2_iif(unit, t_id, t_info->l2_dest));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_destroy_fp_l2_eif(unit, t_id, t_info->l2_dest));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_destroy_fp_egr_l2_oif(unit, t_id, t_info->l2_dest));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_destroy_fp_failover(unit, t_id, t_priv));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l2_if_free(unit, t_info->l2_dest));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a fabric trunk group with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fabric_group(
    int unit,
    bcmint_trunk_id_t t_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_SYSTEMs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_SYSTEM_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a fabric trunk failover attributes with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fabric_failover(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    int i, member_count;
    bcmint_trunk_member_t *member_array;
    bcmint_trunk_info_t *t_info;
    uint32_t fail_flags;
    bcm_gport_t fail_port;

    SHR_FUNC_ENTER(unit);

    t_info = t_priv->t_info;
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_trunk_failover_flags_extract(unit, t_info->flags,
                                               bcmintTrunkTypeFabric,
                                               &fail_flags));
    if (fail_flags != 0) {
        member_count = t_info->member_count;
        member_array = t_priv->member_array;

        for (i = 0; i < member_count; i++) {
            fail_port = member_array[i].gport;
            if (member_array[i].flags &
                BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_fabric_enable_set(unit, t_id,
                                                           fail_port, 0));
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_fabric_port_set(unit, fail_port, -1));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_failover_fabric_set(unit, t_id, -1, 0, 0, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a fabric trunk dynamic loadbalance configurations.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fabric_dlb(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    bcmint_trunk_type_t t_type = bcmintTrunkTypeFabric;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_update_dlb(unit, t_type, t_id, NULL,
                                   0, NULL,
                                   t_priv, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a fabric trunk with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_fabric(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_destroy_fabric_group(unit, t_id));

    if (ltsw_xfs_trunk_dlb_validate_feature(unit)) {
        /* Destroy dynamic load balancing */
        rv = ltsw_xfs_trunk_destroy_fabric_dlb(unit, t_id, t_priv);
        if (rv != SHR_E_UNAVAIL) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_destroy_fabric_failover(unit, t_id, t_priv));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a virtual port link aggregation group with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_virtual_group(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit, rv;
    bcmint_trunk_info_t *t_info = t_priv->t_info;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (t_info->flags & BCM_TRUNK_FLAG_WEIGHTED) {
        lt_name = TRUNK_VP_WEIGHTEDs;
    } else {
        lt_name = TRUNK_VPs;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &lte_hdl));

    value = t_info->l2_dest;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_VP_IDs, value));

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a virtual port link aggregation group member attributes with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_virtual_port_attr_weighted(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int i, member_count;
    int vp, vp_lag_vp;
    int dunit, rv;
    bcm_gport_t gport;
    uint64_t value;
    uint32_t count;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    member_count = t_info->member_count;
    vp_lag_vp = t_info->l2_dest;

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_VP_WEIGHTEDs, &lte_hdl));
    value = vp_lag_vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_VP_IDs, value));
    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (SHR_SUCCESS(rv)) {
        for (i = 0; i < member_count; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(lte_hdl, DVPs, i,
                                             &value, 1, &count));
            vp = value & 0xffffffff;
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_gport_virtual_port_construct(unit, vp, &gport));
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_update_virtual_port_attr(unit, gport,
                                                         vp, vp_lag_vp));
        }
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
        SHR_EXIT();
    } else {
        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a virtual port link aggregation group member attributes with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_virtual_port_attr(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    int i, member_count;
    int rv;
    int vp, vp_lag_vp;
    bcmint_trunk_member_t *member_array;
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    if (t_info->flags & BCM_TRUNK_FLAG_WEIGHTED) {
        rv = ltsw_xfs_trunk_destroy_virtual_port_attr_weighted(unit,
                                                               t_id, t_priv);
        if (SHR_SUCCESS(rv)) {
            SHR_EXIT();
        } else {
            SHR_ERR_EXIT(rv);
        }
    }

    member_count = t_info->member_count;
    member_array = t_priv->member_array;
    vp_lag_vp = t_info->l2_dest;

    for (i = 0; i < member_count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_gport_virtual_port_resolve(unit,
                                                       member_array[i].gport,
                                                       &vp));
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_update_virtual_port_attr(unit,
                                                     member_array[i].gport,
                                                     vp, vp_lag_vp));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy svp for a virtual port link aggregation group.
 *
 * \param [in] unit Unit Number.
 * \param [in] svp Source virtual port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_virtual_svp(
    int unit,
    int svp)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_SVP_TABLEs, &lte_hdl));

    value = svp;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SVPs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a virtual port link aggregation group with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_destroy_virtual(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    bcmint_trunk_info_t *t_info = t_priv->t_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_destroy_virtual_port_attr(unit, t_id, t_priv));
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_destroy_virtual_group(unit, t_id, t_priv));
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_destroy_virtual_svp(unit, t_info->l2_dest));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear port type from trunk port to normal port.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_clear_port_attribute(int unit)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit, rv;
    uint64_t value;
    int l2_eif, is_trunk, system_port, t_id;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_EIF_SYSTEM_DESTINATIONs, &lte_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, lte_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, L2_EIF_IDs, &value));
        l2_eif = value & 0xffffffff;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, IS_TRUNKs, &value));
        is_trunk = value & 0xffffffff;

        if (is_trunk) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, L2_EIF_IDs, &value));
            t_id = value & 0xffffffff;
            SHR_IF_ERR_CONT
                (bcmi_lt_entry_commit(unit, lte_hdl,
                                      BCMLT_OPCODE_DELETE,
                                      BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_destroy_fp_l2_iif(unit, t_id, l2_eif));

            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_destroy_fp_egr_l2_oif(unit, t_id, l2_eif));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l2_if_free(unit, l2_eif));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(lte_hdl, SYSTEM_PORTs, &value));
            system_port = value & 0xffffffff;
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_update_fp_port_attr(unit, system_port, l2_eif));
        }
    }
exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear front panel trunk configuration.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_clear_fp(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Clear TRUNK table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TRUNKs));

    /* Clear TRUNK_FAILOVER table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TRUNK_FAILOVERs));

    /* Clear PORT_SYSTEM table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_clear_port_attribute(unit));

    /* Clean up trunk user in virtual module. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_user_trunk_cleanup(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear fabric trunk configuration.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_clear_fabric(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Clear TRUNK_SYSTEM table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TRUNK_SYSTEMs));

    /* Clear TRUNK_SYSTEM_FAILOVER table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TRUNK_SYSTEM_FAILOVERs));

    /* Clear PORT_TRUNK table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, PORT_TRUNKs));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear virtual port link aggregation group configuration.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_clear_virtual(int unit)
{
    int rv;
    int svp;
    bcmint_trunk_pub_info_t t_pub;

    SHR_FUNC_ENTER(unit);

    /* Clear TRUNK_VPs table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TRUNK_VPs));

    /* Clear TRUNK_VP_WEIGHTEDs table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TRUNK_VP_WEIGHTEDs));

    sal_memset(&t_pub, 0, sizeof(t_pub));
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_pub_info_get(unit, &t_pub));
    for (svp = t_pub.base_vplag_idx;
         svp < t_pub.base_vplag_idx + t_pub.ngroups_vplag; svp++) {
        rv = ltsw_xfs_trunk_destroy_virtual_svp(unit, svp);
        if (rv == SHR_E_NOT_FOUND) {
            continue;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Find a specific front panel trunk with member gport.
 *
 * \param [in] unit Unit Number.
 * \param [in] gport Generic Port Number.
 * \param [out] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_find_fp(
    int unit,
    bcm_gport_t gport,
    bcmint_trunk_id_t *t_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit;
    int system_port, l2_eif;
    bcmint_trunk_type_t t_type;

    SHR_FUNC_ENTER(unit);

    /* Get PORT_SYSTEM_ID for specific modid */
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_gport_resolve(unit, gport,
                                      NULL, NULL, &system_port, NULL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_SYSTEM_PORT_TABLEs, &lte_hdl));

    value = system_port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SYSTEM_SOURCEs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, L2_IIFs, &value));

    (void)bcmlt_entry_free(lte_hdl);
    lte_hdl = BCMLT_INVALID_HDL;

    l2_eif = value & 0xffffffff;

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_l2_eif_to_type_id(unit, l2_eif, &t_type, t_id));
    if (t_type != bcmintTrunkTypeFrontPanel) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Find a specific fabric trunk with member gport.
 *
 * \param [in] unit Unit Number.
 * \param [in] gport Generic Port Number.
 * \param [out] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_find_fabric(
    int unit,
    bcm_gport_t gport,
    bcmint_trunk_id_t *t_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int rv, dunit;
    int modid, modid_is_local, port, member_port_id;
    uint32_t i, member_cnt, count;
    int is_higig_port = 0;

    SHR_FUNC_ENTER(unit);

    modid = BCM_GPORT_MODPORT_MODID_GET(gport);
    port = BCM_GPORT_MODPORT_PORT_GET(gport);

    SHR_IF_ERR_CONT
        (bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local));
    if (SHR_FUNC_ERR() || !modid_is_local) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }
    is_higig_port = bcmi_ltsw_port_is_type(unit,
                                           port,
                                           BCMI_LTSW_PORT_TYPE_HG);
    if (!is_higig_port) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* Get PORT_SYSTEM_ID for specific modid */
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_SYSTEMs, &lte_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, lte_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, MEMBER_CNTs, &value));
        member_cnt = value & 0xffffffff;

        for (i = 0; i < member_cnt; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(lte_hdl, MEMBER_PORT_IDs, i,
                                             &value, 1, &count));
            member_port_id = value & 0xffffffff;
            if (member_port_id == port) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(lte_hdl, TRUNK_SYSTEM_IDs, &value));
                *t_id = value & 0xffffffff;
                SHR_EXIT();
            }
        }
    }

    SHR_ERR_EXIT(SHR_E_NOT_FOUND);

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Find a specific front panel trunk with member gport.
 *
 * \param [in] unit Unit Number.
 * \param [in] gport Generic Port Number.
 * \param [out] vp_lag_vp The VPLAG vp number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xfs_trunk_find_virtual(
    int unit,
    bcm_gport_t gport,
    bcmint_trunk_id_t *vp_lag_vp)
{
    SHR_FUNC_ENTER(unit);

    if (BCM_GPORT_IS_FLOW_PORT(gport)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_flow_port_source_vp_lag_get(unit, gport, vp_lag_vp));
    } else if (BCM_GPORT_IS_MPLS_PORT(gport)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_mpls_port_source_vp_lag_get(unit, gport, vp_lag_vp));
    } else {
        return BCM_E_PORT;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ltsw_xfs_trunk_override_set(
    int unit,
    bcmint_trunk_id_t t_id,
    int enable)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value, value_enable;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_SYSTEMs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_SYSTEM_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, RESOLUTION_DISABLEs, &value));

    value_enable = enable ? 1 : 0;
    if (value != value_enable) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, RESOLUTION_DISABLEs, value_enable));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

static int
ltsw_xfs_trunk_override_get(
    int unit,
    bcmint_trunk_id_t t_id,
    int *enable)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_SYSTEMs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_SYSTEM_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, RESOLUTION_DISABLEs, &value));
    if (enable) {
        *enable = value ? 1 : 0;
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

static int
ltsw_xfs_trunk_vp_lag_member_update(
    int unit,
    int vp_lag_vp,
    bcm_gport_t gport)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv, dunit, vp, dvp;
    int i, member_cnt = 0;
    uint64_t value;
    uint32_t count;
    bcm_if_t egress_if;
    int nexthop2OrEcmpIndex1 = 0, prot_idx = 0;
    bcmi_ltsw_l3_egr_obj_type_t egress_type;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_gport_virtual_port_resolve(unit, gport, &vp));

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_VPs, &lte_hdl));
    value = vp_lag_vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_VP_IDs, value));
    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, MEMBER_CNTs, &value));
        member_cnt = value & 0xffffffff;

        for (i = 0; i < member_cnt; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(lte_hdl, DVPs, i,
                                             &value, 1, &count));
            dvp = value & 0xffffffff;
            if (dvp != vp) {
                continue;
            }

            if (ltsw_xfs_trunk_virtual_port_is_network(unit, vp)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_port_egress_obj_get(unit, gport,
                                                           &egress_if));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_l3_egress_obj_id_resolve(unit, egress_if,
                                                        &nexthop2OrEcmpIndex1,
                                                        &egress_type));
                /* egress_if is only for L2 tunnel use currently */
                if ((egress_type != BCMI_LTSW_L3_EGR_OBJ_T_UL) &&
                    (egress_type != BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL)) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }

                if (egress_type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
                    prot_idx = 1;
                } else {
                    prot_idx = (1 << 2) | 1; /* ECMP indicator. */
                }
            } else {
                nexthop2OrEcmpIndex1 = 0;
                prot_idx = 0;
            }

            value = nexthop2OrEcmpIndex1;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             NHOP_2_OR_ECMP_GROUP_INDEX_1s,
                                             i, &value, 1));
            value = prot_idx;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,
                                             i, &value, 1));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
        SHR_EXIT();
    } else {
        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_VP_WEIGHTEDs, &lte_hdl));
    value = vp_lag_vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_VP_IDs, value));
    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, MEMBER_CNTs, &value));
        member_cnt = value & 0xffffffff;

        for (i = 0; i < member_cnt; i++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(lte_hdl, DVPs, i,
                                             &value, 1, &count));
            dvp = value & 0xffffffff;
            if (dvp != vp) {
                continue;
            }

            if (ltsw_xfs_trunk_virtual_port_is_network(unit, vp)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_port_egress_obj_get(unit, gport,
                                                           &egress_if));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_l3_egress_obj_id_resolve(unit, egress_if,
                                                        &nexthop2OrEcmpIndex1,
                                                        &egress_type));
                /* egress_if is only for L2 tunnel use currently */
                if ((egress_type != BCMI_LTSW_L3_EGR_OBJ_T_UL) &&
                    (egress_type != BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL)) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }

                if (egress_type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
                    prot_idx = 1;
                } else {
                    prot_idx = (1 << 2) | 1; /* ECMP indicator. */
                }
            } else {
                nexthop2OrEcmpIndex1 = 0;
                prot_idx = 0;
            }

            value = nexthop2OrEcmpIndex1;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             NHOP_2_OR_ECMP_GROUP_INDEX_1s,
                                             i, &value, 1));
            value = prot_idx;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl,
                                             ECMP_AND_PROT_SWT_SFC_PROFILE_INDEXs,
                                             i, &value, 1));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
        SHR_EXIT();
    } else {
        if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

static int
ltsw_xfs_trunk_vp_lag_vp_learn_get(
    int unit,
    int vp_lag_vp,
    uint32_t *flags)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit, cml = 0;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_SVP_TABLEs, &lte_hdl));
    value = vp_lag_vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SVPs, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, CML_FLAGS_NEWs, &value));
    cml = value & 0xffffffff;

    *flags = 0;
    if (!(cml & BCMI_XFS_CML_FLAGS_DROP)) {
       *flags |= BCM_PORT_LEARN_FWD;
    }
    if (cml & BCMI_XFS_CML_FLAGS_COPY_TO_CPU) {
       *flags |= BCM_PORT_LEARN_CPU;
    }
    if (cml & BCMI_XFS_CML_FLAGS_LEARN) {
       *flags |= BCM_PORT_LEARN_ARL;
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

static int
ltsw_xfs_trunk_vp_lag_vp_learn_set(
    int unit,
    int vp_lag_vp,
    uint32_t flags)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit, cml = 0;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    if (!(flags & BCM_PORT_LEARN_FWD)) {
        cml |= BCMI_XFS_CML_FLAGS_DROP;
    }
    if (flags & BCM_PORT_LEARN_CPU) {
        cml |= BCMI_XFS_CML_FLAGS_COPY_TO_CPU;
    }
    if (flags & BCM_PORT_LEARN_ARL) {
        cml |= BCMI_XFS_CML_FLAGS_LEARN;
    }
    if (flags & BCM_PORT_LEARN_PENDING) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ING_SVP_TABLEs, &lte_hdl));
    value = vp_lag_vp;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, SVPs, value));
    value = cml;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, CML_FLAGS_NEWs, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, CML_FLAGS_MOVEs, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/******************************************************************************
 * Public functions
 */

int
xfs_ltsw_trunk_type_id_to_l2_dest(
    int unit,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    int *l2_dest)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_type_id_to_l2_eif(unit, t_id, t_priv, l2_dest));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PORT);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_l2_dest_to_type_id(
    int unit,
    int l2_dest,
    bcmint_trunk_type_t *t_type,
    bcmint_trunk_id_t *t_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_l2_eif_to_type_id(unit, l2_dest, t_type, t_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_gport_is_channelized_access_port(
    int unit,
    bcm_gport_t gport,
    bool *is_channelized_access_port)
{
    SHR_FUNC_ENTER(unit);

    *is_channelized_access_port =
        ltsw_xfs_trunk_gport_is_channelized_access_port(unit, gport);
    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_pub_info_get(
    int unit,
    bcmint_trunk_pub_info_t *t_pub)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_pub_info_get(unit, t_pub));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_psc_compare(
    int unit,
    bcmint_trunk_type_t t_type,
    int psc0,
    int psc1,
    int exact,
    bool *result)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
        case bcmintTrunkTypeFabric:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_psc_compare(unit, psc0, psc1, exact, result));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_init(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_detach(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Clear front panel trunk configuration. */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_clear_fp(unit));

    /* Clear fabric trunk configuration. */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_clear_fabric(unit));

    if (ltsw_feature(unit, LTSW_FT_VPLAG)) {
        /* Clear virtual port link aggregation group configuration. */
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xfs_trunk_clear_virtual(unit));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_create(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_priv_info_t *t_priv)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_create_fp(unit, t_id, t_priv));
            break;
        case bcmintTrunkTypeFabric:
            break;
        case bcmintTrunkTypeVplag:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_create_virtual(unit, t_id, t_priv));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_params_validate(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_params_validate_fp(unit, t_id, trunk_info,
                                                   member_count, member_array,
                                                   op, member));
            break;
        case bcmintTrunkTypeFabric:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_params_validate_fabric(unit, t_id, trunk_info,
                                                       member_count,
                                                       member_array,
                                                       op, member));
            break;
        case bcmintTrunkTypeVplag:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_params_validate_virtual(unit, t_id, trunk_info,
                                                       member_count,
                                                       member_array,
                                                       op, member));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_priv_info_t *t_priv,
    bcm_trunk_info_t *trunk_info,
    int member_max,
    bcm_trunk_member_t *member_array,
    int *member_count)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_get_fp(unit, t_id, t_priv, trunk_info,
                                       member_max, member_array,
                                       member_count));
            break;
        case bcmintTrunkTypeFabric:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_get_fabric(unit, t_id, t_priv, trunk_info,
                                           member_max, member_array,
                                           member_count));
            break;
        case bcmintTrunkTypeVplag:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_get_virtual(unit, t_id, t_priv, trunk_info,
                                            member_max, member_array,
                                            member_count));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_update(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_update_fp(unit, t_id, trunk_info,
                                          member_count, member_array,
                                          op, member, t_priv, t_update));
            break;
        case bcmintTrunkTypeFabric:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_update_fabric(unit, t_id, trunk_info,
                                              member_count, member_array,
                                              op, member, t_priv, t_update));
            break;
        case bcmintTrunkTypeVplag:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_update_virtual(unit, t_id, trunk_info,
                                               member_count, member_array,
                                               op, member, t_priv, t_update));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_destroy(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_priv_info_t *t_priv)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_destroy_fp(unit, t_id, t_priv));
            break;
        case bcmintTrunkTypeFabric:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_destroy_fabric(unit, t_id, t_priv));
            break;
        case bcmintTrunkTypeVplag:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_destroy_virtual(unit, t_id, t_priv));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_find(
    int unit,
    bcm_gport_t gport,
    bcmint_trunk_id_t *t_id,
    bcmint_trunk_type_t *t_type)
{
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(t_id, SHR_E_PARAM);
    SHR_NULL_CHECK(t_type, SHR_E_PARAM);

    rv = ltsw_xfs_trunk_find_fabric(unit, gport, t_id);
    if (SHR_SUCCESS(rv)) {
        *t_type = bcmintTrunkTypeFabric;
        SHR_EXIT();
    } else if (rv != SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(rv);
    }

    rv = ltsw_xfs_trunk_find_fp(unit, gport, t_id);
    if (SHR_SUCCESS(rv)) {
        *t_type = bcmintTrunkTypeFrontPanel;
        SHR_EXIT();
    } else if (rv != SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(rv);
    }

    SHR_ERR_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_find_virtual(
    int unit,
    bcm_gport_t gport,
    int *vp_lag_vp)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(vp_lag_vp, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_find_virtual(unit, gport, vp_lag_vp));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_notify(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type)
{
    return SHR_E_NONE;
}

int
xfs_ltsw_trunk_failover_flags_extract(
    int unit,
    uint32_t flags,
    bcmint_trunk_type_t t_type,
    uint32_t *fail_flags)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_fp_flags_extract(unit, flags,
                                                          fail_flags));
            break;
        case bcmintTrunkTypeFabric:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_fabric_flags_extract(unit, flags,
                                                              fail_flags));
            break;
        case bcmintTrunkTypeVplag:
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_failover_psc_validate(
    int unit,
    bcmint_trunk_type_t t_type,
    int psc)
{
    SHR_FUNC_ENTER(unit);

    switch (t_type) {
        case bcmintTrunkTypeFrontPanel:
        case bcmintTrunkTypeFabric:
            if (psc != BCM_TRUNK_PSC_PORTFLOW) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_failover_set(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_gport_t fail_port,
    int psc,
    int ftp_count,
    bcm_gport_t *ftp)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_fp_set(unit, t_id, fail_port,
                                                psc, ftp_count, ftp));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_lag_failover_enable_set(unit, fail_port,
                                                        ftp_count ? 1 : 0));
            break;
        case bcmintTrunkTypeFabric:
            if (ftp_count > 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (ltsw_xfs_trunk_failover_fabric_set(unit, t_id, -1,
                                                        psc, ftp_count, ftp));
            }
            if (fail_port != -1) {
                int i, j, next = 1, failto_port;

                for (i = 0; i < ftp_count; i++) {
                    if (ftp[i] != fail_port) {
                        continue;
                    }
                    for (j = ((i + 1) % ftp_count);
                         j != i;
                         /* coverity[dead_error_line : FALSE] */
                         j = ((j + 1) % ftp_count)) {
                        failto_port = BCM_GPORT_MODPORT_PORT_GET(ftp[j]);

                        SHR_IF_ERR_VERBOSE_EXIT
                            (ltsw_xfs_trunk_failover_fabric_port_set(unit,
                                                                 fail_port,
                                                                 failto_port));
                        /* coverity[dead_error_condition : FALSE] */
                        if (next) {
                            break;
                        }
                    }
                }
            }
            if (fail_port != -1) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (ltsw_xfs_trunk_failover_fabric_enable_set(unit, t_id,
                                                               fail_port,
                                                               ftp_count ?
                                                               1 : 0));
            }
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_failover_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_gport_t fail_port,
    int *psc,
    int ftp_max,
    bcm_gport_t *ftp,
    int *ftp_count)
{
    int enable = 0;

    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_fp_get(unit, t_id, fail_port,
                                                psc, ftp_max, ftp, ftp_count));
            break;
        case bcmintTrunkTypeFabric:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_fabric_enable_get(unit, t_id,
                                                           fail_port, &enable));
            if (enable) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (ltsw_xfs_trunk_failover_fabric_get(unit, t_id, -1,
                                                        psc, ftp_max,
                                                        ftp, ftp_count));
            } else {
                if (psc) {
                    *psc = -1;
                }
                if (ftp_count) {
                    *ftp_count = 0;
                }
            }
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_failover_update(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    int psc,
    uint32_t fail_flags,
    bcm_gport_t fail_port,
    int ftp_max,
    int member_count,
    bcm_trunk_member_t *member_array)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_update_fp(unit, t_id, t_type,
                                                   psc, fail_flags,
                                                   fail_port, ftp_max,
                                                   member_count, member_array));
            break;
        case bcmintTrunkTypeFabric:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xfs_trunk_failover_update_fabric(unit, t_id, t_type,
                                                       psc, fail_flags,
                                                       fail_port, ftp_max,
                                                       member_count,
                                                       member_array));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_override_set(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_override_type_t o_type,
    int o_index,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(o_type);
    COMPILER_REFERENCE(o_index);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_override_set(unit, t_id, enable));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_override_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_override_type_t o_type,
    int o_index,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    COMPILER_REFERENCE(o_type);
    COMPILER_REFERENCE(o_index);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_override_get(unit, t_id, enable));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_member_status_set(
    int unit,
    bcm_port_t port,
    int status)
{
    bcmi_ltsw_dlb_type_t dlb_type;

    SHR_FUNC_ENTER(unit);

    dlb_type = bcmi_dlb_type_fp_trunk;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_dlb_member_status_set(unit, port, dlb_type, status));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_member_status_get(
    int unit,
    bcm_port_t port,
    int *status)
{
    bcmi_ltsw_dlb_type_t dlb_type;

    SHR_FUNC_ENTER(unit);

    dlb_type = bcmi_dlb_type_fp_trunk;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_dlb_member_status_get(unit, port, dlb_type, status));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_find_dlb_id(
    int unit,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    int *dlb_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_dlb_find_dlb_id(unit, t_type, t_id, t_priv, dlb_id));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_vp_lag_member_update(
    int unit,
    int vp_lag_vp,
    bcm_gport_t gport)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_vp_lag_member_update(unit, vp_lag_vp, gport));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_vp_lag_vp_learn_get(
    int unit,
    int vp_lag_vp,
    uint32_t *flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_vp_lag_vp_learn_get(unit, vp_lag_vp, flags));

exit:
    SHR_FUNC_EXIT();
}

int
xfs_ltsw_trunk_vp_lag_vp_learn_set(
    int unit,
    int vp_lag_vp,
    uint32_t flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xfs_trunk_vp_lag_vp_learn_set(unit, vp_lag_vp, flags));

exit:
    SHR_FUNC_EXIT();
}

