/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm/mirror.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/xgs/mirror.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/tunnel.h>
#include <bcm_int/ltsw/switch.h>
#include <bcm_int/ltsw/field.h>
#include <bcm_int/ltsw/issu.h>
#include <bcm_int/ltsw/generated/mirror_ha.h>

#include <sal/sal_types.h>
#include <shr/shr_bitop.h>
#include <bsl/bsl.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>
#include <bcmlt/bcmlt.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_MIRROR

/*! Mirror destination is a tunnel encap. */
#define MIRROR_DEST_IS_TUNNEL(mirror_dest) \
            ((mirror_dest->flags & BCMINT_MIRROR_DEST_TUNNELS) || \
             (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_PSAMP_FORMAT_2) || \
             (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP))

/*!
 * \brief Ethernet type for mirror encap.
 */
/*! IPv4 type. */
#define MIRROR_ENCAP_ETHERTYPE_IPV4 0x0800

/*! IPv6 type. */
#define MIRROR_ENCAP_ETHERTYPE_IPV6 0x86DD

/*!
 * \brief IP protocol type for mirror encap.
 */
/*! GRE protocol. */
#define MIRROR_ENCAP_IP_PROTO_TYPE_GRE 0x2F

/*! UDP protocol. */
#define MIRROR_ENCAP_IP_PROTO_TYPE_UDP 0x11

/*! Default protocol type of GRE header. */
#define MIRROR_ENCAP_GRE_DEF_PROTO_TYPE 0x88BE

/*! GRE protocol type for ERSPAN type III. */
#define MIRROR_ENCAP_GRE_PROTO_TYPE_ERSPAN3 0x22EB

/*!
 * \brief IP protocol version.
 */
/*! IPv4. */
#define MIRROR_ENCAP_IP_VER_IPV4 4

/*! IPv6. */
#define MIRROR_ENCAP_IP_VER_IPV6 6

/*!
 * \brief Mirror container number on source.
 */
/*! Max num. */
#define MIRROR_CONTAINER_NUM_MAX 4

/*! Ingress mirroring port. */
#define MIRROR_CONTAINER_NUM_PORT_ING 4

/*! Egress mirroring port. */
#define MIRROR_CONTAINER_NUM_PORT_EGR 4

/*! Mirror instance number per session table. */
#define MIRROR_INSTANCE_NUM 8

/*! Multiple mirror destination IP group allocator number. */
#define MIRROR_MULTI_DIP_ALLOC_NUM 3

/*!
 * \brief RPSAN encapsulation structure.
 */
typedef struct mirror_encap_rspan_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! VLAN priority to insert into the encapsulation header. Applicable only when vlan_id is valid. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header. Applicable only if vlan_id is valid. */
    bool cfi;

    /*! VLAN ID to insert into the mirrored packet. */
    bcm_vlan_t vlan_id;

    /*! TPID to insert into the mirrored packet. */
    uint16_t tpid;

} mirror_encap_rspan_t;

/*!
 * \brief ERSPAN encapsulation structure.
 */
typedef struct mirror_encap_erspan_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv4 address. */
    bcm_ip_t src_ipv4;

    /*! Destination IPv4 address. */
    bcm_ip_t dst_ipv4;

    /*! IPv4 type of service. */
    uint8_t tos;

    /*! IPv4 time to live. */
    uint8_t ttl;

    /*! IPv4 protocol type. */
    uint8_t proto;

    /*! IPv4 dont fragment flag. */
    bool df;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! GRE header, 0x88BE for GRE protocol type 2, 0x22EB for GRE protocol type 3. */
    uint32_t gre_header;

} mirror_encap_erspan_t;

/*!
 * \brief ERSPAN IPv6 encapsulation structure.
 */
typedef struct mirror_encap_erspan_ipv6_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv6 address. */
    bcm_ip6_t src_ipv6;

    /*! Destination IPv6 address. */
    bcm_ip6_t dst_ipv6;

    /*! IPv6 traffic class. */
    uint8_t traffic_class;

    /*! IPv6 hop limit. */
    uint8_t hop_limit;

    /*! IPv6 next header. */
    uint8_t next_header;

    /*! IPv6 flow label. */
    uint32_t flow_label;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! GRE header, 0x88BE for GRE protocol type 2, 0x22EB for GRE protocol type 3. */
    uint32_t gre_header;

} mirror_encap_erspan_ipv6_t;

/*!
 * \brief PSAMP encap structure.
 */
typedef struct mirror_encap_psamp_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv4 address. */
    bcm_ip_t src_ipv4;

    /*! Destination IPv4 address. */
    bcm_ip_t dst_ipv4;

    /*! IPv4 type of service. */
    uint8_t tos;

    /*! IPv4 time to live. */
    uint8_t ttl;

    /*! IPv4 protocol type. */
    uint8_t proto;

    /*! IPv4 dont fragment flag. */
    bool df;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Observation domain for IP flow information export (IPFIX) header. */
    uint32_t observation_domain;

    /*! Template identifier for IPFIX header. */
    uint16_t template_id;

    /*! Starting sequence number in PSAMP header. */
    uint32_t initial_seq_num;

} mirror_encap_psamp_t;

/*!
 * \brief PSAMP IPv6 encapsulation structure.
 */
typedef struct mirror_encap_psamp_ipv6_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv6 address. */
    bcm_ip6_t src_ipv6;

    /*! Destination IPv6 address. */
    bcm_ip6_t dst_ipv6;

    /*! IPv6 traffic class. */
    uint8_t traffic_class;

    /*! IPv6 hop limit. */
    uint8_t hop_limit;

    /*! IPv6 next header. */
    uint8_t next_header;

    /*! IPv6 flow label. */
    uint32_t flow_label;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Observation domain for IP flow information export (IPFIX) header. */
    uint32_t observation_domain;

    /*! Template identifier for IPFIX header. */
    uint16_t template_id;

    /*! Starting sequence number in PSAMP header. */
    uint32_t initial_seq_num;

} mirror_encap_psamp_ipv6_t;

/*!
 * \brief PSAMP_METADATA encap structure.
 */
typedef struct mirror_encap_psamp_metadata_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv4 address. */
    bcm_ip_t src_ipv4;

    /*! Destination IPv4 address. */
    bcm_ip_t dst_ipv4;

    /*! IPv4 type of service. */
    uint8_t tos;

    /*! IPv4 time to live. */
    uint8_t ttl;

    /*! IPv4 protocol type. */
    uint8_t proto;

    /*! IPv4 dont fragment flag. */
    bool df;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Observation domain for IP flow information export (IPFIX) header. */
    uint32_t observation_domain;

    /*! Template identifier for IPFIX header. */
    uint16_t template_id;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Starting sequence number in PSAMP header. */
    uint32_t initial_seq_num;

} mirror_encap_psamp_metadata_t;

/*!
 * \brief PSAMP_METADATA IPv6 encapsulation structure.
 */
typedef struct mirror_encap_psamp_metadata_ipv6_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv6 address. */
    bcm_ip6_t src_ipv6;

    /*! Destination IPv6 address. */
    bcm_ip6_t dst_ipv6;

    /*! IPv6 traffic class. */
    uint8_t traffic_class;

    /*! IPv6 hop limit. */
    uint8_t hop_limit;

    /*! IPv6 next header. */
    uint8_t next_header;

    /*! IPv6 flow label. */
    uint32_t flow_label;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Observation domain for IP flow information export (IPFIX) header. */
    uint32_t observation_domain;

    /*! Template identifier for IPFIX header. */
    uint16_t template_id;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Starting sequence number in PSAMP header. */
    uint32_t initial_seq_num;

} mirror_encap_psamp_metadata_ipv6_t;

/*!
 * \brief sFlow encapsulation structure.
 */
typedef struct mirror_encap_sflow_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv4 address. */
    bcm_ip_t src_ipv4;

    /*! Destination IPv4 address. */
    bcm_ip_t dst_ipv4;

    /*! IPv4 type of service. */
    uint8_t tos;

    /*! IPv4 time to live. */
    uint8_t ttl;

    /*! IPv4 protocol type. */
    uint8_t proto;

    /*! IPv4 dont fragment flag. */
    bool df;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

} mirror_encap_sflow_t;

/*!
 * \brief sFlow IPv6 encapsulation structure.
 */
typedef struct mirror_encap_sflow_ipv6_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv6 address. */
    bcm_ip6_t src_ipv6;

    /*! Destination IPv6 address. */
    bcm_ip6_t dst_ipv6;

    /*! IPv6 traffic class. */
    uint8_t traffic_class;

    /*! IPv6 hop limit. */
    uint8_t hop_limit;

    /*! IPv6 next header. */
    uint8_t next_header;

    /*! IPv6 flow label. */
    uint32_t flow_label;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

} mirror_encap_sflow_ipv6_t;

/*!
 * \brief sFlow_SEQ encapsulation structure.
 */
typedef struct mirror_encap_sflow_seq_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv4 address. */
    bcm_ip_t src_ipv4;

    /*! Destination IPv4 address. */
    bcm_ip_t dst_ipv4;

    /*! IPv4 type of service. */
    uint8_t tos;

    /*! IPv4 time to live. */
    uint8_t ttl;

    /*! IPv4 protocol type. */
    uint8_t proto;

    /*! IPv4 dont fragment flag. */
    bool df;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Starting sequence number in PSAMP header. */
    uint32_t initial_seq_num;

} mirror_encap_sflow_seq_t;

/*!
 * \brief sFlow_SEQ IPv6 encapsulation structure.
 */
typedef struct mirror_encap_sflow_seq_ipv6_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv6 address. */
    bcm_ip6_t src_ipv6;

    /*! Destination IPv6 address. */
    bcm_ip6_t dst_ipv6;

    /*! IPv6 traffic class. */
    uint8_t traffic_class;

    /*! IPv6 hop limit. */
    uint8_t hop_limit;

    /*! IPv6 next header. */
    uint8_t next_header;

    /*! IPv6 flow label. */
    uint32_t flow_label;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Starting sequence number in PSAMP header. */
    uint32_t initial_seq_num;

} mirror_encap_sflow_seq_ipv6_t;

/*!
 * \brief Mirror-on-drop encapsulation structure.
 */
typedef struct mirror_encap_mirror_on_drop_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv4 address. */
    bcm_ip_t src_ipv4;

    /*! Destination IPv4 address. */
    bcm_ip_t dst_ipv4;

    /*! IPv4 type of service. */
    uint8_t tos;

    /*! IPv4 time to live. */
    uint8_t ttl;

    /*! IPv4 protocol type. */
    uint8_t proto;

    /*! IPv4 dont fragment flag. */
    bool df;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Observation domain for IP flow information export (IPFIX) header. */
    uint32_t observation_domain;

    /*! Template identifier for IPFIX header. */
    uint16_t template_id;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Switch id. */
    uint32_t switch_id;

    /*! Starting sequence number in PSAMP header. */
    uint32_t initial_seq_num;

} mirror_encap_mirror_on_drop_t;

/*!
 * \brief sFlow IPv6 encapsulation structure.
 */
typedef struct mirror_encap_mirror_on_drop_ipv6_s {

    /*! Enable to remove the outer VLAN tag from the mirrored packet. */
    bool untag;

    /*! Source MAC address. */
    bcm_mac_t src_mac;

    /*! Destination MAC address. */
    bcm_mac_t dst_mac;

    /*! Source IPv6 address. */
    bcm_ip6_t src_ipv6;

    /*! Destination IPv6 address. */
    bcm_ip6_t dst_ipv6;

    /*! IPv6 traffic class. */
    uint8_t traffic_class;

    /*! IPv6 hop limit. */
    uint8_t hop_limit;

    /*! IPv6 next header. */
    uint8_t next_header;

    /*! IPv6 flow label. */
    uint32_t flow_label;

    /*! Layer-4 UDP destination port. */
    uint16_t l4_dst_port;

    /*! Layer-4 UDP source port. */
    uint16_t l4_src_port;

    /*! Ethertype. */
    uint16_t ethertype;

    /*! Enable to add an outer VLAN tag into the encapsulation header. */
    bool outer_vlan;

    /*! VLAN priority to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    uint8_t pri;

    /*! CFI value to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bool cfi;

    /*! VLAN ID to insert into the encapsulation header, applicable only if outer_vlan is enabled. */
    bcm_vlan_t vlan_id;

    /*! TPID for VLAN tag, applicable only if outer_vlan is enabled. */
    uint16_t tpid;

    /*! Observation domain for IP flow information export (IPFIX) header. */
    uint32_t observation_domain;

    /*! Template identifier for IPFIX header. */
    uint16_t template_id;

    /*! Specifies the type of metadata. */
    int metadata_type;

    /*! Encapsulation header metadata, applicable only if metadata_type == TABLE_METADATA. */
    uint16_t metadata;

    /*! Switch id. */
    uint32_t switch_id;

    /*! Starting sequence number in PSAMP header. */
    uint32_t initial_seq_num;

} mirror_encap_mirror_on_drop_ipv6_t;

/*!
 * \brief Data structure to save ingress MOD control data.
 */
typedef struct mirror_ingress_mod_ctrl_s {

    /*! Ingress MOD control data is initialized or not. */
    bool inited;

    /*! Ingress MOD event group number. */
    int ingress_mod_event_group_num;

    /*! Ingress MOD event group. */
    bcmint_mirror_ingress_mod_event_group_cfg_t *ingress_mod_event_group;

    /*! Ingress MOD event profile number. */
    int ingress_mod_event_profile_num;

    /*! Ingress MOD event profile. */
    bcmint_mirror_ingress_mod_event_profile_cfg_t *ingress_mod_event_profile;

    /*! Profile used bitmap. */
    SHR_BITDCL *profile_bmp;

} mirror_ingress_mod_ctrl_t;

/*!
 * \brief Multiple mirror destination IP allocator data structure.
 *
 * Store an array for each block's longest allocate-able entry number.
 * Total number of block is (size * 2 - 1)
 *
 * Multiple DIP allocator use a variant of buddy memory allocation algorithm,
 * for example, for a 64 size entry table, blocks would be like below diagram:
 *
 *   Block indices
 *
 *   Size
 *        -----------------------------------------------------------------
 *     64 |                               0                               |
 *        -----------------------------------------------------------------
 *     32 |               1               |               2               |
 *        -----------------------------------------------------------------
 *     16 |       3       |       4       |       5       |       6       |
 *        -----------------------------------------------------------------
 *      8 |   7   |   8   |   9   |  10   |  11   |  12   |  13   |  14   |
 *        -----------------------------------------------------------------
 *      4 |15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |
 *        -----------------------------------------------------------------
 *      2 |31|.........................................................|62|
 *        -----------------------------------------------------------------
 *      1 |63|........................................................|126|
 *        -----------------------------------------------------------------
 *
 * After initialization, longest[block_index] == block_size
 * Block size means the number of allocated entry in HW.

 */
typedef struct mirror_multi_dip_alloc_s {

    /*! Maximun number of entries that can be allocated. */
    uint32_t size;

    /*! Array for longest allocate-able entry number of blocks. */
    uint32_t *longest;

} mirror_multi_dip_alloc_t;

/*!
 * \brief Data structure to save multiple mirror DIP control data.
 */
typedef struct mirror_multi_dip_ctrl_s {

    /*! Multiple DIP control data is initialized or not. */
    bool inited;

    /*! Maximun number of DIP groups. */
    uint32_t group_num;

    /*! Multiple DIP group. */
    bcmint_mirror_multi_dip_group_cfg_t *multi_dip_group;

    /*! Multiple DIP group allocator. */
    mirror_multi_dip_alloc_t *multi_dip_allocator;

} mirror_multi_dip_ctrl_t;

/******************************************************************************
 * Private functions
 */


static void
mirror_ingress_mod_event_profile_id_hold(int unit, int id);

static int
mirror_multi_dip_allocator_create(
    int unit,
    int size,
    mirror_multi_dip_alloc_t *allocator);

static int
mirror_multi_dip_allocator_recover(int unit);

static int
mirror_multi_dip_group_get(
    int unit,
    int id,
    bcmint_mirror_multi_dip_group_cfg_t *dip_group);

/* Static global variable to hold ingress mirror-on-drop event index. */
static int mirror_ingress_mod_event_index[BCM_MAX_NUM_UNITS][bcmMirrorIngModEventCount];

/* Static global variable to hold ingress mirror-on-drop control data. */
static mirror_ingress_mod_ctrl_t mirror_ingress_mod_ctrl[BCM_MAX_NUM_UNITS] = {{0}};

/* Static global variable to hold multiple mirror DIP control data. */
static mirror_multi_dip_ctrl_t mirror_multi_dip_ctrl[BCM_MAX_NUM_UNITS]  = {{0}};

/* Ingress MOD control data. */
#define MIRROR_ING_MOD_CTRL(unit) \
    (&mirror_ingress_mod_ctrl[unit])

/* Check if ingress MOD is initialized. */
#define MIRROR_ING_MOD_CTRL_INIT_CHECK(unit)                              \
    do {                                                                  \
        mirror_ingress_mod_ctrl_t *imod_ctrl = MIRROR_ING_MOD_CTRL(unit); \
        if (imod_ctrl->inited == false) {                                 \
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);                       \
        }                                                                 \
    } while(0)

/* Ingress mirror-on-drop event group number. */
#define MIRROR_ING_MOD_EVENT_GRP_NUM(unit) \
    (MIRROR_ING_MOD_CTRL(unit)->ingress_mod_event_group_num)

/* Ingress mirror-on-drop event group node. */
#define MIRROR_ING_MOD_EVENT_GRP(unit, id) \
    (MIRROR_ING_MOD_CTRL(unit)->ingress_mod_event_group[id - \
     BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE])

/* Check ingress mirror-on-drop event group id is valid. */
#define MIRROR_ING_MOD_EVENT_GRP_ID_CHECK(unit, id)             \
    do {                                                        \
        if ((id) < BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE ||   \
            (id) >= MIRROR_ING_MOD_EVENT_GRP_NUM(unit) +        \
             BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE) {         \
            SHR_ERR_EXIT(SHR_E_PARAM);                   \
        }                                                       \
    } while (0)

/* Reference count of ingress mirror-on-drop event group. */
#define MIRROR_ING_MOD_EVENT_GRP_REF_COUNT(unit, id) \
    (MIRROR_ING_MOD_EVENT_GRP(unit, id).ref_cnt)

/* Ingress mirror-on-drop event profile number. */
#define MIRROR_ING_MOD_EVENT_PROF_NUM(unit) \
    (MIRROR_ING_MOD_CTRL(unit)->ingress_mod_event_profile_num)

/* Ingress mirror-on-drop event profile node. */
#define MIRROR_ING_MOD_EVENT_PROF(unit, id) \
    (MIRROR_ING_MOD_CTRL(unit)->ingress_mod_event_profile[id -  \
     BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE])

/* Ingress mirror-on-drop event profile used bitmap. */
#define ING_MOD_EVENT_PROF_BMP(unit) \
    (MIRROR_ING_MOD_CTRL(unit)->profile_bmp)

/* Set ingress mirror-on-drop event profile used bitmap. */
#define ING_MOD_EVENT_PROF_BMP_USED_SET(unit, id) \
    (SHR_BITSET(ING_MOD_EVENT_PROF_BMP(unit), id))

/* Get ingress mirror-on-drop event profile used bitmap. */
#define ING_MOD_EVENT_PROF_BMP_USED_GET(unit, id) \
    (SHR_BITGET(ING_MOD_EVENT_PROF_BMP(unit), id))

/* Clear ingress mirror-on-drop event profile used bitmap. */
#define ING_MOD_EVENT_PROF_BMP_USED_CLR(unit, id) \
    (SHR_BITCLR(ING_MOD_EVENT_PROF_BMP(unit), id))

/* Check ingress mirror-on-drop event profile id is valid. */
#define MIRROR_ING_MOD_EVENT_PROF_ID_CHECK(unit, id)             \
    do {                                                         \
        if ((id) < BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE ||   \
            (id) >= MIRROR_ING_MOD_EVENT_PROF_NUM(unit) +        \
             BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE) {         \
            SHR_ERR_EXIT(SHR_E_PARAM);                    \
        }                                                        \
    } while (0)

/* Multiple mirror destination IP control data. */
#define MIRROR_MULTI_DIP_CTRL(unit) \
    (&mirror_multi_dip_ctrl[unit])

/* Check if multiple DIP is initialized. */
#define MIRROR_MULTI_DIP_CTRL_INIT_CHECK(unit)                            \
    do {                                                                  \
        mirror_multi_dip_ctrl_t *mdip_ctrl = MIRROR_MULTI_DIP_CTRL(unit); \
        if (mdip_ctrl->inited == false) {                                 \
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);                       \
        }                                                                 \
    } while(0)

/* Multiple mirror destination IP group number. */
#define MIRROR_MULTI_DIP_GRP_NUM(unit) \
    (MIRROR_MULTI_DIP_CTRL(unit)->group_num)

/* Multiple mirror destination IP group node. */
#define MIRROR_MULTI_DIP_GRP(unit, id) \
    (MIRROR_MULTI_DIP_CTRL(unit)->multi_dip_group[id - \
     BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE])

/* Reference count of multiple mirror destination IP group. */
#define MIRROR_MULTI_DIP_GRP_REF_COUNT(unit, id) \
    (MIRROR_MULTI_DIP_GRP(unit, id).ref_cnt)

/* Check ingress mirror-on-drop event group id is valid. */
#define MIRROR_MULTI_DIP_GRP_ID_CHECK(unit, id)             \
    do {                                                    \
        if ((id) < BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE ||   \
            (id) >= MIRROR_MULTI_DIP_GRP_NUM(unit) +        \
             BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE) {         \
            SHR_ERR_EXIT(SHR_E_PARAM);               \
        }                                                   \
    } while (0)

/* Multiple mirror destination IP group allocator node. */
#define MIRROR_MULTI_DIP_ALLOC(unit, id) \
    (MIRROR_MULTI_DIP_CTRL(unit)->multi_dip_allocator[id])

/* Multiple DIP allocator for IPv4 index 0 entry. */
#define MIRROR_MULTI_DIP_IPV4_IDX0_ALLOC(unit) \
    (MIRROR_MULTI_DIP_CTRL(unit)->multi_dip_allocator[0])

/* Multiple DIP allocator for IPv4 index 1 entry. */
#define MIRROR_MULTI_DIP_IPV4_IDX1_ALLOC(unit) \
    (MIRROR_MULTI_DIP_CTRL(unit)->multi_dip_allocator[1])

/* Multiple DIP allocator for IPv6 entry. */
#define MIRROR_MULTI_DIP_IPV6_ALLOC(unit) \
    (MIRROR_MULTI_DIP_CTRL(unit)->multi_dip_allocator[2])

/*
 * Encapsulation type.
 */
typedef enum {
    /* No encap header. */
    ENCAP_NONE,

    /* RSPAN encap. */
    ENCAP_RSPAN,

    /* ERSPAN encap. */
    ENCAP_ERSPAN,

    /* ERSPAN IPv6 encap. */
    ENCAP_ERSPAN_IPv6,

    /* PSAMP encap. */
    ENCAP_PSAMP,

    /* PSAMP IPv6 encap. */
    ENCAP_PSAMP_IPv6,

    /* PSAMP format 2 encap. */
    ENCAP_PSAMP_METADATA,

    /* PSAMP format 2 IPv6 encap. */
    ENCAP_PSAMP_METADATA_IPv6,

    /* sFlow encap. */
    ENCAP_SFLOW,

    /* sFlow IPv6 encap. */
    ENCAP_SFLOW_IPv6,

    /* sFlow encap with sequence number. */
    ENCAP_SFLOW_SEQ,

    /* sFlow IPv6 encap with sequence number. */
    ENCAP_SFLOW_SEQ_IPv6,

    /* Mirror-on-drop encap. */
    ENCAP_MIRROR_ON_DROP,

    /* Mirror-on-drop IPv6 encap. */
    ENCAP_MIRROR_ON_DROP_IPv6,

    /* Last encap type. */
    ENCAP_COUNT
} mirror_encap_type;

/*
 * Data structure for Mirror encapsulation profile entry.
 */
typedef struct mirror_encap_profile_entry_s {
    /* Egress mirroring or not. */
    bool egr;

    /* Destination system port ID. */
    int sys_port;

    /* Encap type. */
    mirror_encap_type type;

    /* Encap data. */
    union {
        mirror_encap_rspan_t rspan;
        mirror_encap_erspan_t erspan;
        mirror_encap_erspan_ipv6_t erspan_ipv6;
        mirror_encap_psamp_t psamp;
        mirror_encap_psamp_ipv6_t psamp_ipv6;
        mirror_encap_psamp_metadata_t psamp_metadata;
        mirror_encap_psamp_metadata_ipv6_t psamp_metadata_ipv6;
        mirror_encap_sflow_t sflow;
        mirror_encap_sflow_ipv6_t sflow_ipv6;
        mirror_encap_sflow_seq_t sflow_seq;
        mirror_encap_sflow_seq_ipv6_t sflow_seq_ipv6;
        mirror_encap_mirror_on_drop_t mirror_on_drop;
        mirror_encap_mirror_on_drop_ipv6_t mirror_on_drop_ipv6;
    } encap;
} mirror_encap_profile_entry_t;

/*
 * Data structure to store encapsulation information.
 */
typedef struct mirror_encap_info_s {
    /* Encap type for specific encap entry. */
    mirror_encap_type *type;
} mirror_encap_info_t;

static mirror_encap_info_t mirror_encap_info[BCM_MAX_NUM_UNITS];

/*!
 * \brief Add Mirror encap entry to RSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_table_add(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.rspan.untag;
    field[2].u.val = entry->encap.rspan.vlan_id;
    field[3].u.val = entry->encap.rspan.tpid;
    field[4].u.val = entry->encap.rspan.pri;
    field[5].u.val = entry->encap.rspan.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit, MIRROR_ENCAP_RSPANs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from RSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_ENCAP_RSPANs, &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from RSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_table_get(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_RSPANs,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.rspan.untag = field[1].u.val;
    entry->encap.rspan.vlan_id = field[2].u.val;
    entry->encap.rspan.tpid = field[3].u.val;
    entry->encap.rspan.pri = field[4].u.val;
    entry->encap.rspan.cfi = field[5].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to ERSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_table_add(int unit, int index,
                              mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {GRE_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.erspan.untag;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.erspan.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.erspan.dst_mac);
    field[3].u.val = data;
    field[4].u.val = entry->encap.erspan.src_ipv4;
    field[5].u.val = entry->encap.erspan.dst_ipv4;
    field[6].u.val = entry->encap.erspan.tos;
    field[7].u.val = entry->encap.erspan.ttl;
    field[8].u.val = entry->encap.erspan.proto;
    field[9].u.val = entry->encap.erspan.df;
    field[10].u.val = entry->encap.erspan.ethertype;
    field[11].u.val = entry->encap.erspan.outer_vlan;
    field[12].u.val = entry->encap.erspan.vlan_id;
    field[13].u.val = entry->encap.erspan.tpid;
    field[14].u.val = entry->encap.erspan.gre_header;
    field[15].u.val = entry->encap.erspan.pri;
    field[16].u.val = entry->encap.erspan.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit, MIRROR_ENCAP_ERSPANs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from ERSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_ENCAP_ERSPANs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from ERSPAN LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_table_get(int unit, int index,
                              mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {GRE_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_ERSPANs,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.erspan.untag = field[1].u.val;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.erspan.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.erspan.dst_mac, &data);
    entry->encap.erspan.src_ipv4 = field[4].u.val;
    entry->encap.erspan.dst_ipv4 = field[5].u.val;
    entry->encap.erspan.tos = field[6].u.val;
    entry->encap.erspan.ttl = field[7].u.val;
    entry->encap.erspan.proto = field[8].u.val;
    entry->encap.erspan.df = field[9].u.val;
    entry->encap.erspan.ethertype = field[10].u.val;
    entry->encap.erspan.outer_vlan = field[11].u.val;
    entry->encap.erspan.vlan_id = field[12].u.val;
    entry->encap.erspan.tpid = field[13].u.val;
    entry->encap.erspan.gre_header = field[14].u.val;
    entry->encap.erspan.pri = field[15].u.val;
    entry->encap.erspan.cfi = field[16].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to ERSPAN IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_ipv6_table_add(int unit, int index,
                                   mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {GRE_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.erspan_ipv6.untag;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.erspan_ipv6.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.erspan_ipv6.dst_mac);
    field[3].u.val = data;
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.erspan_ipv6.src_ipv6);
    field[4].u.val = ipv6_addr[1];
    field[5].u.val = ipv6_addr[0];
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.erspan_ipv6.dst_ipv6);
    field[6].u.val = ipv6_addr[1];
    field[7].u.val = ipv6_addr[0];
    field[8].u.val = entry->encap.erspan_ipv6.traffic_class;
    field[9].u.val = entry->encap.erspan_ipv6.hop_limit;
    field[10].u.val = entry->encap.erspan_ipv6.next_header;
    field[11].u.val = entry->encap.erspan_ipv6.flow_label;
    field[12].u.val = entry->encap.erspan_ipv6.ethertype;
    field[13].u.val = entry->encap.erspan_ipv6.outer_vlan;
    field[14].u.val = entry->encap.erspan_ipv6.vlan_id;
    field[15].u.val = entry->encap.erspan_ipv6.tpid;
    field[16].u.val = entry->encap.erspan_ipv6.gre_header;
    field[17].u.val = entry->encap.erspan_ipv6.pri;
    field[18].u.val = entry->encap.erspan_ipv6.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_ERSPAN_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from ERSPAN IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_ipv6_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_ERSPAN_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from ERSPAN IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_ipv6_table_get(int unit, int index,
                                   mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {GRE_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_ERSPAN_IPV6s,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.erspan_ipv6.untag = field[1].u.val;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.erspan_ipv6.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.erspan_ipv6.dst_mac, &data);
    ipv6_addr[1] = field[4].u.val;
    ipv6_addr[0] = field[5].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.erspan_ipv6.src_ipv6, ipv6_addr);
    ipv6_addr[1] = field[6].u.val;
    ipv6_addr[0] = field[7].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.erspan_ipv6.dst_ipv6, ipv6_addr);
    entry->encap.erspan_ipv6.traffic_class = field[8].u.val;
    entry->encap.erspan_ipv6.hop_limit = field[9].u.val;
    entry->encap.erspan_ipv6.next_header = field[10].u.val;
    entry->encap.erspan_ipv6.flow_label = field[11].u.val;
    entry->encap.erspan_ipv6.ethertype = field[12].u.val;
    entry->encap.erspan_ipv6.outer_vlan = field[13].u.val;
    entry->encap.erspan_ipv6.vlan_id = field[14].u.val;
    entry->encap.erspan_ipv6.tpid = field[15].u.val;
    entry->encap.erspan_ipv6.gre_header = field[16].u.val;
    entry->encap.erspan_ipv6.pri = field[17].u.val;
    entry->encap.erspan_ipv6.cfi = field[18].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to PSAMP LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_table_add(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.psamp.untag;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp.dst_mac);
    field[3].u.val = data;
    field[4].u.val = entry->encap.psamp.src_ipv4;
    field[5].u.val = entry->encap.psamp.dst_ipv4;
    field[6].u.val = entry->encap.psamp.tos;
    field[7].u.val = entry->encap.psamp.ttl;
    field[8].u.val = entry->encap.psamp.proto;
    field[9].u.val = entry->encap.psamp.df;
    field[10].u.val = entry->encap.psamp.l4_dst_port;
    field[11].u.val = entry->encap.psamp.l4_src_port;
    field[12].u.val = entry->encap.psamp.ethertype;
    field[13].u.val = entry->encap.psamp.outer_vlan;
    field[14].u.val = entry->encap.psamp.vlan_id;
    field[15].u.val = entry->encap.psamp.tpid;
    field[16].u.val = entry->encap.psamp.observation_domain;
    field[17].u.val = entry->encap.psamp.template_id;
    field[18].u.val = entry->encap.psamp.initial_seq_num;
    field[19].u.val = entry->encap.psamp.pri;
    field[20].u.val = entry->encap.psamp.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_PSAMPs,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from PSAMP LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_PSAMPs,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from PSAMP LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_table_get(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_PSAMPs,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.psamp.untag = field[1].u.val;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp.dst_mac, &data);
    entry->encap.psamp.src_ipv4 = field[4].u.val;
    entry->encap.psamp.dst_ipv4 = field[5].u.val;
    entry->encap.psamp.tos = field[6].u.val;
    entry->encap.psamp.ttl = field[7].u.val;
    entry->encap.psamp.proto = field[8].u.val;
    entry->encap.psamp.df = field[9].u.val;
    entry->encap.psamp.l4_dst_port = field[10].u.val;
    entry->encap.psamp.l4_src_port = field[11].u.val;
    entry->encap.psamp.ethertype = field[12].u.val;
    entry->encap.psamp.outer_vlan = field[13].u.val;
    entry->encap.psamp.vlan_id = field[14].u.val;
    entry->encap.psamp.tpid = field[15].u.val;
    entry->encap.psamp.observation_domain = field[16].u.val;
    entry->encap.psamp.template_id = field[17].u.val;
    entry->encap.psamp.initial_seq_num = field[18].u.val;
    entry->encap.psamp.pri = field[19].u.val;
    entry->encap.psamp.cfi = field[20].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to PSAMP IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_ipv6_table_add(int unit, int index,
                                  mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.psamp_ipv6.untag;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp_ipv6.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp_ipv6.dst_mac);
    field[3].u.val = data;
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.psamp_ipv6.src_ipv6);
    field[4].u.val = ipv6_addr[1];
    field[5].u.val = ipv6_addr[0];
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.psamp_ipv6.dst_ipv6);
    field[6].u.val = ipv6_addr[1];
    field[7].u.val = ipv6_addr[0];
    field[8].u.val = entry->encap.psamp_ipv6.traffic_class;
    field[9].u.val = entry->encap.psamp_ipv6.hop_limit;
    field[10].u.val = entry->encap.psamp_ipv6.next_header;
    field[11].u.val = entry->encap.psamp_ipv6.flow_label;
    field[12].u.val = entry->encap.psamp_ipv6.l4_dst_port;
    field[13].u.val = entry->encap.psamp_ipv6.l4_src_port;
    field[14].u.val = entry->encap.psamp_ipv6.ethertype;
    field[15].u.val = entry->encap.psamp_ipv6.outer_vlan;
    field[16].u.val = entry->encap.psamp_ipv6.vlan_id;
    field[17].u.val = entry->encap.psamp_ipv6.tpid;
    field[18].u.val = entry->encap.psamp_ipv6.observation_domain;
    field[19].u.val = entry->encap.psamp_ipv6.template_id;
    field[20].u.val = entry->encap.psamp_ipv6.initial_seq_num;
    field[21].u.val = entry->encap.psamp_ipv6.pri;
    field[22].u.val = entry->encap.psamp_ipv6.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_PSAMP_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from PSAMP IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_ipv6_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_PSAMP_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from PSAMP IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_ipv6_table_get(int unit, int index,
                                  mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_PSAMP_IPV6s,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.psamp_ipv6.untag = field[1].u.val;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp_ipv6.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp_ipv6.dst_mac, &data);
    ipv6_addr[1] = field[4].u.val;
    ipv6_addr[0] = field[5].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.psamp_ipv6.src_ipv6, ipv6_addr);
    ipv6_addr[1] = field[6].u.val;
    ipv6_addr[0] = field[7].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.psamp_ipv6.dst_ipv6, ipv6_addr);
    entry->encap.psamp_ipv6.traffic_class = field[8].u.val;
    entry->encap.psamp_ipv6.hop_limit = field[9].u.val;
    entry->encap.psamp_ipv6.next_header = field[10].u.val;
    entry->encap.psamp_ipv6.flow_label = field[11].u.val;
    entry->encap.psamp_ipv6.l4_dst_port = field[12].u.val;
    entry->encap.psamp_ipv6.l4_src_port = field[13].u.val;
    entry->encap.psamp_ipv6.ethertype = field[14].u.val;
    entry->encap.psamp_ipv6.outer_vlan = field[15].u.val;
    entry->encap.psamp_ipv6.vlan_id = field[16].u.val;
    entry->encap.psamp_ipv6.tpid = field[17].u.val;
    entry->encap.psamp_ipv6.observation_domain = field[18].u.val;
    entry->encap.psamp_ipv6.template_id = field[19].u.val;
    entry->encap.psamp_ipv6.initial_seq_num = field[20].u.val;
    entry->encap.psamp_ipv6.pri = field[21].u.val;
    entry->encap.psamp_ipv6.cfi = field[22].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to PSAMP_METADATA LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_metadata_table_add(int unit, int index,
                                      mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_SET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*19*/ {METADATAs, 0, 0, {0}},
        /*20*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.psamp_metadata.untag;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp_metadata.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp_metadata.dst_mac);
    field[3].u.val = data;
    field[4].u.val = entry->encap.psamp_metadata.src_ipv4;
    field[5].u.val = entry->encap.psamp_metadata.dst_ipv4;
    field[6].u.val = entry->encap.psamp_metadata.tos;
    field[7].u.val = entry->encap.psamp_metadata.ttl;
    field[8].u.val = entry->encap.psamp_metadata.proto;
    field[9].u.val = entry->encap.psamp_metadata.df;
    field[10].u.val = entry->encap.psamp_metadata.l4_dst_port;
    field[11].u.val = entry->encap.psamp_metadata.l4_src_port;
    field[12].u.val = entry->encap.psamp_metadata.ethertype;
    field[13].u.val = entry->encap.psamp_metadata.outer_vlan;
    field[14].u.val = entry->encap.psamp_metadata.vlan_id;
    field[15].u.val = entry->encap.psamp_metadata.tpid;
    field[16].u.val = entry->encap.psamp_metadata.observation_domain;
    field[17].u.val = entry->encap.psamp_metadata.template_id;

    switch (entry->encap.psamp_metadata.metadata_type) {
        case bcmMirrorPsampFmt2HeaderZeroes:
            field[18].u.sym_val = ZEROESs;
            break;
        case bcmMirrorPsampFmt2HeaderI2eClassId:
            field[18].u.sym_val = ING_TO_EGR_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderNextHopClassId:
            field[18].u.sym_val = NHOP_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderUserMeta:
            field[18].u.sym_val = TABLE_METADATAs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (sal_strcmp(field[18].u.sym_val, ZEROESs) != 0) {
        field[19].flags = BCMI_LT_FIELD_F_SET;
        field[19].u.val = entry->encap.psamp_metadata.metadata;
    }

    field[20].u.val = entry->encap.psamp_metadata.initial_seq_num;
    field[21].u.val = entry->encap.psamp_metadata.pri;
    field[22].u.val = entry->encap.psamp_metadata.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_PSAMP_METADATAs,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from PSAMP_METADATA LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_metadata_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_PSAMP_METADATAs,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from PSAMP_METADATA LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_metadata_table_get(int unit, int index,
                                      mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_GET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*19*/ {METADATAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_PSAMP_METADATAs,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.psamp_metadata.untag = field[1].u.val;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp_metadata.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp_metadata.dst_mac, &data);
    entry->encap.psamp_metadata.src_ipv4 = field[4].u.val;
    entry->encap.psamp_metadata.dst_ipv4 = field[5].u.val;
    entry->encap.psamp_metadata.tos = field[6].u.val;
    entry->encap.psamp_metadata.ttl = field[7].u.val;
    entry->encap.psamp_metadata.proto = field[8].u.val;
    entry->encap.psamp_metadata.df = field[9].u.val;
    entry->encap.psamp_metadata.l4_dst_port = field[10].u.val;
    entry->encap.psamp_metadata.l4_src_port = field[11].u.val;
    entry->encap.psamp_metadata.ethertype = field[12].u.val;
    entry->encap.psamp_metadata.outer_vlan = field[13].u.val;
    entry->encap.psamp_metadata.vlan_id = field[14].u.val;
    entry->encap.psamp_metadata.tpid = field[15].u.val;
    entry->encap.psamp_metadata.observation_domain = field[16].u.val;
    entry->encap.psamp_metadata.template_id = field[17].u.val;

    if (sal_strcmp(field[18].u.sym_val, ZEROESs) == 0) {
        entry->encap.psamp_metadata.metadata_type =
            bcmMirrorPsampFmt2HeaderZeroes;
    } else if (sal_strcmp(field[18].u.sym_val, ING_TO_EGR_CLASS_IDs) == 0) {
        entry->encap.psamp_metadata.metadata_type =
            bcmMirrorPsampFmt2HeaderI2eClassId;
        entry->encap.psamp_metadata.metadata = field[19].u.val;
    } else if (sal_strcmp(field[18].u.sym_val, NHOP_CLASS_IDs) == 0) {
        entry->encap.psamp_metadata.metadata_type =
            bcmMirrorPsampFmt2HeaderNextHopClassId;
        entry->encap.psamp_metadata.metadata = field[19].u.val;
    } else if (sal_strcmp(field[18].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.psamp_metadata.metadata_type =
            bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.psamp_metadata.metadata = field[19].u.val;
    }

    entry->encap.psamp_metadata.initial_seq_num = field[20].u.val;
    entry->encap.psamp_metadata.pri = field[21].u.val;
    entry->encap.psamp_metadata.cfi = field[22].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to PSAMP_METADATA IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_metadata_ipv6_table_add(int unit, int index,
                                           mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_SET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*21*/ {METADATAs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*23*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*24*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.psamp_metadata_ipv6.untag;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp_metadata_ipv6.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.psamp_metadata_ipv6.dst_mac);
    field[3].u.val = data;
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.psamp_metadata_ipv6.src_ipv6);
    field[4].u.val = ipv6_addr[1];
    field[5].u.val = ipv6_addr[0];
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.psamp_metadata_ipv6.dst_ipv6);
    field[6].u.val = ipv6_addr[1];
    field[7].u.val = ipv6_addr[0];
    field[8].u.val = entry->encap.psamp_metadata_ipv6.traffic_class;
    field[9].u.val = entry->encap.psamp_metadata_ipv6.hop_limit;
    field[10].u.val = entry->encap.psamp_metadata_ipv6.next_header;
    field[11].u.val = entry->encap.psamp_metadata_ipv6.flow_label;
    field[12].u.val = entry->encap.psamp_metadata_ipv6.l4_dst_port;
    field[13].u.val = entry->encap.psamp_metadata_ipv6.l4_src_port;
    field[14].u.val = entry->encap.psamp_metadata_ipv6.ethertype;
    field[15].u.val = entry->encap.psamp_metadata_ipv6.outer_vlan;
    field[16].u.val = entry->encap.psamp_metadata_ipv6.vlan_id;
    field[17].u.val = entry->encap.psamp_metadata_ipv6.tpid;
    field[18].u.val = entry->encap.psamp_metadata_ipv6.observation_domain;
    field[19].u.val = entry->encap.psamp_metadata_ipv6.template_id;

    switch (entry->encap.psamp_metadata_ipv6.metadata_type) {
        case bcmMirrorPsampFmt2HeaderZeroes:
            field[20].u.sym_val = ZEROESs;
            break;
        case bcmMirrorPsampFmt2HeaderI2eClassId:
            field[20].u.sym_val = ING_TO_EGR_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderNextHopClassId:
            field[20].u.sym_val = NHOP_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderUserMeta:
            field[20].u.sym_val = TABLE_METADATAs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (sal_strcmp(field[20].u.sym_val, ZEROESs) != 0) {
        field[21].flags = BCMI_LT_FIELD_F_SET;
        field[21].u.val = entry->encap.psamp_metadata_ipv6.metadata;
    }

    field[22].u.val = entry->encap.psamp_metadata_ipv6.initial_seq_num;
    field[23].u.val = entry->encap.psamp_metadata_ipv6.pri;
    field[24].u.val = entry->encap.psamp_metadata_ipv6.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_PSAMP_METADATA_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from PSAMP_METADATA IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_metadata_ipv6_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_PSAMP_METADATA_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from PSAMP_METADATA IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_metadata_ipv6_table_get(int unit, int index,
                                           mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_GET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*21*/ {METADATAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*23*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*24*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_PSAMP_METADATA_IPV6s,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.psamp_metadata_ipv6.untag = field[1].u.val;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp_metadata_ipv6.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.psamp_metadata_ipv6.dst_mac, &data);
    ipv6_addr[1] = field[4].u.val;
    ipv6_addr[0] = field[5].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.psamp_metadata_ipv6.src_ipv6, ipv6_addr);
    ipv6_addr[1] = field[6].u.val;
    ipv6_addr[0] = field[7].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.psamp_metadata_ipv6.dst_ipv6, ipv6_addr);
    entry->encap.psamp_metadata_ipv6.traffic_class = field[8].u.val;
    entry->encap.psamp_metadata_ipv6.hop_limit = field[9].u.val;
    entry->encap.psamp_metadata_ipv6.next_header = field[10].u.val;
    entry->encap.psamp_metadata_ipv6.flow_label = field[11].u.val;
    entry->encap.psamp_metadata_ipv6.l4_dst_port = field[12].u.val;
    entry->encap.psamp_metadata_ipv6.l4_src_port = field[13].u.val;
    entry->encap.psamp_metadata_ipv6.ethertype = field[14].u.val;
    entry->encap.psamp_metadata_ipv6.outer_vlan = field[15].u.val;
    entry->encap.psamp_metadata_ipv6.vlan_id = field[16].u.val;
    entry->encap.psamp_metadata_ipv6.tpid = field[17].u.val;
    entry->encap.psamp_metadata_ipv6.observation_domain = field[18].u.val;
    entry->encap.psamp_metadata_ipv6.template_id = field[19].u.val;
    if (sal_strcmp(field[20].u.sym_val, ZEROESs) == 0) {
        entry->encap.psamp_metadata_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderZeroes;
    } else if (sal_strcmp(field[20].u.sym_val, ING_TO_EGR_CLASS_IDs) == 0) {
        entry->encap.psamp_metadata_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderI2eClassId;
        entry->encap.psamp_metadata_ipv6.metadata = field[21].u.val;
    } else if (sal_strcmp(field[20].u.sym_val, NHOP_CLASS_IDs) == 0) {
        entry->encap.psamp_metadata_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderNextHopClassId;
        entry->encap.psamp_metadata_ipv6.metadata = field[21].u.val;
    } else if (sal_strcmp(field[20].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.psamp_metadata_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.psamp_metadata_ipv6.metadata = field[21].u.val;
    }
    entry->encap.psamp_metadata_ipv6.initial_seq_num = field[22].u.val;
    entry->encap.psamp_metadata_ipv6.pri = field[23].u.val;
    entry->encap.psamp_metadata_ipv6.cfi = field[24].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to SFLOW LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_table_add(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.sflow.untag;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow.dst_mac);
    field[3].u.val = data;
    field[4].u.val = entry->encap.sflow.src_ipv4;
    field[5].u.val = entry->encap.sflow.dst_ipv4;
    field[6].u.val = entry->encap.sflow.tos;
    field[7].u.val = entry->encap.sflow.ttl;
    field[8].u.val = entry->encap.sflow.proto;
    field[9].u.val = entry->encap.sflow.df;
    field[10].u.val = entry->encap.sflow.l4_dst_port;
    field[11].u.val = entry->encap.sflow.l4_src_port;
    field[12].u.val = entry->encap.sflow.ethertype;
    field[13].u.val = entry->encap.sflow.outer_vlan;
    field[14].u.val = entry->encap.sflow.vlan_id;
    field[15].u.val = entry->encap.sflow.tpid;
    field[16].u.val = entry->encap.sflow.pri;
    field[17].u.val = entry->encap.sflow.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_SFLOWs,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from SFLOW LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_SFLOWs,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from SFLOW LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_table_get(int unit, int index,
                             mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_SFLOWs,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.sflow.untag = field[1].u.val;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow.dst_mac, &data);
    entry->encap.sflow.src_ipv4 = field[4].u.val;
    entry->encap.sflow.dst_ipv4 = field[5].u.val;
    entry->encap.sflow.tos = field[6].u.val;
    entry->encap.sflow.ttl = field[7].u.val;
    entry->encap.sflow.proto = field[8].u.val;
    entry->encap.sflow.df = field[9].u.val;
    entry->encap.sflow.l4_dst_port = field[10].u.val;
    entry->encap.sflow.l4_src_port = field[11].u.val;
    entry->encap.sflow.ethertype = field[12].u.val;
    entry->encap.sflow.outer_vlan = field[13].u.val;
    entry->encap.sflow.vlan_id = field[14].u.val;
    entry->encap.sflow.tpid = field[15].u.val;
    entry->encap.sflow.pri = field[16].u.val;
    entry->encap.sflow.cfi = field[17].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to SFLOW IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_ipv6_table_add(int unit, int index,
                                      mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.sflow_ipv6.untag;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow_ipv6.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow_ipv6.dst_mac);
    field[3].u.val = data;
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.sflow_ipv6.src_ipv6);
    field[4].u.val = ipv6_addr[1];
    field[5].u.val = ipv6_addr[0];
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.sflow_ipv6.dst_ipv6);
    field[6].u.val = ipv6_addr[1];
    field[7].u.val = ipv6_addr[0];
    field[8].u.val = entry->encap.sflow_ipv6.traffic_class;
    field[9].u.val = entry->encap.sflow_ipv6.hop_limit;
    field[10].u.val = entry->encap.sflow_ipv6.next_header;
    field[11].u.val = entry->encap.sflow_ipv6.flow_label;
    field[12].u.val = entry->encap.sflow_ipv6.l4_dst_port;
    field[13].u.val = entry->encap.sflow_ipv6.l4_src_port;
    field[14].u.val = entry->encap.sflow_ipv6.ethertype;
    field[15].u.val = entry->encap.sflow_ipv6.outer_vlan;
    field[16].u.val = entry->encap.sflow_ipv6.vlan_id;
    field[17].u.val = entry->encap.sflow_ipv6.tpid;
    field[18].u.val = entry->encap.sflow_ipv6.pri;
    field[19].u.val = entry->encap.sflow_ipv6.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_SFLOW_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from SFLOW IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_ipv6_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_SFLOW_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from SFLOW IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_ipv6_table_get(int unit, int index,
                                  mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_SFLOW_IPV6s,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.sflow_ipv6.untag = field[1].u.val;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow_ipv6.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow_ipv6.dst_mac, &data);
    ipv6_addr[1] = field[4].u.val;
    ipv6_addr[0] = field[5].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.sflow_ipv6.src_ipv6, ipv6_addr);
    ipv6_addr[1] = field[6].u.val;
    ipv6_addr[0] = field[7].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.sflow_ipv6.dst_ipv6, ipv6_addr);
    entry->encap.sflow_ipv6.traffic_class = field[8].u.val;
    entry->encap.sflow_ipv6.hop_limit = field[9].u.val;
    entry->encap.sflow_ipv6.next_header = field[10].u.val;
    entry->encap.sflow_ipv6.flow_label = field[11].u.val;
    entry->encap.sflow_ipv6.l4_dst_port = field[12].u.val;
    entry->encap.sflow_ipv6.l4_src_port = field[13].u.val;
    entry->encap.sflow_ipv6.ethertype = field[14].u.val;
    entry->encap.sflow_ipv6.outer_vlan = field[15].u.val;
    entry->encap.sflow_ipv6.vlan_id = field[16].u.val;
    entry->encap.sflow_ipv6.tpid = field[17].u.val;
    entry->encap.sflow_ipv6.pri = field[18].u.val;
    entry->encap.sflow_ipv6.cfi = field[19].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to SFLOW_SEQ LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_seq_table_add(int unit, int index,
                                 mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_SET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*17*/ {METADATAs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.sflow_seq.untag;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow_seq.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow_seq.dst_mac);
    field[3].u.val = data;
    field[4].u.val = entry->encap.sflow_seq.src_ipv4;
    field[5].u.val = entry->encap.sflow_seq.dst_ipv4;
    field[6].u.val = entry->encap.sflow_seq.tos;
    field[7].u.val = entry->encap.sflow_seq.ttl;
    field[8].u.val = entry->encap.sflow_seq.proto;
    field[9].u.val = entry->encap.sflow_seq.df;
    field[10].u.val = entry->encap.sflow_seq.l4_dst_port;
    field[11].u.val = entry->encap.sflow_seq.l4_src_port;
    field[12].u.val = entry->encap.sflow_seq.ethertype;
    field[13].u.val = entry->encap.sflow_seq.outer_vlan;
    field[14].u.val = entry->encap.sflow_seq.vlan_id;
    field[15].u.val = entry->encap.sflow_seq.tpid;

    switch (entry->encap.sflow_seq.metadata_type) {
        case bcmMirrorPsampFmt2HeaderZeroes:
            field[16].u.sym_val = ZEROESs;
            break;
        case bcmMirrorPsampFmt2HeaderI2eClassId:
            field[16].u.sym_val = ING_TO_EGR_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderNextHopClassId:
            field[16].u.sym_val = NHOP_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderUserMeta:
            field[16].u.sym_val = TABLE_METADATAs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (sal_strcmp(field[16].u.sym_val, ZEROESs) != 0) {
        field[17].flags = BCMI_LT_FIELD_F_SET;
        field[17].u.val = entry->encap.sflow_seq.metadata;
    }

    field[18].u.val = entry->encap.sflow_seq.initial_seq_num;
    field[19].u.val = entry->encap.sflow_seq.pri;
    field[20].u.val = entry->encap.sflow_seq.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_SFLOW_SEQs,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from SFLOW_SEQ LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_seq_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_SFLOW_SEQs,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from SFLOW_SEQ LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_seq_table_get(int unit, int index,
                                 mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_GET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*17*/ {METADATAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_SFLOW_SEQs,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.sflow_seq.untag = field[1].u.val;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow_seq.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow_seq.dst_mac, &data);
    entry->encap.sflow_seq.src_ipv4 = field[4].u.val;
    entry->encap.sflow_seq.dst_ipv4 = field[5].u.val;
    entry->encap.sflow_seq.tos = field[6].u.val;
    entry->encap.sflow_seq.ttl = field[7].u.val;
    entry->encap.sflow_seq.proto = field[8].u.val;
    entry->encap.sflow_seq.df = field[9].u.val;
    entry->encap.sflow_seq.l4_dst_port = field[10].u.val;
    entry->encap.sflow_seq.l4_src_port = field[11].u.val;
    entry->encap.sflow_seq.ethertype = field[12].u.val;
    entry->encap.sflow_seq.outer_vlan = field[13].u.val;
    entry->encap.sflow_seq.vlan_id = field[14].u.val;
    entry->encap.sflow_seq.tpid = field[15].u.val;

    if (sal_strcmp(field[16].u.sym_val, ZEROESs) == 0) {
        entry->encap.sflow_seq.metadata_type =
            bcmMirrorPsampFmt2HeaderZeroes;
    } else if (sal_strcmp(field[16].u.sym_val, ING_TO_EGR_CLASS_IDs) == 0) {
        entry->encap.sflow_seq.metadata_type =
            bcmMirrorPsampFmt2HeaderI2eClassId;
        entry->encap.sflow_seq.metadata = field[17].u.val;
    } else if (sal_strcmp(field[16].u.sym_val, NHOP_CLASS_IDs) == 0) {
        entry->encap.sflow_seq.metadata_type =
            bcmMirrorPsampFmt2HeaderNextHopClassId;
        entry->encap.sflow_seq.metadata = field[17].u.val;
    } else if (sal_strcmp(field[16].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.sflow_seq.metadata_type =
            bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.sflow_seq.metadata = field[17].u.val;
    }
    entry->encap.sflow_seq.initial_seq_num = field[18].u.val;
    entry->encap.sflow_seq.pri = field[19].u.val;
    entry->encap.sflow_seq.cfi = field[20].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to SFLOW_SEQ IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_seq_ipv6_table_add(int unit, int index,
                                      mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_SET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*19*/ {METADATAs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.sflow_seq_ipv6.untag;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow_seq_ipv6.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.sflow_seq_ipv6.dst_mac);
    field[3].u.val = data;
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.sflow_seq_ipv6.src_ipv6);
    field[4].u.val = ipv6_addr[1];
    field[5].u.val = ipv6_addr[0];
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.sflow_seq_ipv6.dst_ipv6);
    field[6].u.val = ipv6_addr[1];
    field[7].u.val = ipv6_addr[0];
    field[8].u.val = entry->encap.sflow_seq_ipv6.traffic_class;
    field[9].u.val = entry->encap.sflow_seq_ipv6.hop_limit;
    field[10].u.val = entry->encap.sflow_seq_ipv6.next_header;
    field[11].u.val = entry->encap.sflow_seq_ipv6.flow_label;
    field[12].u.val = entry->encap.sflow_seq_ipv6.l4_dst_port;
    field[13].u.val = entry->encap.sflow_seq_ipv6.l4_src_port;
    field[14].u.val = entry->encap.sflow_seq_ipv6.ethertype;
    field[15].u.val = entry->encap.sflow_seq_ipv6.outer_vlan;
    field[16].u.val = entry->encap.sflow_seq_ipv6.vlan_id;
    field[17].u.val = entry->encap.sflow_seq_ipv6.tpid;

    switch (entry->encap.sflow_seq_ipv6.metadata_type) {
        case bcmMirrorPsampFmt2HeaderZeroes:
            field[18].u.sym_val = ZEROESs;
            break;
        case bcmMirrorPsampFmt2HeaderI2eClassId:
            field[18].u.sym_val = ING_TO_EGR_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderNextHopClassId:
            field[18].u.sym_val = NHOP_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderUserMeta:
            field[18].u.sym_val = TABLE_METADATAs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (sal_strcmp(field[18].u.sym_val, ZEROESs) != 0) {
        field[19].flags = BCMI_LT_FIELD_F_SET;
        field[19].u.val = entry->encap.sflow_seq_ipv6.metadata;
    }

    field[20].u.val = entry->encap.sflow_seq_ipv6.initial_seq_num;
    field[21].u.val = entry->encap.sflow_seq_ipv6.pri;
    field[22].u.val = entry->encap.sflow_seq_ipv6.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_SFLOW_SEQ_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from SFLOW_SEQ IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_seq_ipv6_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_SFLOW_SEQ_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from SFLOW_SEQ IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_seq_ipv6_table_get(int unit, int index,
                                      mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_GET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*19*/ {METADATAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_SFLOW_SEQ_IPV6s,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.sflow_seq_ipv6.untag = field[1].u.val;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow_seq_ipv6.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.sflow_seq_ipv6.dst_mac, &data);
    ipv6_addr[1] = field[4].u.val;
    ipv6_addr[0] = field[5].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.sflow_seq_ipv6.src_ipv6, ipv6_addr);
    ipv6_addr[1] = field[6].u.val;
    ipv6_addr[0] = field[7].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.sflow_seq_ipv6.dst_ipv6, ipv6_addr);
    entry->encap.sflow_seq_ipv6.traffic_class = field[8].u.val;
    entry->encap.sflow_seq_ipv6.hop_limit = field[9].u.val;
    entry->encap.sflow_seq_ipv6.next_header = field[10].u.val;
    entry->encap.sflow_seq_ipv6.flow_label = field[11].u.val;
    entry->encap.sflow_seq_ipv6.l4_dst_port = field[12].u.val;
    entry->encap.sflow_seq_ipv6.l4_src_port = field[13].u.val;
    entry->encap.sflow_seq_ipv6.ethertype = field[14].u.val;
    entry->encap.sflow_seq_ipv6.outer_vlan = field[15].u.val;
    entry->encap.sflow_seq_ipv6.vlan_id = field[16].u.val;
    entry->encap.sflow_seq_ipv6.tpid = field[17].u.val;

    if (sal_strcmp(field[18].u.sym_val, ZEROESs) == 0) {
        entry->encap.sflow_seq_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderZeroes;
    } else if (sal_strcmp(field[18].u.sym_val, ING_TO_EGR_CLASS_IDs) == 0) {
        entry->encap.sflow_seq_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderI2eClassId;
        entry->encap.sflow_seq_ipv6.metadata = field[19].u.val;
    } else if (sal_strcmp(field[18].u.sym_val, NHOP_CLASS_IDs) == 0) {
        entry->encap.sflow_seq_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderNextHopClassId;
        entry->encap.sflow_seq_ipv6.metadata = field[19].u.val;
    } else if (sal_strcmp(field[18].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.sflow_seq_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.sflow_seq_ipv6.metadata = field[19].u.val;
    }

    entry->encap.sflow_seq_ipv6.initial_seq_num = field[20].u.val;
    entry->encap.sflow_seq_ipv6.pri = field[21].u.val;
    entry->encap.sflow_seq_ipv6.cfi = field[22].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to Mirror-on-drop LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_table_add(int unit, int index,
                                      mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_SET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*19*/ {METADATAs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {SWITCH_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*23*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.mirror_on_drop.untag;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.mirror_on_drop.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data, entry->encap.mirror_on_drop.dst_mac);
    field[3].u.val = data;
    field[4].u.val = entry->encap.mirror_on_drop.src_ipv4;
    field[5].u.val = entry->encap.mirror_on_drop.dst_ipv4;
    field[6].u.val = entry->encap.mirror_on_drop.tos;
    field[7].u.val = entry->encap.mirror_on_drop.ttl;
    field[8].u.val = entry->encap.mirror_on_drop.proto;
    field[9].u.val = entry->encap.mirror_on_drop.df;
    field[10].u.val = entry->encap.mirror_on_drop.l4_dst_port;
    field[11].u.val = entry->encap.mirror_on_drop.l4_src_port;
    field[12].u.val = entry->encap.mirror_on_drop.ethertype;
    field[13].u.val = entry->encap.mirror_on_drop.outer_vlan;
    field[14].u.val = entry->encap.mirror_on_drop.vlan_id;
    field[15].u.val = entry->encap.mirror_on_drop.tpid;
    field[16].u.val = entry->encap.mirror_on_drop.observation_domain;
    field[17].u.val = entry->encap.mirror_on_drop.template_id;

    switch (entry->encap.mirror_on_drop.metadata_type) {
        case bcmMirrorPsampFmt2HeaderZeroes:
            field[18].u.sym_val = ZEROESs;
            break;
        case bcmMirrorPsampFmt2HeaderI2eClassId:
            field[18].u.sym_val = ING_TO_EGR_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderNextHopClassId:
            field[18].u.sym_val = NHOP_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderUserMeta:
            field[18].u.sym_val = TABLE_METADATAs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (sal_strcmp(field[18].u.sym_val, ZEROESs) != 0) {
        field[19].flags = BCMI_LT_FIELD_F_SET;
        field[19].u.val = entry->encap.mirror_on_drop.metadata;
    }

    field[20].u.val = entry->encap.mirror_on_drop.switch_id;
    field[21].u.val = entry->encap.mirror_on_drop.initial_seq_num;
    field[22].u.val = entry->encap.mirror_on_drop.pri;
    field[23].u.val = entry->encap.mirror_on_drop.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_MIRROR_ON_DROPs,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from Mirror-on-drop LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_MIRROR_ON_DROPs,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from Mirror-on-drop LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_table_get(int unit, int index,
                                      mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {DST_IPV4s, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {TOSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {TTLs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {PROTOs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {DO_NOT_FRAGMENTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_GET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*19*/ {METADATAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {SWITCH_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*23*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_MIRROR_ON_DROPs,
                           &lt_entry,
                           NULL, NULL));

    entry->encap.mirror_on_drop.untag = field[1].u.val;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.mirror_on_drop.src_mac, &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.mirror_on_drop.dst_mac, &data);
    entry->encap.mirror_on_drop.src_ipv4 = field[4].u.val;
    entry->encap.mirror_on_drop.dst_ipv4 = field[5].u.val;
    entry->encap.mirror_on_drop.tos = field[6].u.val;
    entry->encap.mirror_on_drop.ttl = field[7].u.val;
    entry->encap.mirror_on_drop.proto = field[8].u.val;
    entry->encap.mirror_on_drop.df = field[9].u.val;
    entry->encap.mirror_on_drop.l4_dst_port = field[10].u.val;
    entry->encap.mirror_on_drop.l4_src_port = field[11].u.val;
    entry->encap.mirror_on_drop.ethertype = field[12].u.val;
    entry->encap.mirror_on_drop.outer_vlan = field[13].u.val;
    entry->encap.mirror_on_drop.vlan_id = field[14].u.val;
    entry->encap.mirror_on_drop.tpid = field[15].u.val;
    entry->encap.mirror_on_drop.observation_domain = field[16].u.val;
    entry->encap.mirror_on_drop.template_id = field[17].u.val;

    if (sal_strcmp(field[18].u.sym_val, ZEROESs) == 0) {
        entry->encap.mirror_on_drop.metadata_type =
            bcmMirrorPsampFmt2HeaderZeroes;
    } else if (sal_strcmp(field[18].u.sym_val, ING_TO_EGR_CLASS_IDs) == 0) {
        entry->encap.mirror_on_drop.metadata_type =
            bcmMirrorPsampFmt2HeaderI2eClassId;
        entry->encap.mirror_on_drop.metadata = field[19].u.val;
    } else if (sal_strcmp(field[18].u.sym_val, NHOP_CLASS_IDs) == 0) {
        entry->encap.mirror_on_drop.metadata_type =
            bcmMirrorPsampFmt2HeaderNextHopClassId;
        entry->encap.mirror_on_drop.metadata = field[19].u.val;
    } else if (sal_strcmp(field[18].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.mirror_on_drop.metadata_type =
            bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.mirror_on_drop.metadata = field[19].u.val;
    }

    entry->encap.mirror_on_drop.switch_id = field[20].u.val;
    entry->encap.mirror_on_drop.initial_seq_num = field[21].u.val;
    entry->encap.mirror_on_drop.pri = field[22].u.val;
    entry->encap.mirror_on_drop.cfi = field[23].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to Mirror-on-drop IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_ipv6_table_add(int unit, int index,
                                           mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_SET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*21*/ {METADATAs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {SWITCH_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*23*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*24*/ {PRIs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*25*/ {CFIs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    field[1].u.val = entry->encap.mirror_on_drop_ipv6.untag;
    bcmi_ltsw_util_mac_to_uint64(&data,
                                 entry->encap.mirror_on_drop_ipv6.src_mac);
    field[2].u.val = data;
    bcmi_ltsw_util_mac_to_uint64(&data,
                                 entry->encap.mirror_on_drop_ipv6.dst_mac);
    field[3].u.val = data;
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.mirror_on_drop_ipv6.src_ipv6);
    field[4].u.val = ipv6_addr[1];
    field[5].u.val = ipv6_addr[0];
    bcmi_ltsw_util_ip6_to_uint64(ipv6_addr,
                                 &entry->encap.mirror_on_drop_ipv6.dst_ipv6);
    field[6].u.val = ipv6_addr[1];
    field[7].u.val = ipv6_addr[0];
    field[8].u.val = entry->encap.mirror_on_drop_ipv6.traffic_class;
    field[9].u.val = entry->encap.mirror_on_drop_ipv6.hop_limit;
    field[10].u.val = entry->encap.mirror_on_drop_ipv6.next_header;
    field[11].u.val = entry->encap.mirror_on_drop_ipv6.flow_label;
    field[12].u.val = entry->encap.mirror_on_drop_ipv6.l4_dst_port;
    field[13].u.val = entry->encap.mirror_on_drop_ipv6.l4_src_port;
    field[14].u.val = entry->encap.mirror_on_drop_ipv6.ethertype;
    field[15].u.val = entry->encap.mirror_on_drop_ipv6.outer_vlan;
    field[16].u.val = entry->encap.mirror_on_drop_ipv6.vlan_id;
    field[17].u.val = entry->encap.mirror_on_drop_ipv6.tpid;
    field[18].u.val = entry->encap.mirror_on_drop_ipv6.observation_domain;
    field[19].u.val = entry->encap.mirror_on_drop_ipv6.template_id;

    switch (entry->encap.mirror_on_drop_ipv6.metadata_type) {
        case bcmMirrorPsampFmt2HeaderZeroes:
            field[20].u.sym_val = ZEROESs;
            break;
        case bcmMirrorPsampFmt2HeaderI2eClassId:
            field[20].u.sym_val = ING_TO_EGR_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderNextHopClassId:
            field[20].u.sym_val = NHOP_CLASS_IDs;
            break;
        case bcmMirrorPsampFmt2HeaderUserMeta:
            field[20].u.sym_val = TABLE_METADATAs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (sal_strcmp(field[20].u.sym_val, ZEROESs) != 0) {
        field[21].flags = BCMI_LT_FIELD_F_SET;
        field[21].u.val = entry->encap.mirror_on_drop_ipv6.metadata;
    }

    field[22].u.val = entry->encap.mirror_on_drop_ipv6.switch_id;
    field[23].u.val = entry->encap.mirror_on_drop_ipv6.initial_seq_num;
    field[24].u.val = entry->encap.mirror_on_drop_ipv6.pri;
    field[25].u.val = entry->encap.mirror_on_drop_ipv6.cfi;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_insert(unit,
                              MIRROR_ENCAP_MIRROR_ON_DROP_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from Mirror-on-drop IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_ipv6_table_delete(int unit, int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit,
                              MIRROR_ENCAP_MIRROR_ON_DROP_IPV6s,
                              &lt_entry,
                              NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap entry from Mirror-on-drop IPv6 LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_ipv6_table_get(int unit, int index,
                                           mirror_encap_profile_entry_t *entry)
{
    uint64_t data = 0, ipv6_addr[2];
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UNTAGs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SRC_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {DST_MACs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SRC_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SRC_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*6*/ {DST_IPV6_UPPERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*7*/ {DST_IPV6_LOWERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*8*/ {TRAFFIC_CLASSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*9*/ {HOP_LIMITs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {NEXT_HEADERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {FLOW_LABELs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {L4_DST_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {L4_SRC_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {ETHERTYPEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {OUTER_VLANs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {VLAN_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {TPIDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {OBSERVATION_DOMAINs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {TEMPLATE_IDENTIFIERs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {METADATA_TYPEs, BCMI_LT_FIELD_F_GET |
                                BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
        /*21*/ {METADATAs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {SWITCH_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*23*/ {INITIAL_SEQ_NUMs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*24*/ {PRIs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*25*/ {CFIs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ENCAP_MIRROR_ON_DROP_IPV6s,
                           &lt_entry,
                           NULL, NULL));

    field[1].u.val = entry->encap.mirror_on_drop_ipv6.untag;
    data = field[2].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.mirror_on_drop_ipv6.src_mac,
                                 &data);
    data = field[3].u.val;
    bcmi_ltsw_util_uint64_to_mac(entry->encap.mirror_on_drop_ipv6.dst_mac,
                                 &data);
    ipv6_addr[1] = field[4].u.val;
    ipv6_addr[0] = field[5].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.mirror_on_drop_ipv6.src_ipv6,
                                 ipv6_addr);
    ipv6_addr[1] = field[6].u.val;
    ipv6_addr[0] = field[7].u.val;
    bcmi_ltsw_util_uint64_to_ip6(&entry->encap.mirror_on_drop_ipv6.dst_ipv6,
                                 ipv6_addr);
    entry->encap.mirror_on_drop_ipv6.traffic_class = field[8].u.val;
    entry->encap.mirror_on_drop_ipv6.hop_limit = field[9].u.val;
    entry->encap.mirror_on_drop_ipv6.next_header = field[10].u.val;
    entry->encap.mirror_on_drop_ipv6.flow_label = field[11].u.val;
    entry->encap.mirror_on_drop_ipv6.l4_dst_port = field[12].u.val;
    entry->encap.mirror_on_drop_ipv6.l4_src_port = field[13].u.val;
    entry->encap.mirror_on_drop_ipv6.ethertype = field[14].u.val;
    entry->encap.mirror_on_drop_ipv6.outer_vlan = field[15].u.val;
    entry->encap.mirror_on_drop_ipv6.vlan_id = field[16].u.val;
    entry->encap.mirror_on_drop_ipv6.tpid = field[17].u.val;
    entry->encap.mirror_on_drop_ipv6.observation_domain = field[18].u.val;
    entry->encap.mirror_on_drop_ipv6.template_id = field[19].u.val;

    if (sal_strcmp(field[20].u.sym_val, ZEROESs) == 0) {
        entry->encap.mirror_on_drop_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderZeroes;
    } else if (sal_strcmp(field[20].u.sym_val, ING_TO_EGR_CLASS_IDs) == 0) {
        entry->encap.mirror_on_drop_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderI2eClassId;
        entry->encap.mirror_on_drop_ipv6.metadata = field[21].u.val;
    } else if (sal_strcmp(field[20].u.sym_val, NHOP_CLASS_IDs) == 0) {
        entry->encap.mirror_on_drop_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderNextHopClassId;
        entry->encap.mirror_on_drop_ipv6.metadata = field[21].u.val;
    } else if (sal_strcmp(field[20].u.sym_val, TABLE_METADATAs) == 0) {
        entry->encap.mirror_on_drop_ipv6.metadata_type =
            bcmMirrorPsampFmt2HeaderUserMeta;
        entry->encap.mirror_on_drop_ipv6.metadata = field[21].u.val;
    }

    entry->encap.mirror_on_drop_ipv6.switch_id = field[22].u.val;
    entry->encap.mirror_on_drop_ipv6.initial_seq_num = field[23].u.val;
    entry->encap.mirror_on_drop_ipv6.pri = field[24].u.val;
    entry->encap.mirror_on_drop_ipv6.cfi = field[25].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set Mirror encap type.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] type Mirror encap type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_type_set(int unit, int index, mirror_encap_type type)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_encap_info[unit].type, SHR_E_INIT);

    mirror_encap_info[unit].type[index] = type;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap type.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [out] type Mirror encap type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_type_get(int unit, int index, mirror_encap_type *type)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_encap_info[unit].type, SHR_E_INIT);

    *type = mirror_encap_info[unit].type[index];

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap entry to LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of encap profile.
 * \param [in] entry Mirror encap profile entry data pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_table_add(int unit, int index,
                       mirror_encap_profile_entry_t *entry)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    if (entry->type == ENCAP_RSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_ERSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_ERSPAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_ipv6_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_PSAMP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_ipv6_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_PSAMP_METADATA) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_metadata_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_PSAMP_METADATA_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_metadata_ipv6_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_SFLOW_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_ipv6_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_SFLOW_SEQ) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_seq_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_SFLOW_SEQ_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_seq_ipv6_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_MIRROR_ON_DROP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_table_add(unit, index, entry));
    } else if (entry->type == ENCAP_MIRROR_ON_DROP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_ipv6_table_add(unit, index, entry));
    }
    /* Save encap type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_type_set(unit, index, entry->type));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap entry from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] type Mirror encap type.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_table_delete(int unit, mirror_encap_type type, int index)
{
    SHR_FUNC_ENTER(unit);

    if (type == ENCAP_RSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_table_delete(unit, index));
    } else if (type == ENCAP_ERSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_table_delete(unit, index));
    } else if (type == ENCAP_ERSPAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_ipv6_table_delete(unit, index));
    } else if (type == ENCAP_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_table_delete(unit, index));
    } else if (type == ENCAP_PSAMP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_ipv6_table_delete(unit, index));
    } else if (type == ENCAP_PSAMP_METADATA) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_metadata_table_delete(unit, index));
    } else if (type == ENCAP_PSAMP_METADATA_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_metadata_ipv6_table_delete(unit, index));
    } else if (type == ENCAP_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_table_delete(unit, index));
    } else if (type == ENCAP_SFLOW_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_ipv6_table_delete(unit, index));
    } else if (type == ENCAP_SFLOW_SEQ) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_seq_table_delete(unit, index));
    } else if (type == ENCAP_SFLOW_SEQ_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_seq_ipv6_table_delete(unit, index));
    } else if (type == ENCAP_MIRROR_ON_DROP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_table_delete(unit, index));
    } else if (type == ENCAP_MIRROR_ON_DROP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_ipv6_table_delete(unit, index));
    }
    /* Save encap type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_type_set(unit, index, ENCAP_NONE));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear all entries in Mirror encap profile.
 *
 * \param [in]  unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_encap_profile_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_RSPANs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_ERSPANs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_ERSPAN_IPV6s));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_PSAMPs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_PSAMP_IPV6s));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_PSAMP_METADATAs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_PSAMP_METADATA_IPV6s));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_SFLOWs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_SFLOW_IPV6s));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_SFLOW_SEQs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_SFLOW_SEQ_IPV6s));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_MIRROR_ON_DROPs));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_ENCAP_MIRROR_ON_DROP_IPV6s));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap profile entry.
 *
 * \param [in]  unit Unit Number.
 * \param [in]  type Mirror encap type.
 * \param [in]  index Entry index of profile table.
 * \param [out] entry Mirror encap profile entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_encap_profile_entry_get(int unit, mirror_encap_type type,
                               int index, mirror_encap_profile_entry_t *entry)
{
    SHR_FUNC_ENTER(unit);

    entry->type = type;

    if (type == ENCAP_RSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_table_get(unit, index, entry));
    } else if (type == ENCAP_ERSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_table_get(unit, index, entry));
    } else if (type == ENCAP_ERSPAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_ipv6_table_get(unit, index, entry));
    } else if (type == ENCAP_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_table_get(unit, index, entry));
    } else if (type == ENCAP_PSAMP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_ipv6_table_get(unit, index, entry));
    } else if (type == ENCAP_PSAMP_METADATA) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_metadata_table_get(unit, index, entry));
    } else if (type == ENCAP_PSAMP_METADATA_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_metadata_ipv6_table_get(unit, index, entry));
    } else if (type == ENCAP_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_table_get(unit, index, entry));
    } else if (type == ENCAP_SFLOW_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_ipv6_table_get(unit, index, entry));
    } else if (type == ENCAP_SFLOW_SEQ) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_seq_table_get(unit, index, entry));
    } else if (type == ENCAP_SFLOW_SEQ_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_seq_ipv6_table_get(unit, index, entry));
    } else if (type == ENCAP_MIRROR_ON_DROP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_table_get(unit, index, entry));
    } else if (type == ENCAP_MIRROR_ON_DROP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_ipv6_table_get(unit, index, entry));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a Mirror encap profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] entry Mirror encap profile entry data pointer.
 * \param [out] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_profile_entry_add(int unit, mirror_encap_profile_entry_t *entry,
                               int *index)
{
    bcmi_ltsw_profile_hdl_t profile_hdl;
    int rv;
    bool allocated = false;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    profile_hdl = BCMI_LTSW_PROFILE_MIRROR_ENCAP;

    rv = bcmi_ltsw_profile_index_allocate(unit, profile_hdl,
                                          entry, 0, 1, index);
    if (rv == SHR_E_EXISTS) {
        /* The same profile already exists. */
        SHR_EXIT();
    }

    if (SHR_FAILURE(rv)) {
       SHR_ERR_EXIT(rv);
    }
    allocated = true;

    /* Add entry to table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_table_add(unit, *index, entry));

exit:
    if (SHR_FUNC_ERR()) {
        if (allocated) {
            (void)bcmi_ltsw_profile_index_free(unit,
                                               BCMI_LTSW_PROFILE_MIRROR_ENCAP,
                                               *index);
        }
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] type Mirror encap type.
 * \param [in] index Index of encap profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_profile_entry_delete(int unit, mirror_encap_type type, int index)
{
    int rv;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_free(unit,
                                      BCMI_LTSW_PROFILE_MIRROR_ENCAP,
                                      index);

    if (rv == SHR_E_BUSY) {
        /* The profile entry is still in used. */
       SHR_EXIT();
    }

    if (rv != SHR_E_NONE) {
        SHR_ERR_EXIT(rv);
    }

    /* Delete table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_table_delete(unit, type, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear all entries in mirror egress zero payload profile.
 *
 * \param [in]  unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_payload_zero_profile_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, MIRROR_EGR_ZERO_PAYLOAD_PROFILEs));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get entry in mirror egress zero payload profile.
 *
 * \param [in]  unit Unit number.
 * \param [in]  profile_idx Index to the zero payload profile.
 *
 * \param [out] profile Zero payload profile offset.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_payload_zero_profile_entry_get(int unit, int profile_idx,
                        bcm_mirror_payload_zero_offsets_t *profile)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /* 0*/ {MIRROR_EGR_ZERO_PAYLOAD_PROFILE_IDs,   BCMI_LT_FIELD_F_SET, 0, {0}},
        /* 1*/ {L2_OFFSETs,                            BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 2*/ {SKIP_L2_OFFSETs,                       BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 3*/ {L3_NON_UDP_OFFSETs,                    BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 4*/ {SKIP_L3_NON_UDP_OFFSETs,               BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 5*/ {L3_UDP_OFFSETs,                        BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 6*/ {SKIP_L3_UDP_OFFSETs,                   BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field) / sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = profile_idx;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_EGR_ZERO_PAYLOAD_PROFILE_IDs,
                           &lt_entry,
                           NULL,
                           NULL));

    profile->l2_offset = field[1].u.val;
    profile->l2_offset_disable = field[2].u.val;
    profile->l3_offset = field[3].u.val;
    profile->l3_offset_disable = field[4].u.val;
    profile->udp_offset = field[5].u.val;
    profile->udp_offset_disable = field[6].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create entry in MIRROR_EGR_ZERO_PAYLOAD_PROFILE table.
 *
 * \param [in] unit Unit Number.
 * \param [in/out] pyld_zero_offset Mirror egress zero payload offsets.
 * \param [in] flags Define module using the API.
 *
 * \param [OUT] profile_index Profile index created.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */

static int
mirror_payload_zero_profile_create(int unit,
        bcm_mirror_payload_zero_offsets_t *pyld_zero_offset,
        uint32 flags,
        uint32 *profile_index)
{
    bool allocated = false;
    int rv;
    int index = 0;
    bcmi_lt_entry_t lt_entry;
    bcmi_ltsw_profile_hdl_t profile_hdl;
    bcmi_lt_field_t field[] =
    {
        /* 0*/ {MIRROR_EGR_ZERO_PAYLOAD_PROFILE_IDs,   0, 0, {0}},
        /* 1*/ {L2_OFFSETs,                            0, 0, {0}},
        /* 2*/ {SKIP_L2_OFFSETs,                       0, 0, {0}},
        /* 3*/ {L3_NON_UDP_OFFSETs,                    0, 0, {0}},
        /* 4*/ {SKIP_L3_NON_UDP_OFFSETs,               0, 0, {0}},
        /* 5*/ {L3_UDP_OFFSETs,                        0, 0, {0}},
        /* 6*/ {SKIP_L3_UDP_OFFSETs,                   0, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(pyld_zero_offset, SHR_E_PARAM);

    profile_hdl = BCMI_LTSW_PROFILE_MIRROR_ZERO_PAYLOAD;

    rv = bcmi_ltsw_profile_index_allocate(unit, profile_hdl,
                                          pyld_zero_offset,
                                          0, 1,
                                          &index);
    if (rv == SHR_E_EXISTS) {
        /* The same profile already exists. */
        SHR_EXIT();
    }

    if (SHR_FAILURE(rv)) {
       SHR_ERR_EXIT(rv);
    }

    *profile_index = index;

    field[0].flags |= BCMI_LT_FIELD_F_SET;
    field[0].u.val = index;

    field[1].flags |= BCMI_LT_FIELD_F_SET;
    field[1].u.val = pyld_zero_offset->l2_offset;
    if (pyld_zero_offset->l2_offset_disable)  {
        field[2].flags |= BCMI_LT_FIELD_F_SET;
        field[2].u.val = pyld_zero_offset->l2_offset_disable;
    }
    field[3].flags |= BCMI_LT_FIELD_F_SET;
    field[3].u.val = pyld_zero_offset->l3_offset;

    field[4].flags |= BCMI_LT_FIELD_F_SET;
    field[4].u.val = pyld_zero_offset->l3_offset_disable;

    field[5].flags |= BCMI_LT_FIELD_F_SET;
    field[5].u.val = pyld_zero_offset->udp_offset;

    field[6].flags |= BCMI_LT_FIELD_F_SET;
    field[6].u.val = pyld_zero_offset->udp_offset_disable;

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    allocated = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_EGR_ZERO_PAYLOAD_PROFILEs, &lt_entry, NULL));

exit:
    if (SHR_FUNC_ERR()) {
        if (allocated) {
            (void)bcmi_ltsw_profile_index_free(unit,
                                               profile_hdl,
                                               index);
        }
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete entry in MIRROR_EGR_ZERO_PAYLOAD_PROFILE table.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags Define module using the API.
 * \param [in] profile_index Profile index created.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */

static int
mirror_payload_zero_profile_destroy(int unit,
        uint32 flags,
        uint32 profile_index)

{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /* 0*/ {MIRROR_EGR_ZERO_PAYLOAD_PROFILE_IDs,   0, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_free(unit,
                                      BCMI_LTSW_PROFILE_MIRROR_ZERO_PAYLOAD,
                                      (int)profile_index);

    if (rv == SHR_E_BUSY) {
        /* The profile entry is still in used. */
       SHR_EXIT();
    }

    if (rv != SHR_E_NONE) {
        SHR_ERR_EXIT(rv);
    }

    field[0].flags |= BCMI_LT_FIELD_F_SET;
    field[0].u.val = profile_index;

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_EGR_ZERO_PAYLOAD_PROFILEs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash signature for Mirror encap LT.
 *
 * \param [in]  unit Unit Number.
 * \param [in]  entries Mirror egress payload profile entry.
 * \param [in]  entries_per_set Number of entries in the profile set.
 * \param [out] hash Hash signature.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_payload_zero_profile_hash_cb(int unit, void *entries,
                             int entries_per_set, uint32_t *hash)
{
    int size = entries_per_set * sizeof(bcm_mirror_payload_zero_offsets_t);
    *hash = shr_crc32(0, entries, size);
    return SHR_E_NONE;

}


/*!
 * \brief Compare profile set of Mirror egress zero payload LT.
 *
 * \param [in]  unit Unit Number.
 * \param [in]  entries Mirror egress payload profile entry.
 * \param [in]  entries_per_set Number of entries in the profile set.
 * \param [in]  index Entry index of profile table.
 * \param [out] cmp Result of comparison.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_payload_zero_profile_cmp_cb(int unit, void *entries,
                             int entries_per_set, int index, int *cmp)
{
    bcm_mirror_payload_zero_offsets_t profile;

    SHR_FUNC_ENTER(unit);

    if (entries_per_set != 1) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    sal_memset(&profile, 0, sizeof(bcm_mirror_payload_zero_offsets_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_payload_zero_profile_entry_get(unit, index, &profile));

    *cmp = sal_memcmp(entries, (void *)&profile,
                      sizeof(bcm_mirror_payload_zero_offsets_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover Mirror egress payload profile information at the given index.
 *
 * \param [in] unit Unit number.
 * \param [in]  profile_idx Entry index of profile table.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_payload_zero_profile_entry_recover(int unit, int profile_idx)
{
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_MIRROR_ZERO_PAYLOAD;
    bcm_mirror_payload_zero_offsets_t profile;
    int entries_per_set = 1;
    uint32_t ref_count = 0;
    int index;

    SHR_FUNC_ENTER(unit);

    sal_memset(&profile, 0, sizeof(bcm_mirror_payload_zero_offsets_t));

    index = profile_idx * entries_per_set;

    /* Update profile hash on the first usage.  */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_get(unit,
                                         profile_hdl,
                                         index,
                                         &ref_count));

    if (ref_count == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_payload_zero_profile_entry_get(unit,
                                                   profile_idx,
                                                   &profile));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_hash_update(unit,
                                           profile_hdl,
                                           &profile,
                                           entries_per_set,
                                           index));

    }

    /* Increment reference count. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_increase(unit, profile_hdl,
                                              entries_per_set, index, 1));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover Miror egress zero payload profile.
 *
 * \param [in]  unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_payload_zero_profile_recover(int unit)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv, dunit, profile_idx;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
                              MIRROR_EGR_ZERO_PAYLOAD_PROFILEs,
                              &entry_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                                   MIRROR_EGR_ZERO_PAYLOAD_PROFILE_IDs,
                                   &data));

        profile_idx = data;

        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_payload_zero_profile_entry_recover(unit, profile_idx));
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash signature for Mirror encap LT.
 *
 * \param [in]  unit Unit Number.
 * \param [in]  entries Mirror encap profile entry.
 * \param [in]  entries_per_set Number of entries in the profile set.
 * \param [out] hash Hash signature.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_encap_profile_hash_cb(int unit, void *entries,
                             int entries_per_set, uint32_t *hash)
{
    mirror_encap_profile_entry_t *encap_profile = NULL;
    mirror_encap_type type;
    void *entry;
    int size = 0;
    SHR_FUNC_ENTER(unit);

    encap_profile = (mirror_encap_profile_entry_t *)entries;
    SHR_NULL_CHECK(encap_profile, SHR_E_PARAM);
    type = encap_profile->type;
    entry = encap_profile;
    entry += sizeof(mirror_encap_type);

    switch (type) {
        case ENCAP_RSPAN:
            size = sizeof(mirror_encap_rspan_t);
            break;
        case ENCAP_ERSPAN:
            size = sizeof(mirror_encap_erspan_t);
            break;
        case ENCAP_ERSPAN_IPv6:
            size = sizeof(mirror_encap_erspan_ipv6_t);
            break;
        case ENCAP_PSAMP:
            size = sizeof(mirror_encap_psamp_t);
            break;
        case ENCAP_PSAMP_IPv6:
            size = sizeof(mirror_encap_psamp_ipv6_t);
            break;
        case ENCAP_PSAMP_METADATA:
            size = sizeof(mirror_encap_psamp_metadata_t);
            break;
        case ENCAP_PSAMP_METADATA_IPv6:
            size = sizeof(mirror_encap_psamp_metadata_ipv6_t);
            break;
        case ENCAP_SFLOW:
            size = sizeof(mirror_encap_sflow_t);
            break;
        case ENCAP_SFLOW_IPv6:
            size = sizeof(mirror_encap_sflow_ipv6_t);
            break;
        case ENCAP_SFLOW_SEQ:
            size = sizeof(mirror_encap_sflow_seq_t);
            break;
        case ENCAP_SFLOW_SEQ_IPv6:
            size = sizeof(mirror_encap_sflow_seq_ipv6_t);
            break;
        case ENCAP_MIRROR_ON_DROP:
            size = sizeof(mirror_encap_mirror_on_drop_t);
            break;
        case ENCAP_MIRROR_ON_DROP_IPv6:
            size = sizeof(mirror_encap_mirror_on_drop_ipv6_t);
            break;
        default:
            break;
    }

    *hash = shr_crc32(0, entry, entries_per_set * size);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare profile set of Mirror encap LT.
 *
 * \param [in]  unit Unit Number.
 * \param [in]  entries Mirror encap profile.
 * \param [in]  entries_per_set Number of entries in the profile set.
 * \param [in]  index Entry index of profile table.
 * \param [out] cmp Result of comparison.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_encap_profile_cmp_cb(int unit, void *entries,
                            int entries_per_set, int index, int *cmp)
{
    mirror_encap_profile_entry_t *encap_profile = NULL, entry_tmp;
    mirror_encap_type type;
    int rv = SHR_E_NONE;
    SHR_FUNC_ENTER(unit);

    encap_profile = (mirror_encap_profile_entry_t *)entries;
    SHR_NULL_CHECK(encap_profile, SHR_E_PARAM);
    type = encap_profile->type;

    sal_memset(&entry_tmp, 0, sizeof(mirror_encap_profile_entry_t));
    entry_tmp.egr = encap_profile->egr;
    entry_tmp.sys_port = encap_profile->sys_port;

    /* Get profile entry for the given index. */
    rv = mirror_encap_profile_entry_get(unit, type, index, &entry_tmp);
    if (rv == SHR_E_NOT_FOUND) {
        *cmp = 1;
    } else if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }

    *cmp = sal_memcmp(encap_profile, &entry_tmp,
                      sizeof(mirror_encap_profile_entry_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover encap profile.
 *
 * \param [in]  unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_encap_profile_recover(int unit)
{
    int i, dunit, rv, id, encap_id, session_ref_cnt = 0;
    uint32_t prf_ref_cnt = 0;
    uint64_t data;
    bcmlt_entry_handle_t entry_hdls[2] = {BCMLT_INVALID_HDL, BCMLT_INVALID_HDL};
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_MIRROR_ENCAP;
    mirror_encap_profile_entry_t entry;
    mirror_encap_type type = ENCAP_NONE;
    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MIRROR_ING_MEMBERs, &entry_hdls[0]));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MIRROR_EGR_MEMBERs, &entry_hdls[1]));
    for (i = 0; i < 2; i++) {
        while ((rv = bcmi_lt_entry_commit(unit, entry_hdls[i],
                                          BCMLT_OPCODE_TRAVERSE,
                                          BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdls[i], MIRROR_INSTANCE_IDs, &data));
            id = (int)data;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdls[i], MIRROR_ENCAP_IDs, &data));
            encap_id = (int)data;

            /* Get session ref_cnt. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_mirror_session_ref_cnt_get(unit, id, &session_ref_cnt));

            /* Get encap profile ref_cnt. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_profile_ref_count_get(unit,
                                                 profile_hdl,
                                                 encap_id,
                                                 &prf_ref_cnt));
            if (prf_ref_cnt == 0) {
                /* Get encap type. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (mirror_encap_type_get(unit, encap_id, &type));

                /* Get encap profile entry. */
                sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
                SHR_IF_ERR_VERBOSE_EXIT
                    (mirror_encap_profile_entry_get(unit, type, encap_id, &entry));

                /* Update hash value for this profile entry. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_profile_hash_update(unit,
                                                   profile_hdl,
                                                   &entry,
                                                   1,
                                                   encap_id));
            }

            /* Increase encap profile reference count. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_profile_ref_count_increase(unit,
                                                      profile_hdl,
                                                      1,
                                                      encap_id,
                                                      session_ref_cnt));
        }
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }
exit:
    for (i = 0; i < 2; i++) {
        if (entry_hdls[i] != BCMLT_INVALID_HDL) {
            bcmlt_entry_free(entry_hdls[i]);
        }
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add RSPAN Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_add(int unit, bool egr,
                       bcm_mirror_destination_t *mirror_dest, int *index)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    entry.type = ENCAP_RSPAN;
    entry.egr = egr;

    if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
        entry.encap.rspan.untag = true;
    }
    entry.encap.rspan.pri = mirror_dest->pkt_prio;
    entry.encap.rspan.cfi = mirror_dest->cfi;
    entry.encap.rspan.vlan_id = mirror_dest->vlan_id;
    entry.encap.rspan.tpid = mirror_dest->tpid;

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete RSPAN Mirror encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_delete(int unit, bcm_mirror_destination_t *mirror_dest,
                          int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, ENCAP_RSPAN, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get RSPAN Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_rspan_get(int unit, int index,
                       bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    entry.type = ENCAP_RSPAN;

    SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_table_get(unit, index, &entry));
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_L2;
    if (entry.encap.rspan.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    mirror_dest->pkt_prio = entry.encap.rspan.pri;
    mirror_dest->cfi = entry.encap.rspan.cfi;
    mirror_dest->vlan_id = entry.encap.rspan.vlan_id;
    mirror_dest->tpid = entry.encap.rspan.tpid;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add ERSPAN Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_add(int unit, bool egr,
                        bcm_mirror_destination_t *mirror_dest, int *index)
{
    mirror_encap_type type;
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_ERSPAN_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_ERSPAN;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    entry.type = type;
    entry.egr = egr;

    if (type == ENCAP_ERSPAN) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.erspan.untag = true;
        }
        sal_memcpy(entry.encap.erspan.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.erspan.dst_mac, mirror_dest->dst_mac, 6);
        entry.encap.erspan.src_ipv4 = mirror_dest->src_addr;
        entry.encap.erspan.dst_ipv4 = mirror_dest->dst_addr;
        entry.encap.erspan.tos = mirror_dest->tos;
        entry.encap.erspan.ttl = mirror_dest->ttl;
        entry.encap.erspan.proto = MIRROR_ENCAP_IP_PROTO_TYPE_GRE;
        entry.encap.erspan.df = mirror_dest->df;
        entry.encap.erspan.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV4;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.erspan.outer_vlan = true;
        }
        entry.encap.erspan.pri = mirror_dest->pkt_prio;
        entry.encap.erspan.cfi = mirror_dest->cfi;
        entry.encap.erspan.vlan_id = mirror_dest->vlan_id;
        entry.encap.erspan.tpid = mirror_dest->tpid;
        entry.encap.erspan.gre_header = mirror_dest->gre_protocol ?
                                        mirror_dest->gre_protocol :
                                        MIRROR_ENCAP_GRE_DEF_PROTO_TYPE;
    } else if (type == ENCAP_ERSPAN_IPv6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.erspan_ipv6.untag = true;
        }
        sal_memcpy(entry.encap.erspan_ipv6.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.erspan_ipv6.dst_mac, mirror_dest->dst_mac, 6);
        sal_memcpy(entry.encap.erspan_ipv6.src_ipv6,
                   mirror_dest->src6_addr, 16);
        sal_memcpy(entry.encap.erspan_ipv6.dst_ipv6,
                   mirror_dest->dst6_addr, 16);
        entry.encap.erspan_ipv6.traffic_class = mirror_dest->tos;
        entry.encap.erspan_ipv6.hop_limit = mirror_dest->ttl;
        entry.encap.erspan_ipv6.next_header = MIRROR_ENCAP_IP_PROTO_TYPE_GRE;
        entry.encap.erspan_ipv6.flow_label = mirror_dest->flow_label;
        entry.encap.erspan_ipv6.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV6;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.erspan_ipv6.outer_vlan = true;
        }
        entry.encap.erspan_ipv6.pri = mirror_dest->pkt_prio;
        entry.encap.erspan_ipv6.cfi = mirror_dest->cfi;
        entry.encap.erspan_ipv6.vlan_id = mirror_dest->vlan_id;
        entry.encap.erspan_ipv6.tpid = mirror_dest->tpid;
        entry.encap.erspan_ipv6.gre_header = mirror_dest->gre_protocol ?
                                             mirror_dest->gre_protocol :
                                             MIRROR_ENCAP_GRE_DEF_PROTO_TYPE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete ERSPAN Mirror encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_delete(int unit, bcm_mirror_destination_t *mirror_dest,
                           int index)
{
    mirror_encap_type type;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_ERSPAN_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_ERSPAN;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, type, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ERSPAN Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_get(int unit, int index,
                        bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_erspan_table_get(unit, index, &entry));

    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_IP_GRE;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV4;

    if (entry.encap.erspan.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.erspan.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.erspan.dst_mac, 6);
    mirror_dest->src_addr = entry.encap.erspan.src_ipv4;
    mirror_dest->dst_addr = entry.encap.erspan.dst_ipv4;
    mirror_dest->tos = entry.encap.erspan.tos;
    mirror_dest->ttl = entry.encap.erspan.ttl;
    mirror_dest->df = entry.encap.erspan.df;
    mirror_dest->pkt_prio = entry.encap.erspan.pri;
    mirror_dest->cfi = entry.encap.erspan.cfi;
    mirror_dest->vlan_id = entry.encap.erspan.vlan_id;
    mirror_dest->tpid = entry.encap.erspan.tpid;
    mirror_dest->gre_protocol = entry.encap.erspan.gre_header;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ERSPAN IPv6 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_erspan_ipv6_get(int unit, int index,
                             bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_erspan_ipv6_table_get(unit, index, &entry));

    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_IP_GRE;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV6;

    if (entry.encap.erspan_ipv6.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }

    sal_memcpy(mirror_dest->src_mac, entry.encap.erspan_ipv6.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.erspan_ipv6.dst_mac, 6);
    sal_memcpy(mirror_dest->src6_addr, entry.encap.erspan_ipv6.src_ipv6, 16);
    sal_memcpy(mirror_dest->dst6_addr, entry.encap.erspan_ipv6.dst_ipv6, 16);
    mirror_dest->tos = entry.encap.erspan_ipv6.traffic_class;
    mirror_dest->ttl = entry.encap.erspan_ipv6.hop_limit;
    mirror_dest->flow_label = entry.encap.erspan_ipv6.flow_label;
    mirror_dest->pkt_prio = entry.encap.erspan_ipv6.pri;
    mirror_dest->cfi = entry.encap.erspan_ipv6.cfi;
    mirror_dest->vlan_id = entry.encap.erspan_ipv6.vlan_id;
    mirror_dest->tpid = entry.encap.erspan_ipv6.tpid;
    mirror_dest->gre_protocol = entry.encap.erspan_ipv6.gre_header;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add sFlow Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_add(int unit, bool egr,
                       bcm_mirror_destination_t *mirror_dest, int *index)
{
    mirror_encap_type type;
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            type = ENCAP_SFLOW_SEQ_IPv6;
        } else {
            type = ENCAP_SFLOW_IPv6;
        }
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            type = ENCAP_SFLOW_SEQ;
        } else {
            type = ENCAP_SFLOW;
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    entry.type = type;
    entry.egr = egr;

    if (type == ENCAP_SFLOW) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.sflow.untag = true;
        }
        sal_memcpy(entry.encap.sflow.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.sflow.dst_mac, mirror_dest->dst_mac, 6);
        entry.encap.sflow.src_ipv4 = mirror_dest->src_addr;
        entry.encap.sflow.dst_ipv4 = mirror_dest->dst_addr;
        entry.encap.sflow.tos = mirror_dest->tos;
        entry.encap.sflow.ttl = mirror_dest->ttl;
        entry.encap.sflow.proto = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.sflow.df = mirror_dest->df;
        entry.encap.sflow.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.sflow.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.sflow.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV4;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.sflow.outer_vlan = true;
        }
        entry.encap.sflow.pri = mirror_dest->pkt_prio;
        entry.encap.sflow.cfi = mirror_dest->cfi;
        entry.encap.sflow.vlan_id = mirror_dest->vlan_id;
        entry.encap.sflow.tpid = mirror_dest->tpid;
    } else if (type == ENCAP_SFLOW_IPv6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.sflow_ipv6.untag = true;
        }
        sal_memcpy(entry.encap.sflow_ipv6.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.sflow_ipv6.dst_mac, mirror_dest->dst_mac, 6);
        sal_memcpy(entry.encap.sflow_ipv6.src_ipv6,
                   mirror_dest->src6_addr, 16);
        sal_memcpy(entry.encap.sflow_ipv6.dst_ipv6,
                   mirror_dest->dst6_addr, 16);
        entry.encap.sflow_ipv6.traffic_class = mirror_dest->tos;
        entry.encap.sflow_ipv6.hop_limit = mirror_dest->ttl;
        entry.encap.sflow_ipv6.next_header = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.sflow_ipv6.flow_label = mirror_dest->flow_label;
        entry.encap.sflow_ipv6.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.sflow_ipv6.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.sflow_ipv6.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV6;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.sflow_ipv6.outer_vlan = true;
        }
        entry.encap.sflow_ipv6.pri = mirror_dest->pkt_prio;
        entry.encap.sflow_ipv6.cfi = mirror_dest->cfi;
        entry.encap.sflow_ipv6.vlan_id = mirror_dest->vlan_id;
        entry.encap.sflow_ipv6.tpid = mirror_dest->tpid;
    } else if (type == ENCAP_SFLOW_SEQ) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.sflow_seq.untag = true;
        }
        sal_memcpy(entry.encap.sflow_seq.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.sflow_seq.dst_mac, mirror_dest->dst_mac, 6);
        entry.encap.sflow_seq.src_ipv4 = mirror_dest->src_addr;
        entry.encap.sflow_seq.dst_ipv4 = mirror_dest->dst_addr;
        entry.encap.sflow_seq.tos = mirror_dest->tos;
        entry.encap.sflow_seq.ttl = mirror_dest->ttl;
        entry.encap.sflow_seq.proto = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.sflow_seq.df = mirror_dest->df;
        entry.encap.sflow_seq.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.sflow_seq.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.sflow_seq.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV4;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.sflow_seq.outer_vlan = true;
        }
        entry.encap.sflow_seq.pri = mirror_dest->pkt_prio;
        entry.encap.sflow_seq.cfi = mirror_dest->cfi;
        entry.encap.sflow_seq.vlan_id = mirror_dest->vlan_id;
        entry.encap.sflow_seq.tpid = mirror_dest->tpid;
        entry.encap.sflow_seq.metadata_type = mirror_dest->meta_data_type;
        entry.encap.sflow_seq.metadata = mirror_dest->meta_data;
        entry.encap.sflow_seq.initial_seq_num = mirror_dest->initial_seq_number;
    } else if (type == ENCAP_SFLOW_SEQ_IPv6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.sflow_seq_ipv6.untag = true;
        }
        sal_memcpy(entry.encap.sflow_seq_ipv6.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.sflow_seq_ipv6.dst_mac, mirror_dest->dst_mac, 6);
        sal_memcpy(entry.encap.sflow_seq_ipv6.src_ipv6,
                   mirror_dest->src6_addr, 16);
        sal_memcpy(entry.encap.sflow_seq_ipv6.dst_ipv6,
                   mirror_dest->dst6_addr, 16);
        entry.encap.sflow_seq_ipv6.traffic_class = mirror_dest->tos;
        entry.encap.sflow_seq_ipv6.hop_limit = mirror_dest->ttl;
        entry.encap.sflow_seq_ipv6.next_header = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.sflow_seq_ipv6.flow_label = mirror_dest->flow_label;
        entry.encap.sflow_seq_ipv6.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.sflow_seq_ipv6.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.sflow_seq_ipv6.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV6;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.sflow_seq_ipv6.outer_vlan = true;
        }
        entry.encap.sflow_seq_ipv6.pri = mirror_dest->pkt_prio;
        entry.encap.sflow_seq_ipv6.cfi = mirror_dest->cfi;
        entry.encap.sflow_seq_ipv6.vlan_id = mirror_dest->vlan_id;
        entry.encap.sflow_seq_ipv6.tpid = mirror_dest->tpid;
        entry.encap.sflow_seq_ipv6.metadata_type = mirror_dest->meta_data_type;
        entry.encap.sflow_seq_ipv6.metadata = mirror_dest->meta_data;
        entry.encap.sflow_seq_ipv6.initial_seq_num =
            mirror_dest->initial_seq_number;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete sFlow Mirror encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_delete(int unit, bcm_mirror_destination_t *mirror_dest,
                          int index)
{
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            type = ENCAP_SFLOW_SEQ_IPv6;
        } else {
            type = ENCAP_SFLOW_IPv6;
        }
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            type = ENCAP_SFLOW_SEQ;
        } else {
            type = ENCAP_SFLOW;
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, type, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sFlow Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_get(int unit, int index,
                       bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_sflow_table_get(unit, index, &entry));

    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_SFLOW;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV4;

    if (entry.encap.sflow.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.sflow.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.sflow.dst_mac, 6);
    mirror_dest->src_addr = entry.encap.sflow.src_ipv4;
    mirror_dest->dst_addr = entry.encap.sflow.dst_ipv4;
    mirror_dest->tos = entry.encap.sflow.tos;
    mirror_dest->ttl = entry.encap.sflow.ttl;
    mirror_dest->df = entry.encap.sflow.df;
    mirror_dest->udp_src_port = entry.encap.sflow.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.sflow.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.sflow.pri;
    mirror_dest->cfi = entry.encap.sflow.cfi;
    mirror_dest->vlan_id = entry.encap.sflow.vlan_id;
    mirror_dest->tpid = entry.encap.sflow.tpid;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sFlow IPv6 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_ipv6_get(int unit, int index,
                            bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_sflow_ipv6_table_get(unit, index, &entry));

    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_SFLOW;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV6;

    if (entry.encap.sflow_ipv6.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.sflow_ipv6.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.sflow_ipv6.dst_mac, 6);
    sal_memcpy(mirror_dest->src6_addr, entry.encap.sflow_ipv6.src_ipv6, 16);
    sal_memcpy(mirror_dest->dst6_addr, entry.encap.sflow_ipv6.dst_ipv6, 16);
    mirror_dest->tos = entry.encap.sflow_ipv6.traffic_class;
    mirror_dest->ttl = entry.encap.sflow_ipv6.hop_limit;
    mirror_dest->flow_label = entry.encap.sflow_ipv6.flow_label;
    mirror_dest->udp_src_port = entry.encap.sflow_ipv6.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.sflow_ipv6.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.sflow_ipv6.pri;
    mirror_dest->cfi = entry.encap.sflow_ipv6.cfi;
    mirror_dest->vlan_id = entry.encap.sflow_ipv6.vlan_id;
    mirror_dest->tpid = entry.encap.sflow_ipv6.tpid;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sFlow_SEQ Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_seq_get(int unit, int index,
                           bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_sflow_seq_table_get(unit, index, &entry));

    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_SFLOW;
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV4;

    if (entry.encap.sflow_seq.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.sflow_seq.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.sflow_seq.dst_mac, 6);
    mirror_dest->src_addr = entry.encap.sflow_seq.src_ipv4;
    mirror_dest->dst_addr = entry.encap.sflow_seq.dst_ipv4;
    mirror_dest->tos = entry.encap.sflow_seq.tos;
    mirror_dest->ttl = entry.encap.sflow_seq.ttl;
    mirror_dest->df = entry.encap.sflow_seq.df;
    mirror_dest->udp_src_port = entry.encap.sflow_seq.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.sflow_seq.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.sflow_seq.pri;
    mirror_dest->cfi = entry.encap.sflow_seq.cfi;
    mirror_dest->vlan_id = entry.encap.sflow_seq.vlan_id;
    mirror_dest->tpid = entry.encap.sflow_seq.tpid;
    mirror_dest->meta_data_type = entry.encap.sflow_seq.metadata_type;
    mirror_dest->meta_data = entry.encap.sflow_seq.metadata;
    mirror_dest->initial_seq_number = entry.encap.sflow_seq.initial_seq_num;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sFlow_SEQ IPv6 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_sflow_seq_ipv6_get(int unit, int index,
                                bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_sflow_seq_ipv6_table_get(unit, index, &entry));

    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_SFLOW;
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV6;

    if (entry.encap.sflow_seq_ipv6.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.sflow_seq_ipv6.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.sflow_seq_ipv6.dst_mac, 6);
    sal_memcpy(mirror_dest->src6_addr, entry.encap.sflow_seq_ipv6.src_ipv6, 16);
    sal_memcpy(mirror_dest->dst6_addr, entry.encap.sflow_seq_ipv6.dst_ipv6, 16);
    mirror_dest->tos = entry.encap.sflow_seq_ipv6.traffic_class;
    mirror_dest->ttl = entry.encap.sflow_seq_ipv6.hop_limit;
    mirror_dest->flow_label = entry.encap.sflow_seq_ipv6.flow_label;
    mirror_dest->udp_src_port = entry.encap.sflow_seq_ipv6.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.sflow_seq_ipv6.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.sflow_seq_ipv6.pri;
    mirror_dest->cfi = entry.encap.sflow_seq_ipv6.cfi;
    mirror_dest->vlan_id = entry.encap.sflow_seq_ipv6.vlan_id;
    mirror_dest->tpid = entry.encap.sflow_seq_ipv6.tpid;
    mirror_dest->meta_data_type = entry.encap.sflow_seq_ipv6.metadata_type;
    mirror_dest->meta_data = entry.encap.sflow_seq_ipv6.metadata;
    mirror_dest->initial_seq_number = entry.encap.sflow_seq_ipv6.initial_seq_num;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add PSAMP Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_add(int unit, bool egr,
                       bcm_mirror_destination_t *mirror_dest, int *index)
{
    mirror_encap_type type;
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        if (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_PSAMP_FORMAT_2) {
            type = ENCAP_PSAMP_METADATA_IPv6;
        } else {
            type = ENCAP_PSAMP_IPv6;
        }
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        if (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_PSAMP_FORMAT_2) {
            type = ENCAP_PSAMP_METADATA;
        } else {
            type = ENCAP_PSAMP;
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    entry.type = type;
    entry.egr = egr;

    if (type == ENCAP_PSAMP) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.psamp.untag = true;
        }
        sal_memcpy(entry.encap.psamp.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.psamp.dst_mac, mirror_dest->dst_mac, 6);
        entry.encap.psamp.src_ipv4 = mirror_dest->src_addr;
        entry.encap.psamp.dst_ipv4 = mirror_dest->dst_addr;
        entry.encap.psamp.tos = mirror_dest->tos;
        entry.encap.psamp.ttl = mirror_dest->ttl;
        entry.encap.psamp.proto = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.psamp.df = mirror_dest->df;
        entry.encap.psamp.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.psamp.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.psamp.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV4;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.psamp.outer_vlan = true;
        }
        entry.encap.psamp.pri = mirror_dest->pkt_prio;
        entry.encap.psamp.cfi = mirror_dest->cfi;
        entry.encap.psamp.vlan_id = mirror_dest->vlan_id;
        entry.encap.psamp.tpid = mirror_dest->tpid;

        entry.encap.psamp.observation_domain = mirror_dest->observation_domain ?
            mirror_dest->observation_domain :
            BCM_MIRROR_IPFIX_OBSERVATION_DOMAIN_DFLT;
        entry.encap.psamp.template_id = mirror_dest->template_id ?
            mirror_dest->template_id : BCM_MIRROR_IPFIX_TEMPLATE_ID_DFLT;
        entry.encap.psamp.initial_seq_num = mirror_dest->initial_seq_number;
    } else if (type == ENCAP_PSAMP_IPv6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.psamp_ipv6.untag = true;
        }
        sal_memcpy(entry.encap.psamp_ipv6.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.psamp_ipv6.dst_mac, mirror_dest->dst_mac, 6);
        sal_memcpy(entry.encap.psamp_ipv6.src_ipv6,
                   mirror_dest->src6_addr, 16);
        sal_memcpy(entry.encap.psamp_ipv6.dst_ipv6,
                   mirror_dest->dst6_addr, 16);
        entry.encap.psamp_ipv6.traffic_class = mirror_dest->tos;
        entry.encap.psamp_ipv6.hop_limit = mirror_dest->ttl;
        entry.encap.psamp_ipv6.next_header = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.psamp_ipv6.flow_label = mirror_dest->flow_label;
        entry.encap.psamp_ipv6.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.psamp_ipv6.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.psamp_ipv6.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV6;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.psamp_ipv6.outer_vlan = true;
        }
        entry.encap.psamp_ipv6.pri = mirror_dest->pkt_prio;
        entry.encap.psamp_ipv6.cfi = mirror_dest->cfi;
        entry.encap.psamp_ipv6.vlan_id = mirror_dest->vlan_id;
        entry.encap.psamp_ipv6.tpid = mirror_dest->tpid;

        entry.encap.psamp_ipv6.observation_domain =
            mirror_dest->observation_domain ?
            mirror_dest->observation_domain :
            BCM_MIRROR_IPFIX_OBSERVATION_DOMAIN_DFLT;
        entry.encap.psamp_ipv6.template_id = mirror_dest->template_id ?
            mirror_dest->template_id : BCM_MIRROR_IPFIX_TEMPLATE_ID_DFLT;
        entry.encap.psamp_ipv6.initial_seq_num = mirror_dest->initial_seq_number;
    } else if (type == ENCAP_PSAMP_METADATA) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.psamp_metadata.untag = true;
        }
        sal_memcpy(entry.encap.psamp_metadata.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.psamp_metadata.dst_mac, mirror_dest->dst_mac, 6);
        entry.encap.psamp_metadata.src_ipv4 = mirror_dest->src_addr;
        entry.encap.psamp_metadata.dst_ipv4 = mirror_dest->dst_addr;
        entry.encap.psamp_metadata.tos = mirror_dest->tos;
        entry.encap.psamp_metadata.ttl = mirror_dest->ttl;
        entry.encap.psamp_metadata.proto = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.psamp_metadata.df = mirror_dest->df;
        entry.encap.psamp_metadata.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.psamp_metadata.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.psamp_metadata.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV4;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.psamp_metadata.outer_vlan = true;
        }
        entry.encap.psamp_metadata.pri = mirror_dest->pkt_prio;
        entry.encap.psamp_metadata.cfi = mirror_dest->cfi;
        entry.encap.psamp_metadata.vlan_id = mirror_dest->vlan_id;
        entry.encap.psamp_metadata.tpid = mirror_dest->tpid;

        entry.encap.psamp_metadata.observation_domain = mirror_dest->observation_domain ?
            mirror_dest->observation_domain :
            BCM_MIRROR_IPFIX_OBSERVATION_DOMAIN_DFLT;
        entry.encap.psamp_metadata.template_id = mirror_dest->template_id ?
            mirror_dest->template_id : BCM_MIRROR_IPFIX_TEMPLATE_ID_DFLT;
        entry.encap.psamp_metadata.metadata_type = mirror_dest->meta_data_type;
        entry.encap.psamp_metadata.metadata = mirror_dest->meta_data;
        entry.encap.psamp_metadata.initial_seq_num = mirror_dest->initial_seq_number;
    } else if (type == ENCAP_PSAMP_METADATA_IPv6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.psamp_metadata_ipv6.untag = true;
        }
        sal_memcpy(entry.encap.psamp_metadata_ipv6.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.psamp_metadata_ipv6.dst_mac, mirror_dest->dst_mac, 6);
        sal_memcpy(entry.encap.psamp_metadata_ipv6.src_ipv6,
                   mirror_dest->src6_addr, 16);
        sal_memcpy(entry.encap.psamp_metadata_ipv6.dst_ipv6,
                   mirror_dest->dst6_addr, 16);
        entry.encap.psamp_metadata_ipv6.traffic_class = mirror_dest->tos;
        entry.encap.psamp_metadata_ipv6.hop_limit = mirror_dest->ttl;
        entry.encap.psamp_metadata_ipv6.next_header = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.psamp_metadata_ipv6.flow_label = mirror_dest->flow_label;
        entry.encap.psamp_metadata_ipv6.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.psamp_metadata_ipv6.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.psamp_metadata_ipv6.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV6;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.psamp_metadata_ipv6.outer_vlan = true;
        }
        entry.encap.psamp_metadata_ipv6.pri = mirror_dest->pkt_prio;
        entry.encap.psamp_metadata_ipv6.cfi = mirror_dest->cfi;
        entry.encap.psamp_metadata_ipv6.vlan_id = mirror_dest->vlan_id;
        entry.encap.psamp_metadata_ipv6.tpid = mirror_dest->tpid;

        entry.encap.psamp_metadata_ipv6.observation_domain =
            mirror_dest->observation_domain ?
            mirror_dest->observation_domain :
            BCM_MIRROR_IPFIX_OBSERVATION_DOMAIN_DFLT;
        entry.encap.psamp_metadata_ipv6.template_id = mirror_dest->template_id ?
            mirror_dest->template_id : BCM_MIRROR_IPFIX_TEMPLATE_ID_DFLT;
        entry.encap.psamp_metadata_ipv6.metadata_type = mirror_dest->meta_data_type;
        entry.encap.psamp_metadata_ipv6.metadata = mirror_dest->meta_data;
        entry.encap.psamp_metadata_ipv6.initial_seq_num = mirror_dest->initial_seq_number;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete PSAMP Mirror encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_delete(int unit, bcm_mirror_destination_t *mirror_dest,
                          int index)
{
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        if (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_PSAMP_FORMAT_2) {
            type = ENCAP_PSAMP_METADATA_IPv6;
        } else {
            type = ENCAP_PSAMP_IPv6;
        }
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        if (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_PSAMP_FORMAT_2) {
            type = ENCAP_PSAMP_METADATA;
        } else {
            type = ENCAP_PSAMP;
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, type, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get PSAMP Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_get(int unit, int index,
                       bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_psamp_table_get(unit, index, &entry));

    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_PSAMP;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV4;

    if (entry.encap.psamp.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.psamp.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.psamp.dst_mac, 6);
    mirror_dest->src_addr = entry.encap.psamp.src_ipv4;
    mirror_dest->dst_addr = entry.encap.psamp.dst_ipv4;
    mirror_dest->tos = entry.encap.psamp.tos;
    mirror_dest->ttl = entry.encap.psamp.ttl;
    mirror_dest->df = entry.encap.psamp.df;
    mirror_dest->udp_src_port = entry.encap.psamp.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.psamp.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.psamp.pri;
    mirror_dest->cfi = entry.encap.psamp.cfi;
    mirror_dest->vlan_id = entry.encap.psamp.vlan_id;
    mirror_dest->tpid = entry.encap.psamp.tpid;
    mirror_dest->observation_domain = entry.encap.psamp.observation_domain;
    mirror_dest->template_id = entry.encap.psamp.template_id;
    mirror_dest->initial_seq_number = entry.encap.psamp.initial_seq_num;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get PSAMP IPv6 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_ipv6_get(int unit, int index,
                            bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_psamp_ipv6_table_get(unit, index, &entry));

    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_PSAMP;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV6;

    if (entry.encap.psamp_ipv6.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }

    sal_memcpy(mirror_dest->src_mac, entry.encap.psamp_ipv6.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.psamp_ipv6.dst_mac, 6);
    sal_memcpy(mirror_dest->src6_addr, entry.encap.psamp_ipv6.src_ipv6, 16);
    sal_memcpy(mirror_dest->dst6_addr, entry.encap.psamp_ipv6.dst_ipv6, 16);
    mirror_dest->tos = entry.encap.psamp_ipv6.traffic_class;
    mirror_dest->ttl = entry.encap.psamp_ipv6.hop_limit;
    mirror_dest->flow_label = entry.encap.psamp_ipv6.flow_label;
    mirror_dest->udp_src_port = entry.encap.psamp_ipv6.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.psamp_ipv6.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.psamp_ipv6.pri;
    mirror_dest->cfi = entry.encap.psamp_ipv6.cfi;
    mirror_dest->vlan_id = entry.encap.psamp_ipv6.vlan_id;
    mirror_dest->tpid = entry.encap.psamp_ipv6.tpid;
    mirror_dest->observation_domain = entry.encap.psamp_ipv6.observation_domain;
    mirror_dest->template_id = entry.encap.psamp_ipv6.template_id;
    mirror_dest->initial_seq_number = entry.encap.psamp_ipv6.initial_seq_num;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get PSAMP_METADATA Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_metadata_get(int unit, int index,
                                bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_psamp_metadata_table_get(unit, index, &entry));

    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_PSAMP;
    mirror_dest->flags2 |= BCM_MIRROR_DEST_FLAGS2_PSAMP_FORMAT_2;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV4;

    if (entry.encap.psamp_metadata.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.psamp_metadata.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.psamp_metadata.dst_mac, 6);
    mirror_dest->src_addr = entry.encap.psamp_metadata.src_ipv4;
    mirror_dest->dst_addr = entry.encap.psamp_metadata.dst_ipv4;
    mirror_dest->tos = entry.encap.psamp_metadata.tos;
    mirror_dest->ttl = entry.encap.psamp_metadata.ttl;
    mirror_dest->df = entry.encap.psamp_metadata.df;
    mirror_dest->udp_src_port = entry.encap.psamp_metadata.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.psamp_metadata.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.psamp_metadata.pri;
    mirror_dest->cfi = entry.encap.psamp_metadata.cfi;
    mirror_dest->vlan_id = entry.encap.psamp_metadata.vlan_id;
    mirror_dest->tpid = entry.encap.psamp_metadata.tpid;
    mirror_dest->observation_domain = entry.encap.psamp_metadata.observation_domain;
    mirror_dest->template_id = entry.encap.psamp_metadata.template_id;
    mirror_dest->meta_data_type = entry.encap.psamp_metadata.metadata_type;
    mirror_dest->meta_data = entry.encap.psamp_metadata.metadata;
    mirror_dest->initial_seq_number = entry.encap.psamp_metadata.initial_seq_num;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get PSAMP_METADATA IPv6 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_psamp_metadata_ipv6_get(int unit, int index,
                                     bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_psamp_metadata_ipv6_table_get(unit, index, &entry));

    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_PSAMP;
    mirror_dest->flags2 |= BCM_MIRROR_DEST_FLAGS2_PSAMP_FORMAT_2;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV6;

    if (entry.encap.psamp_metadata_ipv6.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }

    sal_memcpy(mirror_dest->src_mac, entry.encap.psamp_metadata_ipv6.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.psamp_metadata_ipv6.dst_mac, 6);
    sal_memcpy(mirror_dest->src6_addr, entry.encap.psamp_metadata_ipv6.src_ipv6, 16);
    sal_memcpy(mirror_dest->dst6_addr, entry.encap.psamp_metadata_ipv6.dst_ipv6, 16);
    mirror_dest->tos = entry.encap.psamp_metadata_ipv6.traffic_class;
    mirror_dest->ttl = entry.encap.psamp_metadata_ipv6.hop_limit;
    mirror_dest->flow_label = entry.encap.psamp_metadata_ipv6.flow_label;
    mirror_dest->udp_src_port = entry.encap.psamp_metadata_ipv6.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.psamp_metadata_ipv6.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.psamp_metadata_ipv6.pri;
    mirror_dest->cfi = entry.encap.psamp_metadata_ipv6.cfi;
    mirror_dest->vlan_id = entry.encap.psamp_metadata_ipv6.vlan_id;
    mirror_dest->tpid = entry.encap.psamp_metadata_ipv6.tpid;
    mirror_dest->observation_domain = entry.encap.psamp_metadata_ipv6.observation_domain;
    mirror_dest->template_id = entry.encap.psamp_metadata_ipv6.template_id;
    mirror_dest->meta_data_type = entry.encap.psamp_metadata_ipv6.metadata_type;
    mirror_dest->meta_data = entry.encap.psamp_metadata_ipv6.metadata;
    mirror_dest->initial_seq_number = entry.encap.psamp_metadata_ipv6.initial_seq_num;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror-on-drop encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_add(int unit, bool egr,
                                bcm_mirror_destination_t *mirror_dest,
                                int *index)
{
    mirror_encap_type type;
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_MIRROR_ON_DROP_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_MIRROR_ON_DROP;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    entry.type = type;
    entry.egr = egr;

    if (type == ENCAP_MIRROR_ON_DROP) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.mirror_on_drop.untag = true;
        }
        sal_memcpy(entry.encap.mirror_on_drop.src_mac, mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.mirror_on_drop.dst_mac, mirror_dest->dst_mac, 6);
        entry.encap.mirror_on_drop.src_ipv4 = mirror_dest->src_addr;
        entry.encap.mirror_on_drop.dst_ipv4 = mirror_dest->dst_addr;
        entry.encap.mirror_on_drop.tos = mirror_dest->tos;
        entry.encap.mirror_on_drop.ttl = mirror_dest->ttl;
        entry.encap.mirror_on_drop.proto = MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.mirror_on_drop.df = mirror_dest->df;
        entry.encap.mirror_on_drop.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.mirror_on_drop.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.mirror_on_drop.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV4;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.mirror_on_drop.outer_vlan = true;
        }
        entry.encap.mirror_on_drop.pri = mirror_dest->pkt_prio;
        entry.encap.mirror_on_drop.cfi = mirror_dest->cfi;
        entry.encap.mirror_on_drop.vlan_id = mirror_dest->vlan_id;
        entry.encap.mirror_on_drop.tpid = mirror_dest->tpid;
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            entry.encap.mirror_on_drop.initial_seq_num =
                mirror_dest->initial_seq_number;
        }
        entry.encap.mirror_on_drop.observation_domain =
            mirror_dest->observation_domain ? mirror_dest->observation_domain :
            BCM_MIRROR_IPFIX_OBSERVATION_DOMAIN_DFLT;
        entry.encap.mirror_on_drop.template_id = mirror_dest->template_id ?
            mirror_dest->template_id : BCM_MIRROR_IPFIX_TEMPLATE_ID_DFLT;
        entry.encap.mirror_on_drop.metadata = mirror_dest->meta_data;
        entry.encap.mirror_on_drop.metadata_type = mirror_dest->meta_data_type;
    } else if (type == ENCAP_MIRROR_ON_DROP_IPv6) {
        if (mirror_dest->flags & BCM_MIRROR_DEST_PAYLOAD_UNTAGGED) {
            entry.encap.mirror_on_drop_ipv6.untag = true;
        }
        sal_memcpy(entry.encap.mirror_on_drop_ipv6.src_mac,
                   mirror_dest->src_mac, 6);
        sal_memcpy(entry.encap.mirror_on_drop_ipv6.dst_mac,
                   mirror_dest->dst_mac, 6);
        sal_memcpy(entry.encap.mirror_on_drop_ipv6.src_ipv6,
                   mirror_dest->src6_addr, 16);
        sal_memcpy(entry.encap.mirror_on_drop_ipv6.dst_ipv6,
                   mirror_dest->dst6_addr, 16);
        entry.encap.mirror_on_drop_ipv6.traffic_class = mirror_dest->tos;
        entry.encap.mirror_on_drop_ipv6.hop_limit = mirror_dest->ttl;
        entry.encap.mirror_on_drop_ipv6.next_header =
            MIRROR_ENCAP_IP_PROTO_TYPE_UDP;
        entry.encap.mirror_on_drop_ipv6.flow_label = mirror_dest->flow_label;
        entry.encap.mirror_on_drop_ipv6.l4_src_port = mirror_dest->udp_src_port;
        entry.encap.mirror_on_drop_ipv6.l4_dst_port = mirror_dest->udp_dst_port;
        entry.encap.mirror_on_drop_ipv6.ethertype = MIRROR_ENCAP_ETHERTYPE_IPV6;
        if (BCM_VLAN_VALID(mirror_dest->vlan_id)) {
            entry.encap.mirror_on_drop_ipv6.outer_vlan = true;
        }
        entry.encap.mirror_on_drop_ipv6.pri = mirror_dest->pkt_prio;
        entry.encap.mirror_on_drop_ipv6.cfi = mirror_dest->cfi;
        entry.encap.mirror_on_drop_ipv6.vlan_id = mirror_dest->vlan_id;
        entry.encap.mirror_on_drop_ipv6.tpid = mirror_dest->tpid;
        if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_WITH_SEQ) {
            entry.encap.mirror_on_drop_ipv6.initial_seq_num
                = mirror_dest->initial_seq_number;
        }
        entry.encap.mirror_on_drop_ipv6.observation_domain =
            mirror_dest->observation_domain ?
            mirror_dest->observation_domain :
            BCM_MIRROR_IPFIX_OBSERVATION_DOMAIN_DFLT;
        entry.encap.mirror_on_drop_ipv6.template_id = mirror_dest->template_id ?
            mirror_dest->template_id : BCM_MIRROR_IPFIX_TEMPLATE_ID_DFLT;
        entry.encap.mirror_on_drop_ipv6.metadata_type = mirror_dest->meta_data_type;
        entry.encap.mirror_on_drop_ipv6.metadata = mirror_dest->meta_data;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror-on-drop encap with encap id.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_delete(int unit,
                                   bcm_mirror_destination_t *mirror_dest,
                                   int index)
{
    mirror_encap_type type;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV6) {
        type = ENCAP_MIRROR_ON_DROP_IPv6;
    } else if (mirror_dest->version == MIRROR_ENCAP_IP_VER_IPV4) {
        type = ENCAP_MIRROR_ON_DROP;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_delete(unit, type, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror-on-drop encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_get(int unit, int index,
                                bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_mirror_on_drop_table_get(unit, index, &entry));

    mirror_dest->flags2 |= BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV4;

    if (entry.encap.mirror_on_drop.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }
    sal_memcpy(mirror_dest->src_mac, entry.encap.mirror_on_drop.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac, entry.encap.mirror_on_drop.dst_mac, 6);
    mirror_dest->src_addr = entry.encap.mirror_on_drop.src_ipv4;
    mirror_dest->dst_addr = entry.encap.mirror_on_drop.dst_ipv4;
    mirror_dest->tos = entry.encap.mirror_on_drop.tos;
    mirror_dest->ttl = entry.encap.mirror_on_drop.ttl;
    mirror_dest->df = entry.encap.mirror_on_drop.df;
    mirror_dest->udp_src_port = entry.encap.mirror_on_drop.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.mirror_on_drop.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.mirror_on_drop.pri;
    mirror_dest->cfi = entry.encap.mirror_on_drop.cfi;
    mirror_dest->vlan_id = entry.encap.mirror_on_drop.vlan_id;
    mirror_dest->tpid = entry.encap.mirror_on_drop.tpid;
    mirror_dest->observation_domain =
        entry.encap.mirror_on_drop.observation_domain;
    mirror_dest->template_id = entry.encap.mirror_on_drop.template_id;
    mirror_dest->meta_data_type = entry.encap.mirror_on_drop.metadata_type;
    mirror_dest->meta_data = entry.encap.mirror_on_drop.metadata;
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
    mirror_dest->initial_seq_number = entry.encap.mirror_on_drop.initial_seq_num;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror-on-drop IPv6 Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_mirror_on_drop_ipv6_get(int unit, int index,
                                     bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_mirror_on_drop_ipv6_table_get(unit, index, &entry));

    mirror_dest->flags2 |= BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP;
    mirror_dest->version = MIRROR_ENCAP_IP_VER_IPV6;

    if (entry.encap.mirror_on_drop_ipv6.untag) {
        mirror_dest->flags |= BCM_MIRROR_DEST_PAYLOAD_UNTAGGED;
    }

    sal_memcpy(mirror_dest->src_mac,
               entry.encap.mirror_on_drop_ipv6.src_mac, 6);
    sal_memcpy(mirror_dest->dst_mac,
               entry.encap.mirror_on_drop_ipv6.dst_mac, 6);
    sal_memcpy(mirror_dest->src6_addr,
               entry.encap.mirror_on_drop_ipv6.src_ipv6, 16);
    sal_memcpy(mirror_dest->dst6_addr,
               entry.encap.mirror_on_drop_ipv6.dst_ipv6, 16);
    mirror_dest->tos = entry.encap.mirror_on_drop_ipv6.traffic_class;
    mirror_dest->ttl = entry.encap.mirror_on_drop_ipv6.hop_limit;
    mirror_dest->flow_label = entry.encap.mirror_on_drop_ipv6.flow_label;
    mirror_dest->udp_src_port = entry.encap.mirror_on_drop_ipv6.l4_src_port;
    mirror_dest->udp_dst_port = entry.encap.mirror_on_drop_ipv6.l4_dst_port;
    mirror_dest->pkt_prio = entry.encap.mirror_on_drop_ipv6.pri;
    mirror_dest->cfi = entry.encap.mirror_on_drop_ipv6.cfi;
    mirror_dest->vlan_id = entry.encap.mirror_on_drop_ipv6.vlan_id;
    mirror_dest->tpid = entry.encap.mirror_on_drop_ipv6.tpid;
    mirror_dest->observation_domain =
        entry.encap.mirror_on_drop_ipv6.observation_domain;
    mirror_dest->template_id = entry.encap.mirror_on_drop_ipv6.template_id;
    mirror_dest->meta_data_type = entry.encap.mirror_on_drop_ipv6.metadata_type;
    mirror_dest->meta_data = entry.encap.mirror_on_drop_ipv6.metadata;
    mirror_dest->flags |= BCM_MIRROR_DEST_TUNNEL_WITH_SEQ;
    mirror_dest->initial_seq_number =
        entry.encap.mirror_on_drop_ipv6.initial_seq_num;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] egr Egress mirroring or not.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [out] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_add(int unit, bool egr,
                 bcm_mirror_destination_t *mirror_dest, int *index)
{
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    if (!MIRROR_DEST_IS_TUNNEL(mirror_dest)) {
        sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));

        entry.type = ENCAP_NONE;
        entry.egr = egr;
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_profile_entry_add(unit, &entry, index));
        SHR_EXIT();
    }

    /* Not support MOD encap for egress mirroring. */
    if (egr) {
        if (mirror_dest->flags2 & BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP) {
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        }
    }

    /* Not support ERSPAN3 encap. */
    if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_IP_GRE &&
        mirror_dest->gre_protocol == MIRROR_ENCAP_GRE_PROTO_TYPE_ERSPAN3) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_IP_GRE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_add(unit, egr, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_add(unit, egr, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_add(unit, egr, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_L2) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_add(unit, egr, mirror_dest, index));
    } else if (mirror_dest->flags2 &
               BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_add(unit, egr, mirror_dest, index));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_dest Mirror destination pointer.
 * \param [in] index Mirror encap index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_delete(int unit, bcm_mirror_destination_t *mirror_dest, int index)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    if (index == -1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* No encap */
    if (!MIRROR_DEST_IS_TUNNEL(mirror_dest)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_profile_entry_delete(unit, ENCAP_NONE, index));

        SHR_EXIT();
    }

    if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_IP_GRE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_delete(unit, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_delete(unit, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_delete(unit, mirror_dest, index));
    } else if (mirror_dest->flags & BCM_MIRROR_DEST_TUNNEL_L2) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_delete(unit, mirror_dest, index));
    } else if (mirror_dest->flags2 &
               BCM_MIRROR_DEST_FLAGS2_MOD_TUNNEL_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_delete(unit, mirror_dest, index));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror encap.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Mirror encap index.
 * \param [out] mirror_dest Mirror destination pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_encap_get(int unit, int index,
                 bcm_mirror_destination_t *mirror_dest)
{
    mirror_encap_type type = ENCAP_NONE;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    /* Get encap type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_type_get(unit, index, &type));

    if (type == ENCAP_RSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_rspan_get(unit, index, mirror_dest));
    } else if (type == ENCAP_ERSPAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_get(unit, index, mirror_dest));
    } else if (type == ENCAP_ERSPAN_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_erspan_ipv6_get(unit, index, mirror_dest));
    } else if (type == ENCAP_PSAMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_get(unit, index, mirror_dest));
    } else if (type == ENCAP_PSAMP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_ipv6_get(unit, index, mirror_dest));
    } else if (type == ENCAP_PSAMP_METADATA) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_metadata_get(unit, index, mirror_dest));
    } else if (type == ENCAP_PSAMP_METADATA_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_psamp_metadata_ipv6_get(unit, index, mirror_dest));
    } else if (type == ENCAP_SFLOW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_get(unit, index, mirror_dest));
    } else if (type == ENCAP_SFLOW_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_ipv6_get(unit, index, mirror_dest));
    } else if (type == ENCAP_SFLOW_SEQ) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_seq_get(unit, index, mirror_dest));
    } else if (type == ENCAP_SFLOW_SEQ_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_sflow_seq_ipv6_get(unit, index, mirror_dest));
    } else if (type == ENCAP_MIRROR_ON_DROP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_get(unit, index, mirror_dest));
    }  else if (type == ENCAP_MIRROR_ON_DROP_IPv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_mirror_on_drop_ipv6_get(unit, index, mirror_dest));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set master mirror enable for Mirror PORT_MIRROR table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Mirror-to port for which to get tag info.
 * \param [in] mirror_enable Enable status for both ingress and egress mirror
 *                           on the ingress port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_port_mirror_table_menable_set(int unit, bcm_port_t port, int mirror_enable)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRRORs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = port;
    field[1].u.val = mirror_enable;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, PORT_MIRRORs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set master mirror enable for all ports.
 *
 * \param [in] unit Unit Number.
 * \param [in] mirror_enable Enable status for both ingress and egress mirror
 *                           on the ingress port.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_port_menable_set_all(int unit, int mirror_enable)
{
    int p, max_port_num;

    SHR_FUNC_ENTER(unit);

    max_port_num = bcmi_ltsw_dev_logic_port_num(unit);

    for (p = 0; p < max_port_num; p++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_port_mirror_table_menable_set(unit, p, mirror_enable));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable the ingress port mirroring on a specific ingress port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Ingress port number.
 * \param [in] container_id Container id.
 * \param [in] en Container enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_table_ingress_add(int unit, bcm_port_t port,
                              int container_id, int en, int idx)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_ING_MIRRORs, &eh));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, PORT_IDs, port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_CONTAINER_IDs, container_id));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRRORs, en));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_INSTANCE_IDs, idx));

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ingress mirroring on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Source port number.
 * \param [in] container_id Container id.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_table_ingress_get(int unit, bcm_port_t port, int container_id,
                              bool *enable, int *idx)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data = 0LL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_ING_MIRRORs, &eh));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, PORT_IDs, port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_CONTAINER_IDs, container_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit,
                              eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eh, MIRRORs, &data));
    *enable = (bool)data;

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eh, MIRROR_INSTANCE_IDs, &data));
    *idx = (int)data;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete egress mirroring on logical table.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Source port number.
 * \param [in] container_id Container id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_table_ingress_delete(int unit, bcm_port_t port, int container_id)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_ING_MIRRORs, &eh));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, PORT_IDs, port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_CONTAINER_IDs, container_id));

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_commit(unit,
                              eh,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));
exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set ingress mirroring on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Source port number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status of container.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_enable_ingress_set(int unit, bcm_port_t port, int mc_bmp,
                               int enable, int *idx)
{
    int i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (mc_bmp & (1 << i)) {
            if (enable & (1 << i)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (mirror_port_table_ingress_add(unit, port, i, 1, idx[i]));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (mirror_port_table_ingress_delete(unit, port, i));
            }
        }
    }

    /* Master mirror enable for the ingress port. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_port_mirror_table_menable_set(unit, port, 1));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ingress mirroring on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Source port number.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_enable_ingress_get(int unit, bcm_port_t port,
                               int *enable, int *idx)
{
    int i, rv, mirror_index = 0, value = 0;
    bool ena = false;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        rv = mirror_port_table_ingress_get(unit, port, i,
                                           &ena, &mirror_index);
        if (rv == SHR_E_NONE && ena) {
            value |= 1 << i;
            idx[i] = mirror_index;
        } else if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }
    *enable = value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable the egress port mirroring on a specific ingress port.
 *
 * \param [in] unit Unit Number.
 * \param [in] ing_port Ingress port number.
 * \param [in] egr_port Egress port number.
 * \param [in] container_id Container id.
 * \param [in] en Container enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_table_egress_add(int unit, bcm_port_t ing_port,
                             bcm_port_t egr_port, int container_id,
                             int en, int idx)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_EGR_MIRRORs, &eh));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, PORT_IDs, ing_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, EGR_PORT_IDs, egr_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_CONTAINER_IDs, container_id));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRRORs, en));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_INSTANCE_IDs, idx));

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get egress port mirroring config on a specific ingress port.
 *
 * \param [in] unit Unit Number.
 * \param [in] ing_port Ingress port number.
 * \param [in] egr_port Egress port number.
 * \param [in] container_id Container id.
 * \param [out] enable Mirror enabled.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_table_egress_get(int unit, bcm_port_t ing_port, bcm_port_t egr_port,
                             int container_id, bool *enable, int* idx)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data = 0LL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_EGR_MIRRORs, &eh));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, PORT_IDs, ing_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, EGR_PORT_IDs, egr_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_CONTAINER_IDs, container_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit,
                              eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eh, MIRRORs, &data));
    *enable = (bool)data;

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eh, MIRROR_INSTANCE_IDs, &data));
    *idx = (int)data;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete egress mirroring on logical table.
 *
 * \param [in] unit Unit Number.
 * \param [in] ing_port Ingress port number.
 * \param [in] egr_port Egress port number.
 * \param [in] i Container id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_table_egress_delete(int unit, bcm_port_t ing_port,
                                bcm_port_t egr_port, int i)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_EGR_MIRRORs, &eh));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, PORT_IDs, ing_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, EGR_PORT_IDs, egr_port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, MIRROR_CONTAINER_IDs, i));

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_commit(unit,
                              eh,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));
exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set egress mirroring on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Source port number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_enable_egress_set(int unit, bcm_port_t port, int mc_bmp,
                              int enable, int *idx)
{
    int i, p, max_port_num;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    max_port_num = bcmi_ltsw_dev_logic_port_num(unit);

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (mc_bmp & (1 << i)) {
            if (enable & (1 << i)) {
                for (p = 0; p < max_port_num; p++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mirror_port_table_egress_add(unit, p, port,
                                                      i, 1, idx[i]));
                }
            } else {
                for (p = 0; p < max_port_num; p++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mirror_port_table_egress_delete(unit, p, port, i));
                }
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_port_menable_set_all(unit, 1));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get egress mirroring on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Source port number.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_port_enable_egress_get(int unit, bcm_port_t port,
                              int *enable, int *idx)
{
    int i, rv, mirror_index = 0, value = 0;
    bool ena = false;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        rv = mirror_port_table_egress_get(unit, 0, port, i,
                                          &ena, &mirror_index);
        if (rv == SHR_E_NONE && ena) {
            value |= 1 << i;
            idx[i] = mirror_index;
        } else if (rv != SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }
    *enable = value;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set ingress mirroring for FP.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status of container.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_fp_enable_ingress_set(int unit, int mc_bmp, int enable, int *idx)
{
    int i, en, p, max_port_num;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    /* Do not enable port mirror container. */
    en = 0;

    /* Configure Mirror container for all ports. */
    max_port_num = bcmi_ltsw_dev_logic_port_num(unit);
    for (p = 0; p < max_port_num; p++) {
        for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
            if (mc_bmp & (1 << i)) {
                if (enable & (1 << i)) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mirror_port_table_ingress_add(unit, p, i, en, idx[i]));
                }
            }
        }

        /* Master mirror enable for the port. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_port_mirror_table_menable_set(unit, p, 1));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set egress mirroring for FP.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status of container.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_fp_enable_egress_set(int unit, int mc_bmp, int enable, int *idx)
{
    int i, en, p, ep, max_port_num;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    /* Do not enable port mirror container. */
    en = 0;

    /* Configure Mirror container for all ports. */
    max_port_num = bcmi_ltsw_dev_logic_port_num(unit);
    for (ep = 0; ep < max_port_num; ep++) {
        for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
            if (mc_bmp & (1 << i)) {
                if (enable & (1 << i)) {
                    for (p = 0; p < max_port_num; p++) {
                        SHR_IF_ERR_VERBOSE_EXIT
                            (mirror_port_table_egress_add(unit, p, ep, i,
                                                          en, idx[i]));
                    }
                }
            }
        }

        /* Master mirror enable for the port. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_port_mirror_table_menable_set(unit, ep, 1));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get mirroring index on a FP entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] source_type.
 * \param [in] entry_id FP entry id.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_fp_enable_get(int unit, int source_type,
                     int entry_id, int *enable, int *idx)
{
    bool m_enable = false;
    int i, ena = 0, mirror_index = 0;
    bcm_field_action_t action;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    if (source_type == BCMINT_MIRROR_ST_F_FP_ING) {
        action = bcmFieldActionMirrorIngress;
    } else if (source_type == BCMINT_MIRROR_ST_F_FP_EGR) {
        action = bcmFieldActionMirrorEgress;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_field_mirror_index_get(unit,
                                              entry_id,
                                              action,
                                              i,
                                              &m_enable,
                                              &mirror_index));
        if (m_enable == true) {
            ena |= 1 << i;
            idx[i] = mirror_index;
            m_enable = false;
        }
    }
    *enable = ena;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set sFlow mirroring on a container.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */

static int
mirror_sflow_table_set(int unit, int mc_bmp, int enable, int* idx)
{
    int i;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_ING_MIRRORs, BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*1*/ {SFLOW_ING_MIRRORs, BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /*2*/ {SFLOW_ING_MIRRORs, BCMI_LT_FIELD_F_ARRAY, 2, {0}},
        /*3*/ {SFLOW_ING_MIRRORs, BCMI_LT_FIELD_F_ARRAY, 3, {0}},
        /*4*/ {SFLOW_ING_MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*5*/ {SFLOW_ING_MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /*6*/ {SFLOW_ING_MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 2, {0}},
        /*7*/ {SFLOW_ING_MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 3, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (mc_bmp & (1 << i)) {
            if (enable & (1 << i)) {
                /* Enable container. */
                field[i].flags |= BCMI_LT_FIELD_F_SET |
                                  BCMI_LT_FIELD_F_ELE_VALID;
                field[i].u.val = 1;

                /* Set instance id for the container. */
                field[i + MIRROR_CONTAINER_NUM_MAX].flags |=
                    BCMI_LT_FIELD_F_SET |
                    BCMI_LT_FIELD_F_ELE_VALID;
                field[i + MIRROR_CONTAINER_NUM_MAX].u.val = idx[i];
            } else {
                /* Disable container. */
                field[i].flags |= BCMI_LT_FIELD_F_SET |
                                  BCMI_LT_FIELD_F_ELE_VALID;
                field[i].u.val = 0;

                /* Reset instance id for the container. */
                field[i + MIRROR_CONTAINER_NUM_MAX].flags |=
                    BCMI_LT_FIELD_F_SET |
                    BCMI_LT_FIELD_F_ELE_VALID;
                field[i + MIRROR_CONTAINER_NUM_MAX].u.val = 0;
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();

}

/*!
 * \brief Get sFlow mirroring on a container.
 *
 * \param [in] unit Unit Number.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */

static int
mirror_sflow_table_get(int unit, int *enable, int* idx)
{
    int i, rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_ING_MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {SFLOW_ING_MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /*2*/ {SFLOW_ING_MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 2, {0}},
        /*3*/ {SFLOW_ING_MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 3, {0}},
        /*4*/ {SFLOW_ING_MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {SFLOW_ING_MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /*6*/ {SFLOW_ING_MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 2, {0}},
        /*7*/ {SFLOW_ING_MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 3, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);

    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
            idx[i] = 0;
        }
        *enable = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (field[i].u.val) {
            *enable |= 1 << i;
        }
        idx[i] = field[i+MIRROR_CONTAINER_NUM_MAX].u.val;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set sFlow mirroring.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status of container.
 * \param [in] instance_id Mirror instance id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sflow_enable_set(int unit, int mc_bmp,
                        int enable, int* instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sflow_table_set(unit, mc_bmp, enable, instance_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_port_menable_set_all(unit, 1));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sFlow mirroring.
 *
 * \param [in] unit Unit Number.
 * \param [out] enable Enable status of container.
 * \param [out] instance_id Mirror instance id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sflow_enable_get(int unit, int *enable, int *instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sflow_table_get(unit, enable, instance_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set INBAND TELEMETRY mirroring on a container.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_int_table_set(int unit, int mc_bmp, int enable, int* idx)
{
    int i;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MON_INBAND_TELEMETRY_MIRROR_ING_CONTAINER_IDs,
               BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRRORs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (mc_bmp & (1 << i)) {
            field[0].u.val = i;
            if (enable & (1 << i)) {
                /* Enable container. */
                field[1].u.val = 1;
                /* Set instance id for the container. */
                field[2].u.val = idx[i];
            } else {
                /* Disable container. */
                field[1].u.val = 0;
                /* Reset instance id for the container. */
                field[2].u.val = 0;
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MON_INBAND_TELEMETRY_MIRROR_ING_CONTAINERs,
                           &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get INBAND TELEMETRY mirroring on a container.
 *
 * \param [in] unit Unit Number.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_int_table_get(int unit, int *enable, int* idx)
{
    int i, rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MON_INBAND_TELEMETRY_MIRROR_ING_CONTAINER_IDs,
               BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRRORs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        field[0].u.val = i;

        rv = bcmi_lt_entry_get(unit,
                               MON_INBAND_TELEMETRY_MIRROR_ING_CONTAINERs,
                               &lt_entry,
                               NULL, NULL);

        /* Return default value when the table is not inserted. */
        if (rv == SHR_E_NOT_FOUND) {
            idx[i] = 0;
            *enable &= ~(1 << i);
            rv = SHR_E_NONE;
        } else if (SHR_FAILURE(rv)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        } else {
            if (field[1].u.val) {
                *enable |= 1 << i;
                idx[i] = field[2].u.val;
            } else {
                *enable &= ~(1 << i);
                idx[i] = 0;
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set INBAND TELEMETRY mirroring.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status of container.
 * \param [in] instance_id Mirror instance id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_int_enable_set(int unit, int mc_bmp,
                      int enable, int* instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_int_table_set(unit, mc_bmp, enable, instance_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_port_menable_set_all(unit, 1));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get INBAND TELEMETRY mirroring.
 *
 * \param [in] unit Unit Number.
 * \param [out] enable Enable status of container.
 * \param [out] instance_id Mirror instance id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_int_enable_get(int unit, int *enable, int *instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_int_table_get(unit, enable, instance_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set ELEPHANT mirroring on a container.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */

static int
mirror_elephant_table_set(int unit, int mc_bmp, int enable, int* idx)
{
    int i;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENABLEs, BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*1*/ {MIRROR_ENABLEs, BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /*2*/ {MIRROR_ENABLEs, BCMI_LT_FIELD_F_ARRAY, 2, {0}},
        /*3*/ {MIRROR_ENABLEs, BCMI_LT_FIELD_F_ARRAY, 3, {0}},
        /*4*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*5*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /*6*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 2, {0}},
        /*7*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 3, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (mc_bmp & (1 << i)) {
            if (enable & (1 << i)) {
                /* Enable container. */
                field[i].flags |= BCMI_LT_FIELD_F_SET |
                                  BCMI_LT_FIELD_F_ELE_VALID;
                field[i].u.val = 1;

                /* Set instance id for the container. */
                field[i + MIRROR_CONTAINER_NUM_MAX].flags |=
                    BCMI_LT_FIELD_F_SET |
                    BCMI_LT_FIELD_F_ELE_VALID;
                field[i + MIRROR_CONTAINER_NUM_MAX].u.val = idx[i];
            } else {
                /* Disable container. */
                field[i].flags |= BCMI_LT_FIELD_F_SET |
                                  BCMI_LT_FIELD_F_ELE_VALID;
                field[i].u.val = 0;

                /* Reset instance id for the container. */
                field[i + MIRROR_CONTAINER_NUM_MAX].flags |=
                    BCMI_LT_FIELD_F_SET |
                    BCMI_LT_FIELD_F_ELE_VALID;
                field[i + MIRROR_CONTAINER_NUM_MAX].u.val = 0;
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MON_ETRAP_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ELEPHANT mirroring on a container.
 *
 * \param [in] unit Unit Number.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */

static int
mirror_elephant_table_get(int unit, int *enable, int* idx)
{
    int i, rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ENABLEs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {MIRROR_ENABLEs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /*2*/ {MIRROR_ENABLEs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 2, {0}},
        /*3*/ {MIRROR_ENABLEs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 3, {0}},
        /*4*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /*6*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 2, {0}},
        /*7*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 3, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MON_ETRAP_CONTROLs,
                           &lt_entry,
                           NULL, NULL);

    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
            idx[i] = 0;
        }
        *enable = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (field[i].u.val) {
            *enable |= 1 << i;
        }
        idx[i] = field[i+MIRROR_CONTAINER_NUM_MAX].u.val;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set ELEPHANT mirroring.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status of container.
 * \param [in] instance_id Mirror instance id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_elephant_enable_set(int unit, int mc_bmp,
                           int enable, int* instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_elephant_table_set(unit, mc_bmp, enable, instance_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_port_menable_set_all(unit, 1));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ELEPHANT mirroring.
 *
 * \param [in] unit Unit Number.
 * \param [out] enable Enable status of container.
 * \param [out] instance_id Mirror instance id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_elephant_enable_get(int unit, int *enable, int *instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_elephant_table_get(unit, enable, instance_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB_MONITOR mirroring on a container.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */

static int
mirror_dlb_monitor_table_set(int unit, int mc_bmp, int enable, int* idx)
{
    int i;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*1*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /*2*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 2, {0}},
        /*3*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY, 3, {0}},
        /*4*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*5*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /*6*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 2, {0}},
        /*7*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY, 3, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (mc_bmp & (1 << i)) {
            if (enable & (1 << i)) {
                /* Enable container. */
                field[i].flags |= BCMI_LT_FIELD_F_SET |
                                  BCMI_LT_FIELD_F_ELE_VALID;
                field[i].u.val = 1;

                /* Set instance id for the container. */
                field[i + MIRROR_CONTAINER_NUM_MAX].flags |=
                    BCMI_LT_FIELD_F_SET |
                    BCMI_LT_FIELD_F_ELE_VALID;
                field[i + MIRROR_CONTAINER_NUM_MAX].u.val = idx[i];
            } else {
                /* Disable container. */
                field[i].flags |= BCMI_LT_FIELD_F_SET |
                                  BCMI_LT_FIELD_F_ELE_VALID;
                field[i].u.val = 0;

                /* Reset instance id for the container. */
                field[i + MIRROR_CONTAINER_NUM_MAX].flags |=
                    BCMI_LT_FIELD_F_SET |
                    BCMI_LT_FIELD_F_ELE_VALID;
                field[i + MIRROR_CONTAINER_NUM_MAX].u.val = 0;
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, DLB_ECMP_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DLB_MONITOR mirroring on a container.
 *
 * \param [in] unit Unit Number.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */

static int
mirror_dlb_monitor_table_get(int unit, int *enable, int* idx)
{
    int i, rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /*2*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 2, {0}},
        /*3*/ {MIRRORs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 3, {0}},
        /*4*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /*6*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 2, {0}},
        /*7*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 3, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           DLB_ECMP_CONTROLs,
                           &lt_entry,
                           NULL, NULL);

    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
            idx[i] = 0;
        }
        *enable = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (field[i].u.val) {
            *enable |= 1 << i;
        }
        idx[i] = field[i+MIRROR_CONTAINER_NUM_MAX].u.val;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DLB_MONITOR mirroring.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status of container.
 * \param [in] instance_id Mirror instance id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_dlb_monitor_enable_set(int unit, int mc_bmp,
                              int enable, int* instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_dlb_monitor_table_set(unit, mc_bmp, enable, instance_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_port_menable_set_all(unit, 1));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DLB_MONITOR mirroring.
 *
 * \param [in] unit Unit Number.
 * \param [out] enable Enable status of container.
 * \param [out] instance_id Mirror instance id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_dlb_monitor_enable_get(int unit, int *enable, int *instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_dlb_monitor_table_get(unit, enable, instance_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set ingress MOD mirroring on a container.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status.
 * \param [in] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_table_set(int unit, int mc_bmp, int enable, int* idx)
{
    int i;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ING_EVENT_CONTAINER_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRRORs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        if (mc_bmp & (1 << i)) {
            field[0].u.val = i;
            if (enable & (1 << i)) {
                /* Enable container. */
                field[1].u.val = 1;
                /* Set instance id for the container. */
                field[2].u.val = idx[i];
            } else {
                /* Disable container. */
                field[1].u.val = 0;
                /* Reset instance id for the container. */
                field[2].u.val = 0;
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_ING_EVENT_CONTAINERs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ingress MOD mirroring on a container.
 *
 * \param [in] unit Unit Number.
 * \param [out] enable Enable status.
 * \param [out] idx Mirror index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_table_get(int unit, int *enable, int* idx)
{
    int i, rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ING_EVENT_CONTAINER_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRRORs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(idx, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < MIRROR_CONTAINER_NUM_MAX; i++) {
        field[0].u.val = i;

        rv = bcmi_lt_entry_get(unit,
                               MIRROR_ING_EVENT_CONTAINERs,
                               &lt_entry,
                               NULL, NULL);

        /* Return default value when the table is not inserted. */
        if (rv == SHR_E_NOT_FOUND) {
            idx[i] = 0;
            *enable &= ~(1 << i);
            rv = SHR_E_NONE;
        } else if (SHR_FAILURE(rv)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        } else {
            if (field[1].u.val) {
                *enable |= 1 << i;
                idx[i] = field[2].u.val;
            } else {
                *enable &= ~(1 << i);
                idx[i] = 0;
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set ingress MOD mirroring.
 *
 * \param [in] unit Unit Number.
 * \param [in] mc_bmp Bitmap of cared mirror containers.
 * \param [in] enable Enable status of container.
 * \param [in] instance_id Mirror instance id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_enable_set(int unit, int mc_bmp,
                              int enable, int* instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_table_set(unit, mc_bmp, enable, instance_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_port_menable_set_all(unit, 1));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ingress MOD mirroring.
 *
 * \param [in] unit Unit Number.
 * \param [out] enable Enable status of container.
 * \param [out] instance_id Mirror instance id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_enable_get(int unit, int *enable, int *instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_table_get(unit, enable, instance_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror EGR member table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [in] session Mirror session entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_egr_member_table_add(int unit, int session_id,
                            bcmint_mirror_session_entry_t *session)
{
    bcmint_mirror_multi_dip_group_cfg_t dip_group;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_MEMBER_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {ENCAPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {TRUNCATE_ACTIONs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {TIMESTAMP_MODEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {MULTIPLE_MIRROR_DSTs, 0, 0, {0}},
        /*7*/ {MIRROR_DST_IP_IDs, 0, 0, {0}},
        /*8*/ {NUM_IP_ENTRYs, 0, 0, {0}},
        /*9*/ {IPV4_INDEXs, 0, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[4].flags |= BCMI_LT_FIELD_F_SYMBOL;
    session_field[5].flags |= BCMI_LT_FIELD_F_SYMBOL;
    session_field[8].flags |= BCMI_LT_FIELD_F_SYMBOL;

    /* The session_id here is actually the "session node id" == instance id. */
    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    /* MIRROR_MEMBER_ID is 0 all the time for trunk not supported device. */
    session_field[1].u.val = 0;
    session_field[2].u.val = session->encap_ena;
    session_field[3].u.val = session->encap_id;
    if (session->truncate == bcmiTruncateDoNotTruncate) {
        session_field[4].u.sym_val = DO_NOT_TRUNCATEs;
    } else if (session->truncate == bcmiTruncateTruncate) {
        session_field[4].u.sym_val = TRUNCATEs;
    } else if (session->truncate == bcmiTruncateTruncateAndZero) {
        session_field[4].u.sym_val = TRUNCATE_AND_ZEROs;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (session->timestamp_mode == bcmMirrorTimestampModePTP) {
        session_field[5].u.sym_val = PTPs;
    } else if (session->timestamp_mode == bcmMirrorTimestampModeNTP) {
        session_field[5].u.sym_val = NTPs;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Multiple mirror destination IP configurations. */
    if (session->multi_dip_group_id != BCM_MIRROR_MULTI_DIP_GROUP_INVALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_multi_dip_group_get(unit,
                                        session->multi_dip_group_id,
                                        &dip_group));
        session_field[6].flags |= BCMI_LT_FIELD_F_SET;
        session_field[6].u.val = 1;
        session_field[7].flags |= BCMI_LT_FIELD_F_SET;
        session_field[7].u.val = dip_group.offset;
        session_field[8].flags |= BCMI_LT_FIELD_F_SET;

        switch (dip_group.group_size) {
            case 1: session_field[8].u.sym_val = ENTRY_NUM_1s;
                break;
            case 2: session_field[8].u.sym_val = ENTRY_NUM_2s;
                break;
            case 4: session_field[8].u.sym_val = ENTRY_NUM_4s;
                break;
            case 8: session_field[8].u.sym_val = ENTRY_NUM_8s;
                break;
            case 16: session_field[8].u.sym_val = ENTRY_NUM_16s;
                break;
            case 32: session_field[8].u.sym_val = ENTRY_NUM_32s;
                break;
            case 64: session_field[8].u.sym_val = ENTRY_NUM_64s;
                break;
            default:
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        if (!dip_group.ipv6) {
            session_field[9].flags |= BCMI_LT_FIELD_F_SET;
            session_field[9].u.val = dip_group.ipv4_index;
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_EGR_MEMBERs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror EGR member table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_egr_member_table_delete(int unit, int session_id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_MEMBER_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    /* MIRROR_MEMBER_ID is 0 all the time for trunk not supported device. */
    session_field[1].u.val = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_EGR_MEMBERs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror EGR member table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [out] session Mirror session entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_egr_member_table_get(int unit, int session_id,
                            bcmint_mirror_session_entry_t *session)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_MEMBER_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {ENCAPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {TRUNCATE_ACTIONs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {TIMESTAMP_MODEs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[4].flags |= BCMI_LT_FIELD_F_SYMBOL;
    session_field[5].flags |= BCMI_LT_FIELD_F_SYMBOL;

    /* The session_id here is actually the "session node id" == instance id. */
    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    /* MIRROR_MEMBER_ID is 0 all the time for trunk not supported device. */
    session_field[1].u.val = 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_EGR_MEMBERs,
                           &lt_entry,
                           NULL, NULL));
    session->egr = 1;
    session->encap_ena = session_field[2].u.val;
    session->encap_id = session_field[3].u.val;
    if (!sal_strcmp(session_field[4].u.sym_val, DO_NOT_TRUNCATEs)) {
        session->truncate = bcmiTruncateDoNotTruncate;
    } else if (!sal_strcmp(session_field[4].u.sym_val, TRUNCATEs)) {
        session->truncate = bcmiTruncateTruncate;
    } else if (!sal_strcmp(session_field[4].u.sym_val, TRUNCATE_AND_ZEROs)) {
        session->truncate = bcmiTruncateTruncateAndZero;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (!sal_strcmp(session_field[5].u.sym_val, PTPs)) {
        session->timestamp_mode = bcmMirrorTimestampModePTP;
    } else if (!sal_strcmp(session_field[5].u.sym_val, NTPs)) {
        session->timestamp_mode = bcmMirrorTimestampModeNTP;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    session->valid = true;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror EGR instance table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [in] session Mirror session entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_egr_instance_table_add(int unit, int session_id,
                              bcmint_mirror_session_entry_t *session)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* Index 0 in the array is used for non-trunk ports.*/
        /*1*/ {MODPORTs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_SET |
                         BCMI_LT_FIELD_F_ELE_VALID, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    session_field[1].u.val = session->local_port;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_EGR_INSTANCEs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror EGR instance table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_egr_instance_table_delete(int unit, int session_id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_EGR_INSTANCEs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror EGR instance table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [out] session Mirror session entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_egr_instance_table_get(int unit, int session_id,
                              bcmint_mirror_session_entry_t *session)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* Index 0 in the array is used for non-trunk ports.*/
        /*1*/ {MODPORTs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit, MIRROR_EGR_INSTANCEs, &lt_entry, NULL, NULL));

    session->local_port = session_field[1].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror ING member table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [in] session Mirror session entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_ing_member_table_add(int unit, int session_id,
                            bcmint_mirror_session_entry_t *session)
{
    bcmint_mirror_multi_dip_group_cfg_t dip_group;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_MEMBER_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {ENCAPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {TRUNCATE_ACTIONs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {TIMESTAMP_MODEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/ {MULTIPLE_MIRROR_DSTs, 0, 0, {0}},
        /*7*/ {MIRROR_DST_IP_IDs, 0, 0, {0}},
        /*8*/ {NUM_IP_ENTRYs, 0, 0, {0}},
        /*9*/ {IPV4_INDEXs, 0, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[4].flags |= BCMI_LT_FIELD_F_SYMBOL;
    session_field[5].flags |= BCMI_LT_FIELD_F_SYMBOL;
    session_field[8].flags |= BCMI_LT_FIELD_F_SYMBOL;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    /* MIRROR_MEMBER_ID is 0 all the time for trunk not supported device. */
    session_field[1].u.val = 0;
    session_field[2].u.val = session->encap_ena;
    session_field[3].u.val = session->encap_id;
    if (session->truncate == bcmiTruncateDoNotTruncate) {
        session_field[4].u.sym_val = DO_NOT_TRUNCATEs;
    } else if (session->truncate == bcmiTruncateTruncate) {
        session_field[4].u.sym_val = TRUNCATEs;
    } else if (session->truncate == bcmiTruncateTruncateAndZero) {
        session_field[4].u.sym_val = TRUNCATE_AND_ZEROs;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (session->timestamp_mode == bcmMirrorTimestampModePTP) {
        session_field[5].u.sym_val = PTPs;
    } else if (session->timestamp_mode == bcmMirrorTimestampModeNTP) {
        session_field[5].u.sym_val = NTPs;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Multiple mirror destination IP configurations. */
    if (session->multi_dip_group_id != BCM_MIRROR_MULTI_DIP_GROUP_INVALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_multi_dip_group_get(unit,
                                        session->multi_dip_group_id,
                                        &dip_group));
        session_field[6].flags |= BCMI_LT_FIELD_F_SET;
        session_field[6].u.val = 1;
        session_field[7].flags |= BCMI_LT_FIELD_F_SET;
        session_field[7].u.val = dip_group.offset;
        session_field[8].flags |= BCMI_LT_FIELD_F_SET;

        switch (dip_group.group_size) {
            case 1: session_field[8].u.sym_val = ENTRY_NUM_1s;
                break;
            case 2: session_field[8].u.sym_val = ENTRY_NUM_2s;
                break;
            case 4: session_field[8].u.sym_val = ENTRY_NUM_4s;
                break;
            case 8: session_field[8].u.sym_val = ENTRY_NUM_8s;
                break;
            case 16: session_field[8].u.sym_val = ENTRY_NUM_16s;
                break;
            case 32: session_field[8].u.sym_val = ENTRY_NUM_32s;
                break;
            case 64: session_field[8].u.sym_val = ENTRY_NUM_64s;
                break;
            default:
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

        if (!dip_group.ipv6) {
            session_field[9].flags |= BCMI_LT_FIELD_F_SET;
            session_field[9].u.val = dip_group.ipv4_index;
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_ING_MEMBERs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror ING member table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_ing_member_table_delete(int unit, int session_id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_MEMBER_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    /* MIRROR_MEMBER_ID is 0 all the time for trunk not supported device. */
    session_field[1].u.val = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_ING_MEMBERs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror ING member table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [out] session Mirror session entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_ing_member_table_get(int unit, int session_id,
                            bcmint_mirror_session_entry_t *session)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MIRROR_MEMBER_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {ENCAPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {TRUNCATE_ACTIONs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {TIMESTAMP_MODEs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[4].flags |= BCMI_LT_FIELD_F_SYMBOL;
    session_field[5].flags |= BCMI_LT_FIELD_F_SYMBOL;

    /* The session_id here is actually the "session node id" == instance id. */
    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    /* MIRROR_MEMBER_ID is 0 all the time for trunk not supported device. */
    session_field[1].u.val = 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_ING_MEMBERs,
                           &lt_entry,
                           NULL, NULL));
    session->egr = 1;
    session->encap_ena = session_field[2].u.val;
    session->encap_id = session_field[3].u.val;
    if (!sal_strcmp(session_field[4].u.sym_val, DO_NOT_TRUNCATEs)) {
        session->truncate = bcmiTruncateDoNotTruncate;
    } else if (!sal_strcmp(session_field[4].u.sym_val, TRUNCATEs)) {
        session->truncate = bcmiTruncateTruncate;
    } else if (!sal_strcmp(session_field[4].u.sym_val, TRUNCATE_AND_ZEROs)) {
        session->truncate = bcmiTruncateTruncateAndZero;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (!sal_strcmp(session_field[5].u.sym_val, PTPs)) {
        session->timestamp_mode = bcmMirrorTimestampModePTP;
    } else if (!sal_strcmp(session_field[5].u.sym_val, NTPs)) {
        session->timestamp_mode = bcmMirrorTimestampModeNTP;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    session->valid = true;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add Mirror ING instance table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [in] session Mirror session entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_ing_instance_table_add(int unit, int session_id,
                              bcmint_mirror_session_entry_t *session)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* Index 0 in the array is used for non-trunk ports.*/
        /*1*/ {MODPORTs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_SET |
                         BCMI_LT_FIELD_F_ELE_VALID, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    session_field[1].u.val = session->local_port;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_ING_INSTANCEs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete Mirror ING instance table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_ing_instance_table_delete(int unit, int session_id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_ING_INSTANCEs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror ING instance table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] session_id Mirror session id.
 * \param [out] session Mirror session entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_ing_instance_table_get(int unit, int session_id,
                              bcmint_mirror_session_entry_t *session)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t session_field[] =
    {
        /*0*/ {MIRROR_INSTANCE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* Index 0 in the array is used for non-trunk ports.*/
        /*1*/ {MODPORTs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    lt_entry.fields = session_field;
    lt_entry.nfields = sizeof(session_field)/sizeof(session_field[0]);
    lt_entry.attr = 0;

    session_field[0].u.val = session_id % MIRROR_INSTANCE_NUM;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit, MIRROR_ING_INSTANCEs, &lt_entry, NULL, NULL));

    session->local_port = session_field[1].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set Mirror PORT_MIRROR table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Mirror-to port for which to get tag info.
 * \param [in] encap_id Mirror encap id.
 * \param [in] enable Enable status of encap.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_port_mirror_table_set(int unit, bcm_port_t port,
                             int encap_id, int enable)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {EGR_ENCAPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = port;
    field[1].u.val = enable;
    field[2].u.val = encap_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, PORT_MIRRORs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Mirror PORT_MIRROR table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Mirror-to port for which to get tag info.
 * \param [out] encap_id Mirror encap id.
 * \param [out] enable Enable status of encap.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mirror_port_mirror_table_get(int unit, bcm_port_t port,
                             int *encap_id, int *enable)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {EGR_ENCAPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {MIRROR_ENCAP_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(encap_id, SHR_E_PARAM);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           PORT_MIRRORs,
                           &lt_entry,
                           NULL, NULL));
    *enable = field[1].u.val;
    *encap_id = field[2].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set MIRROR_EGR_ZERO_PAYLOAD table.
 *
 * \param [in] unit Unit Number.
 * \param [in/out] pyld_zero_cfg Array containing protocol number or port number
 *                               and/or offset value for the fields represented
 *                               by bcm_mirror_payload_zero_field_t.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */

static int
mirror_egr_zero_payload_table_set(int unit,
                                  bcm_mirror_payload_zero_info_t *pyld_zero_cfg)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /* 0*/ {IP_PROTOCOLs,             BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /* 1*/ {IP_PROTOCOLs,             BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /* 2*/ {IP_PROTOCOLs,             BCMI_LT_FIELD_F_ARRAY, 2, {0}},
        /* 3*/ {IP_PROTOCOL_OFFSETs,      BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /* 4*/ {IP_PROTOCOL_OFFSETs,      BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /* 5*/ {IP_PROTOCOL_OFFSETs,      BCMI_LT_FIELD_F_ARRAY, 2, {0}},

        /* 6*/ {IPV6_NEXT_HEADERs,        BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /* 7*/ {IPV6_NEXT_HEADERs,        BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /* 8*/ {IPV6_NEXT_HEADERs,        BCMI_LT_FIELD_F_ARRAY, 2, {0}},
        /* 9*/ {IPV6_NEXT_HEADER_OFFSETs, BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*10*/ {IPV6_NEXT_HEADER_OFFSETs, BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /*11*/ {IPV6_NEXT_HEADER_OFFSETs, BCMI_LT_FIELD_F_ARRAY, 2, {0}},

        /*12*/ {DST_L4_PORTs,             BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*13*/ {DST_L4_PORTs,             BCMI_LT_FIELD_F_ARRAY, 1, {0}},
        /*14*/ {DST_L4_PORT_OFFSETs,      BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*15*/ {DST_L4_PORT_OFFSETs,      BCMI_LT_FIELD_F_ARRAY, 1, {0}},

        /*16*/ {IP_IN_IP_OFFSETs,         0, 0, {0}},
        /*17*/ {L2_OFFSETs,               0, 0, {0}},
        /*18*/ {L3_OFFSETs,               0, 0, {0}},
        /*19*/ {MPLS_OFFSETs,             0, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(pyld_zero_cfg, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    switch (pyld_zero_cfg->field_id) {
        /* IPv4. */
        case bcmMirrorPayloadZeroIp4Protocol0:
            field[0].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[3].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[0].u.val = pyld_zero_cfg->protocol_port_value;
            field[3].u.val = pyld_zero_cfg->protocol_port_offset;
            break;

        case bcmMirrorPayloadZeroIp4Protocol1:
            field[1].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[4].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[1].u.val = pyld_zero_cfg->protocol_port_value;
            field[4].u.val = pyld_zero_cfg->protocol_port_offset;
            break;

        case bcmMirrorPayloadZeroIp4Protocol2:
            field[2].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[5].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[2].u.val = pyld_zero_cfg->protocol_port_value;
            field[5].u.val = pyld_zero_cfg->protocol_port_offset;
            break;

        /* IPv6. */
        case bcmMirrorPayloadZeroIp6NxtHdr0:
            field[6].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[9].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[6].u.val = pyld_zero_cfg->protocol_port_value;
            field[9].u.val = pyld_zero_cfg->protocol_port_offset;
            break;

        case bcmMirrorPayloadZeroIp6NxtHdr1:
            field[7].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[10].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[7].u.val = pyld_zero_cfg->protocol_port_value;
            field[10].u.val = pyld_zero_cfg->protocol_port_offset ;
            break;

        case bcmMirrorPayloadZeroIp6NxtHdr2:
            field[8].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[11].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[8].u.val = pyld_zero_cfg->protocol_port_value;
            field[11].u.val = pyld_zero_cfg->protocol_port_offset;
            break;

        /* UDP ports. */
        case bcmMirrorPayloadZeroUdpPort0:
            field[12].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[14].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[12].u.val = pyld_zero_cfg->protocol_port_value;
            field[14].u.val = pyld_zero_cfg->protocol_port_offset;
            break;

        case bcmMirrorPayloadZeroUdpPort1:
            field[13].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[15].flags |=
                (BCMI_LT_FIELD_F_SET | BCMI_LT_FIELD_F_ELE_VALID);
            field[13].u.val = pyld_zero_cfg->protocol_port_value;
            field[15].u.val = pyld_zero_cfg->protocol_port_offset;
            break;

        /* Other protocols. */
        case bcmMirrorPayloadZeroIpInIpOffset:
            field[16].flags |= BCMI_LT_FIELD_F_SET;
            field[16].u.val = pyld_zero_cfg->protocol_port_offset;
            break;

        case bcmMirrorPayloadZeroL2Offset:
            field[17].flags |= BCMI_LT_FIELD_F_SET;
            field[17].u.val = pyld_zero_cfg->protocol_port_offset;
            break;

        case bcmMirrorPayloadZeroL3Offset:
            field[18].flags |= BCMI_LT_FIELD_F_SET;
            field[18].u.val = pyld_zero_cfg->protocol_port_offset;
            break;

        case bcmMirrorPayloadZeroMplsOffset:
            field[19].flags |= BCMI_LT_FIELD_F_SET;
            field[19].u.val = pyld_zero_cfg->protocol_port_offset;
            break;

        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_EGR_ZERO_PAYLOADs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MIRROR_EGR_ZERO_PAYLOAD table.
 *
 * \param [in] unit Unit Number.
 * \param [in/out] pyld_zero_cfg Array with the desired 'field_id' initialized
 *                               with a valid bcm_mirror_payload_zero_field_t
 *                               enum value in each array member.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */

static int
mirror_payload_zero_table_get(int unit,
                                  bcm_mirror_payload_zero_info_t *pyld_zero_cfg)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /* 0*/ {IP_PROTOCOLs,             BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 1*/ {IP_PROTOCOLs,             BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /* 2*/ {IP_PROTOCOLs,             BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 2, {0}},
        /* 3*/ {IP_PROTOCOL_OFFSETs,      BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 4*/ {IP_PROTOCOL_OFFSETs,      BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /* 5*/ {IP_PROTOCOL_OFFSETs,      BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 2, {0}},

        /* 6*/ {IPV6_NEXT_HEADERs,        BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 7*/ {IPV6_NEXT_HEADERs,        BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /* 8*/ {IPV6_NEXT_HEADERs,        BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 2, {0}},
        /* 9*/ {IPV6_NEXT_HEADER_OFFSETs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {IPV6_NEXT_HEADER_OFFSETs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /*11*/ {IPV6_NEXT_HEADER_OFFSETs, BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 2, {0}},

        /*12*/ {DST_L4_PORTs,             BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {DST_L4_PORTs,             BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},
        /*14*/ {DST_L4_PORT_OFFSETs,      BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {DST_L4_PORT_OFFSETs,      BCMI_LT_FIELD_F_ARRAY | BCMI_LT_FIELD_F_GET, 1, {0}},

        /*16*/ {IP_IN_IP_OFFSETs,         BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {L2_OFFSETs,               BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {L3_OFFSETs,               BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {MPLS_OFFSETs,             BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(pyld_zero_cfg, SHR_E_PARAM);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           MIRROR_EGR_ZERO_PAYLOADs,
                           &lt_entry,
                           NULL, NULL));

    switch (pyld_zero_cfg->field_id) {
        /* IPv4. */
        case bcmMirrorPayloadZeroIp4Protocol0:
            pyld_zero_cfg->protocol_port_value = field[0].u.val;
            pyld_zero_cfg->protocol_port_offset = field[3].u.val;
            break;

        case bcmMirrorPayloadZeroIp4Protocol1:
            pyld_zero_cfg->protocol_port_value = field[1].u.val;
            pyld_zero_cfg->protocol_port_offset = field[4].u.val;
            break;

        case bcmMirrorPayloadZeroIp4Protocol2:
            pyld_zero_cfg->protocol_port_value = field[2].u.val;
            pyld_zero_cfg->protocol_port_offset = field[5].u.val;
            break;

        /* IPv6. */
        case bcmMirrorPayloadZeroIp6NxtHdr0:
            pyld_zero_cfg->protocol_port_value = field[6].u.val;
            pyld_zero_cfg->protocol_port_offset = field[9].u.val;
            break;

        case bcmMirrorPayloadZeroIp6NxtHdr1:
            pyld_zero_cfg->protocol_port_value = field[7].u.val;
            pyld_zero_cfg->protocol_port_offset = field[10].u.val;
            break;

        case bcmMirrorPayloadZeroIp6NxtHdr2:
            pyld_zero_cfg->protocol_port_value = field[8].u.val;
            pyld_zero_cfg->protocol_port_offset = field[11].u.val;
            break;

        /* UDP ports. */
        case bcmMirrorPayloadZeroUdpPort0:
            pyld_zero_cfg->protocol_port_value = field[12].u.val;
            pyld_zero_cfg->protocol_port_offset = field[14].u.val;
            break;

        case bcmMirrorPayloadZeroUdpPort1:
            pyld_zero_cfg->protocol_port_value = field[13].u.val;
            pyld_zero_cfg->protocol_port_offset = field[15].u.val;
            break;

        /* Other protocols. */
        case bcmMirrorPayloadZeroIpInIpOffset:
            pyld_zero_cfg->protocol_port_value = BCM_MIRROR_PAYLOAD_ZERO_INVALID_PROTO_PORT;
            pyld_zero_cfg->protocol_port_offset = field[16].u.val;
            break;

        case bcmMirrorPayloadZeroL2Offset:
            pyld_zero_cfg->protocol_port_value = BCM_MIRROR_PAYLOAD_ZERO_INVALID_PROTO_PORT;
            pyld_zero_cfg->protocol_port_offset = field[17].u.val;
            break;

        case bcmMirrorPayloadZeroL3Offset:
            pyld_zero_cfg->protocol_port_value = BCM_MIRROR_PAYLOAD_ZERO_INVALID_PROTO_PORT;
            pyld_zero_cfg->protocol_port_offset = field[18].u.val;
            break;

        case bcmMirrorPayloadZeroMplsOffset:
            pyld_zero_cfg->protocol_port_value = BCM_MIRROR_PAYLOAD_ZERO_INVALID_PROTO_PORT;
            pyld_zero_cfg->protocol_port_offset = field[19].u.val;
            break;

        default:
            pyld_zero_cfg->protocol_port_value = BCM_MIRROR_PAYLOAD_ZERO_INVALID_PROTO_PORT;
            pyld_zero_cfg->protocol_port_offset = BCM_MIRROR_PAYLOAD_ZERO_INVALID_OFFSET;
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set ingress sampler random seed value.
 *
 * \param [in] unit Unit Number.
 * \param [in] value Random seed value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sampler_ing_seed_set(int unit, int value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_ING_SEEDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ingress sampler random seed value.
 *
 * \param [in] unit Unit Number.
 * \param [out] value Random seed value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sampler_ing_seed_get(int unit, int *value)
{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_ING_SEEDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *value = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    *value = field[0].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set egress sampler random seed value.
 *
 * \param [in] unit Unit Number.
 * \param [in] value Random seed value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sampler_egr_seed_set(int unit, int value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_EGR_SEEDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get egress sampler random seed value.
 *
 * \param [in] unit Unit Number.
 * \param [out] value Random seed value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sampler_egr_seed_get(int unit, int *value)
{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_EGR_SEEDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *value = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    *value = field[0].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set flex sampler random seed value.
 *
 * \param [in] unit Unit Number.
 * \param [in] value Random seed value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sampler_flex_seed_set(int unit, int value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_ING_FLEX_SEEDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get flex sampler random seed value.
 *
 * \param [in] unit Unit Number.
 * \param [out] value Random seed value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sampler_flex_seed_get(int unit, int *value)
{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_ING_FLEX_SEEDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *value = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    *value = field[0].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set sFlow version number.
 *
 * \param [in] unit Unit Number.
 * \param [in] value sFlow version number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sample_version_set(int unit, int value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_VERSIONs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get sFlow version number.
 *
 * \param [in] unit Unit Number.
 * \param [in] value sFlow version number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_sample_version_get(int unit, int *value)
{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SFLOW_VERSIONs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *value = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    *value = field[0].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set PSAMP IPFIX version number.
 *
 * \param [in] unit Unit Number.
 * \param [in] value PSAMP IPFIX version number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_psamp_ipfix_version_set(int unit, int value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PSAMP_IPFIX_VERSIONs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get PSAMP IPFIX version number.
 *
 * \param [in] unit Unit Number.
 * \param [in] value PSAMP IPFIX version number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_psamp_ipfix_version_get(int unit, int *value)
{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PSAMP_IPFIX_VERSIONs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *value = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    *value = field[0].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set PSAMP epoch number.
 *
 * \param [in] unit Unit Number.
 * \param [in] value PSAMP epoch number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_psamp_epoch_set(int unit, int value)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PSAMP_DLB_EPOCHs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get PSAMP epoch number.
 *
 * \param [in] unit Unit Number.
 * \param [in] value PSAMP epoch number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_psamp_epoch_get(int unit, int *value)
{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PSAMP_DLB_EPOCHs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *value = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    *value = field[0].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set CoS for unicast mirror traffic.
 *
 * \param [in] unit Unit Number.
 * \param [in] cosq CoSQ value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_uc_cos_set(int unit, int cosq)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {UC_PKT_MC_COS_OVERRIDEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {UC_PKT_MC_COSs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    if (cosq == -1) {
        field[0].u.val = false;
        field[1].u.val = 0;
    } else if (cosq >= 0) {
        field[0].u.val = true;
        field[1].u.val = cosq;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get CoS for unitcast mirror traffic.
 *
 * \param [in] unit Unit Number.
 * \param [out] cosq CoSQ value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_uc_cos_get(int unit, int *cosq)
{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {UC_PKT_MC_COS_OVERRIDEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {UC_PKT_MC_COSs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *cosq = -1;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (field[0].u.val) {
        *cosq = field[1].u.val;
    } else {
        *cosq = -1;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set CoS for multicast mirror traffic.
 *
 * \param [in] unit Unit Number.
 * \param [in] cosq CoSQ value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_mc_cos_set(int unit, int cosq)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MC_PKT_MC_COS_OVERRIDEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {MC_PKT_MC_COSs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    if (cosq == -1) {
        field[0].u.val = false;
        field[1].u.val = 0;
    } else if (cosq >= 0) {
        field[0].u.val = true;
        field[1].u.val = cosq;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get CoS for multicast mirror traffic.
 *
 * \param [in] unit Unit Number.
 * \param [out] cosq CoSQ value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_mc_cos_get(int unit, int *cosq)
{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MC_PKT_MC_COS_OVERRIDEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {MC_PKT_MC_COSs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *cosq = -1;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (field[0].u.val) {
        *cosq = field[1].u.val;
    } else {
        *cosq = -1;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set CoS for mirror traffic destined for CPU port.
 *
 * \param [in] unit Unit Number.
 * \param [in] cosq CoSQ value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_cpu_cos_set(int unit, int cosq)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_CPU_COS_OVERRIDEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TM_CPU_COSs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    if (cosq == -1) {
        field[0].u.val = false;
        field[1].u.val = 0;
    } else if (cosq >= 0) {
        field[0].u.val = true;
        field[1].u.val = cosq;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get CoS for mirror traffic destined for CPU port.
 *
 * \param [in] unit Unit Number.
 * \param [out] cosq CoSQ value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_cpu_cos_get(int unit, int *cosq)
{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {TM_CPU_COS_OVERRIDEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {TM_CPU_COSs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *cosq = -1;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    if (field[0].u.val) {
        *cosq = field[1].u.val;
    } else {
        *cosq = -1;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set enable status for mirror traffic to drop pkts with invalid VLAN.
 *
 * \param [in] unit Unit Number.
 * \param [in] enable Enable status.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_invalid_vlan_drop_set(int unit, int enable)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {INVALID_VLAN_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = enable;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get enable status of mirror traffic dropping pkts with invalid VLAN.
 *
 * \param [in] unit Unit Number.
 * \param [out] enable Enable status.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_invalid_vlan_drop_get(int unit, int *enable)
{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {INVALID_VLAN_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *enable = 0;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    *enable = field[0].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set enable status for skipping packet checks for mirror packets.
 *
 * \param [in] unit Unit Number.
 * \param [in] enable Enable status.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_pkt_checks_set(int unit, int enable)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SKIP_PKT_CHECKSs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = enable ? 0 : 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get enable status of skipping packet checks for mirror packets.
 *
 * \param [in] unit Unit Number.
 * \param [in] enable Enable status.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_pkt_checks_get(int unit, int *enable)
{
    int rv;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {SKIP_PKT_CHECKSs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           MIRROR_CONTROLs,
                           &lt_entry,
                           NULL, NULL);
    /* Return default value when the table is not inserted. */
    if (rv == SHR_E_NOT_FOUND) {
        *enable = 1;
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NONE);
    } else if (SHR_FAILURE(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    *enable = field[0].u.val ? 0 : 1;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize PSAMP IPFIX version number.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_psamp_ipfix_version_init(int unit)
{
    int warm = bcmi_warmboot_get(unit);
    SHR_FUNC_ENTER(unit);

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_psamp_ipfix_version_set(unit, (uint32_t)0xA));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the ingress mirror-on-drop event mapping index.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_index_init(int unit)
{
    int index, size;
    bcm_mirror_ingress_mod_event_t  event_id;
    bcmint_mirror_ingress_mod_event_map_info_t *event_map_tab = NULL;

    SHR_FUNC_ENTER(unit);

    /* Get chip-specific map info. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mirror_ingress_mod_event_map_info_get(unit, &event_map_tab, &size));

    memset(mirror_ingress_mod_event_index[unit], -1, sizeof(mirror_ingress_mod_event_index[unit]));

    index = 0;
    while (index < size) {
        event_id = event_map_tab[index].type;
        if (mirror_ingress_mod_event_index[unit][event_id] == -1) {
            mirror_ingress_mod_event_index[unit][event_id] = index;
        }
        index++;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover ingress mirror-on-drop event profile used bitmap.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_profile_bmp_recover(int unit)
{
    int i, id, profile_id;

    SHR_FUNC_ENTER(unit);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    SHR_NULL_CHECK(MIRROR_ING_MOD_CTRL(unit)->ingress_mod_event_profile,
                   SHR_E_INIT);

    for (i = 0; i < MIRROR_ING_MOD_EVENT_PROF_NUM(unit); i++) {
        id = i + BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE;
        profile_id = MIRROR_ING_MOD_EVENT_PROF(unit, id).profile_id;
        /* Not used. */
        if (profile_id == 0) {
            continue;
        }
        mirror_ingress_mod_event_profile_id_hold(unit, id);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init ingress MOD bookkeeping info.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_bk_init(int unit)
{
    uint64_t idx_min_data = 0LL, idx_max_data = 0LL;
    uint32_t entry_num, alloc_size = 0, req_size = 0,
             ha_instance_size = 0, ha_array_size = 0;
    int warm = bcmi_warmboot_get(unit), i, rv, idx_min, idx_max;
    void *ptr_ingress_mod_group = NULL, *ptr_ingress_mod_profile = NULL;
    mirror_ingress_mod_ctrl_t *imod_ctrl = MIRROR_ING_MOD_CTRL(unit);

    SHR_FUNC_ENTER(unit);

    /* Get number of ingress MOD event groups. */
    rv = bcmi_lt_field_value_range_get(unit,
                                       MIRROR_ING_EVENT_GROUPs,
                                       MIRROR_ING_EVENT_GROUP_IDs,
                                       &idx_min_data,
                                       &idx_max_data);
    if (rv != SHR_E_NONE) {
        imod_ctrl->inited = false;
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    idx_min = (int)idx_min_data;
    idx_max = (int)idx_max_data;
    if (idx_max - idx_min < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    imod_ctrl->ingress_mod_event_group_num = idx_max - idx_min + 1;

    /* Get number of ingress MOD event profiles. */
    rv = bcmi_lt_capacity_get(unit,
                              MIRROR_ING_EVENT_PROFILEs,
                              &entry_num);

    if (rv != SHR_E_NONE) {
        imod_ctrl->inited = false;
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    imod_ctrl->ingress_mod_event_profile_num = entry_num;

    /* Ingress MOD event groups. */
    ha_instance_size = sizeof(bcmint_mirror_ingress_mod_event_group_cfg_t);
    ha_array_size = MIRROR_ING_MOD_EVENT_GRP_NUM(unit);
    req_size = ha_instance_size * ha_array_size;
    alloc_size = req_size;
    ptr_ingress_mod_group = bcmi_ltsw_ha_mem_alloc(unit,
                        BCMI_HA_COMP_ID_MIRROR,
                        BCMINT_MIRROR_SUB_COMP_ID_MIRROR_ING_MOD_EVENT_GROUP,
                        "bcmMirrorIngModEventGroup",
                        &alloc_size);
    SHR_NULL_CHECK(ptr_ingress_mod_group, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT((alloc_size < req_size) ?
                            SHR_E_MEMORY : SHR_E_NONE);
    MIRROR_ING_MOD_CTRL(unit)->ingress_mod_event_group =
        (bcmint_mirror_ingress_mod_event_group_cfg_t *)ptr_ingress_mod_group;
    if (!warm) {
        sal_memset(ptr_ingress_mod_group, 0, alloc_size);
        for (i = 0; i < MIRROR_ING_MOD_EVENT_GRP_NUM(unit); i++) {
            MIRROR_ING_MOD_CTRL(unit)->ingress_mod_event_group[i].group_id = 0;
        }
    }

    rv = bcmi_ltsw_issu_struct_info_report(unit,
             BCMI_HA_COMP_ID_MIRROR,
             BCMINT_MIRROR_SUB_COMP_ID_MIRROR_ING_MOD_EVENT_GROUP,
             0, ha_instance_size, ha_array_size,
             BCMINT_MIRROR_INGRESS_MOD_EVENT_GROUP_CFG_T_ID);
    if (rv != SHR_E_EXISTS) {
       SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    /* Ingress MOD event profiles. */
    ha_instance_size = sizeof(bcmint_mirror_ingress_mod_event_profile_cfg_t);
    ha_array_size = MIRROR_ING_MOD_EVENT_PROF_NUM(unit);
    req_size = ha_instance_size * ha_array_size;
    alloc_size = req_size;
    ptr_ingress_mod_profile = bcmi_ltsw_ha_mem_alloc(unit,
                        BCMI_HA_COMP_ID_MIRROR,
                        BCMINT_MIRROR_SUB_COMP_ID_MIRROR_ING_MOD_EVENT_PROFILE,
                        "bcmMirrorIngModEventProfile",
                        &alloc_size);
    SHR_NULL_CHECK(ptr_ingress_mod_profile, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT((alloc_size < req_size) ?
                            SHR_E_MEMORY : SHR_E_NONE);
    MIRROR_ING_MOD_CTRL(unit)->ingress_mod_event_profile =
        (bcmint_mirror_ingress_mod_event_profile_cfg_t *)ptr_ingress_mod_profile;
    if (!warm) {
        sal_memset(ptr_ingress_mod_profile, 0, alloc_size);
        for (i = 0; i < MIRROR_ING_MOD_EVENT_PROF_NUM(unit); i++) {
            MIRROR_ING_MOD_CTRL(unit)->ingress_mod_event_profile[i].profile_id = 0;
        }
    }

    rv = bcmi_ltsw_issu_struct_info_report(unit,
             BCMI_HA_COMP_ID_MIRROR,
             BCMINT_MIRROR_SUB_COMP_ID_MIRROR_ING_MOD_EVENT_PROFILE,
             0, ha_instance_size, ha_array_size,
             BCMINT_MIRROR_INGRESS_MOD_EVENT_PROFILE_CFG_T_ID);
    if (rv != SHR_E_EXISTS) {
       SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    /* Ingress MOD event profile used bitmap. */
    alloc_size = sizeof(SHR_BITDCL);
    MIRROR_ING_MOD_CTRL(unit)->profile_bmp = sal_alloc(alloc_size, "ltswMirrorIngModEvntProfBmp");
    SHR_NULL_CHECK(MIRROR_ING_MOD_CTRL(unit)->profile_bmp, SHR_E_MEMORY);
    sal_memset(MIRROR_ING_MOD_CTRL(unit)->profile_bmp, 0, alloc_size);

    imod_ctrl->inited = true;

    if (warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ingress_mod_event_profile_bmp_recover(unit));
    }


exit:
    if (SHR_FUNC_ERR()) {
        imod_ctrl->inited = false;
        if (!warm && ptr_ingress_mod_group) {
            (void)bcmi_ltsw_ha_mem_free(unit, ptr_ingress_mod_group);
            MIRROR_ING_MOD_CTRL(unit)->ingress_mod_event_group = NULL;
        }
        if (!warm && ptr_ingress_mod_profile) {
            (void)bcmi_ltsw_ha_mem_free(unit, ptr_ingress_mod_profile);
            MIRROR_ING_MOD_CTRL(unit)->ingress_mod_event_profile = NULL;
        }
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Allocate an ingress mirror-on-drop event group buffer.
 *
 * \param [in] unit Unit number.
 * \param [out] event_group Ingress mirror-on-drop event group buffer pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_group_alloc(
    int unit,
    bcmint_mirror_ingress_mod_event_group_cfg_t **event_group)
{
    int alloc_size;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(event_group, SHR_E_PARAM);

    alloc_size = sizeof(bcmint_mirror_ingress_mod_event_group_cfg_t);

    *event_group = sal_alloc(alloc_size, "ltswMirrorEventGrpBuffer");
    SHR_NULL_CHECK(*event_group, SHR_E_MEMORY);
    sal_memset(*event_group, 0, alloc_size);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Free an ingress mirror-on-drop event group buffer.
 *
 * \param [in] event_group Ingress mirror-on-drop event group buffer pointer.
 */
static void
mirror_ingress_mod_event_group_free(
    bcmint_mirror_ingress_mod_event_group_cfg_t **event_group)
{
    if (event_group && *event_group) {
        sal_free(*event_group);
        *event_group = NULL;
    }
}

/*!
 * \brief Reference an ingress mirror-on-drop event group.
 *
 * \param [in] unit Unit number.
 * \param [in] id Event group id.
 * \param [in] count Increased count.
 */
static void
mirror_ingress_mod_event_group_refer(int unit, int id, uint32_t count)
{
    MIRROR_ING_MOD_EVENT_GRP_REF_COUNT(unit, id) += count;
}

/*!
 * \brief Dereference an ingress mirror-on-drop event group.
 *
 * \param [in] unit Unit number.
 * \param [in] id Event group id.
 * \param [in] count Decreased count.
 */
static void
mirror_ingress_mod_event_group_derefer(int unit, int id, uint32_t count)
{
    MIRROR_ING_MOD_EVENT_GRP_REF_COUNT(unit, id) -= count;
}

/*!
 * \brief Allocate a free ingress mirror-on-drop event group id from pool.
 *
 * \param [in] unit Unit number.
 * \param [out] id Event group id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_group_id_alloc(int unit, int *id)
{
    int i;

    for (i = BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE;
         i < MIRROR_ING_MOD_EVENT_GRP_NUM(unit) +
             BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE; i++) {
        if (MIRROR_ING_MOD_EVENT_GRP_REF_COUNT(unit, i)) {
            continue;
        }
        *id = i;
        return SHR_E_NONE;
    }
    return SHR_E_RESOURCE;
}

/*!
 * \brief Add an ingress mirror-on-drop event group to group pool.
 *
 * \param [in] unit Unit number.
 * \param [in] event_group Ingress mirror-on-drop event group buffer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_group_add(
    int unit,
    bcmint_mirror_ingress_mod_event_group_cfg_t *event_group)
{
    int id;

    SHR_FUNC_ENTER(unit);

    id = event_group->group_id;
    MIRROR_ING_MOD_EVENT_GRP_ID_CHECK(unit, id);

    MIRROR_ING_MOD_EVENT_GRP(unit, id) = *event_group;
    mirror_ingress_mod_event_group_refer(unit, id, 1);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get an ingress mirror-on-drop event group from group pool.
 *
 * \param [in] unit Unit number.
 * \param [in] id Group id.
 * \param [out] event_group Ingress mirror-on-drop event group buffer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_group_get(
    int unit,
    int id,
    bcmint_mirror_ingress_mod_event_group_cfg_t *event_group)
{
    SHR_FUNC_ENTER(unit);
    MIRROR_ING_MOD_EVENT_GRP_ID_CHECK(unit, id);

    if (MIRROR_ING_MOD_EVENT_GRP_REF_COUNT(unit, id) == 0) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    *event_group = MIRROR_ING_MOD_EVENT_GRP(unit, id);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete an ingress mirror-on-drop event group from group pool.
 *
 * \param [in] unit Unit number.
 * \param [in] id Group id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_group_delete(int unit, int id)
{
    SHR_FUNC_ENTER(unit);
    MIRROR_ING_MOD_EVENT_GRP_ID_CHECK(unit, id);

    /* The group is still being used by others. */
    if (MIRROR_ING_MOD_EVENT_GRP_REF_COUNT(unit, id) > 1) {
        SHR_ERR_EXIT(SHR_E_BUSY);
    } else if (MIRROR_ING_MOD_EVENT_GRP_REF_COUNT(unit, id) <= 0) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    mirror_ingress_mod_event_group_derefer(unit, id, 1);
    sal_memset(&MIRROR_ING_MOD_EVENT_GRP(unit, id), 0,
               sizeof(bcmint_mirror_ingress_mod_event_group_cfg_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate an ingress mirror-on-drop event parameter.
 *
 * \param [in] unit Unit number.
 * \param [in] event_array Ingress mirror-on-drop event array.
 * \param [in] num_events Number of events given.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_validate(
    int unit,
    bcm_mirror_ingress_mod_event_t *event_array,
    int num_events)
{
    int i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(event_array, SHR_E_PARAM);

    for (i = 0; i < num_events; i++) {
        if (event_array[i] < bcmMirrorIngModEventInvalidVlan ||
            event_array[i] >= bcmMirrorIngModEventCount) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Allocate an ingress mirror-on-drop event profile buffer.
 *
 * \param [in] unit Unit number.
 * \param [out] event_profile Ingress mirror-on-drop event profile buffer pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_profile_alloc(
    int unit,
    bcmint_mirror_ingress_mod_event_profile_cfg_t **event_profile)
{
    int alloc_size;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(event_profile, SHR_E_PARAM);

    alloc_size = sizeof(bcmint_mirror_ingress_mod_event_profile_cfg_t);

    *event_profile = sal_alloc(alloc_size, "ltswMirrorEventGrpBuffer");
    SHR_NULL_CHECK(*event_profile, SHR_E_MEMORY);
    sal_memset(*event_profile, 0, alloc_size);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Free an ingress mirror-on-drop event profile buffer.
 *
 * \param [in] event_profile Ingress mirror-on-drop event profile buffer pointer.
 */
static void
mirror_ingress_mod_event_profile_free(
    bcmint_mirror_ingress_mod_event_profile_cfg_t **event_profile)
{
    if (event_profile && *event_profile) {
        sal_free(*event_profile);
        *event_profile = NULL;
    }
}

/*!
 * \brief Hold an ingress mirror-on-drop event profile id.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Profile id.
 */
static void
mirror_ingress_mod_event_profile_id_hold(int unit, int id)
{
    if (id < BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE ||
        id >= (MIRROR_ING_MOD_EVENT_PROF_NUM(unit) +
              BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE)) {
        return;
    }
    ING_MOD_EVENT_PROF_BMP_USED_SET(unit, id);

    return;
}

/*!
 * \brief Free an ingress mirror-on-drop event profile id.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Profile id.
 */
static void
mirror_ingress_mod_event_profile_id_free(int unit, int id)
{
    if (id < BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE ||
        id >= (MIRROR_ING_MOD_EVENT_PROF_NUM(unit) +
              BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE)) {
        return;
    }
    ING_MOD_EVENT_PROF_BMP_USED_CLR(unit, id);
    return;
}

/*!
 * \brief Allocate a free ingress mirror-on-drop event profile id from pool.
 *
 * \param [in] unit Unit number.
 * \param [out] id Event profile id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_profile_id_alloc(int unit, int *id)
{
    int i;
    SHR_BITDCL *bitmap = MIRROR_ING_MOD_CTRL(unit)->profile_bmp;

    for (i = BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE;
         i < MIRROR_ING_MOD_EVENT_PROF_NUM(unit) +
             BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE; i++) {
        if (!SHR_BITGET(bitmap, i)) {
            *id = i;
            return SHR_E_NONE;
        }
    }
    return SHR_E_RESOURCE;
}

/*!
 * \brief Add an ingress mirror-on-drop event profile to profile pool.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_data Ingress mirror-on-drop event profile data.
 * \param [in] event_profile Ingress mirror-on-drop event profile buffer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_profile_add(
    int unit,
    bcm_mirror_ingress_mod_event_profile_t* profile_data,
    bcmint_mirror_ingress_mod_event_profile_cfg_t *event_profile)
{
    int id;

    SHR_FUNC_ENTER(unit);

    id = event_profile->profile_id;
    MIRROR_ING_MOD_EVENT_PROF_ID_CHECK(unit, id);

    event_profile->reason_code = profile_data->reason_code;
    event_profile->sample_rate = profile_data->sample_rate;
    event_profile->priority = profile_data->priority;

    MIRROR_ING_MOD_EVENT_PROF(unit, id) = *event_profile;
    mirror_ingress_mod_event_profile_id_hold(unit, id);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get an ingress mirror-on-drop event profile from profile pool.
 *
 * \param [in] unit Unit number.
 * \param [in] id Profile id.
 * \param [out] event_profile Ingress mirror-on-drop event profile buffer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_profile_get(
    int unit,
    int id,
    bcmint_mirror_ingress_mod_event_profile_cfg_t *event_profile)
{
    SHR_BITDCL *bitmap = MIRROR_ING_MOD_CTRL(unit)->profile_bmp;

    SHR_FUNC_ENTER(unit);

    MIRROR_ING_MOD_EVENT_PROF_ID_CHECK(unit, id);

    if (!SHR_BITGET(bitmap, id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    *event_profile = MIRROR_ING_MOD_EVENT_PROF(unit, id);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete an ingress mirror-on-drop event profile from profile pool.
 *
 * \param [in] unit Unit number.
 * \param [in] id Profile id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ingress_mod_event_profile_delete(int unit, int id)
{
    int i, group_id;
    bcmint_mirror_ingress_mod_event_profile_cfg_t profile;
    SHR_BITDCL *bitmap = MIRROR_ING_MOD_CTRL(unit)->profile_bmp;

    SHR_FUNC_ENTER(unit);

    MIRROR_ING_MOD_EVENT_PROF_ID_CHECK(unit, id);

    if (!SHR_BITGET(bitmap, id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_profile_get(unit, id, &profile));

    /* Update reference count for groups in the profile. */
    for (i = 0; i < MIRROR_ING_MOD_EVENT_GRP_NUM(unit); i++) {
        group_id = i + BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE;
        if (SHR_BITGET(&(profile.group_bmp), group_id)) {
            mirror_ingress_mod_event_group_derefer(unit, group_id, 1);
        }
    }

    mirror_ingress_mod_event_profile_id_free(unit, id);
    sal_memset(&MIRROR_ING_MOD_EVENT_PROF(unit, id), 0,
               sizeof(bcmint_mirror_ingress_mod_event_profile_cfg_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add an ingress mirror-on-drop event group entry to LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] group_id Index of event group.
 * \param [in] event_array Ingress mirror-on-drop events the group.
 * \param [in] num_events Number of events given.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ing_event_group_table_add(
    int unit,
    int group_id,
    bcm_mirror_ingress_mod_event_t *event_array,
    int num_events)
{
    int i, size, event_index;
    bcmint_mirror_ingress_mod_event_map_info_t *event_map_tab = NULL;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ING_EVENT_GROUP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {NULL, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(event_array, SHR_E_MEMORY);

    /* Get chip-specific map info. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mirror_ingress_mod_event_map_info_get(unit, &event_map_tab, &size));

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = group_id - BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE;

    for (i = 0; i < num_events; i++) {
        event_index = mirror_ingress_mod_event_index[unit][event_array[i]];
        if (event_index == -1) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        field[1].fld_name = event_map_tab[event_index].field_name;
        field[1].u.val = 1;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit, MIRROR_ING_EVENT_GROUPs, &lt_entry, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete an ingress mirror-on-drop event group entry from LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] group_id Index of event group.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ing_event_group_table_delete(
    int unit,
    int group_id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ING_EVENT_GROUP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = group_id - BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_ING_EVENT_GROUPs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get an ingress mirror-on-drop event group entry from LT.
 * If event_array is NULL, return the number of active events of the group.
 * Otherwise if event_array is not NULL, return the events up to num_events.

 *
 * \param [in] unit Unit Number.
 * \param [in] group_id Index of event group.
 * \param [out] event_array Ingress mirror-on-drop events the group.
 * \param [in/out] num_events Number of the events in the group.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ing_event_group_table_get(
    int unit,
    int group_id,
    bcm_mirror_ingress_mod_event_t *event_array,
    int *num_events)
{
    int i, size, count = 0, event_index;
    bcmint_mirror_ingress_mod_event_map_info_t *event_map_tab = NULL;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {MIRROR_ING_EVENT_GROUP_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {NULL, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(num_events, SHR_E_PARAM);

    /* Get chip-specific map info. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mirror_ingress_mod_event_map_info_get(unit, &event_map_tab, &size));

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = group_id - BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE;

    /*
     * If event_array is NULL, return the number of active events of the group.
     * Otherwise if event_array is not NULL, return the events up to num_events.
     */
    if (event_array == NULL) {
        for (i = 0; i < bcmMirrorIngModEventCount; i++) {
            event_index = mirror_ingress_mod_event_index[unit][i];
            if (event_index == -1) {
                continue;
            }
            field[1].fld_name = event_map_tab[event_index].field_name;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_get(unit,
                                   MIRROR_ING_EVENT_GROUPs,
                                   &lt_entry,
                                   NULL, NULL));
            if (field[1].u.val == 1) {
                count++;
            }
        }
        *num_events = count;
    } else {
        if (*num_events <= 0 || *num_events > bcmMirrorIngModEventCount) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        for (i = 0; i < bcmMirrorIngModEventCount; i++) {
            event_index = mirror_ingress_mod_event_index[unit][i];
            if (event_index == -1) {
                continue;
            }
            field[1].fld_name = event_map_tab[event_index].field_name;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_get(unit,
                                   MIRROR_ING_EVENT_GROUPs,
                                   &lt_entry,
                                   NULL, NULL));
            if (field[1].u.val == 1 && count < *num_events) {
                event_array[count] = event_map_tab[event_index].type;
                count++;
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete an ingress mirror-on-drop event profile entry to LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile Index of event profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ing_event_profile_table_delete(
    int unit,
    bcmint_mirror_ingress_mod_event_profile_cfg_t *profile)
{
    int i, id;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/  {EVENT_GROUP_0s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/  {EVENT_GROUP_1s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/  {EVENT_GROUP_2s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/  {EVENT_GROUP_3s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/  {EVENT_GROUP_4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/  {EVENT_GROUP_5s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/  {EVENT_GROUP_6s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/  {EVENT_GROUP_7s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/  {EVENT_GROUP_0_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/  {EVENT_GROUP_1_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {EVENT_GROUP_2_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {EVENT_GROUP_3_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {EVENT_GROUP_4_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {EVENT_GROUP_5_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {EVENT_GROUP_6_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {EVENT_GROUP_7_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < MIRROR_ING_MOD_EVENT_GRP_NUM(unit); i++) {
        id = i + BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE;
        field[i].u.val = SHR_BITGET(&profile->group_bmp, id) ? 1 : 0;
        field[i + MIRROR_ING_MOD_EVENT_GRP_NUM(unit)].u.val =
            SHR_BITGET(&profile->group_mask_bmp, id) ? 1 : 0;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_delete(unit, MIRROR_ING_EVENT_PROFILEs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update an ingress mirror-on-drop event profile entry to LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile Ingress mirror-on-drop event profile config data.
 * \param [in] group_bmp_new New group bitmap for profile.
 * \param [in] group_mask_bmp_new New group mask bitmap for profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_ing_event_profile_table_update(
    int unit,
    bcmint_mirror_ingress_mod_event_profile_cfg_t *profile,
    SHR_BITDCL group_bmp_new,
    SHR_BITDCL group_mask_bmp_new)
{
    int i, id;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/  {EVENT_GROUP_0s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/  {EVENT_GROUP_1s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/  {EVENT_GROUP_2s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/  {EVENT_GROUP_3s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/  {EVENT_GROUP_4s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/  {EVENT_GROUP_5s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*6*/  {EVENT_GROUP_6s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*7*/  {EVENT_GROUP_7s, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*8*/  {EVENT_GROUP_0_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*9*/  {EVENT_GROUP_1_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {EVENT_GROUP_2_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {EVENT_GROUP_3_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {EVENT_GROUP_4_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {EVENT_GROUP_5_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {EVENT_GROUP_6_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {EVENT_GROUP_7_MASKs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {MIRRORs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {REASON_CODEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {SAMPLEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {SAMPLE_RATEs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {ENTRY_PRIORITYs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    /* Delete LT entry if no group left in profile after updating. */
    if (profile->group_mask_bmp != 0 && group_mask_bmp_new == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ing_event_profile_table_delete(unit, profile));
        SHR_EXIT();
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    /* The key of LT is composed of EVENT_GROUP_0-7 and EVENT_GROUP_MASK_0-7,
     * so adding/deleting a group to a profile will change the original key.
     * Inorder to add/delete a group to a profile entry,
     *     1. Delete LT entry with old key
     *     2. Insert LT entry with new key
     *
     * LT field data are bookkeeping in SW, because they are passed-in by
     * bcm_mirror_ingress_mod_event_profile_create, but LT is only updated in
     * bcm_mirror_ingress_mod_event_profile_group_add/delete
     */

    /* Delete LT entry with old key if it's not the first time adding a group. */
    if (profile->group_mask_bmp != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ing_event_profile_table_delete(unit, profile));
    }

    /* Insert LT entry with new key. */
    for (i = 0; i < MIRROR_ING_MOD_EVENT_GRP_NUM(unit); i++) {
        id = i + BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE;
        field[i].u.val = SHR_BITGET(&group_bmp_new, id) ? 1 : 0;
        field[i + MIRROR_ING_MOD_EVENT_GRP_NUM(unit)].u.val =
            SHR_BITGET(&group_mask_bmp_new, id) ? 1 : 0;
    }

    field[16].u.val = 1;
    field[17].u.val = profile->reason_code;
    field[18].u.val = profile->sample_rate ? 1 : 0;
    field[19].u.val = profile->sample_rate;
    field[20].u.val = profile->priority;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, MIRROR_ING_EVENT_PROFILEs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*
 * Helper functions for multiple mirror destination IP allocator usage.
 */
static inline int left_leaf(uint32_t index)
{
    return index * 2 + 1;
}

static inline int right_leaf(uint32_t index)
{
    return index * 2 + 2;
}

static inline int parent(uint32_t index)
{
    return (index + 1) / 2 - 1;
}

static inline int is_power_of_2(int num)
{
    return !( num & (num - 1));
}

static inline int max(int a, int b)
{
    return (a > b) ? a : b;
}

/*!
 * \brief Init multiple DIP bookkeeping info.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_bk_init(int unit)
{
    int warm, i, rv, idx_min, idx_max;
    uint64_t idx_min_data = 0LL;
    uint64_t idx_max_data = 0LL;
    uint32_t alloc_size = 0;
    uint32_t req_size = 0;
    uint32_t dip_alloc_size = 0;
    uint32_t ha_instance_size = 0;
    uint32_t ha_array_size = 0;
    uint32_t instance_size = 0;
    uint32_t array_size = 0;
    void *ptr_multi_dip_group = NULL;
    mirror_multi_dip_alloc_t *dip_allocator = NULL, *dip_allocator_tmp = NULL;

    SHR_FUNC_ENTER(unit);
    warm = bcmi_warmboot_get(unit);
    /* Get number of multiple DIP entries. */
    rv = bcmi_lt_field_value_range_get(unit,
                                       MIRROR_DST_IPV4s,
                                       MIRROR_DST_IPV4_IDs,
                                       &idx_min_data,
                                       &idx_max_data);
    if (rv != SHR_E_NONE) {
        MIRROR_MULTI_DIP_CTRL(unit)->inited = false;
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    idx_min = (int)idx_min_data;
    idx_max = (int)idx_max_data;
    if (idx_max - idx_min < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Maximum group number is doubled for IPv4. */
    MIRROR_MULTI_DIP_CTRL(unit)->group_num = (idx_max - idx_min + 1) * 2;

    /* Multiple mirror destination IP groups. */
    ha_instance_size = sizeof(bcmint_mirror_multi_dip_group_cfg_t);
    ha_array_size = MIRROR_MULTI_DIP_CTRL(unit)->group_num;
    req_size = ha_instance_size * ha_array_size;
    alloc_size = req_size;
    ptr_multi_dip_group = bcmi_ltsw_ha_mem_alloc(unit,
                        BCMI_HA_COMP_ID_MIRROR,
                        BCMINT_MIRROR_SUB_COMP_ID_MIRROR_MULTI_DIP_GROUP,
                        "bcmMirrorMultiDipGroup",
                        &alloc_size);
    SHR_NULL_CHECK(ptr_multi_dip_group, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT((alloc_size < req_size) ?
                            SHR_E_MEMORY : SHR_E_NONE);
    MIRROR_MULTI_DIP_CTRL(unit)->multi_dip_group =
        (bcmint_mirror_multi_dip_group_cfg_t *)ptr_multi_dip_group;
    if (!warm) {
        sal_memset(ptr_multi_dip_group, 0, alloc_size);
    }

    rv = bcmi_ltsw_issu_struct_info_report(unit,
             BCMI_HA_COMP_ID_MIRROR,
             BCMINT_MIRROR_SUB_COMP_ID_MIRROR_MULTI_DIP_GROUP,
             0, ha_instance_size, ha_array_size,
             BCMINT_MIRROR_MULTI_DIP_GROUP_CFG_T_ID);
    if (rv != SHR_E_EXISTS) {
       SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    /* Multiple mirror destination IP allocator. */
    instance_size = sizeof(mirror_multi_dip_alloc_t);
    array_size = MIRROR_MULTI_DIP_ALLOC_NUM;
    alloc_size = instance_size * array_size;
    MIRROR_MULTI_DIP_CTRL(unit)->multi_dip_allocator =
                                 sal_alloc(alloc_size,
                                           "ltswMirrorMultiDipAlloc");

    SHR_NULL_CHECK(MIRROR_MULTI_DIP_CTRL(unit)->multi_dip_allocator,
                   SHR_E_MEMORY);
    sal_memset(MIRROR_MULTI_DIP_CTRL(unit)->multi_dip_allocator, 0, alloc_size);

    /* Create first allocator. */
    dip_allocator = &MIRROR_MULTI_DIP_ALLOC(unit, 0);
    dip_alloc_size = MIRROR_MULTI_DIP_CTRL(unit)->group_num / 2;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_allocator_create(unit,
                                           dip_alloc_size,
                                           dip_allocator));

    /* Copy first allocator to the others. */
    for (i = 1; i <= 2; i++) {
        dip_allocator_tmp = &MIRROR_MULTI_DIP_ALLOC(unit, i);
        alloc_size = 2 * dip_alloc_size * sizeof(uint32_t);
        dip_allocator_tmp->longest = (uint32_t*) sal_alloc(
                                    alloc_size, "ltswMirrorMultiDipAllocLgst");
        SHR_NULL_CHECK(dip_allocator_tmp->longest, SHR_E_MEMORY);

        dip_allocator_tmp->size = dip_alloc_size;
        sal_memcpy(dip_allocator_tmp->longest, dip_allocator->longest, alloc_size);
    }

    MIRROR_MULTI_DIP_CTRL(unit)->inited = true;

    if (warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_multi_dip_allocator_recover(unit));
    }


exit:
    if (SHR_FUNC_ERR()) {
        if (MIRROR_MULTI_DIP_CTRL(unit)->group_num != 0) {
            if (!warm && ptr_multi_dip_group) {
                (void)bcmi_ltsw_ha_mem_free(unit, ptr_multi_dip_group);
                MIRROR_MULTI_DIP_CTRL(unit)->multi_dip_group = NULL;
            }
            if (!warm && MIRROR_MULTI_DIP_CTRL(unit)->multi_dip_allocator) {
                for (i = 0; i < MIRROR_MULTI_DIP_ALLOC_NUM; i++) {
                    sal_free(MIRROR_MULTI_DIP_ALLOC(unit, i).longest);
                    sal_free(&MIRROR_MULTI_DIP_ALLOC(unit, i));
                }
            }
        }
        MIRROR_MULTI_DIP_CTRL(unit)->inited = false;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create a multiple DIP allocator.
 *
 * \param [in] unit Unit number.
 * \param [in] size Size of the llocate-able entries.
 * \param [in/out] allocator Multiple DIP allocator.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_allocator_create(
    int unit,
    int size,
    mirror_multi_dip_alloc_t *allocator)
{
    int i, alloc_size;
    uint32_t node_size;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(allocator, SHR_E_PARAM);

    if (size < 1 || !is_power_of_2(size)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    alloc_size = 2 * size * sizeof(uint32_t);
    allocator->longest = (uint32_t*) sal_alloc(alloc_size, "ltswMirrorMultiDipAllocLgst");
    SHR_NULL_CHECK(allocator->longest, SHR_E_MEMORY);

    allocator->size = size;
    node_size = size * 2;

    for (i = 0; i < 2 * size - 1; i++) {
        if (is_power_of_2(i + 1)) {
            node_size /= 2;
        }
        allocator->longest[i] = node_size;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert enum type bcm_mirror_multi_dip_entry_num_t to int.
 *
 * \param [in] unit Unit number.
 * \param [in] num Entry number.
 * \param [out] size Entry size.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_entry_num_to_size(
    int unit,
    bcm_mirror_multi_dip_entry_num_t num,
    uint32_t *size)
{
    SHR_FUNC_ENTER(unit);

    if (num < bcmMirrorMultiDipEntryNum1 ||
        num >= bcmMirrorMultiDipEntryNumCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *size = 1 << num;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Allocate a block from multiple DIP allocator.
 *
 * \param [in] unit Unit number.
 * \param [in] allocator Multiple DIP allocator.
 * \param [in] req_size Required entry size.
 * \param [out] offset Entry offset.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_allocator_alloc(
    int unit,
    mirror_multi_dip_alloc_t *allocator,
    int req_size,
    int *offset)
{
    uint32_t index = 0, node_size = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(allocator, SHR_E_PARAM);

    if (allocator->longest[index] < req_size) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }

    for (node_size = allocator->size; node_size != req_size; node_size /= 2 ) {
        if (allocator->longest[left_leaf(index)] >= req_size) {
            index = left_leaf(index);
        } else {
            index = right_leaf(index);
        }
    }

    allocator->longest[index] = 0;
    *offset = (index + 1) * node_size - allocator->size;

    while (index > 0) {
        index = parent(index);
        allocator->longest[index] =
            max(allocator->longest[left_leaf(index)],
                allocator->longest[right_leaf(index)]);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Free a block from multiple DIP allocator.
 *
 * \param [in] unit Unit number.
 * \param [in] allocator Multiple DIP allocator.
 * \param [in] offset Entry offset.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_allocator_free(
    int unit,
    mirror_multi_dip_alloc_t *allocator,
    int offset)
{
    uint32_t node_size, index = 0;
    uint32_t left_longest, right_longest;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(allocator, SHR_E_PARAM);

    if (offset < 0 || offset >= allocator->size) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    node_size = 1;
    index = offset + allocator->size - 1;

    while (allocator->longest[index] > 0) {
        node_size *= 2;
        if (index == 0) {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
        index = parent(index);
    }

    allocator->longest[index] = node_size;

    while (index > 0) {
        index = parent(index);
        node_size *= 2;

        left_longest = allocator->longest[left_leaf(index)];
        right_longest = allocator->longest[right_leaf(index)];

        if (left_longest + right_longest == node_size) {
            allocator->longest[index] = node_size;
        } else {
            allocator->longest[index] = max(left_longest, right_longest);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the size of a block from multiple DIP allocator.
 *
 * \param [in] unit Unit number.
 * \param [in] allocator Multiple DIP allocator.
 * \param [in] offset Entry offset.
 * \param [out] block_size Block size allocated from offset.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_allocator_block_size_get(
    int unit,
    const mirror_multi_dip_alloc_t *allocator,
    int offset,
    uint32_t *block_size)
{
    uint32_t index = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(allocator, SHR_E_PARAM);
    SHR_NULL_CHECK(block_size, SHR_E_PARAM);

    if (offset < 0 || offset >= allocator->size) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *block_size = 1;
    index = offset + allocator->size - 1;
    while (allocator->longest[index] > 0) {
        (*block_size) *= 2;
        index = parent(index);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Copy a block from one multiple DIP allocator to another.
 *
 * \param [in] unit Unit number.
 * \param [in] allocator_src Source multiple DIP allocator.
 * \param [in] allocator_dst Destination multiple DIP allocator.
 * \param [in] offset Entry offset.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_allocator_copy_at_offset(
    int unit,
    const mirror_multi_dip_alloc_t *allocator_src,
    mirror_multi_dip_alloc_t *allocator_dst,
    int offset)
{

    uint32_t offset_block_size, node_size, index = 0;
    uint32_t left_longest, right_longest;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(allocator_src, SHR_E_PARAM);
    SHR_NULL_CHECK(allocator_dst, SHR_E_PARAM);

    if (offset < 0 || offset >= allocator_src->size ||
        offset >= allocator_dst->size) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    node_size = 1;
    index = offset + allocator_src->size - 1;

    while (allocator_src->longest[index] > 0) {
        node_size *= 2;
        if (index == 0) {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
        index = parent(index);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_allocator_block_size_get(unit,
                                                   allocator_src,
                                                   offset,
                                                   &offset_block_size));

    allocator_dst->longest[index] = node_size - offset_block_size;

    while (index > 0) {
        index = parent(index);
        node_size *= 2;

        left_longest = allocator_src->longest[left_leaf(index)];
        right_longest = allocator_src->longest[right_leaf(index)];

        if (left_longest + right_longest == node_size) {
            allocator_dst->longest[index] = 0;
        } else {
            allocator_dst->longest[index] = node_size -
                                            max(left_longest, right_longest);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Dump a multiple DIP allocator.
 *
 * \param [in] unit Unit number.
 * \param [in] allocator Multiple DIP allocator.
 */
static void
mirror_multi_dip_allocator_dump(
    int unit,
    const mirror_multi_dip_alloc_t *allocator)
{
    uint32_t node_size, offset = 0;
    int i;

    if (allocator == NULL) {
        return;
    }

    node_size = allocator->size * 2;

    for (i = 0; i < 2 * allocator->size - 1; ++i) {
        if (is_power_of_2(i+1)) {
            node_size /= 2;
        }

        if (allocator->longest[i] == 0) {
            if (i >=  allocator->size - 1) {
                offset = i - allocator->size + 1;
                LOG_CLI((BSL_META_U(unit, "[%d+:%d]"), offset, node_size));
            } else if (allocator->longest[left_leaf(i)] &&
                       allocator->longest[right_leaf(i)]) {
                offset = (i+1) * node_size - allocator->size;
                LOG_CLI((BSL_META_U(unit, "[%d+:%d]"), offset, node_size));
            } else if (node_size == 1) {
                LOG_CLI((BSL_META_U(unit, "[%d+:%d]"), offset, node_size));
            }
        }
    }
    LOG_CLI((BSL_META_U(unit, "\n")));
}

/*!
 * \brief Dump multiple destination IP allocator.
 *
 * \param [in] unit Unit number.
 */
static void
mirror_multi_dip_dump(int unit)
{
    int i;
    mirror_multi_dip_alloc_t *allocator;

    for (i = 0; i < MIRROR_MULTI_DIP_ALLOC_NUM; i++) {
        allocator = &MIRROR_MULTI_DIP_ALLOC(unit, i);
        LOG_CLI((BSL_META_U(unit, "Multiple mirror DIP allocator %d: \n"), i));
        mirror_multi_dip_allocator_dump(unit, allocator);
    }
}

/*!
 * \brief Allocate an multiple mirror destination IP group buffer.
 *
 * \param [in] unit Unit number.
 * \param [out] dip_group Multiple DIP group buffer pointer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_group_alloc(
    int unit,
    bcmint_mirror_multi_dip_group_cfg_t **dip_group)
{
    int alloc_size;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(dip_group, SHR_E_PARAM);

    alloc_size = sizeof(bcmint_mirror_multi_dip_group_cfg_t);

    *dip_group = sal_alloc(alloc_size, "ltswMirrorMultiDipGrpBuffer");
    SHR_NULL_CHECK(*dip_group, SHR_E_MEMORY);
    sal_memset(*dip_group, 0, alloc_size);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Free an multiple mirror destination IP group buffer.
 *
 * \param [in] dip_group Multiple DIP group buffer pointer.
 */
static void
mirror_multi_dip_group_free(
    bcmint_mirror_multi_dip_group_cfg_t **dip_group)
{
    if (dip_group && *dip_group) {
        sal_free(*dip_group);
        *dip_group = NULL;
    }
}

/*!
 * \brief Reference an multiple mirror destination IP group.
 *
 * \param [in] unit Unit number.
 * \param [in] id Event group id.
 * \param [in] count Increased count.
 */
static void
mirror_multi_dip_group_refer(int unit, int id, uint32_t count)
{
    MIRROR_MULTI_DIP_GRP_REF_COUNT(unit, id) += count;
}

/*!
 * \brief Dereference an multiple mirror destination IP group.
 *
 * \param [in] unit Unit number.
 * \param [in] id Event group id.
 * \param [in] count Decreased count.
 */
static void
mirror_multi_dip_group_derefer(int unit, int id, uint32_t count)
{
    MIRROR_MULTI_DIP_GRP_REF_COUNT(unit, id) -= count;
}

/*!
 * \brief Allocate a free multiple mirror destination IP group id from pool.
 *
 * \param [in] unit Unit number.
 * \param [out] id Event group id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_group_id_alloc(int unit, int *id)
{
    int i;

    for (i = BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE;
         i < MIRROR_MULTI_DIP_GRP_NUM(unit) +
             BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE; i++) {
        if (MIRROR_MULTI_DIP_GRP_REF_COUNT(unit, i)) {
            continue;
        }
        *id = i;
        return SHR_E_NONE;
    }
    return SHR_E_RESOURCE;
}

/*!
 * \brief Add an multiple mirror destination IP group to group pool.
 *
 * \param [in] unit Unit number.
 * \param [in] dip_group Multiple DIP group buffer.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_group_add(
    int unit,
    bcmint_mirror_multi_dip_group_cfg_t *dip_group)
{
    int id;

    SHR_FUNC_ENTER(unit);

    id = dip_group->group_id;
    MIRROR_MULTI_DIP_GRP_ID_CHECK(unit, id);

    MIRROR_MULTI_DIP_GRP(unit, id) = *dip_group;
    mirror_multi_dip_group_refer(unit, id, 1);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get an multiple mirror destination IP group from group pool.
 *
 * \param [in] unit Unit number.
 * \param [in] id Group id.
 * \param [out] dip_group Multiple DIP group data.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
int
mirror_multi_dip_group_get(
    int unit,
    int id,
    bcmint_mirror_multi_dip_group_cfg_t *dip_group)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(dip_group, SHR_E_PARAM);

    MIRROR_MULTI_DIP_GRP_ID_CHECK(unit, id);

    if (MIRROR_MULTI_DIP_GRP_REF_COUNT(unit, id) == 0) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    *dip_group = MIRROR_MULTI_DIP_GRP(unit, id);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete an multiple mirror destination IP group from group pool.
 *
 * \param [in] unit Unit number.
 * \param [in] id Group id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_group_delete(int unit, int id)
{
    SHR_FUNC_ENTER(unit);
    MIRROR_MULTI_DIP_GRP_ID_CHECK(unit, id);

    /* The group is still being used by others. */
    if (MIRROR_MULTI_DIP_GRP_REF_COUNT(unit, id) > 1) {
        SHR_ERR_EXIT(SHR_E_BUSY);
    } else if (MIRROR_MULTI_DIP_GRP_REF_COUNT(unit, id) <= 0) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    mirror_multi_dip_group_derefer(unit, id, 1);
    sal_memset(&MIRROR_MULTI_DIP_GRP(unit, id), 0,
               sizeof(bcmint_mirror_multi_dip_group_cfg_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover multiple DIP allocator.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_allocator_recover(int unit)
{
    int i, rv, offset;
    bcmint_mirror_multi_dip_group_cfg_t dip_group;
    mirror_multi_dip_alloc_t *allocator = NULL, *allocator_ipv6 = NULL;

    SHR_FUNC_ENTER(unit);

    MIRROR_MULTI_DIP_CTRL_INIT_CHECK(unit);

    allocator_ipv6 = &MIRROR_MULTI_DIP_IPV6_ALLOC(unit);

    for (i = BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE;
         i < MIRROR_MULTI_DIP_GRP_NUM(unit) +
             BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE; i++) {
        rv = mirror_multi_dip_group_get(unit, i, &dip_group);
        if (rv == SHR_E_NOT_FOUND) {
            continue;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }

        if (dip_group.ipv6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_multi_dip_allocator_alloc(unit,
                                                  allocator_ipv6,
                                                  dip_group.group_size,
                                                  &offset));

            /* Also update IPv4_index0 allocator. */
            allocator = &MIRROR_MULTI_DIP_IPV4_IDX0_ALLOC(unit);
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_multi_dip_allocator_copy_at_offset(unit,
                                                           allocator_ipv6,
                                                           allocator,
                                                           offset));
        } else {
            if (dip_group.ipv4_index == 0) {
                allocator = &MIRROR_MULTI_DIP_IPV4_IDX0_ALLOC(unit);
            } else {
                allocator = &MIRROR_MULTI_DIP_IPV4_IDX1_ALLOC(unit);
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_multi_dip_allocator_alloc(unit,
                                                  allocator,
                                                  dip_group.group_size,
                                                  &offset));
            if (dip_group.ipv4_index == 0) {
                /*Also update IPv6 allocator. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (mirror_multi_dip_allocator_copy_at_offset(unit,
                                                               allocator,
                                                               allocator_ipv6,
                                                               offset));
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add multiple mirror destination IPv4 addresses to table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] ipv4_addr_array Multiple mirror destination IPv4 addresses.
 * \param [in] array_size Size of ipv4_addr_array.
 * \param [in] offset Offset to table entry.
 * \param [in] ipv4_index IPv4 index in a table entry. An entry can contain two IPv4 addresses.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_ipv4_table_add(
    int unit,
    bcm_ip_t *ipv4_addr_array,
    uint32_t array_size,
    int offset,
    int ipv4_index)
{
    int i, index;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/  {MIRROR_DST_IPV4_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/  {IPV4s, BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*2*/  {IPV4s, BCMI_LT_FIELD_F_ARRAY, 1, {0}},
    };

    SHR_FUNC_ENTER(unit);

    if (ipv4_index < 0 || ipv4_index > 1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    index = offset;
    for (i = 0; i < array_size; i++, index++) {
        field[0].u.val = index;
        field[1 + ipv4_index].u.val = ipv4_addr_array[i];
        field[1 + ipv4_index].flags |= BCMI_LT_FIELD_F_SET |
                                       BCMI_LT_FIELD_F_ELE_VALID;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit, MIRROR_DST_IPV4s, &lt_entry, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete multiple mirror destination IPv4 addresses from table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] addr_size Size of addresses to be deleted.
 * \param [in] offset Offset to table entry.
 * \param [in] ipv4_index IPv4 index in a table entry. An entry can contain two IPv4 addresses.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_ipv4_table_delete(
    int unit,
    uint32_t addr_size,
    int offset,
    int ipv4_index)
{
    int i, index;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/  {MIRROR_DST_IPV4_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/  {IPV4s, BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*2*/  {IPV4s, BCMI_LT_FIELD_F_ARRAY, 1, {0}},
    };

    SHR_FUNC_ENTER(unit);

    if (ipv4_index < 0 || ipv4_index > 1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    index = offset;
    for (i = 0; i < addr_size; i++, index++) {
        /*
         * An entry can contain two IPv4 addresses.
         * Only delete LT entry when no IPv4 address remains.
         */
        field[0].u.val = index;
        field[1].flags |= BCMI_LT_FIELD_F_GET |
                          BCMI_LT_FIELD_F_ELE_VALID;
        field[2].flags |= BCMI_LT_FIELD_F_GET |
                          BCMI_LT_FIELD_F_ELE_VALID;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_get(unit,
                               MIRROR_DST_IPV4s,
                               &lt_entry,
                               NULL, NULL));

        /* Delete the whole entry. */
        if (((ipv4_index == 0) && (field[2].u.val == 0)) ||
            ((ipv4_index == 1) && (field[1].u.val == 0))) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_delete(unit, MIRROR_DST_IPV4s, &lt_entry, NULL));

            continue;
        }

        /* Delete address in IPv4[ipv4_index]. */

        /* Reset flags. */
        field[1].flags = BCMI_LT_FIELD_F_ARRAY;
        field[2].flags = BCMI_LT_FIELD_F_ARRAY;

        field[1 + ipv4_index].u.val = 0;
        field[1 + ipv4_index].flags |= BCMI_LT_FIELD_F_SET |
                                       BCMI_LT_FIELD_F_ELE_VALID;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit, MIRROR_DST_IPV4s, &lt_entry, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get multiple mirror destination IPv4 addresses from table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] offset Offset to table entry.
 * \param [in] ipv4_index IPv4 index in a table entry. An entry can contain two IPv4 addresses.
 * \param [in] array_size Size of ipv4_addr_array.
 * \param [out] ipv4_addr_array Multiple mirror destination IPv4 addresses.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_ipv4_table_get(
    int unit,
    int offset,
    int ipv4_index,
    uint32_t array_size,
    bcm_ip_t *ipv4_addr_array)
{
    int i, index;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/  {MIRROR_DST_IPV4_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/  {IPV4s, BCMI_LT_FIELD_F_ARRAY, 0, {0}},
        /*2*/  {IPV4s, BCMI_LT_FIELD_F_ARRAY, 1, {0}},
    };

    SHR_FUNC_ENTER(unit);

    if (ipv4_index < 0 || ipv4_index > 1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    index = offset;
    for (i = 0; i < array_size; i++, index++) {
        field[0].u.val = index;
        field[1].flags |= BCMI_LT_FIELD_F_GET |
                          BCMI_LT_FIELD_F_ELE_VALID;
        field[2].flags |= BCMI_LT_FIELD_F_GET |
                          BCMI_LT_FIELD_F_ELE_VALID;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_get(unit,
                               MIRROR_DST_IPV4s,
                               &lt_entry,
                               NULL, NULL));

        ipv4_addr_array[i] = (bcm_ip_t) field[1 + ipv4_index].u.val;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add multiple mirror destination IPv6 addresses to table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] ipv6_addr_array Multiple mirror destination IPv6 addresses.
 * \param [in] array_size Size of ipv6_addr_array.
 * \param [in] offset Offset to table entry.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_ipv6_table_add(
    int unit,
    bcm_ip6_t *ipv6_addr_array,
    uint32_t array_size,
    int offset)
{
    uint64_t ipv6_addr[2];
    int i, index;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/  {MIRROR_DST_IPV6_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*
        * Lower or upper 64 bits of the destination IPv6 address. For even
        * values of MIRROR_DST_IPV6_ID, this field represents the lower 64 bits
        * of the IPv6 address. For odd values of MIRROR_DST_IPV6_ID, this
        * field represents the upper 64 bits of the IPv6 address.
        */
        /*1*/  {IPV6s, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    index = offset;
    for (i = 0; i < array_size; i++, index++) {
        field[0].u.val = index;
        bcmi_ltsw_util_ip6_to_uint64(ipv6_addr, &ipv6_addr_array[i]);
        /* Lower 64 bits of the IPv6 address.*/
        field[1].u.val = ipv6_addr[0];

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit, MIRROR_DST_IPV6s, &lt_entry, NULL));

        index++;
        field[0].u.val = index;
        /* Higher 64 bits of the IPv6 address.*/
        field[1].u.val = ipv6_addr[1];

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit, MIRROR_DST_IPV6s, &lt_entry, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete multiple mirror destination IPv6 addresses from table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] addr_size Size of addresses to be deleted.
 * \param [in] offset Offset to table entry.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_ipv6_table_delete(
    int unit,
    uint32_t addr_size,
    int offset)
{
    int i, index;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/  {MIRROR_DST_IPV6_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    index = offset;
    for (i = 0; i < addr_size; i++, index++) {
        field[0].u.val = index;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_delete(unit, MIRROR_DST_IPV6s, &lt_entry, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get multiple mirror destination IPv6 addresses from table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] offset Offset to table entry.
 * \param [in] array_size Size of ipv6_addr_array.
 * \param [out] ipv6_addr_array Multiple mirror destination IPv4 addresses.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
mirror_multi_dip_ipv6_table_get(
    int unit,
    int offset,
    uint32_t array_size,
    bcm_ip6_t *ipv6_addr_array)
{
    uint64_t ipv6_addr[2];
    int i, index;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/  {MIRROR_DST_IPV6_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*
        * Lower or upper 64 bits of the destination IPv6 address. For even
        * values of MIRROR_DST_IPV6_ID, this field represents the lower 64 bits
        * of the IPv6 address. For odd values of MIRROR_DST_IPV6_ID, this
        * field represents the upper 64 bits of the IPv6 address.
        */
        /*1*/  {IPV6s, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    index = offset;
    for (i = 0; i < array_size; i++, index++) {
        field[0].u.val = index;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_get(unit,
                               MIRROR_DST_IPV6s,
                               &lt_entry,
                               NULL, NULL));
        /* Lower 64 bits of the IPv6 address.*/
        ipv6_addr[0] = field[1].u.val;

        index++;
        field[0].u.val = index;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_get(unit,
                               MIRROR_DST_IPV6s,
                               &lt_entry,
                               NULL, NULL));
        /* Higher 64 bits of the IPv6 address.*/
        ipv6_addr[1] = field[1].u.val;

        bcmi_ltsw_util_uint64_to_ip6(&ipv6_addr_array[i], ipv6_addr);
    }

exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_mirror_init(int unit)
{
    bcmi_ltsw_profile_hdl_t profile_hdl;
    bcmi_ltsw_profile_hdl_t zero_pylod_profile_hdl;
    uint64_t idx_min_data = 0LL, idx_max_data = 0LL;
    int idx_min, idx_max, index;
    uint32_t size = 0;
    int warm = bcmi_warmboot_get(unit);
    mirror_encap_profile_entry_t entry;
    void *ptr = NULL;

    SHR_FUNC_ENTER(unit);

    profile_hdl = BCMI_LTSW_PROFILE_MIRROR_ENCAP;
    zero_pylod_profile_hdl = BCMI_LTSW_PROFILE_MIRROR_ZERO_PAYLOAD;

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit, profile_hdl), SHR_E_NOT_FOUND);

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit,
                                      zero_pylod_profile_hdl), SHR_E_NOT_FOUND);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       MIRROR_ING_MEMBERs,
                                       MIRROR_ENCAP_IDs,
                                       &idx_min_data,
                                       &idx_max_data));
    idx_min = (int)idx_min_data;
    idx_max = (int)idx_max_data;
    if (idx_max - idx_min < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit,
                                    &profile_hdl,
                                    &idx_min,
                                    &idx_max,
                                    1,
                                    mirror_encap_profile_hash_cb,
                                    mirror_encap_profile_cmp_cb));

    size = idx_max - idx_min + 1;
    size *= sizeof(mirror_encap_type);
    /*
     * Save encap type in HA for the benefit of:
     * 1. Recover encap profile hash data during wb.
     * 2. Recover mirror destination during wb.
     */
    ptr = bcmi_ltsw_ha_mem_alloc(unit,
                                 BCMI_HA_COMP_ID_MIRROR,
                                 BCMINT_MIRROR_SUB_COMP_ID_MIRROR_ENCAP_TYPE,
                                 "bcmMirrorEncapType",
                                 &size);
    SHR_NULL_CHECK(ptr, SHR_E_MEMORY);
    mirror_encap_info[unit].type = ptr;

    /* Mirror egress zero payload profile table */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       MIRROR_EGR_ZERO_PAYLOAD_PROFILEs,
                                       MIRROR_EGR_ZERO_PAYLOAD_PROFILE_IDs,
                                       &idx_min_data,
                                       &idx_max_data));
    idx_min = (int)idx_min_data;
    idx_max = (int)idx_max_data;
    if (idx_max - idx_min < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit,
                                    &zero_pylod_profile_hdl,
                                    &idx_min,
                                    &idx_max,
                                    1,
                                    mirror_payload_zero_profile_hash_cb,
                                    mirror_payload_zero_profile_cmp_cb));

    if (!warm) {
        sal_memset(ptr, 0, size);
        SHR_IF_ERR_EXIT
            (mirror_encap_profile_clear(unit));

        SHR_IF_ERR_EXIT
            (mirror_payload_zero_profile_clear(unit));

        /* Reserve one entry for non-encap usage. */
        sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_profile_entry_add(unit, &entry, &index));
        if (index != 0) {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
    } else {
        /* Recover ref_cnt for default entry. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit,
                                                  profile_hdl,
                                                  1, 0, 1));

        /* Recover ref_cnt for encap profile entries. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_encap_profile_recover(unit));

        SHR_IF_ERR_EXIT
            (mirror_payload_zero_profile_recover(unit));
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (!warm && ptr) {
            (void)bcmi_ltsw_ha_mem_free(unit, ptr);
            mirror_encap_info[unit].type = NULL;
        }
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit, BCMI_LTSW_PROFILE_MIRROR_ENCAP),
         SHR_E_NOT_FOUND);

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit,
                                      BCMI_LTSW_PROFILE_MIRROR_ZERO_PAYLOAD),
         SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_encap_add(
    int unit,
    bool egr,
    bcm_mirror_destination_t *mirror_dest,
    int *index)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_add(unit, egr, mirror_dest, index));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_encap_delete(
    int unit,
    bcm_mirror_destination_t *mirror_dest,
    int index)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_delete(unit, mirror_dest, index));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_encap_get(
    int unit,
    int index,
    bcm_mirror_destination_t *mirror_dest)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_dest, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_get(unit, index, mirror_dest));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_session_add(
    int unit,
    int session_id,
    bcmint_mirror_session_entry_t *session)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    if (session->egr) {
        /* Program MTP for mirror instance. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_egr_instance_table_add(unit, session_id, session));
        /*
         * Enable ENCAP for mirror instance,
         * config truncate action and timestamp mode.
         */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_egr_member_table_add(unit, session_id, session));
    } else {
        /* CoSQ MOD only update encap id. */
        if (session->cosq_mod) {
            /* Enable ENCAP for mirror instance. */
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_ing_member_table_add(unit, session_id, session));
            SHR_EXIT();
        }

        /* Program MTP for mirror instance. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ing_instance_table_add(unit, session_id, session));
        /*
         * Enable ENCAP for mirror instance,
         * config truncate action and timestamp mode.
         */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ing_member_table_add(unit, session_id, session));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_session_delete(
    int unit,
    int session_id,
    bool egr,
    bool cosq_mod)
{
    SHR_FUNC_ENTER(unit);

    if (egr) {
        /* Program MTP for mirror instance. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_egr_instance_table_delete(unit, session_id));
        /* Disable ENCAP for mirror instance. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_egr_member_table_delete(unit, session_id));
    } else {
        /* CoSQ MOD only update encap id. */
        if (cosq_mod) {
            /* Disable ENCAP for mirror instance. */
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_ing_member_table_delete(unit, session_id));
            SHR_EXIT();
        }

        /* Program MTP for mirror instance. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ing_instance_table_delete(unit, session_id));
        /* Disable ENCAP for mirror instance. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ing_member_table_delete(unit, session_id));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_session_get(
    int unit,
    int session_id,
    bcmint_mirror_session_entry_t *session)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(session, SHR_E_PARAM);

    if (session->egr) {
        /* Get MTP for mirror instance. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_egr_instance_table_get(unit, session_id, session));
        /* Get ENCAP for mirror instance. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_egr_member_table_get(unit, session_id, session));
    } else {
        /* CoSQ MOD only update encap id. */
        if (session->cosq_mod) {
            /* Get ENCAP for mirror instance. */
            SHR_IF_ERR_VERBOSE_EXIT
                (mirror_ing_member_table_get(unit, session_id, session));
            SHR_EXIT();
        }

        /* Get MTP for mirror instance. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ing_instance_table_get(unit, session_id, session));
        /* Get ENCAP for mirror instance. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ing_member_table_get(unit, session_id, session));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_enable_get(
    int unit,
    bcmint_mirror_source_t *source,
    int *enable,
    int *instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(source, SHR_E_PARAM);
    SHR_NULL_CHECK(enable, SHR_E_PARAM);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    if (source->type == BCMINT_MIRROR_ST_F_SAMPLER) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sflow_enable_get(unit,
                                     enable,
                                     instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_INT) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_int_enable_get(unit,
                                   enable,
                                   instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_ELEPHANT) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_elephant_enable_get(unit,
                                        enable,
                                        instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_DLB_MONITOR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_dlb_monitor_enable_get(unit,
                                           enable,
                                           instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_PORT_ING) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_port_enable_ingress_get(unit,
                                            source->port,
                                            enable,
                                            instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_PORT_EGR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_port_enable_egress_get(unit,
                                           source->port,
                                           enable,
                                           instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_FP_ING ||
               source->type == BCMINT_MIRROR_ST_F_FP_EGR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_fp_enable_get(unit,
                                  source->type,
                                  source->entry_id,
                                  enable,
                                  instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_ING_MOD) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ingress_mod_enable_get(unit,
                                           enable,
                                           instance_id));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_enable_set(
    int unit,
    bcmint_mirror_source_t *source,
    int mc_bmp,
    int enable,
    int *instance_id)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(source, SHR_E_PARAM);
    SHR_NULL_CHECK(instance_id, SHR_E_PARAM);

    if (source->type == BCMINT_MIRROR_ST_F_SAMPLER) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sflow_enable_set(unit,
                                     mc_bmp,
                                     enable,
                                     instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_INT) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_int_enable_set(unit,
                                   mc_bmp,
                                   enable,
                                   instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_ELEPHANT) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_elephant_enable_set(unit,
                                        mc_bmp,
                                        enable,
                                        instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_DLB_MONITOR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_dlb_monitor_enable_set(unit,
                                           mc_bmp,
                                           enable,
                                           instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_PORT_ING) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_port_enable_ingress_set(unit,
                                            source->port,
                                            mc_bmp,
                                            enable,
                                            instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_PORT_EGR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_port_enable_egress_set(unit,
                                           source->port,
                                           mc_bmp,
                                           enable,
                                           instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_ING_MOD) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ingress_mod_enable_set(unit,
                                           mc_bmp,
                                           enable,
                                           instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_FP_ING) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_fp_enable_ingress_set(unit,
                                          mc_bmp,
                                          enable,
                                          instance_id));
    } else if (source->type == BCMINT_MIRROR_ST_F_FP_EGR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_fp_enable_egress_set(unit,
                                         mc_bmp,
                                         enable,
                                         instance_id));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_misc_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_psamp_ipfix_version_init(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_index_init(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_bk_init(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_bk_init(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_misc_deinit(int unit)
{
    /* No specific deinit requirements. */
    return SHR_E_NONE;
}

int
xgs_ltsw_mirror_sampler_seed_set(
    int unit,
    bcmi_ltsw_mirror_sampler_seed_type_t type,
    int value)
{
    SHR_FUNC_ENTER(unit);

    if (type == bcmiSamplerSeedIngress) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sampler_ing_seed_set(unit, value));
    } else if (type == bcmiSamplerSeedEgress) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sampler_egr_seed_set(unit, value));
    } else if (type == bcmiSamplerSeedFlex) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sampler_flex_seed_set(unit, value));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_sampler_seed_get(
    int unit,
    bcmi_ltsw_mirror_sampler_seed_type_t type,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    if (type == bcmiSamplerSeedIngress) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sampler_ing_seed_get(unit, value));
    } else if (type == bcmiSamplerSeedEgress) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sampler_egr_seed_get(unit, value));
    } else if (type == bcmiSamplerSeedFlex) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_sampler_flex_seed_get(unit, value));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_sample_version_set(
    int unit,
    int value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_version_set(unit, value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_sample_version_get(
    int unit,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_sample_version_get(unit, value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_psamp_ipfix_version_set(
    int unit,
    int value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_psamp_ipfix_version_set(unit, value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_psamp_ipfix_version_get(
    int unit,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_psamp_ipfix_version_get(unit, value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_psamp_epoch_set(
    int unit,
    int value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_psamp_epoch_set(unit, value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_psamp_epoch_get(
    int unit,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_psamp_epoch_get(unit, value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_uc_cos_set(
    int unit,
    int uc_cos)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_uc_cos_set(unit, uc_cos));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_uc_cos_get(
    int unit,
    int *uc_cos)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_uc_cos_get(unit, uc_cos));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_mc_cos_set(
    int unit,
    int mc_cos)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_mc_cos_set(unit, mc_cos));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_mc_cos_get(
    int unit,
    int *mc_cos)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_mc_cos_get(unit, mc_cos));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_cpu_cos_set(
    int unit,
    int cpu_cos)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_cpu_cos_set(unit, cpu_cos));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_cpu_cos_get(
    int unit,
    int *cpu_cos)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_cpu_cos_get(unit, cpu_cos));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_invalid_vlan_drop_set(
    int unit,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_invalid_vlan_drop_set(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_invalid_vlan_drop_get(
    int unit,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_invalid_vlan_drop_get(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_pkt_checks_set(
    int unit,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_pkt_checks_set(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_pkt_checks_get(
    int unit,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_pkt_checks_get(unit, enable));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_vlan_get(
    int unit,
    bcm_port_t port,
    uint16_t *tpid,
    uint16_t *vlan)
{
    int encap_id, enable;
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(tpid, SHR_E_PARAM);
    SHR_NULL_CHECK(vlan, SHR_E_PARAM);

    /* Validate local port. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &port));

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_port_mirror_table_get(unit, port, &encap_id, &enable));

    if (!enable) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_rspan_table_get(unit, encap_id, &entry));

    *tpid = entry.encap.rspan.tpid;
    *vlan = entry.encap.rspan.vlan_id;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_vlan_set(
    int unit,
    bcm_port_t port,
    uint16_t tpid,
    uint16_t vlan)
{
    int encap_id, enable;
    mirror_encap_profile_entry_t entry;

    SHR_FUNC_ENTER(unit);

    /* Validate local port. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &port));

    sal_memset(&entry, 0, sizeof(mirror_encap_profile_entry_t));
    entry.type = ENCAP_RSPAN;
    entry.egr = TRUE;
    entry.encap.rspan.tpid = tpid;
    entry.encap.rspan.vlan_id = vlan;

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_encap_profile_entry_add(unit, &entry, &encap_id));

    enable = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_port_mirror_table_set(unit, port, encap_id, enable));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_payload_zero_control_multi_get(
    int unit,
    bcm_mirror_payload_zero_info_t *pyld_zero_cfg,
    int num_elems)
{
    int i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(pyld_zero_cfg, SHR_E_PARAM);

    if ((num_elems < 1) ||
        (num_elems > bcmMirrorPayloadZeroCount)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    for (i = 0; i < num_elems; i++) {
        if ((pyld_zero_cfg[i].field_id < bcmMirrorPayloadZeroIp4Protocol0) ||
            (pyld_zero_cfg[i].field_id >= bcmMirrorPayloadZeroCount)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_payload_zero_table_get(unit, &pyld_zero_cfg[i]));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_payload_zero_control_multi_set(
    int unit,
    bcm_mirror_payload_zero_info_t *pyld_zero_cfg,
    int num_elems)
{
    int i;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(pyld_zero_cfg, SHR_E_PARAM);

    if ((num_elems < 1) ||
        (num_elems > bcmMirrorPayloadZeroCount)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    for (i = 0; i < num_elems; i++) {
        if ((pyld_zero_cfg[i].field_id < bcmMirrorPayloadZeroIp4Protocol0) ||
            (pyld_zero_cfg[i].field_id >= bcmMirrorPayloadZeroCount)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_egr_zero_payload_table_set(unit, &pyld_zero_cfg[i]));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_payload_zero_profile_create(
    int unit,
    bcm_mirror_payload_zero_offsets_t *mirror_payload_offset_info,
    uint32 flags,
    uint32 * profile_index)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(mirror_payload_offset_info, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_payload_zero_profile_create(unit,
                                            mirror_payload_offset_info,
                                            flags,
                                            profile_index));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_payload_zero_profile_destroy(
    int unit,
    uint32 flags,
    uint32 profile_index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_payload_zero_profile_destroy(unit,
                                             flags,
                                             profile_index));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_group_create(
    int unit,
    bcm_mirror_ingress_mod_event_t *event_array,
    int num_events,
    bcm_mirror_ingress_mod_event_group_t *group)
{
    int group_id = -1;
    bool group_created = false;
    bcmint_mirror_ingress_mod_event_group_cfg_t *event_group_temp = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(event_array, SHR_E_PARAM);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    /* Validate ingress mirror-on-drop event parameter. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_validate(unit, event_array, num_events));

    /* Allocate an event group buffer. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_group_alloc(unit, &event_group_temp));

    /* Allocate an event group id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_group_id_alloc(unit, &group_id));

    event_group_temp->group_id = group_id;

    /* Add the group to group pool. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_group_add(unit, event_group_temp));
    group_created = true;

    /* Add events to the group. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ing_event_group_table_add(unit,
                                          group_id,
                                          event_array,
                                          num_events));

    *group = (bcm_mirror_ingress_mod_event_group_t) group_id;

exit:
    if (SHR_FUNC_ERR() && (group_created == true)) {
        (void)mirror_ingress_mod_event_group_delete(unit, group_id);
    }
    if (event_group_temp != NULL) {
        mirror_ingress_mod_event_group_free(&event_group_temp);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_group_destroy(
    int unit,
    bcm_mirror_ingress_mod_event_group_t group)
{
    SHR_FUNC_ENTER(unit);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    /* Delete the group from group pool. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_group_delete(unit, group));

    /* Delete the group. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ing_event_group_table_delete(unit, group));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_group_get_all(
    int unit,
    bcm_mirror_ingress_mod_event_group_t *group_array,
    int *count)
{
    int i, rv = 0, index = 0;
    bcmint_mirror_ingress_mod_event_group_cfg_t event_group;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(count, SHR_E_PARAM);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    if (group_array == NULL) {
        *count = 0;
        for (i = BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE;
             i < MIRROR_ING_MOD_EVENT_GRP_NUM(unit) +
                 BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE; i++) {
            rv = mirror_ingress_mod_event_group_get(unit, i, &event_group);
            if (rv == SHR_E_NOT_FOUND) {
                continue;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            *count = *count + 1;
        }
    } else {
        for (i = BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE;
             i < MIRROR_ING_MOD_EVENT_GRP_NUM(unit) +
                 BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE; i++) {
            rv = mirror_ingress_mod_event_group_get(unit, i, &event_group);
            if (rv == SHR_E_NOT_FOUND) {
                continue;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            if (index < *count) {
                group_array[index] = (bcm_mirror_ingress_mod_event_group_t)
                                     event_group.group_id;
                index++;
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_group_event_get(
    int unit,
    bcm_mirror_ingress_mod_event_group_t group,
    bcm_mirror_ingress_mod_event_t *event_array,
    int *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(count, SHR_E_PARAM);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    MIRROR_ING_MOD_EVENT_GRP_ID_CHECK(unit, group);

    /* Get group events. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ing_event_group_table_get(unit,
                                          group,
                                          event_array,
                                          count));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_profile_create(
    int unit,
    bcm_mirror_ingress_mod_event_profile_t *profile,
    int *profile_id)
{
    int profile_id_temp = -1;
    bool profile_created = false;
    bcmint_mirror_ingress_mod_event_profile_cfg_t *profile_temp = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);
    SHR_NULL_CHECK(profile_id, SHR_E_PARAM);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    /* Allocate an event profile buffer. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_profile_alloc(unit, &profile_temp));

    /* Allocate an event profile id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_profile_id_alloc(unit, &profile_id_temp));
    profile_temp->profile_id = profile_id_temp;

    /* Add the profile to profile pool. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_profile_add(unit, profile, profile_temp));
    profile_created = true;

    *profile_id = profile_id_temp;

exit:
    if (SHR_FUNC_ERR() && (profile_created == true)) {
        (void)mirror_ingress_mod_event_profile_delete(unit, *profile_id);
    }
    if (profile_temp != NULL) {
        mirror_ingress_mod_event_profile_free(&profile_temp);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_profile_destroy(
    int unit,
    int profile_id)
{
    bcmint_mirror_ingress_mod_event_profile_cfg_t profile;

    SHR_FUNC_ENTER(unit);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_profile_get(unit, profile_id, &profile));

    /* Delete the profile LT entry if group has been add. */
    if (profile.group_mask_bmp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ing_event_profile_table_delete(unit, &profile));
    }

    /* Delete the profile from SW bookkeeping. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_profile_delete(unit, profile_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_profile_get_all(
    int unit,
    int *profile_id_array,
    int *count)
{
    int i, index = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(count, SHR_E_PARAM);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    if (profile_id_array == NULL) {
        *count = 0;
        for (i = BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE;
             i < MIRROR_ING_MOD_EVENT_PROF_NUM(unit) +
                 BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE; i++) {
            if (ING_MOD_EVENT_PROF_BMP_USED_GET(unit, i)) {
                *count = *count + 1;
            }
        }
    } else {
        for (i = BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE;
             i < MIRROR_ING_MOD_EVENT_PROF_NUM(unit) +
                 BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE; i++) {
            if (ING_MOD_EVENT_PROF_BMP_USED_GET(unit, i)) {
                if (index < *count) {
                    profile_id_array[index] = i;
                    index++;
                }
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_profile_cfg_get(
    int unit,
    int profile_id,
    bcm_mirror_ingress_mod_event_profile_t *profile)
{
    bcmint_mirror_ingress_mod_event_profile_cfg_t profile_temp;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_profile_get(unit, profile_id, &profile_temp));

    profile->reason_code = profile_temp.reason_code;
    profile->sample_rate = profile_temp.sample_rate;
    profile->priority    = profile_temp.priority;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_profile_group_add(
    int unit,
    int profile_id,
    bcm_mirror_ingress_mod_event_group_t group,
    int hit)
{
    int i;
    SHR_BITDCL group_bmp_new = 0, mask_bmp_new = 0;
    SHR_BITDCL *group_bmp_temp = NULL, *mask_bmp_temp = NULL;
    bcmint_mirror_ingress_mod_event_profile_cfg_t profile;

    SHR_FUNC_ENTER(unit);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_profile_get(unit, profile_id, &profile));

    /* Check if the group has been added. */
    if (SHR_BITGET(&profile.group_mask_bmp, group)) {
        SHR_ERR_EXIT(SHR_E_EXISTS);
    }

    group_bmp_new = profile.group_bmp;
    mask_bmp_new = profile.group_mask_bmp;

    /* Update profile's group and mask bitmap. */
    if (hit) {
        SHR_BITSET(&group_bmp_new, group);
    } else {
        SHR_BITCLR(&group_bmp_new, group);
    }
    SHR_BITSET(&mask_bmp_new, group);

    /* Check if there is already a profile with same group and mask bitmap. */
    for (i = BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE;
         i < MIRROR_ING_MOD_EVENT_PROF_NUM(unit) +
             BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE; i++) {
        if (i == profile_id || ING_MOD_EVENT_PROF_BMP_USED_GET(unit, i) == 0) {
            continue;
        }
        group_bmp_temp = &(MIRROR_ING_MOD_EVENT_PROF(unit, i).group_bmp);
        mask_bmp_temp = &(MIRROR_ING_MOD_EVENT_PROF(unit, i).group_mask_bmp);

        if ((group_bmp_new == *group_bmp_temp) &&
            (mask_bmp_new == *mask_bmp_temp)) {
            SHR_ERR_EXIT(SHR_E_EXISTS);
        }
    }

    /* Udate profile table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ing_event_profile_table_update(unit,
                                               &profile,
                                               group_bmp_new,
                                               mask_bmp_new));

    /* Update group reference count. */
    mirror_ingress_mod_event_group_refer(unit, group, 1);

    /* Update bitmap. */
    MIRROR_ING_MOD_EVENT_PROF(unit, profile_id).group_bmp = group_bmp_new;
    MIRROR_ING_MOD_EVENT_PROF(unit, profile_id).group_mask_bmp = mask_bmp_new;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_profile_group_delete(
    int unit,
    int profile_id,
    bcm_mirror_ingress_mod_event_group_t group)
{
    int i;
    SHR_BITDCL group_bmp_new = 0, mask_bmp_new = 0;
    SHR_BITDCL *group_bmp_temp = NULL, *mask_bmp_temp = NULL;
    bcmint_mirror_ingress_mod_event_profile_cfg_t profile;

    SHR_FUNC_ENTER(unit);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_profile_get(unit, profile_id, &profile));

    /* Check if the group has been added. */
    if (!SHR_BITGET(&profile.group_mask_bmp, group)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    group_bmp_new = profile.group_bmp;
    mask_bmp_new = profile.group_mask_bmp;

    /* Update profile's group and mask bitmap. */
    SHR_BITCLR(&group_bmp_new, group);
    SHR_BITCLR(&mask_bmp_new, group);

    /* Delete profile table if no group remains. */
    if (mask_bmp_new == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ing_event_profile_table_delete(unit, &profile));
    } else {
        /* Check if there is already a profile with same group and mask bitmap. */
        for (i = BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE;
             i < MIRROR_ING_MOD_EVENT_PROF_NUM(unit) +
                 BCMINT_MIRROR_ING_MOD_EVENT_PROF_ID_BASE; i++) {
            if (i == profile_id || ING_MOD_EVENT_PROF_BMP_USED_GET(unit, i) == 0) {
                continue;
            }
            group_bmp_temp = &(MIRROR_ING_MOD_EVENT_PROF(unit, i).group_bmp);
            mask_bmp_temp = &(MIRROR_ING_MOD_EVENT_PROF(unit, i).group_mask_bmp);

            if ((group_bmp_new == *group_bmp_temp) &&
                (mask_bmp_new == *mask_bmp_temp)) {
                SHR_ERR_EXIT(SHR_E_EXISTS);
            }
        }

        /* Update profile table. */
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_ing_event_profile_table_update(unit,
                                                   &profile,
                                                   group_bmp_new,
                                                   mask_bmp_new));

    }

    /* Update group reference count. */
    mirror_ingress_mod_event_group_derefer(unit, group, 1);

    /* Update bitmap. */
    MIRROR_ING_MOD_EVENT_PROF(unit, profile_id).group_bmp = group_bmp_new;
    MIRROR_ING_MOD_EVENT_PROF(unit, profile_id).group_mask_bmp = mask_bmp_new;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_profile_group_get_all(
    int unit,
    int profile_id,
    bcm_mirror_ingress_mod_event_group_t *group_array,
    int *count)
{
    int i, index = 0;
    SHR_BITDCL *mask_bmp_temp = NULL;
    bcmint_mirror_ingress_mod_event_profile_cfg_t profile;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(count, SHR_E_PARAM);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_profile_get(unit, profile_id, &profile));

    mask_bmp_temp = &(profile.group_mask_bmp);

    if (group_array == NULL) {
        *count = 0;
        for (i = BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE;
             i < MIRROR_ING_MOD_EVENT_GRP_NUM(unit) +
                 BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE; i++) {
            if (SHR_BITGET(mask_bmp_temp, i)) {
                *count = *count + 1;
            }
        }
    } else {
        for (i = BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE;
             i < MIRROR_ING_MOD_EVENT_GRP_NUM(unit) +
                 BCMINT_MIRROR_ING_MOD_EVENT_GRP_ID_BASE; i++) {
            if (SHR_BITGET(mask_bmp_temp, i)) {
                if (index < *count) {
                    group_array[index] = i;
                    index++;
                }
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_ingress_mod_event_profile_group_get(
    int unit,
    int profile_id,
    bcm_mirror_ingress_mod_event_group_t group,
    int *hit)
{
    SHR_BITDCL *group_bmp_temp = NULL, *mask_bmp_temp = NULL;
    bcmint_mirror_ingress_mod_event_profile_cfg_t profile;

    SHR_FUNC_ENTER(unit);

    MIRROR_ING_MOD_CTRL_INIT_CHECK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_ingress_mod_event_profile_get(unit, profile_id, &profile));

    group_bmp_temp = &(profile.group_bmp);
    mask_bmp_temp = &(profile.group_mask_bmp);

    if (!SHR_BITGET(mask_bmp_temp, group)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    *hit = SHR_BITGET(group_bmp_temp, group) ? 1 : 0;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_multi_dip_group_ipv4_create(
    int unit,
    bcm_mirror_multi_dip_entry_num_t num_entries,
    bcm_ip_t *ipv4_addr_array,
    bcm_mirror_multi_dip_group_t *group)
{
    uint32_t req_size = 0;
    int rv, offset, group_id = 0, ipv4_index = 0;
    bool group_created = false;
    mirror_multi_dip_alloc_t *allocator = NULL, *allocator_ipv6 = NULL;
    bcmint_mirror_multi_dip_group_cfg_t *dip_group = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ipv4_addr_array, SHR_E_PARAM);
    SHR_NULL_CHECK(group, SHR_E_PARAM);

    MIRROR_MULTI_DIP_CTRL_INIT_CHECK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_entry_num_to_size(unit, num_entries, &req_size));

    /* First try to allocate at entry left side. */
    ipv4_index = 0;
    allocator = &MIRROR_MULTI_DIP_IPV4_IDX0_ALLOC(unit);
    rv = mirror_multi_dip_allocator_alloc(unit, allocator, req_size, &offset);

    /* If left side is full, try to allocate at right side. */
    if (rv == SHR_E_RESOURCE) {
        ipv4_index = 1;
        allocator = &MIRROR_MULTI_DIP_IPV4_IDX1_ALLOC(unit);
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_multi_dip_allocator_alloc(unit,
                                              allocator,
                                              req_size,
                                              &offset));
        rv = SHR_E_NONE;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    /*
     * Since the entry is shared between IPv4 and IPv6, update IPv6 allocator.
     * If the allocation is for ipv4_index 1, means there is no room for IPv6,
     * so do not update IPv6 allocator in this case.
     */
    if (ipv4_index == 0) {
        allocator_ipv6 = &MIRROR_MULTI_DIP_IPV6_ALLOC(unit);
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_multi_dip_allocator_copy_at_offset(unit,
                                                       allocator,
                                                       allocator_ipv6,
                                                       offset));
    }

    /* Allocate a multi dip group buffer. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_alloc(unit, &dip_group));

    /* Allocate a multi dip group id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_id_alloc(unit, &group_id));

    dip_group->group_id = group_id;
    dip_group->group_size = req_size;
    dip_group->ipv6 = false;
    dip_group->offset = offset;
    dip_group->ipv4_index = ipv4_index;

    /* Add the group to group pool. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_add(unit, dip_group));
    group_created = true;

    /* Add IP addresses to table entries. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_ipv4_table_add(unit,
                                         ipv4_addr_array,
                                         req_size,
                                         offset,
                                         ipv4_index));

    *group = (bcm_mirror_multi_dip_group_t) group_id;

exit:
    if (SHR_FUNC_ERR() && (group_created == true)) {
        (void)mirror_multi_dip_group_delete(unit, group_id);
    }
    if (dip_group != NULL) {
        mirror_multi_dip_group_free(&dip_group);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_multi_dip_group_ipv4_destroy(
    int unit,
    bcm_mirror_multi_dip_group_t group)
{
    mirror_multi_dip_alloc_t *allocator = NULL, *allocator_ipv6 = NULL;
    bcmint_mirror_multi_dip_group_cfg_t dip_group;

    SHR_FUNC_ENTER(unit);

    MIRROR_MULTI_DIP_CTRL_INIT_CHECK(unit);

    /* Get the group node. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_get(unit, group, &dip_group));

    /* Check if the group is for IPv4. */
    if (dip_group.ipv6) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (dip_group.ipv4_index == 0) {
        allocator = &MIRROR_MULTI_DIP_IPV4_IDX0_ALLOC(unit);
    } else {
        allocator = &MIRROR_MULTI_DIP_IPV4_IDX1_ALLOC(unit);
    }

    /* Delete the group. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_ipv4_table_delete(unit,
                                             dip_group.group_size,
                                             dip_group.offset,
                                             dip_group.ipv4_index));

    /* Free the block from allocator. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_allocator_free(unit, allocator, dip_group.offset));
    /*
     * Since the entry is shared between IPv4 and IPv6, update IPv6 allocator.
     * And only updated it if the allocation is for ipv4_index 0, this is
     * to be consistence with mirror_multi_dip_group_ipv4_create.
     */
    if (dip_group.ipv4_index == 0) {
        allocator_ipv6 = &MIRROR_MULTI_DIP_IPV6_ALLOC(unit);
        SHR_IF_ERR_VERBOSE_EXIT
            (mirror_multi_dip_allocator_free(unit, allocator_ipv6, dip_group.offset));
    }

    /* Delete the group from group pool. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_delete(unit, group));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_multi_dip_group_ipv4_get_all(
    int unit,
    bcm_mirror_multi_dip_group_t *ipv4_group_array,
    int *count)
{
    int i, rv = 0, index = 0;
    bcmint_mirror_multi_dip_group_cfg_t dip_group;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(count, SHR_E_PARAM);

    MIRROR_MULTI_DIP_CTRL_INIT_CHECK(unit);

    if (ipv4_group_array == NULL) {
        *count = 0;
        for (i = BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE;
             i < MIRROR_MULTI_DIP_GRP_NUM(unit) +
                 BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE; i++) {
            rv = mirror_multi_dip_group_get(unit, i, &dip_group);
            if (rv == SHR_E_NOT_FOUND || dip_group.ipv6) {
                continue;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            *count = *count + 1;
        }
    } else {
        for (i = BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE;
             i < MIRROR_MULTI_DIP_GRP_NUM(unit) +
                 BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE; i++) {
            rv = mirror_multi_dip_group_get(unit, i, &dip_group);
            if (rv == SHR_E_NOT_FOUND || dip_group.ipv6) {
                continue;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            if (index < *count) {
                ipv4_group_array[index] = (bcm_mirror_multi_dip_group_t)
                                      dip_group.group_id;
                index++;
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_multi_dip_group_ipv4_get(
    int unit,
    bcm_mirror_multi_dip_group_t group,
    bcm_ip_t *ipv4_addr_array,
    int *count)
{
    bcmint_mirror_multi_dip_group_cfg_t dip_group;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(count, SHR_E_PARAM);

    MIRROR_MULTI_DIP_CTRL_INIT_CHECK(unit);

    /* Get the group node. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_get(unit, group, &dip_group));

    /* Check if the group is for IPv4. */
    if (dip_group.ipv6) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (ipv4_addr_array == NULL) {
        *count = (int) dip_group.group_size;
        SHR_EXIT();
    } else {
        /* In case the reuired count is smaller than group_szie. */
        if (dip_group.group_size > (uint32_t)(*count)) {
            dip_group.group_size = (uint32_t)(*count);
        }
    }

    /* Get addresses. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_ipv4_table_get(unit,
                                         dip_group.offset,
                                         dip_group.ipv4_index,
                                         dip_group.group_size,
                                         ipv4_addr_array));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_multi_dip_group_ipv6_create(
    int unit,
    bcm_mirror_multi_dip_entry_num_t num_entries,
    bcm_ip6_t *ipv6_addr_array,
    bcm_mirror_multi_dip_group_t *group)
{
    uint32_t req_size = 0, array_size = 0;
    int offset, group_id = 0;
    bool group_created = false;
    mirror_multi_dip_alloc_t *allocator = NULL, *allocator_ipv6 = NULL;
    bcmint_mirror_multi_dip_group_cfg_t *dip_group = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ipv6_addr_array, SHR_E_PARAM);
    SHR_NULL_CHECK(group, SHR_E_PARAM);

    MIRROR_MULTI_DIP_CTRL_INIT_CHECK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_entry_num_to_size(unit, num_entries, &req_size));

    /* An IPv6 address will occupy two table entries. */
    array_size = req_size;
    req_size *= 2;

    /* Allocate IPv6 entry. */
    allocator_ipv6 = &MIRROR_MULTI_DIP_IPV6_ALLOC(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_allocator_alloc(unit,
                                          allocator_ipv6,
                                          req_size,
                                          &offset));


    /*
     * Since the entry is shared between IPv4 and IPv6,
     * also update allocation for ipv4 allocators.
     */
    allocator = &MIRROR_MULTI_DIP_IPV4_IDX0_ALLOC(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_allocator_copy_at_offset(unit,
                                                   allocator_ipv6,
                                                   allocator,
                                                   offset));

    allocator = &MIRROR_MULTI_DIP_IPV4_IDX1_ALLOC(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_allocator_copy_at_offset(unit,
                                                   allocator_ipv6,
                                                   allocator,
                                                   offset));


    /* Allocate a multi dip group buffer. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_alloc(unit, &dip_group));

    /* Allocate a multi dip group id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_id_alloc(unit, &group_id));

    dip_group->group_id = group_id;
    dip_group->group_size = req_size;
    dip_group->ipv6 = true;
    dip_group->offset = offset;
    dip_group->ipv4_index = -1;

    /* Add the group to group pool. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_add(unit, dip_group));
    group_created = true;

    /* Add IP addresses to table entries. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_ipv6_table_add(unit,
                                         ipv6_addr_array,
                                         array_size,
                                         offset));

    *group = (bcm_mirror_multi_dip_group_t) group_id;

exit:
    if (SHR_FUNC_ERR() && (group_created == true)) {
        (void)mirror_multi_dip_group_delete(unit, group_id);
    }
    if (dip_group != NULL) {
        mirror_multi_dip_group_free(&dip_group);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_multi_dip_group_ipv6_destroy(
    int unit,
    bcm_mirror_multi_dip_group_t group)
{
    mirror_multi_dip_alloc_t *allocator = NULL, *allocator_ipv6 = NULL;
    bcmint_mirror_multi_dip_group_cfg_t dip_group;

    SHR_FUNC_ENTER(unit);

    MIRROR_MULTI_DIP_CTRL_INIT_CHECK(unit);

    /* Get the group node. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_get(unit, group, &dip_group));

    /* Check if the group is for IPv6. */
    if (!dip_group.ipv6) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Get IPv6 allocator. */
    allocator_ipv6 = &MIRROR_MULTI_DIP_IPV6_ALLOC(unit);

    /* Delete the group. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_ipv6_table_delete(unit,
                                            dip_group.group_size,
                                            dip_group.offset));

    /* Free the block from allocator. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_allocator_free(unit, allocator_ipv6, dip_group.offset));

    /*
     * Since the entry is shared between IPv4 and IPv6,
     * also update allocation for ipv4 allocators.
     */
    allocator = &MIRROR_MULTI_DIP_IPV4_IDX0_ALLOC(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_allocator_free(unit, allocator, dip_group.offset));

    allocator = &MIRROR_MULTI_DIP_IPV4_IDX1_ALLOC(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_allocator_free(unit, allocator, dip_group.offset));

    /* Delete the group from group pool. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_delete(unit, group));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_multi_dip_group_ipv6_get_all(
    int unit,
    bcm_mirror_multi_dip_group_t *ipv6_group_array,
    int *count)
{
    int i, rv = 0, index = 0;
    bcmint_mirror_multi_dip_group_cfg_t dip_group;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(count, SHR_E_PARAM);

    MIRROR_MULTI_DIP_CTRL_INIT_CHECK(unit);

    if (ipv6_group_array == NULL) {
        *count = 0;
        for (i = BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE;
             i < MIRROR_MULTI_DIP_GRP_NUM(unit) +
                 BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE; i++) {
            rv = mirror_multi_dip_group_get(unit, i, &dip_group);
            if (rv == SHR_E_NOT_FOUND || !dip_group.ipv6) {
                continue;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            *count = *count + 1;
        }
    } else {
        for (i = BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE;
             i < MIRROR_MULTI_DIP_GRP_NUM(unit) +
                 BCMINT_MIRROR_MULTI_DIP_GRP_ID_BASE; i++) {
            rv = mirror_multi_dip_group_get(unit, i, &dip_group);
            if (rv == SHR_E_NOT_FOUND || !dip_group.ipv6) {
                continue;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            if (index < *count) {
                ipv6_group_array[index] = (bcm_mirror_multi_dip_group_t)
                                           dip_group.group_id;
                index++;
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_multi_dip_group_ipv6_get(
    int unit,
    bcm_mirror_multi_dip_group_t group,
    bcm_ip6_t *ipv6_addr_array,
    int *count)
{
    uint32_t ipv6_addr_num = 0;
    bcmint_mirror_multi_dip_group_cfg_t dip_group;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(count, SHR_E_PARAM);

    MIRROR_MULTI_DIP_CTRL_INIT_CHECK(unit);

    /* Get the group node. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_group_get(unit, group, &dip_group));

    /* Check if the group is for IPv6. */
    if (!dip_group.ipv6) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* An IPv6 address occupies two table entries. */
    ipv6_addr_num = dip_group.group_size / 2;

    if (ipv6_addr_array == NULL) {
        *count = (int) ipv6_addr_num;
        SHR_EXIT();
    } else {
        /* In case the reuired count is smaller than group_szie. */
        if (ipv6_addr_num > (uint32_t)(*count)) {
            ipv6_addr_num = (uint32_t)(*count);
        }
    }

    /* Get addresses. */
    SHR_IF_ERR_VERBOSE_EXIT
        (mirror_multi_dip_ipv6_table_get(unit,
                                         dip_group.offset,
                                         ipv6_addr_num,
                                         ipv6_addr_array));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mirror_multi_dip_dump(int unit)
{
    if (MIRROR_MULTI_DIP_CTRL(unit)->inited == true) {
        mirror_multi_dip_dump(unit);
    }
    return SHR_E_NONE;
}

