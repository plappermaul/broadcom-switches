/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/multicast.h>
#include <bcm_int/control.h>
#include <bcm_int/ltsw_dispatch.h>

#include <bcm_int/ltsw/xgs/multicast.h>
#include <bcm_int/ltsw/multicast.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/index_table_mgmt.h>
#include <bcm_int/ltsw/l3_egress.h>
#include <bcm_int/ltsw/l3_intf.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/vlan.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_MULTICAST

/******************************************************************************
 * Private functions
 */


#define XGS_MC_AGG_ID_HW_INVALID                          0xff

/* Default L2 multicast group ID for default VLAN. */
#define XGS_MC_DEF_VLAN_GRP_ID                         0
/*
 * Multicast replication head REPL_HEAD free blocks.
 */
typedef struct xgs_mc_repl_head_free_block_s {

    /* Starting index of a free block of REPL_HEAD table entries. */
    int index;

    /* Number of entries in the free block. */
    int size;

    /* Pointer to next free block. */
    struct xgs_mc_repl_head_free_block_s *next;

} xgs_mc_repl_head_free_block_t;

/*
 * Multicast replication head info structure.
 */
typedef struct xgs_mc_repl_head_info_s {

    /* Array of lists of free blocks. */
    xgs_mc_repl_head_free_block_t **free_list_array;

    /* Number of lists in the array. */
    int array_size;

} xgs_mc_repl_head_info_t;


typedef struct xgs_mc_info_s {
    /* L3 multicast replication head table size. */
    uint32_t                 repl_head_sz;

    /* L3 multicast replication head info. */
    xgs_mc_repl_head_info_t  repl_head_info;

    /* Minimum vaule of L3 mc remap index. */
    uint32_t                 remap_idx_min;

    /* Maximum vaule of L3 mc remap index. */
    uint32_t                 remap_idx_max;

} xgs_mc_info_t;


/* Static global variable of multicast info. */
static xgs_mc_info_t xgs_mc_info[BCM_MAX_NUM_UNITS] = {{ 0 }};

/* Multicast information. */
#define MC_INFO(u)                 (&xgs_mc_info[u])

/* IPMC replication head info. */
#define REPL_HEAD_SIZE(u)          (MC_INFO(u)->repl_head_sz)
#define REPL_HEAD(u)               (&(MC_INFO(u)->repl_head_info))
#define REPL_HEAD_FREE_LIST(u, idx) \
    (MC_INFO(u)->repl_head_info.free_list_array[idx])

/******************************************************************************
 * Private functions
 */

/*!
 * \brief Get a L2 multicast group.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  l2mc_id        L2 multicast group id.
 * \param [in]  port_size      Maxium mumber of GPORTS in this group.
 * \param [out] port_array     Returned egress ports of this group.
 * \param [out] encap_id_array Returned list of encap_id.
 * \param [out] port_count     Count of returned ports.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l2_grp_get(
    int unit,
    int l2mc_id,
    int port_size,
    bcm_gport_t *gport_array,
    bcm_if_t *encap_id_array,
    int *port_count)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t *port_id_arr = NULL;
    int       max_ports, idx;
    uint32_t  r_cnt, cnt;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_MC_GROUPs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_MC_GROUP_IDs, l2mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    port_id_arr = sal_alloc(sizeof(uint64_t) * max_ports, "xgsMcPortIdArr");
    SHR_NULL_CHECK(port_id_arr, SHR_E_MEMORY);
    sal_memset(port_id_arr, 0, sizeof(uint64_t) * max_ports);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_get(eh, PORT_IDs, 0,
                                     port_id_arr, max_ports, &r_cnt));

    cnt = 0;
    for (idx = 0; idx < r_cnt; idx++) {
        /*
         * When port_size is > 0, only port_size ports are returned.
         * When port_size is 0, then just return the actual port_count.
         */
        if ((port_size > 0) && (cnt >= port_size)) {
            break;
        }

        /* Port is the member of this L2 multicast group. */
        if (port_id_arr[idx] == 1) {
            if (gport_array != NULL) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_port_gport_get(unit, idx, (gport_array + cnt)));
            }
            if (encap_id_array != NULL) {
                encap_id_array[cnt] = BCM_IF_INVALID;
            }
            cnt++;
        }
    }
    *port_count = cnt;

exit:
    SHR_FREE(port_id_arr);

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Free a block of REPL_HEAD table entries.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  index         Index of the first entry of the block.
 * \param [in]  size          Size of the block.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
mc_repl_head_block_free(
    int unit,
    int index,
    int size)
{
    int i;
    int block_index, block_size;
    int coalesced_index, coalesced_size;
    xgs_mc_repl_head_free_block_t *block_ptr;
    xgs_mc_repl_head_free_block_t *prev_block_ptr;
    xgs_mc_repl_head_free_block_t *next_block_ptr;
    xgs_mc_repl_head_free_block_t *coalesced_block_ptr;

    SHR_FUNC_ENTER(unit);

    if (size <= 0) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    /*
     * First, coalesce the block with any existing free blocks
     * that are contiguous with the block.
     */
    coalesced_index = index;
    coalesced_size = size;
    for (i = 0; i < REPL_HEAD(unit)->array_size; i++) {
        block_ptr = REPL_HEAD_FREE_LIST(unit, i);
        prev_block_ptr = NULL;
        while (NULL != block_ptr) {
            block_index = block_ptr->index;
            block_size = block_ptr->size;
            next_block_ptr = block_ptr->next;
            if ((block_index + block_size) == coalesced_index) {
                coalesced_index = block_index;
                coalesced_size += block_size;
                if (block_ptr == REPL_HEAD_FREE_LIST(unit, i)) {
                    REPL_HEAD_FREE_LIST(unit, i) = next_block_ptr;
                } else {
                    /*
                     * In the following line of code, Coverity thinks the
                     * prev_block_ptr may still be NULL when dereferenced.
                     * This situation will never occur because
                     * if block_ptr is not pointing to the head of the
                     * linked list, prev_block_ptr would not be NULL.
                     */
                    /* coverity[var_deref_op : FALSE] */
                    prev_block_ptr->next = next_block_ptr;
                }
                SHR_FREE(block_ptr);
            } else if ((coalesced_index + coalesced_size) == block_index) {
                coalesced_size += block_size;
                if (block_ptr == REPL_HEAD_FREE_LIST(unit, i)) {
                    REPL_HEAD_FREE_LIST(unit, i) = next_block_ptr;
                } else {
                    /*
                     * In the following line of code, Coverity thinks the
                     * prev_block_ptr may still be NULL when dereferenced.
                     * This situation will never occur because
                     * if block_ptr is not pointing to the head of the
                     * linked list, prev_block_ptr would not be NULL.
                     */
                    /* coverity[var_deref_op : FALSE] */
                    prev_block_ptr->next = next_block_ptr;
                }
                SHR_FREE(block_ptr);
            } else {
                prev_block_ptr = block_ptr;
            }
            block_ptr = next_block_ptr;
        }
    }

    /* Insert coalesced free block. */
    coalesced_block_ptr = sal_alloc(sizeof(xgs_mc_repl_head_free_block_t),
                                    "xgsMcCoalescedReplHeadFreeBlock");
    SHR_NULL_CHECK(coalesced_block_ptr, SHR_E_MEMORY);
    coalesced_block_ptr->index = coalesced_index;
    coalesced_block_ptr->size = coalesced_size;
    if (coalesced_size > (REPL_HEAD(unit)->array_size - 1)) {
        /* Insert into free list 0. */
        coalesced_block_ptr->next = REPL_HEAD_FREE_LIST(unit, 0);
        REPL_HEAD_FREE_LIST(unit, 0) = coalesced_block_ptr;
    } else {
        coalesced_block_ptr->next = REPL_HEAD_FREE_LIST(unit, coalesced_size);
        REPL_HEAD_FREE_LIST(unit, coalesced_size) = coalesced_block_ptr;
    }

    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Allocate a free block of REPL_HEAD table entries..
 *
 * \param [in]  unit          Unit number.
 * \param [in]  size          Size of free block requested.
 * \param [out] index         Index of the first entry of the free block.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
mc_repl_head_block_alloc(
    int unit,
    int size,
    int *index)
{
    int max_array_index;
    int i;
    int block_index, block_size;
    xgs_mc_repl_head_free_block_t *next_block_ptr;

    SHR_FUNC_ENTER(unit);

    if (size == 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (NULL == index) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    max_array_index = REPL_HEAD(unit)->array_size - 1;
    for (i = size; i <= max_array_index; i++) {
        if (NULL != REPL_HEAD_FREE_LIST(unit, i)) {
           block_index = REPL_HEAD_FREE_LIST(unit, i)->index;
           block_size = REPL_HEAD_FREE_LIST(unit, i)->size;
           next_block_ptr = REPL_HEAD_FREE_LIST(unit, i)->next;
           SHR_FREE(REPL_HEAD_FREE_LIST(unit, i));
           REPL_HEAD_FREE_LIST(unit, i) = next_block_ptr;

           /*
            *If the obtained free block contains more entries
            * than requested, insert the remainder back into
            * the free list array.
            */
           if (block_size > size) {
               SHR_IF_ERR_VERBOSE_EXIT
                   (mc_repl_head_block_free(unit,
                                            block_index + size,
                                            block_size - size));
           }

           *index = block_index;
           SHR_EXIT();
        }
    }

    /* Get free block from free list 0. */
    if (NULL != REPL_HEAD_FREE_LIST(unit, 0)) {
        block_index = REPL_HEAD_FREE_LIST(unit, 0)->index;
        block_size = REPL_HEAD_FREE_LIST(unit, 0)->size;
        next_block_ptr = REPL_HEAD_FREE_LIST(unit, 0)->next;
        if (block_size < size) {
            /*
             * Free blocks on list 0 should never be
             * smaller than requested size.
             */
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }

        SHR_FREE(REPL_HEAD_FREE_LIST(unit, 0));
        REPL_HEAD_FREE_LIST(unit, 0) = next_block_ptr;

        /*
         * If the obtained free block contains more entries
         * than requested, insert the remainder back into
         * the free list array.
         */
        if (block_size > size) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_repl_head_block_free(unit,
                                         block_index + size,
                                         block_size - size));
        }

        *index = block_index;
        SHR_EXIT();
    }

    /* No free block of sufficient size can be found */
    SHR_ERR_EXIT(SHR_E_RESOURCE);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-initialize replication head info.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static void
mc_repl_head_info_deinit(int unit)
{
    int i;
    xgs_mc_repl_head_free_block_t *block_ptr;
    xgs_mc_repl_head_free_block_t *next_block_ptr;

    if (NULL != REPL_HEAD(unit)) {
        if (NULL != REPL_HEAD(unit)->free_list_array) {
            for (i = 0; i < REPL_HEAD(unit)->array_size; i++) {
                block_ptr = REPL_HEAD_FREE_LIST(unit, i);
                while (NULL != block_ptr) {
                    next_block_ptr = block_ptr->next;
                    SHR_FREE(block_ptr);
                    block_ptr = next_block_ptr;
                }
                REPL_HEAD_FREE_LIST(unit, i) = NULL;
            }
            SHR_FREE(REPL_HEAD(unit)->free_list_array);
            REPL_HEAD(unit)->free_list_array = NULL;
            REPL_HEAD(unit)->array_size = 0;
        }
    }

    return;
}

/*!
 * \brief Initialize replication head info.
 *
 * \param [in]  unit          Unit number.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
mc_repl_head_info_init(int unit)
{
    int alloc_size;
    int max_array_index = 0;
    uint64_t agg_list_id_min = 0, agg_list_id_max = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TM_MC_PORT_AGG_LISTs,
                                       TM_MC_PORT_AGG_LIST_IDs,
                                       &agg_list_id_min, &agg_list_id_max));

    REPL_HEAD_SIZE(unit) = agg_list_id_max - agg_list_id_min + 1;
    sal_memset(REPL_HEAD(unit), 0, sizeof(xgs_mc_repl_head_info_t));

    /*
     * Each element of the array is a linked list of free blocks.
     * Array element N is a linked list of free blocks of size N.
     * When allocating a block of REPL_HEAD table entries, the max
     * number of entries needed is equal to the max number of members
     * in a replication group. This will also be the max index of the
     * array. Of course, the REPL_HEAD table may contain bigger blocks
     * of free entries. Array element 0 wil be a linked list of free
     * blocks with size greater than the max number of members in a
     * replication group.
     */
    max_array_index = bcmi_ltsw_dev_logic_port_num(unit);
    alloc_size = (max_array_index + 1) *
                  sizeof(xgs_mc_repl_head_free_block_t *);
    REPL_HEAD(unit)->free_list_array =
        sal_alloc(alloc_size, "xgsMcReplHeadFreeListArr");
    SHR_NULL_CHECK(REPL_HEAD(unit)->free_list_array, SHR_E_MEMORY);
    sal_memset(REPL_HEAD(unit)->free_list_array, 0, alloc_size);
    REPL_HEAD(unit)->array_size = max_array_index + 1;

    REPL_HEAD_FREE_LIST(unit, 0) =
        sal_alloc(sizeof(xgs_mc_repl_head_free_block_t),
                  "xgsMcReplHeadFreeBlock");
    SHR_NULL_CHECK(REPL_HEAD_FREE_LIST(unit, 0), SHR_E_MEMORY);

    /*
     * Initially, there is only one free block, starting at entry 1 of
     * REPL_HEAD table and ending at the last entry.
     * Entry 0 is reserved.
     */
    REPL_HEAD_FREE_LIST(unit, 0)->index = agg_list_id_min;
    REPL_HEAD_FREE_LIST(unit, 0)->size = REPL_HEAD_SIZE(unit);
    REPL_HEAD_FREE_LIST(unit, 0)->next = NULL;

    

exit:
    if (SHR_FUNC_ERR()) {
        mc_repl_head_info_deinit(unit);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get info for a L3 multicast group.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  l3mc_id        L3 multicast group id.
 * \param [out] repl_head_base Replication head base ptr for this group.
 * \param [out] repl_head_cnt  Count of repl_head entries.
 * \param [out] l2_mem_arr     Returned L2 bitmap member.
 * \param [out] l3_mem_arr     Returned L3 bitmap member.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_info_get(
    int unit,
    int l3mc_id,
    int *repl_head_base,
    int *repl_head_cnt,
    int *l2_mem_arr,
    int *l3_mem_arr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int       dunit = 0;
    uint64_t  value = 0;
    int       max_ports, idx;
    uint32_t  r_cnt;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_GROUPs, &eh));

    /* Add L3 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, l3mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, TM_MC_PORT_AGG_LIST_IDs, &value));
    *repl_head_base = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, NUM_PORT_LIST_ENTRIESs, &value));
    *repl_head_cnt = value;

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    if (l2_mem_arr != NULL) {
        for (idx = 0; idx < max_ports; idx++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(eh, L2_PORTs,
                                             idx, &value, 1, &r_cnt));
            l2_mem_arr[idx] = value;
        }
    }

    if (l3_mem_arr != NULL) {
        for (idx = 0; idx < max_ports; idx++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(eh, L3_PORTs,
                                             idx, &value, 1, &r_cnt));
            l3_mem_arr[idx] = value;
        }
    }

exit:

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Set info for a L3 multicast group.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  l3mc_id        L3 multicast group id.
 * \param [in]  repl_head_base Replication head base ptr for this group.
 * \param [in]  repl_head_cnt  Count of repl_head entries.
 * \param [in]  l2_mem_arr     L2 bitmap member.
 * \param [in]  l3_mem_arr     L3 bitmap member.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_info_set(
    int unit,
    int l3mc_id,
    int repl_head_base,
    int repl_head_cnt,
    int *l2_mem_arr,
    int *l3_mem_arr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int      dunit = 0;
    uint64_t value = 0;
    int      max_ports, idx;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_GROUPs, &eh));

    /* Add L3 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, l3mc_id));

    value = repl_head_base;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_PORT_AGG_LIST_IDs, value));

    value = repl_head_cnt;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, NUM_PORT_LIST_ENTRIESs, value));

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    for (idx = 0; idx < max_ports; idx++) {
        value = l2_mem_arr[idx];
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(eh, L2_PORTs, idx, &value, 1));
    }
    for (idx = 0; idx < max_ports; idx++) {
        value = l3_mem_arr[idx];
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(eh, L3_PORTs, idx, &value, 1));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Add/Remove a port to/from L2 bitmap of a L3 multicast group.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  l3mc_id        L3 multicast group id.
 * \param [in]  port           Logical port id.
 * \param [in]  set            1 means add, 0 means remove.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_port_l2_set(
    int unit,
    int l3mc_id,
    bcm_port_t port,
    int set)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int      dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_GROUPs, &eh));

    /* Add L3 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, l3mc_id));

    value = set;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(eh, L2_PORTs, port, &value, 1));


    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));
exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set encap_id array to SDKLT(HW).
 *
 * \param [in]  unit            Unit Number.
 * \param [in]  pal_id          Port aggregate encap list ID.
 * \param [in]  agg_id          Port aggregate ID.
 * \param [in]  encap_id_arr    Encap id array.
 * \param [in]  encap_id_cnt    Count of encap id.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_encap_set(
    int unit,
    int pal_id,
    int agg_id,
    int *encap_id_arr,
    uint32_t encap_id_cnt)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t value = 0;
    int idx;

    SHR_FUNC_ENTER(unit);

    if ((encap_id_cnt > 0) && (encap_id_arr == NULL)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_PORT_AGG_LISTs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_PORT_AGG_LIST_IDs, pal_id));

    if (encap_id_cnt > 0) {

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, TM_MC_PORT_AGG_IDs, agg_id));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, NUM_AGG_LIST_MEMBERs, encap_id_cnt));

        for (idx = 0; idx < encap_id_cnt; idx++) {
            value = encap_id_arr[idx];
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(eh, AGG_LIST_MEMBERs,
                                             idx, &value, 1));
        }

        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, eh,
                                  BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get encap id array of a port aggregate list ID.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  pal_id         Port's related list ID.
 * \param [out] agg_id         Port's aggregate ID.
 * \param [in]  encap_id_sz    Maximum count of returned encap id. When it is 0,
 *                             it means to return all encap id for this port.
 * \param [out] encap_id_arr   Returned Encap id array.
 * \param [out] encap_id_cnt   Returned count of encap id.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_encap_get(
    int unit,
    int pal_id,
    int *agg_id,
    int encap_id_sz,
    int *encap_id_arr,
    int *encap_id_cnt)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int      dunit;
    uint64_t value;
    int      idx;
    uint32_t r_cnt = 0;

    SHR_FUNC_ENTER(unit);

    if (encap_id_sz < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    } else if ((encap_id_sz > 0) && (encap_id_arr == NULL)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (encap_id_cnt == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_PORT_AGG_LISTs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_PORT_AGG_LIST_IDs, pal_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, TM_MC_PORT_AGG_IDs, &value));
    *agg_id = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, NUM_AGG_LIST_MEMBERs, &value));
    *encap_id_cnt = value;

    for (idx = 0; idx < (*encap_id_cnt); idx++) {
        if ((encap_id_sz > 0) && (idx >= encap_id_sz)) {
            SHR_EXIT();
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(eh, AGG_LIST_MEMBERs,
                                         idx, &value, 1, &r_cnt));
        if (encap_id_arr != NULL) {
            encap_id_arr[idx] = value;
        }
    }
    *encap_id_cnt = idx;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set egress encap to a port of L3 multicast group.
 *
 * \param [in]  unit           Unit Number.
 * \param [in]  l3mc_id        L3 multicast group id.
 * \param [in]  port           Logical port id.
 * \param [in]  encap_id_arr   Encap id array.
 * \param [in]  encap_id_cnt   Count of encap id.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_port_encap_set(
    int unit,
    uint32_t l3mc_id,
    bcm_port_t port,
    int *encap_id_arr,
    int encap_id_cnt)
{
    uint32_t max_ports = 0;
    int      idx = 0;
    int     *l2_memb = NULL;
    int     *l3_memb = NULL;

    /* Replication head info. */
    int rh_base = 0, rh_cnt = 0, new_rh_base;
    int member_id, new_member_id;
    /* Encap id array. */
    int *tmp_eid_arr = NULL;
    int  r_cnt = 0;
    uint64_t eid_min = 0, eid_max = 0;

    /* Port Aggregate List ID. */
    int pal_id;
    int agg_id;

    SHR_FUNC_ENTER(unit);

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    l2_memb = sal_alloc(sizeof(int) * max_ports, "xgsMcL2MemArr");
    SHR_NULL_CHECK(l2_memb, SHR_E_MEMORY);
    sal_memset(l2_memb, 0, sizeof(int) * max_ports);

    l3_memb = sal_alloc(sizeof(int) * max_ports, "xgsMcL3MemArr");
    SHR_NULL_CHECK(l3_memb, SHR_E_MEMORY);
    sal_memset(l3_memb, 0, sizeof(int) * max_ports);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_l3_grp_info_get(unit, l3mc_id,
                            &rh_base, &rh_cnt,
                            l2_memb, l3_memb));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TM_MC_PORT_AGG_LISTs,
                                       NUM_AGG_LIST_MEMBERs,
                                       &eid_min, &eid_max));
    tmp_eid_arr = sal_alloc(sizeof(int) * eid_max, "xgsMcEncapIdArr");
    SHR_NULL_CHECK(tmp_eid_arr, SHR_E_MEMORY);

    /* It means to remove a port from a group when encap_id_cnt equals 0. */
    if (encap_id_cnt == 0) {
        if (l3_memb[port] == 0) {
            SHR_EXIT();
        }

        if (rh_cnt > 1) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_repl_head_block_alloc(unit, (rh_cnt - 1), &new_rh_base));

            /*
             * When a port is removed from a group, repl_head entry for
             * this port is deleted. So each original repl_head entry is
             * needed to be moved to a new place.
             */
            member_id = 0;
            new_member_id = 0;
            for (idx = 0; idx < max_ports; idx++) {
                if (l3_memb[idx] == 0) {
                    continue;
                }

                if (idx != port) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mc_l3_grp_encap_get(unit, rh_base + member_id,
                                             &agg_id, eid_max,
                                             tmp_eid_arr, &r_cnt));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mc_l3_grp_encap_set(unit, new_rh_base + new_member_id,
                                             agg_id, tmp_eid_arr, r_cnt));
                    new_member_id++;
                }
                member_id++;
            }
            l3_memb[port] = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_info_set(unit, l3mc_id,
                                    new_rh_base, (rh_cnt - 1),
                                    l2_memb, l3_memb));
        } else {
            l3_memb[port] = 0;
            
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_info_set(unit, l3mc_id, rh_base,
                                    0, l2_memb, l3_memb));
        }

        /* Free old repl_head encap list entries. */
        member_id = 0;
        l3_memb[port] = 1;
        for (idx = 0; idx < max_ports; idx++) {
            if (l3_memb[idx] == 0) {
                continue;
            }
            agg_id = idx;
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_encap_set(unit, rh_base + member_id,
                                     agg_id, NULL, 0));
            member_id++;
        }

        /* Free repl_head resources. */
        if (rh_base > 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_repl_head_block_free(unit, rh_base, rh_cnt));
        }
    } else if (encap_id_cnt > 0) { /* Port is still a L3 member of the group. */
        /* Port is already a l3 member of the group. */
        if (l3_memb[port]) {
            member_id = 0;
            for (idx = 0; idx < max_ports; idx++) {
                if (l3_memb[idx]) {
                    if (idx == port) {
                        break;
                    }
                    member_id++;
                }
            }
            pal_id = rh_base + member_id;
            agg_id = port;
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_encap_set(unit, pal_id,
                                     agg_id, encap_id_arr, encap_id_cnt));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_repl_head_block_alloc(unit, (rh_cnt + 1), &new_rh_base));

            /*
             * When a port is newly added to a group, repl_head entry for
             * this port is added. So each original repl_head entry is
             * needed to be moved to a new place.
             * And note that member_id may be changed.
             */
            member_id = 0;
            new_member_id = 0;
            for (idx = 0; idx < max_ports; idx++) {
                if (idx == port) {
                    agg_id = port;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mc_l3_grp_encap_set(unit, new_rh_base + new_member_id,
                                             agg_id, encap_id_arr,
                                             encap_id_cnt));
                    new_member_id++;
                    continue;
                }

                if (l3_memb[idx] == 0) {
                    continue;
                }

                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_encap_get(unit, rh_base + member_id,
                                         &agg_id, eid_max,
                                         tmp_eid_arr, &r_cnt));
                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_encap_set(unit, new_rh_base + new_member_id,
                                         agg_id, tmp_eid_arr, r_cnt));
                member_id++;
                new_member_id++;
            }

            l3_memb[port] = 1;
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_info_set(unit, l3mc_id,
                                    new_rh_base, (rh_cnt + 1),
                                    l2_memb, l3_memb));

            /* Free old repl_head encap list entries. */
            member_id = 0;
            for (idx = 0; idx < max_ports; idx++) {
                if (l3_memb[idx] == 0) {
                    continue;
                }
                if (idx == port) {
                    continue;
                }

                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_encap_set(unit, rh_base + member_id, 0, NULL, 0));
                member_id++;
            }

            /* Free repl_head resources. */
            
            if ((rh_base > 0) && (rh_cnt > 0)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_repl_head_block_free(unit, rh_base, rh_cnt));
            }
        }
    } else if ((encap_id_cnt == -1) && (port == -1) && (rh_cnt > 0)) {
        /* It means to remove all ports from a group when port and encap_id_cnt equal -1. */
        /* Free repl_head encap list entries. */
        member_id = 0;
        for (idx = 0; idx < max_ports; idx++) {
            if (l3_memb[idx] == 0) {
                continue;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_encap_set(unit, rh_base + member_id, 0, NULL, 0));
            member_id++;
        }

        sal_memset(l3_memb, 0, sizeof(int) * max_ports);
        SHR_IF_ERR_VERBOSE_EXIT
            (mc_l3_grp_info_set(unit, l3mc_id, rh_base,
                                0, l2_memb, l3_memb));

        /* Free repl_head resources. */
        if (rh_base > 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_repl_head_block_free(unit, rh_base, rh_cnt));
        }
    }

exit:

    SHR_FREE(tmp_eid_arr);
    SHR_FREE(l2_memb);
    SHR_FREE(l3_memb);

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get encap id array of port.
 *
 * \param [in]  unit          Unit Number.
 * \param [in]  l3cm_id       L3 multicast group id.
 * \param [in]  encap_id_sz   Maximum count of returned encap id. When it is 0,
 *                            it means to return all encap id for this group.
 * \param [out] encap_id_arr  Returned Encap id array.
 * \param [out] encap_id_cnt  Returned Count of encap id.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_l3_grp_port_encap_get(
    int unit,
    uint32_t l3mc_id,
    bcm_port_t port,
    int encap_id_sz,
    int *encap_id_arr,
    int *encap_id_cnt)
{
    /* Replicastion head info. */
    int rh_base = 0, rh_cnt = 0;
    int *l2_memb = NULL;
    int *l3_memb = NULL;

    /* Port Aggregate List Id*/
    int pal_id;
    int agg_id;

    int max_ports, member_id;
    int idx;
    int found = 0;

    SHR_FUNC_ENTER(unit);

    if (encap_id_sz < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    } else if ((encap_id_sz > 0) && (NULL == encap_id_arr)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (NULL == encap_id_cnt) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);

    l2_memb = sal_alloc(sizeof(int) * max_ports, "xgsMcL2MemArr");
    SHR_NULL_CHECK(l2_memb, SHR_E_MEMORY);
    sal_memset(l2_memb, 0, sizeof(int) * max_ports);

    l3_memb = sal_alloc(sizeof(int) * max_ports, "xgsMcL3MemArr");
    SHR_NULL_CHECK(l3_memb, SHR_E_MEMORY);
    sal_memset(l3_memb, 0, sizeof(int) * max_ports);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_l3_grp_info_get(unit, l3mc_id,
                            &rh_base, &rh_cnt,
                            l2_memb, l3_memb));

    /* It means this group has no egress member. */
    if (rh_base == 0) {
        *encap_id_cnt = 0;
        SHR_EXIT();
    }

    /* Find the corresponding repl_head entry index for the given port. */
    member_id = 0;
    for (idx = 0; idx < max_ports; idx++) {
        if (l3_memb[idx]) {
            if (idx == port) {
                found = 1;
                break;
            }
            member_id++;
        }
    }

    if (found) {
        pal_id = rh_base + member_id;
        SHR_IF_ERR_VERBOSE_EXIT
            (mc_l3_grp_encap_get(unit, pal_id, &agg_id,
                                 encap_id_sz, encap_id_arr, encap_id_cnt));
    } else {
        *encap_id_cnt = 0;
    }

exit:
    SHR_FREE(l2_memb);
    SHR_FREE(l3_memb);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the aggregate ID Mappings on the port.
 *
 * \param [in] unit Unit number.
 * \param [in] port Port of this operation.
 * \param [in] aggid The aggregate ID Mapping on the port.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mc_aggid_set(int unit, bcm_port_t port, uint32_t aggid)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_PORT_AGG_MAPs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, PORT_IDs, port));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_PORT_AGG_IDs, aggid));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_INSERT,
                              BCMLT_PRIORITY_NORMAL));
exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the aggregate ID Mappings.
 *
 * \param [in]  unit            Unit Number.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mc_aggid_init(int unit)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;
    int max_ports = 0, i;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Clean up L2 multicast table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TM_MC_PORT_AGG_MAPs));

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_PORT_AGG_MAPs, &eh));

    for (i = 0; i < max_ports; i++) {
        /* By default, agg_id is same as PORT_ID. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, PORT_IDs, i));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(eh, TM_MC_PORT_AGG_IDs, i));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, eh,
                                  BCMLT_OPCODE_INSERT,
                                  BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}


/*!
 * \brief Insert a free block of REPL_HEAD table entries into free array list.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of the first entry of the block.
 * \param [in] size Size of block.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval SHR_E_MEMORY Out of memory.
 */
static int
mc_repl_head_block_insert(int unit, int index, int size)
{
    xgs_mc_repl_head_free_block_t *block_ptr;

    SHR_FUNC_ENTER(unit);

    block_ptr = sal_alloc(sizeof(xgs_mc_repl_head_free_block_t),
                          "xgsMcReplHeadFreeBlock");
    SHR_NULL_CHECK(block_ptr, SHR_E_MEMORY);

    block_ptr->index = index;
    block_ptr->size = size;
    if (size > (MC_INFO(unit)->repl_head_info.array_size - 1)) {
        /* Insert into free list 0 */
        block_ptr->next = REPL_HEAD_FREE_LIST(unit, 0);
        REPL_HEAD_FREE_LIST(unit, 0) = block_ptr;
    } else {
        block_ptr->next = REPL_HEAD_FREE_LIST(unit, size);
        REPL_HEAD_FREE_LIST(unit, size) = block_ptr;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Mark a block of REPL_HEAD table entries as used.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of the first entry of the block.
 * \param [in] size Size of block.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mc_repl_head_block_used_set(int unit, int index, int size)
{
    int i;
    xgs_mc_repl_head_free_block_t *prev_block_ptr;
    xgs_mc_repl_head_free_block_t *block_ptr;
    int block_index, block_size, sub_block_size;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < MC_INFO(unit)->repl_head_info.array_size; i++) {
        block_ptr = REPL_HEAD_FREE_LIST(unit, i);
        prev_block_ptr = NULL;
        while (NULL != block_ptr) {
            block_index = block_ptr->index;
            block_size = block_ptr->size;
            if ((index >= block_index) &&
                ((index + size) <= (block_index + block_size))) {
                /*
                 * This free block contains the block to be marked as used.
                 * Remove this free block from linked list.
                 */
                if (block_ptr == REPL_HEAD_FREE_LIST(unit, i)) {
                    REPL_HEAD_FREE_LIST(unit, i) = block_ptr->next;
                } else {
                    /*
                     * In the following line of code, Coverity thinks the
                     * prev_block_ptr may still be NULL when dereferenced.
                     * This situation will never occur because
                     * if block_ptr is not pointing to the head of the
                     * linked list, prev_block_ptr would not be NULL.
                     */
                    /* coverity[var_deref_op : FALSE] */
                    prev_block_ptr->next = block_ptr->next;
                }
                SHR_FREE(block_ptr);

                /*
                 * This free block contains up to 3 sub-blocks: the sub-block
                 * to be marked as used, and the sub-blocks before and after
                 * it. The sub-blocks before and after the used sub-block
                 * need to be inserted back into the free list array.
                 * Insert the sub-block before the used sub-block back into
                 * the free list array.
                 */
                sub_block_size = index - block_index;
                if (sub_block_size > 0) {
                    SHR_IF_ERR_EXIT
                        (mc_repl_head_block_insert(unit,
                                                   block_index,
                                                   sub_block_size));
                }

                /*
                 * Insert the sub-block after the used sub-block back into
                 * the free list array.
                 */
                sub_block_size = (block_index + block_size) - (index + size);
                if (sub_block_size > 0) {
                    SHR_IF_ERR_EXIT
                        (mc_repl_head_block_insert(unit,
                                                   index + size,
                                                   sub_block_size));
                }

                SHR_EXIT();
            }

            prev_block_ptr = block_ptr;
            block_ptr = block_ptr->next;
        }
    }

    /* The block to be marked used is not found among the free blocks. */
    SHR_ERR_EXIT(BCM_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover software replication head resource state.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mc_repl_reload(int unit)
{
    uint64_t l3mc_min, l3mc_max;
    int l3mc_id;
    int repl_head_base, repl_head_cnt;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TM_MC_GROUPs, TM_MC_GROUP_IDs,
                                       &l3mc_min, &l3mc_max));

    for (l3mc_id = l3mc_min; l3mc_id <= l3mc_max; l3mc_id++) {
        rv = mc_l3_grp_info_get(unit, l3mc_id, &repl_head_base,
                                &repl_head_cnt, NULL, NULL);
        if (rv == SHR_E_NONE) {
            if ((repl_head_base == 0) || (repl_head_cnt == 0)) {
                continue;
            }

            /* Update REPL_HEAD table usage */
            SHR_IF_ERR_EXIT
                (mc_repl_head_block_used_set(unit,
                                             repl_head_base,
                                             repl_head_cnt));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize a L2 multicast group for default Vlan.
 *
 * \param [in] unit Unit number.
 * \param [in] init If set, means initialization.
 *
 * \retval SHR_E_NONE  No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mc_def_vlan_grp_set(int unit, bool init)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t *port_id_arr = NULL;
    int max_ports;
    bcm_port_t port;
    bcm_pbmp_t pbmp;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_MC_GROUPs, &eh));

    /* Add L2 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_MC_GROUP_IDs, XGS_MC_DEF_VLAN_GRP_ID));

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    port_id_arr =
        sal_alloc(sizeof(uint64_t) * max_ports, "xgsMcPortIdArr");
    SHR_NULL_CHECK(port_id_arr, SHR_E_MEMORY);
    sal_memset(port_id_arr, 0, sizeof(uint64_t) * max_ports);

    BCM_PBMP_CLEAR(pbmp);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_def_pbmp_get(unit, &pbmp));

    BCM_PBMP_ITER(pbmp, port) {
        if ((port < 0) || (port >= max_ports)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        port_id_arr[port] = 1;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(eh, PORT_IDs, 0, port_id_arr, max_ports));

    if (init) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_INSERT,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    }

exit:
    SHR_FREE(port_id_arr);

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_multicast_init(int unit)
{
    int warm;

    SHR_FUNC_ENTER(unit);

    warm = bcmi_warmboot_get(unit);
    if (!warm) {

        /* Clean up L2 multicast table. */
        SHR_IF_ERR_EXIT
            (bcmi_lt_clear(unit, L2_MC_GROUPs));

        /* Clean up L3 multicast table. */
        SHR_IF_ERR_EXIT
            (bcmi_lt_clear(unit, TM_MC_GROUPs));

        /* Clean up REPL_LIST table. */
        SHR_IF_ERR_EXIT
            (bcmi_lt_clear(unit, TM_MC_PORT_AGG_LISTs));

        /* Initialize the port aggid. */
        SHR_IF_ERR_EXIT
            (mc_aggid_init(unit));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_repl_head_info_init(unit));

    if (warm) {
        SHR_IF_ERR_EXIT
            (mc_repl_reload(unit));
    }

    if(!warm) {
        SHR_IF_ERR_EXIT
            (mc_def_vlan_grp_set(unit, TRUE));
    }

exit:
    if (SHR_FUNC_ERR()) {
        (void)xgs_ltsw_multicast_detach(unit);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_detach(int unit)
{
    mc_repl_head_info_deinit(unit);

    return SHR_E_NONE;
}

int
xgs_ltsw_multicast_pub_info_get(
    int unit,
    bcmint_multicast_pub_info_t *mc_pub)
{
    uint64_t l2mc_min, l2mc_max;
    uint64_t l3mc_min, l3mc_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
         (bcmi_lt_field_value_range_get(unit, L2_MC_GROUPs, L2_MC_GROUP_IDs,
                                         &l2mc_min,&l2mc_max));
    /* L2 MC group 0 is reserved for defaut vlan in TD4. */
    mc_pub->l2mc_min = 1;
    mc_pub->l2mc_max = l2mc_max;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TM_MC_GROUPs, TM_MC_GROUP_IDs,
                                       &l3mc_min, &l3mc_max));
    mc_pub->l3mc_min = l3mc_min;
    mc_pub->l3mc_max = l3mc_max;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_l2_grp_create(
    int unit,
    uint32_t l2mc_id)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_MC_GROUPs, &eh));

    /* Add L2 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_MC_GROUP_IDs, l2mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_INSERT,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_l2_grp_destroy(
    int unit,
    uint32_t l2mc_id)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_MC_GROUPs, &eh));

    /* Add L2 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_MC_GROUP_IDs, l2mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_l2_grp_update(
    int unit,
    uint32_t l2mc_id,
    bcmint_multicast_l2_grp_op_code_t opcode,
    bcm_port_t *port_array,
    uint32_t port_count)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int       dunit = 0;
    uint64_t *port_id_arr = NULL;
    uint64_t  data = 0;
    int       max_ports, idx;
    bcm_port_t l_port;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L2_MC_GROUPs, &eh));

    /* Add L2 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_MC_GROUP_IDs, l2mc_id));

    switch (opcode) {
    case bcmintMcL2GrpMemAdd:
        data = 1;
        for (idx = 0; idx < port_count; idx++) {
            /*
             * PORT_ID is an array of bool values for logical ports.
             * So port_array[idx] is the index of array.
             */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(eh, PORT_IDs,
                                             port_array[idx],
                                             &data, 1));
        }
        break;
    case bcmintMcL2GrpMemDel:
        data = 0;
        for (idx = 0; idx < port_count; idx++) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(eh, PORT_IDs,
                                             port_array[idx],
                                             &data, 1));
        }
        break;
    case bcmintMcL2GrpMemSet:
        max_ports = bcmi_ltsw_dev_logic_port_num(unit);
        port_id_arr =
            sal_alloc(sizeof(uint64_t) * max_ports, "xgsMcPortIdArr");
        SHR_NULL_CHECK(port_id_arr, SHR_E_MEMORY);
        sal_memset(port_id_arr, 0, sizeof(uint64_t) * max_ports);

        for (idx = 0; idx < port_count; idx++) {
            l_port = port_array[idx];
            if ((l_port < 0) || (l_port >= max_ports)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            port_id_arr[l_port] = 1;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(eh, PORT_IDs,
                                         0, port_id_arr, max_ports));
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
        break;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    SHR_FREE(port_id_arr);

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_l2_egress_get(
    int unit,
    uint32_t l2mc_id,
    int port_size,
    bcm_gport_t *port_array,
    bcm_if_t *encap_id_array,
    int *port_count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_l2_grp_get(unit, l2mc_id, port_size,
                       port_array, encap_id_array, port_count));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_l3_grp_create(
    int unit,
    uint32_t l3mc_id)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_GROUPs, &eh));

    /* Add L3 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, l3mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_INSERT,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_l3_grp_destroy(
    int unit,
    uint32_t l3mc_id)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TM_MC_GROUPs, &eh));

    /* Add L3 multicast group ID. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, l3mc_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_l3_grp_update(
    int unit,
    uint32_t l3mc_id,
    bcmint_multicast_l3_grp_op_code_t opcode,
    bcm_port_t port,
    bcm_if_t *encap_id_array,
    uint32_t encap_count)
{
    /* Encap id array. */
    int *eid_arr = NULL;
    int  r_cnt = 0;
    uint64_t eid_min = 0, eid_max = 0;

    int  idx = 0;
    int  match = FALSE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TM_MC_PORT_AGG_LISTs,
                                       NUM_AGG_LIST_MEMBERs,
                                       &eid_min, &eid_max));

    switch (opcode) {
    case bcmintMcL3GrpPortEncapAdd:
        /* For add operation, it only has one encap_id. */
        if (encap_id_array[0] == BCM_IF_INVALID) {

            /* -1 means a layer 2 copy. */
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_port_l2_set(unit, l3mc_id, port, 1));

        } else {
            eid_arr = sal_alloc(sizeof(int) * eid_max, "xgsMcEncapIdArr");
            SHR_NULL_CHECK(eid_arr, SHR_E_MEMORY);

            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_port_encap_get(unit, l3mc_id, port,
                                          eid_max, eid_arr, &r_cnt));

            for (idx = 0; idx < r_cnt; idx++) {
                if (eid_arr[idx] == encap_id_array[0]) {
                    /* Encap_id is already added. */
                    SHR_EXIT();
                }
            }
            if (r_cnt == eid_max) {
                SHR_ERR_EXIT(SHR_E_FULL);
            }
            eid_arr[idx] = encap_id_array[0];

            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_port_encap_set(unit, l3mc_id, port,
                                          eid_arr, (r_cnt + 1)));

        }
        break;
    case bcmintMcL3GrpPortEncapDel:
        /* For del operation, it only has one encap_id. */
        if (encap_id_array[0] == BCM_IF_INVALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_port_l2_set(unit, l3mc_id, port, 0));
        } else {
            eid_arr = sal_alloc(sizeof(int) * eid_max, "xgsMcEncapIdArr");
            SHR_NULL_CHECK(eid_arr, SHR_E_MEMORY);

            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_port_encap_get(unit, l3mc_id, port,
                                          eid_max, eid_arr, &r_cnt));

            match = FALSE;
            for (idx = 0; idx < r_cnt; idx++) {
                if (match) {
                    eid_arr[idx - 1] = eid_arr[idx];
                } else {
                    if (eid_arr[idx] == encap_id_array[0]) {
                        match = TRUE;
                    }
                }
            }

            if (match) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_port_encap_set(unit, l3mc_id, port,
                                              eid_arr, (r_cnt - 1)));
            } else {
                SHR_ERR_EXIT(SHR_E_NOT_FOUND);
            }
        }

        break;
    case bcmintMcL3GrpPortEncapDelAll:
        if (port == BCM_PORT_INVALID) {
            /* Delete all replications for the specified mulitcast group ID. */
            int     *l2_memb = NULL;
            int     *l3_memb = NULL;
            uint32_t max_ports = 0;
            int rh_base = 0, rh_cnt = 0;
            bcm_pbmp_t mc_pbmp;
            bcm_port_t port_iter;
            BCM_PBMP_CLEAR(mc_pbmp);

            max_ports = bcmi_ltsw_dev_logic_port_num(unit);
            l2_memb = sal_alloc(sizeof(int) * max_ports, "xgsMcL2MemArr");
            SHR_NULL_CHECK(l2_memb, SHR_E_MEMORY);
            sal_memset(l2_memb, 0, sizeof(int) * max_ports);

            l3_memb = sal_alloc(sizeof(int) * max_ports, "xgsMcL3MemArr");
            SHR_NULL_CHECK(l3_memb, SHR_E_MEMORY);
            sal_memset(l3_memb, 0, sizeof(int) * max_ports);

            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_info_get(unit, l3mc_id, &rh_base, &rh_cnt,
                                    l2_memb, l3_memb));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_ALL, &mc_pbmp));

            BCM_PBMP_ITER(mc_pbmp, port_iter) {
                if (l2_memb[port_iter]) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mc_l3_grp_port_l2_set(unit, l3mc_id, port_iter, 0));
                }
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (mc_l3_grp_port_encap_set(unit, l3mc_id, -1, NULL, -1));
        }
        break;
    case bcmintMcL3GrpPortEncapSet:
        if (encap_count > eid_max) {
            SHR_ERR_EXIT(SHR_E_FULL);
        }
        eid_arr = sal_alloc(sizeof(int) * eid_max, "xgsMcEncapIdArr");
        SHR_NULL_CHECK(eid_arr, SHR_E_MEMORY);
        match = FALSE;
        r_cnt = 0;
        for (idx = 0; idx < encap_count; idx++) {
            if (encap_id_array[idx] == BCM_IF_INVALID) {
                match = TRUE;
                continue;
            }
            eid_arr[r_cnt] = encap_id_array[idx];
            r_cnt++;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (mc_l3_grp_port_l2_set(unit, l3mc_id, port, match));

        SHR_IF_ERR_VERBOSE_EXIT
            (mc_l3_grp_port_encap_set(unit, l3mc_id, port,
                                      eid_arr, r_cnt));

        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
        break;
    }

exit:

    SHR_FREE(eid_arr);

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_l3_egress_get(
    int unit,
    uint32_t l3mc_id,
    int port_size,
    bcm_gport_t *port_array,
    bcm_if_t *encap_id_array,
    int *port_count)
{
    uint32_t  max_ports = 0;
    int       idx = 0;
    int      *l2_memb = NULL;
    int      *l3_memb = NULL;
    bcm_if_t *local_id_arr = NULL;
    uint64_t  eid_min = 0, eid_max = 0;
    int       eid = 0;

    /* Replication head info. */
    int rh_base, rh_cnt;
    int r_cnt = 0;

    bcm_gport_t gport;

    SHR_FUNC_ENTER(unit);

    max_ports = bcmi_ltsw_dev_logic_port_num(unit);
    l2_memb = sal_alloc(sizeof(int) * max_ports, "xgsMcL2MemArr");
    SHR_NULL_CHECK(l2_memb, SHR_E_MEMORY);
    sal_memset(l2_memb, 0, sizeof(int) * max_ports);

    l3_memb = sal_alloc(sizeof(int) * max_ports, "xgsMcL3MemArr");
    SHR_NULL_CHECK(l3_memb, SHR_E_MEMORY);
    sal_memset(l3_memb, 0, sizeof(int) * max_ports);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_l3_grp_info_get(unit, l3mc_id,
                            &rh_base, &rh_cnt,
                            l2_memb, l3_memb));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TM_MC_PORT_AGG_LISTs,
                                       NUM_AGG_LIST_MEMBERs,
                                       &eid_min, &eid_max));

    local_id_arr = sal_alloc(sizeof(bcm_if_t) * eid_max, "xgsMcLocArr");
    SHR_NULL_CHECK(local_id_arr, SHR_E_MEMORY);
    sal_memset(local_id_arr, 0, sizeof(int) * eid_max);

    *port_count = 0;
    for (idx = 0; idx < max_ports; idx++) {
        /*
         * When port_size is > 0, only port_size ports are returned.
         * When port_size is 0, then just return the actual port_count.
         */
        if ((port_size > 0) && (*port_count >= port_size)) {
            SHR_EXIT();
        }
        if (l3_memb[idx] == 1) {
            if (port_size > 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_port_encap_get(unit,
                                              l3mc_id,
                                              idx,
                                              (port_size - (*port_count)),
                                              local_id_arr, &r_cnt));
            } else {
                 SHR_IF_ERR_VERBOSE_EXIT
                    (mc_l3_grp_port_encap_get(unit,
                                              l3mc_id,
                                              idx,
                                              0,
                                              local_id_arr, &r_cnt));
            }

            if (port_array != NULL) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_port_gport_get(unit, idx, &gport));
            }

            for (eid = 0; eid < r_cnt; eid++) {
                if (encap_id_array != NULL) {
                    encap_id_array[(*port_count) + eid] = local_id_arr[eid];
                }
                if (port_array != NULL) {
                    port_array[(*port_count) + eid] = gport;
                }
            }
            (*port_count) += r_cnt;
        }
    }

    for (idx = 0; idx < max_ports; idx++) {
        /*
         * When port_size is > 0, only port_size ports are returned.
         * When port_size is 0, then just return the actual port_count.
         */
        if ((port_size > 0) && (*port_count >= port_size)) {
            SHR_EXIT();
        }
        if (l2_memb[idx] == 1) {
            if (port_array != NULL) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_port_gport_get(unit,
                                             idx,
                                             &(port_array[*port_count])));
            }
            if (encap_id_array != NULL) {
                encap_id_array[*port_count] = BCM_IF_INVALID;
            }
            *port_count += 1;
        }
    }


exit:

    SHR_FREE(l2_memb);
    SHR_FREE(l3_memb);
    SHR_FREE(local_id_arr);

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_encap_create(
    int unit,
    bcm_multicast_encap_t *mc_encap,
    bcm_if_t *encap_id)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_multicast_encap_destroy(
    int unit,
    bcm_if_t encap_id)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_multicast_encap_get(
    int unit,
    bcm_if_t encap_id,
    bcm_multicast_encap_t *mc_encap)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_multicast_encap_recover(
    int unit,
    bcm_if_t encap_id)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_multicast_def_vlan_grp_id_get(
    int unit,
    uint32_t *grp_id)
{
    SHR_FUNC_ENTER(unit);

    if (grp_id == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *grp_id = XGS_MC_DEF_VLAN_GRP_ID;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_def_vlan_grp_update(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mc_def_vlan_grp_set(unit, FALSE));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_l2_l3_combined_set(
    int unit,
    bool enable)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int      dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Allocate entry container. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L3_MC_CONTROLs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L2_L3_MC_COMBINED_MODEs, enable));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_l2_l3_combined_get(
    int unit,
    bool *enable)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value = 0;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L3_MC_CONTROLs, &eh));

    rv = bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(eh, L2_L3_MC_COMBINED_MODEs, &value));
        *enable = value;
    } else {
        *enable = FALSE;
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_remap_group_set(
    int unit,
    int mc_index_from,
    int mc_index_to)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_multicast_remap_group_get(
    int unit,
    int mc_index_from,
    int *mc_index_to)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_multicast_egress_object_encap_get(
    int unit,
    bcm_multicast_t group,
    bcm_if_t intf,
    bcm_if_t *encap_id)
{
    int nh_idx;
    bcmi_ltsw_l3_egr_obj_type_t type;

    SHR_FUNC_ENTER(unit);

    
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_l3_egress_obj_id_resolve(unit, intf,
                                            &nh_idx, &type));

    *encap_id = nh_idx;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_mtu_set(
    int unit,
    int mc_index,
    int mtu)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t min, max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, L3_MC_MTUs, L3_MTUs, &min, &max));

    if ((mtu < min) || (mtu > max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L3_MC_MTUs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, mc_index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, L3_MTUs, mtu));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_mtu_get(
    int unit,
    int mc_index,
    int *mtu)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, L3_MC_MTUs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TM_MC_GROUP_IDs, mc_index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, L3_MTUs, &value));
    *mtu = (int)value;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_repl_port_attach(
    int unit,
    bcm_port_t port)
{
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    /* Detach the IPMC REPL in case it is already attached. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_multicast_repl_port_detach(unit, port));

    /* configure device port to repl aggregateId map */
    rv = mc_aggid_set(unit, port, port);
    if (SHR_FAILURE(rv)) {
        (void)xgs_ltsw_multicast_repl_port_detach(unit, port);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_repl_port_detach(
    int unit,
    bcm_port_t port)
{
    SHR_FUNC_ENTER(unit);

    /* Reset TM_MC_PORT_AGG_IDs to HW invalid */
    SHR_IF_ERR_VERBOSE_EXIT
        (mc_aggid_set(unit, port, XGS_MC_AGG_ID_HW_INVALID));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_multicast_vlan_flood_init(int unit)
{
    return SHR_E_UNAVAIL;
}

