/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/time.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/xgs/time.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/port.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_TIME

/******************************************************************************
 * Private functions
 */


/*! The max number of timesync configurations. */
#define XGS_TIMESYNC_CONFIG_MAX (1)

/*! LT PC_SYNCE_STAGE0_MODE_T enum strings. */
#define XGS_TIME_PC_SYNCE_STAGE_0_MODE_STR { \
    PC_SYNCE_STAGE_0_MODE_DIV_NONEs, \
    PC_SYNCE_STAGE_0_MODE_DIV_GAP_CLK_4_OVER_5s, \
    PC_SYNCE_STAGE_0_MODE_SDM_FRAC_DIVs \
}

/*! LT PC_SYNCE_STAGE1_MODE_T enum strings. */
#define XGS_TIME_PC_SYNCE_STAGE_1_MODE_STR { \
    PC_SYNCE_STAGE_1_MODE_DIV_NONEs, \
    PC_SYNCE_STAGE_1_MODE_DIV_7s, \
    PC_SYNCE_STAGE_1_MODE_DIV_11s \
}

/*!
 * \brief PTP message control object.
 *
 * This is the data object of profile handler
 * BCMI_LTSW_PROFILE_DEVICE_TS_PTP_MSG_CONTROL.
 *
 * BCMI_LTSW_PROFILE_DEVICE_TS_PTP_MSG_CONTROL is used to manage
 * DEVICE_TS_PTP_MSG_CONTROL_PROFILEs LT.
 */
typedef struct xgs_ptp_msg_control_s {
    int tocpu;
    int drop;
} xgs_ptp_msg_control_t;

/******************************************************************************
 * Profile management
 */
/*!
 * \brief Get DEVICE_TS_PTP_MSG_CONTROL_PROFILE LT entry.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 * \param [out] entry Profile entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_device_ts_ptp_msg_ctrl_entry_get(
    int unit,
    int index,
    xgs_ptp_msg_control_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t fields[] =
    {
        /* Key fields to set. */
        /* 0*/ {DEVICE_TS_PTP_MSG_CONTROL_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},

        /* Data fields to get. */
        /* 1*/ {SYNC_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 2*/ {SYNC_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 3*/ {FOLLOW_UP_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 4*/ {FOLLOW_UP_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 5*/ {DELAY_REQ_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 6*/ {DELAY_REQ_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 7*/ {DELAY_RESP_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 8*/ {DELAY_RESP_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /* 9*/ {PDELAY_RESP_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*10*/ {PDELAY_RESP_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*11*/ {PDELAY_RESP_FOLLOW_UP_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*12*/ {PDELAY_RESP_FOLLOW_UP_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*13*/ {PDELAY_REQ_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*14*/ {PDELAY_REQ_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*15*/ {MSG_TYPE4_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*16*/ {MSG_TYPE4_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*17*/ {MSG_TYPE5_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*18*/ {MSG_TYPE5_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*19*/ {MSG_TYPE6_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*20*/ {MSG_TYPE6_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*21*/ {MSG_TYPE7_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*22*/ {MSG_TYPE7_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*23*/ {MSG_TYPE11_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*24*/ {MSG_TYPE11_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*25*/ {MSG_TYPE12_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*26*/ {MSG_TYPE12_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*27*/ {MSG_TYPE13_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*28*/ {MSG_TYPE13_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*29*/ {MSG_TYPE14_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*30*/ {MSG_TYPE14_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*31*/ {MSG_TYPE15_TO_CPUs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*32*/ {MSG_TYPE15_DROPs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = fields;
    lt_entry.nfields = COUNTOF(fields);
    lt_entry.attr = 0;
    fields[0].u.val = index;
    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_get(unit,
                           DEVICE_TS_PTP_MSG_CONTROL_PROFILEs,
                           &lt_entry,
                           NULL,
                           NULL));

    /*
     * Convert the LT field values to xgs_ptp_msg_control_t.
     *
     * The LT fields for MGS_TYPE4~MSG_TYPE7 and MGS_TYPE14~MSG_TYPE15 are not
     * mapped yet, because those message types are reserved.
     */
    sal_memset(entry, 0, sizeof(*entry));
    if (fields[1].u.val) {
        entry->tocpu |= BCM_PORT_TIMESYNC_PKT_SYNC;
    }
    if (fields[2].u.val) {
        entry->drop |= BCM_PORT_TIMESYNC_PKT_SYNC;
    }
    if (fields[3].u.val) {
        entry->tocpu |= BCM_PORT_TIMESYNC_PKT_FOLLOWUP;
    }
    if (fields[4].u.val) {
        entry->drop |= BCM_PORT_TIMESYNC_PKT_FOLLOWUP;
    }
    if (fields[5].u.val) {
        entry->tocpu |= BCM_PORT_TIMESYNC_PKT_DELAY_REQ;
    }
    if (fields[6].u.val) {
        entry->drop |= BCM_PORT_TIMESYNC_PKT_DELAY_REQ;
    }
    if (fields[7].u.val) {
        entry->tocpu |= BCM_PORT_TIMESYNC_PKT_DELAY_RESP;
    }
    if (fields[8].u.val) {
        entry->drop |= BCM_PORT_TIMESYNC_PKT_DELAY_RESP;
    }
    if (fields[9].u.val) {
        entry->tocpu |= BCM_PORT_TIMESYNC_PKT_PDELAY_RESP;
    }
    if (fields[10].u.val) {
        entry->drop |= BCM_PORT_TIMESYNC_PKT_PDELAY_RESP;
    }
    if (fields[11].u.val) {
        entry->tocpu |= BCM_PORT_TIMESYNC_PKT_PDELAY_RESP_FOLLOWUP;
    }
    if (fields[12].u.val) {
        entry->drop |= BCM_PORT_TIMESYNC_PKT_PDELAY_RESP_FOLLOWUP;
    }
    if (fields[13].u.val) {
        entry->tocpu |= BCM_PORT_TIMESYNC_PKT_PDELAY_REQ;
    }
    if (fields[14].u.val) {
        entry->drop |= BCM_PORT_TIMESYNC_PKT_PDELAY_REQ;
    }
    if (fields[23].u.val) {
        entry->tocpu |= BCM_PORT_TIMESYNC_PKT_ANNOUNCE;
    }
    if (fields[24].u.val) {
        entry->drop |= BCM_PORT_TIMESYNC_PKT_ANNOUNCE;
    }
    if (fields[25].u.val) {
        entry->tocpu |= BCM_PORT_TIMESYNC_PKT_SIGNALLING;
    }
    if (fields[26].u.val) {
        entry->drop |= BCM_PORT_TIMESYNC_PKT_SIGNALLING;
    }
    if (fields[27].u.val) {
        entry->tocpu |= BCM_PORT_TIMESYNC_PKT_MANAGMENT;
    }
    if (fields[28].u.val) {
        entry->drop |= BCM_PORT_TIMESYNC_PKT_MANAGMENT;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DEVICE_TS_PTP_MSG_CONTROL_PROFILE LT entry.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 * \param [in] entry Profile entry.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_device_ts_ptp_msg_ctrl_entry_set(
    int unit,
    int index,
    xgs_ptp_msg_control_t *entry)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t fields[] =
    {
        /* Key fields to set. */
        /* 0*/ {DEVICE_TS_PTP_MSG_CONTROL_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},

        /* Data fields to set. */
        /* 1*/ {SYNC_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* 2*/ {SYNC_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* 3*/ {FOLLOW_UP_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* 4*/ {FOLLOW_UP_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* 5*/ {DELAY_REQ_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* 6*/ {DELAY_REQ_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* 7*/ {DELAY_RESP_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* 8*/ {DELAY_RESP_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /* 9*/ {PDELAY_RESP_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*10*/ {PDELAY_RESP_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*11*/ {PDELAY_RESP_FOLLOW_UP_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*12*/ {PDELAY_RESP_FOLLOW_UP_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*13*/ {PDELAY_REQ_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*14*/ {PDELAY_REQ_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*15*/ {MSG_TYPE4_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*16*/ {MSG_TYPE4_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*17*/ {MSG_TYPE5_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*18*/ {MSG_TYPE5_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*19*/ {MSG_TYPE6_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*20*/ {MSG_TYPE6_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*21*/ {MSG_TYPE7_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*22*/ {MSG_TYPE7_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*23*/ {MSG_TYPE11_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*24*/ {MSG_TYPE11_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*25*/ {MSG_TYPE12_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*26*/ {MSG_TYPE12_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*27*/ {MSG_TYPE13_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*28*/ {MSG_TYPE13_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*29*/ {MSG_TYPE14_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*30*/ {MSG_TYPE14_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*31*/ {MSG_TYPE15_TO_CPUs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*32*/ {MSG_TYPE15_DROPs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    lt_entry.fields = fields;
    lt_entry.nfields = COUNTOF(fields);
    lt_entry.attr = 0;

    fields[0].u.val = index;

    /*
     * Convert the xgs_ptp_msg_control_t value to LT fields.
     *
     * The LT fields for MGS_TYPE4~MSG_TYPE7 and MGS_TYPE14~MSG_TYPE15 are not
     * mapped yet, because those message types are reserved.
     */
    if (entry->tocpu & BCM_PORT_TIMESYNC_PKT_SYNC) {
        fields[1].u.val = 1;
    }
    if (entry->drop & BCM_PORT_TIMESYNC_PKT_SYNC) {
        fields[2].u.val = 1;
    }
    if (entry->tocpu & BCM_PORT_TIMESYNC_PKT_FOLLOWUP) {
        fields[3].u.val = 1;
    }
    if (entry->drop & BCM_PORT_TIMESYNC_PKT_FOLLOWUP) {
        fields[4].u.val = 1;
    }
    if (entry->tocpu & BCM_PORT_TIMESYNC_PKT_DELAY_REQ) {
        fields[5].u.val = 1;
    }
    if (entry->drop & BCM_PORT_TIMESYNC_PKT_DELAY_REQ) {
        fields[6].u.val = 1;
    }
    if (entry->tocpu & BCM_PORT_TIMESYNC_PKT_DELAY_RESP) {
        fields[7].u.val = 1;
    }
    if (entry->drop & BCM_PORT_TIMESYNC_PKT_DELAY_RESP) {
        fields[8].u.val = 1;
    }
    if (entry->tocpu & BCM_PORT_TIMESYNC_PKT_PDELAY_RESP) {
        fields[9].u.val = 1;
    }
    if (entry->drop & BCM_PORT_TIMESYNC_PKT_PDELAY_RESP) {
        fields[10].u.val = 1;
    }
    if (entry->tocpu & BCM_PORT_TIMESYNC_PKT_PDELAY_RESP_FOLLOWUP) {
        fields[11].u.val = 1;
    }
    if (entry->drop & BCM_PORT_TIMESYNC_PKT_PDELAY_RESP_FOLLOWUP) {
        fields[12].u.val = 1;
    }
    if (entry->tocpu & BCM_PORT_TIMESYNC_PKT_PDELAY_REQ) {
        fields[13].u.val = 1;
    }
    if (entry->drop & BCM_PORT_TIMESYNC_PKT_PDELAY_REQ) {
        fields[14].u.val = 1;
    }
    if (entry->tocpu & BCM_PORT_TIMESYNC_PKT_ANNOUNCE) {
        fields[23].u.val = 1;
    }
    if (entry->drop & BCM_PORT_TIMESYNC_PKT_ANNOUNCE) {
        fields[24].u.val = 1;
    }
    if (entry->tocpu & BCM_PORT_TIMESYNC_PKT_SIGNALLING) {
        fields[25].u.val = 1;
    }
    if (entry->drop & BCM_PORT_TIMESYNC_PKT_SIGNALLING) {
        fields[26].u.val = 1;
    }
    if (entry->tocpu & BCM_PORT_TIMESYNC_PKT_MANAGMENT) {
        fields[27].u.val = 1;
    }
    if (entry->drop & BCM_PORT_TIMESYNC_PKT_MANAGMENT) {
        fields[28].u.val = 1;
    }

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_set(unit, DEVICE_TS_PTP_MSG_CONTROL_PROFILEs, &lt_entry,
                           NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete DEVICE_TS_PTP_MSG_CONTROL_PROFILE LT entry.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_device_ts_ptp_msg_ctrl_entry_delete(
    int unit,
    int index)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t fields[] =
    {
        {DEVICE_TS_PTP_MSG_CONTROL_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    lt_entry.fields = fields;
    lt_entry.nfields = COUNTOF(fields);
    lt_entry.attr = 0;

    fields[0].u.val = index;

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_delete(unit, DEVICE_TS_PTP_MSG_CONTROL_PROFILEs,
                              &lt_entry, NULL));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a DEVICE_TS_PTP_MSG_CONTROL_PROFILE profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] entry DEVICE_TS_PTP_MSG_CONTROL_PROFILE profile entry.
 * \param [out] index Profile index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
xgs_time_ptp_msg_control_profile_entry_add(
    int unit,
    xgs_ptp_msg_control_t *entry,
    int *index)
{
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_DEVICE_TS_PTP_MSG_CONTROL;
    int rv;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(index, SHR_E_PARAM);
    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    /* Allocate a new profile entry if required */
    rv = bcmi_ltsw_profile_index_allocate(unit, ph, entry, 0, 1, index);
    if (SHR_SUCCESS(rv)) {
        /* New entry is created, to add its data to LT */
        rv = lt_device_ts_ptp_msg_ctrl_entry_set(unit, *index, entry);
        if (SHR_FAILURE(rv)) {
            (void)bcmi_ltsw_profile_index_free(unit, ph, *index);
            SHR_ERR_EXIT(rv);
        }
    } else if (rv != SHR_E_EXISTS) {
       SHR_ERR_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete a DEVICE_TS_PTP_MSG_CONTROL_PROFILE profile entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_index Profile index created.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_ptp_msg_control_profile_entry_delete(
    int unit,
    int index)

{
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_DEVICE_TS_PTP_MSG_CONTROL;
    int rv;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_free(unit, ph, index);
    if (rv == SHR_E_BUSY) {
        /* The entry is still in use. */
        SHR_EXIT();
    }
    SHR_IF_ERR_EXIT(rv);

    SHR_IF_ERR_EXIT
        (lt_device_ts_ptp_msg_ctrl_entry_delete(unit, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover DEVICE_TS_PTP_MSG_CONTROL_PROFILE profile entry.
 *
 * This function recovers the hash and reference count for the given index.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index of profile table.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xgs_time_ptp_msg_control_profile_entry_recover(int unit, int index)
{
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_DEVICE_TS_PTP_MSG_CONTROL;
    xgs_ptp_msg_control_t entry;
    int entries_per_set = 1;
    uint32_t ref_cnt = 0;

    SHR_FUNC_ENTER(unit);

    sal_memset(&entry, 0, sizeof(entry));

    /* Update profile hash on the first usage. */
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_profile_ref_count_get(unit, ph, index, &ref_cnt));
    if (ref_cnt == 0) {
        SHR_IF_ERR_EXIT
            (lt_device_ts_ptp_msg_ctrl_entry_get(unit, index, &entry));
        SHR_IF_ERR_EXIT
            (bcmi_ltsw_profile_hash_update(unit, ph, &entry, entries_per_set,
                                           index));
    }

    /* Increment reference count. */
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_profile_ref_count_increase(unit, ph,
                                              entries_per_set, index, 1));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover DEVICE_TS_PTP_MSG_CONTROL_PROFILE profile.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_ptp_msg_control_profile_recover(int unit)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit, index;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORTs, &eh));

    while (SHR_SUCCESS(bcmi_lt_entry_commit(unit, eh,
                                            BCMLT_OPCODE_TRAVERSE,
                                            BCMLT_PRIORITY_NORMAL))) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(eh,
                                   DEVICE_TS_PTP_MSG_CONTROL_PROFILE_IDs,
                                   &data));
        index = data;
        SHR_IF_ERR_EXIT
            (xgs_time_ptp_msg_control_profile_entry_recover(unit, index));
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare DEVICE_TS_PTP_MSG_CONTROL_PROFILE profile entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] entries DEVICE_TS_PTP_MSG_CONTROL_PROFILE profile entry.
 * \param [in] entries_per_set Number of entries in the profile set.
 * \param [in] index Entry index of profile table.
 * \param [out] cmp Result of comparison.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_ptp_msg_control_profile_cmp_cb(
    int unit,
    void *entries,
    int entries_per_set,
    int index,
    int *cmp)
{
    xgs_ptp_msg_control_t data;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(cmp, SHR_E_PARAM);

    if (entries_per_set != 1) {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_EXIT
        (lt_device_ts_ptp_msg_ctrl_entry_get(unit, index, &data));

    *cmp = sal_memcmp(entries, (void *)&data, sizeof(data));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash for DEVICE_TS_PTP_MSG_CONTROL_PROFILE profile entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] entries DEVICE_TS_PTP_MSG_CONTROL_PROFILE profile entry.
 * \param [in] entries_per_set Number of entries in the profile set.
 * \param [out] hash Hash signature.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_ptp_msg_control_profile_hash_cb(
    int unit,
    void *entries,
    int entries_per_set,
    uint32_t *hash)
{
    int size;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    if (entries_per_set != 1) {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }

    size = entries_per_set * sizeof(xgs_ptp_msg_control_t);
    *hash = shr_crc32(0, entries, size);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize profile information.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_profile_init(int unit)
{
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_DEVICE_TS_PTP_MSG_CONTROL;
    uint64_t idx_min_u64, idx_max_u64;
    int idx_min, idx_max, idx;
    int entries_per_set = 1;
    uint32_t ref_cnt = 0;
    xgs_ptp_msg_control_t entry;

    SHR_FUNC_ENTER(unit);

    /* Setup profile handler for DEVICE_TS_PTP_MSG_CONTROL_PROFILE */
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit, ph),
         SHR_E_NOT_FOUND);

    SHR_IF_ERR_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       DEVICE_TS_PTP_MSG_CONTROL_PROFILEs,
                                       DEVICE_TS_PTP_MSG_CONTROL_PROFILE_IDs,
                                       &idx_min_u64,
                                       &idx_max_u64));
    idx_min = idx_min_u64;
    idx_max = idx_max_u64;
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_profile_register(unit,
                                    &ph,
                                    &idx_min,
                                    &idx_max,
                                    1,
                                    xgs_time_ptp_msg_control_profile_hash_cb,
                                    xgs_time_ptp_msg_control_profile_cmp_cb));

    /* Recover the profile when warm boot. */
    if (bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_EXIT
            (xgs_time_ptp_msg_control_profile_recover(unit));

        /* Increment reference count for the default entry. */
        idx = 0;
        SHR_IF_ERR_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit, ph, entries_per_set,
                                                  idx, 1));
        SHR_EXIT();
    }

    /* Clear DEVICE_TS_PTP_MSG_CONTROL_PROFILEs table when cold boot. */
    SHR_IF_ERR_EXIT
        (bcmi_lt_clear(unit, DEVICE_TS_PTP_MSG_CONTROL_PROFILEs));

    /* Reserve the first entry as the default entry. */
    sal_memset(&entry, 0, sizeof(entry));
    SHR_IF_ERR_EXIT
        (xgs_time_ptp_msg_control_profile_entry_add(unit, &entry, &idx));
    if (idx != 0) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    /* All PORT LT entries reference to the default profile entry. */
    SHR_IF_ERR_EXIT
        (bcmi_lt_capacity_get(unit, PORTs, &ref_cnt));
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_profile_ref_count_increase(unit, ph, entries_per_set,
                                              idx, ref_cnt));

exit:
    SHR_FUNC_EXIT();
}

/******************************************************************************
 * LT manipulation
 */

/*!
 * \brief Set SyncE divisor setting.
 *
 * \param [in] unit Unit Number.
 * \param [in] clk_src Clock source type (Primary, Secondary).
 * \param [in] divisor Divisor setting.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_synce_clock_set_by_port(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    bcm_time_synce_divisor_setting_t *divisor)
{
    int dunit, idx;
    uint64_t val;
    bcm_port_t port;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t pc_entry = BCMLT_INVALID_HDL;
    const char *stage0_modes[] = XGS_TIME_PC_SYNCE_STAGE_0_MODE_STR;
    const char *stage1_modes[] = XGS_TIME_PC_SYNCE_STAGE_1_MODE_STR;
    const char *symbol[1];

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(divisor, SHR_E_PARAM);

    if (clk_src != bcmTimeSynceClockSourcePrimary &&
        clk_src != bcmTimeSynceClockSourceSecondary) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Select clock source. */
    idx = (clk_src == bcmTimeSynceClockSourcePrimary) ? 0 : 1;

    /* Assumes input index is logical port number. */
    port = divisor->index;

    /* Force to insert DEVICE_TS_SYNCE_CLK_CONTROLs entry. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_TS_SYNCE_CLK_CONTROLs, &entry));
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_EXISTS);

    /* Re-enable, so disable first. */
    val = 0;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, CLK_RECOVERYs, idx, &val, 1));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

    /* Serdes port configuration. */
    val = port;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, PORT_IDs, idx, &val, 1));

    symbol[0] = DIVIDE_BY_1s;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_symbol_add(entry, CLK_DIVISORs, idx,
                                            symbol, 1));

    /* Enable recov clk as valid, default it is invalid. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, OVERRIDEs, 1));

    val = 1;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, OVERRIDE_CLK_VALIDs, idx, &val, 1));

    /* Re-enable. */
    val = 1;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, CLK_RECOVERYs, idx, &val, 1));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

    /* Update PC_PORT_TIMESYNCs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PC_PORT_TIMESYNCs, &pc_entry));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(pc_entry, PORT_IDs, port));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(pc_entry, STAGE_0_MODEs,
            stage0_modes[divisor->stage0_mode]));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(pc_entry, STAGE_1_MODEs,
            stage1_modes[divisor->stage1_div]));

    val = ((divisor->stage0_sdm_whole & 0xFF) << 8 |
           (divisor->stage0_sdm_frac & 0xFF));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(pc_entry, FRACTIONAL_DIVISORs, val));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(pc_entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (entry != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry);
    }
    if (pc_entry != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(pc_entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get SyncE divisor setting.
 *
 * \param [in] unit Unit Number.
 * \param [in] clk_src Clock source type (Primary, Secondary).
 * \param [out] divisor Divisor setting.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_synce_clock_get_by_port(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    bcm_time_synce_divisor_setting_t *divisor)
{
    int dunit, idx;
    uint64_t val;
    uint32_t r_count, entry_num;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t pc_entry = BCMLT_INVALID_HDL;
    const char *str_p;
    const char *stage0_modes[] = XGS_TIME_PC_SYNCE_STAGE_0_MODE_STR;
    const char *stage1_modes[] = XGS_TIME_PC_SYNCE_STAGE_1_MODE_STR;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(divisor, SHR_E_PARAM);

    if (clk_src != bcmTimeSynceClockSourcePrimary &&
        clk_src != bcmTimeSynceClockSourceSecondary) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);
    bcm_time_synce_divisor_setting_t_init(divisor);

    /* Select clock source. */
    idx = (clk_src == bcmTimeSynceClockSourcePrimary) ? 0 : 1;

    /* Force to insert DEVICE_TS_SYNCE_CLK_CONTROLs entry. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_TS_SYNCE_CLK_CONTROLs, &entry));
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_EXISTS);

    /* Read DEVICE_TS_SYNCE_CLK_CONTROLs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_get(entry, CLK_RECOVERYs, idx,
                                     &val, 1, &r_count));
    if (r_count != 1 || val != 1) {
        SHR_EXIT();
    }
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_get(entry, PORT_IDs, idx,
                                     &val, 1, &r_count));
    divisor->index = val;
    divisor->input_src = bcmTimeSynceInputSourceTypePort;

    /* Read PC_PORT_TIMESYNCs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PC_PORT_TIMESYNCs, &pc_entry));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(pc_entry, PORT_IDs, val));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(pc_entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    /* Fetch stage 0. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_get(pc_entry, STAGE_0_MODEs, &str_p));
    entry_num = COUNTOF(stage0_modes);
    for (idx = 0; idx < entry_num; idx++) {
        if (!sal_strcmp(str_p, stage0_modes[idx])) {
            divisor->stage0_mode = idx;
        }
    }

    /* Fetch stage 1. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_get(pc_entry, STAGE_1_MODEs, &str_p));
    entry_num = COUNTOF(stage1_modes);
    for (idx = 0; idx < entry_num; idx++) {
        if (!sal_strcmp(str_p, stage1_modes[idx])) {
            divisor->stage1_div = idx;
        }
    }

    /* Fetch stage0_sdm. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(pc_entry, FRACTIONAL_DIVISORs, &val));
    divisor->stage0_sdm_whole = (val >> 8) & 0xFF;
    divisor->stage0_sdm_frac = (val) & 0xFF;

exit:
    if (entry != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry);
    }
    if (pc_entry != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(pc_entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Set syncE clock source squelch option.
 *
 * \param [in] unit Unit Number.
 * \param [in] clk_src Clock source type (Primary, Secondary).
 * \param [in] squelch synce clock source squelch setting.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_synce_clock_source_squelch_set(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    int squelch)
{
    int dunit, idx;
    uint64_t val;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    if (clk_src != bcmTimeSynceClockSourcePrimary &&
        clk_src != bcmTimeSynceClockSourceSecondary) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Select clock source. */
    idx = (clk_src == bcmTimeSynceClockSourcePrimary) ? 0 : 1;

    /* Force to insert DEVICE_TS_SYNCE_CLK_CONTROLs entry. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_TS_SYNCE_CLK_CONTROLs, &entry));
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_EXISTS);

    /* Re-enable, so disable first. */
    val = 0;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, CLK_RECOVERYs, idx, &val, 1));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

    val = (squelch) ? 0 : 1;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, OVERRIDEs, val));
    val = (squelch) ? 1 : 0;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, OVERRIDE_CLK_VALIDs, idx, &val, 1));

    /* Re-enable. */
    val = 1;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_add(entry, CLK_RECOVERYs, idx, &val, 1));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (entry != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get syncE clock source squelch option.
 *
 * \param [in] unit Unit Number.
 * \param [in] clk_src Clock source type (Primary, Secondary).
 * \param [out] squelch synce clock source squelch setting.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_synce_clock_source_squelch_get(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    int *squelch)
{
    int dunit, idx;
    uint32_t r_count;
    uint64_t val;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(squelch, SHR_E_PARAM);

    if (clk_src != bcmTimeSynceClockSourcePrimary &&
        clk_src != bcmTimeSynceClockSourceSecondary) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Select clock source. */
    idx = (clk_src == bcmTimeSynceClockSourcePrimary) ? 0 : 1;

    /* Force to insert DEVICE_TS_SYNCE_CLK_CONTROLs entry. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_TS_SYNCE_CLK_CONTROLs, &entry));
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_EXISTS);

    /* Read DEVICE_TS_SYNCE_CLK_CONTROLs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_get(entry, OVERRIDE_CLK_VALIDs, idx,
                                     &val, 1, &r_count));
    *squelch = val;

exit:
    if (entry != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get TOD LT entry.
 *
 * \param [in] unit Unit Number.
 * \param [out] tod Time of the day values.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_INTERNAL Auto-update is not working properly.
 */
static int
xgs_time_tod_entry_get(
    int unit,
    const char *tbl_name,
    bcm_time_tod_t *tod)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t fields[BCMI_LT_FIELD_MAX];
    int hw_update_supported;
    uint64_t auto_update, sec, nsec, adj;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(tod, SHR_E_PARAM);

    if (SHR_SUCCESS(bcmi_lt_field_validate(unit, tbl_name, HW_UPDATEs))) {
        hw_update_supported = 1;
    } else {
        hw_update_supported = 0;
    }

    bcmi_lt_entry_init(&lt_entry, fields);
    bcmi_lt_entry_field_add(unit, &lt_entry, TOD_SECs, 0, BCMI_LT_FIELD_F_GET);
    bcmi_lt_entry_field_add(unit, &lt_entry, TOD_NSECs, 0, BCMI_LT_FIELD_F_GET);
    bcmi_lt_entry_field_add(unit, &lt_entry, ADJUSTs, 0, BCMI_LT_FIELD_F_GET);

    /* Read hw-update fields only when they are valid. */
    if (hw_update_supported) {
        bcmi_lt_entry_field_add(unit, &lt_entry, HW_UPDATEs, 0,
                                BCMI_LT_FIELD_F_GET);
        bcmi_lt_entry_field_add(unit, &lt_entry, TOD_SEC_OPERs, 0,
                                BCMI_LT_FIELD_F_GET);
        bcmi_lt_entry_field_add(unit, &lt_entry, TOD_NSEC_OPERs, 0,
                                BCMI_LT_FIELD_F_GET);
        bcmi_lt_entry_field_add(unit, &lt_entry, ADJUST_OPERs, 0,
                                BCMI_LT_FIELD_F_GET);
        bcmi_lt_entry_field_symbol_add(unit, &lt_entry, OPERATIONAL_STATEs, "",
                                       BCMI_LT_FIELD_F_GET);
    }

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_get(unit, tbl_name, &lt_entry, NULL, NULL));

    if (hw_update_supported) {
        const char *st;

        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, HW_UPDATEs,
                                     &auto_update));
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_symbol_get(unit, &lt_entry, OPERATIONAL_STATEs,
                                            &st));

        if (auto_update &&
            sal_memcmp(st, SUCCESSs, sal_strlen(SUCCESSs))) {
            LOG_VERBOSE(BSL_LOG_MODULE,
                        (BSL_META_U(unit,
                                    "ToD auto-update is not working properly."
                                    "\n")));
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
    } else {
        auto_update = 0;
    }

    if (auto_update) {
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, TOD_SEC_OPERs, &sec));
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, TOD_NSEC_OPERs, &nsec));
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, ADJUST_OPERs, &adj));
    } else {
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, TOD_SECs, &sec));
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, TOD_NSECs, &nsec));
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_field_get(unit, &lt_entry, ADJUSTs, &adj));
    }

    tod->auto_update = auto_update;
    tod->ts.seconds = sec;
    tod->ts.nanoseconds = nsec;
    tod->ts_adjustment_counter_ns = adj;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set TOD LT entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] tod Time of the day values.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_tod_entry_set(
    int unit,
    const char *tbl_name,
    bcm_time_tod_t *tod)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t fields[BCMI_LT_FIELD_MAX];
    uint64_t auto_update, sec, nsec, adj;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(tod, SHR_E_PARAM);

    auto_update = tod->auto_update;
    sec = tod->ts.seconds;
    nsec = tod->ts.nanoseconds;
    adj = tod->ts_adjustment_counter_ns;

    bcmi_lt_entry_init(&lt_entry, fields);
    bcmi_lt_entry_field_add(unit, &lt_entry, TOD_SECs, sec,
                            BCMI_LT_FIELD_F_SET);
    bcmi_lt_entry_field_add(unit, &lt_entry, TOD_NSECs, nsec,
                            BCMI_LT_FIELD_F_SET);
    bcmi_lt_entry_field_add(unit, &lt_entry, ADJUSTs, adj,
                            BCMI_LT_FIELD_F_SET);

    /* Update hw-update field only when it is valid. */
    if (SHR_SUCCESS(bcmi_lt_field_validate(unit, tbl_name, HW_UPDATEs))) {
        bcmi_lt_entry_field_add(unit, &lt_entry, HW_UPDATEs, auto_update,
                                BCMI_LT_FIELD_F_SET);
    }

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_set(unit, tbl_name, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update ToD value.
 *
 * \param [in] unit Unit Number.
 * \param [in] tod Time of the day values.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_tod_set(
    int unit,
    uint32 stages,
    bcm_time_tod_t *tod)
{
    bcm_time_tod_t tod_st;
    char *tbl_name;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(tod, SHR_E_PARAM);

    if (stages & BCM_TIME_STAGE_EGRESS) {
        tbl_name = DEVICE_TS_TODs;
    } else if (stages & BCM_TIME_STAGE_MMU) {
        tbl_name = TM_TS_TODs;
    } else {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    if (!tod->auto_update) {
        SHR_IF_ERR_EXIT
            (xgs_time_tod_entry_set(unit, tbl_name, tod));
        SHR_EXIT();
    }

    /* Check if auto_update is supported. */
    if (SHR_FAILURE(bcmi_lt_field_validate(unit, tbl_name, HW_UPDATEs))) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Restart ToD auto-update operation by disabling and then enabling it. */
    tod->auto_update = 0;
    SHR_IF_ERR_EXIT
        (xgs_time_tod_entry_set(unit, tbl_name, tod));
    tod->auto_update = 1;
    SHR_IF_ERR_EXIT
        (xgs_time_tod_entry_set(unit, tbl_name, tod));

    /* Check if auto-update operation is working properly. */
    SHR_IF_ERR_EXIT
        (xgs_time_tod_entry_get(unit, tbl_name, &tod_st));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get ToD value.
 *
 * \param [in] unit Unit Number.
 * \param [out] tod Time of the day values.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_tod_get(
    int unit,
    uint32 stages,
    bcm_time_tod_t *tod)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field;
    char *tbl_name;

    SHR_FUNC_ENTER(unit);

    if (stages & BCM_TIME_STAGE_EGRESS) {
        tbl_name = DEVICE_TS_TODs;
    } else if (stages & BCM_TIME_STAGE_MMU) {
        tbl_name = TM_TS_TODs;
    } else {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Force to insert DEVICE_TS_TODs entry. */
    bcmi_lt_entry_init(&lt_entry, &field);
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_lt_entry_insert(unit, tbl_name, &lt_entry, NULL),
         SHR_E_EXISTS);

    /* Get DEVICE_TS_TODs entry. */
    SHR_IF_ERR_EXIT
        (xgs_time_tod_entry_get(unit, tbl_name, tod));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear port ingress/egress time config.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_port_timesync_config_clr(
    int unit,
    bcm_port_t port)
{
    int dunit, cnt, idx;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    static const char *lt_names[] = { PORT_ING_TS_PTPs,
                                      PORT_EGR_TS_PTPs };

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    cnt = COUNTOF(lt_names);

    for (idx = 0; idx < cnt; idx++) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate(dunit, lt_names[idx], &entry));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, PORT_IDs, port));

        /* Delete and insert again. */
        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmlt_entry_commit(entry,
                                BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL),
             SHR_E_NOT_FOUND);
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry,
                                BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL));

        (void)bcmlt_entry_free(entry);
        entry = BCMLT_INVALID_HDL;
    }

exit:
    if (entry != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Set LTs for BCM_PORT_TIMESYNC_DEFAULT mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] ts_config Timesync configuration.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_port_timesync_default_set(
    int unit,
    bcm_port_t port,
    bcm_port_timesync_config_t *ts_config)
{
    int dunit;
    bcmlt_entry_handle_t ientry = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t eentry = BCMLT_INVALID_HDL;
    uint64_t mac = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Force to insert PORT_ING_TS_PTPs entry. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_ING_TS_PTPs, &ientry));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(ientry, PORT_IDs, port));
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(ientry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_EXISTS);

    /* Force to insert PORT_EGR_TS_PTPs entry. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_EGR_TS_PTPs, &eentry));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eentry, PORT_IDs, port));
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(eentry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_EXISTS);

    /* Clear original configuration. */
    SHR_IF_ERR_EXIT
        (xgs_time_port_timesync_config_clr(unit, port));

    /* Set one-step timestamp configurations */
    if (ts_config->flags & BCM_PORT_TIMESYNC_ONE_STEP_TIMESTAMP) {
        /* Enable Correction updates for ingress and egress. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(ientry, CORRECTION_FIELDs, 1));

        /*
         * Enable for below situations:
         * 1. Ethernet port but not stack port
         * 2. Higig but not higig proxy. (no higig on SDKLT)
         */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(ientry, SIGN_FROM_TIMESTAMPs, 0));

        if (ts_config->flags &
            BCM_PORT_TIMESYNC_TIMESTAMP_CFUPDATE_ALL) {
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_symbol_add(eentry, CF_UPDATE_MODEs,
                                              PORT_BASED_ENABLEs));
        } else {
            /*
             * The ingress port is default enabled for correction
             * updates for one-step timestamping and hence the
             * EGR update mode is set to ingress based correction
             * updates.
            */
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_symbol_add(eentry, CF_UPDATE_MODEs,
                                              ING_UPDATE_BASED_ENABLEs));
        }

        /* Enable Source Address update for corrections. */
        if (!BCM_MAC_IS_ZERO(ts_config->src_mac_addr)) {
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_add(eentry, REPLACE_SRC_MACs, 1));
            bcmi_ltsw_util_mac_to_uint64(&mac, ts_config->src_mac_addr);
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_add(eentry, SRC_MACs, mac));
        }

    }

    /* Set two-step correction update enable. */
    if (ts_config->flags & BCM_PORT_TIMESYNC_TWO_STEP_TIMESTAMP) {
        /* Set two-step timestamping in mac for all event pkts. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eentry, TS_SYNCs, 1));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eentry, TS_DELAY_REQs, 1));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eentry, TS_PDELAY_REQs, 1));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eentry, TS_PDELAY_RESPs, 1));
    }

    /* Timesync Packet type bitmaps. */
    if (ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_INVALID) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(eentry, DROP_INVALID_IEEE1588_PKTs, 1));
    }

    /* Write to PORT_ING_TS_PTPs and PORT_EGR_TS_PTPs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(ientry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(eentry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (ientry != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(ientry);
    }
    if (eentry != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eentry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get LTs for BCM_PORT_TIMESYNC_DEFAULT mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] ts_config Timesync configuration.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_port_timesync_default_get(
    int unit,
    bcm_port_t port,
    bcm_port_timesync_config_t *ts_config)
{
    int dunit;
    uint64_t mac = 0, val;
    const char *str_p;
    bcmlt_entry_handle_t ientry = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t eentry = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(ts_config, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);
    ts_config->flags |= BCM_PORT_TIMESYNC_DEFAULT;

    /* Force to insert PORT_ING_TS_PTPs entry. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_ING_TS_PTPs, &ientry));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(ientry, PORT_IDs, port));
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(ientry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_EXISTS);

    /* Read PORT_ING_TS_PTPs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(ientry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    /* Force to insert PORT_EGR_TS_PTPs entry. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, PORT_EGR_TS_PTPs, &eentry));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eentry, PORT_IDs, port));
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(eentry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_EXISTS);

    /* Read PORT_EGR_TS_PTPs. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(eentry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    /* Get timesync packet type bitmaps. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eentry, DROP_INVALID_IEEE1588_PKTs, &val));
    if (val == 1) {
        ts_config->pkt_drop |= BCM_PORT_TIMESYNC_PKT_INVALID;
    }

    /* Get two-step timestamp configurations. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eentry, TS_SYNCs, &val));
    if (val == 1) {
        ts_config->flags |= BCM_PORT_TIMESYNC_TWO_STEP_TIMESTAMP;
    }

    /* Get one-step timestamp configurations. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(ientry, CORRECTION_FIELDs, &val));
    if (val == 1) {
        ts_config->flags |= BCM_PORT_TIMESYNC_ONE_STEP_TIMESTAMP;

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(eentry, CF_UPDATE_MODEs, &str_p));
        if (!sal_strcmp(str_p, PORT_BASED_ENABLEs)) {
            ts_config->flags |= BCM_PORT_TIMESYNC_TIMESTAMP_CFUPDATE_ALL;
        }

        /* Get Source Address update for corrections. */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(eentry, REPLACE_SRC_MACs, &val));
        if (val == 1) {
            SHR_IF_ERR_EXIT
                (bcmlt_entry_field_get(eentry, SRC_MACs, &mac));
            bcmi_ltsw_util_uint64_to_mac(ts_config->src_mac_addr, &mac);
        }
    }

exit:
    if (ientry != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(ientry);
    }
    if (eentry != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eentry);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get DEVICE_TS_PTP_MSG_CONTROL_PROFILE_ID value from PORT LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [out] prof_id Value of DEVICE_TS_PTP_MSG_CONTROL_PROFILE_IDf.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
lt_port_ptp_msg_ctrl_prof_id_get(
    int unit,
    int port,
    int *prof_id)
{
    SHR_FUNC_ENTER(unit);

    *prof_id = 0;
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_port_tab_get(unit, port,
                                BCMI_PT_DEVICE_TS_PTP_MSG_CONTROL_PROFILE_ID,
                                prof_id),
         SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set DEVICE_TS_PTP_MSG_CONTROL_PROFILE_ID value to PORT LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] prof_id Value of DEVICE_TS_PTP_MSG_CONTROL_PROFILE_IDf.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
lt_port_ptp_msg_ctrl_prof_id_set(
    int unit,
    int port,
    int prof_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmi_ltsw_port_tab_set(unit, port,
                                BCMI_PT_DEVICE_TS_PTP_MSG_CONTROL_PROFILE_ID,
                                prof_id));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get PTP message control.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] ts_config Timesync configuration.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_port_timesync_ptp_msg_ctrl_get(
    int unit,
    bcm_port_t port,
    bcm_port_timesync_config_t *ts_config)
{
    int prof_id;
    xgs_ptp_msg_control_t ctrl;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (lt_port_ptp_msg_ctrl_prof_id_get(unit, port, &prof_id));
    SHR_IF_ERR_EXIT
        (lt_device_ts_ptp_msg_ctrl_entry_get(unit, prof_id, &ctrl));

    ts_config->pkt_drop |= ctrl.drop;
    ts_config->pkt_tocpu |= ctrl.tocpu;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set PTP message control.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] ts_config Timesync configuration.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_port_timesync_ptp_msg_ctrl_set(
    int unit,
    bcm_port_t port,
    bcm_port_timesync_config_t *ts_config)
{
    int prof_id, prof_id_old;
    xgs_ptp_msg_control_t ctrl, ctrl_old;

    SHR_FUNC_ENTER(unit);

    ctrl.drop = ts_config->pkt_drop;
    ctrl.tocpu = ts_config->pkt_tocpu;

    /* Get the current settings. */
    SHR_IF_ERR_EXIT
        (lt_port_ptp_msg_ctrl_prof_id_get(unit, port, &prof_id_old));
    SHR_IF_ERR_EXIT
        (lt_device_ts_ptp_msg_ctrl_entry_get(unit, prof_id_old, &ctrl_old));

    /* Do nothing if no changes. */
    if (ctrl.drop == ctrl_old.drop &&
        ctrl.tocpu == ctrl_old.tocpu) {
        SHR_EXIT();
    }

    /* Update control settings. */
    SHR_IF_ERR_EXIT
        (xgs_time_ptp_msg_control_profile_entry_add(unit, &ctrl, &prof_id));
    SHR_IF_ERR_EXIT
        (xgs_time_ptp_msg_control_profile_entry_delete(unit, prof_id_old));
    SHR_IF_ERR_EXIT
        (lt_port_ptp_msg_ctrl_prof_id_set(unit, port, prof_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set port ingress/egress time config.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] ts_config Timesync configuration.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_port_timesync_config_set(
    int unit,
    bcm_port_t port,
    bcm_port_timesync_config_t *ts_config)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(ts_config, SHR_E_PARAM);

    /* Only support BCM_PORT_TIMESYNC_DEFAULT mode. */
    if ((ts_config->flags & BCM_PORT_TIMESYNC_DEFAULT) == 0) {
        SHR_IF_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Setup BCM_PORT_TIMESYNC_DEFAULT mode. */
    SHR_IF_ERR_EXIT
        (xgs_time_port_timesync_default_set(unit, port, ts_config));

    /* Setup PTP drop and to_cup actions. */
    SHR_IF_ERR_EXIT
        (xgs_time_port_timesync_ptp_msg_ctrl_set(unit, port, ts_config));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get port ingress/egress time config.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [out] ts_config Timesync configuration.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
xgs_time_port_timesync_config_get(
    int unit,
    bcm_port_t port,
    bcm_port_timesync_config_t *ts_config)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(ts_config, SHR_E_PARAM);

    bcm_port_timesync_config_t_init(ts_config);

    /* Get BCM_PORT_TIMESYNC_DEFAULT mode settings. */
    SHR_IF_ERR_EXIT
        (xgs_time_port_timesync_default_get(unit, port, ts_config));

    /* Get PTP drop and to_cup actions. */
    SHR_IF_ERR_EXIT
        (xgs_time_port_timesync_ptp_msg_ctrl_get(unit, port, ts_config));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get field value from DEVICE_TS_CONTROL LT.
 *
 * \param [in] unit Unit number.
 * \param [in] fld_name Field name.
 * \param [out] val Field value.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_device_ts_control_field_get(
    int unit,
    const char *fld_name,
    int *val)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field;
    bcmlt_field_def_t fld_def;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmi_lt_field_def_get(unit, DEVICE_TS_CONTROLs, fld_name, &fld_def));

    lt_entry.fields = &field;
    lt_entry.nfields = 1;
    lt_entry.attr = 0;

    sal_memset(&field, 0, sizeof(field));
    field.fld_name = fld_name;
    field.flags = BCMI_LT_FIELD_F_GET;
    if (fld_def.symbol) {
        field.flags |= BCMI_LT_FIELD_F_SYMBOL;
    }

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_get(unit, DEVICE_TS_CONTROLs, &lt_entry, NULL, NULL));

    if (!sal_strcmp(fld_name, TIMESTAMPING_MODEs)) {
        if (!sal_strcmp(field.u.sym_val, TIMESTAMP_32_MODEs)) {
            *val = bcmTimesyncTimestampingMode32bit;
        } else {
            *val = bcmTimesyncTimestampingMode48bit;
        }
    } else if (!sal_strcmp(fld_name, IEEE1588_VERSIONs)) {
        if (!sal_strcmp(field.u.sym_val, VER_EQ_2s)) {
            *val = 0;
        } else {
            *val = 1;
        }
    } else if (!sal_strcmp(fld_name, PARSE_NTP_DST_L4_UDP_PORTs)) {
        *val = field.u.val;
    } else {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set field value to DEVICE_TS_CONTROL LT.
 *
 * \param [in] unit Unit number.
 * \param [in] fld_name Field name.
 * \param [in] val Field value.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
lt_device_ts_control_field_set(
    int unit,
    const char *fld_name,
    int val)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field;
    bcmlt_field_def_t fld_def;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmi_lt_field_def_get(unit, DEVICE_TS_CONTROLs, fld_name, &fld_def));

    lt_entry.fields = &field;
    lt_entry.nfields = 1;
    lt_entry.attr = 0;

    sal_memset(&field, 0, sizeof(field));
    field.fld_name = fld_name;
    field.flags = BCMI_LT_FIELD_F_SET;
    if (fld_def.symbol) {
        field.flags |= BCMI_LT_FIELD_F_SYMBOL;
    }

    if (!sal_strcmp(fld_name, TIMESTAMPING_MODEs)) {
        if (val == bcmTimesyncTimestampingMode32bit) {
            field.u.sym_val = TIMESTAMP_32_MODEs;
        } else {
            field.u.sym_val = TIMESTAMP_48_MODEs;
        }
    } else if (!sal_strcmp(fld_name, IEEE1588_VERSIONs)) {
        if (val == 0) {
            field.u.sym_val = VER_EQ_2s;
        } else {
            field.u.sym_val = VER_GT_OR_EQ_2s;
        }
    } else if (!sal_strcmp(fld_name, PARSE_NTP_DST_L4_UDP_PORTs)) {
        field.u.val = val;
    } else {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_set(unit, DEVICE_TS_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_time_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (xgs_time_profile_init(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_time_deinit(int unit)
{
    bcmi_ltsw_profile_hdl_t ph = BCMI_LTSW_PROFILE_DEVICE_TS_PTP_MSG_CONTROL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit, ph),
         SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_time_synce_clock_set(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    bcm_time_synce_divisor_setting_t *divisor)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(divisor, SHR_E_PARAM);

    switch(divisor->input_src) {
        case bcmTimeSynceInputSourceTypePort:
            SHR_IF_ERR_EXIT
                (xgs_time_synce_clock_set_by_port(unit, clk_src, divisor));
            break;
        case bcmTimeSynceInputSourceTypePLL:
                SHR_ERR_EXIT(SHR_E_UNAVAIL);
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_time_synce_clock_get(
    int unit,
    bcm_time_synce_clock_src_type_t clk_src,
    bcm_time_synce_divisor_setting_t *divisor)
{
    return xgs_time_synce_clock_get_by_port(unit, clk_src, divisor);
}

int
xgs_ltsw_time_synce_clock_source_control_set(
    int unit,
    bcm_time_synce_clock_source_config_t *clk_src_config,
    bcm_time_synce_clock_source_control_t control,
    int value)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(clk_src_config, SHR_E_PARAM);

    switch (control) {
        case bcmTimeSynceClockSourceControlSquelch:
            SHR_IF_ERR_EXIT
                (xgs_time_synce_clock_source_squelch_set(
                    unit, clk_src_config->clk_src, value));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
   }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_time_synce_clock_source_control_get(
    int unit,
    bcm_time_synce_clock_source_config_t *clk_src_config,
    bcm_time_synce_clock_source_control_t control,
    int *value)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(clk_src_config, SHR_E_PARAM);

    switch (control) {
        case bcmTimeSynceClockSourceControlSquelch:
            SHR_IF_ERR_EXIT
                (xgs_time_synce_clock_source_squelch_get(
                    unit, clk_src_config->clk_src, value));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
   }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_time_tod_set(
    int unit,
    uint32 stages,
    bcm_time_tod_t *tod)
{
    if (stages & (BCM_TIME_STAGE_EGRESS)) {
        return xgs_time_tod_set(unit, stages, tod);
    }

    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_time_tod_get(
    int unit,
    uint32 stages,
    bcm_time_tod_t *tod)
{
    if (stages & (BCM_TIME_STAGE_EGRESS)) {
        return xgs_time_tod_get(unit, stages, tod);
    }

    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_time_port_timesync_config_set(
    int unit,
    bcm_port_t port,
    int config_count,
    bcm_port_timesync_config_t *config_array)
{
    int cnt;
    bcm_port_timesync_config_t *ts_config;

    SHR_FUNC_ENTER(unit);

    /* Clear timesync settings if config count is 0 */
    if (config_count == 0) {
        SHR_IF_ERR_EXIT
            (xgs_time_port_timesync_config_clr(unit, port));
        SHR_EXIT();
    }

    /* Sanitize */
    if (config_count > XGS_TIMESYNC_CONFIG_MAX ||
        config_count < 0 ||
        !config_array) {
        SHR_ERR_EXIT(BCM_E_PARAM);
    }

    /* Set timesync profiles */
    for (cnt = 0; cnt < config_count; cnt++) {
        ts_config = (bcm_port_timesync_config_t *) (config_array + cnt);
        SHR_IF_ERR_EXIT
            (xgs_time_port_timesync_config_set(unit, port, ts_config));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_time_port_timesync_config_get(
    int unit,
    bcm_port_t port,
    int config_count,
    bcm_port_timesync_config_t *config_array,
    int *array_count)
{
    int cnt;
    bcm_port_timesync_config_t *ts_config;

    SHR_FUNC_ENTER(unit);

    /* Sanitize */
    if (config_count <= 0 ||
        config_count > XGS_TIMESYNC_CONFIG_MAX ||
        !config_array ||
        !array_count) {
        SHR_ERR_EXIT(BCM_E_PARAM);
    }

    /* Get timesync profiles */
    for (cnt = 0; cnt < config_count; cnt++) {
        ts_config = (bcm_port_timesync_config_t*)(config_array + cnt);
        SHR_IF_ERR_EXIT
            (xgs_time_port_timesync_config_get(unit, port, ts_config));
    }
    *array_count = cnt;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_time_switch_control_set(
    int unit,
    bcm_switch_control_t type,
    int arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmSwitchTimesyncEgressTimestampingMode:
            SHR_IF_ERR_EXIT
                (lt_device_ts_control_field_set(unit, TIMESTAMPING_MODEs, arg));
            break;
        case bcmSwitchTimesyncEgressVersion:
        case bcmSwitchTimesyncIngressVersion:
            SHR_IF_ERR_EXIT
                (lt_device_ts_control_field_set(unit, IEEE1588_VERSIONs, arg));
            break;
        case bcmSwitchNtpL4DestPort:
            SHR_IF_ERR_EXIT
                (lt_device_ts_control_field_set(unit,
                                                PARSE_NTP_DST_L4_UDP_PORTs,
                                                arg));
            break;
        case bcmSwitchTimesyncLiveWireToD:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_time_switch_control_get(
    int unit,
    bcm_switch_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmSwitchTimesyncEgressTimestampingMode:
            SHR_IF_ERR_EXIT
                (lt_device_ts_control_field_get(unit, TIMESTAMPING_MODEs, arg));
            break;
        case bcmSwitchTimesyncEgressVersion:
        case bcmSwitchTimesyncIngressVersion:
            SHR_IF_ERR_EXIT
                (lt_device_ts_control_field_get(unit, IEEE1588_VERSIONs, arg));
            break;
        case bcmSwitchNtpL4DestPort:
            SHR_IF_ERR_EXIT
                (lt_device_ts_control_field_get(unit,
                                                PARSE_NTP_DST_L4_UDP_PORTs,
                                                arg));
            break;
        case bcmSwitchTimesyncLiveWireToD:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_time_switch_control_port_set(
    int unit,
    bcm_port_t port,
    bcm_switch_control_t type,
    int arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmSwitchNtpResidenceTimeUpdate:
            SHR_IF_ERR_EXIT
                (bcmi_ltsw_port_tab_set(unit, port, BCMI_PT_NTP_TC, arg));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_time_switch_control_port_get(
    int unit,
    bcm_port_t port,
    bcm_switch_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmSwitchNtpResidenceTimeUpdate:
            SHR_IF_ERR_EXIT
                (bcmi_ltsw_port_tab_get(unit, port, BCMI_PT_NTP_TC, arg));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

