/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/common/multicast.h>
#include <bcm_int/control.h>
#include <bcm_int/ltsw_dispatch.h>

#include <bcm_int/ltsw/xgs/flow.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/flow.h>
#include <bcm_int/ltsw/flow_int.h>
#include <bcm_int/ltsw/qos.h>
#include <bcm_int/ltsw/sbr.h>
#include <bcm_int/ltsw/vlan.h>
#include <bcm_int/ltsw/l3.h>
#include <bcm_int/ltsw/l3_egress.h>
#include <bcm_int/ltsw/flexctr.h>
#include <bcm_int/ltsw/tunnel.h>
#include <bcm_int/ltsw/index_table_mgmt.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/types.h>

#include <shr/shr_debug.h>
#include <sal/sal_time.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_FLOW

/******************************************************************************
 * Private functions
 */


/*! Index to the MTU profile entry which disables MTU check. */
#define FLOW_PORT_ENCAP_MTU_PROFILE_DEF   (0)

/*
 * \brief Port encap MTU profile structure.
 *
 * This data structure is used to identify the profile structure for MTU
 * check.
 */
typedef struct port_encap_mtu_profile_s {
    bool     enable;
    uint16_t mtu;
} port_encap_mtu_profile_t;

static const char *action_if_not_present_str[] = {
    NO_ACTIONs,
    ADD_VLAN_TPIDs,
    "INVALID"
};

/* L2 tag action if not present enum definition. */
typedef enum action_if_not_present_sz_e {
    ACTION_IF_NOT_PRESENT_NO_ACTION = 0,
    ACTION_IF_NOT_PRESENT_ADD_VID_TPID = 1,
    ACTION_IF_NOT_PRESENT_SZ_CNT
} action_if_not_present_sz_t;

static const char *action_if_present_str[] = {
    NO_ACTIONs,
    REPLACE_VLAN_TPIDs,
    REPLACE_VLANs,
    DELETEs,
    REPLACE_VLAN_PRI_TPIDs,
    REPLACE_VLAN_PRIs,
    REPLACE_PRIs,
    REPLACE_TPIDs,
    "INVALID"
};

/* L2 tag action if present enum definition. */
typedef enum action_if_present_sz_e {
    ACTION_IF_PRESENT_NO_ACTION = 0,
    ACTION_IF_PRESENT_REPLACE_VID_TPID = 1,
    ACTION_IF_PRESENT_REPLACE_VID_ONLY = 2,
    ACTION_IF_PRESENT_DELETE = 3,
    ACTION_IF_PRESENT_REPLACE_VID_PRI_TPID = 4,
    ACTION_IF_PRESENT_REPLACE_VID_PRI_ONLY = 5,
    ACTION_IF_PRESENT_REPLACE_PRI_ONLY = 6,
    ACTION_IF_PRESENT_REPLACE_TPID_ONLY = 7,
    ACTION_IF_PRESENT_SZ_CNT
} action_if_present_sz_t;

typedef struct ing_adapt_user_data_s {
        bcm_flow_match_traverse_cb cb;
        void *user_data;
} ing_adapt_user_data_t;

/*!
 * \brief Get vlan action if present from sybmol.
 *
 * \param [in] unit Unit number.
 * \param [in] symbol String.
 * \param [out] value label action.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
action_if_present_symbol_to_scalar(int unit, const char *symbol,
                                   uint64_t *value)
{
    int i = 0;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i< ACTION_IF_PRESENT_SZ_CNT; i++) {
        if (!sal_strcmp(symbol, action_if_present_str[i])) {
            break;
        }
    }

    if (i >= ACTION_IF_PRESENT_SZ_CNT) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

    *value = i;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get vlan action if present sybmol from value.
 *
 * \param [in] unit Unit number.
 * \param [in] value load balance mode.
 * \param [out] symbol String.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
action_if_present_scalar_to_symbol(int unit, uint64_t value,
                                    const char **symbol)
{
    SHR_FUNC_ENTER(unit);

    if (value >= ACTION_IF_PRESENT_SZ_CNT) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

    *symbol = action_if_present_str[value];

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get vlan action if not present from sybmol.
 *
 * \param [in] unit Unit number.
 * \param [in] symbol String.
 * \param [out] value label action.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
action_if_not_present_symbol_to_scalar(int unit, const char *symbol,
                                       uint64_t *value)
{
    int i = 0;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i< ACTION_IF_NOT_PRESENT_SZ_CNT; i++) {
        if (!sal_strcmp(symbol, action_if_not_present_str[i])) {
            break;
        }
    }

    if (i >= ACTION_IF_NOT_PRESENT_SZ_CNT) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

    *value = i;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get vlan action if present sybmol from value.
 *
 * \param [in] unit Unit number.
 * \param [in] value load balance mode.
 * \param [out] symbol String.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
action_if_not_present_scalar_to_symbol(int unit, uint64_t value,
                                        const char **symbol)
{
    SHR_FUNC_ENTER(unit);

    if (value >= ACTION_IF_NOT_PRESENT_SZ_CNT) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

    *symbol = action_if_not_present_str[value];

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the parameters for tunnel termination configuration.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Tunnel termination info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_term_param_validation(int unit, bcmint_flow_hw_opt_type_t opt,
                                      bcm_flow_tunnel_terminator_t *info)
{
    uint32_t supported_items = 0;

    SHR_FUNC_ENTER(unit);

    /* Validate flow option vs criteria. */
    if (info->flow_option == BCMINT_FLOW_OPT_ID_LOOKUP_IPV6_DIP_TERM_TUNNEL) {
        if (!(info->valid_elements  & BCM_FLOW_TUNNEL_TERM_DIP6_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "DIP6 must be valid for \
                                            LOOKUP_IPV6_DIP_TERM_TUNNEL!\n")));
        }
    }

    /* Validate flow handle vs elements. */
    if ((info->flow_handle == BCMINT_FLOW_ID_VXLAN) &&
        (!(info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_VALID))) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "DIP6 must be valid for VXLAN IPv6!\n")));
    }

    if (info->flow_handle == BCMINT_FLOW_ID_VXLAN) {
        supported_items = BCM_FLOW_TUNNEL_TERM_VLAN_VALID |
                          BCM_FLOW_TUNNEL_TERM_DIP6_VALID |
                          BCM_FLOW_TUNNEL_TERM_SIP6_VALID |
                          BCM_FLOW_TUNNEL_TERM_VLAN_MASK_VALID |
                          BCM_FLOW_TUNNEL_TERM_SIP6_MASK_VALID |
                          BCM_FLOW_TUNNEL_TERM_DIP6_MASK_VALID |
                          BCM_FLOW_TUNNEL_TERM_CLASS_ID_VALID;
    } else if (info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN) {
        supported_items = BCM_FLOW_TUNNEL_TERM_VLAN_VALID |
                          BCM_FLOW_TUNNEL_TERM_DIP_VALID |
                          BCM_FLOW_TUNNEL_TERM_SIP_VALID |
                          BCM_FLOW_TUNNEL_TERM_VLAN_MASK_VALID |
                          BCM_FLOW_TUNNEL_TERM_SIP_MASK_VALID |
                          BCM_FLOW_TUNNEL_TERM_DIP_MASK_VALID |
                          BCM_FLOW_TUNNEL_TERM_CLASS_ID_VALID;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Wrong flow handle!\n")));
    }

    if (info->valid_elements & (~supported_items)) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Elements:supported(%d)/provided(%d)!\n"),
                                        supported_items, info->valid_elements));
    }

    /* Validate required elements. */
     if (info->flow_handle == BCMINT_FLOW_ID_VXLAN) {
         supported_items = BCM_FLOW_TUNNEL_TERM_DIP6_VALID;
     } else if (info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN) {
         supported_items = BCM_FLOW_TUNNEL_TERM_DIP_VALID;
     } else {
         SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                             (BSL_META_U(unit, "Wrong flow handle!\n")));
     }

     if ((info->valid_elements & supported_items) != supported_items) {
         SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                             (BSL_META_U(unit, "Elements:required(%d)/provided(%d)!\n"),
                                         supported_items, info->valid_elements));
     }

     /* Validate contorl flags */
     supported_items = BCM_TUNNEL_REPLACE |
                       BCM_TUNNEL_TERM_UDP_CHECKSUM_ENABLE |
                       BCM_TUNNEL_TERM_USE_OUTER_DSCP |
                       BCM_TUNNEL_TERM_USE_OUTER_PCP |
                       BCM_TUNNEL_TERM_USE_OUTER_TTL |
                       BCM_TUNNEL_TERM_KEEP_INNER_DSCP;
     if (info->flags & (~supported_items)) {
         SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                             (BSL_META_U(unit, "Flags:supported(%d)/provided(%d)!\n"),
                                         supported_items, info->flags));
     }

     /* Bud node not supported. */
     if (info->multicast_flag == BCM_FLOW_MULTICAST_TUNNEL_STATE_BUD_ENABLE) {
         SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                             (BSL_META_U(unit, "Bud node not supported.!\n")));
     }

     /* Mask should be provided for TCAM while should not for HASH. */
     if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_MASK_VALID) {
        if ((info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP6_VALID) &&
            (!(info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP6_MASK_VALID))) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        if ((info->valid_elements & BCM_FLOW_TUNNEL_TERM_VLAN_VALID) &&
            (!(info->valid_elements & BCM_FLOW_TUNNEL_TERM_VLAN_MASK_VALID))) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
     } else {
         if ((info->valid_elements & BCM_FLOW_TUNNEL_TERM_VLAN_MASK_VALID) ||
             (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP6_MASK_VALID)) {
             SHR_ERR_EXIT(SHR_E_PARAM);
         }
     }
     if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP_MASK_VALID) {
        if ((info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP_VALID) &&
            (!(info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP_MASK_VALID))) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        if ((info->valid_elements & BCM_FLOW_TUNNEL_TERM_VLAN_VALID) &&
            (!(info->valid_elements & BCM_FLOW_TUNNEL_TERM_VLAN_MASK_VALID))) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
     } else {
         if ((info->valid_elements & BCM_FLOW_TUNNEL_TERM_VLAN_MASK_VALID) ||
             (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP_MASK_VALID)) {
             SHR_ERR_EXIT(SHR_E_PARAM);
         }
     }

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Determine the logical table based on termination configuration.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  info      Tunnel termination info structure.
 * \param [out] lt_name   Logical table for tunnel termination.
 *
 * \retval NONE
 */
static void
xgs_flow_tunnel_term_lt_determine(int unit,
                                  bcm_flow_tunnel_terminator_t *info,
                                  const char **lt_name)
{
    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_VALID) {
        if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP6_VALID) {
            if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_MASK_VALID) {
                *lt_name = TNL_L2_VXLAN_DECAP_OVID_IPV6s;
            } else {
                *lt_name = TNL_L2_VXLAN_DECAP_OVID_IPV6_EMs;
            }
        } else {
            if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_MASK_VALID) {
                *lt_name = TNL_L2_VXLAN_DECAP_OVID_DST_IPV6s;
            } else {
                *lt_name = TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EMs;
            }
        }
    } else {
        if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP_VALID) {
            if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP_MASK_VALID) {
                *lt_name = TNL_L2_VXLAN_DECAP_OVID_IPV4s;
            } else {
                *lt_name = TNL_L2_VXLAN_DECAP_OVID_IPV4_EMs;
            }
        } else {
            if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP_MASK_VALID) {
                *lt_name = TNL_L2_VXLAN_DECAP_OVID_DST_IPV4s;
            } else {
                *lt_name = TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EMs;
            }
        }
    }
}

/*!
 * \brief Determine the termination criteria based on logical table.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  lt_name   Logical table for tunnel termination.
 * \param [out] info      Tunnel termination info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_term_criteria_determine(int unit,
                                        const char *lt_name,
                                        bcm_flow_tunnel_terminator_t *info)
{
    SHR_FUNC_ENTER(unit);

    if (lt_name == TNL_L2_VXLAN_DECAP_OVID_IPV6_EMs) {
        info->valid_elements = BCM_FLOW_TUNNEL_TERM_VLAN_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP6_VALID |
                               BCM_FLOW_TUNNEL_TERM_SIP6_VALID;
        info->flow_handle = BCMINT_FLOW_ID_VXLAN;
        info->type = bcmTunnelTypeVxlan6;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EMs) {
        info->valid_elements = BCM_FLOW_TUNNEL_TERM_VLAN_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP6_VALID;
        info->flow_handle = BCMINT_FLOW_ID_VXLAN;
        info->type = bcmTunnelTypeVxlan6;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_OVID_IPV6s) {
        info->valid_elements = BCM_FLOW_TUNNEL_TERM_VLAN_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP6_VALID |
                               BCM_FLOW_TUNNEL_TERM_SIP6_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP6_MASK_VALID |
                               BCM_FLOW_TUNNEL_TERM_SIP6_MASK_VALID;
        info->flow_handle = BCMINT_FLOW_ID_VXLAN;
        info->type = bcmTunnelTypeVxlan6;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_OVID_DST_IPV6s) {
        info->valid_elements = BCM_FLOW_TUNNEL_TERM_VLAN_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP6_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP6_MASK_VALID;
        info->flow_handle = BCMINT_FLOW_ID_VXLAN;
        info->type = bcmTunnelTypeVxlan6;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_OVID_IPV4_EMs) {
        info->valid_elements = BCM_FLOW_TUNNEL_TERM_VLAN_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP_VALID |
                               BCM_FLOW_TUNNEL_TERM_SIP_VALID;
        info->flow_handle = BCMINT_FLOW_ID_CLASSIC_VXLAN;
        info->type = bcmTunnelTypeVxlan;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EMs) {
        info->valid_elements = BCM_FLOW_TUNNEL_TERM_VLAN_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP_VALID;
        info->flow_handle = BCMINT_FLOW_ID_CLASSIC_VXLAN;
        info->type = bcmTunnelTypeVxlan;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_OVID_IPV4s) {
        info->valid_elements = BCM_FLOW_TUNNEL_TERM_VLAN_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP_VALID |
                               BCM_FLOW_TUNNEL_TERM_SIP_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP_MASK_VALID |
                               BCM_FLOW_TUNNEL_TERM_SIP_MASK_VALID;
        info->flow_handle = BCMINT_FLOW_ID_CLASSIC_VXLAN;
        info->type = bcmTunnelTypeVxlan;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_OVID_DST_IPV4s) {
        info->valid_elements = BCM_FLOW_TUNNEL_TERM_VLAN_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP_VALID |
                               BCM_FLOW_TUNNEL_TERM_DIP_MASK_VALID;
        info->flow_handle = BCMINT_FLOW_ID_CLASSIC_VXLAN;
        info->type = bcmTunnelTypeVxlan;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad lt:%s!\n"), lt_name));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set key info to LT entry handle.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  info      Tunnel termination info structure.
 * \param [in]  entry_hd  LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_term_key_set(int unit,
                             bcm_flow_tunnel_terminator_t *info,
                             bcmlt_entry_handle_t entry_hd)
{
    uint64 set_ipv6_val[2] = {0};

    SHR_FUNC_ENTER(unit);

    /*
     * Vlan ID is option from API aspect but must for LT.
     * If not provided by API then 0 will be set to LT.
     */
    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_VLAN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, OVIDs, info->vlan));
        if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_VLAN_MASK_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OVID_MASKs, info->vlan_mask));
        } else {
            /* If no valid, make sure it's tcam case. */
            if ((info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_MASK_VALID) ||
                (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP_MASK_VALID)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hd, OVID_MASKs, 0));
                }
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, OVIDs, 0x0));
        /* Set default value for tcam case. */
        if ((info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_MASK_VALID) ||
            (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP_MASK_VALID)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OVID_MASKs, 0));
            }
    }

    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_VALID) {
        bcmi_ltsw_util_ip6_to_uint64(set_ipv6_val, &(info->dip6));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, OUTER_DST_IPV6_LOWERs,
                                   set_ipv6_val[0]));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, OUTER_DST_IPV6_UPPERs,
                                   set_ipv6_val[1]));
        if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_MASK_VALID) {
            bcmi_ltsw_util_ip6_to_uint64(set_ipv6_val, &(info->dip6_mask));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_DST_IPV6_LOWER_MASKs,
                                       set_ipv6_val[0]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_DST_IPV6_UPPER_MASKs,
                                       set_ipv6_val[1]));

        }
        if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP6_VALID) {
            bcmi_ltsw_util_ip6_to_uint64(set_ipv6_val, &(info->sip6));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV6_LOWERs,
                                       set_ipv6_val[0]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV6_UPPERs,
                                       set_ipv6_val[1]));
            if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP6_MASK_VALID) {
                bcmi_ltsw_util_ip6_to_uint64(set_ipv6_val, &(info->sip6_mask));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV6_LOWER_MASKs,
                                           set_ipv6_val[0]));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV6_UPPER_MASKs,
                                           set_ipv6_val[1]));
            }
        }
    } else {
        if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_DST_IPV4s, info->dip));
            if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP_MASK_VALID) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hd, OUTER_DST_IPV4_MASKs,
                                           info->dip_mask));
            }
        }
        if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV4s, info->sip));

            if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP_MASK_VALID) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV4_MASKs,
                                           info->sip_mask));
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get key info from LT entry handle.
 *
 * \param [in]   unit      Unit number.
 * \param [out]  info      Tunnel termination info structure.
 * \param [in]   entry_hd  LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_term_key_get(int unit,
                             bcm_flow_tunnel_terminator_t *info,
                             const bcmlt_entry_handle_t entry_hd)
{
    uint64_t get_val;
    uint64 get_ipv6_val[2] = {0};

    SHR_FUNC_ENTER(unit);

    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_VLAN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OVIDs, &get_val));
        info->vlan = get_val;
    }
    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_VLAN_MASK_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OVID_MASKs, &get_val));
        info->vlan_mask = get_val;
    }

    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_DST_IPV6_LOWERs,
                                   &get_ipv6_val[0]));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_DST_IPV6_UPPERs,
                                   &get_ipv6_val[1]));
        bcmi_ltsw_util_uint64_to_ip6(&(info->dip6), get_ipv6_val);
    }
    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP6_MASK_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_DST_IPV6_LOWER_MASKs,
                                   &get_ipv6_val[0]));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_DST_IPV6_UPPER_MASKs,
                                   &get_ipv6_val[1]));
        bcmi_ltsw_util_uint64_to_ip6(&(info->dip6_mask), get_ipv6_val);
    }
    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP6_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_SRC_IPV6_LOWERs,
                                   &get_ipv6_val[0]));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_SRC_IPV6_UPPERs,
                                   &get_ipv6_val[1]));
        bcmi_ltsw_util_uint64_to_ip6(&(info->sip6), get_ipv6_val);
    }
    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP6_MASK_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_SRC_IPV6_LOWER_MASKs,
                                   &get_ipv6_val[0]));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_SRC_IPV6_UPPER_MASKs,
                                   &get_ipv6_val[1]));
        bcmi_ltsw_util_uint64_to_ip6(&(info->sip6_mask), get_ipv6_val);
    }
    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_DST_IPV4s, &get_val));
        info->dip = get_val;
    }
    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_DIP_MASK_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_DST_IPV4_MASKs, &get_val));
        info->dip_mask = get_val;
    }
    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_SRC_IPV4s, &get_val));
        info->sip = get_val;
    }
    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_SIP_MASK_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_SRC_IPV4_MASKs, &get_val));
        info->sip_mask = get_val;
    }

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set data info to LT entry handle.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  info      Tunnel termination info structure.
 * \param [in]  entry_hd  LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_term_data_set(int unit,
                              bcm_flow_tunnel_terminator_t *info,
                              bcmlt_entry_handle_t entry_hd)
{
    SHR_FUNC_ENTER(unit);

    if (info->flags & BCM_TUNNEL_TERM_UDP_CHECKSUM_ENABLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, IGNORE_UDP_CHKSUMs, FALSE));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, IGNORE_UDP_CHKSUMs, TRUE));
    }

    if (info->flags & BCM_TUNNEL_TERM_USE_OUTER_TTL) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, USE_TNL_HDR_TTLs, TRUE));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, USE_TNL_HDR_TTLs, FALSE));
    }

    if (info->flags & BCM_TUNNEL_TERM_KEEP_INNER_DSCP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, KEEP_PAYLOAD_DSCPs, TRUE));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, KEEP_PAYLOAD_DSCPs, FALSE));
    }

    if (info->flags & BCM_TUNNEL_TERM_USE_OUTER_DSCP) {
        SHR_IF_ERR_VERBOSE_EXIT
              (bcmlt_entry_field_symbol_add(entry_hd, TNL_HDR_FOR_PHBs,
                                            USE_TNL_L3_DSCP_FOR_PHBs));
    } else if (info->flags & BCM_TUNNEL_TERM_USE_OUTER_PCP) {
        SHR_IF_ERR_VERBOSE_EXIT
              (bcmlt_entry_field_symbol_add(entry_hd, TNL_HDR_FOR_PHBs,
                                            USE_TNL_L2_DOT1P_CFI_FOR_PHBs));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
              (bcmlt_entry_field_symbol_add(entry_hd, TNL_HDR_FOR_PHBs, NONEs));
    }

    if (info->valid_elements & BCM_FLOW_TUNNEL_TERM_CLASS_ID_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, CLASS_IDs, info->class_id));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get data info from LT entry handle.
 *
 * \param [in]   unit      Unit number.
 * \param [out]  info      Tunnel termination info structure.
 * \param [in]   entry_hd  LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_term_data_get(int unit,
                              bcm_flow_tunnel_terminator_t *info,
                              const char *lt_name,
                              const bcmlt_entry_handle_t entry_hd)
{
    uint64_t get_val;
    const char* symbol = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, IGNORE_UDP_CHKSUMs, &get_val));
    if (get_val == 0) {
        info->flags |= BCM_TUNNEL_TERM_UDP_CHECKSUM_ENABLE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, USE_TNL_HDR_TTLs, &get_val));
    if (get_val != 0) {
        info->flags |= BCM_TUNNEL_TERM_USE_OUTER_TTL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, KEEP_PAYLOAD_DSCPs, &get_val));
    if (get_val != 0) {
        info->flags |= BCM_TUNNEL_TERM_KEEP_INNER_DSCP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hd, TNL_HDR_FOR_PHBs, &symbol));
    if (!sal_strcmp(symbol, USE_TNL_L3_DSCP_FOR_PHBs)) {
        info->flags |= BCM_TUNNEL_TERM_USE_OUTER_DSCP;
    } else if (!sal_strcmp(symbol, USE_TNL_L2_DOT1P_CFI_FOR_PHBs)) {
        info->flags |= BCM_TUNNEL_TERM_USE_OUTER_PCP;
    } else {
        /* Do nothing. */
    }

    /* Bud node not supported. */
    info->multicast_flag |= BCM_FLOW_MULTICAST_TUNNEL_STATE_BUD_DISABLE;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, CLASS_IDs, &get_val));
    info->class_id = (uint32_t)get_val;

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Confingure pbmp info to LT entry handle.
 *
 * \param [in]  unit           Unit number.
 * \param [out] info           Tunnel termination info structure.
 * \param [in]  entry_hd_read  LT handle.
 * \param [in]  entry_hd       LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_term_pbmp_profile_ctrl(int unit,
                                       bcmint_flow_hw_opt_type_t opt,
                                       bcm_flow_tunnel_terminator_t *info,
                                       bcmlt_entry_handle_t entry_hd_read,
                                       bcmlt_entry_handle_t entry_hd)
{
    bcmi_ltsw_tunnel_decap_port_profile_t entry;
    int idx = 0;
    int old_idx = 0;
    uint64_t get_val;

    /*!
     * Created by tunnel_decap_port_profile_init.
     * Better to have an internal API to get from tunnel module.
     */
#define FLOW_TUNNEL_TERM_PBMP_PROFILE_DEF   (0)

    SHR_FUNC_ENTER(unit);

    if ((opt == HW_OPT_SET) && (!(info->flags & BCM_TUNNEL_REPLACE))) {
        old_idx = FLOW_TUNNEL_TERM_PBMP_PROFILE_DEF;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
           (bcmlt_entry_field_get(entry_hd_read, TNL_DECAP_PORT_PROFILE_IDs,
                                  &get_val));
        old_idx = (int)get_val;
    }
    if (opt == HW_OPT_GET) {
        if (old_idx != FLOW_TUNNEL_TERM_PBMP_PROFILE_DEF) {
            sal_memset(&entry, 0, sizeof(entry));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_tunnel_decap_port_profile_get(unit, &entry,
                                                         old_idx));
            BCM_PBMP_ASSIGN(info->term_pbmp, entry.decap_ports);
        } else {
            BCM_PBMP_CLEAR(info->term_pbmp);
        }
    } else if (opt == HW_OPT_SET) {
        if (old_idx != FLOW_TUNNEL_TERM_PBMP_PROFILE_DEF) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_tunnel_decap_port_profile_delete(unit, old_idx));
        }
        sal_memset(&entry, 0, sizeof(entry));
        BCM_PBMP_ASSIGN(entry.decap_ports, info->term_pbmp);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_tunnel_decap_port_profile_add(unit, &entry, &idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, TNL_DECAP_PORT_PROFILE_IDs,
                                   idx));
    } else if (opt == HW_OPT_CLR) {
        if (old_idx != FLOW_TUNNEL_TERM_PBMP_PROFILE_DEF) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_tunnel_decap_port_profile_delete(unit, old_idx));
        }
    } else {
        /* Do nothing. */
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse HW table based on tunnel terminator.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     cb            User callback function.
 * \param [in]     user_data     User context data.
 * \param [in]     lt_name       LT name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_term_table_traverse(int unit,
                                    bcm_flow_tunnel_terminator_traverse_cb cb,
                                    void *user_data,
                                    const char *lt_name)
{
    int rv = SHR_E_NONE;
    bcm_flow_tunnel_terminator_t info = {0};
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    int rv1 = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    while ((rv = bcmi_lt_entry_commit(dunit, entry_hd, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        bcm_flow_tunnel_terminator_t_init(&info);

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_term_criteria_determine(unit, lt_name, &info));

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_term_key_get(unit, &info, entry_hd));

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_term_data_get(unit, &info, lt_name, entry_hd));
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_term_pbmp_profile_ctrl(unit, HW_OPT_GET, &info,
                                                    entry_hd,
                                                    BCMLT_INVALID_HDL));
        if (cb) {
            rv1 = (*cb) (unit, &info, 0, NULL, user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy all flow tunnel terminator entry.
 *
 * \param [in]     unit          Unit Number.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_term_destroy_all(int unit)
{
    const char *lt_list[] = {TNL_L2_VXLAN_DECAP_OVID_IPV6_EMs,
                             TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EMs,
                             TNL_L2_VXLAN_DECAP_OVID_IPV4_EMs,
                             TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EMs,
                             TNL_L2_VXLAN_DECAP_OVID_IPV6s,
                             TNL_L2_VXLAN_DECAP_OVID_DST_IPV6s,
                             TNL_L2_VXLAN_DECAP_OVID_IPV4s,
                             TNL_L2_VXLAN_DECAP_OVID_DST_IPV4s};
    int lt_num = COUNTOF(lt_list);
    int idx = 0;

    SHR_FUNC_ENTER(unit);

    for (idx = 0; idx < lt_num; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, lt_list[idx]));
    }

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Determine whether initiator is Ipv6 tunnel.
 *
 * \param [in]  unit      Unit number.
 * \param [in]  info      Tunnel initiator info structure.
 * \param [in]  tnl_idx   Tunnel index. Key of tunnel type.
 * \param [out] ipv6      Tunnel type, IPv6 or not.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_initiator_type_determine(int unit,
                                         bcm_flow_tunnel_initiator_t *info,
                                         int tnl_idx, uint8_t *ipv6)
{
    uint32_t soft_tnl_idx = BCMINT_FLOW_EGR_TUNNEL_RESERVED;
    bcmi_ltsw_tunnel_type_t tnl_type;
    int encap_idx;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ipv6, SHR_E_PARAM);

    *ipv6 = 0;
    /* Determine the type based on initiator info. */
    if (info) {
        if ((info->type == bcmTunnelTypeVxlan6) ||
            (info->flow_handle == BCMINT_FLOW_ID_VXLAN)) {
            *ipv6 = TRUE;
            SHR_ERR_EXIT(SHR_E_NONE);
        }

        if ((info->type == bcmTunnelTypeVxlan) ||
            (info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN)) {
            *ipv6 = FALSE;
            SHR_ERR_EXIT(SHR_E_NONE);
        }
    }

    /* Determine the type based on tunnel index. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_flow_tunnel_sw_idx_get(unit, tnl_idx, &soft_tnl_idx));
    if (soft_tnl_idx != BCMINT_FLOW_EGR_TUNNEL_RESERVED) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_intf_tnl_init_get(unit, soft_tnl_idx,
                                            &tnl_type,  &encap_idx));
        if (tnl_type == bcmiTunnelTypeIp6L3) {
            *ipv6 = TRUE;
            SHR_ERR_EXIT(SHR_E_NONE);
        }

        if (tnl_type == bcmiTunnelTypeIpL3) {
            *ipv6 = FALSE;
            SHR_ERR_EXIT(SHR_E_NONE);
        }
    }

    SHR_ERR_EXIT(SHR_E_PARAM);

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Get hw index for tunnel initiator.
 *
 * \param [in] unit Unit Number.
 * \param [in] ipv6 Tunnel type.
 * \param [in] tnl_idx Tunnel LT index.
 * \param [out] encap_idx HW index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xgs_flow_tunnel_initiator_encap_index_get(int unit,
                                          int ipv6,
                                          int tnl_idx,
                                          int *encap_idx)
{
    int dunit = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val;
    const char *ltname, *fldname;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(encap_idx, SHR_E_PARAM);

    if (ipv6) {
        ltname = TNL_IPV6_ENCAPs;
        fldname = TNL_IPV6_ENCAP_IDs;
    } else {
        ltname = TNL_IPV4_ENCAPs;
        fldname = TNL_IPV4_ENCAP_IDs;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ltname, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, fldname, tnl_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, ENCAP_INDEXs, &val));
    *encap_idx = val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set IPv4 ID info to LT entry handle.
 *
 * \param [in]  unit           Unit number.
 * \param [in]  info           Egress encap info structure.
 * \param [in]  entry_hd_read  LT handle.
 * \param [in]  entry_hd       LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_initiator_ipv4_id_set(int unit,
                                      bcm_flow_tunnel_initiator_t *info,
                                      uint32_t tnl_inx)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint32_t value;
    uint16_t random;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_tunnel_control_get(unit,
                                      bcmiTunnelControlTunnelIp4IdShared,
                                      &value));
    if (!value) {
        dunit = bcmi_ltsw_dev_dunit(unit);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_ENCAP_FRAGMENTs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_ENCAP_FRAGMENT_IDs, tnl_inx));

        if (info->flags & BCM_TUNNEL_INIT_IP4_ID_SET_FIXED) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, FRAGMENT_IDs,
                                       info->ip4_id));
        } else if (info->flags & BCM_TUNNEL_INIT_IP4_ID_SET_RANDOM) {
            random = (uint16) (sal_time_usecs() & 0xFFFF);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, FRAGMENT_IDs, random));
        } else {
            /* Default is random */
            random = (uint16_t) (sal_time_usecs() & 0xFFFF);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, FRAGMENT_IDs, random));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl,
                                      BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get data info from LT entry handle.
 *
 * \param [in]   unit      Unit number.
 * \param [in]   tnl_idx   Index to tunnel initiator hardware table.
 * \param [out]  info      Tunnel initiator info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_initiator_get(int unit,
                              int tnl_idx,
                              bcm_flow_tunnel_initiator_t *info)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint8_t ipv6 = 0;
    uint64_t get_val;
    const char* symbol = NULL;
    uint64 get_ipv6_val[2] = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_initiator_type_determine(unit, info, tnl_idx, &ipv6));

    dunit = bcmi_ltsw_dev_dunit(unit);
    if (ipv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV6_ENCAPs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_IPV6_ENCAP_IDs, tnl_idx));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV4_ENCAPs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_IPV4_ENCAP_IDs, tnl_idx));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    /* Parse common fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, TNL_TYPEs, &symbol));
    if (!sal_strcmp(symbol, VXLANs)) {
        /* Do nothing. */
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                      &symbol));
    if (!sal_strcmp(symbol, FIXEDs)) {
        info->dscp_sel = bcmTunnelDscpAssign;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, DSCPs, &get_val));
        info->dscp = get_val;
    } else if (!sal_strcmp(symbol, MAPs)){
        info->dscp_sel = bcmTunnelDscpMap;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, PHB_EGR_IP_INT_PRI_TO_DSCP_IDs,
                                   &get_val));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_construct(unit, get_val,
                                            bcmiQosMapTypeL3Egress,
                                            &(info->dscp_map)));
    } else if (!sal_strcmp(symbol, PACKETs)){
        info->dscp_sel = bcmTunnelDscpPacket;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, DST_L4_PORTs, &get_val));
    info->udp_dst_port = get_val;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, SRC_L4_PORTs, &get_val));
    info->udp_src_port = get_val;

    /* Parse specified fields. */
    if (ipv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, HOP_LIMITs, &get_val));
        info->ttl = get_val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, FLOW_LABEL_SELECTs,
                                          &symbol));
        if (!sal_strcmp(symbol, FLOW_LABELs)) {
            /*Do nothing. */
        } else if (!sal_strcmp(symbol, HASH_ENTROPYs)){
            info->flow_option = BCMINT_FLOW_OPT_ID_IPV6_FLOW_LABEL_USE_ENTROPY;
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, FLOW_LABELs, &get_val));
        info->flow_label = get_val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, DST_IPV6_LOWERs,
                                   &get_ipv6_val[0]));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, DST_IPV6_UPPERs,
                                   &get_ipv6_val[1]));
        bcmi_ltsw_util_uint64_to_ip6(&(info->dip6), get_ipv6_val);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_LOWERs,
                                   &get_ipv6_val[0]));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_UPPERs,
                                   &get_ipv6_val[1]));
        bcmi_ltsw_util_uint64_to_ip6(&(info->sip6), get_ipv6_val);
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, IPV4_IN_IPV4_DF_MODEs,
                                          &symbol));
        if (!sal_strcmp(symbol, USE_INNER_DFs)) {
            info->flags |= BCM_TUNNEL_INIT_USE_INNER_DF;
        } else if (!sal_strcmp(symbol, SETs)){
            info->flags |= BCM_TUNNEL_INIT_IPV4_SET_DF;
        } else if (!sal_strcmp(symbol, CLEARs)){
           /* Do nothing. */
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, IPV6_IN_IPV4_DF_MODEs,
                                          &symbol));
        if (!sal_strcmp(symbol, SETs)) {
            info->flags |= BCM_TUNNEL_INIT_IPV6_SET_DF;
        } else if (!sal_strcmp(symbol, CLEARs)){
           /* Do nothing. */
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, TNL_TTLs, &get_val));
        info->ttl = get_val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, DST_IPV4s, &get_val));
        info->dip = get_val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, SRC_IPV4s, &get_val));
        info->sip = get_val;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the parameters for tunnel initiator configuration.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Tunnel initiator info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_initiator_param_validation(int unit,
                                           bcmint_flow_hw_opt_type_t opt,
                                           bcm_flow_tunnel_initiator_t *info)
{
    uint32_t tnl_idx;
    uint32_t soft_tnl_idx;
    uint32_t supported_items = 0;
    uint32 ref_cnt = 0;
    bcmi_ltsw_tunnel_type_t tnl_type;
    uint8_t ipv6 = 0;
    bcmi_ltsw_idx_tbl_id_t tbl_id;
    uint8_t user_id;

    SHR_FUNC_ENTER(unit);

    BCMI_LTSW_GPORT_TUNNEL_ID_GET(info->tunnel_id, tnl_type, soft_tnl_idx);
    if (!((opt == HW_OPT_SET) && !(info->flags & BCM_TUNNEL_REPLACE))) {
        if (tnl_type != bcmiTunnelTypeFlexFlow) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

    if (opt == HW_OPT_SET) {
        /* Validate tunnel type. */
        if ((info->type != bcmTunnelTypeVxlan) &&
            (info->type != bcmTunnelTypeVxlan6)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Bad tunnel type:%d!\n"),
                                            info->type));
        }

        /* Validate tunnel type vs flow handle. */
        if (((info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN) &&
            (info->type != bcmTunnelTypeVxlan)) ||
            ((info->flow_handle == BCMINT_FLOW_ID_VXLAN) &&
            (info->type != bcmTunnelTypeVxlan6))) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Type vs handle mismatch:%d,%d!\n"),
                                            info->type, info->flow_handle));
        }

        /* Validate flow handle vs elements. */
        if (info->flow_handle == BCMINT_FLOW_ID_VXLAN) {
            supported_items = BCM_FLOW_TUNNEL_INIT_TTL_VALID |
                              BCM_FLOW_TUNNEL_INIT_DSCP_VALID |
                              BCM_FLOW_TUNNEL_INIT_SIP6_VALID |
                              BCM_FLOW_TUNNEL_INIT_DIP6_VALID |
                              BCM_FLOW_TUNNEL_INIT_FLOW_LABEL_VALID |
                              BCM_FLOW_TUNNEL_INIT_UDP_DPORT_VALID |
                              BCM_FLOW_TUNNEL_INIT_UDP_SPORT_VALID;
        } else if (info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN) {
            supported_items = BCM_FLOW_TUNNEL_INIT_TTL_VALID |
                              BCM_FLOW_TUNNEL_INIT_DSCP_VALID |
                              BCM_FLOW_TUNNEL_INIT_DIP_VALID |
                              BCM_FLOW_TUNNEL_INIT_SIP_VALID |
                              BCM_FLOW_TUNNEL_INIT_UDP_DPORT_VALID |
                              BCM_FLOW_TUNNEL_INIT_UDP_SPORT_VALID |
                              BCM_FLOW_TUNNEL_INIT_IP4_ID_VALID;
        } else {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Wrong flow handle!\n")));
        }
        if (info->valid_elements & (~supported_items)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Elements:supported(%d)/provided(%d)!\n"),
                                            supported_items, info->valid_elements));
        }

        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_TTL_VALID) {
            if (!BCM_TTL_VALID(info->ttl)) {
                SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                    (BSL_META_U(unit, "Bad TTL:%d!\n"), info->ttl));
            }
        }

        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DSCP_VALID) {
            if (info->dscp > 63 || info->dscp < 0) {
                SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                    (BSL_META_U(unit, "Bad dscp:%d!\n"),
                                                info->dscp));
            }

            if ((info->dscp_sel < bcmTunnelDscpAssign) ||
                (info->dscp_sel >= bcmTunnelDscpCount)) {
                SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                    (BSL_META_U(unit, "Bad dscp_sel:%d!\n"),
                                                info->dscp_sel));
            }

            if (info->dscp_sel == bcmTunnelDscpMap) {
                bcmi_ltsw_qos_map_type_t map_type;
                int map_ptr;

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_qos_map_id_resolve(unit,
                                                  info->dscp_map,
                                                  &map_type,
                                                  &map_ptr));
                if (map_type != bcmiQosMapTypeL3Egress) {
                    SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                        (BSL_META_U(unit, "Bad dscp_map:%d!\n"),
                                                    info->dscp_map));
                }
            }
        }

        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_IP4_ID_VALID) {
            uint32_t value;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_tunnel_control_get(unit,
                                              bcmiTunnelControlTunnelIp4IdShared,
                                              &value));
            if (value) {
                SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                    (BSL_META_U(unit,
                                                "IPv4 ID globally shared.!\n")));
            }
        }

        if (info->flags & BCM_TUNNEL_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
            if (tnl_idx == 0) {
                SHR_ERR_EXIT(SHR_E_NOT_FOUND);
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_tunnel_initiator_type_determine(unit, info, tnl_idx,
                                                          &ipv6));
            if (ipv6) {
                 tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL;
                 user_id = BCMI_EGR_L3_IP6_TNL_USER_ID_FLEX_FLOW;
            } else {
                 tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
                 user_id = BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id, tnl_idx,
                                                 &ref_cnt));
            if (!ref_cnt) {
                SHR_ERR_EXIT(SHR_E_NOT_FOUND);
            }
        } else {
            /*
             * Egress L3 interface must exist and must not attached with
             * tunnel.
             */
            bcm_l3_intf_t l3_intf;
            bcm_l3_intf_t_init(&l3_intf);
            l3_intf.l3a_intf_id = info->l3_intf_id;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_l3_intf_get(unit, &l3_intf));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_flow_tunnel_idx_get(unit, info->l3_intf_id, &tnl_idx));
            if (tnl_idx != 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (xgs_flow_tunnel_initiator_type_determine(unit, info,
                                                              tnl_idx, &ipv6));
                if (ipv6) {
                     tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL;
                     user_id = BCMI_EGR_L3_IP6_TNL_USER_ID_FLEX_FLOW;
                } else {
                     tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
                     user_id = BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW;
                }
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id,
                                                     tnl_idx, &ref_cnt));
                if (ref_cnt) {
                    SHR_ERR_EXIT(SHR_E_EXISTS);
                }
            }
        }
    } else {
        /* opt = get, clear*/
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
        if (tnl_idx == -1) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Tunnel not provided!\n")));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_initiator_type_determine(unit, info, tnl_idx, &ipv6));
        if (ipv6) {
             tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL;
             user_id = BCMI_EGR_L3_IP6_TNL_USER_ID_FLEX_FLOW;
        } else {
             tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
             user_id = BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id, tnl_idx,
                                             &ref_cnt));

        if (!ref_cnt) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_NOT_FOUND,
                                (BSL_META_U(unit, "Tunnel not exist!\n")));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate tunnel initiator entry hash(signature).
 *
 * \param [in]  unit   Unit number.
 * \param [in]  buf    Tunnel initiator entry information.
 * \param [out] hash   Hash(signature) calculated value.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_initiator_hash_calc(int unit, void *buf, uint16_t *hash)
{
    bcm_flow_tunnel_initiator_t tnl_entry;
    bcm_flow_tunnel_initiator_t *info;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(buf, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    info = (bcm_flow_tunnel_initiator_t *)buf;

    bcm_flow_tunnel_initiator_t_init(&tnl_entry);
    tnl_entry.type = info->type;

    if (tnl_entry.type == bcmTunnelTypeVxlan) {
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_SIP_VALID) {
            tnl_entry.sip = info->sip;
        }
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DIP_VALID) {
            tnl_entry.dip = info->dip;
        }
     } else if (tnl_entry.type == bcmTunnelTypeVxlan6) {
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_SIP6_VALID) {
            sal_memcpy(tnl_entry.sip6, info->sip6, sizeof(bcm_ip6_t));
        }
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DIP6_VALID) {
            sal_memcpy(tnl_entry.dip6, info->dip6, sizeof(bcm_ip6_t));
        }

     } else {
         SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                             (BSL_META_U(unit, "Bad tunnel type:%d!\n"),
                                         tnl_entry.type));
     }

     tnl_entry.udp_dst_port = info->udp_dst_port;
     tnl_entry.udp_src_port = info->udp_src_port;

     /* Calculate hash */
    *hash = _shr_crc16(0, (uint8 *)&tnl_entry,
                       sizeof(bcm_flow_tunnel_initiator_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compares tunnel initiator entry with entry at specified index in chip.
 *
 * \param [in]  unit        Unit number.
 * \param [in]  buf         Tunnel initiator entry to compare.
 * \param [in]  tnl_idx     Entry index in the chip to compare.
 * \param [out] cmp_result  Compare result.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xgs_flow_tunnel_initiator_cmp(int unit, int tnl_idx, void *buf, int *cmp_result)
{
    bcm_flow_tunnel_initiator_t *tnl_init_tmp = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(buf, SHR_E_PARAM);
    SHR_NULL_CHECK(cmp_result, SHR_E_PARAM);

    SHR_ALLOC(tnl_init_tmp, sizeof(bcm_tunnel_initiator_t),
              "tnlInitTmp");
    SHR_NULL_CHECK(tnl_init_tmp, SHR_E_MEMORY);
    sal_memset(tnl_init_tmp, 0, sizeof(bcm_tunnel_initiator_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_initiator_get(unit, tnl_idx, tnl_init_tmp));

    *cmp_result = sal_memcmp(buf, tnl_init_tmp,
                             sizeof(bcm_flow_tunnel_initiator_t));

exit:
    SHR_FREE(tnl_init_tmp);

    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert tunnel initiator to given hardware entry.
 *
 * \param [in] unit  Unit number.
 * \param [in] flags Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index Entry index.
 * \param [in] entry Entry content of bcm_flow_tunnel_initiator_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xgs_flow_tunnel_initiator_insert(int unit,
                                 uint32_t flags,
                                 int tnl_idx,
                                 void *entry)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint8_t ipv6;
    uint64 set_val = {0};
    uint64 set_ipv6_val[2] = {0};
    bcm_flow_tunnel_initiator_t *info = entry;
    bcmi_ltsw_qos_map_type_t map_type;
    int map_ptr;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_initiator_type_determine(unit, info, tnl_idx, &ipv6));

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (ipv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV6_ENCAPs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_IPV6_ENCAP_IDs, tnl_idx));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV4_ENCAPs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_IPV4_ENCAP_IDs, tnl_idx));
    }

    /* Handling common fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, VXLANs));

    if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DSCP_VALID) {
        if (info->dscp_sel == bcmTunnelDscpAssign) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                              FIXEDs));
            set_val = info->dscp;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DSCPs, set_val));
        } else if (info->dscp_sel == bcmTunnelDscpMap) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                              MAPs));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_resolve(unit,
                                              info->dscp_map,
                                              &map_type,
                                              &map_ptr));
            set_val = map_ptr;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, PHB_EGR_IP_INT_PRI_TO_DSCP_IDs,
                                       set_val));
        } else {
            /* bcmTunnelDscpPacket */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                              PACKETs));
            set_val = info->dscp;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DSCPs, set_val));
        }
    }

    if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_UDP_SPORT_VALID) {
        set_val = info->udp_src_port;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, SRC_L4_PORTs, set_val));
    }
    if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_UDP_DPORT_VALID) {
        set_val = info->udp_dst_port;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, DST_L4_PORTs, set_val));
    }

    /* Handling specified fields. */
    if (ipv6) {
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_TTL_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, HOP_LIMITs, info->ttl));
        }
        if (info->flow_option == BCMINT_FLOW_OPT_ID_IPV6_FLOW_LABEL_USE_ENTROPY) {
            /* Use entropy as flow label. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, FLOW_LABEL_SELECTs,
                                              HASH_ENTROPYs));
        } else {
            /* Use assigned flow label. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, FLOW_LABEL_SELECTs,
                                              FLOW_LABELs));
        }
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_FLOW_LABEL_VALID) {
            set_val = info->flow_label;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, FLOW_LABELs, set_val));
        }

        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DIP6_VALID) {
            bcmi_ltsw_util_ip6_to_uint64(set_ipv6_val, &(info->dip6));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV6_LOWERs,
                                       set_ipv6_val[0]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV6_UPPERs,
                                       set_ipv6_val[1]));
        }

        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_SIP6_VALID) {
            bcmi_ltsw_util_ip6_to_uint64(set_ipv6_val, &(info->sip6));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_LOWERs,
                                       set_ipv6_val[0]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_UPPERs,
                                       set_ipv6_val[1]));
        }
    } else {
        if (info->flags & BCM_TUNNEL_INIT_USE_INNER_DF) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, IPV4_IN_IPV4_DF_MODEs,
                                              USE_INNER_DFs));
        } else if (info->flags & BCM_TUNNEL_INIT_IPV4_SET_DF) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, IPV4_IN_IPV4_DF_MODEs,
                                              SETs));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, IPV4_IN_IPV4_DF_MODEs,
                                              CLEARs));
        }
        if (info->flags & BCM_TUNNEL_INIT_IPV6_SET_DF) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, IPV6_IN_IPV4_DF_MODEs,
                                              SETs));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, IPV6_IN_IPV4_DF_MODEs,
                                              CLEARs));
        }
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_TTL_VALID) {
            set_val = info->ttl;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, TNL_TTLs, set_val));
        }
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_DIP_VALID) {
            set_val = info->dip;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV4s, set_val));
        }
        if (info->valid_elements & BCM_FLOW_TUNNEL_INIT_SIP_VALID) {
            set_val = info->sip;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV4s, set_val));
        }
    }

    if (info->flags & BCM_TUNNEL_REPLACE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_INSERT,
                                  BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete specified entry from tunnel table.
 *
 * \param [in] unit     Unit number.
 * \param [in] tnl_idx  Index to tunnel initiator hardware table.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_initiator_delete(int unit, int tnl_idx)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint8_t ipv6 = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_initiator_type_determine(unit, NULL, tnl_idx, &ipv6));

    dunit = bcmi_ltsw_dev_dunit(unit);
    if (ipv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV6_ENCAPs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_IPV6_ENCAP_IDs, tnl_idx));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV4_ENCAPs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_IPV4_ENCAP_IDs, tnl_idx));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy all flow tunnel initiator entry.
 *
 * \param [in]  unit Unit Number.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_tunnel_initiator_delete_all(int unit)
{
     uint64_t idx_min, idx_max;
     uint32_t tnl_idx, soft_tnl_idx;
     bcmi_ltsw_tunnel_type_t tnl_type;
     int encap_idx;
     bcmi_ltsw_idx_tbl_id_t tbl_id;
     uint8_t user_id;
     int local_rv = SHR_E_NONE;

     SHR_FUNC_ENTER(unit);

     SHR_IF_ERR_VERBOSE_EXIT
         (bcmi_lt_field_value_range_get(unit, L3_EIFs, L3_EIF_IDs,
                                        &idx_min, &idx_max));
     /*
      * Enhance tunnel index to support egress L3 interface.
      * Index 0 reserved.
      */
     if (idx_min == 0) {
         idx_min = 1;
     }
     for (soft_tnl_idx = idx_min; soft_tnl_idx <= idx_max; soft_tnl_idx++) {
         SHR_IF_ERR_VERBOSE_EXIT
             (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
         if (tnl_idx == BCMINT_FLOW_EGR_TUNNEL_RESERVED) {
             continue;
         }
         local_rv = bcmi_ltsw_l3_intf_tnl_init_get(unit, soft_tnl_idx,
                                                   &tnl_type,  &encap_idx);
         if (local_rv == SHR_E_NONE) {
            /* LT still there. Clear flow related configuration. */
             if (tnl_type == bcmiTunnelTypeIp6L3) {
                  tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL;
                  user_id = BCMI_EGR_L3_IP6_TNL_USER_ID_FLEX_FLOW;
             } else if (tnl_type == bcmiTunnelTypeIpL3) {
                  tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
                  user_id = BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW;
             } else {
                 SHR_IF_ERR_MSG_EXIT(SHR_E_INTERNAL,
                                     (BSL_META_U(unit, "Invalid tunnel type:%d!\n"),
                                                 tnl_type));
             }
             SHR_IF_ERR_VERBOSE_EXIT
                 (bcmi_ltsw_idx_tbl_entry_free(unit, 0, tbl_id, user_id,
                                               tnl_idx));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_intf_tnl_init_reset(unit, soft_tnl_idx));
         } else {
             /*
              * Do nothing if LT has been clear by other modules or
              * L3 returns other errors. Assuming error handling in L3 will
              * cover the "other errors" case.
              */
         }
         SHR_IF_ERR_VERBOSE_EXIT
             (bcmint_flow_tunnel_idx_set(unit, soft_tnl_idx,
                                         BCMINT_FLOW_EGR_TUNNEL_RESERVED));
     }

exit:

    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover index table mgmt bookkeepings for tunnel initiator.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xgs_flow_tunnel_initiator_recover(int unit)
{
    bcm_flow_tunnel_initiator_t info;
    uint32 ref_cnt;
    uint64_t idx_min, idx_max;
    uint32_t tnl_idx, soft_tnl_idx;
    bcmi_ltsw_tunnel_type_t tnl_type;
    int encap_idx;
    uint8_t ipv6 = 0;
    bcmi_ltsw_tunnel_type_t tbl_id;
    uint8_t user_id;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, L3_EIFs, L3_EIF_IDs,
                                       &idx_min, &idx_max));
    /* Skip index 0.*/
    idx_min = idx_min? idx_min : 1;
    for (soft_tnl_idx = idx_min; soft_tnl_idx <= idx_max; soft_tnl_idx++) {
        bcm_flow_tunnel_initiator_t_init(&info);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_warmboot_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
        if (tnl_idx == BCMINT_FLOW_EGR_TUNNEL_RESERVED) {
            continue;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_intf_tnl_init_get(unit, soft_tnl_idx, &tnl_type,
                                            &encap_idx));

       if (tnl_type == bcmiTunnelTypeIp6L3) {
           ipv6 = 1;
           info.type = bcmTunnelTypeVxlan6;
           info.flow_handle = BCMINT_FLOW_ID_VXLAN;
       } else {
           ipv6 = 0;
           info.type = bcmTunnelTypeVxlan;
           info.flow_handle = BCMINT_FLOW_ID_CLASSIC_VXLAN;
       }
       info.l3_intf_id = soft_tnl_idx;
       BCMI_LTSW_GPORT_TUNNEL_ID_SET(info.tunnel_id,
                                     bcmiTunnelTypeFlexFlow, soft_tnl_idx);
       if (ipv6) {
            tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL;
            user_id = BCMI_EGR_L3_IP6_TNL_USER_ID_FLEX_FLOW;
       } else {
            tbl_id = BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL;
            user_id = BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW;
       }

       SHR_IF_ERR_VERBOSE_EXIT
           (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id, tnl_idx,
                                                  &ref_cnt));
       if (ref_cnt == 0) {
           SHR_IF_ERR_VERBOSE_EXIT
               (xgs_flow_tunnel_initiator_get(unit, tnl_idx, &info));
           SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_ltsw_idx_tbl_entry_hash_update(unit, tbl_id, user_id,
                                                    &info, tnl_idx));
       }
       SHR_IF_ERR_VERBOSE_EXIT
           (bcmi_ltsw_idx_tbl_entry_ref_increase(unit, tbl_id, user_id,
                                                 tnl_idx));
    }

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Hash callback function for port encap MTU profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] entries Port encap MTU profile entry.
 * \param [in] entries_per_set Number of entries per set.
 * \param [out] hash Hash value returned.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_port_encap_mtu_profile_entry_hash_cb(
    int unit,
    void *entries,
    int entries_per_set,
    uint32_t *hash)
{
    SHR_FUNC_ENTER(unit);

    if (entries_per_set != 1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    *hash = shr_crc32(0, entries,
                      entries_per_set * sizeof(port_encap_mtu_profile_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve a port encap MTU profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] idx Index.
 * \param [out] prof_entry Profile entry returned.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_port_encap_mtu_profile_entry_get(
    int unit,
    int idx,
    port_encap_mtu_profile_t *prof_entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t get_val;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_DVP_MTU_PROFILEs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PORT_DVP_MTU_PROFILE_IDs, idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, ENABLEs, &get_val));
    prof_entry->enable = (get_val? 0x1: 0x0);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, MTUs, &get_val));
    prof_entry->mtu = (uint16_t)get_val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Comparison callback function for port encap MTU profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] entries Port encap MTU profile entry.
 * \param [in] entries_per_set Number of entries per set.
 * \param [index] Index of LT entry.
 * \param [out] cmp_result Comparison result.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_port_encap_mtu_profile_entry_cmp_cb(
    int unit,
    void *entries,
    int entries_per_set,
    int index,
    int *cmp_result)
{
    port_encap_mtu_profile_t prof_entry;

    SHR_FUNC_ENTER(unit);

    if (entries_per_set != 1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(cmp_result, SHR_E_PARAM);

    sal_memset(&prof_entry, 0, sizeof(prof_entry));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_port_encap_mtu_profile_entry_get(unit, index, &prof_entry));

    *cmp_result = sal_memcmp(entries, &prof_entry, sizeof(prof_entry));

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Set a port encap MTU profile entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] idx Index.
 * \param [out] prof_entry Profile entry returned.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_port_encap_mtu_profile_entry_set(
    int unit,
    int idx,
    port_encap_mtu_profile_t *prof_entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_DVP_MTU_PROFILEs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PORT_DVP_MTU_PROFILE_IDs, idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, ENABLEs, prof_entry->enable));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MTUs, prof_entry->mtu));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete a port encap MTU profile entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] idx Index.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_port_encap_mtu_profile_entry_del(
    int unit,
    int idx)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_DVP_MTU_PROFILEs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PORT_DVP_MTU_PROFILE_IDs, idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
xgs_flow_port_encap_mtu_profile_get(
    int unit,
    port_encap_mtu_profile_t *entry,
    int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_port_encap_mtu_profile_entry_get(unit, index, entry));

exit:
    SHR_FUNC_EXIT();
}

static int
xgs_flow_port_encap_mtu_profile_recover(
    int unit,
    int index)
{
    uint32_t ref_cnt;
    uint64_t idx_min, idx_max;
    port_encap_mtu_profile_t profile;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, PORT_DVP_MTU_PROFILEs,
                                       PORT_DVP_MTU_PROFILE_IDs,
                                       &idx_min, &idx_max));

    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_get(unit,
                                         BCMI_LTSW_PROFILE_FLOW_DVP_MTU_PROFILE,
                                         index, &ref_cnt));
    if (ref_cnt == 0) {
        /* If profile entry has not been initialized. */
        sal_memset(&profile, 0, sizeof(profile));
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_port_encap_mtu_profile_get(unit, &profile, index));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_hash_update(unit,
                                           BCMI_LTSW_PROFILE_FLOW_DVP_MTU_PROFILE,
                                           &profile, 1, index));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_increase(unit,
                                              BCMI_LTSW_PROFILE_FLOW_DVP_MTU_PROFILE,
                                              1, index, 1));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize tunnel decap port profiles.
 *
 * \param [in] unit Unit Number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
xgs_flow_port_encap_mtu_profile_init(int unit)
{
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_FLOW_DVP_MTU_PROFILE;
    uint64_t idx_max, idx_min;
    int ent_idx_min, ent_idx_max;
    int idx;
    port_encap_mtu_profile_t profile;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv;
    int dunit;
    uint64_t data;
    uint32_t tbl_size = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit, profile_hdl), SHR_E_NOT_FOUND);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, PORT_DVP_MTU_PROFILEs,
                                       PORT_DVP_MTU_PROFILE_IDs,
                                       &idx_min, &idx_max));
    ent_idx_min = (int)idx_min;
    ent_idx_max = (int)idx_max;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit, &profile_hdl,
                                    &ent_idx_min, &ent_idx_max, 1,
                                    xgs_flow_port_encap_mtu_profile_entry_hash_cb,
                                    xgs_flow_port_encap_mtu_profile_entry_cmp_cb));

    if (bcmi_warmboot_get(unit)) {
        /* Recover */
        dunit = bcmi_ltsw_dev_dunit(unit);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, PORT_DVPs, &entry_hdl));
        while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                          BCMLT_OPCODE_TRAVERSE,
                                          BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, PORT_DVP_MTU_PROFILE_IDs,
                                       &data));
            idx = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_port_encap_mtu_profile_recover(unit, idx));
        }

        if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
            SHR_ERR_EXIT(rv);
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, PORT_DVP_MTU_PROFILEs));

        /* Reserve profile 0 for default to disable MTU check. */
        sal_memset(&profile, 0, sizeof(profile));
        profile.enable = 0;
        profile.mtu = 0x3fff;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_index_allocate(unit, profile_hdl, &profile, 0, 1,
                                              &idx));
        if (idx != FLOW_PORT_ENCAP_MTU_PROFILE_DEF) {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_port_encap_mtu_profile_entry_set(unit, idx, &profile));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_capacity_get(unit, PORT_DVPs, &tbl_size));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit,
                 BCMI_LTSW_PROFILE_FLOW_DVP_MTU_PROFILE, 1, idx, tbl_size));
        }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_flow_port_encap_mtu_profile_add(
    int unit,
    port_encap_mtu_profile_t *entry,
    int *index)
{
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    rv = bcmi_ltsw_profile_index_allocate(unit,
                                          BCMI_LTSW_PROFILE_FLOW_DVP_MTU_PROFILE,
                                          entry, 0, 1, index);
    if (rv == SHR_E_EXISTS) {
        /* the same profile already exists */
        SHR_EXIT();
    }

    if (SHR_FAILURE(rv)) {
       SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_port_encap_mtu_profile_entry_set(unit, *index, entry));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_flow_port_encap_mtu_profile_delete(
    int unit,
    int index)
{
    int rv;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_free(unit,
                                      BCMI_LTSW_PROFILE_FLOW_DVP_MTU_PROFILE,
                                      index);

    if (rv == SHR_E_BUSY) {
        /* profile entry is still inused */
       SHR_EXIT();
    }

    if (rv != SHR_E_NONE) {
        SHR_ERR_EXIT(rv);
    }

    /* empty the profile entry */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_port_encap_mtu_profile_entry_del(unit, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the parameters for port encap configuration.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Egress encap info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_port_encap_param_validation(int unit,
                                     bcmint_flow_hw_opt_type_t opt,
                                     bcm_flow_port_encap_t *info)
{
    int vp = -1;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    int update_l2_tag = 0;

    SHR_FUNC_ENTER(unit);

    vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
    if (vp == -1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    bcmi_ltsw_virtual_vp_info_init(&vp_info);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info));
    if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_FLOW)) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Flow port only!\n")));
    }

    if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_EGRESS_CASCADED) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Validate flow option. */
    if (info->flow_option == BCMINT_FLOW_OPT_ID_IPV6) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Option IPv6 not supported!\n")));
    }

    /* Validate opt vs valid elements. */
    if ((opt == HW_OPT_SET) &&
        (!(info->options & BCM_FLOW_PORT_ENCAP_OPTION_CLEAR))) {
        uint32_t supported_elements = BCM_FLOW_PORT_ENCAP_NETWORK_GROUP_VALID |
                                      BCM_FLOW_PORT_ENCAP_DVP_GROUP_VALID |
                                      BCM_FLOW_PORT_ENCAP_EGRESS_IF_VALID |
                                      BCM_FLOW_PORT_ENCAP_PORT_VALID |
                                      BCM_FLOW_PORT_ENCAP_FLAGS_VALID |
                                      BCM_FLOW_PORT_ENCAP_MTU_VALID |
                                      BCM_FLOW_PORT_ENCAP_ES_ID_VALID |
                                      BCM_FLOW_PORT_ENCAP_VLAN_VALID |
                                      BCM_FLOW_PORT_ENCAP_PKT_PRI_VALID |
                                      BCM_FLOW_PORT_ENCAP_PKT_CFI_VALID |
                                      BCM_FLOW_PORT_ENCAP_TPID_VALID;
        if (info->valid_elements & (~supported_elements)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "elements:supported(%d)/provided(%d)!\n"),
                                            supported_elements, info->valid_elements));
        }
    }

    /* Validate elements. */
    if (opt == HW_OPT_SET) {
        if (info->valid_elements & BCM_FLOW_PORT_ENCAP_EGRESS_IF_VALID) {
            int nh_idx;
            bcmi_ltsw_l3_egr_obj_type_t nh_type;
            int used = 0;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_egress_obj_id_resolve(unit,
                                                    info->egress_if,
                                                    &nh_idx,
                                                    &nh_type));
            if ((nh_type != BCMI_LTSW_L3_EGR_OBJ_T_UL) &&
                (nh_type != BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if (!(info->options & (BCM_FLOW_PORT_ENCAP_OPTION_REPLACE |
                BCM_FLOW_PORT_ENCAP_OPTION_CLEAR))) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_port_egress_obj_used(unit,
                                                            info->egress_if,
                                                            &used));
                if (used) {
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }
            }
        }

        if ((info->valid_elements & BCM_FLOW_PORT_ENCAP_FLAGS_VALID) &&
             (info->flags & BCM_FLOW_ENCAP_FLAG_SERVICE_TAGGED)) {
             update_l2_tag |= 1;
        }
        if ((info->valid_elements & BCM_FLOW_PORT_ENCAP_FLAGS_VALID) &&
             (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_OPAQUE_TAGGED)) {
             update_l2_tag |= 1;
        }
        if (info->valid_elements & BCM_FLOW_PORT_ENCAP_ES_ID_VALID) {
             update_l2_tag |= 1;
        }
        if (update_l2_tag && (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "L2 Tag on access VP only!\n")));

        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Confingure MTU info to LT entry handle.
 *
 * \param [in]  unit           Unit number.
 * \param [in]  info           Egress encap info structure.
 * \param [in]  entry_hd_read  LT handle.
 * \param [in]  entry_hd       LT handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_port_encap_mtu_ctrl(int unit,
                             bcmint_flow_hw_opt_type_t opt,
                             bcm_flow_port_encap_t *info,
                             bcmlt_entry_handle_t entry_hd_read,
                             bcmlt_entry_handle_t entry_hd)
{
    port_encap_mtu_profile_t entry;
    int idx = 0;
    int old_idx = 0;
    uint64_t get_val;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
       (bcmlt_entry_field_get(entry_hd_read, PORT_DVP_MTU_PROFILE_IDs,
                              &get_val));
    old_idx = (uint32_t)get_val;
    if (opt == HW_OPT_GET) {
        if (old_idx != FLOW_PORT_ENCAP_MTU_PROFILE_DEF) {
            sal_memset(&entry, 0, sizeof(entry));
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_port_encap_mtu_profile_entry_get(unit, old_idx,
                                                           &entry));
            info->mtu = entry.mtu;
        } else {
            info->mtu = 0;
        }
    } else if (opt == HW_OPT_SET) {
        if (old_idx != FLOW_PORT_ENCAP_MTU_PROFILE_DEF) {
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_port_encap_mtu_profile_delete(unit, old_idx));
        }

        if (info->options & BCM_FLOW_PORT_ENCAP_OPTION_CLEAR) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, PORT_DVP_MTU_PROFILE_IDs,
                                       FLOW_PORT_ENCAP_MTU_PROFILE_DEF));
        } else {
            sal_memset(&entry, 0, sizeof(entry));
            entry.enable = 1;
            entry.mtu = info->mtu;
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_port_encap_mtu_profile_add(unit, &entry, &idx));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, PORT_DVP_MTU_PROFILE_IDs,
                                       idx));
        }
    } else {
        /* Do nothing. */
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update tag action to nexthop.
 *
 * \param [in]  unit           Unit number.
 * \param [in]  info           Egress encap info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_port_encap_egr_obj_set(int unit,
                                bcm_flow_port_encap_t *info)
{
    bcmi_ltsw_l3_egr_l2_tag_info_t l2_tag_info;
    int nh_idx;
    bcmi_ltsw_l3_egr_obj_type_t nh_type;
    int update = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_egress_obj_id_resolve(unit,
                                            info->egress_if,
                                            &nh_idx,
                                            &nh_type));

    sal_memset(&l2_tag_info, 0, sizeof(l2_tag_info));
    if (info->options & BCM_FLOW_PORT_ENCAP_OPTION_REPLACE) {
        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_ltsw_l3_egress_get_l2tag(unit, nh_idx, &l2_tag_info), SHR_E_NOT_FOUND);
        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_ltsw_l3_egress_delete_l2tag(unit, nh_idx), SHR_E_NOT_FOUND);
    }
    if ((info->valid_elements & BCM_FLOW_PORT_ENCAP_FLAGS_VALID) &&
        (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_SERVICE_TAGGED)) {
        uint64_t action_present = 0;
        uint64_t action_not_present = 0;
        int remark_cfi = 0;
        int tpid_idx = 0;

        update |= 1;

        if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_SERVICE_VLAN_ADD) {
            remark_cfi = TRUE;
            action_not_present =
                BCMI_LTSW_VLAN_TAG_NOT_PRESENT_ACTION_ADD_VLAN_TPID;
        }

        if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_SERVICE_VLAN_TPID_REPLACE) {
            action_present =
                BCMI_LTSW_VLAN_TAG_PRESENT_ACTION_REPLACE_VLAN_TPID;
        } else if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_VLAN_REPLACE) {
            action_present = BCMI_LTSW_VLAN_TAG_PRESENT_ACTION_REPLACE_VLAN;
        } else if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_VLAN_DELETE) {
            action_present = BCMI_LTSW_VLAN_TAG_PRESENT_ACTION_DELETE;
        } else if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_VLAN_PRI_TPID_REPLACE) {
            remark_cfi = TRUE;
            action_present =
                BCMI_LTSW_VLAN_TAG_PRESENT_ACTION_REPLACE_VLAN_PRI_TPID;
        } else if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_VLAN_PRI_REPLACE){
            remark_cfi = TRUE;
            action_present = ACTION_IF_PRESENT_REPLACE_VID_PRI_ONLY;
        } else if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_PRI_REPLACE ) {
            remark_cfi = TRUE;
            action_present = BCMI_LTSW_VLAN_TAG_PRESENT_ACTION_REPLACE_PRI;
        } else if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_TPID_REPLACE) {
            action_present = BCMI_LTSW_VLAN_TAG_PRESENT_ACTION_REPLACE_TPID;
        }

        if (info->valid_elements & BCM_FLOW_PORT_ENCAP_VLAN_VALID) {
            l2_tag_info.vlan = info->vlan;
        }
        if (info->valid_elements & BCM_FLOW_PORT_ENCAP_PKT_PRI_VALID) {
            l2_tag_info.pri = info->pri;
        }
        if (info->valid_elements & BCM_FLOW_PORT_ENCAP_PKT_CFI_VALID) {
            l2_tag_info.cfi = info->cfi;
        }
        l2_tag_info.remark_cfi = remark_cfi;
        l2_tag_info.vlan_tag_present_action = action_present;
        l2_tag_info.vlan_tag_not_present_action = action_not_present;

        if ((info->flags & BCM_FLOW_PORT_ENCAP_FLAG_SERVICE_VLAN_ADD) ||
            (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_SERVICE_VLAN_TPID_REPLACE) ||
            (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_TPID_REPLACE) ||
            (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_VLAN_PRI_TPID_REPLACE)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_vlan_otpid_entry_add(unit, info->tpid, &tpid_idx));
            l2_tag_info.tpid_id = tpid_idx;
        } else {
            /*
             * If no TPID configured, the value in default TPID index 0
             * will be used so adjust the ref count here.
             */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_vlan_otpid_entry_ref_count_add(unit, 0, 1));
        }
    }

    /* Opaque tag handling. */
    if ((info->valid_elements & BCM_FLOW_PORT_ENCAP_FLAGS_VALID) &&
        (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_OPAQUE_TAGGED )) {
        update |= 1;

        if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_OPAQUE_TAG_ADD) {
            l2_tag_info.opaque_tag_not_present_action =
                BCMI_LTSW_OPAQUE_TAG_NOT_PRESENT_ACTION_ADD;
        } else {
            /* No need to update action, avoid reset the readback value. */
        }
        if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_OPAQUE_TAG_REPLACE) {
            l2_tag_info.opaque_tag_present_action =
                BCMI_LTSW_OPAQUE_TAG_PRESENT_ACTION_REPLACE;
        } else if (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_OPAQUE_TAG_DELETE) {
            l2_tag_info.opaque_tag_present_action =
                BCMI_LTSW_OPAQUE_TAG_PRESENT_ACTION_DELETE;
        } else {
            /* No need to update action, avoid reset the readback value. */
        }
    }

    /* ES_ID handling. */
    if (info->valid_elements & BCM_FLOW_PORT_ENCAP_ES_ID_VALID) {
        update |= 1;

        l2_tag_info.es_id = info->es_id;
    }

    if (update) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_add_l2tag(unit, nh_idx, &l2_tag_info));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get tag action from nexthop.
 *
 * \param [in]  unit           Unit number.
 * \param [in/out]  info           Egress encap info structure.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_port_encap_egr_obj_get(int unit,
                                bcm_flow_port_encap_t *info)
{
    bcmi_ltsw_l3_egr_l2_tag_info_t l2_tag_info;
    int nh_idx;
    bcmi_ltsw_l3_egr_obj_type_t nh_type;
    uint32_t action_present = 0;
    uint32_t action_not_present = 0;
    uint16_t tpid = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_egress_obj_id_resolve(unit,
                                            info->egress_if,
                                            &nh_idx,
                                            &nh_type));

    sal_memset(&l2_tag_info, 0, sizeof(l2_tag_info));
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_l3_egress_get_l2tag(unit, nh_idx, &l2_tag_info), SHR_E_NOT_FOUND);
    /* ES_ID handling. */
    info->es_id = l2_tag_info.es_id;

    /* vlan action handling. */
    action_present = l2_tag_info.vlan_tag_present_action;
    action_not_present = l2_tag_info.vlan_tag_not_present_action;
    if (action_not_present || action_present) {
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_SERVICE_TAGGED;
    }
    if (action_not_present) {
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_SERVICE_VLAN_ADD;
    }
    if (action_present == ACTION_IF_PRESENT_REPLACE_VID_TPID) {
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_SERVICE_VLAN_TPID_REPLACE;
    } else if (action_present == ACTION_IF_PRESENT_REPLACE_VID_ONLY) {
        info->flags  |= BCM_FLOW_PORT_ENCAP_FLAG_VLAN_REPLACE;
    } else if (action_present == ACTION_IF_PRESENT_DELETE) {
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_VLAN_DELETE;
    } else if (action_present == ACTION_IF_PRESENT_REPLACE_VID_PRI_TPID) {
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_VLAN_PRI_TPID_REPLACE;
    } else if (action_present == ACTION_IF_PRESENT_REPLACE_VID_PRI_ONLY) {
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_VLAN_PRI_REPLACE;
    } else if (action_present == ACTION_IF_PRESENT_REPLACE_PRI_ONLY) {
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_PRI_REPLACE;
    } else if (action_present == ACTION_IF_PRESENT_REPLACE_TPID_ONLY) {
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_TPID_REPLACE;
    }

    if ((info->flags & BCM_FLOW_PORT_ENCAP_FLAG_SERVICE_VLAN_ADD) ||
        (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_SERVICE_VLAN_TPID_REPLACE) ||
        (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_TPID_REPLACE) ||
        (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_VLAN_PRI_TPID_REPLACE)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_vlan_otpid_entry_get(unit, l2_tag_info.tpid_id, &tpid));
        info->tpid = tpid;
    }

    info->vlan = l2_tag_info.vlan;
    info->pri = l2_tag_info.pri;
    info->cfi = l2_tag_info.cfi;

    /* Opaque action handling. */
    action_present = l2_tag_info.opaque_tag_present_action;
    if (action_present == BCMI_LTSW_OPAQUE_TAG_PRESENT_ACTION_REPLACE) {
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_OPAQUE_TAG_REPLACE;
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_OPAQUE_TAGGED;
    } else if (action_present == BCMI_LTSW_OPAQUE_TAG_PRESENT_ACTION_DELETE) {
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_OPAQUE_TAG_DELETE;
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_OPAQUE_TAGGED;
    } else {
        /* No need to update flags. */
    }
    action_not_present = l2_tag_info.opaque_tag_not_present_action;
    if (action_not_present == BCMI_LTSW_OPAQUE_TAG_NOT_PRESENT_ACTION_ADD) {
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_OPAQUE_TAG_ADD;
        info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_OPAQUE_TAGGED;
    } else {
        /* No need to update flags. */
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the parameters for encap configuration.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Flow encap information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_param_validation(int unit,
                                bcmint_flow_hw_opt_type_t opt,
                                bcm_flow_encap_config_t *info)
{
    int rv = SHR_E_NONE;
    int vp = -1;
    uint32 supported_elements = 0;

    SHR_FUNC_ENTER(unit);

    if (info->flow_handle == BCMINT_FLOW_ID_INT) {
        if ((info->flow_option != 0) && (info->flow_option !=
            BCMINT_FLOW_OPT_ID_ASSIGN_DEVICE_ID_TEMPLATE_ID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid flow option :%d!\n"),
                                            info->flow_option));

        } else {
            SHR_EXIT();
        }
    }

    /* Validate criteria. */
    switch(info->criteria) {
        case BCM_FLOW_ENCAP_CRITERIA_VFI:
            break;
        case BCM_FLOW_ENCAP_CRITERIA_VFI_DVP_GROUP:
            break;
        case BCM_FLOW_ENCAP_CRITERIA_VFI_PORT_GROUP:
            break;
        default:
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "invalid criteria:%d!\n"),
                                            info->criteria));
    }

    /* Validate flow option vs criteria. */
    if (info->flow_option == BCMINT_FLOW_OPT_ID_LOOKUP_VFI_ASSIGN_VNID) {
        if (info->criteria != BCM_FLOW_ENCAP_CRITERIA_VFI) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VFI must be criteria for \
                                            LOOKUP_VFI_ASSIGN_VNID!\n")));
        }
    }
    if (info->flow_option == BCMINT_FLOW_OPT_ID_LOOKUP_DVP_VFI_ASSIGN_VNID) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "LOOKUP_DVP_VFI_ASSIGN_VNID not \
                                        supported!\n")));
    }

    /* Validate criteria vs valid elements. */
    if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI) {
        if (!(info->valid_elements & BCM_FLOW_ENCAP_VPN_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VPN not provided!\n")));
        }
        supported_elements = BCM_FLOW_ENCAP_VPN_VALID |
                             BCM_FLOW_ENCAP_TPID_VALID |
                             BCM_FLOW_ENCAP_VNID_VALID |
                             BCM_FLOW_ENCAP_VLAN_VALID |
                             BCM_FLOW_ENCAP_PKT_PRI_VALID |
                             BCM_FLOW_ENCAP_PKT_CFI_VALID |
                             BCM_FLOW_ENCAP_FLAGS_VALID;
        if (info->valid_elements & (~supported_elements)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "elements:supported(%d)/provided(%d)!\n"),
                                            supported_elements, info->valid_elements));
        }
    } else  if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI_DVP_GROUP) {
        if (!(info->valid_elements & BCM_FLOW_ENCAP_VPN_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VPN not provided!\n")));
        }
        if (!(info->valid_elements & BCM_FLOW_ENCAP_DVP_GROUP_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "DVP group not provided!\n")));
        }
        supported_elements = BCM_FLOW_ENCAP_VPN_VALID |
                             BCM_FLOW_ENCAP_DVP_GROUP_VALID |
                             BCM_FLOW_ENCAP_VNID_VALID |
                             BCM_FLOW_ENCAP_TPID_VALID |
                             BCM_FLOW_ENCAP_VLAN_VALID |
                             BCM_FLOW_ENCAP_PKT_PRI_VALID |
                             BCM_FLOW_ENCAP_PKT_CFI_VALID |
                             BCM_FLOW_ENCAP_FLAGS_VALID;

        if (info->valid_elements & (~supported_elements)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "elements:supported(%d)/provided(%d)!\n"),
                                            supported_elements, info->valid_elements));
        }
    } else  if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI_PORT_GROUP) {
        if (!(info->valid_elements & BCM_FLOW_ENCAP_VPN_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VPN not provided!\n")));
        }
        if (!(info->valid_elements & BCM_FLOW_ENCAP_PORT_GROUP_VALID )) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Port group not provided!\n")));
        }
        supported_elements = BCM_FLOW_ENCAP_VPN_VALID |
                             BCM_FLOW_ENCAP_PORT_GROUP_VALID  |
                             BCM_FLOW_ENCAP_FLOW_PORT_VALID |
                             BCM_FLOW_ENCAP_DVP_GROUP_VALID |
                             BCM_FLOW_ENCAP_TPID_VALID |
                             BCM_FLOW_ENCAP_VLAN_VALID |
                             BCM_FLOW_ENCAP_PKT_PRI_VALID |
                             BCM_FLOW_ENCAP_PKT_CFI_VALID |
                             BCM_FLOW_ENCAP_FLAGS_VALID;

        if (info->valid_elements & (~supported_elements)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "elements:supported(%d)/provided(%d)!\n"),
                                            supported_elements, info->valid_elements));
        }
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

    /* Validate elements */
     if (info->valid_elements & BCM_FLOW_ENCAP_FLOW_PORT_VALID) {
         vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
         if ((vp == -1) ||
             bcmi_ltsw_virtual_vp_used_get(unit, vp,
                                           BCMI_LTSW_VP_TYPE_FLOW)) {
             SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                 (BSL_META_U(unit, "Invalid flow port:%d!\n"),
                                             info->flow_port));
         }
     }
      if (info->valid_elements & BCM_FLOW_ENCAP_VPN_VALID) {
          rv = bcmint_flow_vpn_is_valid(unit, info->vpn);
          if ((BCM_FAILURE(rv))) {
              SHR_IF_ERR_MSG_EXIT(rv,
                                  (BSL_META_U(unit, "Invalid VPN:%d!\n"),
                                              info->vpn));
          }
      }
      if (info->valid_elements & BCM_FLOW_ENCAP_VNID_VALID) {
          if (info->vnid == BCMINT_FLOW_VNID_RESERVED) {
              SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                  (BSL_META_U(unit, "VNID 0 reserved for \
                                              internal use!\n")));
          }
      }

      if (info->valid_elements & BCM_FLOW_ENCAP_VLAN_VALID) {
          if (info->vlan >= BCM_VLAN_INVALID) {
              SHR_IF_ERR_MSG_EXIT(rv,
                                  (BSL_META_U(unit, "Invalid vlan:%d!\n"),
                                              info->vlan));
          }
      }
      if (info->valid_elements & BCM_FLOW_ENCAP_PKT_PRI_VALID) {
          if (info->pri >= BCM_PRIO_MAX) {
              SHR_IF_ERR_MSG_EXIT(rv,
                                  (BSL_META_U(unit, "Invalid pri:%d!\n"),
                                              info->pri));
          }
      }
      if (info->valid_elements & BCM_FLOW_ENCAP_PKT_CFI_VALID) {
          if (info->cfi > 1) {
              SHR_IF_ERR_MSG_EXIT(rv,
                                  (BSL_META_U(unit, "Invalid cfi:%d!\n"),
                                              info->cfi));
          }
      }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Determine logical table based on encap info.
 *
 * \param [in]  unit    Unit number.
 * \param [in]  info    Flow encap information.
 * \param [out] lt_name Logical table name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_lt_determine(int unit,
                            bcm_flow_encap_config_t *info,
                            const char **lt_name)
{
    SHR_FUNC_ENTER(unit);

    if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI) {
        *lt_name = TNL_L2_VXLAN_ADAPT_VFIs;
    } else if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI_DVP_GROUP) {
        *lt_name = TNL_L2_VXLAN_ADAPT_VFI_DVP_GRPs;
    } else if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI_PORT_GROUP) {
        *lt_name = VFI_EGR_ADAPT_PORT_GRPs;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Determine encap criteria based on logical table.
 *
 * \param [in]  unit    Unit number.
 * \param [in]  lt_name Logical table name.
 * \param [out] info    Flow encap information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_criteria_determine(int unit,
                                  const char *lt_name,
                                  bcm_flow_encap_config_t *info)
{
    SHR_FUNC_ENTER(unit);

    if (lt_name == TNL_L2_VXLAN_ADAPT_VFIs) {
        info->criteria = BCM_FLOW_ENCAP_CRITERIA_VFI;
        info->valid_elements = BCM_FLOW_ENCAP_VPN_VALID |
                               BCM_FLOW_ENCAP_VNID_VALID |
                               BCM_FLOW_ENCAP_VLAN_VALID |
                               BCM_FLOW_ENCAP_PKT_PRI_VALID |
                               BCM_FLOW_ENCAP_PKT_CFI_VALID |
                               BCM_FLOW_ENCAP_FLAGS_VALID;
    } else if (lt_name == TNL_L2_VXLAN_ADAPT_VFI_DVP_GRPs) {
        info->criteria = BCM_FLOW_ENCAP_CRITERIA_VFI_DVP_GROUP;
        info->valid_elements = BCM_FLOW_ENCAP_VPN_VALID |
                               BCM_FLOW_ENCAP_DVP_GROUP_VALID |
                               BCM_FLOW_ENCAP_VNID_VALID |
                               BCM_FLOW_ENCAP_VLAN_VALID |
                               BCM_FLOW_ENCAP_PKT_PRI_VALID |
                               BCM_FLOW_ENCAP_PKT_CFI_VALID |
                               BCM_FLOW_ENCAP_FLAGS_VALID;
    } else if (lt_name == VFI_EGR_ADAPT_PORT_GRPs) {
        info->criteria = BCM_FLOW_ENCAP_CRITERIA_VFI_PORT_GROUP ;
        info->valid_elements = BCM_FLOW_ENCAP_VPN_VALID |
                               BCM_FLOW_ENCAP_PORT_GROUP_VALID  |
                               BCM_FLOW_ENCAP_VLAN_VALID |
                               BCM_FLOW_ENCAP_PKT_PRI_VALID |
                               BCM_FLOW_ENCAP_PKT_CFI_VALID |
                               BCM_FLOW_ENCAP_FLAGS_VALID;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad lt:%s!\n"), lt_name));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set key based on encap criteria.
 *
 * \param [in]  unit     Unit number.
 * \param [in]  info     Flow encap information.
 * \param [in]  entry_hd Logical table entry handle..
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_key_set(int unit,
                       bcm_flow_encap_config_t *info,
                       bcmlt_entry_handle_t entry_hd)
{
    uint32_t vfi_idx = -1;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_idx_get(unit, info->vpn, &vfi_idx));

    if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VFI_IDs, vfi_idx));
    } else if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI_DVP_GROUP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, DVP_GRPs,
                                   info->dvp_group));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VFI_IDs, vfi_idx));
    } else if (info->criteria == BCM_FLOW_ENCAP_CRITERIA_VFI_PORT_GROUP ) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, PORT_GRPs,
                                   info->port_group));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VFI_IDs, vfi_idx));
        /* Assume termination status as 1 for vxlan flow. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VXLAN_DECAPs, 0x1));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get key info based on encap criteria.
 *
 * \param [in]  unit     Unit number.
 * \param [in]  info     Flow encap information.
 * \param [in]  entry_hd Logical table entry handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_key_get(int unit,
                       bcm_flow_encap_config_t *info,
                       const bcmlt_entry_handle_t entry_hd)
{
    uint64_t get_val;

    SHR_FUNC_ENTER(unit);

    if (info->valid_elements & BCM_FLOW_ENCAP_VPN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, VFI_IDs, &get_val));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, get_val, &(info->vpn)));

    }
    if (info->valid_elements & BCM_FLOW_ENCAP_DVP_GROUP_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, DVP_GRPs, &get_val));
        info->dvp_group = (uint32_t)get_val;
    }
    if (info->valid_elements & BCM_FLOW_ENCAP_PORT_GROUP_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, PORT_GRPs, &get_val));
        info->port_group = (uint32_t)get_val;
    }

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set valid element based on logical table.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   entry_hd      Logical table entry handle.
 * \param [in]   lt_name       Logical table name.
 * \param [out]  valid_element Element valid status.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_data_valid_indicator(int unit,
                                    const char *lt_name,
                                    const bcmlt_entry_handle_t entry_hd,
                                    uint32_t *valid_element,
                                    uint32_t *valid_flags)
{
    SHR_FUNC_ENTER(unit);

    *valid_element = 0;
    *valid_flags = 0;
    if (lt_name == TNL_L2_VXLAN_ADAPT_VFIs) {
        *valid_element = BCM_FLOW_ENCAP_VNID_VALID |
                         BCM_FLOW_ENCAP_TPID_VALID |
                         BCM_FLOW_ENCAP_VLAN_VALID |
                         BCM_FLOW_ENCAP_PKT_PRI_VALID |
                         BCM_FLOW_ENCAP_PKT_CFI_VALID |
                         BCM_FLOW_ENCAP_FLAGS_VALID;
    } else if (lt_name == TNL_L2_VXLAN_ADAPT_VFI_DVP_GRPs) {
        *valid_element = BCM_FLOW_ENCAP_VNID_VALID |
                         BCM_FLOW_ENCAP_TPID_VALID |
                         BCM_FLOW_ENCAP_VLAN_VALID |
                         BCM_FLOW_ENCAP_PKT_PRI_VALID |
                         BCM_FLOW_ENCAP_PKT_CFI_VALID |
                         BCM_FLOW_ENCAP_FLAGS_VALID;

    } else if (lt_name == VFI_EGR_ADAPT_PORT_GRPs) {
        *valid_element = BCM_FLOW_ENCAP_FLOW_PORT_VALID |
                         BCM_FLOW_ENCAP_DVP_GROUP_VALID |
                         BCM_FLOW_ENCAP_TPID_VALID |
                         BCM_FLOW_ENCAP_VLAN_VALID |
                         BCM_FLOW_ENCAP_PKT_PRI_VALID |
                         BCM_FLOW_ENCAP_PKT_CFI_VALID |
                         BCM_FLOW_ENCAP_FLAGS_VALID;

    } else {
       SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
   SHR_FUNC_EXIT();
}

/*!
 * \brief Set data portion based on encap info.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   lt_name       Logical table name.
 * \param [in]   info          Flow encap information.
 * \param [in]   entry_hd      Logical table entry handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_data_set(int unit,
                        const char *lt_name,
                        bcm_flow_encap_config_t *info,
                        bcmlt_entry_handle_t entry_hd)
{
    SHR_FUNC_ENTER(unit);

    if (info->options & BCM_FLOW_ENCAP_OPTION_REPLACE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hd, VNIDs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hd, OVIDs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hd, OPRIs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hd, REMARK_CFIs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hd, VLAN_TAG_PRESENT_ACTIONs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hd, VLAN_TAG_NOT_PRESENT_ACTIONs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hd, L2_OPAQUE_TAG_NOT_PRESENT_ACTIONs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hd, L2_OPAQUE_TAG_PRESENT_ACTIONs));
    }

    if (info->valid_elements & BCM_FLOW_ENCAP_VNID_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VNIDs, info->vnid));
    }
    if (info->valid_elements & BCM_FLOW_ENCAP_DVP_GROUP_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, DVP_GRPs, info->dvp_group));
    }
    if (info->valid_elements & BCM_FLOW_ENCAP_FLOW_PORT_VALID) {
        int vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, PORT_DVP_IDs, vp));
    }

    if ((info->valid_elements & BCM_FLOW_ENCAP_FLAGS_VALID) &&
        (info->flags & BCM_FLOW_ENCAP_FLAG_SERVICE_TAGGED)) {
        uint64_t action_present = 0;
        uint64_t action_not_present = 0;
        int remark_cfi = 0;
        int tpid_idx = 0;
        const char *field_symbol = NULL;

        if (info->flags & BCM_FLOW_ENCAP_FLAG_SERVICE_VLAN_ADD) {
            remark_cfi = TRUE;
            action_not_present = ACTION_IF_NOT_PRESENT_ADD_VID_TPID;
        }

        if (info->flags & BCM_FLOW_ENCAP_FLAG_SERVICE_VLAN_TPID_REPLACE) {
            action_present = ACTION_IF_PRESENT_REPLACE_VID_TPID;
        } else if (info->flags & BCM_FLOW_ENCAP_FLAG_VLAN_REPLACE) {
            action_present = ACTION_IF_PRESENT_REPLACE_VID_ONLY;
        } else if (info->flags & BCM_FLOW_ENCAP_FLAG_VLAN_DELETE) {
            action_present = ACTION_IF_PRESENT_DELETE;
        } else if (info->flags & BCM_FLOW_ENCAP_FLAG_VLAN_PRI_TPID_REPLACE) {
            remark_cfi = TRUE;
            action_present = ACTION_IF_PRESENT_REPLACE_VID_PRI_TPID;
        } else if (info->flags & BCM_FLOW_ENCAP_FLAG_VLAN_PRI_REPLACE){
            remark_cfi = TRUE;
            action_present = ACTION_IF_PRESENT_REPLACE_VID_PRI_ONLY;
        } else if (info->flags & BCM_FLOW_ENCAP_FLAG_PRI_REPLACE ) {
            remark_cfi = TRUE;
            action_present = ACTION_IF_PRESENT_REPLACE_PRI_ONLY;
        } else if (info->flags & BCM_FLOW_ENCAP_FLAG_TPID_REPLACE) {
            action_present = ACTION_IF_PRESENT_REPLACE_TPID_ONLY;
        }

        if (info->valid_elements & BCM_FLOW_ENCAP_VLAN_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OVIDs, info->vlan));
        }
        if (info->valid_elements & BCM_FLOW_ENCAP_PKT_PRI_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OPRIs, info->pri));

        }
        if (info->valid_elements & BCM_FLOW_ENCAP_PKT_CFI_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OCFIs, info->cfi));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, REMARK_CFIs, remark_cfi));

        SHR_IF_ERR_VERBOSE_EXIT
            (action_if_present_scalar_to_symbol(unit, action_present,
                                                &field_symbol));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hd, VLAN_TAG_PRESENT_ACTIONs,
                                          field_symbol));
        SHR_IF_ERR_VERBOSE_EXIT
            (action_if_not_present_scalar_to_symbol(unit, action_not_present,
                                                    &field_symbol));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hd,
                                          VLAN_TAG_NOT_PRESENT_ACTIONs,
                                          field_symbol));

        if ((info->flags & BCM_FLOW_ENCAP_FLAG_SERVICE_VLAN_ADD) ||
            (info->flags & BCM_FLOW_ENCAP_FLAG_SERVICE_VLAN_TPID_REPLACE) ||
            (info->flags & BCM_FLOW_ENCAP_FLAG_TPID_REPLACE) ||
            (info->flags & BCM_FLOW_ENCAP_FLAG_VLAN_PRI_TPID_REPLACE)) {
            if (info->options & BCM_FLOW_ENCAP_OPTION_REPLACE) {
                uint64_t get_val;
                int old_tpid_idx = 0;

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hd, VLAN_OUTER_TPID_IDs,
                                           &get_val));
                old_tpid_idx = (int)get_val;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_vlan_otpid_entry_delete(unit, old_tpid_idx));

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_remove(entry_hd, VLAN_OUTER_TPID_IDs));
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_vlan_otpid_entry_add(unit, info->tpid, &tpid_idx));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, VLAN_OUTER_TPID_IDs,
                                       tpid_idx));
        } else {
            /*
             * If no TPID configured, the value in default TPID index 0
             * will be used so adjust the ref count here.
             */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_vlan_otpid_entry_ref_count_add(unit, 0, 1));
        }
    }

    /* Opaque tag handling. */
    if ((info->valid_elements & BCM_FLOW_ENCAP_FLAGS_VALID) &&
        (info->flags & BCM_FLOW_ENCAP_FLAG_OPAQUE_TAGGED )) {

        if (info->flags & BCM_FLOW_ENCAP_FLAG_OPAQUE_TAG_ADD) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hd,
                                              L2_OPAQUE_TAG_NOT_PRESENT_ACTIONs,
                                              ADDs));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hd,
                                              L2_OPAQUE_TAG_NOT_PRESENT_ACTIONs,
                                              NO_ACTIONs));
        }

        if (info->flags & BCM_FLOW_ENCAP_FLAG_OPAQUE_TAG_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hd,
                                              L2_OPAQUE_TAG_PRESENT_ACTIONs,
                                              REPLACEs));
        } else if (info->flags & BCM_FLOW_ENCAP_FLAG_OPAQUE_TAG_DELETE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hd,
                                              L2_OPAQUE_TAG_PRESENT_ACTIONs,
                                              DELETEs));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hd,
                                              L2_OPAQUE_TAG_PRESENT_ACTIONs,
                                              NO_ACTIONs));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get data portion based on encap info.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   info          Flow encap information.
 * \param [in]   lt_name       Logical table name.
 * \param [in]   entry_hd      Logical table entry handle.
 * \param [out]  valid         Indicate whether valid data found.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_data_get(int unit,
                        bcm_flow_encap_config_t *info,
                        const char *lt_name,
                        const bcmlt_entry_handle_t entry_hd,
                        uint8_t *valid)
{
    uint64_t get_val;
    uint32_t valid_element = 0;
    uint32_t valid_flags = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_data_valid_indicator(unit, lt_name, entry_hd,
                                             &valid_element, &valid_flags));

    *valid = 0;
    if (valid_element & BCM_FLOW_ENCAP_VNID_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, VNIDs, &get_val));
        info->vnid = (int)get_val;

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_ENCAP_VLAN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OVIDs, &get_val));
        info->vlan = (int)get_val;

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_ENCAP_PKT_PRI_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OPRIs, &get_val));
        info->pri = (int)get_val;

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_ENCAP_PKT_CFI_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OCFIs, &get_val));
        info->cfi = (int)get_val;

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_ENCAP_DVP_GROUP_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, DVP_GRPs, &get_val));
        info->dvp_group = (int)get_val;

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_ENCAP_FLOW_PORT_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, PORT_DVP_IDs, &get_val));
        BCM_GPORT_FLOW_PORT_ID_SET(info->flow_port, (int)get_val);

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_ENCAP_FLAGS_VALID) {
        uint64_t action_present = 0;
        uint64_t action_not_present = 0;
        int tpid_idx = 0;
        uint16_t tpid = 0;
        const char *field_symbol = NULL;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hd, VLAN_TAG_PRESENT_ACTIONs,
                                          &field_symbol));
        SHR_IF_ERR_VERBOSE_EXIT
            (action_if_present_symbol_to_scalar(unit, field_symbol,
                                                &action_present));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hd, VLAN_TAG_NOT_PRESENT_ACTIONs,
                                          &field_symbol));
        SHR_IF_ERR_VERBOSE_EXIT
            (action_if_not_present_symbol_to_scalar(unit, field_symbol,
                                                    &action_not_present));

        if (action_not_present || action_present) {
            info->flags |= BCM_FLOW_ENCAP_FLAG_SERVICE_TAGGED;
        }
        if (action_not_present) {
            info->flags |= BCM_FLOW_ENCAP_FLAG_SERVICE_VLAN_ADD;
        }

        if (action_present == ACTION_IF_PRESENT_REPLACE_VID_TPID) {
            info->flags |= BCM_FLOW_ENCAP_FLAG_SERVICE_VLAN_TPID_REPLACE;
        } else if (action_present == ACTION_IF_PRESENT_REPLACE_VID_ONLY) {
            info->flags  |= BCM_FLOW_ENCAP_FLAG_VLAN_REPLACE;
        } else if (action_present == ACTION_IF_PRESENT_DELETE) {
            info->flags |= BCM_FLOW_ENCAP_FLAG_VLAN_DELETE;
        } else if (action_present == ACTION_IF_PRESENT_REPLACE_VID_PRI_TPID) {
            info->flags |= BCM_FLOW_ENCAP_FLAG_VLAN_PRI_TPID_REPLACE;
        } else if (action_present == ACTION_IF_PRESENT_REPLACE_VID_PRI_ONLY) {
            info->flags |= BCM_FLOW_ENCAP_FLAG_VLAN_PRI_REPLACE;
        } else if (action_present == ACTION_IF_PRESENT_REPLACE_PRI_ONLY) {
            info->flags |= BCM_FLOW_ENCAP_FLAG_PRI_REPLACE;
        } else if (action_present == ACTION_IF_PRESENT_REPLACE_TPID_ONLY) {
            info->flags |= BCM_FLOW_ENCAP_FLAG_TPID_REPLACE;
        }

        if ((info->flags & BCM_FLOW_ENCAP_FLAG_SERVICE_VLAN_ADD) ||
            (info->flags & BCM_FLOW_ENCAP_FLAG_SERVICE_VLAN_TPID_REPLACE) ||
            (info->flags & BCM_FLOW_ENCAP_FLAG_TPID_REPLACE) ||
            (info->flags & BCM_FLOW_ENCAP_FLAG_VLAN_PRI_TPID_REPLACE)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hd, VLAN_OUTER_TPID_IDs,
                                       &get_val));
            tpid_idx = (int)get_val;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_vlan_otpid_entry_get(unit, tpid_idx, &tpid));
            info->tpid = tpid;
            *valid = 1;
        }
    }

     if (valid_element & BCM_FLOW_ENCAP_FLAGS_VALID) {
         const char *action_present_symbol = NULL;
         const char *action_not_presentsymbol = NULL;

         SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_symbol_get(entry_hd,
                                           L2_OPAQUE_TAG_PRESENT_ACTIONs,
                                           &action_present_symbol));
         if (!sal_strcmp(action_present_symbol, REPLACEs)) {
             info->flags |= BCM_FLOW_ENCAP_FLAG_OPAQUE_TAG_REPLACE;
             info->flags |= BCM_FLOW_ENCAP_FLAG_OPAQUE_TAGGED;
         } else if (!sal_strcmp(action_present_symbol, DELETEs)){
             info->flags |= BCM_FLOW_ENCAP_FLAG_OPAQUE_TAG_DELETE;
             info->flags |= BCM_FLOW_ENCAP_FLAG_OPAQUE_TAGGED;
         } else if (!sal_strcmp(action_present_symbol, NO_ACTIONs)){
             /* No need to update flags. */
         } else {
             SHR_ERR_EXIT(SHR_E_PARAM);
         }

         SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_symbol_get(entry_hd,
                                           L2_OPAQUE_TAG_NOT_PRESENT_ACTIONs,
                                           &action_not_presentsymbol));
         if (!sal_strcmp(action_not_presentsymbol, ADDs)) {
             info->flags |= BCM_FLOW_ENCAP_FLAG_OPAQUE_TAG_ADD;
             info->flags |= BCM_FLOW_ENCAP_FLAG_OPAQUE_TAGGED;
         } else if (!sal_strcmp(action_not_presentsymbol, NO_ACTIONs)){
             /* No need to update flags. */
         } else {
             SHR_ERR_EXIT(SHR_E_PARAM);
         }
     }

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Configuration on hash table based on encap info.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Flow encap information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_general_ctrl(int unit,
                            bcmint_flow_hw_opt_type_t opt,
                            bcm_flow_encap_config_t *info)
{

    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    uint8_t valid = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_lt_determine(unit, info, &lt_name));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_key_set(unit, info, entry_hd));
    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                                   BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_encap_data_get(unit, info, lt_name, entry_hd, &valid));
    } else if (opt == HW_OPT_SET) {
        if (info->options & BCM_FLOW_ENCAP_OPTION_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                 (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                                       BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_encap_data_set(unit, lt_name, info, entry_hd));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_UPDATE,
                                      BCMLT_PRIORITY_NORMAL));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_encap_data_set(unit, lt_name, info, entry_hd));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_INSERT,
                                      BCMLT_PRIORITY_NORMAL));
        }
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hd) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse hash table for encap info.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     cb            User callback function.
 * \param [in]     user_data     User context data.
 * \param [in]     lt_name       Logical table name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_hash_table_traverse(int unit,
                                   bcm_flow_encap_traverse_cb cb,
                                   void *user_data,
                                   const char *lt_name)
{
    int rv = SHR_E_NONE;
    bcm_flow_encap_config_t info = {0};
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint8_t valid = 0;
    int rv1 = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    while ((rv = bcmi_lt_entry_commit(dunit, entry_hd, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        bcm_flow_encap_config_t_init(&info);

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_encap_criteria_determine(unit, lt_name, &info));

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_encap_key_get(unit, &info, entry_hd));

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_encap_data_get(unit, &info, lt_name, entry_hd, &valid));

        if (valid == 0) {
            continue;
        }

        if (cb) {
            rv1 = (*cb) (unit, &info, 0, NULL, user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Configuration on INT parameter based on encap info.
 *
 * \param [in] unit            Unit number.
 * \param [in] opt             Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info            Flow encap information.
 * \param [in] num_of_fields   Number of logical fieldsn.
 * \param [in-out] field       Logical field array.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_int_ctrl(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_encap_config_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field)
{
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    int idx;
    uint64_t get_val;
    char lt_name[BCMINT_FLOW_LT_NAME_LEN_MAX];
    char field_name[BCMINT_FLOW_LF_NAME_LEN_MAX];

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    sal_memset(lt_name, 0, BCMINT_FLOW_LT_NAME_LEN_MAX);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flow_option_logical_table_name_get(unit, info->flow_handle,
                                                      info->flow_option,
                                                      lt_name));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                                     BCMLT_PRIORITY_NORMAL));
        for (idx = 0; idx < num_of_fields; idx++) {
            sal_memset(field_name, 0, BCMINT_FLOW_LF_NAME_LEN_MAX);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_flow_logical_field_name_get(unit, info->flow_handle,
                                                       field[idx].id,
                                                       field_name));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hd, field_name, &get_val));

            field[idx].value = (uint32_t)get_val;
        }
        if (num_of_fields) {
            info->valid_elements |= BCM_FLOW_ENCAP_FLEX_DATA_VALID;
        }
    } else if (opt == HW_OPT_SET) {
        if (info->valid_elements & BCM_FLOW_ENCAP_FLEX_DATA_VALID) {
            for (idx = 0; idx < num_of_fields; idx++) {
                sal_memset(field_name, 0, BCMINT_FLOW_LF_NAME_LEN_MAX);
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_flow_logical_field_name_get(unit,
                                                           info->flow_handle,
                                                           field[idx].id,
                                                           field_name));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hd, field_name,
                                           field[idx].value));
            }
        }
        if (info->options & BCM_FLOW_ENCAP_OPTION_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_UPDATE,
                                      BCMLT_PRIORITY_NORMAL));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_INSERT,
                                      BCMLT_PRIORITY_NORMAL));
        }
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hd) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse INT register for encap info.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     cb            User callback function.
 * \param [in]     user_data     User context data.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_encap_int_traverse(int unit,
                            bcm_flow_encap_traverse_cb cb,
                            void *user_data)
{
    int rv = SHR_E_NONE;
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t get_val;
    bcm_flow_encap_config_t info = {0};
    uint32 num_of_fields = 0;
    bcm_flow_logical_field_t field[3];
    char lt_name[64];
    char field_name[BCMINT_FLOW_LF_NAME_LEN_MAX];
    uint32 field_id = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    info.flow_handle = BCMINT_FLOW_ID_INT;
    info.flow_option = BCMINT_FLOW_OPT_ID_ASSIGN_DEVICE_ID_TEMPLATE_ID;
    sal_memset(lt_name, 0, 64);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flow_option_logical_table_name_get(unit, info.flow_handle,
                                                      info.flow_option,
                                                      lt_name));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    rv = bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }
    if (rv == SHR_E_NONE) {
        sal_memset(field, 0, 3*sizeof(bcm_flow_logical_field_t));
        num_of_fields = 0;

        sal_memset(field_name, 0, BCMINT_FLOW_LF_NAME_LEN_MAX);
        field_id = BCMINT_FLOW_LF_ID_INT_DEVICE_ID;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_flow_logical_field_name_get(unit, info.flow_handle,
                                                   field_id, field_name));

        rv = bcmlt_entry_field_get(entry_hd, field_name, &get_val);
        if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
            SHR_ERR_EXIT(rv);
        }
        if (rv == SHR_E_NONE) {
            field[num_of_fields].id = field_id;
            field[num_of_fields].value = (uint32_t)get_val;
            num_of_fields++;
        }

        if (num_of_fields) {
            info.valid_elements |= BCM_FLOW_ENCAP_FLEX_DATA_VALID;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (cb(unit, &info, num_of_fields, field, user_data));
    }

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Update ingress adaptation tables based on match criteria.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     opt           Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in-out] info          Flow match information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_ing_adapt_ctrl(int unit,
                              bcmint_flow_hw_opt_type_t opt,
                              bcm_flow_match_config_t *info)
{
    bcm_vlan_translate_key_t key_type;
    bcm_gport_t port;
    bcm_vlan_t outer_vlan;
    bcm_vlan_t inner_vlan;
    bcmi_ltsw_vlan_ing_xlate_cfg_t cfg;
    uint32_t vfi = 0;

    SHR_FUNC_ENTER(unit);

    if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN) {
        key_type = bcmVlanTranslateKeyPortGroupOuter;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }
    port = info->port;
    outer_vlan = info->vlan;
    inner_vlan = info->inner_vlan;

    sal_memset(&cfg, 0, sizeof(cfg));
    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_ltsw_vlan_ing_xlate_get(unit, key_type, port, outer_vlan,
                                             inner_vlan, &cfg));
        BCM_GPORT_FLOW_PORT_ID_SET(info->flow_port, cfg.svp);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, cfg.vfi, &(info->vpn)));

        info->intf_id = cfg.l3_iif;
    } else if (opt == HW_OPT_SET) {
        if (info->valid_elements & BCM_FLOW_MATCH_FLOW_PORT_VALID) {
            cfg.fld_bmp |= BCMI_LTSW_VLAN_ING_XLATE_FLD_SVP;
            cfg.svp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
        }
        if (info->valid_elements & BCM_FLOW_MATCH_VPN_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_vfi_idx_get(unit, info->vpn, &vfi));
            cfg.fld_bmp |= BCMI_LTSW_VLAN_ING_XLATE_FLD_VFI;
            cfg.vfi = vfi;
        }

        if (info->options & BCM_FLOW_MATCH_OPTION_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                   (bcmi_ltsw_vlan_ing_xlate_update(unit, key_type, port,
                                                    outer_vlan,
                                                    inner_vlan, &cfg));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                   (bcmi_ltsw_vlan_ing_xlate_add(unit, key_type, port,
                                                 outer_vlan, inner_vlan, &cfg));
        }
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_ltsw_vlan_ing_xlate_delete(unit, key_type, port,
                                                outer_vlan, inner_vlan));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:

    SHR_FUNC_EXIT();
}

/*!
 * \brief Helper function for flow match to traverse ingress adaptation tables.
 *
 * This function is used to parse info from ingress adaptation entries and
 * call flow match callback.
 *
 * \param [in] unit              Unit number.
 * \param [in] key_type          Key Type - bcmVlanTranslateKey*.
 * \param [in] port              Port ID.
 * \param [in] outer_vlan        Outer VLAN ID.
 * \param [in] inner_vlan        Inner VLAN ID.
 * \param [in] cfg               Ingress xlate configuration.
 * \param [in] user_data         User data to a call back.
 *
 * \retval SHR_E_NONE            No errors.
 * \retval !SHR_E_NONE           Failure.
 */
static int
xgs_flow_match_ing_adapt_traverse_cb(int unit, bcm_vlan_translate_key_t key_type,
                                     bcm_gport_t port,  bcm_vlan_t outer_vlan,
                                     bcm_vlan_t inner_vlan,
                                     bcmi_ltsw_vlan_ing_xlate_cfg_t *cfg,
                                     void *user_data)
{
    ing_adapt_user_data_t *ing_adapt_user_data = user_data;
    bcm_flow_match_config_t info;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    if (BCMINT_FLOW_VP_RESERVED != cfg->svp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vp_info_get(unit, cfg->svp, &vp_info));
        if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_FLOW)) {
            SHR_EXIT();
        }
    }

    bcm_flow_match_config_t_init(&info);
    if (key_type == bcmVlanTranslateKeyPortGroupOuter) {
        info.criteria = BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN;
        info.valid_elements = BCM_FLOW_MATCH_PORT_VALID |
                              BCM_FLOW_MATCH_VLAN_VALID;
    }

    info.vlan = outer_vlan;
    info.port = port;
    if (BCMINT_FLOW_VP_RESERVED != cfg->svp) {
        BCM_GPORT_FLOW_PORT_ID_SET(info.flow_port, cfg->svp);
    }
    if (BCMINT_FLOW_VFI_RESERVED != cfg->vfi) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, cfg->vfi, &(info.vpn)));
    }

    if (ing_adapt_user_data->cb) {
        rv = (ing_adapt_user_data->cb)(unit, &info, 0, NULL,
                                       ing_adapt_user_data->user_data);
        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_ERR_EXIT(rv);
        }
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all entries in ingress adaptation tables.
 *
 * This function is used to traverse all ingress adaptation entries and
 * call callback function.
 *
 * \param [in] unit              Unit number.
 * \param [in] cb                Callback function of flow match traverse.
 * \param [in] user_data         User data to a call back.
 *
 * \retval SHR_E_NONE            No errors.
 * \retval !SHR_E_NONE           Failure.
 */
static int
xgs_flow_match_ing_adapt_traverse(int unit,
                                  bcm_flow_match_traverse_cb cb,
                                  void *user_data)
{
    ing_adapt_user_data_t ing_adapt_user_data;

    SHR_FUNC_ENTER(unit);

    ing_adapt_user_data.cb = cb;
    ing_adapt_user_data.user_data = user_data;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_ing_xlate_traverse(unit,
                                           xgs_flow_match_ing_adapt_traverse_cb,
                                           &ing_adapt_user_data));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Determines whether match is configured on ing adapatation table.
 *
 * \param [in]  unit  Unit number.
 * \param [in]  info  Flow match information.
 *
 * \retval TRUE or FALSE.
 */
static int
xgs_flow_match_on_ing_adapt(int unit,
                            bcm_flow_match_config_t *info)
{
    if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*!
 * \brief Validate the parameters for match configuration.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Flow match information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_param_validation(int unit,
                                bcmint_flow_hw_opt_type_t opt,
                                bcm_flow_match_config_t *info)
{
    int vp = -1;
    uint32_t fld_width = 0;
    uint32_t vfi = 0;

    SHR_FUNC_ENTER(unit);

    /* Validate criteria. */
    switch(info->criteria) {
        case BCM_FLOW_MATCH_CRITERIA_PORT:
            break;
        case BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN:
            break;
        case BCM_FLOW_MATCH_CRITERIA_VN_ID:
            break;
        case BCM_FLOW_MATCH_CRITERIA_SIP:
            break;
        case BCM_FLOW_MATCH_CRITERIA_SIP_VNID:
            break;
        default:
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "invalid criteria:%d!\n"),
                                            info->criteria));
    }

    /* Validate flow option vs criteria. */
    if (info->flow_option == BCMINT_FLOW_OPT_ID_LOOKUP_VNID_ASSIGN_VFI) {
        if (info->criteria != BCM_FLOW_MATCH_CRITERIA_VN_ID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VNID must be criteria for \
                                            LOOKUP_VNID_ASSIGN_VFI!\n")));
        }
    }
    if (info->flow_option == BCMINT_FLOW_OPT_ID_LOOKUP_IPV6_SIP_ASSIGN_SVP) {
        if (info->criteria != BCM_FLOW_MATCH_CRITERIA_SIP) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "SIP must be criteria for \
                                            LOOKUP_IPV6_SIP_ASSIGN_SVP!\n")));
        }
    }

    /* Validate criteria vs valid elements. */
    if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT) {
        if (!(info->valid_elements & BCM_FLOW_MATCH_PORT_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "port not provided!\n")));
        }
        if (info->port == BCM_PORT_INVALID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid  port:%d!\n"),
                                            info->port));
        }
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN) {
        if (!(info->valid_elements & BCM_FLOW_MATCH_PORT_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit,
                                            "port group not provided!\n")));
        }
        if (!(info->valid_elements & BCM_FLOW_MATCH_VLAN_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit,
                                            "vlan not provided!\n")));
        }
    } else if (info->criteria == BCM_FLOW_MATCH_CRITERIA_VN_ID) {
        if (!(info->valid_elements & BCM_FLOW_MATCH_VNID_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VNID not provided!\n")));
        }
    } else if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SIP) {
        if (!(info->valid_elements &
            (BCM_FLOW_MATCH_SIP_VALID | BCM_FLOW_MATCH_SIP_V6_VALID))) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "SIP not provided!\n")));
        }
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SIP_VNID) {
        if (!(info->valid_elements & BCM_FLOW_MATCH_VNID_VALID)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VNID not provided!\n")));
        }
        if (!(info->valid_elements &
            (BCM_FLOW_MATCH_SIP_VALID | BCM_FLOW_MATCH_SIP_V6_VALID))) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "SIP not provided!\n")));
        }
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

    /* Validate elements */
    if ((info->valid_elements & BCM_FLOW_MATCH_FLOW_PORT_VALID) &&
        (opt != HW_OPT_GET)) {
        vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
        if (vp == BCMINT_FLOW_VP_RESERVED) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VP 0 reserved for \
                                            internal use!\n")));
        }
        if ((vp == -1) ||
            (bcmi_ltsw_virtual_vp_used_get(unit, vp, BCMI_LTSW_VP_TYPE_VPLAG) &&
             bcmi_ltsw_virtual_vp_used_get(unit, vp, BCMI_LTSW_VP_TYPE_FLOW))) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid flow port:%d!\n"),
                                            info->flow_port));
        }
    }
    if (info->valid_elements & BCM_FLOW_MATCH_VLAN_VALID) {
        if (!BCM_VLAN_VALID(info->vlan)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid vlan:%d!\n"),
                                            info->vlan));
        }
    }

    /* Actually port_group */
    if ((info->valid_elements & BCM_FLOW_MATCH_PORT_VALID) &&
         xgs_flow_match_on_ing_adapt(unit, info)) {
       SHR_IF_ERR_VERBOSE_EXIT
           (bcmi_lt_field_width_get(unit, PORT_SYSTEMs,
                                    VFI_ING_ADAPT_PORT_GRPs,
                                    &fld_width));
       if (info->port >= (1<<fld_width)) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Invalid port_group:%d!\n"),
                                            info->port));
        }
    }
    if ((info->valid_elements & BCM_FLOW_MATCH_VPN_VALID) &&
        (opt != HW_OPT_GET)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vfi_idx_get(unit, info->vpn, &vfi));
        if (vfi == BCMINT_FLOW_VFI_RESERVED) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "VFI 0 reserved for \
                                            internal use!\n")));
        }
    }
    if (info->valid_elements & BCM_FLOW_MATCH_IIF_VALID) {
        if (info->intf_id == BCMINT_FLOW_L3_IIF_RESERVED) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "Intf 0 reserved for \
                                            internal use!\n")));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Configuration on port/trunk based on match.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Flow match information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_port_ctrl(int unit,
                         bcmint_flow_hw_opt_type_t opt,
                         bcm_flow_match_config_t *info)
{
    int vp = 0;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    int dunit = 0;
    uint64_t get_val;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int old_vp = 0;
    bcm_port_t port = 0;

    SHR_FUNC_ENTER(unit);

    if (info->valid_elements & BCM_FLOW_MATCH_FLOW_PORT_VALID) {
        vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
        bcmi_ltsw_virtual_vp_info_init(&vp_info);
        if (bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info)) {
            SHR_ERR_EXIT(SHR_E_PORT);
        }
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, info->port, &port));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SYSTEMs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PORT_SYSTEM_IDs, port));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, PORT_SVP_IDs,
                               &get_val));
    old_vp = (int)get_val;
    if (opt == HW_OPT_GET) {
        if (old_vp != BCMINT_FLOW_VP_RESERVED) {
            BCM_GPORT_FLOW_PORT_ID_SET(info->flow_port, old_vp);
            info->valid_elements |= BCM_FLOW_MATCH_FLOW_PORT_VALID;
        }
    } else if (opt == HW_OPT_SET) {
        if (!(info->options & BCM_FLOW_MATCH_OPTION_REPLACE)) {
            if (old_vp != BCMINT_FLOW_VP_RESERVED) {
                SHR_ERR_EXIT(SHR_E_EXISTS);
            }
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hdl, PORT_SVP_IDs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PORT_SVP_IDs, vp));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_remove(entry_hdl, PORT_SVP_IDs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PORT_SVP_IDs,
                                   BCMINT_FLOW_VP_RESERVED));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Determine logical table based on match info.
 *
 * \param [in]  unit    Unit number.
 * \param [in]  info    Flow match information.
 * \param [out] lt_name Logical table name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_lt_determine(int unit,
                            bcm_flow_match_config_t *info,
                            const char **lt_name)
{
    SHR_FUNC_ENTER(unit);

    if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT) {
        *lt_name = PORT_SYSTEMs;
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN) {
        *lt_name = VFI_ING_ADAPT_OVID_PORT_GRPs;
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_VN_ID) {
        *lt_name = TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNIDs;
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SIP) {
        if (info->valid_elements & BCM_FLOW_MATCH_SIP_VALID) {
            *lt_name = TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4s;
        } else {
            *lt_name = TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6s;
        }
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SIP_VNID) {
        if (info->valid_elements & BCM_FLOW_MATCH_SIP_VALID) {
            *lt_name = TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4s;
        } else {
            *lt_name = TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6s;
        }

    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Determine match criteria based on logical table.
 *
 * \param [in]  unit    Unit number.
 * \param [in]  lt_name Logical table name.
 * \param [out] info    Flow match information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_criteria_determine(int unit,
                                  const char *lt_name,
                                  bcm_flow_match_config_t *info)
{
    SHR_FUNC_ENTER(unit);

    if (lt_name == VFI_ING_ADAPT_OVID_PORT_GRPs) {
        info->criteria = BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN;
        info->valid_elements = BCM_FLOW_MATCH_PORT_VALID |
                               BCM_FLOW_MATCH_VLAN_VALID;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNIDs) {
        /* Determined as BCM_FLOW_MATCH_CRITERIA_VN_ID based on SVP value */
        info->criteria = BCM_FLOW_MATCH_CRITERIA_VN_ID;
        info->valid_elements = BCM_FLOW_MATCH_VNID_VALID |
                               BCM_FLOW_MATCH_VLAN_VALID;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4s) {
        /* Determined as BCM_FLOW_MATCH_CRITERIA_VN_ID based on SVP value */
        info->criteria = BCM_FLOW_MATCH_CRITERIA_SIP_VNID;
        info->valid_elements = BCM_FLOW_MATCH_VNID_VALID |
                               BCM_FLOW_MATCH_VLAN_VALID |
                               BCM_FLOW_MATCH_SIP_VALID;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6s) {
        /* Determined as BCM_FLOW_MATCH_CRITERIA_VN_ID based on SVP value */
        info->criteria = BCM_FLOW_MATCH_CRITERIA_VN_ID;
        info->valid_elements = BCM_FLOW_MATCH_VNID_VALID |
                               BCM_FLOW_MATCH_VLAN_VALID |
                               BCM_FLOW_MATCH_SIP_V6_VALID;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4s) {
        info->criteria = BCM_FLOW_MATCH_CRITERIA_SIP;
        info->valid_elements = BCM_FLOW_MATCH_SIP_VALID |
                               BCM_FLOW_MATCH_VLAN_VALID;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6s) {
        info->criteria = BCM_FLOW_MATCH_CRITERIA_SIP;
        info->valid_elements = BCM_FLOW_MATCH_SIP_V6_VALID |
                               BCM_FLOW_MATCH_VLAN_VALID;
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad lt:%s!\n"), lt_name));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set key based on match criteria.
 *
 * \param [in]  unit     Unit number.
 * \param [in]  info     Flow match information.
 * \param [in]  entry_hd Logical table entry handle..
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_key_set(int unit,
                       bcm_flow_match_config_t *info,
                       bcmlt_entry_handle_t entry_hd)
{
    uint64_t get_ipv6_val[2] = {0};

    SHR_FUNC_ENTER(unit);

    if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT_GROUP_VLAN) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, PORT_GRPs,
                                   info->port));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, OVIDs, info->vlan));
    } else if (info->criteria == BCM_FLOW_MATCH_CRITERIA_VN_ID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, OVIDs, info->vlan));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VNIDs, info->vnid));
    } else  if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SIP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, OVIDs, info->vlan));
        if (info->valid_elements & BCM_FLOW_MATCH_SIP_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV4s, info->sip));
        } else {
            bcmi_ltsw_util_ip6_to_uint64(get_ipv6_val, &(info->sip6));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV6_LOWERs,
                                       get_ipv6_val[0]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV6_UPPERs,
                                       get_ipv6_val[1]));
        }
    } else if (info->criteria == BCM_FLOW_MATCH_CRITERIA_SIP_VNID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, OVIDs, info->vlan));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VNIDs, info->vnid));
        if (info->valid_elements & BCM_FLOW_MATCH_SIP_VALID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV4s, info->sip));
        } else {
            bcmi_ltsw_util_ip6_to_uint64(get_ipv6_val, &(info->sip6));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV6_LOWERs,
                                       get_ipv6_val[0]));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hd, OUTER_SRC_IPV6_UPPERs,
                                       get_ipv6_val[1]));
        }

    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Bad criteria validation!\n")));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get key info based on match criteria.
 *
 * \param [in]       unit     Unit number.
 * \param [in-out]   info     Flow match information.
 * \param [in]       entry_hd Logical table entry handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_key_get(int unit,
                        bcm_flow_match_config_t *info,
                        const bcmlt_entry_handle_t entry_hd)
{
    uint64_t get_val;
    uint64_t get_ipv6_val[2] = {0};

    SHR_FUNC_ENTER(unit);

    if (info->valid_elements & BCM_FLOW_MATCH_VLAN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OVIDs, &get_val));
        info->vlan = (uint32_t)get_val;
    }

    if (info->valid_elements & BCM_FLOW_MATCH_VNID_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, VNIDs, &get_val));
        info->vnid = (uint32_t)get_val;
    }
    if (info->valid_elements & BCM_FLOW_MATCH_SIP_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_SRC_IPV4s, &get_val));
        info->sip = get_val;
    }
    if (info->valid_elements & BCM_FLOW_MATCH_SIP_V6_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_SRC_IPV6_LOWERs,
                                   &get_ipv6_val[0]));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, OUTER_SRC_IPV6_UPPERs,
                                   &get_ipv6_val[1]));
        bcmi_ltsw_util_uint64_to_ip6(&(info->sip6), get_ipv6_val);
    }
    if (info->valid_elements & BCM_FLOW_MATCH_PORT_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, PORT_GRPs,
                                   &get_val));
        info->port = (uint32_t)get_val;
    }

 exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set valid element based on logical table.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   lt_name       Logical table name.
 * \param [out]  valid_element Element valid status.
 */
static void
xgs_flow_match_data_valid_indicator(int unit,
                                    const char *lt_name,
                                    uint32_t *valid_element,
                                    uint32_t *valid_flags)
{
    *valid_element = 0;
    *valid_flags = 0;
    if (lt_name == VFI_ING_ADAPT_OVID_PORT_GRPs) {
        *valid_element = BCM_FLOW_MATCH_VPN_VALID |
                         BCM_FLOW_MATCH_FLOW_PORT_VALID;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNIDs) {
        *valid_element = BCM_FLOW_MATCH_VPN_VALID;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4s) {
        *valid_element = BCM_FLOW_MATCH_VPN_VALID;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6s) {
        *valid_element = BCM_FLOW_MATCH_VPN_VALID;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4s) {
        *valid_element = BCM_FLOW_MATCH_FLOW_PORT_VALID;
    } else if (lt_name == TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6s) {
        *valid_element = BCM_FLOW_MATCH_FLOW_PORT_VALID;
    } else {
       /* Do nothing */
    }
}

/*!
 * \brief Set data portion based on match info.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   info          Flow match information.
 * \param [in]   entry_hd      Logical table entry handle.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_data_set(int unit,
                        bcm_flow_match_config_t *info,
                        bcmlt_entry_handle_t entry_hd)
{
    int vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);
    uint32_t vfi = 0;

    SHR_FUNC_ENTER(unit);

    if (info->valid_elements & BCM_FLOW_MATCH_FLOW_PORT_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, PORT_SVP_IDs, vp));
    }

    if (info->valid_elements & BCM_FLOW_MATCH_VPN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vfi_idx_get(unit, info->vpn, &vfi));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, VFI_IDs, vfi));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get data portion based on match info.
 *
 * \param [in]   unit          Unit number.
 * \param [in]   info          Flow match information.
 * \param [in]   lt_name       Logical table name.
 * \param [in]   entry_hd      Logical table entry handle.
 * \param [out]  valid         Indicate whether valid data found.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_data_get(int unit,
                        bcm_flow_match_config_t *info,
                        const char *lt_name,
                        const bcmlt_entry_handle_t entry_hd,
                        uint8_t *valid)
{
    uint64_t get_val;
    uint32_t valid_element = 0;
    uint32_t valid_flags = 0;

    SHR_FUNC_ENTER(unit);

    xgs_flow_match_data_valid_indicator(unit, lt_name, &valid_element,
                                        &valid_flags);
    *valid = 0;
    if (valid_element & BCM_FLOW_MATCH_FLOW_PORT_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, PORT_SVP_IDs, &get_val));
        BCM_GPORT_FLOW_PORT_ID_SET(info->flow_port, (int)get_val);

        *valid = 1;
    }

    if (valid_element & BCM_FLOW_MATCH_VPN_VALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, VFI_IDs, &get_val));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, get_val, &(info->vpn)));

        *valid = 1;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Configuration on hash table based on match.
 *
 * \param [in] unit   Unit number.
 * \param [in] opt    Opt type from ltsw_flow_hw_opt_type_t.
 * \param [in] info   Flow match information.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_general_ctrl(int unit,
                            bcmint_flow_hw_opt_type_t opt,
                            bcm_flow_match_config_t *info)
{
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;
    int rv = SHR_E_NONE;
    uint8_t valid = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_lt_determine(unit, info, &lt_name));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_key_set(unit, info, entry_hd));
    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                                     BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_match_data_get(unit, info, lt_name, entry_hd, &valid));
    } else if (opt == HW_OPT_SET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_match_data_set(unit, info, entry_hd));
        if (info->options & BCM_FLOW_MATCH_OPTION_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_UPDATE,
                                      BCMLT_PRIORITY_NORMAL));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_INSERT,
                                      BCMLT_PRIORITY_NORMAL));
        }
    } else if (opt == HW_OPT_CLR) {
        rv = bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL);
        if ((rv == SHR_E_NOT_FOUND) &&
             xgs_flow_match_on_ing_adapt(unit,info)) {
            SHR_EXIT();
        } else {
            if (SHR_SUCCESS(rv)) {
                SHR_EXIT();
            } else {
                SHR_ERR_EXIT(rv);
            }
        }
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hd) {
        (void) bcmlt_entry_free(entry_hd);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse HW table based with port/trunk as criteria.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     cb            User callback function.
 * \param [in]     user_data     User context data.
 * \param [in]     lt_name       Logical table name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_port_table_traverse(int unit,
                                    bcm_flow_match_traverse_cb cb,
                                    void *user_data,
                                    const char *lt_name)
{
    int rv = SHR_E_NONE;
    int dunit = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t get_val;
    bcm_flow_match_config_t info = {0};
    int vp = -1;
    int rv1 = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hdl));

    while ((rv = bcmi_lt_entry_commit(dunit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, PORT_SVP_IDs, &get_val));
        vp = (int)get_val;
        if (vp) {
            bcm_flow_match_config_t_init(&info);

            info.criteria = BCM_FLOW_MATCH_CRITERIA_PORT;
            BCM_GPORT_FLOW_PORT_ID_SET(info.flow_port, vp);
            info.valid_elements = BCM_FLOW_MATCH_FLOW_PORT_VALID;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, PORT_SYSTEM_IDs, &get_val));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_port_gport_get(unit, get_val, &(info.port)));
            if (cb) {
                rv1 = (*cb) (unit, &info, 0, NULL, user_data);
                if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                    SHR_ERR_EXIT(rv1);
                }
            }
        }
    }
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse HW table based with hash key as criteria.
 *
 * \param [in]     unit          Unit Number.
 * \param [in]     cb            User callback function.
 * \param [in]     user_data     User context data.
 * \param [in]     lt_name       Logical table name.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_flow_match_hash_table_traverse(int unit,
                                   bcm_flow_match_traverse_cb cb,
                                   void *user_data,
                                   const char *lt_name)
{
    int rv = SHR_E_NONE;
    bcm_flow_match_config_t info = {0};
    int dunit = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint8_t valid = 0;
    int rv1 = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hdl));

    while ((rv = bcmi_lt_entry_commit(dunit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        bcm_flow_match_config_t_init(&info);

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_match_criteria_determine(unit, lt_name, &info));

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_match_key_get(unit, &info, entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_match_data_get(unit, &info, lt_name, entry_hdl, &valid));

        if (valid == 0) {
            continue;
        }

        if (cb) {
            rv1 = (*cb) (unit, &info, 0, NULL, user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }
    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}


static int
xgs_ltsw_flow_switch_udp_src_get(int unit, int *arg)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char* symbol = NULL;
    int rv;
    const char *tbl_desc;

    SHR_FUNC_ENTER(unit);

    rv = bcmlt_table_desc_get(unit, TNL_L2_VXLAN_CONTROLs, &tbl_desc);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    } else {
        /* do nothing. */
    }

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_L2_VXLAN_CONTROLs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, SRC_L4_PORT_SELECTs,
                                      &symbol));
    if (!sal_strcmp(symbol, SRC_L4_PORTs)) {
        *arg = bcmSwitchTunnelUdpSrcPortStatic;
    } else if (!sal_strcmp(symbol, HASH_ENTROPYs)){
        *arg = bcmSwitchTunnelUdpSrcPortHashEntropy;
    } else if (!sal_strcmp(symbol, HASH_ENTROPY_PRIVATEs)){
        *arg = bcmSwitchTunnelUdpSrcPortHashEntropyPrivate;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_ltsw_flow_switch_udp_src_set(int unit, int arg)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv;
    const char *tbl_desc;

    SHR_FUNC_ENTER(unit);

    rv = bcmlt_table_desc_get(unit, TNL_L2_VXLAN_CONTROLs, &tbl_desc);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    } else {
        /* do nothing. */
    }

    if ((arg < bcmSwitchTunnelUdpSrcPortStatic) ||
        (arg >= bcmSwitchTunnelUdpSrcPortCount) ) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Invalid  mode:%d!\n"), arg));
    }

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_L2_VXLAN_CONTROLs, &entry_hdl));
    if (arg == bcmSwitchTunnelUdpSrcPortHashEntropyPrivate) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, SRC_L4_PORT_SELECTs,
                                          HASH_ENTROPY_PRIVATEs));
    } else if (arg == bcmSwitchTunnelUdpSrcPortHashEntropy) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, SRC_L4_PORT_SELECTs,
                                          HASH_ENTROPYs));
    } else {
        /* Should be bcmSwitchTunnelUdpSrcPortStatic. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, SRC_L4_PORT_SELECTs,
                                          SRC_L4_PORTs));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_ltsw_flow_switch_control_general_fld_determine(
   int unit,
   bcm_switch_control_t type,
   const char **field_name)
{
    SHR_FUNC_ENTER(unit);

    if (type == bcmSwitchVxlanUdpDestPortSet) {
        *field_name = DECAP_DST_L4_PORTs;
    } else if (type == bcmSwitchVxlanTunnelMissToCpu) {
        *field_name = VXLAN_SVP_ASSIGN_FAIL_COPY_TO_CPUs;
    } else if (type == bcmSwitchVxlanVnIdMissToCpu) {
        *field_name = VXLAN_VFI_ASSIGN_FAIL_COPY_TO_CPUs;
    } else if (type == bcmSwitchVxlanHeaderFlags) {
        *field_name = FLAGSs;
    } else if (type == bcmSwitchVxlanHeaderReserved1) {
        *field_name = RESERVED_1s;
    } else if (type == bcmSwitchVxlanHeaderReserved2) {
        *field_name = RESERVED_2s;
    } else if (type == bcmSwitchVxlanHeaderMatchFlags) {
        *field_name = DECAP_FLAGSs;
    } else if (type == bcmSwitchVxlanHeaderFlagsMask) {
        *field_name = DECAP_FLAGS_MASKs;
    } else if (type == bcmSwitchVxlanHeaderFlagsMismatchDrop) {
        *field_name = DECAP_FLAGS_MISMATCH_DROPs;
    } else {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
xgs_ltsw_flow_switch_control_general_get(
    int unit,
    bcm_switch_control_t type,
    int *arg)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv;
    const char *tbl_desc;
    const char *field_name;
    uint64_t get_val;

    SHR_FUNC_ENTER(unit);

    rv = bcmlt_table_desc_get(unit, TNL_L2_VXLAN_CONTROLs, &tbl_desc);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    } else {
        /* do nothing. */
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_flow_switch_control_general_fld_determine(unit, type,
                                                            &field_name));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_L2_VXLAN_CONTROLs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, field_name, &get_val));
    *arg = (int)get_val;

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_ltsw_flow_switch_control_general_set(
    int unit,
    bcm_switch_control_t type,
    int arg)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv;
    const char *tbl_desc;
    const char *field_name;

    SHR_FUNC_ENTER(unit);

    rv = bcmlt_table_desc_get(unit, TNL_L2_VXLAN_CONTROLs, &tbl_desc);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    } else {
        /* do nothing. */
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_flow_switch_control_general_fld_determine(unit, type,
                                                            &field_name));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_L2_VXLAN_CONTROLs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, field_name, arg));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_flow_es_filter_check(int unit)
{
    int rv;
    const char *tbl_desc;

    SHR_FUNC_ENTER(unit);

    rv = bcmlt_table_desc_get(unit, PORT_SVP_ES_FILTERINGs, &tbl_desc);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    } else {
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

static int
xgs_flow_es_filter_stat_update(int unit, bcm_gport_t flow_port_id,
                               bcmi_ltsw_flexctr_counter_info_t *info,
                               uint8_t flag)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    int vp;

    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_virtual_vfi_type_vp_get(unit, flow_port_id, &vp));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SVP_ES_FILTERINGs, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, PORT_SVP_IDs, vp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, CTR_EGR_EFLEX_ACTIONs, &flex_ctr_action));

    if (flag) {
        /* Flex counter action must not attached. */
        if (flex_ctr_action != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_BUSY,
                                (BSL_META_U(unit, "%d already attached!\n"),
                                            (int)flex_ctr_action));
        }
    } else {
        /* Flex counter action must already attached. */
        if (flex_ctr_action != (uint64_t)info->action_index) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "%d not expected (%d)!\n"),
                                            (int)flex_ctr_action,
                                            (int)info->action_index));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_clear(entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, PORT_SVP_IDs, vp));
    if (flag) {
        flex_ctr_action = (uint64_t)info->action_index;
    } else {
        flex_ctr_action = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, CTR_EGR_EFLEX_ACTIONs, flex_ctr_action));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_flow_vpn_stat_update(int unit, bcm_vpn_t vpn,
                         bcmi_ltsw_flexctr_counter_info_t *info,
                         uint8_t flag)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    uint32_t vfi_index = 0;
    const char *action_name = CTR_ING_EFLEX_ACTIONs;

    SHR_FUNC_ENTER(unit);

    if (info->source == bcmFlexctrSourceEgrVpn) {
        action_name = CTR_EGR_EFLEX_ACTIONs;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_idx_get(unit, vpn, &vfi_index));
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, VFIs, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, VFI_IDs, vfi_index));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, action_name, &flex_ctr_action));

    if (flag) {
        /* Flex counter action must not attached. */
        if (flex_ctr_action != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_BUSY,
                                (BSL_META_U(unit, "%d already attached!\n"),
                                            (int)flex_ctr_action));
        }
    } else {
        /* Flex counter action must already attached. */
        if (flex_ctr_action != (uint64_t)info->action_index) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "%d not expected (%d)!\n"),
                                            (int)flex_ctr_action,
                                            (int)info->action_index));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_clear(entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, VFI_IDs, vfi_index));
    if (flag) {
        flex_ctr_action = (uint64_t)info->action_index;
    } else {
        flex_ctr_action = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, action_name, flex_ctr_action));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_flow_vp_stat_update(int unit, bcm_gport_t flow_port_id,
                        bcmi_ltsw_flexctr_counter_info_t *info,
                        uint8_t flag)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    int vp = 0;

    SHR_FUNC_ENTER(unit);

    vp = BCM_GPORT_FLOW_PORT_ID_GET(flow_port_id);
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_DVPs, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, PORT_DVP_IDs, vp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, CTR_EGR_EFLEX_ACTIONs, &flex_ctr_action));

    if (flag) {
        /* Flex counter action must not attached. */
        if (flex_ctr_action != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_BUSY,
                                (BSL_META_U(unit, "%d already attached!\n"),
                                            (int)flex_ctr_action));
        }
    } else {
        /* Flex counter action must already attached. */
        if (flex_ctr_action != (uint64_t)info->action_index) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "%d not expected (%d)!\n"),
                                            (int)flex_ctr_action,
                                            (int)info->action_index));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_clear(entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, PORT_DVP_IDs, vp));
    if (flag) {
        flex_ctr_action = (uint64_t)info->action_index;
    } else {
        flex_ctr_action = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, CTR_EGR_EFLEX_ACTIONs, flex_ctr_action));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_flow_tunnel_initiator_stat_update(int unit, bcm_gport_t tunnel_id,
                                      bcmi_ltsw_flexctr_counter_info_t *info,
                                      uint8_t flag)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    uint32_t tnl_idx = 0;
    uint32_t soft_tnl_idx = 0;
    bcmi_ltsw_tunnel_type_t tnl_type;
    int encap_idx = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    BCMI_LTSW_GPORT_TUNNEL_ID_GET(tunnel_id, tnl_type, soft_tnl_idx);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_intf_tnl_init_get(unit, soft_tnl_idx,
                                        &tnl_type,  &encap_idx));
    if (tnl_type == bcmiTunnelTypeIp6L3) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV6_ENCAPs, &entry_hd));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, TNL_IPV6_ENCAP_IDs, tnl_idx));
    } else if (tnl_type == bcmiTunnelTypeIpL3) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV4_ENCAPs, &entry_hd));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, TNL_IPV4_ENCAP_IDs, tnl_idx));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Invalid tunnel type:%d!\n"),
                                        tnl_type));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, CTR_EGR_EFLEX_ACTIONs, &flex_ctr_action));

    if (flag) {
        /* Flex counter action must not attached. */
        if (flex_ctr_action != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_BUSY,
                                (BSL_META_U(unit, "%d already attached!\n"),
                                            (int)flex_ctr_action));
        }
    } else {
        /* Flex counter action must already attached. */
        if (flex_ctr_action != (uint64_t)info->action_index) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "%d not expected (%d)!\n"),
                                            (int)flex_ctr_action,
                                            (int)info->action_index));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_clear(entry_hd));
    if (tnl_type == bcmiTunnelTypeIp6L3) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, TNL_IPV6_ENCAP_IDs, tnl_idx));
    } else if (tnl_type == bcmiTunnelTypeIpL3) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, TNL_IPV4_ENCAP_IDs, tnl_idx));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Invalid tunnel type:%d!\n"),
                                        tnl_type));
    }
    if (flag) {
        flex_ctr_action = (uint64_t)info->action_index;
    } else {
        flex_ctr_action = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, CTR_EGR_EFLEX_ACTIONs, flex_ctr_action));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_flow_encap_stat_update(int unit, bcm_flow_encap_config_t *encap_info,
                           bcmi_ltsw_flexctr_counter_info_t *info,
                           uint8_t flag)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    const char *action_name = CTR_EGR_EFLEX_ACTIONs;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_lt_determine(dunit, encap_info, &lt_name));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_key_set(unit, encap_info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, action_name, &flex_ctr_action));

    if (flag) {
        /* Flex counter action must not attached. */
        if (flex_ctr_action != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_BUSY,
                                (BSL_META_U(unit, "%d already attached!\n"),
                                            (int)flex_ctr_action));
        }
    } else {
        /* Flex counter action must already attached. */
        if (flex_ctr_action != (uint64_t)info->action_index) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "%d not expected (%d)!\n"),
                                            (int)flex_ctr_action,
                                            (int)info->action_index));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_clear(entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_key_set(unit, encap_info, entry_hd));
    if (flag) {
        flex_ctr_action = (uint64_t)info->action_index;
    } else {
        flex_ctr_action = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, action_name, flex_ctr_action));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_flow_match_stat_update(int unit, bcm_flow_match_config_t *match_info,
                           bcmi_ltsw_flexctr_counter_info_t *info,
                           uint8_t flag)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    const char *action_name = CTR_ING_EFLEX_ACTIONs;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_lt_determine(dunit, match_info, &lt_name));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_key_set(unit, match_info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, action_name, &flex_ctr_action));

    if (flag) {
        /* Flex counter action must not attached. */
        if (flex_ctr_action != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_BUSY,
                                (BSL_META_U(unit, "%d already attached!\n"),
                                            (int)flex_ctr_action));
        }
    } else {
        /* Flex counter action must already attached. */
        if (flex_ctr_action != (uint64_t)info->action_index) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "%d not expected (%d)!\n"),
                                            (int)flex_ctr_action,
                                            (int)info->action_index));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_clear(entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_key_set(unit, match_info, entry_hd));
    if (flag) {
        flex_ctr_action = (uint64_t)info->action_index;
    } else {
        flex_ctr_action = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, action_name, flex_ctr_action));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_flow_tunnel_terminator_stat_update(int unit,
                                       bcm_flow_tunnel_terminator_t *term_info,
                                       bcmi_ltsw_flexctr_counter_info_t *info,
                                       uint8_t flag)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    const char *action_name = CTR_ING_EFLEX_ACTIONs;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    xgs_flow_tunnel_term_lt_determine(dunit, term_info, &lt_name);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_term_key_set(unit, term_info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, action_name, &flex_ctr_action));

    if (flag) {
        /* Flex counter action must not attached. */
        if (flex_ctr_action != BCMI_LTSW_FLEXCTR_ACTION_INVALID) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_BUSY,
                                (BSL_META_U(unit, "%d already attached!\n"),
                                            (int)flex_ctr_action));
        }
    } else {
        /* Flex counter action must already attached. */
        if (flex_ctr_action != (uint64_t)info->action_index) {
            SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                                (BSL_META_U(unit, "%d not expected (%d)!\n"),
                                            (int)flex_ctr_action,
                                            (int)info->action_index));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_clear(entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_term_key_set(unit, term_info, entry_hd));
    if (flag) {
        flex_ctr_action = (uint64_t)info->action_index;
    } else {
        flex_ctr_action = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, action_name, flex_ctr_action));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_flow_init(int unit)
{
    int warm = bcmi_warmboot_get(unit);
    uint64_t min, max;
    bcmi_ltsw_idx_tbl_user_info_t user_info;
    bcmi_ltsw_idx_tbl_lt_info_t lt_info;

    SHR_FUNC_ENTER(unit);

    /* warmboot is handled within the interface. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_port_encap_mtu_profile_init(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV4_ENCAPs,
                                       TNL_IPV4_ENCAP_IDs, &min, &max));
    sal_memset(&lt_info, 0, sizeof(lt_info));
    /* Max number of users of this LT. */
    lt_info.user_cnt  = BCMI_EGR_L3_TNL_USER_ID_CNT;
    lt_info.tbl_name  = TNL_IPV4_ENCAPs;
    lt_info.idx_field = TNL_IPV4_ENCAP_IDs;
    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = (uint32_t)min;
    user_info.idx_max     = (uint32_t)max;
    user_info.func_hash   = xgs_flow_tunnel_initiator_hash_calc;
    user_info.func_cmp    = xgs_flow_tunnel_initiator_cmp;
    user_info.func_insert = xgs_flow_tunnel_initiator_insert;
    user_info.func_del    = xgs_flow_tunnel_initiator_delete;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                    BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                                    &lt_info, &user_info));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV6_ENCAPs,
                                       TNL_IPV6_ENCAP_IDs, &min, &max));
    sal_memset(&lt_info, 0, sizeof(lt_info));
    /* Max number of users of this LT. */
    lt_info.user_cnt  = BCMI_EGR_L3_IP6_TNL_USER_ID_CNT;
    lt_info.tbl_name  = TNL_IPV6_ENCAPs;
    lt_info.idx_field = TNL_IPV6_ENCAP_IDs;
    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = (uint32_t)min;
    user_info.idx_max     = (uint32_t)max;
    user_info.func_hash   = xgs_flow_tunnel_initiator_hash_calc;
    user_info.func_cmp    = xgs_flow_tunnel_initiator_cmp;
    user_info.func_insert = xgs_flow_tunnel_initiator_insert;
    user_info.func_del    = xgs_flow_tunnel_initiator_delete;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                                    BCMI_EGR_L3_IP6_TNL_USER_ID_FLEX_FLOW,
                                    &lt_info, &user_info));

    if (warm) {
        /* Recover tunnel initiator s/w status. */
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_initiator_recover(unit));
    }

exit:
    if (SHR_FUNC_ERR()) {
        SHR_IF_ERR_CONT
            (xgs_ltsw_flow_detach(unit));
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (bcmi_warmboot_get(unit)) {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_initiator_delete_all(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_term_destroy_all(unit));

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_idx_tbl_unregister(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                      BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW),
                                      SHR_E_NOT_FOUND);
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_idx_tbl_unregister(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                                      BCMI_EGR_L3_IP6_TNL_USER_ID_FLEX_FLOW),
                                      SHR_E_NOT_FOUND);
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit,
                                      BCMI_LTSW_PROFILE_FLOW_DVP_MTU_PROFILE),
                                      SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_vpn_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_vpn_t vpn,
    bcm_flow_vpn_config_t *info)
{
    int dunit = 0;
    uint32_t vfi_index = 0;
    uint32_t dest_val = 0;
    uint32_t group_type = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint32_t valid_fields;
    bcm_vlan_control_vlan_t vlan_control;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_idx_get(unit, vpn, &vfi_index));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, VFIs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, VFI_IDs, vfi_index));

    if (opt == HW_OPT_SET) {
        group_type = _BCM_MULTICAST_TYPE_GET(info->broadcast_group);
        if (group_type == _BCM_MULTICAST_TYPE_FLOW) {
            dest_val = _BCM_MULTICAST_ID_GET(info->broadcast_group);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, L3_BC_GRP_IDs, dest_val));
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        group_type = _BCM_MULTICAST_TYPE_GET(info->unknown_multicast_group);
        if (group_type == _BCM_MULTICAST_TYPE_FLOW) {
            dest_val = _BCM_MULTICAST_ID_GET(info->unknown_multicast_group);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, L3_UNKOWN_MC_GRP_IDs,
                                       dest_val));
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        group_type = _BCM_MULTICAST_TYPE_GET(info->unknown_unicast_group);
        if (group_type == _BCM_MULTICAST_TYPE_FLOW) {
            dest_val = _BCM_MULTICAST_ID_GET(info->unknown_unicast_group);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, L3_UNKOWN_UC_GRP_IDs,
                                       dest_val));

        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        /* Protocol packet handling. */
        valid_fields = BCM_VLAN_CONTROL_VLAN_PROTOCOL_PKT_MASK;
        bcm_vlan_control_vlan_t_init(&vlan_control);
        sal_memcpy(&(vlan_control.protocol_pkt), &(info->protocol_pkt),
                   sizeof(bcm_vlan_protocol_packet_ctrl_t));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_vlan_control_vlan_selective_set(unit, vpn,
                                                      valid_fields,
                                                      &vlan_control));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    } else if (opt == HW_OPT_GET) {
        uint64_t f_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L3_BC_GRP_IDs, &f_val));
        dest_val = (uint32_t)f_val;
        _BCM_MULTICAST_GROUP_SET(info->broadcast_group,
                                 _BCM_MULTICAST_TYPE_FLOW, dest_val);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L3_UNKOWN_MC_GRP_IDs, &f_val));
        dest_val = (uint32_t)f_val;
        _BCM_MULTICAST_GROUP_SET(info->unknown_multicast_group,
                                 _BCM_MULTICAST_TYPE_FLOW, dest_val);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L3_UNKOWN_UC_GRP_IDs, &f_val));
        dest_val = (uint32_t)f_val;
        _BCM_MULTICAST_GROUP_SET(info->unknown_unicast_group,
                                 _BCM_MULTICAST_TYPE_FLOW, dest_val);

        /* Protocol packet handling. */
        valid_fields = BCM_VLAN_CONTROL_VLAN_PROTOCOL_PKT_MASK;
        bcm_vlan_control_vlan_t_init(&vlan_control);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_vlan_control_vlan_selective_get(unit, vpn,
                                                      valid_fields,
                                                      &vlan_control));
        sal_memcpy(&(info->protocol_pkt), &(vlan_control.protocol_pkt),
                   sizeof(bcm_vlan_protocol_packet_ctrl_t));
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_vp_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_port_t *flow_port)
{
    int dunit = 0;
    int vp = -1;
    uint64_t get_val;
    bcmlt_entry_handle_t hd_ing_svp = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t hd_egr_dvp = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t hd_def_svp = BCMLT_INVALID_HDL;
    int local_rv = SHR_E_NOT_FOUND;

    bcmi_ltsw_qos_map_type_t qos_type;
    int qos_base_ptr;

    SHR_FUNC_ENTER(unit);

    vp = BCM_GPORT_FLOW_PORT_ID_GET(flow_port->flow_port_id);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SVPs, &hd_ing_svp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(hd_ing_svp, PORT_SVP_IDs, vp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_DVPs, &hd_egr_dvp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(hd_egr_dvp, PORT_DVP_IDs, vp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_L2_VXLAN_CONTROLs, &hd_def_svp));

    if (opt == HW_OPT_SET) {
        bcmlt_opcode_t opcode = (flow_port->flags & BCM_FLOW_PORT_REPLACE)?
                                 BCMLT_OPCODE_UPDATE:BCMLT_OPCODE_INSERT;
        if (flow_port->flags & BCM_FLOW_PORT_SERVICE_TAGGED) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        /* flow_port->ingress_opaque_ctrl_id, sliently ignored. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(hd_ing_svp, SVP_NETWORK_GRPs,
                                   flow_port->network_group_id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(hd_ing_svp, CLASS_IDs,
                                   flow_port->if_class));

        if (flow_port->dscp_map_id != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_resolve(unit, flow_port->dscp_map_id,
                                              &qos_type, &qos_base_ptr));
            if (qos_type != bcmiQosMapTypeL3Ingress) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        } else {
            qos_base_ptr = 0;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(hd_ing_svp,
                                   PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs,
                                   qos_base_ptr));

        if (flow_port->vlan_pri_map_id != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_resolve(unit, flow_port->vlan_pri_map_id,
                                              &qos_type, &qos_base_ptr));
            if (qos_type != bcmiQosMapTypeL2Ingress) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        } else {
            qos_base_ptr = 0;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(hd_ing_svp, PHB_ING_L2_IDs, qos_base_ptr));

        if (flow_port->flags & BCM_FLOW_PORT_NETWORK) {
            if (flow_port->drop_mode > bcmFlowPortSplitHorizonDropAll) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
        }

        if (flow_port->flags & BCM_FLOW_PORT_MULTICAST_GROUP_REMAP) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        /* Below are default configuraion. */
        if (!(flow_port->flags & BCM_FLOW_PORT_REPLACE)) {
            /* PORT_SVP configuration. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(hd_ing_svp, MAC_LEARNs, 0x1));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(hd_ing_svp, MAC_MOVEs, 0x1));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(hd_ing_svp, SKIP_VLAN_CHECKs, 0x1));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, hd_ing_svp, opcode,
                                  BCMLT_PRIORITY_NORMAL));

        if (flow_port->flags & BCM_FLOW_PORT_DEFAULT) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(hd_def_svp, DEFAULT_NETWORK_SVPs, vp));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_set_commit(unit, hd_def_svp,
                                          BCMLT_PRIORITY_NORMAL));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, hd_egr_dvp, opcode,
                                  BCMLT_PRIORITY_NORMAL));
    } else if (opt == HW_OPT_GET) {
        uint64_t get_val;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, hd_ing_svp, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(hd_ing_svp, SVP_NETWORK_GRPs, &get_val));
        flow_port->network_group_id = (uint32_t)get_val;;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(hd_ing_svp, CLASS_IDs,
                                   &get_val));
        flow_port->if_class = (uint32_t)get_val;

        flow_port->dscp_map_id = 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(hd_ing_svp,
                                   PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs,
                                   &get_val));
        qos_base_ptr = (uint32_t)get_val;
        if (qos_base_ptr != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_construct(unit, qos_base_ptr,
                                                bcmiQosMapTypeL3Ingress,
                                                &(flow_port->dscp_map_id)));
        }

        flow_port->vlan_pri_map_id = 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(hd_ing_svp, PHB_ING_L2_IDs, &get_val));
        qos_base_ptr = (uint32_t)get_val;
        if (qos_base_ptr != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_construct(unit, qos_base_ptr,
                                                bcmiQosMapTypeL2Ingress,
                                                &(flow_port->vlan_pri_map_id)));
        }

        /* Default SVP handling */
        local_rv = bcmi_lt_entry_commit(unit, hd_def_svp,
                                        BCMLT_OPCODE_LOOKUP,
                                        BCMLT_PRIORITY_NORMAL);
        if (local_rv == SHR_E_NONE) {
            /* default SVP configured */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(hd_def_svp, DEFAULT_NETWORK_SVPs,
                                       &get_val));
            if ((int)get_val == vp){
                flow_port->flags |= BCM_FLOW_PORT_DEFAULT;
            }
        } else {
            /* something wrong internally */
            SHR_ERR_EXIT(local_rv);
        }

        flow_port->drop_mode = bcmFlowPortSplitHorizonDropAll;
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, hd_ing_svp, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, hd_egr_dvp, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));

        /* Default SVP handling */
        local_rv = bcmi_lt_entry_commit(unit, hd_def_svp,
                                        BCMLT_OPCODE_LOOKUP,
                                        BCMLT_PRIORITY_NORMAL);
        if (local_rv == SHR_E_NONE) {
            /* default SVP configured */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(hd_def_svp, DEFAULT_NETWORK_SVPs,
                                       &get_val));
            if ((int)get_val == vp){
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(hd_def_svp, DEFAULT_NETWORK_SVPs,
                                           BCMINT_FLOW_VP_RESERVED));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_lt_entry_commit(unit, hd_def_svp,
                                          BCMLT_OPCODE_UPDATE,
                                          BCMLT_PRIORITY_NORMAL));
            }
        } else {
            /* something wrong internally */
            SHR_ERR_EXIT(local_rv);
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    if (BCMLT_INVALID_HDL != hd_ing_svp) {
        (void) bcmlt_entry_free(hd_ing_svp);
    }
    if (BCMLT_INVALID_HDL != hd_egr_dvp) {
        (void) bcmlt_entry_free(hd_egr_dvp);
    }
    if (BCMLT_INVALID_HDL != hd_def_svp) {
        (void) bcmlt_entry_free(hd_def_svp);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_match_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_match_config_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_param_validation(unit, opt, info));

    if (info->criteria == BCM_FLOW_MATCH_CRITERIA_PORT) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_match_port_ctrl(unit, opt, info));
    } else if (xgs_flow_match_on_ing_adapt(unit, info)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_match_ing_adapt_ctrl(unit, opt, info));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_match_general_ctrl(unit, opt, info));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_match_traverse(
    int unit,
    bcm_flow_match_traverse_cb cb,
    void *user_data)
{
    const char *lt_list[] = {TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNIDs,
                             TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV4s,
                             TNL_L2_VXLAN_DECAP_VFI_ASSIGNMENT_OVID_VNID_SRC_IPV6s,
                             TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV4s,
                             TNL_L2_VXLAN_DECAP_SVP_ASSIGNMENT_OVID_SRC_IPV6s};
    int lt_num = COUNTOF(lt_list);
    int idx = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_port_table_traverse(unit, cb, user_data,
                                            PORT_SYSTEMs));

    for (idx = 0; idx < lt_num; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_match_hash_table_traverse(unit, cb, user_data,
                                                lt_list[idx]));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_ing_adapt_traverse(unit, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_encap_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_encap_config_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_param_validation(unit, opt, info));

    if (info->flow_handle == BCMINT_FLOW_ID_INT) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_encap_int_ctrl(unit, opt, info,
                                     num_of_fields, field));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_encap_general_ctrl(unit, opt, info));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_encap_traverse(
    int unit,
    bcm_flow_encap_traverse_cb cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_hash_table_traverse(unit, cb, user_data,
                                            TNL_L2_VXLAN_ADAPT_VFIs));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_hash_table_traverse(unit, cb, user_data,
                                            TNL_L2_VXLAN_ADAPT_VFI_DVP_GRPs));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_int_traverse(unit, cb, user_data));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_hash_table_traverse(unit, cb, user_data,
                                            VFI_EGR_ADAPT_PORT_GRPs));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_port_encap_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_port_encap_t *info)
{
    int dunit = 0;
    int vp = -1;
    bcmlt_entry_handle_t ent_hd_egr_dvp = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t ent_hd_egr_dvp_read = BCMLT_INVALID_HDL;
    uint64_t get_val;
    uint32_t set_val;
    bcmi_ltsw_virtual_vp_info_t vp_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_port_encap_param_validation(unit, opt, info));

    dunit = bcmi_ltsw_dev_dunit(unit);

    vp = BCM_GPORT_FLOW_PORT_ID_GET(info->flow_port);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_DVPs, &ent_hd_egr_dvp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hd_egr_dvp, PORT_DVP_IDs, vp));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_DVPs, &ent_hd_egr_dvp_read));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hd_egr_dvp_read, PORT_DVP_IDs, vp));

    bcmi_ltsw_virtual_vp_info_init(&vp_info);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vp_info_get(unit, vp, &vp_info));

    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_egr_dvp, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_egr_dvp, DVP_GRPs, &get_val));
        info->dvp_group = (int)get_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_egr_dvp, DVP_NETWORK_GRPs, &get_val));
        info->network_group = (int)get_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hd_egr_dvp, BC_DROPs, &get_val));
        if (get_val) {
            info->flags |= BCM_FLOW_PORT_ENCAP_FLAG_DROP;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_port_encap_mtu_ctrl(unit, opt, info,
                                          ent_hd_egr_dvp,
                                          BCMLT_INVALID_HDL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_egress_obj_get(unit, info->flow_port,
                                                   &info->egress_if));
        if ((info->egress_if != 0) &&
            (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT))) {
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_port_encap_egr_obj_get(unit, info));
        }
    } else if (opt == HW_OPT_SET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_egr_dvp_read,
                                  BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        if (info->options & BCM_FLOW_PORT_ENCAP_OPTION_CLEAR) {
            int local_rv;
            bcm_if_t egress_if;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp, DVP_GRPs,
                                       BCMINT_FLOW_VP_GROUP_DEF));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp, DVP_NETWORK_GRPs,
                                       BCMINT_FLOW_VP_GROUP_DEF));
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_port_encap_mtu_ctrl(unit, opt, info,
                                              ent_hd_egr_dvp_read,
                                              ent_hd_egr_dvp));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp, BC_DROPs, 0));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp, UNKNOWN_MC_DROPs, 0));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(ent_hd_egr_dvp, UNKNOWN_UC_DROPs, 0));

            /* Clear nexthop linked to access VP. */
            local_rv = bcmi_ltsw_virtual_port_egress_obj_get(unit,
                                                             info->flow_port,
                                                             &egress_if);
            if ((local_rv == SHR_E_NONE) && (egress_if != 0) &&
                (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT))) {
                int nh_idx;
                bcmi_ltsw_l3_egr_obj_type_t nh_type;

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_l3_egress_obj_id_resolve(unit,
                                                        egress_if,
                                                        &nh_idx,
                                                        &nh_type));
                SHR_IF_ERR_EXIT_EXCEPT_IF
                    (bcmi_ltsw_l3_egress_delete_l2tag(unit, nh_idx), SHR_E_NOT_FOUND);
            }
            if (egress_if != 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_l3_egress_dvp_set(unit, egress_if, 0));
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_port_egress_obj_set(unit,
                                                       info->flow_port,
                                                       0x0));
        } else {
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_FLAGS_VALID) {
                set_val = (info->flags & BCM_FLOW_PORT_ENCAP_FLAG_DROP) ? 1 : 0;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, BC_DROPs, set_val));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, UNKNOWN_MC_DROPs,
                                           set_val));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, UNKNOWN_UC_DROPs,
                                           set_val));
            }

            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_DVP_GROUP_VALID) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, DVP_GRPs,
                                           info->dvp_group));
            }
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_MTU_VALID) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (xgs_flow_port_encap_mtu_ctrl(unit, opt, info,
                                                  ent_hd_egr_dvp_read,
                                                  ent_hd_egr_dvp));
            }
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_NETWORK_GROUP_VALID) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, DVP_NETWORK_GRPs,
                                           info->network_group));
            }
            if (info->valid_elements & BCM_FLOW_PORT_ENCAP_EGRESS_IF_VALID) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_port_egress_obj_set(unit, info->flow_port,
                                                           info->egress_if));
                SHR_IF_ERR_EXIT_EXCEPT_IF
                    (bcmi_ltsw_l3_egress_dvp_set(unit, info->egress_if, vp), SHR_E_NOT_FOUND);

                /* Sync egress adaptation key type to HW during linkage. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_virtual_port_egress_adapt_key_sync(
                        unit, info->flow_port, info->egress_if));

                /* Update tag action to nexthop linked to acess VP. */
                if (!(vp_info.flags & BCMI_LTSW_VIRTUAL_VP_NETWORK_PORT)) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (xgs_flow_port_encap_egr_obj_set(unit, info));
                }
            }

            /* Default configuration not controled by API. */
            if ((info->flow_handle == 0) ||
                (info->flow_handle == BCMINT_FLOW_ID_CLASSIC_VXLAN) ||
                (info->flow_handle == BCMINT_FLOW_ID_VXLAN)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, SKIP_VP_PRUNINGs,
                                           0x0));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(ent_hd_egr_dvp, SKIP_VLAN_CHECKs,
                                           0x1));
            }
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hd_egr_dvp, BCMLT_OPCODE_UPDATE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hd_egr_dvp) {
        (void) bcmlt_entry_free(ent_hd_egr_dvp);
    }
    if (BCMLT_INVALID_HDL != ent_hd_egr_dvp_read) {
        (void) bcmlt_entry_free(ent_hd_egr_dvp_read);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_l2_if_to_port(
    int unit,
    int l2_if,
    bcm_port_t *port)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_flow_port_to_l2_if(
    int unit,
    bcm_port_t port,
    int *l2_if)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_flow_tunnel_term_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_tunnel_terminator_t *info)
{
    int dunit = 0;
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t entry_hd_read = BCMLT_INVALID_HDL;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_term_param_validation(unit, opt, info));

    dunit = bcmi_ltsw_dev_dunit(unit);

    xgs_flow_tunnel_term_lt_determine(unit, info, &lt_name);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_term_key_set(unit, info, entry_hd));

    
    if (opt == HW_OPT_GET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_term_criteria_determine(unit, lt_name, info));

        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_LOOKUP,
                                     BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_term_data_get(unit, info, lt_name, entry_hd));
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_term_pbmp_profile_ctrl(unit, opt, info,
                                                    entry_hd,
                                                    BCMLT_INVALID_HDL));
    } else if (opt == HW_OPT_SET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_term_data_set(unit, info, entry_hd));
        if (info->flags & BCM_TUNNEL_REPLACE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, lt_name, &entry_hd_read));
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_tunnel_term_key_set(unit, info, entry_hd_read));
            SHR_IF_ERR_VERBOSE_EXIT
                   (bcmi_lt_entry_commit(unit, entry_hd_read, BCMLT_OPCODE_LOOKUP,
                                         BCMLT_PRIORITY_NORMAL));

            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_tunnel_term_pbmp_profile_ctrl(unit, opt, info,
                                                        entry_hd_read,
                                                        entry_hd));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_UPDATE,
                                      BCMLT_PRIORITY_NORMAL));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_flow_tunnel_term_pbmp_profile_ctrl(unit, opt, info,
                                                        BCMLT_INVALID_HDL,
                                                        entry_hd));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_INSERT,
                                      BCMLT_PRIORITY_NORMAL));
        }
    } else if (opt == HW_OPT_CLR) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, lt_name, &entry_hd_read));
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_term_key_set(unit, info, entry_hd_read));
        SHR_IF_ERR_VERBOSE_EXIT
               (bcmi_lt_entry_commit(unit, entry_hd_read, BCMLT_OPCODE_LOOKUP,
                                     BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_term_pbmp_profile_ctrl(unit, opt, info,
                                                    entry_hd_read,
                                                    BCMLT_INVALID_HDL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hd, BCMLT_OPCODE_DELETE,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hd) {
        (void) bcmlt_entry_free(entry_hd);
    }
    if (BCMLT_INVALID_HDL != entry_hd_read) {
        (void) bcmlt_entry_free(entry_hd_read);
    }

    SHR_FUNC_EXIT();

}

int
xgs_ltsw_flow_tunnel_term_traverse(
    int unit,
    bcm_flow_tunnel_terminator_traverse_cb cb,
    void *user_data)
{
    const char *lt_list[] = {TNL_L2_VXLAN_DECAP_OVID_IPV6_EMs,
                             TNL_L2_VXLAN_DECAP_OVID_DST_IPV6_EMs,
                             TNL_L2_VXLAN_DECAP_OVID_IPV4_EMs,
                             TNL_L2_VXLAN_DECAP_OVID_DST_IPV4_EMs,
                             TNL_L2_VXLAN_DECAP_OVID_IPV6s,
                             TNL_L2_VXLAN_DECAP_OVID_DST_IPV6s,
                             TNL_L2_VXLAN_DECAP_OVID_IPV4s,
                             TNL_L2_VXLAN_DECAP_OVID_DST_IPV4s};
    int lt_num = COUNTOF(lt_list);
    int idx = 0;

    SHR_FUNC_ENTER(unit);

    for (idx = 0; idx < lt_num; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_term_table_traverse(unit, cb, user_data,
                                                 lt_list[idx]));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_tunnel_initiator_hw_opt(
    int unit,
    bcmint_flow_hw_opt_type_t opt,
    bcm_flow_tunnel_initiator_t *info)
{
    uint32_t tnl_idx = 0;
    uint32_t soft_tnl_idx = 0;
    uint8_t tnl_allocated = 0;
    bcmi_ltsw_tunnel_type_t tnl_type;
    uint8_t ipv6 = 0;
    int encap_idx = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_initiator_param_validation(unit, opt, info));

    if (opt == HW_OPT_GET) {
        BCMI_LTSW_GPORT_TUNNEL_ID_GET(info->tunnel_id, tnl_type, soft_tnl_idx);
        info->l3_intf_id = soft_tnl_idx;;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_intf_tnl_init_get(unit, info->l3_intf_id,
                                            &tnl_type,  &encap_idx));
        if (tnl_type == bcmiTunnelTypeIp6L3) {
            info->type = bcmTunnelTypeVxlan6;
            info->flow_handle = BCMINT_FLOW_ID_VXLAN;
        } else if (tnl_type == bcmiTunnelTypeIpL3) {
            info->type = bcmTunnelTypeVxlan;
            info->flow_handle = BCMINT_FLOW_ID_CLASSIC_VXLAN;
        } else {
            SHR_IF_ERR_MSG_EXIT(SHR_E_INTERNAL,
                                (BSL_META_U(unit, "Invalid tunnel type:%d!\n"),
                                            tnl_type));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_initiator_get(unit, tnl_idx, info));
    } else if (opt == HW_OPT_SET) {
        uint32_t flag;

        flag = BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO;
        if (info->flags & BCM_TUNNEL_REPLACE) {
           flag |= BCMI_LTSW_IDX_TBL_OP_REPLACE | BCMI_LTSW_IDX_TBL_OP_WITH_ID;
           BCMI_LTSW_GPORT_TUNNEL_ID_GET(info->tunnel_id, tnl_type, soft_tnl_idx);
           SHR_IF_ERR_VERBOSE_EXIT
               (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_initiator_type_determine(unit, info, tnl_idx,
                                                      &ipv6));
        if (ipv6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_alloc(
                     unit, flag,
                     BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                     BCMI_EGR_L3_IP6_TNL_USER_ID_FLEX_FLOW,
                     info, (int *)(&tnl_idx)));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_alloc(
                     unit, flag,
                     BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                     BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                     info, (int *)(&tnl_idx)));
        }

        tnl_allocated = 1;
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_initiator_encap_index_get(unit, ipv6, tnl_idx,
                                                       &encap_idx));
        if (ipv6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_intf_tnl_init_set(unit, info->l3_intf_id,
                                                bcmiTunnelTypeIp6L3,
                                                encap_idx));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_intf_tnl_init_set(unit, info->l3_intf_id,
                                                bcmiTunnelTypeIpL3,
                                                encap_idx));
        }

        /* IPv4 Fragment ID  */
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_initiator_ipv4_id_set(unit, info, encap_idx));

        if (!(info->flags & BCM_TUNNEL_REPLACE)) {
            soft_tnl_idx = info->l3_intf_id;
            BCMI_LTSW_GPORT_TUNNEL_ID_SET(info->tunnel_id,
                                          bcmiTunnelTypeFlexFlow,
                                          soft_tnl_idx);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_flow_tunnel_idx_set(unit, soft_tnl_idx, tnl_idx));
        }
    } else if (opt == HW_OPT_CLR) {
        BCMI_LTSW_GPORT_TUNNEL_ID_GET(info->tunnel_id, tnl_type, soft_tnl_idx);
        info->l3_intf_id = soft_tnl_idx;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_intf_tnl_init_get(unit, info->l3_intf_id,
                                            &tnl_type,  &encap_idx));
        if (tnl_type == bcmiTunnelTypeIp6L3) {
            SHR_IF_ERR_VERBOSE_EXIT(
                bcmi_ltsw_idx_tbl_entry_free(
                      unit, 0,
                      BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                      BCMI_EGR_L3_IP6_TNL_USER_ID_FLEX_FLOW,
                      tnl_idx));
        } else if (tnl_type == bcmiTunnelTypeIpL3) {
            SHR_IF_ERR_VERBOSE_EXIT(
                bcmi_ltsw_idx_tbl_entry_free(
                      unit, 0,
                      BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                      BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                      tnl_idx));
        } else {
            SHR_IF_ERR_MSG_EXIT(SHR_E_INTERNAL,
                                (BSL_META_U(unit, "Invalid tunnel type:%d!\n"),
                                            tnl_type));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_intf_tnl_init_reset(unit, info->l3_intf_id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_tunnel_idx_set(unit, soft_tnl_idx,
                                        BCMINT_FLOW_EGR_TUNNEL_RESERVED));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "invalid opt:%d!\n"), opt));
    }

exit:
    if (SHR_FUNC_ERR() && tnl_allocated) {
        if (ipv6) {
            (void)bcmi_ltsw_idx_tbl_entry_free(
                      unit, 0,
                      BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                      BCMI_EGR_L3_IP6_TNL_USER_ID_FLEX_FLOW,
                      tnl_idx);
        } else {
            (void)bcmi_ltsw_idx_tbl_entry_free(
                      unit, 0,
                      BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                      BCMI_EGR_L3_TNL_USER_ID_FLEX_FLOW,
                      tnl_idx);
        }
        (void)bcmi_ltsw_l3_intf_tnl_init_reset(unit, info->l3_intf_id);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_tunnel_initiator_traverse(
    int unit,
    bcm_flow_tunnel_initiator_traverse_cb cb,
    void *user_data)
{
    uint64_t idx_min, idx_max;
    bcm_flow_tunnel_initiator_t info;
    uint32_t tnl_idx, soft_tnl_idx;
    bcmi_ltsw_tunnel_type_t tnl_type;
    int encap_idx;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, L3_EIFs, L3_EIF_IDs,
                                       &idx_min, &idx_max));
    /*
     * Enhance tunnel index to support egress L3 interface.
     * Index 0 reserved.
     */
    if (idx_min == 0) {
        idx_min = 1;
    }
    for (soft_tnl_idx = idx_min; soft_tnl_idx <= idx_max; soft_tnl_idx++) {
        bcm_flow_tunnel_initiator_t_init(&info);

        info.l3_intf_id = soft_tnl_idx;
        BCMI_LTSW_GPORT_TUNNEL_ID_SET(info.tunnel_id,
                                      bcmiTunnelTypeFlexFlow, soft_tnl_idx);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
        if (tnl_idx == BCMINT_FLOW_EGR_TUNNEL_RESERVED) {
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_intf_tnl_init_get(unit, info.l3_intf_id,
                                            &tnl_type,  &encap_idx));
        if (tnl_type == bcmiTunnelTypeIp6L3) {
            info.type = bcmTunnelTypeVxlan6;
            info.flow_handle = BCMINT_FLOW_ID_VXLAN;
        } else if (tnl_type == bcmiTunnelTypeIpL3) {
            info.type = bcmTunnelTypeVxlan;
            info.flow_handle = BCMINT_FLOW_ID_CLASSIC_VXLAN;
        } else {
            SHR_IF_ERR_MSG_EXIT(SHR_E_INTERNAL,
                                (BSL_META_U(unit, "Invalid tunnel type:%d!\n"),
                                            tnl_type));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_flow_tunnel_initiator_get(unit, tnl_idx, &info));

        if (cb) {
            rv = (*cb) (unit, &info, 0, NULL, user_data);
            if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv);
            }
        }
   }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_stat_attach(
    int unit,
    bcm_flow_stat_info_t *info,
    uint32_t stat_counter_id)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_flow_stat_detach(
    int unit,
    bcm_flow_stat_info_t *info,
    uint32_t stat_counter_id)
{
    return SHR_E_UNAVAIL;
}

void
xgs_ltsw_flow_sw_dump(int unit)
{
    return;
}

int
xgs_ltsw_flow_switch_control_set(
    int unit,
    bcm_switch_control_t type,
    int arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmSwitchVxlanUdpSrcPortSelect:
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_ltsw_flow_switch_udp_src_set(unit, arg));
            break;
        case bcmSwitchVxlanUdpDestPortSet:
        case bcmSwitchVxlanTunnelMissToCpu:
        case bcmSwitchVxlanVnIdMissToCpu:
        case bcmSwitchVxlanHeaderFlags:
        case bcmSwitchVxlanHeaderReserved1:
        case bcmSwitchVxlanHeaderReserved2:
        case bcmSwitchVxlanHeaderMatchFlags:
        case bcmSwitchVxlanHeaderFlagsMask:
        case bcmSwitchVxlanHeaderFlagsMismatchDrop:
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_ltsw_flow_switch_control_general_set(unit, type, arg));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_switch_control_get(
    int unit,
    bcm_switch_control_t type,
    int *arg)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case bcmSwitchVxlanUdpSrcPortSelect:
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_ltsw_flow_switch_udp_src_get(unit, arg));
            break;
        case bcmSwitchVxlanUdpDestPortSet:
        case bcmSwitchVxlanTunnelMissToCpu:
        case bcmSwitchVxlanVnIdMissToCpu:
        case bcmSwitchVxlanHeaderFlags:
        case bcmSwitchVxlanHeaderReserved1:
        case bcmSwitchVxlanHeaderReserved2:
        case bcmSwitchVxlanHeaderMatchFlags:
        case bcmSwitchVxlanHeaderFlagsMask:
        case bcmSwitchVxlanHeaderFlagsMismatchDrop:
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_ltsw_flow_switch_control_general_get(unit, type, arg));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_es_filter_set(
    int unit,
    bcm_gport_t flow_port_id,
    uint32_t es_id,
    uint32_t flags)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int vp;
    uint64_t set_val;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_es_filter_check(unit));
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_virtual_vfi_type_vp_get(unit, flow_port_id, &vp));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SVP_ES_FILTERINGs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PORT_SVP_IDs, vp));
    if (flags & BCM_FLOW_ES_FILTER_DROP_ENABLE ) {
        set_val = 1;
    } else {
        set_val = 0;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, ES_DROPs, es_id, &set_val, 1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_es_filter_get(
    int unit,
    bcm_gport_t flow_port_id,
    uint32_t es_id,
    uint32_t *flags)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int vp;
    uint64_t get_val;
    uint32_t r_elem_cnt;
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(flags, SHR_E_PARAM);
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_es_filter_check(unit));
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_virtual_vfi_type_vp_get(unit, flow_port_id, &vp));

    *flags = 0;
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SVP_ES_FILTERINGs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PORT_SVP_IDs, vp));
    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_EXIT();
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, ES_DROPs, es_id, &get_val,
                                         1, &r_elem_cnt));
        if (get_val) {
            *flags |= BCM_FLOW_ES_FILTER_DROP_ENABLE;
        }
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_es_filter_flexctr_object_set(
    int unit,
    bcm_gport_t flow_port_id,
    uint32_t value)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int vp;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_es_filter_check(unit));
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_virtual_vfi_type_vp_get(unit, flow_port_id, &vp));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SVP_ES_FILTERINGs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PORT_SVP_IDs, vp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CTR_EGR_EFLEX_OBJECTs, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_es_filter_flexctr_object_get(
    int unit,
    bcm_gport_t flow_port_id,
    uint32_t *value)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int vp;
    uint64_t get_val;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(value, SHR_E_PARAM);
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_es_filter_check(unit));
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_virtual_vfi_type_vp_get(unit, flow_port_id, &vp));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SVP_ES_FILTERINGs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PORT_SVP_IDs, vp));
    SHR_IF_ERR_VERBOSE_EXIT
         (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                               BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, CTR_EGR_EFLEX_OBJECTs, &get_val));
    *value = get_val;

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_es_filter_stat_attach(
    int unit,
    bcm_gport_t flow_port_id,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_es_filter_check(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));

    if (counter_info.source != bcmFlexctrSourceEsFilter) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_attach_counter_id_status_update(unit,
                                                           stat_counter_id));

    SHR_IF_ERR_CONT
        (xgs_flow_es_filter_stat_update(unit, flow_port_id, &counter_info,
                                        TRUE));

    if (SHR_FUNC_ERR()) {
        (void)
        bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                          stat_counter_id);
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_es_filter_stat_detach(
    int unit,
    bcm_gport_t flow_port_id,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_es_filter_check(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));

    if (counter_info.source != bcmFlexctrSourceEsFilter) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_es_filter_stat_update(unit, flow_port_id, &counter_info,
                                        FALSE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                           stat_counter_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_es_filter_stat_id_get(
    int unit,
    bcm_gport_t flow_port_id,
    uint32_t *stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t ci = {0};
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    int vp;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(stat_counter_id, SHR_E_PARAM);
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_es_filter_check(unit));
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_virtual_vfi_type_vp_get(unit, flow_port_id, &vp));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SVP_ES_FILTERINGs, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, PORT_SVP_IDs, vp));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, CTR_EGR_EFLEX_ACTIONs, &flex_ctr_action));
    ci.action_index = flex_ctr_action;
    ci.direction = BCMI_LTSW_FLEXCTR_DIR_EGRESS;
    ci.stage = BCMI_LTSW_FLEXCTR_STAGE_EGR_CTR;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_get(unit, &ci, stat_counter_id));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_vpn_stat_attach(
    int unit,
    bcm_vpn_t vpn,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));

    if ((counter_info.source != bcmFlexctrSourceIngVpn) &&
        (counter_info.source != bcmFlexctrSourceEgrVpn)) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_attach_counter_id_status_update(unit,
                                                           stat_counter_id));
    SHR_IF_ERR_CONT
        (xgs_flow_vpn_stat_update(unit, vpn, &counter_info, TRUE));
    if (SHR_FUNC_ERR()) {
        (void)
        bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                          stat_counter_id);
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_vpn_stat_detach(
    int unit,
    bcm_vpn_t vpn,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));
    if ((counter_info.source != bcmFlexctrSourceIngVpn) &&
        (counter_info.source != bcmFlexctrSourceEgrVpn)) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_vpn_stat_update(unit, vpn, &counter_info, FALSE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                           stat_counter_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_vpn_stat_id_get(
    int unit,
    bcm_vpn_t vpn,
    bcm_flexctr_direction_t direction,
    uint32_t *stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t ci = {0};
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    uint32_t vfi_index = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(stat_counter_id, SHR_E_PARAM);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_virtual_vfi_idx_get(unit, vpn, &vfi_index));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, VFIs, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, VFI_IDs, vfi_index));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    if (direction == bcmFlexctrDirectionEgress) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, CTR_EGR_EFLEX_ACTIONs, &flex_ctr_action));
        ci.action_index = flex_ctr_action;
        ci.direction = BCMI_LTSW_FLEXCTR_DIR_EGRESS;
        ci.stage = BCMI_LTSW_FLEXCTR_STAGE_EGR_CTR;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, CTR_ING_EFLEX_ACTIONs, &flex_ctr_action));
        ci.action_index = flex_ctr_action;
        ci.direction = BCMI_LTSW_FLEXCTR_DIR_INGRESS;
        ci.stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_get(unit, &ci, stat_counter_id));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_port_stat_attach(
    int unit,
    bcm_gport_t flow_port_id,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));

    if ((counter_info.source != bcmFlexctrSourceSvp) &&
        (counter_info.source != bcmFlexctrSourceDvp)) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    /* Special handling for SVP flex counter. */
    if (counter_info.source == bcmFlexctrSourceSvp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_stat_attach(unit, flow_port_id,
                                                stat_counter_id));
        SHR_EXIT();
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_attach_counter_id_status_update(unit,
                                                           stat_counter_id));
    SHR_IF_ERR_CONT
        (xgs_flow_vp_stat_update(unit, flow_port_id, &counter_info, TRUE));
    if (SHR_FUNC_ERR()) {
        (void)
        bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                          stat_counter_id);
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_port_stat_detach(
    int unit,
    bcm_gport_t flow_port_id,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));
    if ((counter_info.source != bcmFlexctrSourceSvp) &&
        (counter_info.source != bcmFlexctrSourceDvp)) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    /* Special handling for SVP flex counter. */
    if (counter_info.source == bcmFlexctrSourceSvp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_stat_detach_with_id(unit, flow_port_id,
                                                        stat_counter_id));
        SHR_EXIT();
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_vp_stat_update(unit, flow_port_id, &counter_info, FALSE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                           stat_counter_id));


exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_port_stat_id_get(
    int unit,
    bcm_gport_t flow_port_id,
    bcm_flexctr_direction_t direction,
    uint32_t *stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t ci = {0};
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t entry_hd_profile = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    int action_profile;
    int vp = 0;
    uint64_t get_val;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(stat_counter_id, SHR_E_PARAM);
    vp = BCM_GPORT_FLOW_PORT_ID_GET(flow_port_id);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (direction == bcmFlexctrDirectionEgress) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, PORT_DVPs, &entry_hd));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, PORT_DVP_IDs, vp));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hd,
                                  BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        /* Enhance API to support ingress. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, CTR_EGR_EFLEX_ACTIONs, &flex_ctr_action));
        ci.action_index = flex_ctr_action;
        ci.direction = BCMI_LTSW_FLEXCTR_DIR_EGRESS;
        ci.stage = BCMI_LTSW_FLEXCTR_STAGE_EGR_CTR;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_flexctr_counter_id_get(unit, &ci, stat_counter_id));
    } else {

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, PORT_SVPs, &entry_hd));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, PORT_SVP_IDs, vp));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hd,
                                  BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd, PORT_SVP_ING_EFLEX_ACTION_IDs,
                                   &get_val));
        action_profile = (int)get_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, PORT_SVP_ING_EFLEX_ACTIONs,
                                  &entry_hd_profile));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd_profile,
                                   PORT_SVP_ING_EFLEX_ACTION_IDs,
                                   action_profile));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hd_profile, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hd_profile, ACTIONs, &flex_ctr_action));

        ci.action_index = flex_ctr_action;
        ci.direction = BCMI_LTSW_FLEXCTR_DIR_INGRESS;
        ci.stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_flexctr_counter_id_get(unit, &ci, stat_counter_id));
    }

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    if (entry_hd_profile != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd_profile);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_tunnel_initiator_stat_attach(
    int unit,
    bcm_gport_t tunnel_id,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));

    if (counter_info.source != bcmFlexctrSourceL2TunnelInitiator) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_attach_counter_id_status_update(unit,
                                                           stat_counter_id));
    SHR_IF_ERR_CONT
        (xgs_flow_tunnel_initiator_stat_update(unit, tunnel_id, &counter_info, TRUE));
    if (SHR_FUNC_ERR()) {
        (void)
        bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                          stat_counter_id);
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_tunnel_initiator_stat_detach(
    int unit,
    bcm_gport_t tunnel_id,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));
    if (counter_info.source != bcmFlexctrSourceL2TunnelInitiator) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_initiator_stat_update(unit, tunnel_id, &counter_info, FALSE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                           stat_counter_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_tunnel_initiator_stat_id_get(
    int unit,
    bcm_gport_t tunnel_id,
    uint32_t *stat_counter_id)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    uint32_t tnl_idx = 0;
    uint32_t soft_tnl_idx = 0;
    bcmi_ltsw_tunnel_type_t tnl_type;
    int encap_idx = 0;
    bcmi_ltsw_flexctr_counter_info_t ci = {0};

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    BCMI_LTSW_GPORT_TUNNEL_ID_GET(tunnel_id, tnl_type, soft_tnl_idx);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_flow_tunnel_idx_get(unit, soft_tnl_idx, &tnl_idx));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_intf_tnl_init_get(unit, soft_tnl_idx,
                                        &tnl_type,  &encap_idx));
    if (tnl_type == bcmiTunnelTypeIp6L3) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV6_ENCAPs, &entry_hd));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, TNL_IPV6_ENCAP_IDs, tnl_idx));
    } else if (tnl_type == bcmiTunnelTypeIpL3) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV4_ENCAPs, &entry_hd));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hd, TNL_IPV4_ENCAP_IDs, tnl_idx));
    } else {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "Invalid tunnel type:%d!\n"),
                                        tnl_type));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, CTR_EGR_EFLEX_ACTIONs, &flex_ctr_action));
    ci.action_index = flex_ctr_action;
    ci.direction = BCMI_LTSW_FLEXCTR_DIR_EGRESS;
    ci.stage = BCMI_LTSW_FLEXCTR_STAGE_EGR_CTR;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_get(unit, &ci, stat_counter_id));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_encap_flexctr_object_set(
    int unit,
    bcm_flow_encap_config_t *info,
    uint32_t value)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    int dunit = 0;
    const char *obj_name = CTR_EGR_EFLEX_OBJECTs ;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_lt_determine(dunit, info, &lt_name));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_key_set(unit, info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, obj_name, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_encap_flexctr_object_get(
    int unit,
    bcm_flow_encap_config_t *info,
    uint32_t *value)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t get_val;
    int dunit = 0;
    const char *obj_name = CTR_EGR_EFLEX_OBJECTs;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_lt_determine(dunit, info, &lt_name));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_key_set(unit, info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, obj_name, &get_val));
    *value = get_val;

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_encap_stat_attach(
    int unit,
    bcm_flow_encap_config_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));

    if (counter_info.source != bcmFlexctrSourceL2TunnelVnidAssignment) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_attach_counter_id_status_update(unit,
                                                           stat_counter_id));
    SHR_IF_ERR_CONT
        (xgs_flow_encap_stat_update(unit, info, &counter_info, TRUE));
    if (SHR_FUNC_ERR()) {
        (void)
        bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                          stat_counter_id);
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_encap_stat_detach(
    int unit,
    bcm_flow_encap_config_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));
    if (counter_info.source != bcmFlexctrSourceL2TunnelVnidAssignment) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_stat_update(unit, info, &counter_info, FALSE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                           stat_counter_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_encap_stat_id_get(
    int unit,
    bcm_flow_encap_config_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field,
    uint32_t *stat_counter_id)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    const char *action_name = CTR_EGR_EFLEX_ACTIONs;
    const char *lt_name = NULL;
    bcmi_ltsw_flexctr_counter_info_t ci = {0};

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_lt_determine(dunit, info, &lt_name));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_encap_key_set(unit, info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, action_name, &flex_ctr_action));
    ci.action_index = flex_ctr_action;
    ci.direction = BCMI_LTSW_FLEXCTR_DIR_EGRESS;
    ci.stage = BCMI_LTSW_FLEXCTR_STAGE_EGR_CTR;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_get(unit, &ci, stat_counter_id));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_match_flexctr_object_set(
    int unit,
    bcm_flow_match_config_t *info,
    uint32_t value)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    int dunit = 0;
    const char *obj_name = CTR_ING_EFLEX_OBJECTs ;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_lt_determine(dunit, info, &lt_name));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_key_set(unit, info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, obj_name, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_match_flexctr_object_get(
    int unit,
    bcm_flow_match_config_t *info,
    uint32_t *value)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t get_val;
    int dunit = 0;
    const char *obj_name = CTR_ING_EFLEX_OBJECTs;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_lt_determine(dunit, info, &lt_name));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_key_set(unit, info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, obj_name, &get_val));
    *value = get_val;

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_match_stat_attach(
    int unit,
    bcm_flow_match_config_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));

    if ((counter_info.source != bcmFlexctrSourceL2TunnelVpnAssignment) &&
        (counter_info.source != bcmFlexctrSourceSvpAssignment)) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_attach_counter_id_status_update(unit,
                                                           stat_counter_id));
    SHR_IF_ERR_CONT
        (xgs_flow_match_stat_update(unit, info, &counter_info, TRUE));
    if (SHR_FUNC_ERR()) {
        (void)
        bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                          stat_counter_id);
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_match_stat_detach(
    int unit,
    bcm_flow_match_config_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));
    if ((counter_info.source != bcmFlexctrSourceL2TunnelVpnAssignment) &&
        (counter_info.source != bcmFlexctrSourceSvpAssignment)) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_stat_update(unit, info, &counter_info, FALSE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                           stat_counter_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_match_stat_id_get(
    int unit,
    bcm_flow_match_config_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field,
    uint32_t *stat_counter_id)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    const char *action_name = CTR_ING_EFLEX_ACTIONs;
    const char *lt_name = NULL;
    bcmi_ltsw_flexctr_counter_info_t ci = {0};

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_lt_determine(dunit, info, &lt_name));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_match_key_set(unit, info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, action_name, &flex_ctr_action));
    ci.action_index = flex_ctr_action;
    ci.direction = BCMI_LTSW_FLEXCTR_DIR_INGRESS;
    ci.stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_get(unit, &ci, stat_counter_id));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_tunnel_terminator_flexctr_object_set(
    int unit,
    bcm_flow_tunnel_terminator_t *info,
    uint32_t value)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    int dunit = 0;
    const char *obj_name = CTR_ING_EFLEX_OBJECTs ;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    xgs_flow_tunnel_term_lt_determine(dunit, info, &lt_name);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_term_key_set(unit, info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hd, obj_name, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_tunnel_terminator_flexctr_object_get(
    int unit,
    bcm_flow_tunnel_terminator_t *info,
    uint32_t *value)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t get_val;
    int dunit = 0;
    const char *obj_name = CTR_ING_EFLEX_OBJECTs;
    const char *lt_name = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    xgs_flow_tunnel_term_lt_determine(dunit, info, &lt_name);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_term_key_set(unit, info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, obj_name, &get_val));
    *value = get_val;

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_tunnel_terminator_stat_attach(
    int unit,
    bcm_flow_tunnel_terminator_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));

    if (counter_info.source != bcmFlexctrSourceL2TunnelTerminator) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_attach_counter_id_status_update(unit,
                                                           stat_counter_id));
    SHR_IF_ERR_CONT
        (xgs_flow_tunnel_terminator_stat_update(unit, info, &counter_info, TRUE));
    if (SHR_FUNC_ERR()) {
        (void)
        bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                          stat_counter_id);
        SHR_EXIT();
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_tunnel_terminator_stat_detach(
    int unit,
    bcm_flow_tunnel_terminator_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field,
    uint32_t stat_counter_id)
{
    bcmi_ltsw_flexctr_counter_info_t counter_info = {0};

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_info_get(unit, stat_counter_id,
                                               &counter_info));
    if (counter_info.source != bcmFlexctrSourceL2TunnelTerminator) {
        SHR_IF_ERR_MSG_EXIT(SHR_E_PARAM,
                            (BSL_META_U(unit, "counter source (%d) not expected!\n"),
                                        counter_info.source));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_terminator_stat_update(unit, info, &counter_info, FALSE));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_detach_counter_id_status_update(unit,
                                                           stat_counter_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flow_tunnel_terminator_stat_id_get(
    int unit,
    bcm_flow_tunnel_terminator_t *info,
    uint32_t num_of_fields,
    bcm_flow_logical_field_t *field,
    uint32_t *stat_counter_id)
{
    bcmlt_entry_handle_t entry_hd = BCMLT_INVALID_HDL;
    uint64_t flex_ctr_action;
    int dunit = 0;
    const char *action_name = CTR_ING_EFLEX_ACTIONs;
    const char *lt_name = NULL;
    bcmi_ltsw_flexctr_counter_info_t ci = {0};

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    xgs_flow_tunnel_term_lt_determine(dunit, info, &lt_name);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_flow_tunnel_term_key_set(unit, info, entry_hd));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hd,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hd, action_name, &flex_ctr_action));
    ci.action_index = flex_ctr_action;
    ci.direction = BCMI_LTSW_FLEXCTR_DIR_INGRESS;
    ci.stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_flexctr_counter_id_get(unit, &ci, stat_counter_id));

exit:
    if (entry_hd != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hd);
    }
    SHR_FUNC_EXIT();
}
