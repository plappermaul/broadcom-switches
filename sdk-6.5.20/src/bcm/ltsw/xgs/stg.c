/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/stg.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/xgs/stg.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/stg_int.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/vlan.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_STG

/******************************************************************************
 * Private functions
 */


/*!
 * \brief STG info structure for callback function.
 */
typedef struct stg_map_recover_info_s {

    /*! Bitmap of allocated STGs. */
    SHR_BITDCL *stg_bmp;

    /*! uidx_first[stg] is the first user(VLAN/VPN) index in a STG. */
    int *uidx_first;

    /*! uidx_next[user_idx] contains the next user index in same STG. */
    int *uidx_next;

} stg_map_recover_info_t;

/*!
 * \brief Recover stg usage bitmap during warm boot.
 *
 * \param [in] unit      Unit Number.
 * \param [in] stg_bmp   Bitmap of STGs.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_bmp_recover(int unit, SHR_BITDCL *stg_bmp)
{
    int rv = SHR_E_NONE;
    int dunit = 0;
    uint64_t stg = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const bcmint_stg_lt_t *lt_info;
    const char *fld_name;
    const bcmint_stg_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stg_lt_get(unit, BCMINT_LTSW_STG_VLAN_VFI_STG, &lt_info));
    flds = lt_info->flds;
    fld_name = flds[BCMINT_LTSW_STG_FLD_VLAN_VFI_STG_ID].name;

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &entry_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry_hdl, fld_name, &stg));

        SHR_BITSET(stg_bmp, stg);
    }

    if (rv != SHR_E_NOT_FOUND) {
        SHR_IF_ERR_EXIT(rv);
    }

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void) bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover stg usage map during warm boot.
 *
 * \param [in] unit       Unit Number.
 * \param [in] info       VLAN info.
 * \param [in] user_data  User data.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
stg_map_recover(int unit, bcmi_ltsw_vlan_info_t *info, void *user_data)
{
    bcm_vlan_t vid = 0;
    int uidx = 0;
    stg_map_recover_info_t *stg_info =
        (stg_map_recover_info_t *)user_data;

    SHR_FUNC_ENTER(unit);

    if ((info->vid > BCM_VLAN_MAX) && (ltsw_feature(unit, LTSW_FT_VFI))) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, info->vid, &vid));
    } else {
        vid = info->vid;
        /* vlan 0 (entry 0 in VFI table) is reserved. */
        if (vid == BCM_VLAN_NONE) {
            SHR_EXIT();
        }
    }

    if (SHR_BITGET(stg_info->stg_bmp, info->stg)) {
        uidx = bcmint_stg_user_idx_get(unit, vid);
        stg_info->uidx_next[uidx] = stg_info->uidx_first[info->stg];
        stg_info->uidx_first[info->stg]= uidx;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Reset VLAN table with default STG.
 *
 * \param [in] unit      Unit Number.
 * \param [in] info       VLAN info.
 * \param [in] user_data  User data.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_stg_vlan_reset(int unit, bcmi_ltsw_vlan_info_t *info, void *user_data)
{
    bcm_vlan_t vid = 0;
    bcm_stg_t stg;
    int ingress;
    SHR_FUNC_ENTER(unit);

    /* Entry 0 is reserved. */
    if (info->vid == BCM_VLAN_NONE) {
        SHR_EXIT();
    }

    /* VFI (> BCM_VLAN_MAX) is used for VPN. */
    if ((info->vid > BCM_VLAN_MAX) && (ltsw_feature(unit, LTSW_FT_VFI))) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, info->vid, &vid));
    } else {
        vid = (bcm_vlan_t)(info->vid);
    }

    ingress = TRUE;
    stg = *((bcm_stg_t*)user_data);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_stg_set(unit, vid, ingress, stg));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set STP state for a port in VLAN STG.
 *
 * \param [in] unit      Unit Number.
 * \param [in] stg       STG index.
 * \param [in] port      Port ID.
 * \param [in] stp_state Spanning tree state.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_stg_entry_set(int unit, bcm_stg_t stg, bcm_port_t port, int stp_state)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const bcmint_stg_lt_t *lt_info;
    const char *fld_name, *str_value;
    const bcmint_stg_fld_t *flds;
    int fid;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stg_lt_get(unit, BCMINT_LTSW_STG_VLAN_VFI_STG, &lt_info));
    /* Allocate entry container. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &entry_hdl));

    /* Add STG ID. */
    flds = lt_info->flds;
    fid = BCMINT_LTSW_STG_FLD_VLAN_VFI_STG_ID;
    fld_name = flds[fid].name;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, fld_name, stg));

    fid = BCMINT_LTSW_STG_FLD_VLAN_VFI_STG_STATE;
    fld_name = flds[fid].name;
    SHR_IF_ERR_VERBOSE_EXIT
        (flds[fid].scalar_to_symbol(unit, stp_state, &str_value));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_symbol_add(entry_hdl, fld_name, (uint32_t)port,
                                            &str_value, 1));

    /* Update VLAN STG entry. */
    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_UPDATE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get STP state for a port in VLAN STG.
 *
 * \param [in] unit      Unit Number.
 * \param [in] stg       STG index.
 * \param [in] port      Port ID.
 * \param [out]stp_state Spanning tree state.
 *
 * \retval SHR_E_NONE    No errors.
 * \retval !SHR_E_NONE   Failure.
 */
static int
xgs_stg_entry_get(int unit, bcm_stg_t stg, bcm_port_t port, int *stp_state)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *state = NULL;
    uint32_t cnt = 0;
    const bcmint_stg_lt_t *lt_info;
    const char *fld_name;
    const bcmint_stg_fld_t *flds;
    int fid;
    uint64_t value;


    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stg_lt_get(unit, BCMINT_LTSW_STG_VLAN_VFI_STG, &lt_info));
    /* Allocate entry container. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &entry_hdl));

    /* Add STG ID. */
    flds = lt_info->flds;
    fid = BCMINT_LTSW_STG_FLD_VLAN_VFI_STG_ID;
    fld_name = flds[fid].name;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, fld_name, stg));

    /* Lookup VLAN STG entry. */
    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

    /* Get STP state. */
    fid = BCMINT_LTSW_STG_FLD_VLAN_VFI_STG_STATE;
    fld_name = flds[fid].name;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_symbol_get(entry_hdl, fld_name, (uint32_t)port,
                                            &state, 1, &cnt));
    SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].symbol_to_scalar(unit, state, &value));

    *stp_state = value;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_stg_size_get(
    int unit,
    bcm_stg_t *stg_min,
    bcm_stg_t *stg_max,
    int *vlan_count,
    int *vpn_count,
    int *vpn_offset)
{
    uint64_t min_stg = 0;
    uint64_t max_stg = 0;
    const bcmint_stg_lt_t *lt_info;
    const char *fld_name;
    const bcmint_stg_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stg_lt_get(unit, BCMINT_LTSW_STG_VLAN_VFI_STG, &lt_info));
    flds = lt_info->flds;
    fld_name = flds[BCMINT_LTSW_STG_FLD_VLAN_VFI_STG_ID].name;

    SHR_IF_ERR_EXIT
        (bcmi_lt_field_value_range_get(unit, lt_info->name, fld_name,
                                       &min_stg, &max_stg));
    /*
     * XGS switches have a special STG 0 entry that is used only for tagged
     * packets with invalid VLAN.
     */
    *stg_min = 1;
    *stg_max = (bcm_stg_t)max_stg;


    *vlan_count = BCM_VLAN_COUNT;

    
    *vpn_count = 0;
    *vpn_offset = 0;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stg_vlan_set(
    int unit,
    bcm_vlan_t vid,
    bcm_stg_t stg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_stg_set(unit, vid, 1, stg));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stg_vlan_get(
    int unit,
    bcm_vlan_t vid,
    bcm_stg_t *stg)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_stg_get(unit, vid, 1, stg));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stg_stp_init(
    int unit,
    bcm_stg_t stg)
{
    int                  dunit     = 0;
    int                  i         = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_field_def_t    fld_def;
    const char           *state[1];
    const bcmint_stg_lt_t *lt_info;
    const char *fld_name;
    const bcmint_stg_fld_t *flds;
    int fid;
    SHR_FUNC_ENTER(unit);

    /* Allocate entry container. */
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stg_lt_get(unit, BCMINT_LTSW_STG_VLAN_VFI_STG, &lt_info));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &entry_hdl));

    /* Add Default STG ID. */
    flds = lt_info->flds;
    fld_name = flds[BCMINT_LTSW_STG_FLD_VLAN_VFI_STG_ID].name;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, fld_name, stg));

    fid = BCMINT_LTSW_STG_FLD_VLAN_VFI_STG_STATE;
    SHR_IF_ERR_VERBOSE_EXIT
        (flds[fid].scalar_to_symbol(unit, BCM_STG_STP_DISABLE, &(state[0])));

    fld_name = flds[BCMINT_LTSW_STG_FLD_VLAN_VFI_STG_STATE].name;
    SHR_IF_ERR_EXIT
        (bcmi_lt_field_def_get(unit, lt_info->name, fld_name, &fld_def));
    for (i = 0; i < fld_def.depth; i++) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl,
                                                fld_name,
                                                (uint32_t)i,
                                                state, 1));
    }

    

    /* Insert VLAN STG entry. */
    SHR_IF_ERR_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void) bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stg_stp_clear(
    int unit,
    bcm_stg_t stg)
{
    int dunit = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const bcmint_stg_lt_t *lt_info;
    const char *fld_name;
    const bcmint_stg_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stg_lt_get(unit, BCMINT_LTSW_STG_VLAN_VFI_STG, &lt_info));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, lt_info->name, &entry_hdl));

    flds = lt_info->flds;
    fld_name = flds[BCMINT_LTSW_STG_FLD_VLAN_VFI_STG_ID].name;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, fld_name, stg));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void) bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stg_stp_set(
    int unit,
    bcm_stg_t stg,
    bcm_port_t port,
    int stp_state)
{
    bcm_port_t local_port = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &local_port));

    if (bcmi_ltsw_port_is_type(unit, local_port, BCMI_LTSW_PORT_TYPE_CPU) ||
        bcmi_ltsw_port_is_type(unit, local_port, BCMI_LTSW_PORT_TYPE_LB)) {
        SHR_IF_ERR_EXIT(SHR_E_PORT);
    }

    SHR_IF_ERR_EXIT
        (xgs_stg_entry_set(unit, stg, local_port, stp_state));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stg_stp_get(
    int unit,
    bcm_stg_t stg,
    bcm_port_t port,
    int *stp_state)
{
    bcm_port_t local_port = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &local_port));

    if (bcmi_ltsw_port_is_type(unit, local_port, BCMI_LTSW_PORT_TYPE_CPU) ||
        bcmi_ltsw_port_is_type(unit, local_port, BCMI_LTSW_PORT_TYPE_LB)) {
        SHR_IF_ERR_EXIT(SHR_E_PORT);
    }

    SHR_IF_ERR_EXIT
        (xgs_stg_entry_get(unit, stg, local_port, stp_state));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stg_reinit(
    int unit,
    SHR_BITDCL *stg_bmp,
    int *uidx_first,
    int *uidx_next)
{
    stg_map_recover_info_t info;
    SHR_FUNC_ENTER(unit);

    /* Recover stg usage bitmap. */
    SHR_IF_ERR_EXIT
        (stg_bmp_recover(unit, stg_bmp));

    /* Recover stg usage map. */
    info.stg_bmp = stg_bmp;
    info.uidx_first = uidx_first;
    info.uidx_next = uidx_next;
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_vlan_traverse(unit, stg_map_recover, &info));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stg_detach(
    int unit,
    bcm_stg_t stg)
{
    bcm_stg_t stg_id;
    const bcmint_stg_lt_t *lt_info;

    SHR_FUNC_ENTER(unit);

    if (bcmi_warmboot_get(unit)) {
        SHR_EXIT();
    }

    /* Reset VLAN table with default STG. */
    stg_id = stg;
    SHR_IF_ERR_EXIT
        (bcmi_ltsw_vlan_traverse(unit, xgs_stg_vlan_reset, &stg_id));

    /* Clear all entries in VLAN_STG table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stg_lt_get(unit, BCMINT_LTSW_STG_VLAN_VFI_STG, &lt_info));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, lt_info->name));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stg_port_check_set(
    int unit,
    bcm_port_t port,
    int disable,
    uint16_t flags)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_stg_init(int unit)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_stg_info_dump(int unit)
{
    return SHR_E_UNAVAIL;
}

