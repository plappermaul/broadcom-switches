/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/rate.h>

#include <bcm_int/ltsw/xgs/rate.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_RATE

/*! Storm control LT table. */
#define RATE_SC METER_STORM_CONTROLs

/*! Storm control enable LT table. */
#define RATE_SC_ENABLE METER_STORM_CONTROL_ENABLEs

/*! Storm control map LT table. */
#define RATE_SC_MAP METER_STORM_CONTROL_MAPs

/******************************************************************************
 * Private functions
 */


/*!
 * \brief Clear Rate related LT tables.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_rate_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Clear METER_STORM_CONTROL_ENABLE table. */
    SHR_IF_ERR_EXIT
        (bcmi_lt_clear(unit, RATE_SC_ENABLE));

    /* Clear METER_STORM_CONTROL table. */
    SHR_IF_ERR_EXIT
        (bcmi_lt_clear(unit, RATE_SC));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set the rate configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port number.
 * \param [in] rate_info Rate Information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_rate_set(
    int unit,
    bcm_port_t port,
    bcmint_rate_info_t *rate_info)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    int enable;
    const char *byte_mode_fids[2] ={
        "METER_RATE_KBPS",
        "BURST_SIZE_KBITS"};
    const char *pkt_mode_fids[2] = {
        "METER_RATE_PPS",
        "BURST_SIZE_PKTS"};
    const char *rate_fid, *burst_fid;
    uint64_t meter_rate = 0;
    uint32_t burst_size = 0;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(rate_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Storm control meter cfg */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, RATE_SC_ENABLE, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    /* Force to insert entry */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Set the update data */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, BYTE_MODEs, rate_info->byte_mode));

    if (rate_info->fmask & BCM_RATE_BCAST) {
        enable = 0;
        if (rate_info->flags & BCM_RATE_BCAST) {
            enable = 1;
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, BCASTs, enable));
    }

    if ((rate_info->fmask) &
        (BCM_RATE_MCAST | BCM_RATE_KNOWN_MCAST)) {
        enable = 0;
        if ((rate_info->flags) &
            (BCM_RATE_MCAST | BCM_RATE_KNOWN_MCAST)) {
            enable = 1;
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, KNOWN_L2MCs, enable));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, KNOWN_IPMCs, enable));
    }

    if ((rate_info->fmask) &
        (BCM_RATE_MCAST | BCM_RATE_UNKNOWN_MCAST)) {
        enable = 0;
        if ((rate_info->flags) &
            (BCM_RATE_MCAST | BCM_RATE_UNKNOWN_MCAST)) {
            enable = 1;
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, UNKNOWN_L2MCs, enable));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, UNKNOWN_IPMCs, enable));
    }

    if (rate_info->fmask & BCM_RATE_DLF) {
        enable = 0;
        if (rate_info->flags & BCM_RATE_DLF) {
            enable = 1;
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, DLFBCs, enable));
    }
    /* Set the update data */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT(
        bcmlt_entry_free(entry));

    /* Storm control meter */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, RATE_SC, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, METER_STORM_CONTROL_IDs,
                               rate_info->map_idx));

    /* Force to insert entry */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Set the update data */
    if (rate_info->byte_mode) {
        rate_fid = byte_mode_fids[0];
        burst_fid = byte_mode_fids[1];

        meter_rate = rate_info->meter_kbps;
        burst_size = rate_info->burst_kbits;
    } else {
        rate_fid = pkt_mode_fids[0];
        burst_fid = pkt_mode_fids[1];

        meter_rate = rate_info->meter_pps;
        burst_size = rate_info->burst_pkts;
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, rate_fid, meter_rate));

    if (burst_size != 0) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, burst_fid, burst_size));
    }

    /* Update the entry */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the rate configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port number.
 * \param [out] rate_info Rate Information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_rate_get(
    int unit,
    bcm_port_t port,
    bcmint_rate_info_t *rate_info)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    const char *byte_mode_fids[2] ={
        "METER_RATE_KBPS_OPER",
        "BURST_SIZE_KBITS_OPER"};
    const char *pkt_mode_fids[2] = {
        "METER_RATE_PPS_OPER",
        "BURST_SIZE_PKTS_OPER"};
    const char *rate_fid;
    const char *burst_fid;
    uint64_t meter_rate = 0;
    uint64_t burst_size = 0;
    int flags = 0;
    int enable, enable1, enable2, enable3;
    bool byte_mode;
    uint64_t value;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(rate_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Get Storm control meter cfg */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, RATE_SC_ENABLE, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (SHR_FAILURE(rv)) {
        if (rv == SHR_E_NOT_FOUND) {
            /*
             * Since SDK6 take register value from a per port register,
             * SDKLT doesn't insert all ports.
             */
            SHR_EXIT();
        }
        SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry, BYTE_MODEs, &value));
    byte_mode = (value == 1) ? TRUE : FALSE ;
    if (rate_info->byte_mode != byte_mode) {
        SHR_EXIT();
    }

    if (rate_info->fmask & BCM_RATE_BCAST) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, BCASTs, &value));
        enable = (value == 1) ? TRUE : FALSE ;
        if (enable) {
            flags |= BCM_RATE_BCAST;
        }
    }
    if (rate_info->fmask & BCM_RATE_MCAST) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, KNOWN_L2MCs, &value));
        enable = (value == 1) ? TRUE : FALSE;
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, KNOWN_IPMCs, &value));
        enable1 = (value == 1) ? TRUE : FALSE;
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, UNKNOWN_L2MCs, &value));
        enable2 = (value == 1) ? TRUE : FALSE;
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, UNKNOWN_IPMCs, &value));
        enable3 = (value == 1) ? TRUE : FALSE;
        if (enable | enable1 | enable2 | enable3) {
            flags |= BCM_RATE_MCAST;
        }
    }
    if (rate_info->fmask & BCM_RATE_KNOWN_MCAST) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, KNOWN_L2MCs, &value));
        enable = (value == 1) ? TRUE : FALSE;
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, KNOWN_IPMCs, &value));
        enable1 = (value == 1) ? TRUE : FALSE;
        if (enable | enable1) {
            flags |= BCM_RATE_KNOWN_MCAST;
        }
    }
    if (rate_info->fmask & BCM_RATE_UNKNOWN_MCAST) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, UNKNOWN_L2MCs, &value));
        enable = (value == 1) ? TRUE : FALSE;
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, UNKNOWN_IPMCs, &value));
        enable1 = (value == 1) ? TRUE : FALSE;
        if (enable | enable1) {
            flags |= BCM_RATE_UNKNOWN_MCAST;
        }
    }
    if (rate_info->fmask & BCM_RATE_DLF) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, DLFBCs, &value));
        enable = (value == 1) ? TRUE : FALSE;
        if (enable) {
            flags |= BCM_RATE_DLF;
        }
    }

    rate_info->flags = flags;

    /* Storm control meter */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, RATE_SC, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, METER_STORM_CONTROL_IDs,
                               rate_info->map_idx));

    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    if (SHR_FAILURE(rv)) {
        if (rv == SHR_E_NOT_FOUND) {
            /*
             * Since SDK6 take register value from a per port register,
             * SDKLT doesn't insert all ports.
             */
            SHR_EXIT();
        }
        SHR_ERR_EXIT(rv);
    }

    if (rate_info->byte_mode) {
        rate_fid = byte_mode_fids[0];
        burst_fid = byte_mode_fids[1];

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, rate_fid, &meter_rate));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, burst_fid, &burst_size));

        rate_info->meter_kbps = meter_rate;
        rate_info->burst_kbits = burst_size;
    } else {
        rate_fid = pkt_mode_fids[0];
        burst_fid = pkt_mode_fids[1];

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, rate_fid, &meter_rate));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_get(entry, burst_fid, &burst_size));

        rate_info->meter_pps = meter_rate;
        rate_info->burst_pkts = burst_size;
    }

exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the rate device configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] dev_info Device Configuration.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_rate_dev_set(
    int unit,
    bcmint_rate_dev_info_t *dev_info)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(dev_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Storm control meter */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, RATE_SC_MAP, &entry));

    /* Force to insert entry */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);

    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Set the data */
    if (dev_info->map_supported[LT_RATE_MAP_BCAST]) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, BCAST_METER_IDs,
                                   dev_info->map_idx[LT_RATE_MAP_BCAST]));
    }

    if (dev_info->map_supported[LT_RATE_MAP_KNOWN_L2MC]) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, KNOWN_L2MC_METER_IDs,
                                   dev_info->map_idx[LT_RATE_MAP_KNOWN_L2MC]));
    }

    if (dev_info->map_supported[LT_RATE_MAP_UNKNOWN_L2MC]) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(
                entry, UNKNOWN_L2MC_METER_IDs,
                dev_info->map_idx[LT_RATE_MAP_UNKNOWN_L2MC]));
    }

    if (dev_info->map_supported[LT_RATE_MAP_KNOWN_IPMC]) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry, KNOWN_IPMC_METER_IDs,
                                   dev_info->map_idx[LT_RATE_MAP_KNOWN_IPMC]));
    }

    if (dev_info->map_supported[LT_RATE_MAP_UNKNOWN_IPMC]) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(
                entry, UNKNOWN_IPMC_METER_IDs,
                dev_info->map_idx[LT_RATE_MAP_UNKNOWN_IPMC]));
    }

    if (dev_info->map_supported[LT_RATE_MAP_DLF]) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(
                entry, DLF_METER_IDs,
                dev_info->map_idx[LT_RATE_MAP_DLF]));
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();

}

/*!
 * \brief Get the rate device configuration.
 *
 * \param [in] unit Unit Number.
 * \param [out] dev_info Device Configuration.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_rate_dev_get(
    int unit,
    bcmint_rate_dev_info_t *dev_info)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    uint64_t idx;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(dev_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Get storm control LT status */
    rv =  bcmlt_entry_allocate(dunit, RATE_SC_MAP, &entry);
    if (rv == SHR_E_PARAM) {
        /* The LT doesn't exist, not support storm control */
        for (idx = LT_RATE_MAP_BCAST;
             idx < LT_RATE_MAP_NUM;
             idx++) {
            dev_info->map_supported[idx] = FALSE;
        }
        SHR_EXIT();
    } else if (rv == SHR_E_NONE) {
        /* The LT exist, support storm control and check each packet types */

        /* Force to insert entry */
        rv = bcmlt_entry_commit(entry,
                                BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL);

        if (rv != SHR_E_NONE &&
            rv != SHR_E_EXISTS) {
            SHR_ERR_EXIT(rv);
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry,
                                BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));
        rv = bcmlt_entry_field_get(entry, BCAST_METER_IDs, &idx);
        if (rv == SHR_E_NONE) {
            dev_info->map_idx[LT_RATE_MAP_BCAST] = idx;
            dev_info->map_supported[LT_RATE_MAP_BCAST] = TRUE;
        }

        rv = bcmlt_entry_field_get(entry, KNOWN_L2MC_METER_IDs, &idx);
        if (rv == SHR_E_NONE) {
            dev_info->map_idx[LT_RATE_MAP_KNOWN_L2MC] = idx;
            dev_info->map_supported[LT_RATE_MAP_KNOWN_L2MC] = TRUE;
        }

        rv = bcmlt_entry_field_get(entry, UNKNOWN_L2MC_METER_IDs, &idx);
        if (rv == SHR_E_NONE) {
            dev_info->map_idx[LT_RATE_MAP_UNKNOWN_L2MC] = idx;
            dev_info->map_supported[LT_RATE_MAP_UNKNOWN_L2MC] = TRUE;
        }

        rv = bcmlt_entry_field_get(entry, KNOWN_IPMC_METER_IDs, &idx);
        if (rv == SHR_E_NONE) {
            dev_info->map_idx[LT_RATE_MAP_KNOWN_IPMC] = idx;
            dev_info->map_supported[LT_RATE_MAP_KNOWN_IPMC] = TRUE;
        }

        rv = bcmlt_entry_field_get(entry, UNKNOWN_IPMC_METER_IDs, &idx);
        if (rv == SHR_E_NONE) {
            dev_info->map_idx[LT_RATE_MAP_UNKNOWN_IPMC] = idx;
            dev_info->map_supported[LT_RATE_MAP_UNKNOWN_IPMC] = TRUE;
        }

        rv = bcmlt_entry_field_get(entry, DLF_METER_IDs, &idx);
        if (rv == SHR_E_NONE) {
            dev_info->map_idx[LT_RATE_MAP_DLF] = idx;
            dev_info->map_supported[LT_RATE_MAP_DLF] = TRUE;
        }
    }

exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Set Meter/Rate control with overhead on wire accounted for per packet.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] value Number of bytes to adjust.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_rate_meter_adjust_set(
    int unit,
    bcm_port_t port,
    int value)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    uint64_t val;

    SHR_FUNC_ENTER(unit);

    if (value < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, METER_FP_CONTROLs, &entry));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Set the data. */
    val = value;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, BYTE_COUNT_INGs, val));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Meter/Rate control with overhead on wire accounted for per packet.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] value Number of bytes to adjust.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_rate_meter_adjust_get(
    int unit,
    bcm_port_t port,
    int *value)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    uint64_t val;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(value, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, METER_FP_CONTROLs, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Get the data. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry, BYTE_COUNT_INGs, &val));
    *value = val;

exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Set Meter/Rate control with overhead on wire accounted for per packet
 * for EFP.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] value Number of bytes to adjust.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_rate_shaper_adjust_set(
    int unit,
    bcm_port_t port,
    int value)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    uint64_t val;

    SHR_FUNC_ENTER(unit);

    if (value < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TM_SHAPER_PORTs, &entry));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Set the data. */
    val = value;
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, INTER_FRAME_GAP_BYTEs, val));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));
exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get Meter/Rate control with overhead on wire accounted for per packet
 * for EFP.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port Number.
 * \param [in] value Number of bytes to adjust.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_rate_shaper_adjust_get(
    int unit,
    bcm_port_t port,
    int *value)
{
    int dunit = 0, rv;
    bcmlt_entry_handle_t entry = BCMLT_INVALID_HDL;
    uint64_t val;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(value, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TM_SHAPER_PORTs, &entry));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry, PORT_IDs, port));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    if (rv != SHR_E_NONE &&
        rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }

    /* Get the data. */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry, INTER_FRAME_GAP_BYTEs, &val));
    *value = val;

exit:
    if (BCMLT_INVALID_HDL != entry) {
        (void)bcmlt_entry_free(entry);
    }

    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_rate_clear(int unit)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xgs_rate_clear(unit));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_rate_set(
    int unit,
    bcm_port_t port,
    bcmint_rate_info_t *rate_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xgs_rate_set(unit, port, rate_info));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_rate_get(
    int unit,
    bcm_port_t port,
    bcmint_rate_info_t *rate_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xgs_rate_get(unit, port, rate_info));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_rate_dev_set(
    int unit,
    bcmint_rate_dev_info_t *dev_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xgs_rate_dev_set(unit, dev_info));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_rate_dev_get(
    int unit,
    bcmint_rate_dev_info_t *dev_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xgs_rate_dev_get(unit, dev_info));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_rate_meter_adjust_set(
    int unit,
    bcm_port_t port,
    int value)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xgs_rate_meter_adjust_set(unit, port, value));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_rate_meter_adjust_get(
    int unit,
    bcm_port_t port,
    int *value)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xgs_rate_meter_adjust_get(unit, port, value));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_rate_shaper_adjust_set(
    int unit,
    bcm_port_t port,
    int value)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xgs_rate_shaper_adjust_set(unit, port, value));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_rate_shaper_adjust_get(
    int unit,
    bcm_port_t port,
    int *value)
{
    SHR_FUNC_ENTER(unit);
    SHR_IF_ERR_EXIT
        (ltsw_xgs_rate_shaper_adjust_get(unit, port, value));
exit:
    SHR_FUNC_EXIT();
}

