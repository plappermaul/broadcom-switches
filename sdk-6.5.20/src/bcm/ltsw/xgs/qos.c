/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/qos.h>
#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/xgs/qos.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/qos_int.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/vlan.h>

#include <shr/shr_bitop.h>
#include <sal/sal_types.h>
#include <bsl/bsl.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>
#include <bcmlt/bcmlt.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_QOS

/*! Ingress map type count. */
#define QOS_ING_MAP_TYPE_COUNT 3

/*! QoS map shift. */
#define QOS_MAP_SHIFT 16

/*! QoS map id mask. */
#define QOS_MAP_ID_MASK ((1 << QOS_MAP_SHIFT) - 1)

/*!
 * \brief HA sub component id. Note that the value of each macro cannot be changed.
 */
/*! L2 ingress map used bitmap. */
#define QOS_SUBCOMPID_L2_ING_USED_BMP 0

/*! L3 ingress map used bitmap. */
#define QOS_SUBCOMPID_L3_ING_USED_BMP 1

/*! MPLS ingress map used bitmap. */
#define QOS_SUBCOMPID_MPLS_ING_USED_BMP 2

/*! L2 egress map used bitmap. */
#define QOS_SUBCOMPID_L2_EGR_USED_BMP 3

/*! L3 egress map used bitmap. */
#define QOS_SUBCOMPID_L3_EGR_USED_BMP 4

/*! MPLS egress map used bitmap. */
#define QOS_SUBCOMPID_MPLS_EGR_USED_BMP 5

/*! MPLS egress L2 map used bitmap. */
#define QOS_SUBCOMPID_MPLS_EGR_L2_USED_BMP 6

/*! Port mapping with egress L2 map_id. */
#define QOS_SUBCOMPID_PORT_EGR_L2_MAPPING 12

/*!
 * \brief QoS map type. Note every new enum must be put following the last valid one.
 */
typedef enum qos_xgs_map_type_s {

    /*! Map dot1p pri/cfi to internal priority/cng. */
    QoSMapTypeL2Ingress = 0,

    /*! Map DSCP of IP packet to internal priority/cng. */
    QoSMapTypeL3Ingress = 1,

    /*! Map Exp of MPLS packet to internal priority/cng. */
    QoSMapTypeMplsIngress = 2,

    /*! Map internal priority/cng to dot1p pri/cfi. */
    QoSMapTypeL2Egress = 3,

    /*! Map internal priority/cng to DSCP of IP packet. */
    QoSMapTypeL3Egress = 4,

    /*! Map internal priority/cng to Exp of MPLS packet. */
    QoSMapTypeMplsEgress = 5,

    /*! Map EXP to dot1p pri/cfi of MPLS packet. */
    QoSMapTypeMplsEgressL2 = 6,

    /*! The count of map type, must be the last. */
    QoSMapTypeCount = 7

} qos_xgs_map_type_t;

#define QOS_XGS_MAP_TYPE_STR \
{ \
    "L2Ingress", \
    "L3Ingress", \
    "MplsIngress", \
    "L2Egress", \
    "L3Egress", \
    "MplsEgress", \
    "MplsEgressL2" \
}

/*!
 * \brief QoS configuration data structure.
 */
typedef struct qos_cfg_s {

    /*! Used bitmap for QoS map id. */
    SHR_BITDCL *bmp[QoSMapTypeCount];

    /*! Mapping of map_id and port_tab. */
    uint32_t *egr_port_map;

} qos_cfg_t;

/*!
 * \brief QoS map set size.
 */
/*! Entry size in one L2 map set. */
#define QOS_MAP_SET_SIZE_L2 16

/*! Entry size in one L3 map set. */
#define QOS_MAP_SET_SIZE_L3 64

/*! Entry size in one MPLS map set. */
#define QOS_MAP_SET_SIZE_MPLS 8

/*! QoS remark set size(int_pri, cng). */
#define QOS_REMARK_INT_PRI_CNG_SET_SIZE 64

/*!
 * \brief Packet QoS field mask.
 */
/*! Packet priority mask. */
#define QOS_PKT_PRI_MASK 0x7

/*! Packet CFI mask. */
#define QOS_PKT_CFI_MASK 0x1

/*! Packet DSCP mask. */
#define QOS_PKT_DSCP_MASK 0x3f

/*! Packet EXP mask. */
#define QOS_PKT_EXP_MASK 0x7

/*! QoS internal priority mask. */
#define QOS_INT_PRI_MASK 0xf

/*! QoS internal CNG mask. */
#define QOS_INT_CNG_MASK 0x3

/******************************************************************************
 * Private functions
 */


static qos_cfg_t qos_cfg[BCM_MAX_NUM_UNITS];

/* QoS config. */
#define QOS_CFG(unit) (&qos_cfg[unit])

/* QoS map used bitmap. */
#define QOS_MAP_BMP(unit, type) \
            (QOS_CFG(unit)->bmp[type])

/* Get QoS map used bitmap. */
#define QOS_MAP_BMP_USED_GET(unit, type, id) \
            (SHR_BITGET(QOS_MAP_BMP(unit, type), id))

/* Set QoS map used bitmap. */
#define QOS_MAP_BMP_USED_SET(unit, type, id) \
            (SHR_BITSET(QOS_MAP_BMP(unit, type), id))

/* Clear QoS map used bitmap. */
#define QOS_MAP_BMP_USED_CLR(unit, type, id) \
            (SHR_BITCLR(QOS_MAP_BMP(unit, type), id))

static const char* qos_tab_map[QoSMapTypeCount] = {
    [QoSMapTypeL2Ingress]         = PHB_ING_L2_TAGGED_TO_INT_PRIs,
    [QoSMapTypeL3Ingress]         = PHB_ING_IP_DSCP_TO_INT_PRI_REMAPs,
    [QoSMapTypeMplsIngress]       = PHB_ING_MPLS_EXP_TO_INT_PRIs,
    [QoSMapTypeL2Egress]          = PHB_EGR_L2_INT_PRI_TO_OTAGs,
    [QoSMapTypeL3Egress]          = PHB_EGR_IP_INT_PRI_TO_DSCPs,
    [QoSMapTypeMplsEgress]        = PHB_EGR_MPLS_INT_PRI_TO_VPN_EXPs,
    [QoSMapTypeMplsEgressL2]      = PHB_EGR_MPLS_EXP_TO_L2_OTAGs,
};

static const int qos_chunk_size[QoSMapTypeCount] = {
    [QoSMapTypeL2Ingress]         = QOS_MAP_SET_SIZE_L2,
    [QoSMapTypeL3Ingress]         = QOS_MAP_SET_SIZE_L3,
    [QoSMapTypeMplsIngress]       = QOS_MAP_SET_SIZE_MPLS,
    [QoSMapTypeL2Egress]          = QOS_REMARK_INT_PRI_CNG_SET_SIZE,
    [QoSMapTypeL3Egress]          = QOS_REMARK_INT_PRI_CNG_SET_SIZE,
    [QoSMapTypeMplsEgress]        = QOS_REMARK_INT_PRI_CNG_SET_SIZE,
    [QoSMapTypeMplsEgressL2]      = QOS_MAP_SET_SIZE_MPLS,
};

typedef struct qos_switch_control_s {
    const char *ltname;
    const char *field_str;
} qos_switch_control_t;

static qos_switch_control_t qos_sc_info[bcmiQosControlCount] =
{
    [bcmiQosControlLayeredQoSResolution] = {PHB_CONTROLs, DSCP_PRESERVE_OVERRIDEs},
};

/* All egress tables. */
#define QOS_EGRESS_TABLE_ALL \
            PHB_EGR_PORT_INT_PRI_TO_L2_OTAGs, \
            PHB_EGR_L2_INT_PRI_TO_OTAGs, \
            PHB_EGR_IP_INT_PRI_TO_DSCPs, \
            PHB_EGR_MPLS_EXP_TO_L2_OTAGs, \
            PHB_EGR_MPLS_INT_PRI_TO_L2_OTAGs, \
            PHB_EGR_MPLS_INT_PRI_TO_LSP_EXPs, \
            PHB_EGR_MPLS_INT_PRI_TO_TRANSIT_EXPs, \
            PHB_EGR_MPLS_INT_PRI_TO_VPN_EXPs

/*! QoS egress table number. */
#define QOS_EGRESS_TABLE_NUM 8

/* All ingress tables. */
#define QOS_INGRESS_TABLE_ALL \
            PHB_ING_L2_TAGGED_TO_INT_PRIs, \
            PHB_ING_L2_UNTAGGED_TO_INT_PRIs, \
            PHB_ING_L2_OTAG_REMAPs, \
            PHB_ING_IP_DSCP_TO_INT_PRI_REMAPs, \
            PHB_ING_MPLS_EXP_TO_INT_PRIs

/*! QoS ingress table number. */
#define QOS_INGRESS_TABLE_NUM 5

/* QoS map is ingress map type. */
#define QOS_MAP_IS_ING_TYPE(type) \
            (type == bcmiQosMapTypeL2Ingress || \
             type == bcmiQosMapTypeL3Ingress || \
             type == bcmiQosMapTypeMplsIngress)

/* QoS map is egress map type. */
#define QOS_MAP_IS_EGR_TYPE(type) \
            (type == bcmiQosMapTypeL2Egress || \
             type == bcmiQosMapTypeL3Egress || \
             type == bcmiQosMapTypeMplsEgress || \
             type == bcmiQosMapTypeMplsEgressL2)

/* MAP ID that is enabled during init stage. */
#define MAP_ID_CREATED_IN_INIT(id, type) ((((type) == QoSMapTypeL2Ingress) || \
    ((type) == QoSMapTypeL3Ingress) || ((type) == QoSMapTypeL2Egress) || \
    ((type) == QoSMapTypeL3Egress)) && \
    ((id) == 0))

#define MAP_CREATED_IN_INIT_NUM 4

#define MAX_PORT_NUM(unit) bcmi_ltsw_dev_logic_port_num(unit)

#define INVALID_MAP_ID -1

/*!
 * \brief Initialize QoS database.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_db_init(int unit)
{
    qos_cfg_t *qos_db = NULL;
    void *ptr[QoSMapTypeCount];
    void *ptr_1 = NULL;
    int i, map_sz;
    int warm = bcmi_warmboot_get(unit);
    uint32_t alloc_size = 0, req_size = 0, size = 0;

    SHR_FUNC_ENTER(unit);

    qos_db = QOS_CFG(unit);

    /* Init local variable. */
    for (i = 0; i < QoSMapTypeCount; i++) {
        ptr[i] = NULL;
    }

    /* Init QoS map used bitmap. */
    for (i = 0; i < QoSMapTypeCount; i++) {

        /* Allocate HA memory for used bitmap. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_capacity_get(unit, qos_tab_map[i], &size));
        map_sz = size / qos_chunk_size[i];
        req_size = SHR_BITALLOCSIZE(map_sz);
        alloc_size = req_size;
        ptr[i] = bcmi_ltsw_ha_mem_alloc(unit,
                                        BCMI_HA_COMP_ID_QOS,
                                        QOS_SUBCOMPID_L2_ING_USED_BMP + i,
                                        "bcmQosL2IngUsedBmp",
                                        &alloc_size);

        SHR_NULL_CHECK(ptr[i], SHR_E_MEMORY);
        SHR_IF_ERR_VERBOSE_EXIT
            ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);
        qos_db->bmp[i] = ptr[i];

        if (!warm) {
            sal_memset(ptr[i], 0, alloc_size);
        }
    }

    req_size = MAX_PORT_NUM(unit) * sizeof(uint32_t);
    alloc_size = req_size;
    ptr_1 = bcmi_ltsw_ha_mem_alloc(unit,
                                   BCMI_HA_COMP_ID_QOS,
                                   QOS_SUBCOMPID_PORT_EGR_L2_MAPPING,
                                   "bcmQosPortEgrL2Mapping",
                                   &alloc_size);
    SHR_NULL_CHECK(ptr_1, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT
        ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);
    qos_db->egr_port_map = ptr_1;
    if (!warm) {
        sal_memset(ptr_1, INVALID_MAP_ID, alloc_size);
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (!warm) {
            for (i = 0; i < QoSMapTypeCount; i++) {
                if (ptr[i] != NULL) {
                    (void)bcmi_ltsw_ha_mem_free(unit, ptr[i]);
                    qos_db->bmp[i] = NULL;
                }
            }
            if (ptr_1 != NULL) {
                (void)bcmi_ltsw_ha_mem_free(unit, ptr_1);
                qos_db->egr_port_map = NULL;
            }
        }
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear all QoS tables.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_table_clear_all(int unit)
{
    int i;
    const char *ingress[] = {QOS_INGRESS_TABLE_ALL};
    const char *egress[] = {QOS_EGRESS_TABLE_ALL};

    SHR_FUNC_ENTER(unit);

    /* Clear ingress QoS map table. */
    for (i = 0; i < QOS_INGRESS_TABLE_NUM; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, ingress[i]));
    }

    /* Clear egress QoS map table. */
    for (i = 0; i < QOS_EGRESS_TABLE_NUM; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, egress[i]));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a entry into ingress phb table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_ingress_table_add(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int int_cng, id, rv;
    bcm_qos_map_t *map_tmp;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    map_tmp = map->entry;
    id = index;

    switch (map->type) {
        case bcmiQosMapTypeL2Ingress:
            if (map->flags & BCM_QOS_MAP_L2_UNTAGGED) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_L2_UNTAGGED_TO_INT_PRIs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_ING_L2_UNTAGGED_TO_INT_PRI_IDs, id));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                           map_tmp->int_pri));
                int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Set a entry. */
                rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                        BCMLT_PRIORITY_NORMAL);
                if (rv == SHR_E_NOT_FOUND) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT,
                                            BCMLT_PRIORITY_NORMAL));
                } else {
                    SHR_IF_ERR_VERBOSE_EXIT(rv);
                }
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_L2_TAGGED_TO_INT_PRIs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_ING_L2_TAGGED_TO_INT_PRI_IDs, id));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, PRIs,
                                           map_tmp->pkt_pri));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CFIs,
                                           map_tmp->pkt_cfi));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                           map_tmp->int_pri));
                int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Set a entry. */
                rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                        BCMLT_PRIORITY_NORMAL);
                if (rv == SHR_E_NOT_FOUND) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT,
                                            BCMLT_PRIORITY_NORMAL));
                } else {
                    SHR_IF_ERR_VERBOSE_EXIT(rv);
                }
            }
            break;
        case bcmiQosMapTypeL3Ingress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_ING_IP_DSCP_TO_INT_PRI_REMAPs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DSCPs, map_tmp->dscp));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, NEW_DSCPs, map_tmp->dscp));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                                       INT_PRIs, map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
            /* Set a entry. */
            rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL);
            if (rv == SHR_E_NOT_FOUND) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT,
                                        BCMLT_PRIORITY_NORMAL));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            break;
        case bcmiQosMapTypeMplsIngress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_ING_MPLS_EXP_TO_INT_PRIs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_ING_MPLS_EXP_TO_INT_PRI_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, EXPs, map_tmp->exp));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DSCPs, map_tmp->dscp));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                       map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
            /* Set a entry. */
            rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL);
            if (rv == SHR_E_NOT_FOUND) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT,
                                        BCMLT_PRIORITY_NORMAL));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            break;
        default:
            SHR_ERR_EXIT(BCM_E_UNAVAIL);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a set of entries into ingress phb table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_ingress_table_add_array(int unit, int index,
                                bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, int_cng, id, pkt_pri, pkt_cfi, dscp, exp;
    bcm_qos_map_t *map_tmp;
    int set_sz, tmp_sz;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    bcmlt_opcode_t op_code;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    set_sz = *map->count;
    map_tmp = map->entry;
    id = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    if (map->flags & BCM_QOS_MAP_REPLACE) {
        op_code = BCMLT_OPCODE_UPDATE;
    } else {
        op_code = BCMLT_OPCODE_INSERT;
    }

    switch (map->type) {
        case bcmiQosMapTypeL2Ingress:
            /* UNTAGGED share same sw structure with TAGGED but with diff set_sz. */
            tmp_sz = 1;
            for (i = 0; i < tmp_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_L2_UNTAGGED_TO_INT_PRIs, &entry_hdl));
                /* Caculating the index for the table. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_ING_L2_UNTAGGED_TO_INT_PRI_IDs, id));
                /* Configure field value.*/
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                           map_tmp->int_pri));
                int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 op_code,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
                id += 1;
                map_tmp++;
            }

            id = index;
            map_tmp = map->entry;
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_L2_TAGGED_TO_INT_PRIs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_ING_L2_TAGGED_TO_INT_PRI_IDs, id));
                /* Caculating the index for the table. */
                pkt_pri = (i >> 1) & QOS_PKT_PRI_MASK;
                pkt_cfi = i & QOS_PKT_CFI_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, PRIs, pkt_pri));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CFIs, pkt_cfi));
                /* Configure field value.*/
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                           map_tmp->int_pri));
                int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 op_code,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
                map_tmp++;
            }
            break;
        case bcmiQosMapTypeL3Ingress:
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_IP_DSCP_TO_INT_PRI_REMAPs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs, id));
                /* Caculating the index for the table. */
                dscp = i & QOS_PKT_DSCP_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DSCPs, dscp));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, NEW_DSCPs, dscp));
                /* Configure field value.*/
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                                           INT_PRIs, map_tmp->int_pri));
                int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 op_code,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
                map_tmp++;
            }
            break;
        case bcmiQosMapTypeMplsIngress:
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_MPLS_EXP_TO_INT_PRIs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_ING_MPLS_EXP_TO_INT_PRI_IDs, id));
                /* Caculating the index for the table. */
                exp = i & QOS_PKT_EXP_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, EXPs, exp));
                /* Configure field value.*/
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DSCPs, map_tmp->dscp));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                           map_tmp->int_pri));
                int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 op_code,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
                map_tmp++;
            }
            break;
        default:
            SHR_ERR_EXIT(BCM_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a entry into egress table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_table_add(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int int_cng, id, rv;
    bcm_qos_map_t *map_tmp;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    map_tmp = map->entry;
    id = index;

    switch (map->type) {
        case bcmiQosMapTypeL2Egress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH,
                                            &trans_hdl));

            /* For PT EGR_MPLS_PRI_MAPPING. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_MPLS_INT_PRI_TO_L2_OTAGs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                       map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, PRIs,
                                       map_tmp->pkt_pri));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CFIs,
                                       map_tmp->pkt_cfi));
            /* Add entry into transaction. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl,
                                             BCMLT_OPCODE_UPDATE,
                                             entry_hdl));
            entry_hdl = BCMLT_INVALID_HDL;

            /*  For PT EGR_MPLS_EXP_MAPPING_1 */
            map_tmp = map->entry;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_L2_INT_PRI_TO_OTAGs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_EGR_L2_INT_PRI_TO_OTAG_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                       map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, PRIs,
                                       map_tmp->pkt_pri));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CFIs,
                                       map_tmp->pkt_cfi));
            /* Add entry into transaction. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl,
                                             BCMLT_OPCODE_UPDATE,
                                             entry_hdl));
            entry_hdl = BCMLT_INVALID_HDL;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_transaction_commit(unit, trans_hdl,
                                            BCMLT_PRIORITY_NORMAL));
            break;
        case bcmiQosMapTypeL3Egress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_IP_INT_PRI_TO_DSCPs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_EGR_IP_INT_PRI_TO_DSCP_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                                       INT_PRIs, map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DSCPs, map_tmp->dscp));
            /* Set a entry. */
            rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL);
            if (rv == SHR_E_NOT_FOUND) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT,
                                        BCMLT_PRIORITY_NORMAL));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            break;
        case bcmiQosMapTypeMplsEgress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH,
                                            &trans_hdl));

            /*  For PT EGR_MPLS_EXP_MAPPING_1 */
            map_tmp = map->entry;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_MPLS_INT_PRI_TO_VPN_EXPs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                       map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, MPLS_EXPs, map_tmp->exp));
            /* Add entry into transaction. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl,
                                             BCMLT_OPCODE_UPDATE,
                                             entry_hdl));
            entry_hdl = BCMLT_INVALID_HDL;

            /*  For PT EGR_MPLS_EXP_MAPPING_2 */
            map_tmp = map->entry;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_MPLS_INT_PRI_TO_LSP_EXPs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                       map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, MPLS_EXPs, map_tmp->exp));
            /* Add entry into transaction. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl,
                                             BCMLT_OPCODE_UPDATE,
                                             entry_hdl));
            entry_hdl = BCMLT_INVALID_HDL;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_transaction_commit(unit, trans_hdl,
                                            BCMLT_PRIORITY_NORMAL));
            break;
        case bcmiQosMapTypeMplsEgressL2:
            /*  For PT EGR_MPLS_EXP_PRI_MAPPING */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_MPLS_EXP_TO_L2_OTAGs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_EGR_MPLS_EXP_TO_L2_OTAG_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, EXPs,
                                       map_tmp->exp));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, PRIs,
                                       map_tmp->pkt_pri));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CFIs,
                                       map_tmp->pkt_cfi));
            /* Set a entry. */
            rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL);
            if (rv == SHR_E_NOT_FOUND) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT,
                                        BCMLT_PRIORITY_NORMAL));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            break;
        default:
            SHR_ERR_EXIT(BCM_E_UNAVAIL);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a set of entries into egress table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_table_add_array(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, int_cng, id, color, int_pri, exp;
    bcm_qos_map_t *map_tmp;
    int set_sz;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    bcmlt_opcode_t op_code;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    set_sz = *map->count;
    map_tmp = map->entry;
    id = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    if (map->flags & BCM_QOS_MAP_REPLACE) {
        op_code = BCMLT_OPCODE_UPDATE;
    } else {
        op_code = BCMLT_OPCODE_INSERT;
    }

    switch (map->type) {
        case bcmiQosMapTypeL2Egress:
            /*  For PT EGR_MPLS_PRI_MAPPING */
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_MPLS_INT_PRI_TO_L2_OTAGs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG_IDs, id));
                /* Caculating the index for the table. */
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Configure field value.*/
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, PRIs,
                                           map_tmp->pkt_pri));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CFIs,
                                           map_tmp->pkt_cfi));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 op_code,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
                map_tmp++;
            }
            /*  For PT EGR_MPLS_EXP_MAPPING_1 */
            map_tmp = map->entry;
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_L2_INT_PRI_TO_OTAGs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                                           PHB_EGR_L2_INT_PRI_TO_OTAG_IDs, id));
                /* Caculating the index for the table. */
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Configure field value.*/
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, PRIs,
                                           map_tmp->pkt_pri));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CFIs,
                                           map_tmp->pkt_cfi));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 op_code,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
                map_tmp++;
            }
            break;
        case bcmiQosMapTypeL3Egress:
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_IP_INT_PRI_TO_DSCPs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_EGR_IP_INT_PRI_TO_DSCP_IDs, id));
                /* Caculating the index for the table. */
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Configure field value.*/
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DSCPs, map_tmp->dscp));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 op_code,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
                map_tmp++;
            }
            break;
        case bcmiQosMapTypeMplsEgress:
            /*  For PT EGR_MPLS_EXP_MAPPING_1 */
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_MPLS_INT_PRI_TO_VPN_EXPs,
                        &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl,
                        PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP_IDs, id));
                /* Caculating the index for the table. */
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Configure field value.*/
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, MPLS_EXPs,
                                           map_tmp->exp));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 op_code,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
                map_tmp++;
            }
            /*  For PT EGR_MPLS_EXP_MAPPING_2 */
            map_tmp = map->entry;
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_MPLS_INT_PRI_TO_LSP_EXPs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP_IDs, id));
                /* Caculating the index for the table. */
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Configure field value.*/
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, MPLS_EXPs, map_tmp->exp));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 op_code,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
                map_tmp++;
            }
            break;
        case bcmiQosMapTypeMplsEgressL2:
            /*  For PT EGR_MPLS_EXP_PRI_MAPPING */
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_MPLS_EXP_TO_L2_OTAGs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_EGR_MPLS_EXP_TO_L2_OTAG_IDs, id));
                /* Caculating the index for the table. */
                exp = i & QOS_PKT_EXP_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, EXPs, exp));
                /* Configure field value.*/
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, PRIs,
                                           map_tmp->pkt_pri));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CFIs,
                                           map_tmp->pkt_cfi));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 op_code,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
                map_tmp++;
            }
            break;
        default:
            SHR_ERR_EXIT(BCM_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Hold a map id.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] id Map id.
 */
static void
qos_map_id_hold(int unit, qos_xgs_map_type_t type, int id)
{
    if (type >= QoSMapTypeCount) {
        return;
    }
    QOS_MAP_BMP_USED_SET(unit, type, id);
    return;
}

/*!
 * \brief Free a map id.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in] id Map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_id_free(int unit, qos_xgs_map_type_t type, int id)
{
    SHR_FUNC_ENTER(unit);
    if (type >= QoSMapTypeCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    QOS_MAP_BMP_USED_CLR(unit, type, id);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add map table entry or entries.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_table_add(int unit, int index, bcmint_qos_map_t *map)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);

    if (*map->count <= 0) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (*map->count == 1) {
        if (QOS_MAP_IS_ING_TYPE(map->type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_ingress_table_add(unit, index, map));
        } else if (QOS_MAP_IS_EGR_TYPE(map->type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_egress_table_add(unit, index, map));
        }
    }else {
        if (QOS_MAP_IS_ING_TYPE(map->type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_ingress_table_add_array(unit, index, map));
        } else if (QOS_MAP_IS_EGR_TYPE(map->type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_egress_table_add_array(unit, index, map));
        }
    }


exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add L2 default mapping table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_l2_default_add(int unit)
{
    int alloc_size, set_size, index, i, pri, cfi;
    bcmint_qos_map_t map;
    bcm_qos_map_t *qos_map = NULL;

    SHR_FUNC_ENTER(unit);

    set_size = QOS_MAP_SET_SIZE_L2;
    alloc_size = set_size * sizeof(bcm_qos_map_t);
    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);

    /* Ing L2 entry Init, untagged & tagged packet. */
    map.type = bcmiQosMapTypeL2Ingress;
    
    map.flags = BCM_QOS_MAP_L2 | BCM_QOS_MAP_INGRESS;
    map.count = &set_size;
    qos_map = map.entry;
    /* Program default entries. */
    for (i = 0; i < set_size; i++) {
        qos_map->pkt_pri = (i >> 1) & QOS_PKT_PRI_MASK;
        qos_map->pkt_cfi = i & QOS_PKT_CFI_MASK;
        qos_map->int_pri = qos_map->pkt_pri;
        qos_map->color = qos_map->pkt_cfi;
        qos_map++;
    }
    index = 0;
    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map));

    qos_map_id_hold(unit, QoSMapTypeL2Ingress, index);

    /* Egr L2 entry setting. */
    SHR_FREE(map.entry);
    set_size = QOS_REMARK_INT_PRI_CNG_SET_SIZE;
    alloc_size = set_size * sizeof(bcm_qos_map_t);
    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);

    map.type = bcmiQosMapTypeL2Egress;
    map.flags = BCM_QOS_MAP_L2 | BCM_QOS_MAP_EGRESS;
    map.count = &set_size;
    qos_map = map.entry;
    /* Program default entries. */
    pri = QOS_PKT_PRI_MASK;
    cfi = QOS_PKT_CFI_MASK;
    for (i = 0; i < set_size; i++) {
        qos_map->int_pri = (i >> 2) & QOS_INT_PRI_MASK;
        qos_map->color = i & QOS_INT_CNG_MASK;
        qos_map->pkt_pri = qos_map->int_pri > pri ? pri : qos_map->int_pri;
        qos_map->pkt_cfi = qos_map->color > cfi ? cfi : qos_map->color;
        qos_map++;
    }
    index = 0;
    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map));

    qos_map_id_hold(unit, QoSMapTypeL2Egress, index);

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add L2 remap default mapping table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_l2_remap_default_add(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, id, pri, cfi;
    int set_sz;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    set_sz = QOS_MAP_SET_SIZE_L2;
    id = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (i = 0; i < set_sz; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(
                dunit, PHB_ING_L2_OTAG_REMAPs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PHB_ING_L2_OTAG_REMAP_IDs, id));
        pri = (i >> 1) & QOS_PKT_PRI_MASK;
        cfi = i & QOS_PKT_CFI_MASK;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PRIs, pri));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CFIs, cfi));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, NEW_PRIs, pri));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, NEW_CFIs, cfi));

        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl,
                                         BCMLT_OPCODE_INSERT,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add L3 default mapping table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_l3_default_add(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    int alloc_size, set_size, index, i, dscp;
    bcmint_qos_map_t map;
    bcm_qos_map_t *qos_map = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    /* Ing L3 entry setting. */
    set_size = QOS_MAP_SET_SIZE_L3;
    index = 0;
    for (i = 0; i < set_size; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(
                dunit, PHB_ING_IP_DSCP_TO_INT_PRI_REMAPs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(
                entry_hdl, PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs, index));
        /* Caculating the index for the table. */
        dscp = i & QOS_PKT_DSCP_MASK;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, DSCPs, dscp));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, NEW_DSCPs, 0));
        /* Configure field value.*/
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, INT_PRIs, 0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CNGs, 0));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl,
                                         BCMLT_OPCODE_INSERT,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

    qos_map_id_hold(unit, QoSMapTypeL3Ingress, index);

    /* Egr L3 entry setting. */
    set_size = QOS_REMARK_INT_PRI_CNG_SET_SIZE;
    alloc_size = set_size * sizeof(bcm_qos_map_t);
    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);

    map.type = bcmiQosMapTypeL3Egress;
    map.flags = BCM_QOS_MAP_L3 | BCM_QOS_MAP_EGRESS;
    map.count = &set_size;
    qos_map = map.entry;
    qos_map->dscp = 0;
    /* Program default entries. */
    for (i = 0; i < set_size; i++) {
        qos_map->int_pri = (i >> 2) & QOS_INT_PRI_MASK;
        qos_map->color = i & QOS_INT_CNG_MASK;
        qos_map++;
    }
    index = 0;
    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map));

    qos_map_id_hold(unit, QoSMapTypeL3Egress, index);

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add MPLS default mapping table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_mpls_default_add(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    int set_size, i, index, color, int_pri, int_cng, pkt_pri, pri;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    set_size = QOS_REMARK_INT_PRI_CNG_SET_SIZE;
    index = 0;
    pri = QOS_PKT_PRI_MASK;
    /*  For PT EGR_MPLS_EXP_MAPPING_2 */
    for (i = 0; i < set_size; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(
                dunit, PHB_EGR_MPLS_INT_PRI_TO_LSP_EXPs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(
                entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP_IDs, index));
        /* Caculating the index for the table. */
        int_pri = (i >> 2) & QOS_INT_PRI_MASK;
        color = i & QOS_INT_CNG_MASK;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
        /* No need to do Color encode, serve as CNG index */
        int_cng = color;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
        /* Configure field value.*/
        pkt_pri = int_pri > pri ? pri : int_pri;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MPLS_EXPs, pkt_pri));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl,
                                         BCMLT_OPCODE_INSERT,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

static int
qos_map_id_construct(int unit, int ptr,
                     bcmi_ltsw_qos_map_type_t map_type, int *map_id);
static int
qos_port_egr_map_set(int unit, bcm_gport_t port, int map_id);

/*!
 * \brief Enable default DSCP mapping on all ports.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_default_add(int unit)
{
    int trust_dscp_ptr = 0;
    bcm_pbmp_t pbmp;
    bcm_port_t port;
    int map_id;
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_ALL, &pbmp));

    /* ptr 0 is the default entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_construct(unit, 0, bcmiQosMapTypeL2Egress, &map_id));

    BCM_PBMP_ITER(pbmp, port) {
        /* Set default DSCP PTR value. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit, port, BCMI_PT_DSCP_PHB,
                                    trust_dscp_ptr));
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_port_egr_map_set(unit, port, map_id));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init QoS table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_table_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Clear QoS table first. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_table_clear_all(unit));

    /* Add L2 default mapping table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_l2_default_add(unit));

    /* Add L2 remap default mapping table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_l2_remap_default_add(unit));

    /* Add L3 default mapping table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_l3_default_add(unit));

    /* Add MPLS default mapping table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_mpls_default_add(unit));

    /* Enable default L2 remarking on ports. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_default_add(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get map type by flags.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS map flags.
 * \param [out] type QoS map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_type_get_by_flags(int unit, uint32_t flags,
                          bcmi_ltsw_qos_map_type_t *type)
{
    bcmi_ltsw_qos_map_type_t type_tmp = bcmiQosMapTypeCount;
    SHR_FUNC_ENTER(unit);

    if (flags & BCM_QOS_MAP_L2) {
        if (flags & BCM_QOS_MAP_INGRESS) {
            type_tmp = bcmiQosMapTypeL2Ingress;
        } else if (flags & BCM_QOS_MAP_EGRESS) {
            if (flags & BCM_QOS_MAP_MPLS) {
                type_tmp = bcmiQosMapTypeMplsEgressL2;
            } else {
                type_tmp = bcmiQosMapTypeL2Egress;
            }
        }
    } else if (flags & BCM_QOS_MAP_L3) {
        if (flags & BCM_QOS_MAP_INGRESS) {
            type_tmp = bcmiQosMapTypeL3Ingress;
        } else if (flags & BCM_QOS_MAP_EGRESS) {
            type_tmp = bcmiQosMapTypeL3Egress;
        }
    } else if (flags & BCM_QOS_MAP_MPLS) {
        if (flags & BCM_QOS_MAP_INGRESS) {
            type_tmp = bcmiQosMapTypeMplsIngress;
        } else if (flags & BCM_QOS_MAP_EGRESS) {
            type_tmp = bcmiQosMapTypeMplsEgress;
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *type = type_tmp;
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Transform QoS map type to native map type.
 *
 * \param [in] unit Unit Number.
 * \param [in] map_type QoS map type.
 * \param [out] type Native map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_type_to_native_type(int unit, bcmi_ltsw_qos_map_type_t map_type,
                            qos_xgs_map_type_t *type)
{
    SHR_FUNC_ENTER(unit);

    switch (map_type) {
        case bcmiQosMapTypeL2Ingress:
        case bcmiQosMapTypeL3Ingress:
        case bcmiQosMapTypeMplsIngress:
        case bcmiQosMapTypeL2Egress:
        case bcmiQosMapTypeL3Egress:
        case bcmiQosMapTypeMplsEgress:
            *type = (qos_xgs_map_type_t)map_type;
            break;
        case bcmiQosMapTypeMplsEgressL2:
            *type = (qos_xgs_map_type_t)QoSMapTypeMplsEgressL2;
            break;
        default:
            /*
             * Assign default invalid value to prevent
             * compiler error in SDK-203796.
             */
            *type = -1;
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Transform QoS map type to public map type.
 *
 * \param [in] unit Unit Number.
 * \param [in] map_type QoS map type.
 * \param [out] type Public map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_type_to_public_type(int unit, qos_xgs_map_type_t map_type,
                            bcmi_ltsw_qos_map_type_t *pub_type)
{
    SHR_FUNC_ENTER(unit);

    switch (map_type) {
        case QoSMapTypeL2Ingress:
        case QoSMapTypeL3Ingress:
        case QoSMapTypeMplsIngress:
        case QoSMapTypeL2Egress:
        case QoSMapTypeL3Egress:
        case QoSMapTypeMplsEgress:
            *pub_type = (bcmi_ltsw_qos_map_type_t)map_type;
            break;
        case QoSMapTypeMplsEgressL2:
            *pub_type = (bcmi_ltsw_qos_map_type_t)bcmiQosMapTypeMplsEgressL2;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get QoS map type from QoS map id.
 *
 * \param [in] unit Unit Number.
 * \param [in] map_id BCM QoS map id.
 * \param [out] type QoS map type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_id_to_map_type(int unit, int map_id, bcmi_ltsw_qos_map_type_t *type)
{
    SHR_FUNC_ENTER(unit);

    *type = map_id >> QOS_MAP_SHIFT;

    if (*type >= bcmiQosMapTypeCount || *type == bcmiQosMapTypeFwdEcnEgress
        || *type == bcmiQosMapTypeFwdEcnDscpEgress
        || *type == bcmiQosMapTypeTnlEcnEgress
        || *type == bcmiQosMapTypeTnlEcnDscpEgress) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief QoS map id check.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [in] type QoS map type.
 * \param [in] map_id QoS map id.
 * \param [out] id Map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_id_check(int unit, qos_xgs_map_type_t type,
                 int map_id, int *id)
{
    qos_xgs_map_type_t type_tmp;
    bcmi_ltsw_qos_map_type_t map_type;
    int id_tmp, map_size;
    uint32_t length;
    SHR_FUNC_ENTER(unit);

    /* Get map type from map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));

    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type_tmp));

    id_tmp = map_id & QOS_MAP_ID_MASK;

    if (type_tmp != type) {
        SHR_ERR_EXIT(SHR_E_BADID);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, qos_tab_map[type], &length));
    map_size = length / qos_chunk_size[type];

    if (id_tmp >= map_size) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *id = id_tmp;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Allocate a map id.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [out] id Map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_id_alloc(int unit, qos_xgs_map_type_t type, int *id)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    SHR_BITDCL *bitmap = NULL;
    SHR_BITDCL *bitmap2 = NULL;
    int i = 0, size = 0;
    uint32_t length;

    SHR_FUNC_ENTER(unit);

    if (type >= QoSMapTypeCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    bitmap = qos_db->bmp[type];

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, qos_tab_map[type], &length));
    size = length / qos_chunk_size[type];

    for (i = 0; i < size; i++) {
        /* MplsEgress and  L2Egress are mutually exclusive. */
        if (type == QoSMapTypeMplsEgress) {
            bitmap2 = qos_db->bmp[QoSMapTypeL2Egress];
            if (!SHR_BITGET(bitmap, i) && !SHR_BITGET(bitmap2, i)) {
                break;
            }
        } else if (type == QoSMapTypeL2Egress) {
            bitmap2 = qos_db->bmp[QoSMapTypeMplsEgress];
            if (!SHR_BITGET(bitmap, i) && !SHR_BITGET(bitmap2, i)) {
                break;
            }
        } else {
            if (!SHR_BITGET(bitmap, i)) {
                break;
            }
        }
    }
    if (i >= size) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }
    *id = i;

exit:
    SHR_FUNC_EXIT();
}

static int
qos_map_default_entry_check(int unit,
                            int id,
                            qos_xgs_map_type_t type,
                            int map_id)
{
    SHR_FUNC_ENTER(unit);

    if (MAP_ID_CREATED_IN_INIT(id, type)) {
        LOG_ERROR(BSL_LS_BCM_QOS,
                 (BSL_META_U(unit,
                             "Error: Cannot modified the id=%d."
                             "It is a default entry."), map_id));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set QoS controls.
 *
 * \param [in] unit Unit Number.
 * \param [in] control Enum value of the QoS control.
 * \param [in] value Value to set.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_control_set(
    int unit,
    bcmi_ltsw_qos_control_t control,
    uint32_t value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, qos_sc_info[control].ltname, &entry_hdl));

    rv = bcmlt_entry_field_add(entry_hdl, qos_sc_info[control].field_str,
                               value);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get QoS controls.
 *
 * \param [in] unit Unit Number.
 * \param [in] control Enum value of the QoS control.
 * \param [out] value Get value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_control_get(
    int unit,
    bcmi_ltsw_qos_control_t control,
    uint32_t *value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_field_def_t fld_def;
    uint64_t field_value;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, qos_sc_info[control].ltname, &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, qos_sc_info[control].ltname,
                                   qos_sc_info[control].field_str,
                                   &fld_def));
        *value = fld_def.def;
        SHR_EXIT();
    }

    rv = bcmlt_entry_field_get(entry_hdl, qos_sc_info[control].field_str,
                               &field_value);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }
    *value = field_value;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Create a QoS map.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [out] map_id QoS map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_create(int unit, uint32_t flags, int *map_id)
{
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int id = -1, alloc_size, set_size, index;
    bcmint_qos_map_t map;
    SHR_FUNC_ENTER(unit);

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));

    /* Get map type from QoS flags. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_get_by_flags(unit, flags, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));

    if (flags & BCM_QOS_MAP_WITH_ID) {
        /* Validate map id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_check(unit, type, *map_id, &id));

        if (QOS_MAP_BMP_USED_GET(unit, type, id)) {
            if (!(flags & BCM_QOS_MAP_REPLACE)) {
                SHR_ERR_EXIT(SHR_E_EXISTS);
            }
            /* Cannot create with the default entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_default_entry_check(unit, id, type, *map_id));

        } else {
            /* MplsEgress and  L2Egress are mutually exclusive LT. */
            if (type == QoSMapTypeMplsEgress) {
                if (QOS_MAP_BMP_USED_GET(
                        unit, QoSMapTypeL2Egress, id)) {
                    LOG_ERROR(BSL_LS_BCM_QOS,
                             (BSL_META_U(unit,
                                         "Error: Cannot set the id=%d."
                                         "It is occupied with "
                                         "L2Egress id."), *map_id));
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }
            } else if (type == QoSMapTypeL2Egress) {
                if (QOS_MAP_BMP_USED_GET(unit, QoSMapTypeMplsEgress, id)) {
                    LOG_ERROR(BSL_LS_BCM_QOS,
                             (BSL_META_U(unit,
                                         "Error: Cannot set the id=%d."
                                         "It is occupied with MplsEgress id."),
                                         *map_id));
                    SHR_ERR_EXIT(SHR_E_PARAM);
                }
            }
        }
    } else {
        /* Allocate a map id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_alloc(unit, type, &id));

        /* Return BCM map id. */
        *map_id = id | (map_type << QOS_MAP_SHIFT);
    }

    /* Get map set size. */
    set_size = qos_chunk_size[type];
    alloc_size = set_size * sizeof(bcm_qos_map_t);

    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);

    map.type = map_type;
    map.flags = flags;
    map.count = &set_size;

    /* Get LT table ID. */
    index = id;

    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map));

    /* Allocated the ID after qos_map is successfully added. */
    qos_map_id_hold(unit, type, id);

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a entry into ingress phb table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_ingress_table_delete(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int id;
    bcm_qos_map_t *map_tmp;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    map_tmp = map->entry;
    id = index;

    switch (map->type) {
        case bcmiQosMapTypeL2Ingress:
            if (map->flags & BCM_QOS_MAP_L2_UNTAGGED) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_L2_UNTAGGED_TO_INT_PRIs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_ING_L2_UNTAGGED_TO_INT_PRI_IDs, id));
                /* Set a entry. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE,
                                        BCMLT_PRIORITY_NORMAL));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_L2_TAGGED_TO_INT_PRIs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_ING_L2_TAGGED_TO_INT_PRI_IDs, id));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, PRIs,
                                           map_tmp->pkt_pri));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CFIs,
                                           map_tmp->pkt_cfi));
                /* Set a entry. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE,
                                        BCMLT_PRIORITY_NORMAL));
            }
            break;
        case bcmiQosMapTypeL3Ingress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_ING_IP_DSCP_TO_INT_PRI_REMAPs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DSCPs, map_tmp->dscp));
            /* Set a entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        case bcmiQosMapTypeMplsIngress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_ING_MPLS_EXP_TO_INT_PRIs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_ING_MPLS_EXP_TO_INT_PRI_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, EXPs, map_tmp->exp));
            /* Set a entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        default:
            SHR_ERR_EXIT(BCM_E_UNAVAIL);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a set of entries into ingress phb table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_ingress_table_delete_array(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, id, pkt_pri, pkt_cfi, dscp, exp;
    int set_sz;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    set_sz = *map->count;
    id = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    switch (map->type) {
        case bcmiQosMapTypeL2Ingress:
            /*  L2 Untaaged and Tagged will be destroy together. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_ING_L2_UNTAGGED_TO_INT_PRIs, &entry_hdl));
            /* Caculating the index for the table. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    PHB_ING_L2_UNTAGGED_TO_INT_PRI_IDs, id));
            /* Add entry into transaction. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl,
                                             BCMLT_OPCODE_DELETE,
                                             entry_hdl));
            entry_hdl = BCMLT_INVALID_HDL;

            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_L2_TAGGED_TO_INT_PRIs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_ING_L2_TAGGED_TO_INT_PRI_IDs, id));
                /* Caculating the index for the table. */
                pkt_pri = (i >> 1) & QOS_PKT_PRI_MASK;
                pkt_cfi = i & QOS_PKT_CFI_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, PRIs, pkt_pri));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CFIs, pkt_cfi));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_DELETE,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            break;
        case bcmiQosMapTypeL3Ingress:
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_IP_DSCP_TO_INT_PRI_REMAPs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs, id));
                /* Caculating the index for the table. */
                dscp = i & QOS_PKT_DSCP_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DSCPs, dscp));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_DELETE,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            break;
        case bcmiQosMapTypeMplsIngress:
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_MPLS_EXP_TO_INT_PRIs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_ING_MPLS_EXP_TO_INT_PRI_IDs, id));
                /* Caculating the index for the table. */
                exp = i & QOS_PKT_EXP_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, EXPs, exp));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_DELETE,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            break;
        default:
            SHR_ERR_EXIT(BCM_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a entry into egress table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_table_delete(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int int_cng, id;
    bcm_qos_map_t *map_tmp;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    map_tmp = map->entry;
    id = index;

    switch (map->type) {
        case bcmiQosMapTypeL2Egress:
            /*  For PT EGR_MPLS_PRI_MAPPING */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_MPLS_INT_PRI_TO_L2_OTAGs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                       map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
            /* Set a entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE,
                                    BCMLT_PRIORITY_NORMAL));
            if (entry_hdl != BCMLT_INVALID_HDL) {
                bcmlt_entry_free(entry_hdl);
                entry_hdl = BCMLT_INVALID_HDL;
            }
            /*  For PT EGR_MPLS_EXP_MAPPING_1 */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_L2_INT_PRI_TO_OTAGs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                                       PHB_EGR_L2_INT_PRI_TO_OTAG_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                       map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
            /* Set a entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE,
                                    BCMLT_PRIORITY_NORMAL));
            if (entry_hdl != BCMLT_INVALID_HDL) {
                bcmlt_entry_free(entry_hdl);
                entry_hdl = BCMLT_INVALID_HDL;
            }
            break;
        case bcmiQosMapTypeL3Egress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_IP_INT_PRI_TO_DSCPs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_EGR_IP_INT_PRI_TO_DSCP_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                                       INT_PRIs, map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
            /* Set a entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        case bcmiQosMapTypeMplsEgress:
            /*  For PT EGR_MPLS_EXP_MAPPING_1 */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_MPLS_INT_PRI_TO_VPN_EXPs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                       map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
            /* Set a entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE,
                                    BCMLT_PRIORITY_NORMAL));
            if (entry_hdl != BCMLT_INVALID_HDL) {
                bcmlt_entry_free(entry_hdl);
                entry_hdl = BCMLT_INVALID_HDL;
            }

            /*  For PT EGR_MPLS_EXP_MAPPING_2 */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_MPLS_INT_PRI_TO_LSP_EXPs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs,
                                       map_tmp->int_pri));
            int_cng = BCMI_LTSW_QOS_COLOR_ENCODING(map_tmp->color);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
            /* Set a entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE,
                                    BCMLT_PRIORITY_NORMAL));
            if (entry_hdl != BCMLT_INVALID_HDL) {
                bcmlt_entry_free(entry_hdl);
                entry_hdl = BCMLT_INVALID_HDL;
            }
            break;
        case bcmiQosMapTypeMplsEgressL2:
            /*  For PT EGR_MPLS_EXP_PRI_MAPPING */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, PHB_EGR_MPLS_EXP_TO_L2_OTAGs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(
                    entry_hdl, PHB_EGR_MPLS_EXP_TO_L2_OTAG_IDs, id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, EXPs,
                                       map_tmp->exp));
            /* Set a entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_DELETE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        default:
            SHR_ERR_EXIT(BCM_E_UNAVAIL);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a set of entries into egress table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_table_delete_array(int unit, int index, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, int_cng, id, color, int_pri, exp;
    int set_sz;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    set_sz = *map->count;
    id = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    switch (map->type) {
        case bcmiQosMapTypeL2Egress:
            /*  For PT EGR_MPLS_PRI_MAPPING */
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_MPLS_INT_PRI_TO_L2_OTAGs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG_IDs, id));
                /* Caculating the index for the table. */
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_DELETE,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            /*  For PT EGR_MPLS_EXP_MAPPING_1 */
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_L2_INT_PRI_TO_OTAGs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                                           PHB_EGR_L2_INT_PRI_TO_OTAG_IDs, id));
                /* Caculating the index for the table. */
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_DELETE,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            break;
        case bcmiQosMapTypeL3Egress:
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_IP_INT_PRI_TO_DSCPs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_EGR_IP_INT_PRI_TO_DSCP_IDs, id));
                /* Caculating the index for the table. */
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_DELETE,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            break;
        case bcmiQosMapTypeMplsEgress:
            /*  For PT EGR_MPLS_EXP_MAPPING_1 */
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_MPLS_INT_PRI_TO_VPN_EXPs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP_IDs, id));
                /* Caculating the index for the table. */
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_DELETE,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            /*  For PT EGR_MPLS_EXP_MAPPING_2 */
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_MPLS_INT_PRI_TO_LSP_EXPs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP_IDs, id));
                /* Caculating the index for the table. */
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_DELETE,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            break;
        case bcmiQosMapTypeMplsEgressL2:
            /*  For PT EGR_MPLS_EXP_PRI_MAPPING */
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_MPLS_EXP_TO_L2_OTAGs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_EGR_MPLS_EXP_TO_L2_OTAG_IDs, id));
                /* Caculating the index for the table. */
                exp = i & QOS_PKT_EXP_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, EXPs, exp));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_DELETE,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            break;
        default:
            SHR_ERR_EXIT(BCM_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete map table entry or entries.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 * \param [in] set Delete full set or single entry.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_table_delete(int unit, int index, bcmint_qos_map_t *map, bool set)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);

    if (set) {
        if (QOS_MAP_IS_ING_TYPE(map->type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_ingress_table_delete_array(unit, index, map));
        } else if (QOS_MAP_IS_EGR_TYPE(map->type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_egress_table_delete_array(unit, index, map));
        }
    } else {
        if (QOS_MAP_IS_ING_TYPE(map->type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_ingress_table_delete(unit, index, map));
        } else if (QOS_MAP_IS_EGR_TYPE(map->type)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_map_egress_table_delete(unit, index, map));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a QoS map.
 *
 * \param [in] unit Unit Number.
 * \param [in] map_id QoS map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_destroy(int unit, int map_id)
{
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    bcmint_qos_map_t map;
    int id, set_size, index;

    SHR_FUNC_ENTER(unit);
    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    /* Validate map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_check(unit, type, map_id, &id));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* Cannot destroy the default QoS setting. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_default_entry_check(unit, id, type, map_id));

    /* Get map set size by map type. */
    set_size = qos_chunk_size[type];

    map.count = &set_size;
    map.type = map_type;
    map.entry = sal_alloc(sizeof(bcm_qos_map_t), "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, sizeof(bcm_qos_map_t));

    /* Get LT table ID. */
    index = id;

    /* Delete qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_delete(unit, index, &map, true));
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_free(unit, type, id));

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check QoS map parameter.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [in] type QoS map type.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_param_check(int unit, uint32_t flags, qos_xgs_map_type_t type,
                    bcm_qos_map_t *map)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case QoSMapTypeL2Ingress:
            if (!(flags & BCM_QOS_MAP_L2) || !(flags & BCM_QOS_MAP_INGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if (map != NULL && ((map->int_pri > QOS_INT_PRI_MASK) ||
                (map->int_pri < 0) || (map->pkt_pri > QOS_PKT_PRI_MASK) ||
                (map->pkt_cfi > 1) || ((map->color != bcmColorGreen) &&
                (map->color != bcmColorYellow) &&
                (map->color != bcmColorRed)))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeL3Ingress:
            if (!(flags & BCM_QOS_MAP_L3) || !(flags & BCM_QOS_MAP_INGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if (map != NULL && ((map->int_pri > QOS_INT_PRI_MASK) ||
                (map->int_pri < 0) ||
                (map->dscp > QOS_PKT_DSCP_MASK) || (map->dscp < 0) ||
                ((map->color != bcmColorGreen) &&
                 (map->color != bcmColorYellow) &&
                 (map->color != bcmColorRed)))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeMplsIngress:
            if (!(flags & BCM_QOS_MAP_MPLS) || !(flags & BCM_QOS_MAP_INGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if (map != NULL && ((map->int_pri > QOS_INT_PRI_MASK) ||
                (map->int_pri < 0) ||
                (map->exp > QOS_PKT_EXP_MASK) || (map->exp < 0) ||
                ((map->color != bcmColorGreen) &&
                (map->color != bcmColorYellow) &&
                (map->color != bcmColorRed)))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeL2Egress:
            if (!(flags & BCM_QOS_MAP_L2) || !(flags & BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if (map != NULL && ((map->int_pri > QOS_INT_PRI_MASK) ||
                (map->int_pri < 0) ||
                (map->pkt_pri > QOS_PKT_PRI_MASK) || (map->pkt_cfi > 1) ||
                ((map->color != bcmColorGreen) &&
                (map->color != bcmColorYellow) &&
                (map->color != bcmColorRed)))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeL3Egress:
            if (!(flags & BCM_QOS_MAP_L3) || !(flags & BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if (map != NULL && ((map->int_pri > QOS_INT_PRI_MASK) ||
                (map->int_pri < 0) ||
                (map->dscp > QOS_PKT_DSCP_MASK) || (map->dscp < 0) ||
                ((map->color != bcmColorGreen) &&
                 (map->color != bcmColorYellow) &&
                 (map->color != bcmColorRed)))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeMplsEgress:
            if (!(flags & BCM_QOS_MAP_MPLS) || !(flags & BCM_QOS_MAP_EGRESS)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if (map != NULL && ((map->int_pri > QOS_INT_PRI_MASK) ||
                (map->int_pri < 0) ||
                (map->exp > QOS_PKT_EXP_MASK) || (map->exp < 0) ||
                (map->pkt_pri > QOS_PKT_PRI_MASK) || (map->pkt_cfi > 1) ||
                ((map->color != bcmColorGreen) &&
                 (map->color != bcmColorYellow) &&
                 (map->color != bcmColorRed)))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        case QoSMapTypeMplsEgressL2:
            if (!(flags & BCM_QOS_MAP_MPLS) || !(flags & BCM_QOS_MAP_EGRESS)
                || !(flags & BCM_QOS_MAP_L2)) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            if (map != NULL && ((map->exp > QOS_PKT_EXP_MASK) ||
                (map->exp < 0) ||
                (map->pkt_pri > QOS_PKT_PRI_MASK) || (map->pkt_cfi > 1))) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief QoS clear map set.
 *
 * \param [in] unit Unit Number.
 * \param [in] type QoS map type.
 * \param [in|out] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_clr_map_set(int unit, qos_xgs_map_type_t type, bcm_qos_map_t *map)
{
    SHR_FUNC_ENTER(unit);

    switch (type) {
        case QoSMapTypeL2Ingress:
            map->int_pri = 0;
            map->color = bcmColorGreen;
            break;
        case QoSMapTypeL3Ingress:
            map->int_pri = 0;
            map->color = bcmColorGreen;
            break;
        case QoSMapTypeMplsIngress:
            map->int_pri = 0;
            map->color = bcmColorGreen;
            break;
        case QoSMapTypeL2Egress:
            map->pkt_pri = 0;
            map->pkt_cfi = 0;
            break;
        case QoSMapTypeL3Egress:
            map->pkt_pri = 0;
            map->pkt_cfi = 0;
            map->dscp = 0;
            break;
        case QoSMapTypeMplsEgress:
            map->exp = 0;
            map->pkt_pri = 0;
            map->pkt_cfi = 0;
            break;
        case QoSMapTypeMplsEgressL2:
            map->pkt_pri = 0;
            map->pkt_cfi = 0;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add an entry into a QoS map.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [in] map QoS map.
 * \param [in] map_id QoS map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_add(int unit, uint32_t flags, bcm_qos_map_t *qos_map, int map_id)
{
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    bcm_qos_map_t qos_map_tmp;
    bcmint_qos_map_t map;
    int id, count = 1, index;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(qos_map, SHR_E_PARAM);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    /* Validate native map id, and retrieve native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_check(unit, type, map_id, &id));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Cannot add the default entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_default_entry_check(unit, id, type, map_id));

    /* Validate map parameter. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_param_check(unit, flags, type, qos_map));

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));
    sal_memcpy(&qos_map_tmp, qos_map, sizeof(bcm_qos_map_t));
    map.type = map_type;
    map.flags = flags;
    map.count = &count;
    map.entry = &qos_map_tmp;

    /* Get LT table ID. */
    index = id;

    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete an entry from a QoS map.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [in] map QoS map.
 * \param [in] map_id QoS map id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_delete(int unit, uint32_t flags, bcm_qos_map_t *qos_map, int map_id)
{
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int id, count = 1, index;
    bcm_qos_map_t clr_map;
    bcmint_qos_map_t map;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(qos_map, SHR_E_PARAM);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    /* Validate native map id, and retrieve native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_check(unit, type, map_id, &id));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Cannot add the default entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_default_entry_check(unit, id, type, map_id));

    sal_memcpy(&clr_map, qos_map, sizeof(clr_map));
    /* Clear the map. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_clr_map_set(unit, type, &clr_map));

    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));
    map.type = map_type;
    map.flags = flags;
    map.count = &count;
    map.entry = &clr_map;

    /* Get LT table ID. */
    index = id;

    /* Add qos map table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_add(unit, index, &map));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get a set of entries from ingress phb table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [out] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_ingress_table_get_array(int unit, int index,
                                uint32_t flags, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, base_index, base_index_tmp;
    int pkt_pri, pkt_cfi, dscp, exp;
    bcm_qos_map_t *map_tmp;
    int set_sz, cnt = 0;
    bcmlt_entry_info_t entry_info;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_info_t trans_info;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    uint64_t data = 0LL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    set_sz = *map->count;
    map_tmp = map->entry;
    base_index = index;
    base_index_tmp = base_index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    switch (map->type) {
        case bcmiQosMapTypeL2Ingress:
            if (map->flags & BCM_QOS_MAP_L2_UNTAGGED) {
                /* Untagged structure consist 1 entry in one map_id*/
                for (i = 0; i < 1; i++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_allocate(
                            dunit, PHB_ING_L2_UNTAGGED_TO_INT_PRIs,
                            &entry_hdl));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(
                            entry_hdl,
                            PHB_ING_L2_UNTAGGED_TO_INT_PRI_IDs,
                            base_index_tmp));
                    /* Add entry into transaction. */
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_transaction_entry_add(trans_hdl,
                                                     BCMLT_OPCODE_LOOKUP,
                                                     entry_hdl));
                    entry_hdl = BCMLT_INVALID_HDL;
                    base_index_tmp++;
                }

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_commit(trans_hdl,
                                              BCMLT_PRIORITY_NORMAL));

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_info_get(trans_hdl, &trans_info));

                /* Get map from each entry. */
                for (i = 0; i < trans_info.num_entries; i++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_transaction_entry_num_get(trans_hdl, i,
                                                         &entry_info));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_get(
                            entry_info.entry_hdl, INT_PRIs, &data));
                    map_tmp->int_pri = (int)data;

                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_get(
                            entry_info.entry_hdl, CNGs, &data));
                    map_tmp->color = BCMI_LTSW_QOS_COLOR_DECODING(data);

                    map_tmp++;
                    cnt++;
                }
            } else {

                for (i = 0; i < set_sz; i++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_allocate(
                            dunit, PHB_ING_L2_TAGGED_TO_INT_PRIs, &entry_hdl));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl,
                            PHB_ING_L2_TAGGED_TO_INT_PRI_IDs, base_index_tmp));
                    pkt_pri = (i >> 1) & QOS_PKT_PRI_MASK;
                    pkt_cfi = i & QOS_PKT_CFI_MASK;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl, PRIs, pkt_pri));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl, CFIs, pkt_cfi));
                    /* Add entry into transaction. */
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_transaction_entry_add(trans_hdl,
                                                     BCMLT_OPCODE_LOOKUP,
                                                     entry_hdl));
                    entry_hdl = BCMLT_INVALID_HDL;
                }

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_commit(trans_hdl,
                                              BCMLT_PRIORITY_NORMAL));

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_info_get(trans_hdl, &trans_info));

                /* Get map from each entry. */
                for (i = 0; i < trans_info.num_entries; i++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_transaction_entry_num_get(trans_hdl, i,
                                                         &entry_info));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_get(
                            entry_info.entry_hdl, INT_PRIs, &data));
                    map_tmp->int_pri = (int)data;

                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_get(
                            entry_info.entry_hdl, CNGs, &data));
                    map_tmp->color = BCMI_LTSW_QOS_COLOR_DECODING(data);
                    map_tmp->pkt_pri = (i >> 1) & QOS_PKT_PRI_MASK;
                    map_tmp->pkt_cfi = i & QOS_PKT_CFI_MASK;

                    map_tmp++;
                    cnt++;
                }
            }
            break;
        case bcmiQosMapTypeL3Ingress:
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_IP_DSCP_TO_INT_PRI_REMAPs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_ING_IP_DSCP_TO_INT_PRI_REMAP_IDs, base_index_tmp));
                dscp = i & QOS_PKT_DSCP_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DSCPs, dscp));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_LOOKUP,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_info_get(trans_hdl, &trans_info));

            /* Get map from each entry. */
            for (i = 0; i < trans_info.num_entries; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_num_get(trans_hdl, i,
                                                     &entry_info));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(
                        entry_info.entry_hdl, INT_PRIs, &data));
                map_tmp->int_pri = (int)data;

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(
                        entry_info.entry_hdl, CNGs, &data));
                map_tmp->color = BCMI_LTSW_QOS_COLOR_DECODING(data);
                map_tmp->dscp = i;

                map_tmp++;
                cnt++;
            }
            break;
        case bcmiQosMapTypeMplsIngress:
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_ING_MPLS_EXP_TO_INT_PRIs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_ING_MPLS_EXP_TO_INT_PRI_IDs, base_index_tmp));
                exp = i & QOS_PKT_EXP_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, EXPs, exp));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_LOOKUP,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_info_get(trans_hdl, &trans_info));

            /* Get map from each entry. */
            for (i = 0; i < trans_info.num_entries; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_num_get(trans_hdl, i,
                                                     &entry_info));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_info.entry_hdl, INT_PRIs, &data));
                map_tmp->int_pri = (int)data;

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_info.entry_hdl, CNGs, &data));
                map_tmp->color = BCMI_LTSW_QOS_COLOR_DECODING(data);

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_info.entry_hdl, DSCPs, &data));
                map_tmp->dscp = (int)data;
                map_tmp->exp = i;

                map_tmp++;
                cnt++;
            }
            break;
        default:
            SHR_ERR_EXIT(BCM_E_UNAVAIL);
    }

    *map->count = cnt;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get a set of entries from egress table.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_egress_table_get_array(int unit, int index,
                               uint32_t flags, bcmint_qos_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, base_index, rv;
    int int_pri, color, int_cng, exp;
    bcm_qos_map_t *map_tmp;
    int set_sz, cnt = 0;
    bcmlt_entry_info_t entry_info;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_info_t trans_info;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    uint64_t data = 0LL;

    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);
    SHR_NULL_CHECK(map->entry, SHR_E_PARAM);

    set_sz = *map->count;
    map_tmp = map->entry;
    base_index = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    switch (map->type) {
        case bcmiQosMapTypeL2Egress:
            /*  For PT EGR_MPLS_PRI_MAPPING */
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_MPLS_INT_PRI_TO_L2_OTAGs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_EGR_MPLS_INT_PRI_TO_L2_OTAG_IDs, base_index));
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_LOOKUP,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_info_get(trans_hdl, &trans_info));

            /* Get map from each entry. */
            for (i = 0; i < trans_info.num_entries; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_num_get(trans_hdl, i,
                                                     &entry_info));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_info.entry_hdl, PRIs, &data));
                map_tmp->pkt_pri = (int)data;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_info.entry_hdl, CFIs, &data));
                map_tmp->pkt_cfi = (int)data;
                map_tmp->int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                map_tmp->color =
                    BCMI_LTSW_QOS_COLOR_DECODING(i & QOS_INT_CNG_MASK);
                map_tmp++;
                cnt++;
            }
            /*
             * If  EGR_MPLS_EXP_MAPPING_1 is configured
             * it will overwrite the previous result.
             */
            if (trans_hdl != BCMLT_INVALID_HDL) {
                bcmlt_transaction_free(trans_hdl);
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH,
                                            &trans_hdl));
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_L2_INT_PRI_TO_OTAGs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_EGR_L2_INT_PRI_TO_OTAG_IDs, base_index));
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_LOOKUP,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            rv = bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL);

            if (rv == SHR_E_NONE) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_info_get(trans_hdl, &trans_info));
                map_tmp = map->entry;
                cnt = 0;
                /* Get map from each entry. */
                for (i = 0; i < trans_info.num_entries; i++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_transaction_entry_num_get(trans_hdl, i,
                                                         &entry_info));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_get(
                            entry_info.entry_hdl, PRIs, &data));
                    map_tmp->pkt_pri = (int)data;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_get(
                            entry_info.entry_hdl, CFIs, &data));
                    map_tmp->pkt_cfi = (int)data;
                    map_tmp->int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                    map_tmp->color =
                        BCMI_LTSW_QOS_COLOR_DECODING(i & QOS_INT_CNG_MASK);
                    map_tmp++;
                    cnt++;
                }
            }else if (rv == SHR_E_NOT_FOUND) {
                SHR_EXIT();
            } else {
                SHR_ERR_EXIT(rv);
            }
            break;
        case bcmiQosMapTypeL3Egress:
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(dunit, PHB_EGR_IP_INT_PRI_TO_DSCPs,
                                          &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_EGR_IP_INT_PRI_TO_DSCP_IDs, base_index));
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_LOOKUP,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_info_get(trans_hdl, &trans_info));

            /* Get map from each entry. */
            for (i = 0; i < trans_info.num_entries; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_num_get(trans_hdl, i,
                                                     &entry_info));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_info.entry_hdl, DSCPs, &data));
                map_tmp->dscp = (int)data;
                map_tmp->int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                map_tmp->color =
                    BCMI_LTSW_QOS_COLOR_DECODING(i & QOS_INT_CNG_MASK);

                map_tmp++;
                cnt++;
            }
            break;
        case bcmiQosMapTypeMplsEgress:
            /*
             * If  EGR_MPLS_EXP_MAPPING_1/2 is configured
             *  precendence of exp result being get = MAPPING_1 > MAPPING_2
             */
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_MPLS_INT_PRI_TO_LSP_EXPs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        PHB_EGR_MPLS_INT_PRI_TO_LSP_EXP_IDs, base_index));
                int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                color = i & QOS_INT_CNG_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                /* No need to do Color encode, serve as CNG index */
                int_cng = color;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_LOOKUP,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            rv = bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL);

            if (rv == SHR_E_NONE) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_info_get(trans_hdl, &trans_info));
                map_tmp = map->entry;
                /* Get map from each entry. */
                for (i = 0; i < trans_info.num_entries; i++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_transaction_entry_num_get(trans_hdl, i,
                                                         &entry_info));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_get(
                            entry_info.entry_hdl, MPLS_EXPs, &data));
                    map_tmp->exp = (int)data;
                    map_tmp->int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                    map_tmp->color =
                        BCMI_LTSW_QOS_COLOR_DECODING(i & QOS_INT_CNG_MASK);

                    map_tmp++;
                    cnt++;
                }
            } else if (rv == SHR_E_NOT_FOUND){
                /* Obtain the EXP from MAPPING_2 table. */
                if (trans_hdl != BCMLT_INVALID_HDL) {
                    bcmlt_transaction_free(trans_hdl);
                }
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH,
                                                &trans_hdl));
                for (i = 0; i < set_sz; i++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_allocate(
                            dunit, PHB_EGR_MPLS_INT_PRI_TO_VPN_EXPs,
                            &entry_hdl));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl,
                            PHB_EGR_MPLS_INT_PRI_TO_VPN_EXP_IDs, base_index));
                    int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                    color = i & QOS_INT_CNG_MASK;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
                    /* No need to do Color encode, serve as CNG index */
                    int_cng = color;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
                    /* Add entry into transaction. */
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_transaction_entry_add(trans_hdl,
                                                     BCMLT_OPCODE_LOOKUP,
                                                     entry_hdl));
                    entry_hdl = BCMLT_INVALID_HDL;
                }
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_commit(trans_hdl,
                                              BCMLT_PRIORITY_NORMAL));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_info_get(trans_hdl, &trans_info));
                map_tmp = map->entry;
                cnt = 0;
                /* Get map from each entry. */
                for (i = 0; i < trans_info.num_entries; i++) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_transaction_entry_num_get(trans_hdl, i,
                                                         &entry_info));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_get(
                            entry_info.entry_hdl, MPLS_EXPs, &data));
                    map_tmp->exp = (int)data;
                    map_tmp->int_pri = (i >> 2) & QOS_INT_PRI_MASK;
                    map_tmp->color =
                        BCMI_LTSW_QOS_COLOR_DECODING(i & QOS_INT_CNG_MASK);

                    map_tmp++;
                    cnt++;
                }
            }else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
            break;
        case bcmiQosMapTypeMplsEgressL2:
            /*  For PT EGR_MPLS_EXP_PRI_MAPPING */
            for (i = 0; i < set_sz; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, PHB_EGR_MPLS_EXP_TO_L2_OTAGs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, PHB_EGR_MPLS_EXP_TO_L2_OTAG_IDs,
                        base_index));
                exp = i & QOS_PKT_EXP_MASK;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, EXPs, exp));
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl,
                                                 BCMLT_OPCODE_LOOKUP,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_info_get(trans_hdl, &trans_info));
            /* Get map from each entry. */
            for (i = 0; i < trans_info.num_entries; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_num_get(trans_hdl, i,
                                                     &entry_info));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_info.entry_hdl, PRIs, &data));
                map_tmp->pkt_pri = (int)data;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_info.entry_hdl, CFIs, &data));
                map_tmp->pkt_cfi = (int)data;
                map_tmp->exp = i;

                cnt++;
                map_tmp++;
            }
            break;
        default:
            SHR_ERR_EXIT(BCM_E_UNAVAIL);
    }

    *map->count = cnt;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get map table entry or entries.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] set Delete full set or single entry.
 * \param [out] map QoS map.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
qos_map_table_get(int unit, int index, uint32_t flags, bcmint_qos_map_t *map)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(map, SHR_E_PARAM);

    if (QOS_MAP_IS_ING_TYPE(map->type)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_ingress_table_get_array(unit, index, flags, map));
    } else if (QOS_MAP_IS_EGR_TYPE(map->type)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_egress_table_get_array(unit, index, flags, map));
    }
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get an entire QoS mapping for the given QoS Map ID.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags QoS flags.
 * \param [in] map_id QoS map id.
 * \param [in] array_size Size of allocated entries in array.
 * \param [out] array QoS map array.
 * \param [out] count Actual number of QoS map entries.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_multi_get(int unit, uint32_t flags, int map_id, int array_size,
                  bcm_qos_map_t *array, int *count)
{
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    bcmint_qos_map_t map;
    int id, set_size, alloc_size, index;

    SHR_FUNC_ENTER(unit);
    sal_memset(&map, 0, sizeof(bcmint_qos_map_t));

    SHR_NULL_CHECK(count, SHR_E_PARAM);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    /* Validate native map id, and retrieve native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_check(unit, type, map_id, &id));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Flags checking. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_param_check(unit, flags, type, NULL));

    /* Get map set size. */
    set_size = qos_chunk_size[type];

    /* Get LT table ID. */
    index = id;

    /* Zero is to query. */
    if (array_size == 0) {
        *count = set_size;
        SHR_EXIT();
    } else {
        SHR_NULL_CHECK(array, SHR_E_PARAM);
    }
    alloc_size = set_size * sizeof(bcm_qos_map_t);

    map.entry = sal_alloc(alloc_size, "ltswQoSMap");
    SHR_NULL_CHECK(map.entry, SHR_E_MEMORY);
    sal_memset(map.entry, 0, alloc_size);

    map.type = map_type;
    map.flags = flags;
    map.count = &set_size;

    /* Get map from table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_table_get(unit, index, flags, &map));

    if (set_size >= array_size) {
        set_size = array_size;
    }
    *count = set_size;
    alloc_size = set_size * sizeof(bcm_qos_map_t);
    sal_memcpy(array, map.entry, alloc_size);

exit:
    SHR_FREE(map.entry);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the count of all used QoS Map IDs.
 *
 * \param [in] unit Unit Number.
 * \param [out] count Count of all QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_id_count_get(int unit, int *count)
{
    qos_cfg_t *qos_db = QOS_CFG(unit);
    qos_xgs_map_type_t type;
    int cnt = 0, map_size;
    uint32_t length;

    SHR_FUNC_ENTER(unit);

    *count = 0;
    for (type = QoSMapTypeL2Ingress; type < QoSMapTypeCount; type++) {
        cnt = 0;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_capacity_get(unit, qos_tab_map[type], &length));
        map_size = length / qos_chunk_size[type];
        /* Count bit size. */
        SHR_BITCOUNT_RANGE(qos_db->bmp[type], cnt, 0, map_size);
        *count += cnt;
    }

    *count -= MAP_CREATED_IN_INIT_NUM;
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get all used map id and flags.
 *
 * \param [in] unit Unit Number.
 * \param [in] array_size Size of allocated entries in map_id array.
 * \param [out] map_id QoS map id array.
 * \param [out] flags QoS flags array.
 * \param [out] count Actual number of QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_id_used_get_all(int unit, int array_size, int *map_id,
                        int *flags, int *count)
{
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t pub_type;
    int cnt = 0, id, map_size;
    uint32_t length;
    uint32_t flags_tmp[QoSMapTypeCount] = {
        BCM_QOS_MAP_L2 | BCM_QOS_MAP_INGRESS,
        BCM_QOS_MAP_L3 | BCM_QOS_MAP_INGRESS,
        BCM_QOS_MAP_MPLS | BCM_QOS_MAP_INGRESS,
        BCM_QOS_MAP_L2 | BCM_QOS_MAP_EGRESS,
        BCM_QOS_MAP_L3 | BCM_QOS_MAP_EGRESS,
        BCM_QOS_MAP_MPLS | BCM_QOS_MAP_EGRESS,
        BCM_QOS_MAP_MPLS | BCM_QOS_MAP_EGRESS | BCM_QOS_MAP_L2,
        };

    SHR_FUNC_ENTER(unit);

    /* Traverse all map types. */
    for (type = QoSMapTypeL2Ingress; type < QoSMapTypeCount; type++) {

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_capacity_get(unit, qos_tab_map[type], &length));
        map_size = length / qos_chunk_size[type];
        for (id = 0; (id < map_size) && (cnt < array_size) ; id++) {
            if (MAP_ID_CREATED_IN_INIT(id, type)) {
                continue;
            }
            if (QOS_MAP_BMP_USED_GET(unit, type, id)) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (qos_map_type_to_public_type(unit, type, &pub_type));
                *(map_id + cnt) = id | (pub_type << QOS_MAP_SHIFT);
                *(flags + cnt) = flags_tmp[type];
                cnt++;
            }
        }
    }
    *count = cnt;
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the list of all QoS Map IDs.
 *
 * \param [in] unit Unit Number.
 * \param [in] array_size Size of allocated entries in map_id array.
 * \param [out] map_id QoS map id array.
 * \param [out] flags QoS flags array.
 * \param [out] count Actual number of QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_multi_get(int unit, int array_size, int *map_id,
              int *flags, int *count)
{
    SHR_FUNC_ENTER(unit);

    /* Zero to query the count. */
    if (array_size == 0) {
        SHR_NULL_CHECK(count, SHR_E_PARAM);

        /* Get the count of all used maps. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_count_get(unit, count));
    } else {
        SHR_NULL_CHECK(map_id, SHR_E_PARAM);
        SHR_NULL_CHECK(flags, SHR_E_PARAM);
        SHR_NULL_CHECK(count, SHR_E_PARAM);

        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_used_get_all(unit, array_size, map_id, flags, count));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
  * \brief Set ingress and egress VLAN port based related QoS setting.
  *
  * \param [in] unit Unit Number.
  * \param [in] port Ingress port.
  * \param [in] vid Vlan domain.
  * \param [in] ing_map ingress QoS id.
  * \param [in] egr_map egress QoS id.
  *
  * \retval SHR_E_NONE No errors.
  * \retval !SHR_E_NONE Failure.
  */
static int
qos_port_vlan_map_set(int unit, bcm_port_t port, bcm_vlan_t vid,
                      int ing_map, int egr_map)
{
    bcm_pbmp_t pbmp, ubmp;
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int ing_id = 0, egr_id = 0;

    SHR_FUNC_ENTER(unit);

    /* Validate Args */
    /* Deal with physical ports */
    if (BCM_GPORT_IS_SET(port)) {
        if (!BCM_GPORT_IS_LOCAL(port) && !BCM_GPORT_IS_MODPORT(port)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        if (bcm_ltsw_port_local_get(unit, port, &port) < 0) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

    if (!BCM_VLAN_VALID(vid)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* check vlan membership for the port */
    BCM_IF_ERROR_RETURN(
        bcm_ltsw_vlan_port_get(unit, vid, &pbmp, &ubmp));
    if (!BCM_PBMP_MEMBER(pbmp, port)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* Validate given ingress map for non supported types and IDs */
    if (ing_map > 0) {
        /* Get map type from BCM map id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_to_map_type(unit, ing_map, &map_type));
        /* Transform map type to native type. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_type_to_native_type(unit, map_type, &type));
        /* It is referencing ING_PRI_CNG_MAP table. */
        if (type != QoSMapTypeL2Ingress) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        /* Validate native map id, and retrieve native map id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_check(unit, type, ing_map, &ing_id));

        if (!QOS_MAP_BMP_USED_GET(unit, type, ing_id)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    /* Validate given egress map for non supported types and IDs */
    if (egr_map > 0) {
        /* Get map type from BCM map id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_to_map_type(unit, egr_map, &map_type));
        /* Transform map type to native type. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_type_to_native_type(unit, map_type, &type));
        /* It is referencing EGR_MPLS_PRI_MAPPING table. */
        if (type != QoSMapTypeL2Egress) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        /* Validate native map id, and retrieve native map id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_id_check(unit, type, egr_map, &egr_id));

        if (!QOS_MAP_BMP_USED_GET(unit, type, egr_id)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

    /* -1 means no change */
    if (ing_map > 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_vlan_ing_qos_set(unit, vid, ing_id));
    } else if (ing_map == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_vlan_ing_qos_set(unit, vid, 0));
    }

    /* -1 means no change */
    if (egr_map > 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_vlan_egr_qos_set(unit, vid, egr_id));
    } else if (egr_map == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_vlan_egr_qos_set(unit, vid, 0));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
  * \brief Get ingress and egress VLAN port based related QoS setting.
  *
  * \param [in] unit Unit Number.
  * \param [in] port Ingress port.
  * \param [in] vid Vlan domain.
  * \param [out] ing_map ingress QoS id.
  * \param [out] egr_map egress QoS id.
  *
  * \retval SHR_E_NONE No errors.
  * \retval !SHR_E_NONE Failure.
  */
static int
qos_port_vlan_map_get(int unit, bcm_port_t port, bcm_vlan_t vid,
                      int *ing_map, int *egr_map)
{
    bcm_pbmp_t pbmp, ubmp;
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t pub_type;
    int ing_id = 0, egr_id = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ing_map, SHR_E_PARAM);
    SHR_NULL_CHECK(egr_map, SHR_E_PARAM);

    /* Validate Args */
    /* Deal with physical ports */
    if (BCM_GPORT_IS_SET(port)) {
        if (!BCM_GPORT_IS_LOCAL(port) && !BCM_GPORT_IS_MODPORT(port)) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        if (bcm_ltsw_port_local_get(unit, port, &port) < 0) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }

    if (!BCM_VLAN_VALID(vid)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    /* check vlan membership for the port */
    BCM_IF_ERROR_RETURN(
        bcm_ltsw_vlan_port_get(unit, vid, &pbmp, &ubmp));
    if (!BCM_PBMP_MEMBER(pbmp, port)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_ing_qos_get(unit, vid, &ing_id));
    type = QoSMapTypeL2Ingress;
    if (!QOS_MAP_BMP_USED_GET(unit, type, ing_id)
        || MAP_ID_CREATED_IN_INIT(ing_id, type)) {
        *ing_map = -1;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_type_to_public_type(unit, type, &pub_type));
        *ing_map = (pub_type << QOS_MAP_SHIFT) | (ing_id & QOS_MAP_ID_MASK);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_vlan_egr_qos_get(unit, vid, &egr_id));
    type = QoSMapTypeL2Egress;
    /* Exclude default created map_id from retrieving. */
    if (!QOS_MAP_BMP_USED_GET(unit, type, egr_id)
        || MAP_ID_CREATED_IN_INIT(egr_id, type)) {
        *egr_map = -1;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_map_type_to_public_type(unit, type, &pub_type));
        *egr_map = (pub_type << QOS_MAP_SHIFT) | (egr_id & QOS_MAP_ID_MASK);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Resolve QoS map id into mapping pointer and QoS map type.
 *
 * \param [in] unit Unit Number.
 * \param [in] map_id QoS map id.
 * \param [out] map_type QoS map type. NULL indicates not care.
 * \param [out] ptr Mapping pointer. NULL indicates not care.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_id_resolve(int unit, int map_id, bcmi_ltsw_qos_map_type_t *map_type,
                   int *ptr)
{
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type_tmp;
    int id, index;
    SHR_FUNC_ENTER(unit);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type_tmp));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type_tmp, &type));
    /* Validate native map id, and retrieve native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_check(unit, type, map_id, &id));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Actual LT table id. */
    index = id;

    if (map_type != NULL) {
        *map_type = map_type_tmp;
    }
    if (ptr != NULL) {
        *ptr = index;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct QoS map id with mapping pointer and QoS map type.
 *
 * \param [in] unit Unit Number.
 * \param [in] ptr Mapping pointer.
 * \param [in] map_type QoS map type.
 * \param [out] map_id QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_map_id_construct(int unit, int ptr, bcmi_ltsw_qos_map_type_t map_type,
                     int *map_id)
{
    int id;
    qos_xgs_map_type_t type;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(map_id, SHR_E_PARAM);

    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));

    id = ptr;

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    *map_id = id | (map_type << QOS_MAP_SHIFT);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Dump QoS map used bitmap.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static void
qos_sw_dump_map_bmp(int unit)
{
    int i, j, size;
    uint32_t length;
    const char *type_list[] = BCMI_LTSW_QOS_MAP_TYPE_STR;
    qos_cfg_t *qos_db = QOS_CFG(unit);
    SHR_BITDCL *bmp = NULL;

    LOG_CLI((BSL_META_U(unit,
                        "----------------%20s----------------\n"),
                        "Used bitmap"));

    LOG_CLI((BSL_META_U(unit,
                        "  %20s         Bmp(upper->lower)\n"),
                        "Type"));

    for (i = 0; i < QoSMapTypeCount; i++) {
        bcmi_lt_capacity_get(unit, qos_tab_map[i], &length);
        size = length / qos_chunk_size[i];
        bmp = qos_db->bmp[i];
        /* Dump type name. */
        if (i >= 6) {
            /* Skip ECN support in QoS. */
            LOG_CLI((BSL_META_U(unit,
                                "  %20s     "),
                                type_list[i + 4]));
        } else {
            LOG_CLI((BSL_META_U(unit,
                                "  %20s     "),
                                type_list[i]));
        }

        LOG_CLI((BSL_META_U(unit, "\n")));

        if (bmp == NULL) {
            continue;
        }
        /* Dump all used bitmap. */
        for (j = size - 1; j >= 0; j--) {
            LOG_CLI((BSL_META_U(unit,
                            "%2x "),
                            SHR_BITGET(bmp, j)));
        }
        LOG_CLI((BSL_META_U(unit, "\n")));
    }
}

/*!
 * \brief Dump QoS module software bookkeepings.
 *
 * \param [in] unit Unit Number.
 */
static void
qos_sw_dump(int unit)
{
    int i, j, map_size;
    uint32_t length;
    const char *blk_name[] = {"L2", "L3", "MPLS"};
    const char *type_list[] = BCMI_LTSW_QOS_MAP_TYPE_STR;

    LOG_CLI((BSL_META_U(unit,
                        "\nSW Information QoS - Unit %d\n"), unit));
    LOG_CLI((BSL_META_U(unit,
                        "----------------%20s----------------\n"),
                        "Block size"));
    /* Dump block size. */
    for (i = 0; i < QOS_ING_MAP_TYPE_COUNT; i++) {
        LOG_CLI((BSL_META_U(unit,
                        "  %20s       : %4d\n"),
                        blk_name[i], qos_chunk_size[i]));
    }

    LOG_CLI((BSL_META_U(unit,
                        "----------------%20s----------------\n"),
                        "Map id size"));
    /* Dump map id size. */
    for (i = 0; i < QoSMapTypeCount; i++) {
        bcmi_lt_capacity_get(unit, qos_tab_map[i], &length);
        map_size = length / qos_chunk_size[i];
        if (i >= 6) {
            j = i + 4;
        } else {
            j = i;
        }
        LOG_CLI((BSL_META_U(unit,
                        "  %20s       : %4d\n"),
                        type_list[j], map_size));
    }

    qos_sw_dump_map_bmp(unit);
}

/*!
 * \brief Clear QoS ingress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_ing_map_clear(int unit, bcm_gport_t port)
{
    SHR_FUNC_ENTER(unit);

    /* Restore dot1p ptr to default setting. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                port,
                                BCMI_PT_DOT1P_PHB,
                                0));

    /* Restore DSCP ptr to default setting. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                port,
                                BCMI_PT_DSCP_PHB,
                                0));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                port,
                                BCMI_PT_TRUST_PHB_ING_DSCP_V4,
                                0));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_tab_set(unit,
                                port,
                                BCMI_PT_TRUST_PHB_ING_DSCP_V6,
                                0));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear QoS egress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_egr_map_clear(int unit, bcm_gport_t port)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, set_sz, int_pri, color, int_cng;
    qos_cfg_t *qos_db = NULL;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    set_sz = QOS_REMARK_INT_PRI_CNG_SET_SIZE;
    qos_db = QOS_CFG(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (i = 0; i < set_sz; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(
                dunit, PHB_EGR_PORT_INT_PRI_TO_L2_OTAGs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PORT_IDs, port));
        /* Caculating the index for the table. */
        int_pri = (i >> 2) & QOS_INT_PRI_MASK;
        color = i & QOS_INT_CNG_MASK;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
        /* No need to do Color encode, serve as CNG index */
        int_cng = color;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
        /* Configure field value.*/
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PRIs, 0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CFIs, 0));
        /* Has been insert before, need update operation. */
        if (qos_db->egr_port_map[port] != INVALID_MAP_ID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl,
                                             BCMLT_OPCODE_UPDATE,
                                             entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl,
                                             BCMLT_OPCODE_INSERT,
                                             entry_hdl));
        }
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

    qos_db->egr_port_map[port] = 0;
exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set QoS ingress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] map_id QoS Map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_ing_map_set(int unit, bcm_gport_t port, int map_id)
{
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int id;
    bcmi_ltsw_port_tab_t ptype = 0, ptype1 = 0, ptype2 = 0;
    SHR_FUNC_ENTER(unit);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    /* Validate native map id, and retrieve native map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_check(unit, type, map_id, &id));

    if (!QOS_MAP_BMP_USED_GET(unit, type, id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    switch (type) {
        case QoSMapTypeL2Ingress:
            ptype = BCMI_PT_DOT1P_PHB;
            break;
        case QoSMapTypeL3Ingress:
            ptype = BCMI_PT_DSCP_PHB;
            ptype1 = BCMI_PT_TRUST_PHB_ING_DSCP_V4;
            ptype2 = BCMI_PT_TRUST_PHB_ING_DSCP_V6;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Set mapping ptr. */
    if (ptype != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit, port, ptype, id));
    }

    /* Enable mapping. */
    if (ptype1 != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit, port, ptype1, 1));
    }

    /* Enable mapping. */
    if (ptype2 != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_set(unit, port, ptype2, 1));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set QoS egress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] map_id QoS Map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_egr_map_set(int unit, bcm_gport_t port, int map_id)
{
    bcmi_ltsw_qos_map_type_t map_type;
    int flags, array_size, count = 0, alloc_sz;
    bcm_qos_map_t map[QOS_REMARK_INT_PRI_CNG_SET_SIZE];
    int dunit = bcmi_ltsw_dev_dunit(unit);
    int i, int_pri, color, int_cng;
    qos_cfg_t *qos_db = NULL;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    qos_db = QOS_CFG(unit);

    /* Get map type from BCM map id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_to_map_type(unit, map_id, &map_type));

    if (map_type != bcmiQosMapTypeL2Egress) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    flags = BCM_QOS_MAP_L2 | BCM_QOS_MAP_EGRESS;
    array_size = QOS_REMARK_INT_PRI_CNG_SET_SIZE;
    alloc_sz = sizeof(bcmint_qos_map_t) * array_size;
    sal_memset(map, 0, alloc_sz);
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_multi_get(unit, flags, map_id, array_size, map, &count));
    if (count != array_size) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    for (i = 0; i < count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(
                dunit, PHB_EGR_PORT_INT_PRI_TO_L2_OTAGs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PORT_IDs, port));
        /* Caculating the index for the table. */
        int_pri = (i >> 2) & QOS_INT_PRI_MASK;
        color = i & QOS_INT_CNG_MASK;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, INT_PRIs, int_pri));
        /* No need to do Color encode, serve as CNG index */
        int_cng = color;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CNGs, int_cng));
        /* Configure field value.*/
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PRIs, map[i].pkt_pri));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CFIs, map[i].pkt_cfi));
        /* Has been insert before, need update operation. */
        if (qos_db->egr_port_map[port] != INVALID_MAP_ID) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl,
                                             BCMLT_OPCODE_UPDATE,
                                             entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl,
                                             BCMLT_OPCODE_INSERT,
                                             entry_hdl));
        }
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

    qos_db->egr_port_map[port] = map_id;
exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Attach QoS map to an object(Gport).
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] ing_map Ingress map id.
 * \param [in] egr_map Egress map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_map_set(int unit, bcm_gport_t port, int ing_map, int egr_map)
{
    int rv;
    bcm_port_t port_out;
    SHR_FUNC_ENTER(unit);

    if (BCM_GPORT_IS_SET(port) && !BCM_GPORT_IS_MODPORT(port) &&
        !BCM_GPORT_IS_LOCAL(port)) {
        /* Not support SVP/DVP HW, and tunnel port. */
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else {
        /* Validate port. */
        rv = bcmi_ltsw_port_gport_validate(unit, port, &port_out);
        if (SHR_FAILURE(rv)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        /* -1 means no change. */
        if (ing_map != -1) {
            /* Clear the existing map. */
            if (ing_map == 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (qos_port_ing_map_clear(unit, port_out));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (qos_port_ing_map_set(unit, port_out, ing_map));
            }
        }

        /* -1 means no change. */
        if (egr_map != -1) {
            if (egr_map == 0) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (qos_port_egr_map_clear(unit, port_out));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (qos_port_egr_map_set(unit, port_out, egr_map));
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get QoS ingress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] flags QoS flags.
 * \param [out] map_id QoS Map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_ing_map_get(int unit, bcm_gport_t port, uint32_t flags, int *map_id)
{
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    int index = 0, id = 0;
    bcmi_ltsw_port_tab_t ptype1 = 0;
    uint32_t flags_tmp = flags;
    SHR_FUNC_ENTER(unit);

    /* Get map type from QoS flags. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_get_by_flags(unit, flags, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    flags_tmp &= ~BCM_QOS_MAP_INGRESS;

    switch (type) {
        case QoSMapTypeL2Ingress:
            ptype1 = BCMI_PT_DOT1P_PHB;
            flags_tmp &= ~BCM_QOS_MAP_L2;
            break;
        case QoSMapTypeL3Ingress:
            ptype1 = BCMI_PT_DSCP_PHB;
            flags_tmp &= ~BCM_QOS_MAP_L3;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* More flags that could not be handled. */
    if (flags_tmp) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Get mapping ptr. */
    if (ptype1 != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_get(unit, port, ptype1, &id));
    }

    if (MAP_ID_CREATED_IN_INIT(id, type)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* Actual LT table id. */
    index = id;

    /* Fetch map id from QoS map type and mapping ptr. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_construct(unit, index, map_type, map_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get QoS egress map on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] flags QoS flags.
 * \param [out] map_id QoS Map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_egr_map_get(int unit, bcm_gport_t port, uint32_t flags, int *map_id)
{
    qos_xgs_map_type_t type;
    bcmi_ltsw_qos_map_type_t map_type;
    uint32_t flags_tmp = flags;
    qos_cfg_t *qos_db = NULL;
    SHR_FUNC_ENTER(unit);

    qos_db = QOS_CFG(unit);

    /* Get map type from QoS flags. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_get_by_flags(unit, flags, &map_type));
    /* Transform map type to native type. */
    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_type_to_native_type(unit, map_type, &type));
    flags_tmp &= ~BCM_QOS_MAP_EGRESS;

    switch (type) {
        case QoSMapTypeL2Egress:
            flags_tmp &= ~BCM_QOS_MAP_L2;
            *map_id = qos_db->egr_port_map[port];
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }
    /*
     * map_id == 0, indicate the qos_port_map being cleared.
     * map_id == INVALID_MAP_ID, indicated never created.
     */
    if(*map_id == INVALID_MAP_ID || *map_id == 0) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* More flags that could not be handled. */
    if (flags_tmp) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve the QoS maps attached to an object(Gport).
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port/Gport id.
 * \param [in] flags QoS flags.
 * \param [out] map_id QoS map id.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
qos_port_map_get(int unit, bcm_gport_t port, uint32_t flags, int *map_id)
{
    int rv;
    bcm_port_t port_out;
    SHR_FUNC_ENTER(unit);

    if (BCM_GPORT_IS_SET(port) && !BCM_GPORT_IS_MODPORT(port) &&
        !BCM_GPORT_IS_LOCAL(port)) {
        /* Not support SVP/DVP HW, and tunnel port. */
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else {
        /* Validate port. */
        rv = bcmi_ltsw_port_gport_validate(unit, port, &port_out);
        if (SHR_FAILURE(rv)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        if (flags & BCM_QOS_MAP_INGRESS) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_port_ing_map_get(unit, port_out, flags, map_id));
        } else if (flags & BCM_QOS_MAP_EGRESS) {
            SHR_IF_ERR_VERBOSE_EXIT
                (qos_port_egr_map_get(unit, port_out, flags, map_id));
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_qos_init(int unit)
{
    int warm = bcmi_warmboot_get(unit);
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_db_init(unit));

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (qos_table_init(unit));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_detach(int unit)
{
    return SHR_E_NONE;
}

int
xgs_ltsw_qos_control_set(
    int unit,
    bcmi_ltsw_qos_control_t control,
    uint32_t value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_control_set(unit, control, value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_control_get(
    int unit,
    bcmi_ltsw_qos_control_t control,
    uint32_t *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_control_get(unit, control, value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_map_create(
    int unit,
    uint32_t flags,
    int *map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_create(unit, flags, map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_map_destroy(
    int unit,
    int map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_destroy(unit, map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_map_add(
    int unit,
    uint32_t flags,
    bcm_qos_map_t *map,
    int map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_add(unit, flags, map, map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_map_delete(
    int unit,
    uint32_t flags,
    bcm_qos_map_t *map,
    int map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_delete(unit, flags, map, map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_port_map_set(
    int unit,
    bcm_gport_t port,
    int ing_map,
    int egr_map)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_map_set(unit, port, ing_map, egr_map));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_port_map_type_get(
    int unit,
    bcm_gport_t port,
    uint32_t flags,
    int *map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_map_get(unit, port, flags, map_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_map_multi_get(
    int unit,
    uint32_t flags,
    int map_id,
    int array_size,
    bcm_qos_map_t *array,
    int *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_multi_get(unit,
                           flags,
                           map_id,
                           array_size,
                           array,
                           count));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_multi_get(
    int unit,
    int array_size,
    int *map_id,
    int *flags,
    int *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_multi_get(unit,
                       array_size,
                       map_id,
                       flags,
                       count));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_port_vlan_map_set(
    int unit,
    bcm_port_t port,
    bcm_vlan_t vid,
    int ing_map,
    int egr_map)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_vlan_map_set(unit, port, vid, ing_map, egr_map));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_port_vlan_map_get(
    int unit,
    bcm_port_t port,
    bcm_vlan_t vid,
    int *ing_map,
    int *egr_map)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_port_vlan_map_get(unit, port, vid, ing_map, egr_map));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_map_id_resolve(
    int unit,
    int map_id,
    bcmi_ltsw_qos_map_type_t *type,
    int *ptr)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_resolve(unit, map_id, type, ptr));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_qos_map_id_construct(
    int unit,
    int ptr,
    bcmi_ltsw_qos_map_type_t type,
    int *map_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (qos_map_id_construct(unit, ptr, type, map_id));
exit:
    SHR_FUNC_EXIT();
}

void
xgs_ltsw_qos_sw_dump(int unit)
{
    qos_sw_dump(unit);
}

