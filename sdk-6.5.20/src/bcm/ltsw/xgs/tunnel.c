/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>

#include <bcm_int/ltsw/xgs/tunnel.h>
#include <bcm_int/ltsw/tunnel.h>
#include <bcm_int/ltsw/tunnel_int.h>
#include <bcm_int/ltsw/mbcm/tunnel.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/l3.h>
#include <bcm_int/ltsw/l3_intf.h>
#include <bcm_int/ltsw/index_table_mgmt.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/sbr.h>
#include <bcm_int/ltsw/qos.h>
#include <bcm_int/ltsw/types.h>

#include <shr/shr_debug.h>
#include <shr/shr_crc.h>
#include <sal/sal_time.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_TUNNEL

/******************************************************************************
 * Private functions
 */


#define XGS_TNL_IP4_FULL_MASK (0xffffffff)/* Full uint32 mask. */

/* Tunnel type for IPv4/IPv6 tunnel. */
typedef enum egr_tnl_init_type_e {
    /* IP tunnel.  */
    EgrTnlInitTypeIp = 0,

    /* IP6TOIP4 tunnel. */
    EgrTnlInitTypeIp6ToIp4 = 1,

    /* ISATAP tunnel. */
    EgrTnlInitTypeIsatap = 2,

    /* IP6TOIP4Secure tunnel. */
    EgrTnlInitTypeIp6ToIp4Secure = 3,

    /* GRE tunnel. */
    EgrTnlInitTypeGre = 4,

    /* PIMSM_DR1 tunnel. */
    EgrTnlInitTypePimsmdr1 = 5,

    /* PIMSM_DR2 tunnel. */
    EgrTnlInitTypePimsmdr2 = 6,

    /* The last mode, invalid. */
    EgrTnlInitTypeCount = 7,
} egr_tnl_init_type_t;


/* Compare result equal. */
#define BCM_L3_CMP_EQUAL     0
/* Compare result NOT equal. */
#define BCM_L3_CMP_NOT_EQUAL 2

typedef struct xgs_ltsw_tnl_term_type_s {
    /* Tunnel terminator type AUTO/CONFIG. */
#define XGS_TNL_TYPE_CONFIG 0x0
#define XGS_TNL_TYPE_AUTO 0x1
    int tnl_auto;
    /* Tunnel terminator sutbype. */
#define XGS_TNL_SUBTYPE_IP6TOIP4 0x0
#define XGS_TNL_SUBTYPE_ISATAP 0x1
#define XGS_TNL_SUBTYPE_IP6TOIP4SECURE 0x2
#define XGS_TNL_SUBTYPE_RESERVED 0x3
    int tnl_sub_type;
    /* PIM_SM tunnel flag. */
    int tnl_pim_sm;
    /* GRE tunnel flag. */
    int tnl_gre;
    /* GRE IPv4 payload allowed. */
    int tnl_gre_v4_payload;
    /* GRE IPv4 payload allowed. */
    int tnl_gre_v6_payload;
    /* Tunnel outer header is IPv6. */
    int tnl_outer_hdr_ipv6;
    /* Tunnel outer IP header protocol. */
#define XGS_TNL_PAYLOAD_PROTOCOL_IP4 0x4
#define XGS_TNL_PAYLOAD_PROTOCOL_IP6 0x29
#define XGS_TNL_PAYLOAD_PROTOCOL_GRE 0x2F
#define XGS_TNL_PAYLOAD_PROTOCOL_PIM 0x67
    int tnl_protocol;
} xgs_ltsw_tnl_term_type_t;

typedef struct tunnel_switch_control_s {
    const char *ltname;
    const char *field_str;
} tunnel_switch_control_t;

typedef struct xgs_ltsw_tunnel_info_s {
    /* Store IPv4 encap id. */
    uint16_t *ipv4_encap_id;

    /* Store IPv6 encap id. */
    uint16_t *ipv6_encap_id;
} xgs_ltsw_tunnel_info_t;

typedef struct tunnel_term_flexctr_cfg_s {
    /* Operation of flexctr fields: 0 = set, 1 = get. */
    bool op;
#define TNL_TERM_FLXCTR_OP_SET   0
#define TNL_TERM_FLXCTR_OP_GET   1

    /* Flags indicate which flexctr field to be operated. */
    uint8_t flags;
#define TNL_TERM_FLXCTR_F_ACTION     (1 << 0)
#define TNL_TERM_FLXCTR_F_INDEX      (1 << 1)

    /* Flex counter action. */
    uint32_t action;

    /*! Distinct flex counter index. */
    uint32_t index;
} tunnel_term_flexctr_cfg_t;

static xgs_ltsw_tunnel_info_t xgs_ltsw_tunnel_info[BCM_MAX_NUM_UNITS];

static const bcmint_tunnel_sc_t *tunnel_sc_info[BCM_MAX_NUM_UNITS] = {NULL};

#define TUNNEL_IPV4_ENCAP_ID(_u, _idx) \
    xgs_ltsw_tunnel_info[_u].ipv4_encap_id[_idx]

#define TUNNEL_IPV6_ENCAP_ID(_u, _idx) \
    xgs_ltsw_tunnel_info[_u].ipv6_encap_id[_idx]

/******************************************************************************
 * Private functions
 */

/*!
 * \brief Specify tunnel switch control behaviors.
 *
 * \param [in] unit Unit number.
 * \param [in] control The desired configuration parameter to modify.
 * \param [in] value The value with which to set the parameter.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
tunnel_control_set(
    int unit,
    bcmi_ltsw_tunnel_control_t control,
    uint32_t value)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;
    int rv;

    SHR_FUNC_ENTER(unit);

    if (tunnel_sc_info[unit][control].ltname == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, tunnel_sc_info[unit][control].ltname, &eh));

    rv = bcmlt_entry_field_add(eh, tunnel_sc_info[unit][control].field_str, value);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve tunnel switch control behaviors.
 *
 * \param [in] unit Unit number.
 * \param [in] control The desired configuration parameter to retrieve.
 * \param [out] value Pointer to where the retrieved value will be written.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
tunnel_control_get(
    int unit,
    bcmi_ltsw_tunnel_control_t control,
    uint32_t *value)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;
    bcmlt_field_def_t fld_def;
    uint64_t field_value;
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(value, SHR_E_PARAM);

    if (tunnel_sc_info[unit][control].ltname == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, tunnel_sc_info[unit][control].ltname,
                              &eh));

    rv = bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, tunnel_sc_info[unit][control].ltname,
                                   tunnel_sc_info[unit][control].field_str,
                                   &fld_def));
        *value = fld_def.def;
        SHR_EXIT();
    }

    rv = bcmlt_entry_field_get(eh, tunnel_sc_info[unit][control].field_str,
                               &field_value);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }
    *value = field_value;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set member ports field from an LT entry container.
 *
 * This function is used to set member ports fields from an LT entry container.
 *
 * \param [in]  unit                 Unit Number.
 * \param [in]  ent_hdl              LT entry handle.
 * \param [in]  fld_name             LT field name.
 * \param [out] member_ports         Member ports.
 *
 * \retval SHR_E_NONE                No errors.
 * \retval !SHR_E_NONE               Failure.
 */
static int
tunnel_member_ports_set(int unit, bcmlt_entry_handle_t ent_hdl,
                        const char *fld_name,
                        bcm_pbmp_t member_ports)
{
    int max_port_num = 0;
    uint64_t value = 0;
    uint32_t i = 0;

    SHR_FUNC_ENTER(unit);

    max_port_num = bcmi_ltsw_dev_logic_port_num(unit);
    for (i = 0; i < max_port_num; i++) {
        value = BCM_PBMP_MEMBER(member_ports, i) ? 1 : 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(ent_hdl, fld_name, i, &value, 1));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get member ports field from an LT entry container.
 *
 * This function is used to set member ports fields from an LT entry container.
 *
 * \param [in]  unit                 Unit Number.
 * \param [in]  ent_hdl              LT entry handle.
 * \param [in]  fld_name             LT field name.
 * \param [out] member_ports         Member ports.
 *
 * \retval SHR_E_NONE                No errors.
 * \retval !SHR_E_NONE               Failure.
 */
static int
tunnel_member_ports_get(int unit, bcmlt_entry_handle_t ent_hdl,
                        const char *fld_name,
                        bcm_pbmp_t *member_ports)
{
    int max_port_num = 0;
    uint64_t value = 0;
    uint32_t r_elem_cnt = 0, i = 0;
    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(*member_ports);
    max_port_num = bcmi_ltsw_dev_logic_port_num(unit);
    for (i = 0; i < max_port_num; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(ent_hdl, fld_name, i,
                                         &value, 1, &r_elem_cnt));
        if(value) {
            BCM_PBMP_PORT_ADD(*member_ports, i);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set tunnel initiator LT TNL_TYPE field.
 *
 * \param [in] unit Unit Number.
 * \param [in] tnl_type Tunnel initiator type.
 * \param [out] type LT field.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_type_set(int unit, bcm_tunnel_type_t tnl_type,
                     egr_tnl_init_type_t *type)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(type, SHR_E_PARAM);

    switch (tnl_type) {
    case bcmTunnelTypeIp4In4:
    case bcmTunnelTypeIp6In4:
    case bcmTunnelTypeIpAnyIn4:
        *type = EgrTnlInitTypeIp;
        break;

    case bcmTunnelTypeIp4In6:
    case bcmTunnelTypeIp6In6:
    case bcmTunnelTypeIpAnyIn6:
        *type = EgrTnlInitTypeIp;
        break;

    case bcmTunnelType6In4Uncheck:
        *type = EgrTnlInitTypeIp6ToIp4;
        break;

    case bcmTunnelTypeIsatap:
        *type = EgrTnlInitTypeIsatap;
        break;

    case bcmTunnelType6In4:
        *type = EgrTnlInitTypeIp6ToIp4Secure;
        break;

    case bcmTunnelTypeGre4In4:
    case bcmTunnelTypeGre6In4:
    case bcmTunnelTypeGreAnyIn4:
        *type = EgrTnlInitTypeGre;
        break;

    case bcmTunnelTypeGre4In6:
    case bcmTunnelTypeGre6In6:
    case bcmTunnelTypeGreAnyIn6:
        *type = EgrTnlInitTypeGre;
        break;

    case bcmTunnelTypePim6SmDr1:
        *type = EgrTnlInitTypePimsmdr1;
        break;
    case bcmTunnelTypePim6SmDr2:
        *type = EgrTnlInitTypePimsmdr2;
        break;

    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
        break;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get tunnel initiator LT TNL_TYPE field.
 *
 * \param [in] unit Unit Number.
 * \param [out] tnl_type Tunnel initiator type.
 * \param [in] ip6 IPv6 or not.
 * \param [in] type LT field.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_type_get(int unit, bcm_tunnel_type_t *tnl_type, bool ip6,
                     egr_tnl_init_type_t type)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_type, SHR_E_PARAM);

    switch (type) {
    case EgrTnlInitTypeIp:
        if (ip6) {
            *tnl_type = bcmTunnelTypeIpAnyIn6;
        } else {
            *tnl_type = bcmTunnelTypeIpAnyIn4;
        }
        break;

    case EgrTnlInitTypeIp6ToIp4:
        *tnl_type = bcmTunnelType6In4Uncheck;
        break;

    case EgrTnlInitTypeIsatap:
        *tnl_type = bcmTunnelTypeIsatap;
        break;

    case EgrTnlInitTypeIp6ToIp4Secure:
        *tnl_type = bcmTunnelType6In4;
        break;

    case EgrTnlInitTypeGre:
        if (ip6) {
            *tnl_type = bcmTunnelTypeGreAnyIn6;
        } else {
            *tnl_type = bcmTunnelTypeGreAnyIn4;
        }
        break;
    
    case EgrTnlInitTypePimsmdr1:
        *tnl_type = bcmTunnelTypePim6SmDr1;
        break;

    case EgrTnlInitTypePimsmdr2:
        *tnl_type = bcmTunnelTypePim6SmDr2;
        break;

    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
        break;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set tunnel terminator LT type fields.
 *
 * \param [in] unit Unit Number.
 * \param [in] tnl_term_info Tunnel parameters.
 * \param [out] tnl_type Tunnel initiator type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_term_type_set(int unit, bcm_tunnel_terminator_t *tnl_term_info,
                     xgs_ltsw_tnl_term_type_t *tnl_type)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);
    SHR_NULL_CHECK(tnl_type, SHR_E_PARAM);

    /* Reset destination buffer first. */
    sal_memset(tnl_type, 0, sizeof(xgs_ltsw_tnl_term_type_t));

    /* Set tunnel outer header IP version. */
    tnl_type->tnl_outer_hdr_ipv6 =
        BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_term_info->type);

    switch (tnl_term_info->type) {
    case bcmTunnelType6In4Uncheck:
        tnl_type->tnl_auto = XGS_TNL_TYPE_AUTO; /* Automatic tunnel. */
        tnl_type->tnl_sub_type = XGS_TNL_SUBTYPE_IP6TOIP4;
        /* 6over4 OR 6to4. */
        tnl_type->tnl_protocol = XGS_TNL_PAYLOAD_PROTOCOL_IP6;
        break;
    case bcmTunnelTypeIsatap:
        tnl_type->tnl_auto = XGS_TNL_TYPE_AUTO; /* Automatic tunnel. */
        tnl_type->tnl_sub_type = XGS_TNL_SUBTYPE_ISATAP;
        /* 6over4 OR 6to4. */
        tnl_type->tnl_protocol = XGS_TNL_PAYLOAD_PROTOCOL_IP6;
        break;
    case bcmTunnelType6In4:
        tnl_type->tnl_auto = XGS_TNL_TYPE_AUTO; /* Automatic tunnel. */
        tnl_type->tnl_sub_type = XGS_TNL_SUBTYPE_IP6TOIP4SECURE;
        /* 6over4 OR 6to4. */
        tnl_type->tnl_protocol = XGS_TNL_PAYLOAD_PROTOCOL_IP6;
        break;
    case bcmTunnelTypeIp4In4:
    case bcmTunnelTypeIp4In6:
        /* Configured tunnel. */
        tnl_type->tnl_auto = XGS_TNL_TYPE_CONFIG;
        /* IPv4 payload only. */
        tnl_type->tnl_sub_type = XGS_TNL_SUBTYPE_IP6TOIP4SECURE;
        /* IP in IP. */
        tnl_type->tnl_protocol = XGS_TNL_PAYLOAD_PROTOCOL_IP4;
        break;
    case bcmTunnelTypeIp6In4:
    case bcmTunnelTypeIp6In6:
        /* Configured tunnel. */
        tnl_type->tnl_auto = XGS_TNL_TYPE_CONFIG;
        /* IPv6 payload only. */
        tnl_type->tnl_sub_type = XGS_TNL_SUBTYPE_ISATAP;
        /* IPv6 */
        tnl_type->tnl_protocol = XGS_TNL_PAYLOAD_PROTOCOL_IP6;
        break;
    case bcmTunnelTypeIpAnyIn4:
    case bcmTunnelTypeIpAnyIn6:
        /* Configured tunnel. */
        tnl_type->tnl_auto = XGS_TNL_TYPE_CONFIG;
        /* IPv4 & IPv6 payload. */
        tnl_type->tnl_sub_type = XGS_TNL_SUBTYPE_RESERVED;
        /* IP in IP. */
        tnl_type->tnl_protocol = XGS_TNL_PAYLOAD_PROTOCOL_IP4;
        break;
    case bcmTunnelTypeGre4In4:
    case bcmTunnelTypeGre4In6:
        /* Configured tunnel. */
        tnl_type->tnl_auto = XGS_TNL_TYPE_CONFIG;
        /* IPv4 payload only. */
        tnl_type->tnl_sub_type = XGS_TNL_SUBTYPE_IP6TOIP4SECURE;
        tnl_type->tnl_gre = 0x1;           /* GRE tunnel. */
        tnl_type->tnl_gre_v4_payload = 0x1;/* IPv4 payload only. */
        /* Protocol GRE */
        tnl_type->tnl_protocol = XGS_TNL_PAYLOAD_PROTOCOL_GRE;
        break;
    case bcmTunnelTypeGre6In4:
    case bcmTunnelTypeGre6In6:
        /* configured tunnel. */
        tnl_type->tnl_auto = XGS_TNL_TYPE_CONFIG;
        /* IPv6 payload only. */
        tnl_type->tnl_sub_type = XGS_TNL_SUBTYPE_ISATAP;
        tnl_type->tnl_gre = 0x1;           /* GRE tunnel. */
        tnl_type->tnl_gre_v6_payload = 0x1;/* IPv4 payload only. */
        /* Protocol GRE */
        tnl_type->tnl_protocol = XGS_TNL_PAYLOAD_PROTOCOL_GRE;
        break;
    case bcmTunnelTypeGreAnyIn4:
    case bcmTunnelTypeGreAnyIn6:
        /* Configured tunnel. */
        tnl_type->tnl_auto = XGS_TNL_TYPE_CONFIG;
        /* IPv4 & IPv6 payload. */
        tnl_type->tnl_sub_type = XGS_TNL_SUBTYPE_RESERVED;
        tnl_type->tnl_gre = 0x1;           /* GRE tunnel. */
        tnl_type->tnl_gre_v4_payload = 0x1;/* IPv4 payload only. */
        tnl_type->tnl_gre_v6_payload = 0x1;/* IPv4 payload only. */
        /* Protocol GRE. */
        tnl_type->tnl_protocol = XGS_TNL_PAYLOAD_PROTOCOL_GRE;
        break;
    case bcmTunnelTypePimSmDr1:
    case bcmTunnelTypePimSmDr2:
    case bcmTunnelTypePim6SmDr1:
    case bcmTunnelTypePim6SmDr2:
        
        /* Configured tunnel. */
        tnl_type->tnl_auto = XGS_TNL_TYPE_CONFIG;
        /* IPv4 & IPv6 payload. */
        tnl_type->tnl_sub_type = XGS_TNL_SUBTYPE_RESERVED;
        tnl_type->tnl_pim_sm = 0x1;        /* PIM SM tunnel. */
        /* Protocol PIM. */
        tnl_type->tnl_protocol = XGS_TNL_PAYLOAD_PROTOCOL_PIM;
        break;
    default:
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get tunnel terminator LT type fields.
 *
 * \param [in] unit Unit Number.
 * \param [in/out] tnl_term_info Tunnel parameters.
 * \param [in] tnl_type Tunnel initiator type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_term_type_get(int unit, bcm_tunnel_terminator_t *tnl_term_info,
                     xgs_ltsw_tnl_term_type_t *tnl_type)
{
    /* Outer header is IPv6. */
    int v6;

    SHR_FUNC_ENTER(unit);

    /* Input parameters check. */
    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);
    SHR_NULL_CHECK(tnl_type, SHR_E_PARAM);

    /* Automatic tunnel */
    if (tnl_type->tnl_auto) {
        switch (tnl_type->tnl_sub_type) {
        case XGS_TNL_SUBTYPE_IP6TOIP4:
            tnl_term_info->type = bcmTunnelType6In4Uncheck;
            break;
        case XGS_TNL_SUBTYPE_ISATAP:
            tnl_term_info->type = bcmTunnelTypeIsatap;
            break;
        case XGS_TNL_SUBTYPE_IP6TOIP4SECURE:
            tnl_term_info->type = bcmTunnelType6In4;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        SHR_EXIT();
    }

    /* Configured IP tunnel. */

    /* Read outer header IP version. */
    v6 = tnl_type->tnl_outer_hdr_ipv6;

    if (tnl_type->tnl_gre) {
        if ((tnl_type->tnl_gre_v4_payload) &&
            (tnl_type->tnl_gre_v6_payload)) {
            tnl_term_info->type =
                (v6) ? bcmTunnelTypeGreAnyIn6 : bcmTunnelTypeGreAnyIn4;
        } else {
            if (tnl_type->tnl_gre_v6_payload) {
                tnl_term_info->type =
                    (v6) ? bcmTunnelTypeGre6In6 : bcmTunnelTypeGre6In4;
            } else {
                tnl_term_info->type =
                    (v6) ? bcmTunnelTypeGre4In6 : bcmTunnelTypeGre4In4;
            }
        }
    } else if (tnl_type->tnl_pim_sm) {
        tnl_term_info->type =
            (v6) ? bcmTunnelTypePim6SmDr1 : bcmTunnelTypePimSmDr1;
    } else {
        switch (tnl_type->tnl_sub_type) {
        case XGS_TNL_SUBTYPE_RESERVED:
            tnl_term_info->type =
                (v6) ? bcmTunnelTypeIpAnyIn6 : bcmTunnelTypeIpAnyIn4;
            break;
        case XGS_TNL_SUBTYPE_IP6TOIP4SECURE:
            tnl_term_info->type =
                (v6) ? bcmTunnelTypeIp4In6 : bcmTunnelTypeIp4In4;
            break;
        case XGS_TNL_SUBTYPE_ISATAP:
            tnl_term_info->type =
                (v6) ? bcmTunnelTypeIp6In6 : bcmTunnelTypeIp6In4;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Hash callback function for tunnel encap sequence profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] entries Tunnel encap sequence profile entry.
 * \param [in] entries_per_set Number of entries per set.
 * \param [out] hash Hash value returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_decap_port_profile_entry_hash_cb(
    int unit,
    void *entries,
    int entries_per_set,
    uint32_t *hash)
{
    SHR_FUNC_ENTER(unit);

    if (entries_per_set != 1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    *hash = shr_crc32(0, entries,
                      entries_per_set * sizeof(bcmi_ltsw_tunnel_decap_port_profile_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve a tunnel decap port profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] idx Index.
 * \param [out] prof_entry Profile entry returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_decap_port_profile_entry_get(
    int unit,
    int idx,
    bcmi_ltsw_tunnel_decap_port_profile_t *prof_entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_DECAP_PORT_PROFILEs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_DECAP_PORT_PROFILE_IDs, idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_member_ports_get(unit, entry_hdl, DECAP_PORTSs,
                                 &(prof_entry->decap_ports)));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Comparison callback function for tunnel encap sequence profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] entries Tunnel encap sequence profile entry.
 * \param [in] entries_per_set Number of entries per set.
 * \param [index] Index of LT entry.
 * \param [out] cmp_result Comparison result.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_decap_port_profile_entry_cmp_cb(
    int unit,
    void *entries,
    int entries_per_set,
    int index,
    int *cmp_result)
{
    bcmi_ltsw_tunnel_decap_port_profile_t prof_entry;

    SHR_FUNC_ENTER(unit);

    if (entries_per_set != 1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(cmp_result, SHR_E_PARAM);

    sal_memset(&prof_entry, 0, sizeof(prof_entry));
    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_decap_port_profile_entry_get(unit, index, &prof_entry));

    *cmp_result = sal_memcmp(entries, &prof_entry, sizeof(prof_entry));

exit:
    SHR_FUNC_EXIT();
}


/*!
 * \brief Set a tunnel encap sequence profile entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] idx Index.
 * \param [out] prof_entry Profile entry returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_decap_port_profile_entry_set(
    int unit,
    int idx,
    bcmi_ltsw_tunnel_decap_port_profile_t *prof_entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_DECAP_PORT_PROFILEs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_DECAP_PORT_PROFILE_IDs, idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_member_ports_set(unit, entry_hdl, DECAP_PORTSs,
                                 prof_entry->decap_ports));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete a tunnel encap sequence profile entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] idx Index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_decap_port_profile_entry_del(
    int unit,
    int idx)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_DECAP_PORT_PROFILEs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_DECAP_PORT_PROFILE_IDs, idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
tunnel_decap_port_profile_get(
    int unit,
    bcmi_ltsw_tunnel_decap_port_profile_t *entry,
    int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_decap_port_profile_entry_get(unit, index, entry));

exit:
    SHR_FUNC_EXIT();
}

static int
tunnel_decap_port_profile_recover(
    int unit,
    int index)
{
    uint32_t ref_cnt;
    uint64_t idx_min, idx_max;
    bcmi_ltsw_tunnel_decap_port_profile_t profile;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_DECAP_PORT_PROFILEs,
                                       TNL_DECAP_PORT_PROFILE_IDs,
                                       &idx_min, &idx_max));

    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_get(unit, BCMI_LTSW_PROFILE_TNL_DECAP_PORT,
                                         index, &ref_cnt));
    if (ref_cnt == 0) {
        /* If profile entry has not been initialized. */
        sal_memset(&profile, 0, sizeof(profile));
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_decap_port_profile_get(unit, &profile, index));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_hash_update(unit,
                                           BCMI_LTSW_PROFILE_TNL_DECAP_PORT,
                                           &profile, 1, index));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_increase(unit,
                                              BCMI_LTSW_PROFILE_TNL_DECAP_PORT,
                                              1, index, 1));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize tunnel decap port profiles.
 *
 * \param [in] unit Unit Number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_decap_port_profile_init(int unit)
{
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_TNL_DECAP_PORT;
    uint64_t idx_max, idx_min;
    int ent_idx_min, ent_idx_max;
    int idx;
    bcmi_ltsw_tunnel_decap_port_profile_t profile;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv;
    int dunit;
    uint64_t data;
    uint32_t tbl_size = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit, profile_hdl), SHR_E_NOT_FOUND);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_DECAP_PORT_PROFILEs,
                                       TNL_DECAP_PORT_PROFILE_IDs,
                                       &idx_min, &idx_max));
    ent_idx_min = (int)idx_min;
    ent_idx_max = (int)idx_max;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit, &profile_hdl,
                                    &ent_idx_min, &ent_idx_max, 1,
                                    tunnel_decap_port_profile_entry_hash_cb,
                                    tunnel_decap_port_profile_entry_cmp_cb));

    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_DECAP_PORT_PROFILEs));
    }

    if (bcmi_warmboot_get(unit)) {
        /* Recover */
        dunit = bcmi_ltsw_dev_dunit(unit);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAPs, &entry_hdl));
        while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                          BCMLT_OPCODE_TRAVERSE,
                                          BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, TNL_DECAP_PORT_PROFILE_IDs,
                                       &data));
            idx = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_decap_port_profile_recover(unit, idx));
        }

        if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
            SHR_ERR_EXIT(rv);
        }

        if (entry_hdl != BCMLT_INVALID_HDL) {
            (void)bcmlt_entry_free(entry_hdl);
            entry_hdl = BCMLT_INVALID_HDL;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAP_EMs, &entry_hdl));
        while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                          BCMLT_OPCODE_TRAVERSE,
                                          BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, TNL_DECAP_PORT_PROFILE_IDs,
                                       &data));
            idx = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_decap_port_profile_recover(unit, idx));
        }

        if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
            SHR_ERR_EXIT(rv);
        }

        if (entry_hdl != BCMLT_INVALID_HDL) {
            (void)bcmlt_entry_free(entry_hdl);
            entry_hdl = BCMLT_INVALID_HDL;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAPs, &entry_hdl));
        while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                          BCMLT_OPCODE_TRAVERSE,
                                          BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, TNL_DECAP_PORT_PROFILE_IDs,
                                       &data));
            idx = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_decap_port_profile_recover(unit, idx));
        }

        if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
            SHR_ERR_EXIT(rv);
        }

        if (entry_hdl != BCMLT_INVALID_HDL) {
            (void)bcmlt_entry_free(entry_hdl);
            entry_hdl = BCMLT_INVALID_HDL;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAP_EMs, &entry_hdl));
        while ((rv = bcmi_lt_entry_commit(unit, entry_hdl,
                                          BCMLT_OPCODE_TRAVERSE,
                                          BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, TNL_DECAP_PORT_PROFILE_IDs,
                                       &data));
            idx = data;
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_decap_port_profile_recover(unit, idx));
        }

        if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
            SHR_ERR_EXIT(rv);
        }
    } else {
        /* Reserve profile 0 for default. */
        sal_memset(&profile, 0, sizeof(profile));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_index_allocate(unit, profile_hdl, &profile, 0, 1,
                                              &idx));
        if (idx != 0) {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_decap_port_profile_entry_set(unit, idx, &profile));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_capacity_get(unit, TNL_IPV4_DECAPs, &tbl_size));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit,
             BCMI_LTSW_PROFILE_TNL_DECAP_PORT, 1, idx, tbl_size));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_capacity_get(unit, TNL_IPV4_DECAP_EMs, &tbl_size));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit,
             BCMI_LTSW_PROFILE_TNL_DECAP_PORT, 1, idx, tbl_size));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

int
tunnel_decap_port_profile_add(
    int unit,
    bcmi_ltsw_tunnel_decap_port_profile_t *entry,
    int *index)
{
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    rv = bcmi_ltsw_profile_index_allocate(unit,
                                          BCMI_LTSW_PROFILE_TNL_DECAP_PORT,
                                          entry, 0, 1, index);
    if (rv == SHR_E_EXISTS) {
        /* the same profile already exists */
        SHR_EXIT();
    }

    if (SHR_FAILURE(rv)) {
       SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_decap_port_profile_entry_set(unit, *index, entry));

exit:
    SHR_FUNC_EXIT();
}

int
tunnel_decap_port_profile_delete(
    int unit,
    int index)
{
    int rv;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_free(unit, BCMI_LTSW_PROFILE_TNL_DECAP_PORT,
                                      index);

    if (rv == SHR_E_BUSY) {
        /* profile entry is still inused */
       SHR_EXIT();
    }

    if (rv != SHR_E_NONE) {
        SHR_ERR_EXIT(rv);
    }

    /* empty the profile entry */
    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_decap_port_profile_entry_del(unit, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get hw index for tunnel initiator.
 *
 * \param [in] unit Unit Number.
 * \param [in] tnl_type Tunnel type.
 * \param [in] tnl_idx Tunnel LT index.
 * \param [in] encap_idx HW index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_encap_index_get(int unit,
                            int tnl_type,
                            int tnl_idx,
                            int *encap_idx)
{
    int dunit = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val;
    uint64_t idx_min, idx_max;
    const char *ltname, *fldname;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(encap_idx, SHR_E_PARAM);

    if (tnl_type == bcmiTunnelTypeIp6L3) {
        ltname = TNL_IPV6_ENCAPs;
        fldname = TNL_IPV6_ENCAP_IDs;
    } else {
        ltname = TNL_IPV4_ENCAPs;
        fldname = TNL_IPV4_ENCAP_IDs;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, ltname, fldname, &idx_min,
                                       &idx_max));

    if ((tnl_idx < idx_min) || (tnl_idx > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ltname, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, fldname, tnl_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, ENCAP_INDEXs, &val));
    *encap_idx = val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash of TNL_IPV4_ENCAP entries.
 *
 * \param [in] unit Unit Number.
 * \param [in] entry Entry info of bcm_tunnel_initiator_t type.
 * \param [out] hash Hash value.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_ipv4_hash(int unit, void *entry, uint16_t *hash)
{
    bcm_tunnel_initiator_t tnl_entry;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    /* Copy to local structure. */
    sal_memcpy(&tnl_entry, entry, sizeof(bcm_tunnel_initiator_t));

    /* Mask fields we don't want to include in hash. */
    tnl_entry.flags = 0;

    switch (tnl_entry.type) {
    case bcmTunnelTypeIp4In4:
    case bcmTunnelTypeIp6In4:
        tnl_entry.type = bcmTunnelTypeIpAnyIn4;
        break;

    case bcmTunnelTypeGre4In4:
    case bcmTunnelTypeGre6In4:
        tnl_entry.type = bcmTunnelTypeGreAnyIn4;
        break;

    default:
        break;
    }

    *hash = shr_crc16(0, (uint8*)&tnl_entry, sizeof(bcm_tunnel_initiator_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get TNL_IPV4_ENCAP entries from LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Entry index.
 * \param [out] entry Entry returned of bcm_tunnel_initiator_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_ipv4_get(int unit, int index, void *entry)
{
    bcm_tunnel_initiator_t *tnl_init_info = entry;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t entry_hdl2 = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t val;
    uint64_t idx_min, idx_max;
    egr_tnl_init_type_t type = -1;
    const char* symbol = NULL;
    uint32_t tmp_val;
    int hw_idx, ptr;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV4_ENCAPs,
                                       TNL_IPV4_ENCAP_IDs, &idx_min, &idx_max));

    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_IPV4_ENCAPs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_IPV4_ENCAP_IDs, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

     /* Parse LT entry content. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, TNL_TYPEs, &symbol));
    if (!sal_strcmp(symbol, "IP")) {
        type = EgrTnlInitTypeIp;
    } else if (!sal_strcmp(symbol, "IP6TOIP4")) {
        type = EgrTnlInitTypeIp6ToIp4;
    } else if (!sal_strcmp(symbol, "ISATAP")) {
        type = EgrTnlInitTypeIsatap;
    } else if (!sal_strcmp(symbol, "IP6TOIP4Secure")) {
        type = EgrTnlInitTypeIp6ToIp4Secure;
    } else if (!sal_strcmp(symbol, "GRE")) {
        type = EgrTnlInitTypeGre;
    } else if (!sal_strcmp(symbol, "PIMSM_DR1")) {
        type = EgrTnlInitTypePimsmdr1;
    } else if (!sal_strcmp(symbol, "PIMSM_DR2")) {
        type = EgrTnlInitTypePimsmdr2;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_init_type_get(unit, &(tnl_init_info->type), FALSE, type));

    /* Get destination ip. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, DST_IPV4s, &val));
    tnl_init_info->dip = (bcm_ip_t)val;

    /* Get source ip. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, SRC_IPV4s, &val));
    tnl_init_info->sip = (bcm_ip_t)val;

    /* Tunnel header DSCP select. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                      &symbol));
    if (!sal_strcmp(symbol, "FIXED")) {
        tnl_init_info->dscp_sel = bcmTunnelDscpAssign;
    } else if (!sal_strcmp(symbol, "PACKET")) {
        tnl_init_info->dscp_sel = bcmTunnelDscpPacket;
    } else if (!sal_strcmp(symbol, "MAP")) {
        tnl_init_info->dscp_sel = bcmTunnelDscpMap;

        /* Tunnel DSCP map. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, PHB_EGR_IP_INT_PRI_TO_DSCP_IDs,
                                   &val));
        ptr = (int)val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_construct(unit, ptr, bcmiQosMapTypeL3Egress,
                                            &(tnl_init_info->dscp_map)));
    }

    /* Tunnel header DSCP value. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, DSCPs, &val));
    tnl_init_info->dscp = val;

    /* IP tunnel hdr DF bit for IPv4. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, IPV4_IN_IPV4_DF_MODEs,
                                      &symbol));
    if (!sal_strcmp(symbol, "USE_INNER_DF")) {
        tnl_init_info->flags |= BCM_TUNNEL_INIT_USE_INNER_DF;
    } else if (!sal_strcmp(symbol, "SET")){
        tnl_init_info->flags |= BCM_TUNNEL_INIT_IPV4_SET_DF;
    }

    /* IP tunnel hdr DF bit for IPv6 */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, IPV6_IN_IPV4_DF_MODEs,
                                      &symbol));
    if (!sal_strcmp(symbol, "SET")) {
        tnl_init_info->flags |= BCM_TUNNEL_INIT_IPV6_SET_DF;
    }

    /* Get TTL. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, TNL_TTLs, &val));
    tnl_init_info->ttl = val;

    /* Get mac address. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, DST_MACs, &val));
    bcmi_ltsw_util_uint64_to_mac(tnl_init_info->dmac, &val);

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_control_get(unit,
                            bcmiTunnelControlTunnelIp4IdShared,
                            &tmp_val));
    if (!tmp_val) {
        dunit = bcmi_ltsw_dev_dunit(unit);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_ENCAP_FRAGMENTs, &entry_hdl2));

        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_init_encap_index_get(unit, bcmiTunnelTypeIpL3, index,
                                         &hw_idx));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl2, TNL_ENCAP_FRAGMENT_IDs, hw_idx));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl2, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl2, FRAGMENT_IDs, &val));
        tnl_init_info->ip4_id = val;
    } else {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    if (entry_hdl2 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl2);
        entry_hdl2 = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare TNL_IPV4_ENCAP entries.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Index of entry to be compared.
 * \param [in] entry Entry content of bcm_tunnel_initiator_t type.
 * \param [out] result 0 if equal, otherwise not equal.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_ipv4_cmp(int unit, int index, void *entry, int *result)
{
    bcm_tunnel_initiator_t tnl_init_tmp;
    bcm_tunnel_initiator_t *tnl_entry;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(result, SHR_E_PARAM);

    /* Compare source & destination IP. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV4_ENCAPs,
                                       TNL_IPV4_ENCAP_IDs, &idx_min,
                                       &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    sal_memset(&tnl_init_tmp, 0, sizeof(bcm_tunnel_initiator_t));

    tnl_entry = (bcm_tunnel_initiator_t*)entry;

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_init_ipv4_get(unit, index, &tnl_init_tmp));

    if ((tnl_entry->dip != tnl_init_tmp.dip) ||
        (tnl_entry->sip != tnl_init_tmp.sip)) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    if ((tnl_entry->flags & BCM_TUNNEL_INIT_IPV4_SET_DF) !=
        (tnl_init_tmp.flags & BCM_TUNNEL_INIT_IPV4_SET_DF)) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    if ((tnl_entry->dscp_sel != tnl_init_tmp.dscp_sel) ||
        (tnl_entry->dscp != tnl_init_tmp.dscp)) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    /* Compare tunnel type / ttl */
    /* Tunnel type comparison.                                  */
    /* Note: Only outer header matters in tunnel initialization */
    if (tnl_entry->type != tnl_init_tmp.type) {
        switch (tnl_entry->type) {
        case bcmTunnelTypeIp4In4:
        case bcmTunnelTypeIp6In4:
            if (bcmTunnelTypeIpAnyIn4 != tnl_init_tmp.type) {
                *result = BCM_L3_CMP_NOT_EQUAL;
                SHR_EXIT();
            }
            break;

        case bcmTunnelType6In4Uncheck:
            if (bcmTunnelType6In4Uncheck != tnl_init_tmp.type) {
                *result = BCM_L3_CMP_NOT_EQUAL;
                SHR_EXIT();
            }
            break;

        case bcmTunnelTypeIsatap:
            if (bcmTunnelTypeIsatap != tnl_init_tmp.type) {
                *result = BCM_L3_CMP_NOT_EQUAL;
                SHR_EXIT();
            }
            break;

        case bcmTunnelType6In4:
            if (bcmTunnelType6In4 != tnl_init_tmp.type) {
                *result = BCM_L3_CMP_NOT_EQUAL;
                SHR_EXIT();
            }
            break;

        case bcmTunnelTypeGre4In4:
        case bcmTunnelTypeGre6In4:
        case bcmTunnelTypeGreAnyIn4:
            if (bcmTunnelTypeGreAnyIn4 != tnl_init_tmp.type) {
                *result = BCM_L3_CMP_NOT_EQUAL;
                SHR_EXIT();
            }
            break;

        default:
            *result = BCM_L3_CMP_NOT_EQUAL;
            SHR_EXIT();
        }
    }

    if (tnl_entry->ttl != tnl_init_tmp.ttl) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    /* Compare destination mac. */
    if (sal_memcmp(tnl_entry->dmac, tnl_init_tmp.dmac,
                   sizeof(bcm_mac_t))) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    *result = BCM_L3_CMP_EQUAL;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert TNL_IPV4_ENCAP entries into LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index Entry index.
 * \param [in] entry Entry content of bcm_tunnel_initiator_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_ipv4_insert(int unit, uint32_t flags, int index,
                        void *entry)
{
    bcm_tunnel_initiator_t *tnl_init_info = entry;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t entry_hdl2 = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t val = 0;
    uint64_t idx_min, idx_max;
    egr_tnl_init_type_t type;
    uint32_t tmp_val;
    int hw_idx, ptr;
    uint16 random;
    bcmi_ltsw_qos_map_type_t qos_type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV4_ENCAPs,
                                       TNL_IPV4_ENCAP_IDs, &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_IPV4_ENCAPs, &entry_hdl));

    /*  Add TNL_IPV4_ENCAP fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_IPV4_ENCAP_IDs, index));

    /* Set destination address. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, DST_IPV4s, tnl_init_info->dip));

    /* Set source address. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, SRC_IPV4s, tnl_init_info->sip));

    /* Outer IPv4 tunnel hdr DF bit for Inner IPv4 hdr. */
    if (tnl_init_info->flags & BCM_TUNNEL_INIT_USE_INNER_DF) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, IPV4_IN_IPV4_DF_MODEs,
                                          "USE_INNER_DF"));
    } else if (tnl_init_info->flags & BCM_TUNNEL_INIT_IPV4_SET_DF) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, IPV4_IN_IPV4_DF_MODEs,
                                          "SET"));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, IPV4_IN_IPV4_DF_MODEs,
                                          "CLEAR"));
    }

    /* Outer IPv4 tunnel hdr DF bit for Inner IPv6 hdr. */
    if (tnl_init_info->flags & BCM_TUNNEL_INIT_IPV6_SET_DF) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, IPV6_IN_IPV4_DF_MODEs,
                                          "SET"));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, IPV6_IN_IPV4_DF_MODEs,
                                          "CLEAR"));
    }

    /* Set DSCP value.  */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, DSCPs, tnl_init_info->dscp));

    /* Tunnel header DSCP select. */
    if (tnl_init_info->dscp_sel == bcmTunnelDscpAssign) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                          "FIXED"));
    } else if (tnl_init_info->dscp_sel == bcmTunnelDscpPacket) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                          "PACKET"));
    } else if (tnl_init_info->dscp_sel == bcmTunnelDscpMap) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                          "MAP"));

        /* DSCP map */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_resolve(unit, tnl_init_info->dscp_map,
                                          &qos_type, &ptr));
        val = ptr;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PHB_EGR_IP_INT_PRI_TO_DSCP_IDs,
                                   val));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_TTLs, tnl_init_info->ttl));

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_init_type_set(unit, tnl_init_info->type, &type));
    if (type == EgrTnlInitTypeIp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, "IP"));
    } else if (type == EgrTnlInitTypeIp6ToIp4) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, "IP6TOIP4"));
    } else if (type == EgrTnlInitTypeIsatap) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, "ISATAP"));
    } else if (type == EgrTnlInitTypeIp6ToIp4Secure) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, "IP6TOIP4Secure"));
    } else if (type == EgrTnlInitTypeGre) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, "GRE"));
    } else if (type == EgrTnlInitTypePimsmdr1) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, "PIMSM_DR1"));
    } else if (type == EgrTnlInitTypePimsmdr2) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, "PIMSM_DR2"));
    }

    /* Set destination mac address. */
    bcmi_ltsw_util_mac_to_uint64(&val, tnl_init_info->dmac);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, DST_MACs, val));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    /* Program the IPv4 ID if not using global ID space */
    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_control_get(unit,
                            bcmiTunnelControlTunnelIp4IdShared,
                            &tmp_val));
    if (!tmp_val) {
        dunit = bcmi_ltsw_dev_dunit(unit);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_ENCAP_FRAGMENTs, &entry_hdl2));

        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_init_encap_index_get(unit, bcmiTunnelTypeIpL3, index,
                                         &hw_idx));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl2, TNL_ENCAP_FRAGMENT_IDs, hw_idx));

        if (tnl_init_info->flags & BCM_TUNNEL_INIT_IP4_ID_SET_FIXED) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl2, FRAGMENT_IDs,
                                       tnl_init_info->ip4_id));
        } else if (tnl_init_info->flags & BCM_TUNNEL_INIT_IP4_ID_SET_RANDOM) {
            random = (uint16) (sal_time_usecs() & 0xFFFF);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl2, FRAGMENT_IDs, random));
        } else {
            /* Default is random */
            random = (uint16) (sal_time_usecs() & 0xFFFF);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl2, FRAGMENT_IDs, random));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl2, BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    if (entry_hdl2 != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl2);
        entry_hdl2 = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete TNL_IPV4_ENCAP entries from LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_ipv4_del(int unit, int index)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV4_ENCAPs,
                                       TNL_IPV4_ENCAP_IDs, &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_IPV4_ENCAPs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_IPV4_ENCAP_IDs, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash of TNL_IPV6_ENCAP entries.
 *
 * \param [in] unit Unit Number.
 * \param [in] entry Entry info of bcm_tunnel_initiator_t type.
 * \param [out] hash Hash value.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_ipv6_hash(int unit, void *entry, uint16_t *hash)
{
    bcm_tunnel_initiator_t tnl_entry;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    /* Copy to local structure. */
    sal_memcpy(&tnl_entry, entry, sizeof(bcm_tunnel_initiator_t));

    /* Ignore flow label for not V6 tunnels or flow label not specified. */
    if (tnl_entry.flow_label_sel != bcmTunnelFlowLabelAssign) {
        tnl_entry.flow_label = 0;
    }

    /* Mask fields we don't want to include in hash. */
    tnl_entry.flags = 0;

    switch (tnl_entry.type) {
    case bcmTunnelTypeIp4In6:
    case bcmTunnelTypeIp6In6:
        tnl_entry.type = bcmTunnelTypeIpAnyIn6;
        break;

    case bcmTunnelTypeGre4In6:
    case bcmTunnelTypeGre6In6:
        tnl_entry.type = bcmTunnelTypeGreAnyIn6;
        break;

    default:
        break;
    }

    *hash = shr_crc16(0, (uint8*)&tnl_entry, sizeof(bcm_tunnel_initiator_t));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get TNL_IPV6_ENCAP entries from LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Entry index.
 * \param [out] entry Entry returned of bcm_tunnel_initiator_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_ipv6_get(int unit, int index, void *entry)
{
    bcm_tunnel_initiator_t *tnl_init_info = entry;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit, ptr;
    uint64_t val;
    uint64_t idx_min, idx_max;
    egr_tnl_init_type_t type = -1;
    const char* symbol = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV6_ENCAPs,
                                       TNL_IPV6_ENCAP_IDs, &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_IPV6_ENCAPs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_IPV6_ENCAP_IDs, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

     /* Parse LT entry content. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, TNL_TYPEs, &symbol));
    if (!sal_strcmp(symbol, "IP")) {
        type = EgrTnlInitTypeIp;
    } else if (!sal_strcmp(symbol, "GRE")) {
        type = EgrTnlInitTypeGre;
    } else if (!sal_strcmp(symbol, "PIMSM_DR1")) {
        type = EgrTnlInitTypePimsmdr1;
    } else if (!sal_strcmp(symbol, "PIMSM_DR2")) {
        type = EgrTnlInitTypePimsmdr2;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_init_type_get(unit, &(tnl_init_info->type), TRUE, type));

    /* Get flow label. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, FLOW_LABEL_SELECTs, &symbol));
    if (!sal_strcmp(symbol, "FLOW_LABEL")) {
        tnl_init_info->flow_label_sel = bcmTunnelFlowLabelAssign;
    } else if (!sal_strcmp(symbol, "HASH_ENTROPY")) {
        tnl_init_info->flow_label_sel = bcmTunnelFlowLabelEntropy;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, FLOW_LABELs, &val));
    tnl_init_info->flow_label = val & 0xFFFFF;

    /* Get destination ip. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, DST_IPV6_UPPERs, &val));
    bcmi_ltsw_util_uint64_to_ip6_half(&(tnl_init_info->dip6), &val, 0);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, DST_IPV6_LOWERs, &val));
    bcmi_ltsw_util_uint64_to_ip6_half(&(tnl_init_info->dip6), &val, 1);

    /* Get source ip. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_UPPERs, &val));
    bcmi_ltsw_util_uint64_to_ip6_half(&(tnl_init_info->sip6), &val, 0);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_LOWERs, &val));
    bcmi_ltsw_util_uint64_to_ip6_half(&(tnl_init_info->sip6), &val, 1);

    /* Tunnel header DSCP select. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                      &symbol));
    if (!sal_strcmp(symbol, "FIXED")) {
        tnl_init_info->dscp_sel = bcmTunnelDscpAssign;
    } else if (!sal_strcmp(symbol, "PACKET")) {
        tnl_init_info->dscp_sel = bcmTunnelDscpPacket;
    } else if (!sal_strcmp(symbol, "MAP")) {
        tnl_init_info->dscp_sel = bcmTunnelDscpMap;

        /* Tunnel DSCP map. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, PHB_EGR_IP_INT_PRI_TO_DSCP_IDs,
                                   &val));
        ptr = (int)val;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_construct(unit, ptr, bcmiQosMapTypeL3Egress,
                                            &(tnl_init_info->dscp_map)));
    }

    /* Tunnel header DSCP value. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, DSCPs, &val));
    tnl_init_info->dscp = val;


    /* Get TTL. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, HOP_LIMITs, &val));
    tnl_init_info->ttl = val;

    /* Get mac address. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, DST_MACs, &val));
    bcmi_ltsw_util_uint64_to_mac(tnl_init_info->dmac, &val);

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare TNL_IPV6_ENCAP entries.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Index of entry to be compared.
 * \param [in] entry Entry content of bcm_tunnel_initiator_t type.
 * \param [out] result 0 if equal, otherwise not equal.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_ipv6_cmp(int unit, int index, void *entry, int *result)
{
    bcm_tunnel_initiator_t tnl_init_tmp;
    bcm_tunnel_initiator_t *tnl_entry;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(result, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV6_ENCAPs,
                                       TNL_IPV6_ENCAP_IDs, &idx_min,
                                       &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    sal_memset(&tnl_init_tmp, 0, sizeof(bcm_tunnel_initiator_t));

    tnl_entry = (bcm_tunnel_initiator_t*)entry;

    /* Compare source & destination IP. */
    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_init_ipv6_get(unit, index, &tnl_init_tmp));

    if((sal_memcmp(tnl_entry->dip6, tnl_init_tmp.dip6, sizeof(bcm_ip6_t))) ||
       (sal_memcmp(tnl_entry->sip6, tnl_init_tmp.sip6, sizeof(bcm_ip6_t))) ||
       (tnl_entry->flow_label_sel != tnl_init_tmp.flow_label_sel) ||
       (tnl_entry->flow_label != tnl_init_tmp.flow_label)) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    if ((tnl_entry->flags & BCM_TUNNEL_INIT_IPV6_SET_DF) !=
        (tnl_init_tmp.flags & BCM_TUNNEL_INIT_IPV6_SET_DF)) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    if ((tnl_entry->dscp_sel != tnl_init_tmp.dscp_sel) ||
        (tnl_entry->dscp != tnl_init_tmp.dscp)) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    /* Compare tunnel type / ttl */
    /* Tunnel type comparison.                                  */
    /* Note: Only outer header matters in tunnel initialization */
    if (tnl_entry->type != tnl_init_tmp.type) {
        switch (tnl_entry->type) {
        case bcmTunnelTypeIp4In6:
        case bcmTunnelTypeIp6In6:
            if (bcmTunnelTypeIpAnyIn6 != tnl_init_tmp.type) {
                *result = BCM_L3_CMP_NOT_EQUAL;
                SHR_EXIT();
            }
            break;

        case bcmTunnelTypeGre4In6:
        case bcmTunnelTypeGre6In6:
        case bcmTunnelTypeGreAnyIn6:
            if (bcmTunnelTypeGreAnyIn6 != tnl_init_tmp.type) {
                *result = BCM_L3_CMP_NOT_EQUAL;
                SHR_EXIT();
            }
            break;

        default:
            *result = BCM_L3_CMP_NOT_EQUAL;
            SHR_EXIT();
        }
    }

    if (tnl_entry->ttl != tnl_init_tmp.ttl) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    /* Compare destination mac. */
    if (sal_memcmp(tnl_entry->dmac, tnl_init_tmp.dmac,
                   sizeof(bcm_mac_t))) {
        *result = BCM_L3_CMP_NOT_EQUAL;
        SHR_EXIT();
    }

    *result = BCM_L3_CMP_EQUAL;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert TNL_IPV6_ENCAP entries into LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index Entry index.
 * \param [in] entry Entry content of bcm_tunnel_initiator_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_ipv6_insert(int unit, uint32_t flags, int index,
                        void *entry)
{
    bcm_tunnel_initiator_t *tnl_init_info = entry;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit, ptr;
    uint64_t val = 0;
    uint64_t idx_min, idx_max;
    egr_tnl_init_type_t type;
    bcmi_ltsw_qos_map_type_t qos_type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV6_ENCAPs,
                                       TNL_IPV6_ENCAP_IDs, &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_IPV6_ENCAPs, &entry_hdl));

    /*  Add TNL_IPV6_ENCAP fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_IPV6_ENCAP_IDs, index));

    /* Set destination IPv6 address. */
    bcmi_ltsw_util_ip6_half_to_uint64(&val, &(tnl_init_info->dip6), 0);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, DST_IPV6_UPPERs, val));

    bcmi_ltsw_util_ip6_half_to_uint64(&val, &(tnl_init_info->dip6), 1);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, DST_IPV6_LOWERs, val));

    /* Set source IPv6 address. */
    bcmi_ltsw_util_ip6_half_to_uint64(&val, &(tnl_init_info->sip6), 0);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_UPPERs, val));

    bcmi_ltsw_util_ip6_half_to_uint64(&val, &(tnl_init_info->sip6), 1);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_LOWERs, val));

    /* Set DSCP value.  */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, DSCPs, tnl_init_info->dscp));

    /* Tunnel header DSCP select. */
    if (tnl_init_info->dscp_sel == bcmTunnelDscpAssign) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                          "FIXED"));
    } else if (tnl_init_info->dscp_sel == bcmTunnelDscpPacket) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                          "PACKET"));
    } else if (tnl_init_info->dscp_sel == bcmTunnelDscpMap) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, PHB_EGR_DSCP_ACTIONs,
                                          "MAP"));
        /* DSCP map */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_resolve(unit, tnl_init_info->dscp_map,
                                          &qos_type, &ptr));
        val = ptr;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PHB_EGR_IP_INT_PRI_TO_DSCP_IDs,
                                   val));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, HOP_LIMITs, tnl_init_info->ttl));

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_init_type_set(unit, tnl_init_info->type, &type));
    if (type == EgrTnlInitTypeIp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, "IP"));
    } else if (type == EgrTnlInitTypeGre) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, "GRE"));
    } else if (type == EgrTnlInitTypePimsmdr1) {
        
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, "PIMSM_DR1"));
    } else if (type == EgrTnlInitTypePimsmdr2) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TNL_TYPEs, "PIMSM_DR2"));
    }

    /* Set flow label. */
    if (tnl_init_info->flow_label_sel == bcmTunnelFlowLabelAssign) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, FLOW_LABEL_SELECTs,
                                          "FLOW_LABEL"));
        val = tnl_init_info->flow_label & 0xFFFFF;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, FLOW_LABELs, val));
    } else if (tnl_init_info->flow_label_sel == bcmTunnelFlowLabelEntropy) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, FLOW_LABEL_SELECTs,
                                          "HASH_ENTROPY"));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, FLOW_LABELs, 0));
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Set destination mac address. */
    bcmi_ltsw_util_mac_to_uint64(&val, tnl_init_info->dmac);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, DST_MACs, val));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete TNL_IPV6_ENCAP entries from LT.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_ipv6_del(int unit, int index)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV6_ENCAPs,
                                       TNL_IPV6_ENCAP_IDs, &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_IPV6_ENCAPs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_IPV6_ENCAP_IDs, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}


/*!
 * \brief Recover index table mgmt bookkeepings for tunnel initiator.
 *
 * \param [in] unit Unit Number.
 * \param [in] ip6 IPv6 or not.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_recover(int unit, int index, bool ip6)
{
    bcm_tunnel_initiator_t tnl_init_info;

    SHR_FUNC_ENTER(unit);

    bcm_tunnel_initiator_t_init(&tnl_init_info);
    if (ip6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_init_ipv6_get(unit, index, &tnl_init_info));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_init_ipv4_get(unit, index, &tnl_init_info));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_hash_update(unit,
         ip6? BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL : BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
         ip6? BCMI_EGR_L3_IP6_TNL_USER_ID_IP6_TNL : BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
         &tnl_init_info, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_increase(unit,
         ip6? BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL : BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
         ip6? BCMI_EGR_L3_IP6_TNL_USER_ID_IP6_TNL : BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
         index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check whether used for tunnel initiator.
 *
 * \param [in] unit Unit Number.
 * \param [in] tnl_type Tunnel type.
 * \param [in] tnl_idx Tunnel LT index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_init_used_get(int unit, int tnl_type, int tnl_idx)
{
    SHR_FUNC_ENTER(unit);

    if ((tnl_type != bcmiTunnelTypeIpL3) &&
        (tnl_type != bcmiTunnelTypeIp6L3)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (tnl_type == bcmiTunnelTypeIp6L3) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit,
                 BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO,
                 BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                 BCMI_EGR_L3_IP6_TNL_USER_ID_IP6_TNL,
                 NULL, tnl_idx));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit,
                 BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO,
                 BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                 BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                 NULL, tnl_idx));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct tunnel terminator LT field with given fields.
 *
 * \param [in] unit Unit Number.
 * \param [in] tnl_term_info Tunnel terminator info.
 * \param [in] entry_hdl LT entry handler.
 * \param [in] key Construct key or not.
 * \param [in] data Construct data or not.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_term_entry_init(int unit,
                       bcm_tunnel_terminator_t *tnl_term_info,
                       bcmlt_entry_handle_t entry_hdl,
                       bool key, bool data)
{
    xgs_ltsw_tnl_term_type_t tnl_type;
    uint64_t sip_data;
    uint64_t sip_mask;
    uint64_t dip_data;
    uint64_t dip_mask;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_term_type_set(unit, tnl_term_info, &tnl_type));

    if (key) {
        if (tnl_type.tnl_outer_hdr_ipv6) {
            /* IPv6 */
            /* Apply mask on source address. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_mask6_apply(tnl_term_info->sip6_mask,
                                          tnl_term_info->sip6));
            bcmi_ltsw_util_ip6_half_to_uint64
                (&sip_data, &(tnl_term_info->sip6), 0);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_UPPERs, sip_data));
            bcmi_ltsw_util_ip6_half_to_uint64
                (&sip_data, &(tnl_term_info->sip6), 1);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_LOWERs, sip_data));

            bcmi_ltsw_util_ip6_half_to_uint64
                (&sip_mask, &(tnl_term_info->sip6_mask), 0);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_MASK_UPPERs,
                                       sip_mask));
            bcmi_ltsw_util_ip6_half_to_uint64
                (&sip_mask, &(tnl_term_info->sip6_mask), 1);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_MASK_LOWERs,
                                       sip_mask));

            bcmi_ltsw_util_ip6_half_to_uint64
                (&dip_data, &(tnl_term_info->dip6), 0);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV6_UPPERs, dip_data));
            bcmi_ltsw_util_ip6_half_to_uint64
                (&dip_data, &(tnl_term_info->dip6), 1);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV6_LOWERs, dip_data));

            bcmi_ltsw_util_ip6_half_to_uint64
                (&dip_mask, &(tnl_term_info->dip6_mask), 0);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV6_MASK_UPPERs,
                                       dip_mask));
            bcmi_ltsw_util_ip6_half_to_uint64
                (&dip_mask, &(tnl_term_info->dip6_mask), 1);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV6_MASK_LOWERs,
                                       dip_mask));
        } else {
            /* IPv4 */
            tnl_term_info->sip &= tnl_term_info->sip_mask;

            /* Set source ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV4s,
                                       tnl_term_info->sip));

            /* Set source subnet mask. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV4_MASKs,
                                       tnl_term_info->sip_mask));

            /* Set destination ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV4s,
                                       tnl_term_info->dip));

            /* Set destination subnet mask. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV4_MASKs,
                                       tnl_term_info->dip_mask));
        }

        /* Set the PROTOCOL field */
        if ((tnl_term_info->type == bcmTunnelTypeIpAnyIn4) ||
            (tnl_term_info->type == bcmTunnelTypeIpAnyIn6))
        {
           /* Set PROTOCOL and PROTOCOL_MASK field to zero for
            * IpAnyInx tunnel type.
            */
           SHR_IF_ERR_VERBOSE_EXIT
               (bcmlt_entry_field_add(entry_hdl, IP_PROTOCOLs, 0x0));
           SHR_IF_ERR_VERBOSE_EXIT
               (bcmlt_entry_field_add(entry_hdl, IP_PROTOCOL_MASKs, 0x0));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_PROTOCOLs,
                                       tnl_type.tnl_protocol));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IP_PROTOCOL_MASKs, 0xff));
        }
    }

    if (data) {
        /* Set tunnel subtype. */
        if (tnl_type.tnl_sub_type == XGS_TNL_SUBTYPE_IP6TOIP4) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, TYPEs, "IP6TOIP4"));
        } else if (tnl_type.tnl_sub_type == XGS_TNL_SUBTYPE_ISATAP) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, TYPEs, "ISATAP"));
        } else if (tnl_type.tnl_sub_type == XGS_TNL_SUBTYPE_IP6TOIP4SECURE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, TYPEs,
                                              "IP6TOIP4SECURE"));
        } else if (tnl_type.tnl_sub_type == XGS_TNL_SUBTYPE_RESERVED) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, TYPEs, "RESERVED"));
        }

        /* Set tunnel type. */
        if (tnl_type.tnl_auto == XGS_TNL_TYPE_CONFIG) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, MODEs, "CONFIG"));
        } else if (tnl_type.tnl_auto == XGS_TNL_TYPE_AUTO) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, MODEs, "AUTO"));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, BFDs, 0));

        /* Save VID for IPMC lookup. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, L3_IIF_IDs,
                                   tnl_term_info->vlan));

        /* Set GRE payload */
        if (tnl_type.tnl_gre) {
            /* GRE IPv6 payload is allowed. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IPV6_GRE_PAYLOADs,
                                       tnl_type.tnl_gre_v6_payload));

            /* GRE IPv4 payload is allowed. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IPV4_GRE_PAYLOADs,
                                       tnl_type.tnl_gre_v4_payload));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse tunnel terminator LT field.
 *
 * \param [in] unit Unit Number.
 * \param [out] tnl_term_info Tunnel terminator info.
 * \param [in] entry_hdl LT entry handler.
 * \param [in] ip6 IPv6 entry or not.
 * \param [in] key Parse key or not.
 * \param [in] data Parse data or not.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_term_entry_parse(int unit,
                        bcm_tunnel_terminator_t *tnl_term_info,
                        bcmlt_entry_handle_t entry_hdl, bool ip6,
                        bool key_parse, bool data_parse)
{
    bcmi_ltsw_tunnel_decap_port_profile_t profile;
    xgs_ltsw_tnl_term_type_t tnl_type;
    const char* symbol = NULL;
    uint64_t sip_data;
    uint64_t sip_mask;
    uint64_t dip_data;
    uint64_t dip_mask;
    uint64_t tmp_val;
    int prof_id;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    sal_memset(&tnl_type, 0, sizeof(xgs_ltsw_tnl_term_type_t));

    if (key_parse) {
        if (ip6) {
            /* IPv6 */
            /* Get source ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_UPPERs, &sip_data));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->sip6), &sip_data, 0);

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_LOWERs, &sip_data));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->sip6), &sip_data, 1);

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_MASK_UPPERs,
                                       &sip_mask));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->sip6_mask), &sip_mask, 0);

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_MASK_LOWERs,
                                       &sip_mask));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->sip6_mask), &sip_mask, 1);

            /* Get destination ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DST_IPV6_UPPERs, &dip_data));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->dip6), &dip_data, 0);

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DST_IPV6_LOWERs, &dip_data));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->dip6), &dip_data, 1);

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DST_IPV6_MASK_UPPERs,
                                       &dip_mask));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->dip6_mask), &dip_mask, 0);

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DST_IPV6_MASK_LOWERs,
                                       &dip_mask));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->dip6_mask), &dip_mask, 1);
        } else {
            /* IPv4 */
            /* Get source ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, SRC_IPV4s, &sip_data));
            tnl_term_info->sip = (bcm_ip_t)sip_data;

            /* Source subnet mask. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, SRC_IPV4_MASKs, &sip_mask));
            tnl_term_info->sip_mask = (bcm_ip_t)sip_mask;

            /* Get destination ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DST_IPV4s, &dip_data));
            tnl_term_info->dip = (bcm_ip_t)dip_data;

            /* Destination subnet mask. */
            tnl_term_info->dip_mask = XGS_TNL_IP4_FULL_MASK;
        }

        /* Get the protocol field and make some decisions. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, IP_PROTOCOLs, &tmp_val));
        tnl_type.tnl_protocol = tmp_val;
        switch (tnl_type.tnl_protocol) {
            case XGS_TNL_PAYLOAD_PROTOCOL_GRE:
                tnl_type.tnl_gre = 1;
                break;
            case XGS_TNL_PAYLOAD_PROTOCOL_PIM:
                tnl_type.tnl_pim_sm = 1;
            default:
                break;
        }
    }

    if (data_parse) {
        /* Get tunnel subtype. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, TYPEs, &symbol));
        if (!sal_strcmp(symbol, "IP6TOIP4")) {
            tnl_type.tnl_sub_type = XGS_TNL_SUBTYPE_IP6TOIP4;
        } else if (!sal_strcmp(symbol, "ISATAP")){
            tnl_type.tnl_sub_type = XGS_TNL_SUBTYPE_ISATAP;
        } else if (!sal_strcmp(symbol, "IP6TOIP4SECURE")){
            tnl_type.tnl_sub_type = XGS_TNL_SUBTYPE_IP6TOIP4SECURE;
        } else if (!sal_strcmp(symbol, "RESERVED")){
            tnl_type.tnl_sub_type = XGS_TNL_SUBTYPE_RESERVED;
        }

        /* Get tunnel type. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, MODEs, &symbol));
        if (!sal_strcmp(symbol, "CONFIG")) {
            tnl_type.tnl_auto  = XGS_TNL_TYPE_CONFIG;
        } else if (!sal_strcmp(symbol, "AUTO")){
            tnl_type.tnl_auto = XGS_TNL_TYPE_AUTO;
        }

        /* Copy DSCP from outer header flag. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, TNL_HDR_DSCP_FOR_PHBs, &tmp_val));
        if (tmp_val) {
            tnl_term_info->flags |= BCM_TUNNEL_TERM_USE_OUTER_DSCP;
        }

        /* Copy TTL from outer header flag. */
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, USE_TNL_HDR_HOP_LIMITs,
                                       &tmp_val));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, USE_TNL_HDR_TTLs, &tmp_val));
        }
        if (tmp_val) {
            tnl_term_info->flags |= BCM_TUNNEL_TERM_USE_OUTER_TTL;
        }

        /* Keep inner header DSCP flag. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, KEEP_PAYLOAD_DSCPs, &tmp_val));
        if (tmp_val) {
            tnl_term_info->flags |= BCM_TUNNEL_TERM_KEEP_INNER_DSCP;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, TNL_DECAP_PORT_PROFILE_IDs,
                                   &tmp_val));
        prof_id = (int)tmp_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_decap_port_profile_get(unit, &profile, prof_id));
        BCM_PBMP_ASSIGN(tnl_term_info->pbmp, profile.decap_ports);

        /* Tunnel or IPMC lookup vlan id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L3_IIF_IDs, &tmp_val));
        tnl_term_info->vlan = tmp_val;

        /* Get Tunnel class id for VFP match */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, CLASS_IDs, &tmp_val));
        tnl_term_info->tunnel_class = tmp_val;

        /* Get gre IPv4 payload allowed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, IPV4_GRE_PAYLOADs, &tmp_val));
        tnl_type.tnl_gre_v4_payload = tmp_val;

        /* Get gre IPv6 payload allowed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, IPV6_GRE_PAYLOADs, &tmp_val));
        tnl_type.tnl_gre_v6_payload = tmp_val;
    }

    if (key_parse && data_parse) {
        /* Get tunnel type. */
        tnl_type.tnl_outer_hdr_ipv6 = ip6;
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_type_get(unit, tnl_term_info, &tnl_type));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add tunnel terminator LT field with given fields.
 *
 * \param [in] unit Unit Number.
 * \param [in] tnl_term_info Tunnel terminator info.
 * \param [in] entry_hdl LT entry handler.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_term_entry_add(int unit,
                      bcm_tunnel_terminator_t *tnl_term_info,
                      bcmlt_entry_handle_t entry_hdl)
{
    int dunit = 0;
    xgs_ltsw_tnl_term_type_t tnl_type;
    uint64_t data;
    uint64_t tmp_val;
    bcmlt_entry_handle_t tmp_entry_hdl = BCMLT_INVALID_HDL;
    bcmi_ltsw_tunnel_decap_port_profile_t profile;
    int prof_id;
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    /* Get tunnel type & sub_type. */
    BCM_IF_ERROR_RETURN
        (tunnel_term_type_set(unit, tnl_term_info, &tnl_type));

    if (tnl_term_info->flags & BCM_TUNNEL_REPLACE) {
        dunit = bcmi_ltsw_dev_dunit(unit);
        if (tnl_type.tnl_outer_hdr_ipv6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAPs,
                                      &tmp_entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAPs,
                                      &tmp_entry_hdl));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_entry_init(unit, tnl_term_info, tmp_entry_hdl, TRUE,
                                    FALSE));
        rv = bcmi_lt_entry_commit(unit, tmp_entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL);
        if (SHR_SUCCESS(rv)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(tmp_entry_hdl,
                                       TNL_DECAP_PORT_PROFILE_IDs, &data));
            prof_id = (int)data;
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_decap_port_profile_delete(unit, prof_id));
        }
    }

    /* Set flag to use outer header DSCP value or not. */
    tmp_val = (tnl_term_info->flags & BCM_TUNNEL_TERM_USE_OUTER_DSCP) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_HDR_DSCP_FOR_PHBs, tmp_val));

    /* Set flag to use outer header TTL value or not. */
    tmp_val = (tnl_term_info->flags & BCM_TUNNEL_TERM_USE_OUTER_TTL) ? 1 : 0;
    if (tnl_type.tnl_outer_hdr_ipv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, USE_TNL_HDR_HOP_LIMITs, tmp_val));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, USE_TNL_HDR_TTLs, tmp_val));
    }

    /* Set flag to preserve inner header DSCP value or not. */
    tmp_val = (tnl_term_info->flags & BCM_TUNNEL_TERM_KEEP_INNER_DSCP) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, KEEP_PAYLOAD_DSCPs, tmp_val));

    sal_memset(&profile, 0, sizeof(profile));
    BCM_PBMP_ASSIGN(profile.decap_ports, tnl_term_info->pbmp);
    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_decap_port_profile_add(unit, &profile, &prof_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_DECAP_PORT_PROFILE_IDs, prof_id));

    /* Set vlan id for ipmc lookup.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, L3_IIF_IDs,
                               tnl_term_info->vlan));

    /* Set Tunnel class id for VFP match. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CLASS_IDs,
                               tnl_term_info->tunnel_class));

exit:
    if (tmp_entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(tmp_entry_hdl);
        tmp_entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct tunnel terminator EM LT field with given fields.
 *
 * \param [in] unit Unit Number.
 * \param [in] tnl_term_info Tunnel terminator info.
 * \param [in] entry_hdl LT entry handler.
 * \param [in] key Construct key or not.
 * \param [in] data Construct data or not.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_term_em_entry_init(int unit,
                          bcm_tunnel_terminator_t *tnl_term_info,
                          bcmlt_entry_handle_t entry_hdl,
                          bool key, bool data)
{
    xgs_ltsw_tnl_term_type_t tnl_type;
    uint64_t sip_data;
    uint64_t dip_data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    if ((tnl_term_info->type == bcmTunnelTypeIpAnyIn4) ||
        (tnl_term_info->type == bcmTunnelTypeIpAnyIn6)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Get tunnel type & sub_type. */
    BCM_IF_ERROR_RETURN
        (tunnel_term_type_set(unit, tnl_term_info, &tnl_type));

    if (key) {
        if (tnl_type.tnl_outer_hdr_ipv6) {
            /* IPv6 */
            bcmi_ltsw_util_ip6_half_to_uint64
                (&sip_data, &(tnl_term_info->sip6), 0);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_UPPERs, sip_data));

            bcmi_ltsw_util_ip6_half_to_uint64
                (&sip_data, &(tnl_term_info->sip6), 1);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV6_LOWERs, sip_data));

            bcmi_ltsw_util_ip6_half_to_uint64
                (&dip_data, &(tnl_term_info->dip6), 0);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV6_UPPERs, dip_data));

            bcmi_ltsw_util_ip6_half_to_uint64
                (&dip_data, &(tnl_term_info->dip6), 1);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV6_LOWERs, dip_data));
        } else {
            /* IPv4 */
            /* Set source ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, SRC_IPV4s,
                                        tnl_term_info->sip));

            /* Set destination ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, DST_IPV4s,
                                       tnl_term_info->dip));
        }

        /* Set the PROTOCOL field */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, IP_PROTOCOLs,
                                   tnl_type.tnl_protocol));
    }

    if (data) {
        if (tnl_type.tnl_sub_type == XGS_TNL_SUBTYPE_IP6TOIP4) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, TYPEs, "IP6TOIP4"));
        } else if (tnl_type.tnl_sub_type == XGS_TNL_SUBTYPE_ISATAP) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, TYPEs, "ISATAP"));
        } else if (tnl_type.tnl_sub_type == XGS_TNL_SUBTYPE_IP6TOIP4SECURE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, TYPEs,
                                              "IP6TOIP4SECURE"));
        } else if (tnl_type.tnl_sub_type == XGS_TNL_SUBTYPE_RESERVED) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, TYPEs, "RESERVED"));
        }

        if (tnl_type.tnl_auto == XGS_TNL_TYPE_CONFIG) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, MODEs, "CONFIG"));
        } else if (tnl_type.tnl_auto == XGS_TNL_TYPE_AUTO) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, MODEs, "AUTO"));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, BFDs, 0));

        /* Set GRE payload */
        if (tnl_type.tnl_gre) {
            /* GRE IPv6 payload is allowed. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IPV6_GRE_PAYLOADs,
                                       tnl_type.tnl_gre_v6_payload));

            /* GRE IPv4 payload is allowed. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, IPV4_GRE_PAYLOADs,
                                       tnl_type.tnl_gre_v4_payload));
        }

        /* Save VID for IPMC lookup. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, L3_IIF_IDs,
                                   tnl_term_info->vlan));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse tunnel terminator EM LT field.
 *
 * \param [in] unit Unit Number.
 * \param [out] tnl_term_info Tunnel terminator info.
 * \param [in] entry_hdl LT entry handler.
 * \param [in] ip6 IPv6 entry or not.
 * \param [in] key Parse key or not.
 * \param [in] data Parse data or not.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_term_em_entry_parse(int unit,
                           bcm_tunnel_terminator_t *tnl_term_info,
                           bcmlt_entry_handle_t entry_hdl, bool ip6,
                           bool key_parse, bool data_parse)
{
    bcmi_ltsw_tunnel_decap_port_profile_t profile;
    xgs_ltsw_tnl_term_type_t tnl_type;
    const char* symbol = NULL;
    uint64_t sip_data;
    uint64_t dip_data;
    uint64_t tmp_val;
    int prof_id;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    sal_memset(&tnl_type, 0, sizeof(xgs_ltsw_tnl_term_type_t));

    if (key_parse) {
        if (ip6) {
            /* IPv6 */
            /* Get source ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_UPPERs, &sip_data));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->sip6), &sip_data, 0);

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, SRC_IPV6_LOWERs, &sip_data));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->sip6), &sip_data, 1);

            /* Get destination ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DST_IPV6_UPPERs, &dip_data));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->dip6), &dip_data, 0);

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DST_IPV6_LOWERs, &dip_data));
            bcmi_ltsw_util_uint64_to_ip6_half
                (&(tnl_term_info->dip6), &dip_data, 1);
        } else {
            /* IPv4 */
            /* Get source ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, SRC_IPV4s, &sip_data));
            tnl_term_info->sip = (bcm_ip_t)sip_data;

            /* Get destination ip. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DST_IPV4s, &dip_data));
            tnl_term_info->dip = (bcm_ip_t)dip_data;

            /* Destination subnet mask. */
            tnl_term_info->dip_mask = XGS_TNL_IP4_FULL_MASK;
        }

        /* Get the protocol field and make some decisions. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, IP_PROTOCOLs, &tmp_val));
        tnl_type.tnl_protocol = tmp_val;
        switch (tnl_type.tnl_protocol) {
            case XGS_TNL_PAYLOAD_PROTOCOL_GRE:
                tnl_type.tnl_gre = 1;
                break;
            case XGS_TNL_PAYLOAD_PROTOCOL_PIM:
                tnl_type.tnl_pim_sm = 1;
            default:
                break;
        }
    }

    if (data_parse) {
        /* Get tunnel subtype. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, TYPEs, &symbol));
        if (!sal_strcmp(symbol, "IP6TOIP4")) {
            tnl_type.tnl_sub_type = XGS_TNL_SUBTYPE_IP6TOIP4;
        } else if (!sal_strcmp(symbol, "ISATAP")){
            tnl_type.tnl_sub_type = XGS_TNL_SUBTYPE_ISATAP;
        } else if (!sal_strcmp(symbol, "IP6TOIP4SECURE")){
            tnl_type.tnl_sub_type = XGS_TNL_SUBTYPE_IP6TOIP4SECURE;
        } else if (!sal_strcmp(symbol, "RESERVED")){
            tnl_type.tnl_sub_type = XGS_TNL_SUBTYPE_RESERVED;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, TNL_DECAP_PORT_PROFILE_IDs,
                                   &tmp_val));
        prof_id = (int)tmp_val;
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_decap_port_profile_get(unit, &profile, prof_id));
        BCM_PBMP_ASSIGN(tnl_term_info->pbmp, profile.decap_ports);

        /* Get tunnel type. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, MODEs, &symbol));
        if (!sal_strcmp(symbol, "CONFIG")) {
            tnl_type.tnl_auto  = XGS_TNL_TYPE_CONFIG;
        } else if (!sal_strcmp(symbol, "AUTO")){
            tnl_type.tnl_auto = XGS_TNL_TYPE_AUTO;
        }

        /* Copy DSCP from outer header flag. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, TNL_HDR_DSCP_FOR_PHBs, &tmp_val));
        if (tmp_val) {
            tnl_term_info->flags |= BCM_TUNNEL_TERM_USE_OUTER_DSCP;
        }

        /* Copy TTL from outer header flag. */
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, USE_TNL_HDR_HOP_LIMITs,
                                       &tmp_val));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, USE_TNL_HDR_TTLs, &tmp_val));
        }
        if (tmp_val) {
            tnl_term_info->flags |= BCM_TUNNEL_TERM_USE_OUTER_TTL;
        }

        /* Keep inner header DSCP flag. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, KEEP_PAYLOAD_DSCPs, &tmp_val));
        if (tmp_val) {
            tnl_term_info->flags |= BCM_TUNNEL_TERM_KEEP_INNER_DSCP;
        }

        /* Tunnel or IPMC lookup vlan id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, L3_IIF_IDs, &tmp_val));
        tnl_term_info->vlan = tmp_val;

        /* Get Tunnel class id for VFP match */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, CLASS_IDs, &tmp_val));
        tnl_term_info->tunnel_class = tmp_val;

        /* Get gre IPv4 payload allowed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, IPV4_GRE_PAYLOADs, &tmp_val));
        tnl_type.tnl_gre_v4_payload = tmp_val;

        /* Get gre IPv6 payload allowed. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, IPV6_GRE_PAYLOADs, &tmp_val));
        tnl_type.tnl_gre_v6_payload = tmp_val;
    }

    if (key_parse && data_parse) {
        /* Get tunnel type. */
        tnl_type.tnl_outer_hdr_ipv6 = ip6;
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_type_get(unit, tnl_term_info, &tnl_type));
    }

    tnl_term_info->flags |= BCM_TUNNEL_TERM_EM;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add tunnel terminator EM LT field with given fields.
 *
 * \param [in] unit Unit Number.
 * \param [in] tnl_term_info Tunnel terminator info.
 * \param [in] entry_hdl LT entry handler.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
tunnel_term_em_entry_add(int unit,
                         bcm_tunnel_terminator_t *tnl_term_info,
                         bcmlt_entry_handle_t entry_hdl)
{
    int dunit = 0;
    xgs_ltsw_tnl_term_type_t tnl_type;
    uint64_t data;
    uint64_t tmp_val;
    bcmlt_entry_handle_t tmp_entry_hdl = BCMLT_INVALID_HDL;
    bcmi_ltsw_tunnel_decap_port_profile_t profile;
    int prof_id;
    int rv;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    /* Get tunnel type & sub_type. */
    BCM_IF_ERROR_RETURN
        (tunnel_term_type_set(unit, tnl_term_info, &tnl_type));

    if (tnl_term_info->flags & BCM_TUNNEL_REPLACE) {
        dunit = bcmi_ltsw_dev_dunit(unit);
        if (tnl_type.tnl_outer_hdr_ipv6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAP_EMs,
                                      &tmp_entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAP_EMs,
                                      &tmp_entry_hdl));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_em_entry_init(unit, tnl_term_info, tmp_entry_hdl, TRUE,
                                       FALSE));
        rv = bcmi_lt_entry_commit(unit, tmp_entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL);
        if (SHR_SUCCESS(rv)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(tmp_entry_hdl, TNL_DECAP_PORT_PROFILE_IDs,
                                       &data));
            prof_id = (int)data;
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_decap_port_profile_delete(unit, prof_id));
        }
    }

    /* Set flag to use outer header DSCP value or not. */
    tmp_val = (tnl_term_info->flags & BCM_TUNNEL_TERM_USE_OUTER_DSCP) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_HDR_DSCP_FOR_PHBs, tmp_val));

    /* Set flag to use outer header TTL value or not. */
    tmp_val = (tnl_term_info->flags & BCM_TUNNEL_TERM_USE_OUTER_TTL) ? 1 : 0;
    if (tnl_type.tnl_outer_hdr_ipv6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, USE_TNL_HDR_HOP_LIMITs, tmp_val));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, USE_TNL_HDR_TTLs, tmp_val));
    }

    /* Set flag to preserve inner header DSCP value or not. */
    tmp_val = (tnl_term_info->flags & BCM_TUNNEL_TERM_KEEP_INNER_DSCP) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, KEEP_PAYLOAD_DSCPs, tmp_val));

    sal_memset(&profile, 0, sizeof(profile));
    BCM_PBMP_ASSIGN(profile.decap_ports, tnl_term_info->pbmp);
    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_decap_port_profile_add(unit, &profile,&prof_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TNL_DECAP_PORT_PROFILE_IDs, prof_id));

    /* Sev VID for IPMC lookup.*/
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, L3_IIF_IDs,
                               tnl_term_info->vlan));

    /* Set Tunnel class id for VFP match. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CLASS_IDs,
                               tnl_term_info->tunnel_class));

exit:
    if (tmp_entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(tmp_entry_hdl);
        tmp_entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Operate flex counter related fields of tunnel decap entry.
 *
 * \param [in] unit Unit number.
 * \param [in] terminator Tunnel terminator.
 * \param [in/out] flexctr Pointer to flex counter config info.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
tunnel_term_flexctr_op(
    int unit,
    bcm_tunnel_terminator_t *terminator,
    tunnel_term_flexctr_cfg_t *flexctr)
{
    int dunit = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val;
    int ip6;

    SHR_FUNC_ENTER(unit);

    ip6 = BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(terminator->type);
    dunit = bcmi_ltsw_dev_dunit(unit);

    if (ip6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAPs, &entry_hdl));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAPs, &entry_hdl));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_term_entry_init(unit, terminator, entry_hdl, TRUE,
                                FALSE));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    if (flexctr->op == TNL_TERM_FLXCTR_OP_SET) {
        if (flexctr->flags & TNL_TERM_FLXCTR_F_ACTION) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CTR_ING_EFLEX_ACTIONs,
                                       flexctr->action));
        }

        if (flexctr->flags & TNL_TERM_FLXCTR_F_INDEX) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, CTR_ING_EFLEX_OBJECTs,
                                       flexctr->index));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    } else if (flexctr->op == TNL_TERM_FLXCTR_OP_GET) {
        if (flexctr->flags & TNL_TERM_FLXCTR_F_ACTION) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CTR_ING_EFLEX_ACTIONs, &val));
            flexctr->action = val;
        }

        if (flexctr->flags & TNL_TERM_FLXCTR_F_INDEX) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CTR_ING_EFLEX_OBJECTs, &val));
            flexctr->index = val;
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_tunnel_init(int unit)
{
    int warmboot; /* during warmboot */
    uint64_t idx_min, idx_max;
    bcmi_ltsw_idx_tbl_user_info_t user_info;
    bcmi_ltsw_idx_tbl_lt_info_t lt_info;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    xgs_ltsw_tunnel_info_t *info = &xgs_ltsw_tunnel_info[unit];
    int dunit;
    int idx;
    int rv;
    uint64_t val, sz;

    SHR_FUNC_ENTER(unit);

    sal_memset(info, 0, sizeof(xgs_ltsw_tunnel_info_t));

    /* IPv4 encap id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV4_ENCAPs,
                                       TNL_IPV4_ENCAP_IDs, &idx_min, &idx_max));

    sz = (idx_max + 1) * sizeof(uint16_t);
    SHR_ALLOC(info->ipv4_encap_id, sz, "bcmXgsIPv4EncapIdInfo");
    SHR_NULL_CHECK(info->ipv4_encap_id, SHR_E_MEMORY);
    sal_memset(info->ipv4_encap_id, 0, sz);

    /* IPv6 encap id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV6_ENCAPs,
                                       TNL_IPV6_ENCAP_IDs, &idx_min, &idx_max));

    sz = (idx_max + 1) * sizeof(uint16_t);
    SHR_ALLOC(info->ipv6_encap_id, sz, "bcmXgsIPv6EncapIdInfo");
    SHR_NULL_CHECK(info->ipv6_encap_id, SHR_E_MEMORY);
    sal_memset(info->ipv6_encap_id, 0, sz);

    warmboot = bcmi_warmboot_get(unit);

    if (!warmboot) {
        /* Reset all LTs */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_IPV4_ENCAPs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_IPV6_ENCAPs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_IPV4_DECAPs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_IPV4_DECAP_EMs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_IPV6_DECAPs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_IPV6_DECAP_EMs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_ENCAP_FRAGMENTs));
    }

    /* Tunnel switch control info init. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_tunnel_sc_info_get(unit, &tunnel_sc_info[unit]));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV4_ENCAPs,
                                       TNL_IPV4_ENCAP_IDs,
                                       &idx_min, &idx_max));
    sal_memset(&lt_info, 0, sizeof(lt_info));
    /* Max number of users of this LT. */
    lt_info.user_cnt  = BCMI_EGR_L3_TNL_USER_ID_CNT;
    lt_info.tbl_name  = TNL_IPV4_ENCAPs;
    lt_info.idx_field = TNL_IPV4_ENCAP_IDs;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = (uint32_t)idx_min;
    user_info.idx_max     = (uint32_t)idx_max;
    user_info.func_hash   = tunnel_init_ipv4_hash;
    user_info.func_cmp    = tunnel_init_ipv4_cmp;
    user_info.func_insert = tunnel_init_ipv4_insert;
    user_info.func_del    = tunnel_init_ipv4_del;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                    BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                                    &lt_info, &user_info));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV6_ENCAPs, TNL_IPV6_ENCAP_IDs,
                                       &idx_min, &idx_max));
    sal_memset(&lt_info, 0, sizeof(lt_info));
    /* Max number of users of this LT. */
    lt_info.user_cnt  = BCMI_EGR_L3_IP6_TNL_USER_ID_CNT;
    lt_info.tbl_name  = TNL_IPV6_ENCAPs;
    lt_info.idx_field = TNL_IPV6_ENCAP_IDs;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = (uint32_t)idx_min;
    user_info.idx_max     = (uint32_t)idx_max;
    user_info.func_hash   = tunnel_init_ipv6_hash;
    user_info.func_cmp    = tunnel_init_ipv6_cmp;
    user_info.func_insert = tunnel_init_ipv6_insert;
    user_info.func_del    = tunnel_init_ipv6_del;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                                    BCMI_EGR_L3_IP6_TNL_USER_ID_IP6_TNL,
                                    &lt_info, &user_info));

    /* Recover tunnel initiator s/w status. */
    if (warmboot) {
        dunit = bcmi_ltsw_dev_dunit(unit);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV4_ENCAPs, &entry_hdl));
        while ((rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                          BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, TNL_IPV4_ENCAP_IDs, &val));
            idx = val;
            /* Save encap_id. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, ENCAP_INDEXs, &val));
            TUNNEL_IPV4_ENCAP_ID(unit, val) = idx;
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_init_recover(unit, idx, 0));
        }

        if (entry_hdl != BCMLT_INVALID_HDL) {
            (void)bcmlt_entry_free(entry_hdl);
            entry_hdl = BCMLT_INVALID_HDL;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_IPV6_ENCAPs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, TNL_IPV6_ENCAPs,
                                           TNL_IPV6_ENCAP_IDs,
                                           &idx_min, &idx_max));

        while ((rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                          BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, TNL_IPV6_ENCAP_IDs, &val));
            idx = val;
            /* Save encap_id. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, ENCAP_INDEXs, &val));
            TUNNEL_IPV6_ENCAP_ID(unit, val) = idx;
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_init_recover(unit, idx, 1));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_decap_port_profile_init(unit));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    if (SHR_FUNC_ERR()) {
        SHR_IF_ERR_CONT
            (xgs_ltsw_tunnel_free_resource(unit));
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_free_resource(int unit)
{
    int warmboot;

    SHR_FUNC_ENTER(unit);

    warmboot = bcmi_warmboot_get(unit);
    /* Do not clear LT entries when "exit clean". */
    if (!warmboot) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_IPV4_ENCAPs));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_IPV6_ENCAPs));
    }

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_idx_tbl_unregister(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                      BCMI_EGR_L3_TNL_USER_ID_IP_TNL),
                                      SHR_E_NOT_FOUND);

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_idx_tbl_unregister(unit, BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                                      BCMI_EGR_L3_IP6_TNL_USER_ID_IP6_TNL),
                                      SHR_E_NOT_FOUND);

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit, BCMI_LTSW_PROFILE_TNL_DECAP_PORT),
                                      SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_initiator_get(
    int unit,
    bcm_l3_intf_t *intf,
    bcm_gport_t tunnel_id,
    bcm_tunnel_initiator_t *tnl_info)
{
    bcmi_ltsw_tunnel_type_t tnl_type;
    int tnl_idx;
    int hw_idx;
    int ifindex;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(intf, SHR_E_PARAM);
    SHR_NULL_CHECK(tnl_info, SHR_E_PARAM);

    ifindex = intf->l3a_intf_id;
    rv = bcmi_ltsw_l3_intf_tnl_init_get(unit, ifindex, &tnl_type, &hw_idx);
    if (rv == SHR_E_PARAM) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    } else if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }
    if ((tnl_type != bcmiTunnelTypeIpL3) &&
        (tnl_type != bcmiTunnelTypeIp6L3)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (tnl_type == bcmiTunnelTypeIp6L3) {
        tnl_idx = TUNNEL_IPV6_ENCAP_ID(unit, hw_idx);
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_init_ipv6_get(unit, tnl_idx, tnl_info));
    } else {
        tnl_idx = TUNNEL_IPV4_ENCAP_ID(unit, hw_idx);
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_init_ipv4_get(unit, tnl_idx, tnl_info));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_initiator_traverse(
    int unit,
    bcm_tunnel_initiator_traverse_cb cb,
    void *user_data)
{
    bcm_tunnel_initiator_t tnl_init_info;
    uint64_t idx_min, idx_max;
    int idx;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV4_ENCAPs,
                                       TNL_IPV4_ENCAP_IDs,
                                       &idx_min, &idx_max));

    for (idx = idx_min; idx <= idx_max; idx++) {
        if (tunnel_init_used_get(unit, bcmiTunnelTypeIpL3, idx) != SHR_E_NONE) {
            continue;
        }

        bcm_tunnel_initiator_t_init(&tnl_init_info);
        rv = tunnel_init_ipv4_get(unit, idx, &tnl_init_info);
        if (SHR_FAILURE(rv)) {
            if (rv != SHR_E_NOT_FOUND) {
                break;
            }
            continue;
        }
        if (cb) {
            rv = (*cb) (unit, &tnl_init_info, user_data);
            if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                break;
            }
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_IPV6_ENCAPs,
                                       TNL_IPV6_ENCAP_IDs,
                                       &idx_min, &idx_max));

    for (idx = idx_min; idx <= idx_max; idx++) {
        if (tunnel_init_used_get(unit, bcmiTunnelTypeIp6L3, idx) != SHR_E_NONE) {
            continue;
        }

        bcm_tunnel_initiator_t_init(&tnl_init_info);
        rv = tunnel_init_ipv6_get(unit, idx, &tnl_init_info);
        if (SHR_FAILURE(rv)) {
            if (rv != SHR_E_NOT_FOUND) {
                break;
            }
            continue;
        }
        if (cb) {
            rv = (*cb) (unit, &tnl_init_info, user_data);
            if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                break;
            }
        }
    }

    if (rv == SHR_E_NOT_FOUND) {
        SHR_EXIT();
    } else {
        SHR_ERR_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_initiator_set(
    int unit,
    bcm_l3_intf_t *intf,
    bcm_tunnel_initiator_t *tnl_info)
{
    int index;
    bcmi_ltsw_tunnel_type_t tnl_type;
    int ip6;
    int hw_idx;
    int rv;
    int ifindex;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(intf, SHR_E_PARAM);
    SHR_NULL_CHECK(tnl_info, SHR_E_PARAM);

    ip6 = BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_info->type);

    /* Check if interface already has tunnel attached. */
    ifindex = intf->l3a_intf_id;
    rv = bcmi_ltsw_l3_intf_tnl_init_get(unit, ifindex, &tnl_type, &hw_idx);
    if (rv == SHR_E_PARAM) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    } else if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }

    /* Check for tunnel replacement. */
    if (hw_idx) {
        if (!(tnl_info->flags & BCM_TUNNEL_REPLACE)) {
            return (BCM_E_EXISTS);
        }

        if ((tnl_type != bcmiTunnelTypeIpL3) &&
            (tnl_type != bcmiTunnelTypeIp6L3)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        /* Destroy original tunnel initiator. */
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_ltsw_tunnel_initiator_clear(unit, intf));
    }

    if (ip6) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_alloc(unit, 0,
                                           BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                                           BCMI_EGR_L3_IP6_TNL_USER_ID_IP6_TNL,
                                           tnl_info, &index));
        tnl_type = bcmiTunnelTypeIp6L3;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_alloc(unit, 0,
                                           BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                           BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                                           tnl_info, &index));
        tnl_type = bcmiTunnelTypeIpL3;
    }

    rv = tunnel_init_encap_index_get(unit, tnl_type, index, &hw_idx);
    if (SHR_FAILURE(rv)) {
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_free(unit, 0,
                                              BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                                              BCMI_EGR_L3_IP6_TNL_USER_ID_IP6_TNL,
                                              index));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_free(unit, 0,
                                              BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                              BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                                              index));
        }
        SHR_ERR_EXIT(rv);
    }

    rv = bcmi_ltsw_l3_intf_tnl_init_set(unit, ifindex, tnl_type, hw_idx);
    if (SHR_FAILURE(rv)) {
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_free(unit, 0,
                                              BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                                              BCMI_EGR_L3_IP6_TNL_USER_ID_IP6_TNL,
                                              index));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_idx_tbl_entry_free(unit, 0,
                                              BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                              BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                                              index));
        }
        SHR_ERR_EXIT(rv);
    }

    if (ip6) {
        TUNNEL_IPV6_ENCAP_ID(unit, hw_idx) = index;
    } else {
        TUNNEL_IPV4_ENCAP_ID(unit, hw_idx) = index;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_initiator_clear(
    int unit,
    bcm_l3_intf_t *intf)
{
    int hw_idx = 0;
    bcmi_ltsw_tunnel_type_t tnl_type;
    int ifindex;
    int tnl_idx;
    uint32_t ref_cnt = 0;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(intf, SHR_E_PARAM);

    /* Read tunnel info from hw. */
    ifindex = intf->l3a_intf_id;
    rv = bcmi_ltsw_l3_intf_tnl_init_get(unit, ifindex, &tnl_type, &hw_idx);
    if (rv == SHR_E_PARAM) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_NOT_FOUND);
    } else if (SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }

    /* Make sure tunnel index is valid. */
    if (!hw_idx ||
        ((tnl_type != bcmiTunnelTypeIpL3) &&
        (tnl_type != bcmiTunnelTypeIp6L3))) {
        return (BCM_E_NOT_FOUND);
    }

    /* Remove tunnel initiator entry to hw. */
    if (tnl_type == bcmiTunnelTypeIp6L3) {
        tnl_idx = TUNNEL_IPV6_ENCAP_ID(unit, hw_idx);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_free(unit, 0,
                                          BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                                          BCMI_EGR_L3_IP6_TNL_USER_ID_IP6_TNL,
                                          tnl_idx));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_get(unit,
                                             BCMI_LTSW_IDX_TBL_ID_EGR_L3_IP6_TNL,
                                             BCMI_EGR_L3_IP6_TNL_USER_ID_IP6_TNL,
                                             tnl_idx, &ref_cnt));

        if (!ref_cnt) {
            TUNNEL_IPV6_ENCAP_ID(unit, hw_idx) = 0;
        }
    } else {
        tnl_idx = TUNNEL_IPV4_ENCAP_ID(unit, hw_idx);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_free(unit, 0,
                                          BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                          BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                                          tnl_idx));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_get(unit,
                                             BCMI_LTSW_IDX_TBL_ID_EGR_L3_TNL,
                                             BCMI_EGR_L3_TNL_USER_ID_IP_TNL,
                                             tnl_idx, &ref_cnt));

        if (!ref_cnt) {
            TUNNEL_IPV4_ENCAP_ID(unit, hw_idx) = 0;
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_intf_tnl_init_reset(unit, ifindex));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_terminator_add(
    int unit,
    bcm_tunnel_terminator_t *tnl_term_info)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    /* Outer header is IPv6. */
    int ip6;
    int dunit;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    ip6 = BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_term_info->type);

    if (tnl_term_info->flags & BCM_TUNNEL_TERM_EM) {
        /* EM tables. */
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAP_EMs, &entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAP_EMs, &entry_hdl));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_em_entry_init(unit, tnl_term_info, entry_hdl, TRUE,
                                       TRUE));

        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_em_entry_add(unit, tnl_term_info, entry_hdl));
    } else {
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAPs, &entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAPs, &entry_hdl));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_entry_init(unit, tnl_term_info, entry_hdl, TRUE,
                                    TRUE));

        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_entry_add(unit, tnl_term_info, entry_hdl));
    }

    rv = bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL);
    if (SHR_FAILURE(rv)) {
        if (rv == SHR_E_RESOURCE) {
            rv = SHR_E_FULL;
        }
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_terminator_get(
    int unit,
    bcm_tunnel_terminator_t *tnl_term_info)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    /* Outer header is IPv6. */
    int ip6;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    ip6 = BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_term_info->type);

    if (tnl_term_info->flags & BCM_TUNNEL_TERM_EM) {
        /* EM tables. */
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAP_EMs, &entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAP_EMs, &entry_hdl));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_em_entry_init(unit, tnl_term_info, entry_hdl, TRUE,
                                       FALSE));
    } else {
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAPs, &entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAPs, &entry_hdl));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_entry_init(unit, tnl_term_info, entry_hdl, TRUE,
                                    FALSE));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    if (tnl_term_info->flags & BCM_TUNNEL_TERM_EM) {
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_em_entry_parse(unit, tnl_term_info, entry_hdl,
                                        ip6, TRUE, TRUE));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_entry_parse(unit, tnl_term_info, entry_hdl, ip6, TRUE,
                                     TRUE));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_terminator_delete(
    int unit,
    bcm_tunnel_terminator_t *tnl_term_info)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    /* Outer header is IPv6. */
    int ip6, prof_id;
    int dunit;
    int rv = SHR_E_NONE;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tnl_term_info, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    ip6 = BCMI_LTSW_TUNNEL_OUTER_HEADER_IPV6(tnl_term_info->type);

    if (tnl_term_info->flags & BCM_TUNNEL_TERM_EM) {
        /* EM tables. */
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAP_EMs, &entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAP_EMs, &entry_hdl));
        }
        /* Prepare lookup key. */
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_em_entry_init(unit, tnl_term_info, entry_hdl, TRUE,
                                       FALSE));
    } else {
        if (ip6) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAPs, &entry_hdl));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAPs, &entry_hdl));
        }
        /* Prepare lookup key. */
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_term_entry_init(unit, tnl_term_info, entry_hdl, TRUE,
                                    FALSE));
    }

    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                                   TNL_DECAP_PORT_PROFILE_IDs, &data));
        prof_id = (int)data;
        SHR_IF_ERR_VERBOSE_EXIT
            (tunnel_decap_port_profile_delete(unit, prof_id));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_terminator_traverse(
    int unit,
    bcm_tunnel_terminator_traverse_cb cb,
    void *user_data)
{
    bcm_tunnel_terminator_t tnl_term_info;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    int rv;
    int rv1;

    SHR_FUNC_ENTER(unit);

    bcm_tunnel_terminator_t_init(&tnl_term_info);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAPs, &entry_hdl));

    /* Traverse TNL_IPV4_DECAP table. */
    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);

    while (rv  == SHR_E_NONE) {
        /* Get and save data of the current entry */
        if (cb) {
            bcm_tunnel_terminator_t_init(&tnl_term_info);
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_term_entry_parse(unit, &tnl_term_info, entry_hdl, FALSE,
                                         TRUE, TRUE));
        }

        /* Traverse to the next entry */
        rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        /* Delete or update data from or into the current entry */
        if (cb) {
            rv1 = (*cb) (unit, &tnl_term_info, user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAPs, &entry_hdl));

    /* Traverse TNL_IPV6_DECAP table. */
    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);

    while (rv  == SHR_E_NONE) {
        /* Get and save data of the current entry */
        if (cb) {
            bcm_tunnel_terminator_t_init(&tnl_term_info);
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_term_entry_parse(unit, &tnl_term_info, entry_hdl, TRUE,
                                         TRUE, TRUE));
        }

        /* Traverse to the next entry */
        rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        /* Delete or update data from or into the current entry */
        if (cb) {
            rv1 = (*cb) (unit, &tnl_term_info, user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_IPV4_DECAP_EMs, &entry_hdl));

    /* Traverse L3_IPV4_TUNNEL_EM table. */
    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);

    while (rv  == SHR_E_NONE) {
        /* Get and save data of the current entry */
        if (cb) {
            bcm_tunnel_terminator_t_init(&tnl_term_info);
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_term_em_entry_parse(unit, &tnl_term_info, entry_hdl,
                                            FALSE, TRUE, TRUE));
        }

        /* Traverse to the next entry */
        rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        /* Delete or update data from or into the current entry */
        if (cb) {
            rv1 = (*cb) (unit, &tnl_term_info, user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_IPV6_DECAP_EMs, &entry_hdl));

    /* Traverse TNL_IPV6_DECAP_EM table. */
    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                              BCMLT_PRIORITY_NORMAL);

    while (rv  == SHR_E_NONE) {
        /* Get and save data of the current entry */
        if (cb) {
            bcm_tunnel_terminator_t_init(&tnl_term_info);
            SHR_IF_ERR_VERBOSE_EXIT
                (tunnel_term_em_entry_parse(unit, &tnl_term_info, entry_hdl,
                                            TRUE, TRUE, TRUE));
        }

        /* Traverse to the next entry */
        rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                  BCMLT_PRIORITY_NORMAL);

        /* Delete or update data from or into the current entry */
        if (cb) {
            rv1 = (*cb) (unit, &tnl_term_info, user_data);
            if (SHR_FAILURE(rv1) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv1);
            }
        }
    }

    if (SHR_FAILURE(rv) && (rv != SHR_E_NOT_FOUND)) {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_terminator_stat_attach(
    int unit,
    bcm_tunnel_terminator_t *terminator,
    bcmi_ltsw_flexctr_counter_info_t *info)
{
    tunnel_term_flexctr_cfg_t flexctr;

    SHR_FUNC_ENTER(unit);

    sal_memset(&flexctr, 0, sizeof(tunnel_term_flexctr_cfg_t));
    flexctr.op = TNL_TERM_FLXCTR_OP_SET;
    flexctr.flags = TNL_TERM_FLXCTR_F_ACTION;
    flexctr.action = info->action_index;

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_term_flexctr_op(unit, terminator, &flexctr));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_terminator_stat_detach(
    int unit,
    bcm_tunnel_terminator_t *terminator)
{
    tunnel_term_flexctr_cfg_t flexctr;

    SHR_FUNC_ENTER(unit);

    sal_memset(&flexctr, 0, sizeof(tunnel_term_flexctr_cfg_t));
    flexctr.op = TNL_TERM_FLXCTR_OP_SET;
    flexctr.flags = TNL_TERM_FLXCTR_F_ACTION;
    flexctr.action = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_term_flexctr_op(unit, terminator, &flexctr));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_terminator_flexctr_object_set(
    int unit,
    bcm_tunnel_terminator_t *terminator,
    uint32 value)
{
    tunnel_term_flexctr_cfg_t flexctr;

    SHR_FUNC_ENTER(unit);

    sal_memset(&flexctr, 0, sizeof(tunnel_term_flexctr_cfg_t));
    flexctr.op = TNL_TERM_FLXCTR_OP_SET;
    flexctr.flags = TNL_TERM_FLXCTR_F_INDEX;
    flexctr.index = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_term_flexctr_op(unit, terminator, &flexctr));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_terminator_flexctr_object_get(
    int unit,
    bcm_tunnel_terminator_t *terminator,
    uint32 *value)
{
    tunnel_term_flexctr_cfg_t flexctr;

    SHR_FUNC_ENTER(unit);

    sal_memset(&flexctr, 0, sizeof(tunnel_term_flexctr_cfg_t));
    flexctr.op = TNL_TERM_FLXCTR_OP_GET;
    flexctr.flags = TNL_TERM_FLXCTR_F_INDEX;

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_term_flexctr_op(unit, terminator, &flexctr));

    *value = flexctr.index;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_terminator_flexctr_info_get(
    int unit,
    bcm_tunnel_terminator_t *terminator,
    bcmi_ltsw_flexctr_counter_info_t *info)
{
    const char *ltname;
    xgs_ltsw_tnl_term_type_t tnl_type;
    tunnel_term_flexctr_cfg_t flexctr;

    SHR_FUNC_ENTER(unit);

    BCM_IF_ERROR_RETURN
        (tunnel_term_type_set(unit, terminator, &tnl_type));

    if (tnl_type.tnl_outer_hdr_ipv6) {
        ltname = TNL_IPV6_DECAPs;
    } else {
        ltname = TNL_IPV4_DECAPs;
    }

    sal_memset(&flexctr, 0, sizeof(tunnel_term_flexctr_cfg_t));
    flexctr.op = TNL_TERM_FLXCTR_OP_GET;
    flexctr.flags = TNL_TERM_FLXCTR_F_ACTION;

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_term_flexctr_op(unit, terminator, &flexctr));

    info->source = bcmFlexctrSourceIpTunnelTerminator;

    if (info->direction != BCMI_LTSW_FLEXCTR_DIR_INGRESS) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    info->action_index = flexctr.action;
    info->table_name = ltname;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_type_support_check(
    int unit,
    bcm_tunnel_type_t tnl_type,
    int *tunnel_term,
    int *tunnel_init)
{
    /* Tunnel terminator supported. */
    int term;
    /* Tunnel initiator supported. */
    int init;

    SHR_FUNC_ENTER(unit);

    switch (tnl_type) {
    case bcmTunnelTypeNone:
    case bcmTunnelTypeIp4In4:
    case bcmTunnelTypeIp6In4:
    case bcmTunnelTypeIsatap:
        term = init = TRUE;
        break;

    case bcmTunnelType6In4Uncheck:
        init = term = TRUE;
        break;

    case bcmTunnelTypeIpAnyIn4:
        init = TRUE;
        if (!(bcmi_ltsw_property_get(unit,
                                     BCMI_CPN_BCM_TUNNEL_TERM_COMPATIBLE_MODE,
                                     0))) {
            term = FALSE;
        } else {
            term = TRUE;
        }
        break;

    case bcmTunnelTypeIp4In6:
    case bcmTunnelTypeIp6In6:
        term = init = TRUE;
        break;

    case bcmTunnelTypeIpAnyIn6:
        init = TRUE;
        if (!(bcmi_ltsw_property_get(unit,
                                     BCMI_CPN_BCM_TUNNEL_TERM_COMPATIBLE_MODE,
                                     0))) {
            term = FALSE;
        } else {
            term = TRUE;
        }
        break;

    case bcmTunnelType6In4:
        init = term = TRUE;
        break;
    
    case bcmTunnelTypePim6SmDr1:
    case bcmTunnelTypePim6SmDr2:
        init = term = FALSE;
        break;

    case bcmTunnelTypeGre4In4:
    case bcmTunnelTypeGre6In4:
        init = term = TRUE;
        break;

    case bcmTunnelTypeGreAnyIn4:
        term = init = TRUE;
        break;

    case bcmTunnelTypeGre4In6:
    case bcmTunnelTypeGre6In6:
        init = term = TRUE;
        break;

    case bcmTunnelTypeGreAnyIn6:
        term = init = TRUE;
        break;

    case bcmTunnelTypeUdp:
    case bcmTunnelTypeMpls:
        init = term = FALSE;
        break;

    case bcmTunnelTypeWlanWtpToAc:
    case bcmTunnelTypeWlanWtpToAc6:
    case bcmTunnelTypeWlanAcToAc:
    case bcmTunnelTypeWlanAcToAc6:
        term = init = FALSE;
        break;

    case bcmTunnelTypeAutoMulticast:
    case bcmTunnelTypeAutoMulticast6:
        init = term = FALSE;
        break;

    default:
        term = init = FALSE;
    }

    if (tunnel_term != NULL) {
        *tunnel_term = term;
    }
    if (tunnel_init != NULL) {
        *tunnel_init = init;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_control_set(
    int unit,
    bcmi_ltsw_tunnel_control_t control,
    uint32_t value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_control_set(unit, control, value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_control_get(
    int unit,
    bcmi_ltsw_tunnel_control_t control,
    uint32_t *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_control_get(unit, control, value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_config_set(
    int unit,
    bcm_tunnel_config_t *tconfig)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint32_t val;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tconfig, SHR_E_PARAM);

    if ((tconfig->ip4_id < 0) ||
        (tconfig->ip4_id > 0xffff)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_control_get(unit,
                            bcmiTunnelControlTunnelIp4IdShared,
                            &val));
    if (val) {
        dunit = bcmi_ltsw_dev_dunit(unit);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_ENCAP_FRAGMENTs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_ENCAP_FRAGMENT_IDs, 0));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, FRAGMENT_IDs, tconfig->ip4_id));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_config_get(
    int unit,
    bcm_tunnel_config_t *tconfig)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint32_t val;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(tconfig, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_control_get(unit,
                            bcmiTunnelControlTunnelIp4IdShared,
                            &val));
    if (val) {
        dunit = bcmi_ltsw_dev_dunit(unit);

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, TNL_ENCAP_FRAGMENTs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_ENCAP_FRAGMENT_IDs, 0));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, FRAGMENT_IDs, &data));
        tconfig->ip4_id = data;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_decap_port_profile_add(
    int unit,
    bcmi_ltsw_tunnel_decap_port_profile_t *entry,
    int *index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_decap_port_profile_add(unit, entry, index));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_decap_port_profile_get(
    int unit,
    bcmi_ltsw_tunnel_decap_port_profile_t *entry,
    int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_decap_port_profile_get(unit, entry, index));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_decap_port_profile_delete(
    int unit,
    int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_decap_port_profile_delete(unit, index));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_tunnel_decap_port_profile_recover(
    int unit,
    int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (tunnel_decap_port_profile_recover(unit, index));

exit:
    SHR_FUNC_EXIT();
}

