/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/xgs/flowtracker.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/property.h>

#include <shr/shr_bitop.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_FLOWTRACKER

/*!
 * \brief Flowtracker ETRAP definitions.
 */
/*! Number of Bloom filter instances. */
#define FLOWTRACKER_ETRAP_BLOOM_FILTER_NUM_INSTANCES (4)

/*! Number of Elephant flow tables banks. */
#define FLOWTRACKER_ETRAP_FLOW_TABLE_NUM_BANKS (2)

/*! Default queue drain time. */
#define FLOWTRACKER_ETRAP_DEF_QUEUE_DRAIN_TIME_USECS (100)

/******************************************************************************
 * Private functions
 */


#define FT_INT_PRI_MAX 16
#define MAX_PORTS 272

static int
ft_queue_drain_time_lt_encode(int unit, int drain_time, const char **hw_value)
{
    SHR_FUNC_ENTER(unit);

    switch (drain_time) {
        case 50:
            *hw_value = TIME_50USs;
            break;
        case 100:
            *hw_value = TIME_100USs;
            break;
        case 150:
            *hw_value = TIME_150USs;
            break;
        case 200:
            *hw_value = TIME_200USs;
            break;
        case 250:
            *hw_value = TIME_250USs;
            break;
        case 500:
            *hw_value = TIME_500USs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_monitor_interval_lt_encode(int unit, int mon_interval, const char **lt_field)
{
    SHR_FUNC_ENTER(unit);

    switch (mon_interval) {
        case 1000:
            *lt_field = TIME_1MSs;
            break;
        case 2000:
            *lt_field = TIME_2MSs;
            break;
        case 5000:
            *lt_field = TIME_5MSs;
            break;
        case 10000:
            *lt_field = TIME_10MSs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_monitor_interval_lt_decode(int unit, const char *lt_field, int *interval)
{
    SHR_FUNC_ENTER(unit);

    if (sal_strcasecmp(lt_field, TIME_1MSs) == 0) {
        *interval = 1000;
    } else if (sal_strcasecmp(lt_field, TIME_2MSs) == 0) {
        *interval = 2000;
    } else if (sal_strcasecmp(lt_field, TIME_5MSs) == 0) {
        *interval = 5000;
    } else if (sal_strcasecmp(lt_field, TIME_10MSs) == 0) {
        *interval = 10000;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_pkt_type_match_set(int unit, const char *table_name, uint32_t pkt_type_bmp)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, table_name, &entry_hdl));

    if (pkt_type_bmp & BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV4_TCP) {
        val = 1;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, IPV4_TCPs, val));
    }

    if (pkt_type_bmp & BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV4_UDP) {
        val = 1;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, IPV4_UDPs, val));
    }

    if (pkt_type_bmp & BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV4_OTHER) {
        val = 1;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, IPV4_OTHERs, val));
    }

    if (pkt_type_bmp & BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV6_TCP) {
        val = 1;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, IPV6_TCPs, val));
    }

    if (pkt_type_bmp & BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV6_UDP) {
        val = 1;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, IPV6_UDPs, val));
    }

    if (pkt_type_bmp & BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV6_OTHER) {
        val = 1;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, IPV6_OTHERs, val));
    }

    if (pkt_type_bmp & BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_MPLS) {
        val = 1;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, MPLSs, val));
    }

    if (pkt_type_bmp & BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_OTHER) {
        val = 1;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, NON_IPV4_IPV6_MPLSs, val));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
ft_pkt_type_match_get(int unit, const char *table_name, uint32_t *pkt_type_bmp)
{
    int rv;
    int dunit;
    uint64_t val = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    *pkt_type_bmp = 0;

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, table_name, &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);

    if (rv == SHR_E_NOT_FOUND) {
        SHR_EXIT();
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, IPV4_TCPs, &val));
    if (val) {
        *pkt_type_bmp |= BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV4_TCP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, IPV4_UDPs, &val));
    if (val) {
        *pkt_type_bmp |= BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV4_UDP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, IPV4_OTHERs, &val));
    if (val) {
        *pkt_type_bmp |= BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV4_OTHER;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, IPV6_TCPs, &val));
    if (val) {
        *pkt_type_bmp |= BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV6_TCP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, IPV6_UDPs, &val));
    if (val) {
        *pkt_type_bmp |= BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV6_UDP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, IPV6_OTHERs, &val));
    if (val) {
        *pkt_type_bmp |= BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_IPV6_OTHER;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, MPLSs, &val));
    if (val) {
        *pkt_type_bmp |= BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_MPLS;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NON_IPV4_IPV6_MPLSs, &val));
    if (val) {
        *pkt_type_bmp |= BCM_FLOWTRACKER_ELEPHANT_PKT_TYPE_OTHER;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
ft_int_pri_match_set(int unit, const char *table_name, uint32_t int_pri_bmp)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int i;
    uint64_t bmp[FT_INT_PRI_MAX] = {0};

    SHR_FUNC_ENTER(unit);

    if ((int_pri_bmp >> FT_INT_PRI_MAX) != 0) {
        /* Some invalid int_pri is set */
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, table_name, &entry_hdl));

    for (i = 0; i < FT_INT_PRI_MAX; i++) {
        if (int_pri_bmp & (1 << i)) {
            bmp[i] = 1;
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, INT_PRIs,
                                     0, bmp, FT_INT_PRI_MAX));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
ft_int_pri_match_get(int unit, const char *table_name, uint32_t *int_pri_bmp)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t bmp[FT_INT_PRI_MAX] = {0};
    int i;
    uint32_t r_elem_cnt;
    int dunit = 0;
    int rv;

    SHR_FUNC_ENTER(unit);

    *int_pri_bmp = 0;

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, table_name, &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);

    if (rv == SHR_E_NOT_FOUND) {
        SHR_EXIT();
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_get(entry_hdl, INT_PRIs, 0, bmp,
                                     FT_INT_PRI_MAX, &r_elem_cnt));

    for (i = 0; i < r_elem_cnt; i++) {
        if (bmp[i] != 0) {
            *int_pri_bmp |= 1 << i;
        }
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
ft_port_match_set(int unit, const char *table_name, bcm_pbmp_t pbmp)
{
    uint64_t bmp[MAX_PORTS] = {0};
    bcm_port_t port;
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_ITER(pbmp, port) {
        bmp[port] = 1;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, table_name, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, PORT_IDs,
                                     0, bmp, MAX_PORTS));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
ft_port_match_get(int unit, const char *table_name, bcm_pbmp_t *pbmp)
{
    uint64_t bmp[MAX_PORTS] = {0};
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int i;
    uint32_t r_elem_cnt;
    int dunit = 0;
    int rv;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_CLEAR(*pbmp);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, table_name, &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);

    if (rv == SHR_E_NOT_FOUND) {
        SHR_EXIT();
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_get(entry_hdl, PORT_IDs, 0, bmp,
                                     MAX_PORTS, &r_elem_cnt));

    i = 0;
    while (i < MAX_PORTS) {
        if (bmp[i] & 0x1) {
            BCM_PBMP_PORT_ADD(*pbmp, i);
        }
        i++;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

static int
ft_lookup_match_set(
    int unit,
    uint32_t match_types,
    bcm_flowtracker_elephant_match_data_t *match_data)
{
    uint32_t valid_match_types = (BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_PKT_TYPE_BMP |
                                  BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INT_PRI_BMP  |
                                  BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INGRESS_PBMP);

    SHR_FUNC_ENTER(unit);

    if ((match_types & ~valid_match_types) != 0) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (match_types & BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_PKT_TYPE_BMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ft_pkt_type_match_set(unit, MON_ETRAP_CONTROLs,
                                   match_data->pkt_type_bmp));
    }

    if (match_types & BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INT_PRI_BMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ft_int_pri_match_set(unit, MON_ETRAP_CONTROLs,
                                  match_data->int_pri_bmp));
    }

    if (match_types & BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INGRESS_PBMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ft_port_match_set(unit, MON_ETRAP_CONTROLs,
                               match_data->ingress_pbmp));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_lookup_match_get(
    int unit,
    uint32 *match_types,
    bcm_flowtracker_elephant_match_data_t *match_data)
{
    int port_count = 0;
    SHR_FUNC_ENTER(unit);

    *match_types = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (ft_pkt_type_match_get(unit, MON_ETRAP_CONTROLs,
                               &(match_data->pkt_type_bmp)));
    if (match_data->pkt_type_bmp != 0) {
        *match_types |= BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_PKT_TYPE_BMP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ft_int_pri_match_get(unit, MON_ETRAP_CONTROLs,
                              &(match_data->int_pri_bmp)));
    if (match_data->int_pri_bmp != 0) {
        *match_types |= BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INT_PRI_BMP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ft_port_match_get(unit, MON_ETRAP_CONTROLs,
                           &(match_data->ingress_pbmp)));
    BCM_PBMP_COUNT(match_data->ingress_pbmp, port_count);
    if (port_count != 0) {
        *match_types |= BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INGRESS_PBMP;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_queue_match_set(
    int unit,
    uint32_t match_types,
    bcm_flowtracker_elephant_match_data_t *match_data)
{
    uint32_t valid_match_types = (BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_PKT_TYPE_BMP |
                                BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INT_PRI_BMP  |
                                BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_EGRESS_PBMP);

    SHR_FUNC_ENTER(unit);

    if ((match_types & ~valid_match_types) != 0) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (match_types & BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_PKT_TYPE_BMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ft_pkt_type_match_set(unit, MON_ETRAP_QUEUE_ASSIGNMENTs,
                                   match_data->pkt_type_bmp));
    }

    if (match_types & BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INT_PRI_BMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ft_int_pri_match_set(unit, MON_ETRAP_QUEUE_ASSIGNMENTs,
                                  match_data->int_pri_bmp));
    }

    if (match_types & BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_EGRESS_PBMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ft_port_match_set(unit, MON_ETRAP_QUEUE_ASSIGNMENTs,
                               match_data->egress_pbmp));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_queue_match_get(
    int unit,
    uint32_t *match_types,
    bcm_flowtracker_elephant_match_data_t *match_data)
{
    int port_count = 0;

    SHR_FUNC_ENTER(unit);

    *match_types = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (ft_pkt_type_match_get(unit, MON_ETRAP_QUEUE_ASSIGNMENTs,
                               &(match_data->pkt_type_bmp)));
    if (match_data->pkt_type_bmp != 0) {
        *match_types |= BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_PKT_TYPE_BMP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ft_int_pri_match_get(unit, MON_ETRAP_QUEUE_ASSIGNMENTs,
                              &(match_data->int_pri_bmp)));
    if (match_data->int_pri_bmp != 0) {
        *match_types |= BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INT_PRI_BMP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ft_port_match_get(unit, MON_ETRAP_QUEUE_ASSIGNMENTs,
                           &(match_data->egress_pbmp)));
    BCM_PBMP_COUNT(match_data->egress_pbmp, port_count);
    if (port_count != 0) {
        *match_types |= BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_EGRESS_PBMP;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_color_match_set(
    int unit,
    uint32_t match_types,
    bcm_flowtracker_elephant_match_data_t *match_data)
{
    uint32_t valid_match_types = (BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_PKT_TYPE_BMP |
                                  BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INT_PRI_BMP  |
                                  BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_EGRESS_PBMP);

    SHR_FUNC_ENTER(unit);

    if ((match_types & ~valid_match_types) != 0) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (match_types & BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_PKT_TYPE_BMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ft_pkt_type_match_set(unit, MON_ETRAP_COLOR_ASSIGNMENTs,
                                   match_data->pkt_type_bmp));
    }

    if (match_types & BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INT_PRI_BMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ft_int_pri_match_set(unit, MON_ETRAP_COLOR_ASSIGNMENTs,
                                  match_data->int_pri_bmp));
    }

    if (match_types & BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_EGRESS_PBMP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ft_port_match_set(unit, MON_ETRAP_COLOR_ASSIGNMENTs,
                               match_data->egress_pbmp));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_color_match_get(int unit, uint32_t *match_types,
                   bcm_flowtracker_elephant_match_data_t *match_data)
{
    int port_count = 0;

    SHR_FUNC_ENTER(unit);

    *match_types = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (ft_pkt_type_match_get(unit, MON_ETRAP_COLOR_ASSIGNMENTs,
                               &(match_data->pkt_type_bmp)));
    if (match_data->pkt_type_bmp != 0) {
        *match_types |= BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_PKT_TYPE_BMP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ft_int_pri_match_get(unit, MON_ETRAP_COLOR_ASSIGNMENTs,
                              &(match_data->int_pri_bmp)));
    if (match_data->int_pri_bmp != 0) {
        *match_types |= BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_INT_PRI_BMP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ft_port_match_get(unit, MON_ETRAP_COLOR_ASSIGNMENTs,
                           &(match_data->egress_pbmp)));
    BCM_PBMP_COUNT(match_data->egress_pbmp, port_count);
    if (port_count != 0) {
        *match_types |= BCM_FLOWTRACKER_ELEPHANT_MATCH_TYPE_EGRESS_PBMP;
    }

exit:
    SHR_FUNC_EXIT();
}

static int
ft_hw_etrap_detach(int unit)
{
    if (!bcmi_warmboot_get(unit)) {
        (void)bcmi_lt_clear(unit, MON_ETRAP_CANDIDATE_FILTERs);
        (void)bcmi_lt_clear(unit, MON_ETRAP_FLOWs);
        (void)bcmi_lt_clear(unit, MON_ETRAP_CONTROLs);
        (void)bcmi_lt_clear(unit, MON_ETRAP_COLOR_ASSIGNMENTs);
        (void)bcmi_lt_clear(unit, MON_ETRAP_INT_PRI_REMAPs);
        (void)bcmi_lt_clear(unit, MON_ETRAP_QUEUE_ASSIGNMENTs);
        (void)bcmi_lt_clear(unit, MON_ETRAP_THRESHOLDs);
    }

    return SHR_E_NONE;
}

static int
ft_hw_etrap_init(int unit)
{
    int dunit;
    int idx = 0, drain_time = 0;
    uint64_t val = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *critical_time = NULL;
    const char *etrap_interval = TIME_5MSs;
    const char *hash_sel[] = {
        HASH0_INSTANCE0s,
        HASH0_INSTANCE1s,
        HASH1_INSTANCE0s,
        HASH1_INSTANCE1s
    };

    SHR_FUNC_ENTER(unit);

    if (bcmi_warmboot_get(unit)) {
        SHR_EXIT();
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_CANDIDATE_FILTERs, &entry_hdl));

    for (idx = 0; idx < FLOWTRACKER_ETRAP_BLOOM_FILTER_NUM_INSTANCES; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl, FILTER_HASH_SELECTs,
                                                idx, &hash_sel[idx], 1));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    (void)bcmlt_entry_free(entry_hdl);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_FLOWs, &entry_hdl));

    for (idx = 0; idx < FLOWTRACKER_ETRAP_FLOW_TABLE_NUM_BANKS; idx++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl, FLOW_HASH_SELECTs,
                                                idx, &hash_sel[idx], 1));
    }

    /* Set ETRAP interval to 5ms. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, ETRAP_INTERVALs, etrap_interval));

    drain_time = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_FLOWTRACKER_ELEPHANT_EXPECTED_QUEUE_DRAIN_TIME_USECS,
                                        FLOWTRACKER_ETRAP_DEF_QUEUE_DRAIN_TIME_USECS);
    SHR_IF_ERR_VERBOSE_EXIT
        (ft_queue_drain_time_lt_encode(unit, drain_time, &critical_time));

    /* Set critical time. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, ETRAP_CRITICAL_TIMEs, critical_time));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    (void)bcmlt_entry_free(entry_hdl);

    /*
     * Enable color action from ETRAP block. Match criteria or IFP action will
     * determine if the color is changed for a given packet
     */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_COLOR_ASSIGNMENTs, &entry_hdl));

    val = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, ETRAP_COLORs, val));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    (void)bcmlt_entry_free(entry_hdl);


    /* Set default int_pri remap to not change the int_pri */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_INT_PRI_REMAPs, &entry_hdl));

    for (idx = 0; idx < FT_INT_PRI_MAX; idx++) {
        val = idx;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, INT_PRIs, val));

        val = idx;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, NEW_INT_PRIs, val));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    }
    (void)bcmlt_entry_free(entry_hdl);

    /* Enable ETRAP using MON_ETRAP_CONTROL. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_CONTROLs, &entry_hdl));

    val = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, ETRAPs, val));

    /*
     * Enable monitoring, there are other controls to decide if the packet
     * needs to be mirrored or copied to CPU
     */
    val = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MONITORs, val));

    /*
     * Always enable Mirroring, ETRAP_MONITOR_MIRROR_CONFIG has controls to
     * decide whether to Mirror a packet or not.
     */
    val = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MIRRORs, val));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    (void)bcmlt_entry_free(entry_hdl);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_THRESHOLDs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    (void)bcmlt_entry_free(entry_hdl);

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_flowtracker_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT(ft_hw_etrap_detach(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flowtracker_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT(ft_hw_etrap_init(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flowtracker_elephant_action_match_set(
    int unit,
    bcm_flowtracker_elephant_match_action_t action,
    uint32_t match_types,
    bcm_flowtracker_elephant_match_data_t *match_data)
{
    SHR_FUNC_ENTER(unit);

    switch(action) {
        case bcmFlowtrackerElephantMatchActionLookup:
            SHR_IF_ERR_VERBOSE_EXIT
                (ft_lookup_match_set(unit, match_types, match_data));
            break;
        case bcmFlowtrackerElephantMatchActionQueue:
            SHR_IF_ERR_VERBOSE_EXIT
                (ft_queue_match_set(unit, match_types, match_data));
            break;
        case bcmFlowtrackerElephantMatchActionColor:
            SHR_IF_ERR_VERBOSE_EXIT
                (ft_color_match_set(unit, match_types, match_data));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flowtracker_elephant_action_match_get(
    int unit,
    bcm_flowtracker_elephant_match_action_t action,
    uint32_t *match_types,
    bcm_flowtracker_elephant_match_data_t *match_data)
{
    SHR_FUNC_ENTER(unit);

    switch(action) {
        case bcmFlowtrackerElephantMatchActionLookup:
            SHR_IF_ERR_VERBOSE_EXIT
                (ft_lookup_match_get(unit, match_types, match_data));
            break;
        case bcmFlowtrackerElephantMatchActionQueue:
            SHR_IF_ERR_VERBOSE_EXIT
                (ft_queue_match_get(unit, match_types, match_data));
            break;
        case bcmFlowtrackerElephantMatchActionColor:
            SHR_IF_ERR_VERBOSE_EXIT
                (ft_color_match_get(unit, match_types, match_data));
            break;
        default:
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flowtracker_elephant_int_pri_remap_set(
    int unit,
    bcm_cos_t int_pri,
    bcm_cos_t new_int_pri)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_INT_PRI_REMAPs, &entry_hdl));

    val = int_pri;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_PRIs, val));

    val = new_int_pri;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, NEW_INT_PRIs, val));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flowtracker_elephant_int_pri_remap_get(
    int unit,
    bcm_cos_t int_pri,
    bcm_cos_t *new_int_pri)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_ETRAP_INT_PRI_REMAPs, &entry_hdl));

    val = int_pri;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_PRIs, val));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NEW_INT_PRIs, &val));

    *new_int_pri = val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flowtracker_elephant_hash_config_set(
    int unit,
    bcm_flowtracker_elephant_hash_table_t hash_table,
    int instance_num,
    int bank_num,
    bcm_flowtracker_elephant_hash_type_t hash_type,
    int right_rotate_bits)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val = 0;
    const char *hash_sel[] = {
        HASH0_INSTANCE0s,
        HASH0_INSTANCE1s,
        HASH1_INSTANCE0s,
        HASH1_INSTANCE1s
    };

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (hash_table == bcmFlowtrackerElephantHashTableBloomFilter) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_CANDIDATE_FILTERs, &entry_hdl));

        val = hash_type;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl, FILTER_HASH_SELECTs,
                                                instance_num, &hash_sel[val], 1));

        val = right_rotate_bits;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(entry_hdl, FILTER_HASH_ROTATE_BITSs, instance_num, &val, 1));

    } else if (hash_table == bcmFlowtrackerElephantHashTableFlowTable) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_FLOWs, &entry_hdl));

        val = hash_type;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl, FLOW_HASH_SELECTs,
                                                bank_num, &hash_sel[val], 1));

        val = right_rotate_bits;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(entry_hdl, FLOW_HASH_ROTATE_BITSs, bank_num, &val, 1));
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flowtracker_elephant_hash_config_get(
    int unit,
    bcm_flowtracker_elephant_hash_table_t hash_table,
    int instance_num,
    int bank_num,
    bcm_flowtracker_elephant_hash_type_t *hash_type,
    int *right_rotate_bits)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint32_t count = 0;
    uint64_t val = 0;
    const char *hash_sel = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (hash_table == bcmFlowtrackerElephantHashTableBloomFilter) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_CANDIDATE_FILTERs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl, FILTER_HASH_SELECTs,
                                                instance_num, &hash_sel, 1, &count));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, FILTER_HASH_ROTATE_BITSs,
                                         instance_num, &val, 1, &count));
        *right_rotate_bits = val;
    } else if (hash_table == bcmFlowtrackerElephantHashTableFlowTable) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_FLOWs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl, FLOW_HASH_SELECTs,
                                                bank_num, &hash_sel, 1, &count));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, FLOW_HASH_ROTATE_BITSs,
                                         bank_num, &val, 1, &count));
        *right_rotate_bits = val;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (!sal_strcmp(hash_sel, HASH0_INSTANCE0s)) {
        *hash_type = bcmFlowtrackerElephantHashTypeField0Function0;
    } else if (!sal_strcmp(hash_sel, HASH0_INSTANCE1s)) {
        *hash_type = bcmFlowtrackerElephantHashTypeField0Function1;
    } else if (!sal_strcmp(hash_sel, HASH1_INSTANCE0s)) {
        *hash_type = bcmFlowtrackerElephantHashTypeField1Function0;
    } else {
        *hash_type = bcmFlowtrackerElephantHashTypeField1Function1;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flowtracker_elephant_control_set(
    int unit,
    bcm_flowtracker_elephant_control_t type,
    int arg)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val = 0;
    const char *mon_interval = NULL;
    uint64_t bmp[FT_INT_PRI_MAX] = {0};
    int i;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    if (type == bcmFlowtrackerElephantControlMonitorIntervalUsecs) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_FLOWs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (ft_monitor_interval_lt_encode(unit, arg, &mon_interval));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, ETRAP_INTERVALs, mon_interval));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    } else if (type == bcmFlowtrackerElephantControlBloomFilterByteThreshold ||
               type == bcmFlowtrackerElephantControlElephantThresholdBytes ||
               type == bcmFlowtrackerElephantControlDemotionThresholdBytes ||
               type == bcmFlowtrackerElephantControlYellowThreshold ||
               type == bcmFlowtrackerElephantControlRedThreshold) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_THRESHOLDs, &entry_hdl));

        val = arg;
        switch (type) {
            case bcmFlowtrackerElephantControlBloomFilterByteThreshold:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CANDIDATE_BYTESs, val));
                break;
            case bcmFlowtrackerElephantControlElephantThresholdBytes:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, ELEPHANT_GREEN_BYTESs, val));
                break;
            case bcmFlowtrackerElephantControlDemotionThresholdBytes:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, RESET_BYTESs, val));
                break;
            case bcmFlowtrackerElephantControlYellowThreshold:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, ELEPHANT_YELLOW_BYTESs, val));
                break;
            case bcmFlowtrackerElephantControlRedThreshold:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, ELEPHANT_RED_BYTESs, val));
                break;
            /*
             * Coverity
             * This is defensive statement.
             */
            /* coverity[dead_error_begin] */
            default:
                SHR_ERR_EXIT(SHR_E_PARAM);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    } else if (type == bcmFlowtrackerElephantControlPacketRemarkEnable) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_COLOR_ASSIGNMENTs, &entry_hdl));

        if (arg == 0) {
            /* Disable packet remarking */
            for (i = 0; i < FT_INT_PRI_MAX; i++) {
                bmp[i] = 0;
            }
        } else {
            /* Enable remarking on all int_pri */
            for (i = 0; i < FT_INT_PRI_MAX; i++) {
                bmp[i] = 1;
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(entry_hdl, EGR_COLOR_UPDATEs,
                                         0, bmp, FT_INT_PRI_MAX));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_CONTROLs, &entry_hdl));

        val = arg;
        switch (type) {
            case bcmFlowtrackerElephantControlSampleRate:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, SAMPLE_THRESHOLDs, val));
                break;
            case bcmFlowtrackerElephantControlSampleSeed:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, MONITOR_SEEDs, val));
                break;
            case bcmFlowtrackerElephantControlSampleCopyToCpu:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, COPY_TO_CPUs, val));
                break;
            default:
                SHR_ERR_EXIT(SHR_E_PARAM);
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flowtracker_elephant_control_get(
    int unit,
    bcm_flowtracker_elephant_control_t type,
    int *arg)
{
    int dunit;
    uint64_t val = 0;
    int interval =0;
    const char *mon_interval = NULL;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t bmp[FT_INT_PRI_MAX] = {0};
    uint32_t r_elem_cnt;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (type == bcmFlowtrackerElephantControlMonitorIntervalUsecs) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_FLOWs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, ETRAP_INTERVALs, &mon_interval));

        SHR_IF_ERR_VERBOSE_EXIT
            (ft_monitor_interval_lt_decode(unit, mon_interval, &interval));
        val = interval;
    } else if (type == bcmFlowtrackerElephantControlBloomFilterByteThreshold ||
               type == bcmFlowtrackerElephantControlElephantThresholdBytes ||
               type == bcmFlowtrackerElephantControlDemotionThresholdBytes ||
               type == bcmFlowtrackerElephantControlYellowThreshold ||
               type == bcmFlowtrackerElephantControlRedThreshold) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_THRESHOLDs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));

        switch (type) {
            case bcmFlowtrackerElephantControlBloomFilterByteThreshold:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, CANDIDATE_BYTESs, &val));
                break;
            case bcmFlowtrackerElephantControlElephantThresholdBytes:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, ELEPHANT_GREEN_BYTESs, &val));
                break;
            case bcmFlowtrackerElephantControlDemotionThresholdBytes:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, RESET_BYTESs, &val));
                break;
            case bcmFlowtrackerElephantControlYellowThreshold:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, ELEPHANT_YELLOW_BYTESs, &val));
                break;
            case bcmFlowtrackerElephantControlRedThreshold:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, ELEPHANT_RED_BYTESs, &val));
                break;
            /*
             * Coverity
             * This is defensive statement.
             */
            /* coverity[dead_error_begin] */
            default:
                SHR_ERR_EXIT(SHR_E_PARAM);
        }
    } else if (type == bcmFlowtrackerElephantControlPacketRemarkEnable) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, MON_ETRAP_COLOR_ASSIGNMENTs, &entry_hdl));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                      BCMLT_PRIORITY_NORMAL));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_get(entry_hdl, EGR_COLOR_UPDATEs, 0, bmp,
                                             FT_INT_PRI_MAX, &r_elem_cnt));

            val = (bmp[0] == 0) ? 0 : 1;

    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, MON_ETRAP_CONTROLs, &entry_hdl));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));

        switch (type) {
            case bcmFlowtrackerElephantControlSampleRate:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, SAMPLE_THRESHOLDs, &val));
                break;
            case bcmFlowtrackerElephantControlSampleSeed:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, MONITOR_SEEDs, &val));
                break;
            case bcmFlowtrackerElephantControlSampleCopyToCpu:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, COPY_TO_CPUs, &val));
                break;
            default:
                SHR_ERR_EXIT(SHR_E_PARAM);
        }

    }

    *arg = val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flowtracker_elephant_stats_get(
    int unit,
    bcm_flowtracker_elephant_stats_t *stats)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, CTR_ETRAPs, &entry_hdl));

    stats->num_candidates_detected = 0;
    stats->num_elephants_detected = 0;
    stats->num_flow_table_insert_success = 0;
    stats->num_flow_table_insert_failures = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, CANDIDATE_FILTER_EXCEEDEDs, &val));
    stats->num_candidates_detected += val;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, FLOW_ELEPHANTs, &val));
    stats->num_elephants_detected += val;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, FLOW_INSERT_SUCCESSs, &val));
    stats->num_flow_table_insert_success += val;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, FLOW_INSERT_FAILUREs, &val));
    stats->num_flow_table_insert_failures += val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_flowtracker_elephant_stats_sync_get(
    int unit,
    bcm_flowtracker_elephant_stats_t *stats)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t val = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, CTR_ETRAPs, &entry_hdl));

    stats->num_candidates_detected = 0;
    stats->num_elephants_detected = 0;
    stats->num_flow_table_insert_success = 0;
    stats->num_flow_table_insert_failures = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_attrib_set(entry_hdl, BCMLT_ENT_ATTR_GET_FROM_HW));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, CANDIDATE_FILTER_EXCEEDEDs, &val));
    stats->num_candidates_detected += val;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, FLOW_ELEPHANTs, &val));
    stats->num_elephants_detected += val;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, FLOW_INSERT_SUCCESSs, &val));
    stats->num_flow_table_insert_success += val;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, FLOW_INSERT_FAILUREs, &val));
    stats->num_flow_table_insert_failures += val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

