/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/l2.h>
#include <bcm_int/control.h>
#include <bcm_int/common/multicast.h>

#include <bcm_int/ltsw/xgs/l2_int.h>
#include <bcm_int/ltsw/xgs/l2.h>
#include <bcm_int/ltsw/l2.h>
#include <bcm_int/ltsw/util.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/event_mgr.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/property.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw_dispatch.h>
#include <bcm_int/ltsw/trunk.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/virtual.h>
#include <bcm_int/ltsw/l3_egress.h>
#include <bcm_int/ltsw/multicast.h>
#include <bcm_int/ltsw/generated/l2_ha.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/issu.h>

#include <bsl/bsl.h>
#include <sal/sal_mutex.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_L2

/******************************************************************************
 * Private functions
 */


/*
* L2 table control structure
*/
typedef struct l2_ctrl_s {
    /* This mutex lock is to guarantee operation of L2 table to be atomic operation */
    sal_mutex_t mutex;

    /* This mutex lock is to guarantee operation of L2 cache table to be atomic operation */
    sal_mutex_t cache_mutex;

    /* L2 Learning enable */
    bool learn_enable;

    /* Label whether L2 cache table is initialized */
    bool l2_cache_init;
} l2_ctrl_t;

typedef int (*bcmint_l2_cache_trav_cb)(int unit,
                                       const bcmint_l2_map_info_t *lt_info,
                                       void *trav_data);

static l2_ctrl_t l2_ctrl[BCM_MAX_NUM_UNITS] = {{ 0 }};

const uint8_t mac_spanning_tree[] = {0x01, 0x80, 0xc2, 0x00, 0x00, 0x00};

const uint8_t mac_all_ones[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

/* 1: L2 is frozen by LT L2_LEARN_OVERRIDE */
static bool frozen_override_status[BCM_MAX_NUM_UNITS];

/* L2 learn control. */
static ltsw_l2_data_control_t l2_learn_control[BCM_MAX_NUM_UNITS];

/* 1: L2 is frozen by LT L2_LEARN_OVERRIDE */
#define L2_FROZEN_OVERRIDE_STATUS(u) frozen_override_status[u]

/* Take L2 table lock */
#define L2T_LOCK(u) \
    sal_mutex_take(l2_ctrl[u].mutex, SAL_MUTEX_FOREVER)

/* Release L2 table lock*/
#define L2T_UNLOCK(u) \
    sal_mutex_give(l2_ctrl[u].mutex)

/* Take L2 cache table lock */
#define L2_CACHE_LOCK(u) \
    sal_mutex_take(l2_ctrl[u].cache_mutex, SAL_MUTEX_FOREVER)

/* Release L2 cache table lock*/
#define L2_CACHE_UNLOCK(u) \
    sal_mutex_give(l2_ctrl[u].cache_mutex)

/* Check if L2 cache is initialized */
#define L2_CACHE_INIT_CHECK(u)                          \
    do {                                                \
        if (l2_ctrl[u].l2_cache_init == false) {        \
            return (SHR_E_INIT);                        \
        }                                               \
    } while(0)

/* This macro indicates if notify L2 event to application */
#define NOTIFY_L2_EVENT(unit) bcmint_l2_callback_num(unit) ? true: false

/* Used to transfer value of fields to value of members of other data structure. Vice versa. */
static const
bcmint_l2_map_info_t *l2_lt_map_info[BCM_MAX_NUM_UNITS];

static int
xgs_ltsw_l2_member_populate(int unit, bcmlt_entry_handle_t eh,
                            bcmint_l2_xgs_lt_id_t hsdk_tid, int id_map_depth,
                            const bcmint_l2_id_map_t *id_map_base,
                            int index, void *data_struct, void *cookie);

/* Opaque tag configurations */
static bcmint_l2_opaque_tag_t *opaque_tag_config[BCM_MAX_NUM_UNITS];

/* Max number of opaque tag can be configured */
#define NUM_OPAQUE_TAG       2

/* Max number of payload opaque tag can be configured */
#define NUM_PAYLOAD_OPAQUE_TAG       1

/******************************************************************************
 * Private functions
 */
/*!
 * \brief Populate data to field.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] array_depth Depth of array field. Depth is 0 for non-array field.
 * \param [in] fid ID of field.
 * \param [in] fld_val Value of field.
 * \param [in] fld_str_val String value of field.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
xgs_ltsw_l2_fld_val_set(int unit, bcmlt_entry_handle_t eh,
                        int array_depth, uint32_t fid,
                        uint64_t *fld_val, const char *fld_str_val)
{
    int rv;

    SHR_FUNC_ENTER(unit);

    if (array_depth) {
        rv = bcmlt_entry_field_array_add_by_id(eh, fid, 0,
                                               fld_val, array_depth);
    } else if (fld_str_val) {
        rv = bcmlt_entry_field_symbol_add_by_id(eh, fid, fld_str_val);
    } else {
        rv = bcmlt_entry_field_add_by_id(eh, fid, fld_val[0]);
    }
    SHR_IF_ERR_EXIT(rv);

    if (fld_str_val) {
        LOG_DEBUG(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Configure field [%d] as [%s].\n"),
                  fid, fld_str_val));
    } else {
        LOG_DEBUG(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Configure field [%d] as [%lld].\n"),
                  fid, (unsigned long long)fld_val[0]));
    }

exit:
    if (SHR_FAILURE(rv)) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Fail to configure value to field [%d].\n"),
                  fid));
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get data from field.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] sym Enum value list.
 * \param [in] sym_fld_flag  Value of field is enum.
 * \param [in] array_depth Depth of array field.
 * \param [in] fid Field ID.
 * \param [out] fld_val Value of field.
 * \param [out] fld_str_val String value of field.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
xgs_ltsw_l2_fld_val_get(int unit, bcmlt_entry_handle_t eh,
                        const bcmint_l2_sym_map_t *sym,
                        int sym_fld_flag, int array_depth,
                        uint32_t fid, uint64_t *fld_val,
                        const char **fld_str_val)
{
    int rv, i;
    uint32_t r_elem_cnt = 0;

    SHR_FUNC_ENTER(unit);

    if (sym_fld_flag && fld_str_val == NULL) {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }
    if (array_depth) {
        rv = bcmlt_entry_field_array_get_by_id(eh, fid, 0, fld_val,
                                               array_depth, &r_elem_cnt);
    } else if (sym_fld_flag == 0) {
        rv = bcmlt_entry_field_get_by_id(eh, fid, fld_val);
    } else {
        rv = bcmlt_entry_field_symbol_get_by_id(eh, fid, fld_str_val);

        for (i = 0; sym[i].sym_str_val != NULL; i++) {
            if (sal_strcmp(*fld_str_val, sym[i].sym_str_val) == 0) {
                fld_val[0] = sym[i].sym_val;
                break;
            }
        }
    }
    SHR_IF_ERR_EXIT(rv);

    if (sym_fld_flag) {
        LOG_DEBUG(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Get value [%s]  from field [%d].\n"),
                  *fld_str_val, fid));
    } else {
        LOG_DEBUG(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Get value [%lld] from field [%d].\n"),
                  (unsigned long long)fld_val[0], fid));
    }

exit:
    if (SHR_FAILURE(rv)) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Fail to get value from field [%d].\n"),
                  fid));
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get or set data from a member variable.
 *
 * \param [in] unit Unit number
 * \param [in/out] addr Address of member variable.
 * \param [in] type Type of memaber variable.
 * \param [in] op  '|', '=', '&', others will be ignored.
 * \param [in/out] mem_val Data gotten from member variable, or set to member variable.
 * \param [in] dir_to_mem 1: set data to member variable,
 * 0: get data from member variable.
 *
 * \return NONE.
 */
static void
xgs_ltsw_l2_mem_val_assign(int unit, void **addr, const char *type,
                           char op, uint64_t *mem_val, int dir_to_mem)
{
    if (sal_strcmp(type, "uint32_t") == 0) {
        MEMBER_VALUE_ASSIGN(dir_to_mem, op, addr, uint32_t, *mem_val);
    } else if (sal_strcmp(type, "int") == 0) {
        MEMBER_VALUE_ASSIGN(dir_to_mem, op, addr, int, *mem_val);
    } else if (sal_strcmp(type, "bcm_mac_t") == 0) {
        if (dir_to_mem) {
            bcmi_ltsw_util_uint64_to_mac(((uint8_t *)*addr), mem_val);
        } else {
            bcmi_ltsw_util_mac_to_uint64(mem_val, ((uint8_t *)*addr));
        }
    } else if (sal_strcmp(type, "bcm_trunk_t") == 0) {
        MEMBER_VALUE_ASSIGN(dir_to_mem, op, addr, bcm_trunk_t, *mem_val);
    } else if (sal_strcmp(type, "bcm_multicast_t") == 0) {
        MEMBER_VALUE_ASSIGN(dir_to_mem, op, addr, bcm_multicast_t, *mem_val);
    } else if (sal_strcmp(type, "bcm_vlan_t") == 0) {
        MEMBER_VALUE_ASSIGN(dir_to_mem, op, addr, bcm_vlan_t, *mem_val);
    } else if (sal_strcmp(type, "bcm_cos_t") == 0) {
        MEMBER_VALUE_ASSIGN(dir_to_mem, op, addr, bcm_cos_t, *mem_val);
    } else if (sal_strcmp(type, "uint64_t") == 0) {
        MEMBER_VALUE_ASSIGN(dir_to_mem, op, addr, uint64_t, *mem_val);
    } else if (sal_strcmp(type, "bcm_port_t") == 0) {
        MEMBER_VALUE_ASSIGN(dir_to_mem, op, addr, bcm_port_t, *mem_val);
    } else if (sal_strcmp(type, "bool") == 0) {
        MEMBER_VALUE_ASSIGN(dir_to_mem, op, addr, bool, *mem_val);
    } else {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Unknown type %s\n"), type));
    }
}

/*!
 * \brief Populate data to assistant fields.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] hsdk_tid Global ID of LT table defined by HSDK.
 * \param [in] id_map_depth Depth of L2 ID map.
 * \param [in] id_map_base Base address of L2 ID map.
 * \param [in] index Index of L2 ID map,
 * \param [in] data_struct Structure which data will be populated to LT fields.
 * \param [in] cookie User data.
 * \param [in] mem_val Value of member variable related to master LT field.
 * \param [in] fld_val Value of master LT field.
 * \param [in] fld_val String value of master LT field.
 * \param [in] mem_val_used 1: mem_val is valid, 0: fld_val or fld_str_val is valid.
 *
 * \return NONE.
 */
static int
xgs_ltsw_l2_member_ass_flds_populate(int unit, bcmlt_entry_handle_t eh,
                                     bcmint_l2_xgs_lt_id_t hsdk_tid, int id_map_depth,
                                     const bcmint_l2_id_map_t *id_map_base,
                                     int index, void *data_struct, void *cookie,
                                     uint64_t mem_val, uint64_t fld_val,
                                     const char *fld_str_val, bool mem_val_used)
{
    int i, j, rv = SHR_E_UNAVAIL, ass_index, ass_fld_num, found;
    uint32_t ass_fids[NUM_COMB_FLDS];
    const bcmint_l2_sym_map_t *sym_map = NULL;
    const bcmint_l2_fld_map_t *fld_map = id_map_base[index].map;
    uint32_t fid = id_map_base[index].val;
    uint64_t mem_val_0, sym_val;
    const char *sym_str_val = NULL;
    char op;
    uint64_t fld_val_1 = fld_val;

    SHR_FUNC_ENTER(unit);

    sym_map = fld_map->sym_map;
    if (fld_str_val) {
        for (i = 0; sym_map[0].sym_str_val != NULL; i++) {
           if (sal_strcmp(sym_map[i].sym_str_val, fld_str_val) == 0) {
               fld_val_1 = sym_map[i].sym_val;
               break;
           }
        }
    }
    for (i = 0, j = 0; sym_map[i].op != 'n'; i++) {
        if (j >= NUM_COMB_FLDS) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "Number of assitant field can't"
                                  " be larger than [%d]!\n"),
                       NUM_COMB_FLDS));
            SHR_IF_ERR_EXIT(SHR_E_CONFIG);
        }
        found = 0;
        if (mem_val_used) {
            mem_val_0 = sym_map[i].mem_val;
            op = sym_map[i].op;
            if ((op == '=' && mem_val_0 != mem_val) ||
                (op == '|' && (mem_val_0 & mem_val) == 0) ||
                (op == '&' && ((~mem_val_0) & mem_val) != 0)) {
                continue;
            }
            sym_str_val = sym_map[i].sym_str_val;
            sym_val = sym_map[i].sym_val;
            rv = xgs_ltsw_l2_fld_val_set(unit, eh, 0, fid,
                                         &sym_val, sym_str_val);
            SHR_IF_ERR_EXIT(rv);
            if (sym_map[i].ass_fid == INVALID_LT_FID) {
                continue;
            }
            ass_fids[j] = sym_map[i].ass_fid;
            j++;
            found = 1;
        } else {
            if (sym_map[i].sym_val == fld_val_1) {
                if (sym_map[i].ass_fid == INVALID_LT_FID) {
                    continue;
                }
                ass_fids[j] = sym_map[i].ass_fid;
                j++;
                found = 1;
            }
        }
        if (found) {
            LOG_DEBUG(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  " Assistant Field [%d] is selected to be populated.\n"),
                       ass_fids[j - 1]));
        }
    }
    ass_fld_num = j;
    for (i = 0; i < ass_fld_num; i++) {
        for (ass_index = 0; ass_index < id_map_depth; ass_index++) {
            if (id_map_base[ass_index].val == ass_fids[i]) {
                break;
            }
        }
        if (ass_index == id_map_depth) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "Assitant field ID[%d] is not found!\n"),
                       ass_fids[i]));
            SHR_IF_ERR_EXIT(SHR_E_CONFIG);
        } else {
            rv = xgs_ltsw_l2_member_populate(unit, eh, hsdk_tid,
                                             id_map_depth, id_map_base,
                                             ass_index, data_struct, cookie);
            SHR_IF_ERR_EXIT(rv);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Populate data to master or assistant fields.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] hsdk_tid global ID of LT table defined by HSDK.
 * \param [in] id_map_depth depth of L2 ID map.
 * \param [in] id_map_base Base address of L2 ID map.
 * \param [in] index index of L2 ID map,
 * \param [in] data_struct structure which data will be populated to LT fields.
 * \param [in] cookie user data.
 *
 * \return NONE.
 */
static int
xgs_ltsw_l2_member_populate(int unit, bcmlt_entry_handle_t eh,
                            bcmint_l2_xgs_lt_id_t hsdk_tid, int id_map_depth,
                            const bcmint_l2_id_map_t *id_map_base,
                            int index, void *data_struct, void *cookie)
{
    uint8_t *base_addr = (uint8_t *)data_struct;
    void *addr = NULL;
    uint64_t fld_val;
    const char *fld_str_val = NULL;
    uint64_t mem_val = 0;
    int array_size, rv;
    uint64_t *arr_fld_val = NULL;
    bcmint_l2_trans_data_t cb_para;
    const bcmint_l2_fld_map_t *fld_map = id_map_base[index].map;
    uint32_t fid = id_map_base[index].val;
    bool mem_val_used = 0;

    SHR_FUNC_ENTER(unit);

    if (fld_map == NULL || fid == INVALID_FLD_VAL) {
        SHR_IF_ERR_EXIT(SHR_E_CONFIG);
    }
    if (fld_map->trans) {
        sal_memset(&cb_para, 0, sizeof(bcmint_l2_trans_data_t));
        if (fld_map->array_depth) {
            array_size = fld_map->array_depth * sizeof(uint64_t);
            SHR_ALLOC(arr_fld_val, array_size, "L2ArrayFldVal");
            SHR_NULL_CHECK(arr_fld_val, SHR_E_MEMORY);
            sal_memset(arr_fld_val, 0, array_size);
            cb_para.array_depth = fld_map->array_depth;
            cb_para.fld_str_val = NULL;
        } else {
            /* Only need to decode one master field */
            arr_fld_val = &fld_val;
            cb_para.array_depth = 0;
            cb_para.fld_str_val = &fld_str_val;
        }
        cb_para.fld_val = arr_fld_val;
        cb_para.hsdk_tid = hsdk_tid;
        cb_para.cookie = cookie;
        cb_para.struct_data = (void *)base_addr;
        cb_para.offset = fld_map->offset;
        cb_para.ass_fld_val = NULL;
        cb_para.type = fld_map->type;

        /* Return SHR_E_UNAVAIL possibly. Callback 'fld_trans' can only support DIR_PARSE. */
        rv = fld_map->trans(unit, &cb_para, DIR_POPULATE);
        if (rv == SHR_E_NONE) {
            /* Master field has been populated. */
            rv = xgs_ltsw_l2_fld_val_set(unit, eh, fld_map->array_depth, fid,
                                         arr_fld_val, fld_str_val);
            SHR_IF_ERR_EXIT(rv);
            mem_val_used = 0;
        } else if (rv != SHR_E_UNAVAIL) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "Fail to populate data to field[%d]. ERR:[%d]!\n"),
                       fid, rv));
            SHR_IF_ERR_EXIT(rv);
        } else {
            mem_val_used = 1;
        }
    } else {
        rv = SHR_E_UNAVAIL;
        mem_val_used = 1;
    }
    if (fld_map->offset == INVALID_MEMBER_OFFSET || fld_map->array_depth) {
        if (mem_val_used) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "Require transfer callback routine!\n")));
            SHR_IF_ERR_EXIT(SHR_E_CONFIG);
        } else if (fld_map->array_depth) {
            /* Exit */
            SHR_EXIT();
        }
    }
    if (mem_val_used) {
        addr = (void *)(base_addr + fld_map->offset);
        xgs_ltsw_l2_mem_val_assign(unit, &addr, fld_map->type,
                                   '=', &mem_val, DIR_POPULATE);

        if (fld_map->sym_map == NULL &&
            fld_map->flag_val == INVALID_FLG_VAL) {
            fld_val = mem_val;
            rv = xgs_ltsw_l2_fld_val_set(unit, eh, 0, fid, &fld_val, NULL);
            /* Exit */
            SHR_IF_ERR_EXIT(rv);
            SHR_EXIT();
        } else if (fld_map->flag_val != INVALID_FLG_VAL) {
            fld_val = (fld_map->flag_val & mem_val) ? 1 : 0;
            rv = xgs_ltsw_l2_fld_val_set(unit, eh, 0, fid, &fld_val, NULL);
            /* Exit */
            SHR_IF_ERR_EXIT(rv);
            SHR_EXIT();
        }
    }
    if (fld_map->sym_map != NULL) {
        SHR_IF_ERR_EXIT
            (xgs_ltsw_l2_member_ass_flds_populate(unit, eh, hsdk_tid, id_map_depth,
                                                  id_map_base, index, data_struct,
                                                  cookie, mem_val, fld_val,
                                                  fld_str_val, mem_val_used));
    }

exit:
    if (fld_map && fld_map->array_depth) {
        SHR_FREE(arr_fld_val);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse field data to one member variable of a data structure.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] hsdk_tid global ID of LT table defined by HSDK.
 * \param [in] id_map_depth depth of L2 ID map.
 * \param [in] id_map_base Base address of L2 ID map.
 * \param [in] index index of L2 ID map,
 * \param [in] data_struct structure which data will be populated to LT fields.
 * \param [in] cookie user data.
 *
 * \return NONE.
 */
static int
xgs_ltsw_l2_member_parse(int unit, bcmlt_entry_handle_t eh,
                         bcmint_l2_xgs_lt_id_t hsdk_tid, int id_map_depth,
                         const bcmint_l2_id_map_t *id_map_base,
                         int index, void *data_struct, void *cookie,
                         uint64_t *ass_val)
{
    uint8_t *base_addr = (uint8_t *)data_struct;
    void *addr = NULL;
    uint64_t fld_val = 0, mem_val, ass_fid_val[NUM_COMB_FLDS];
    const char *fld_str_val;
    uint32_t ass_fids[NUM_COMB_FLDS];
    int sym_fld_flag = 0, i, array_size, j, rv, ass_index, ass_fld_num;
    uint64_t *arr_fld_val = NULL;
    bcmint_l2_trans_data_t cb_para;
    const bcmint_l2_fld_map_t *fld_map = id_map_base[index].map;
    const bcmint_l2_sym_map_t *sym_map = NULL;
    uint32_t fid = id_map_base[index].val;

    SHR_FUNC_ENTER(unit);

    if (fld_map == NULL || fid == INVALID_FLD_VAL) {
        SHR_IF_ERR_EXIT(SHR_E_CONFIG);
    }
    sym_map = fld_map->sym_map;
    if (sym_map && sym_map[0].sym_str_val) {
        sym_fld_flag = 1;
    }
    if (fld_map->array_depth) {
        array_size = fld_map->array_depth * sizeof(uint64_t);
        SHR_ALLOC(arr_fld_val, array_size, "L2ArrayFldVal");
        SHR_NULL_CHECK(arr_fld_val, SHR_E_MEMORY);
        sal_memset(arr_fld_val, 0, array_size);
    } else {
        arr_fld_val = &fld_val;
    }
    SHR_IF_ERR_EXIT
        (xgs_ltsw_l2_fld_val_get(unit, eh, sym_map, sym_fld_flag,
                                 fld_map->array_depth, fid,
                                 arr_fld_val, &fld_str_val));
    if (fld_map->trans) {
        sal_memset(&cb_para, 0, sizeof(bcmint_l2_trans_data_t));
        cb_para.hsdk_tid = hsdk_tid;
        cb_para.cookie = cookie;
        cb_para.struct_data = (void *)base_addr;
        cb_para.fld_val = arr_fld_val;
        cb_para.type = fld_map->type;
        cb_para.array_depth = fld_map->array_depth;
        cb_para.offset = fld_map->offset;
        cb_para.fld_str_val = &fld_str_val;
        cb_para.ass_fld_val = ass_val;
        /* Callback 'fld_trans' only supports DIR_POPULATE */
        rv = fld_map->trans(unit, &cb_para, DIR_PARSE);

        if (rv != SHR_E_UNAVAIL && rv != SHR_E_NONE) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "Fail to parse data of field[%d]"
                                  " to member value. ERR:[%d]!\n"),
                       fid, rv));
            SHR_IF_ERR_EXIT(rv);
        }
    } else {
        rv = SHR_E_UNAVAIL;
    }
    if (fld_map->offset == INVALID_MEMBER_OFFSET || fld_map->array_depth) {
        if (rv == SHR_E_UNAVAIL) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "Require transfer routine!\n")));
            SHR_IF_ERR_EXIT(SHR_E_CONFIG);
        } else if (fld_map->array_depth) {
            /* Exit */
            SHR_EXIT();
        }
    }
    if (fld_map->sym_map == NULL && fld_map->flag_val == INVALID_FLG_VAL) {
        if (fld_map->offset < INVALID_MEMBER_OFFSET) {
            addr = (void *)(base_addr + fld_map->offset);
            mem_val = fld_val;
            xgs_ltsw_l2_mem_val_assign(unit, &addr, fld_map->type,
                                       '=', &mem_val, DIR_PARSE);
        }
    } else if (fld_map->flag_val != INVALID_FLG_VAL) {
        if (fld_map->offset < INVALID_MEMBER_OFFSET) {
            addr = (void *)(base_addr + fld_map->offset);
            mem_val = fld_val ? fld_map->flag_val : 0;
            xgs_ltsw_l2_mem_val_assign(unit, &addr, fld_map->type,
                                       '|', &mem_val, DIR_PARSE);
        }
    } else if (sym_map != NULL) {
        /* Parse assistant fields */
        for (i = 0, j = 0; sym_map[i].op != 'n'; i++) {
            if (j >= NUM_COMB_FLDS) {
                LOG_ERROR(BSL_LOG_MODULE,
                          (BSL_META_U(unit,
                                      "Number of assitant field can't"
                                      " be larger than [%d]!\n"),
                           NUM_COMB_FLDS));
                SHR_IF_ERR_EXIT(SHR_E_CONFIG);
            }
            if (fld_val != sym_map[i].sym_val) {
                continue;
            }
            if (fld_map->offset < INVALID_MEMBER_OFFSET) {
                mem_val = sym_map[i].mem_val;
                addr = (void *)(base_addr + fld_map->offset);
                xgs_ltsw_l2_mem_val_assign(unit, &addr, fld_map->type,
                                           sym_map[i].op, &mem_val, DIR_PARSE);
            }
            if (sym_map[i].ass_fid == INVALID_LT_FID) {
                continue;
            }
            ass_fids[j] = sym_map[i].ass_fid;
            if (fid == ass_fids[j]) {
                LOG_ERROR(BSL_LOG_MODULE,
                          (BSL_META_U(unit,
                                      " Field [%d] can't assist itself\n"),
                           fid));
                SHR_IF_ERR_EXIT(SHR_E_CONFIG);
            }
            LOG_DEBUG(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  " Assistant Field [%d] is selected to be parsed.\n"),
                       ass_fids[j]));
            j++;
        }
        ass_fld_num = j;

        for (i = 0; i < ass_fld_num; i++) {
            for (ass_index = 0; ass_index < id_map_depth; ass_index++) {
                if (id_map_base[ass_index].val == ass_fids[i]) {
                    break;
                }
            }
            if (ass_index == id_map_depth) {
                LOG_ERROR(BSL_LOG_MODULE,
                          (BSL_META_U(unit,
                                      "Assitant field ID[%d] is not found!\n"),
                           ass_fids[i]));
                SHR_IF_ERR_EXIT(SHR_E_CONFIG);
            } else {
                rv = xgs_ltsw_l2_member_parse(unit, eh, hsdk_tid,
                                              id_map_depth, id_map_base,
                                              ass_index, data_struct,
                                              cookie, ass_fid_val);
                SHR_IF_ERR_EXIT(rv);
            }
        }
    }

exit:
    if (fld_map && fld_map->array_depth) {
        SHR_FREE(arr_fld_val);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Populate data to LT fields, the data comes from a structure.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] lt_map L2 ID map.
 * \param [in] select_flags Used to filter some fields.
 * \param [in] data_struct structure which data will be populated to LT fields.
 * \param [in] cookie user data.
 *
 * \return NONE.
 */
static int
xgs_ltsw_l2_struct_populate(int unit, bcmlt_entry_handle_t eh,
                            const bcmint_l2_map_info_t *lt_map, uint32_t select_flags,
                            void *data_struct, void *cookie)
{
    int i;
    const bcmint_l2_id_map_t *id_map = NULL;

    SHR_FUNC_ENTER(unit);

    id_map = lt_map->id_map;

    if (data_struct == NULL && cookie == NULL) {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }
    LOG_DEBUG(BSL_LOG_MODULE,
              (BSL_META_U(unit,
                          "Populate data to LT [%s].\n"),
               lt_map->lt_name));
    for (i = 0; i < lt_map->depth; i++) {
        if (!(select_flags & id_map[i].map->filter)) {
            continue;
        }
        SHR_IF_ERR_EXIT
            (xgs_ltsw_l2_member_populate(unit, eh, lt_map->hsdk_tid,
                                         lt_map->depth, lt_map->id_map,
                                         i, data_struct, cookie));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse field data to a data structure.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] lt_map L2 ID map.
 * \param [in] select_flags Used to filter some fields.
 * \param [in] data_struct structure which data will be populated to LT fields.
 * \param [in] cookie user data.
 *
 * \return NONE.
 */
static int
xgs_ltsw_l2_struct_parse(int unit, bcmlt_entry_handle_t eh,
                         const bcmint_l2_map_info_t *lt_map, uint32_t select_flags,
                         void *data_struct, void *cookie)
{
    int i;
    const bcmint_l2_id_map_t *id_map = NULL;

    SHR_FUNC_ENTER(unit);

    if (data_struct == NULL && cookie == NULL) {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }
    id_map = lt_map->id_map;

    LOG_DEBUG(BSL_LOG_MODULE,
              (BSL_META_U(unit,
                          "Parse data from LT [%s].\n"),
               lt_map->lt_name));

    for (i = 0; i < lt_map->depth; i++) {
        if (!(select_flags & id_map[i].map->filter) ||
            (id_map[i].map->filter & SELECT_FLAG_ONLY_POPULATE_USED)) {
            continue;
        }
        SHR_IF_ERR_EXIT
            (xgs_ltsw_l2_member_parse(unit, eh, lt_map->hsdk_tid,
                                      lt_map->depth, lt_map->id_map,
                                      i, data_struct, cookie, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get L2 LT ID information according to LT ID defined by HSDK.
 *
 * \param [in] unit Unit number
 * \param [in] l2_lt_id L2 LT ID.
 *
 * \return LT ID information.
 */
static const bcmint_l2_map_info_t *
xgs_ltsw_l2_lt_info_get(int unit, bcmint_l2_xgs_lt_id_t l2_lt_id)
{
    int i;

    for (i = 0; i < XGS_L2_MAX_NUM; i++) {
        if (l2_lt_map_info[unit][i].hsdk_tid == l2_lt_id) {
            break;
        }
    }
    if (i == XGS_L2_MAX_NUM) {
        return NULL;
    } else {
        return &(l2_lt_map_info[unit][i]);
    }
}

/*!
 * \brief Configure TABLE_CONTROL.
 *
 * \param [in]   unit Unit number
 * \param [in]   tbl_name Lt table name.
 * \param [in]   tbl_op_pt_info Enable or disable to record
 * physical table address information for operations in this LT.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
lt_tbl_control_config(int unit, const char *tbl_name, bool tbl_op_pt_info)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_CONTROLs, &eh));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(eh, TABLE_IDs, tbl_name));

    data = tbl_op_pt_info ? 1 : 0;

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(eh, TABLE_OP_PT_INFOs, data));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get physical table index for operations in this LT through TABLE_OP_PT_INFO.
 *
 * \param [in] unit Unit number
 * \param [in] tbl_name Lt table name.
 * \param [out] index_array Physical table indexes accessed for this LT operation.
 * \param [in/out] array_num Number of index.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
lt_tbl_op_pt_info_index_get(int unit, const char *tbl_name,
                            int *index_array, uint32_t *array_num)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint32_t actual_index_num = 0, i;
    uint64_t index_num, indexes[16];

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_OP_PT_INFOs, &eh));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(eh, TABLE_IDs, tbl_name));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(eh, PT_INDEX_CNTs, &index_num));
    /*
     * One LT can map with multiple physical tables.
     * When one LT is accessed, multiple physical tables are accessed.
     * So number of index can be larger than 1.
     */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_get(eh, PT_INDEXs, 0, indexes,
                                     16, &actual_index_num));
    for (i = 0; i < *array_num && i < actual_index_num; i++) {
        index_array[i] = (int)indexes[i];
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check whether L2 cache is supported or not.
 *
 * \param [in] unit Unit number.
 *
 * \return true or false.
 */
static int
l2_cache_is_supported(int unit)
{
    bool skip;

    skip = bcmi_ltsw_property_get(unit, BCMI_CPN_SKIP_L2_USER_ENTRY, false);
    if (skip || (ltsw_feature(unit, LTSW_FT_L2_USER_ENTRY) == 0)) {
        return false;
    } else {
        return true;
    }
}

/*!
 * \brief Transfer data structure from L2 cache to L2 station.
 *
 * \param [in] unit Unit number.
 * \param [in] l2caddr Data structure of l2 cache.
 * \param [out] l2station Data structure of l2 station.
 *
 * \return NONE.
 */
static void
l2_cache_to_my_station_transfer(int unit, bcm_l2_cache_addr_t *l2caddr,
                                bcm_l2_station_t *l2station, int key_only)
{
    sal_memset(l2station, 0, sizeof(bcm_l2_station_t));
    if (key_only == 0) {
        if (l2caddr->flags & BCM_L2_CACHE_DISCARD) {
            l2station->flags |= BCM_L2_STATION_DISCARD;
        }
        if (l2caddr->flags & BCM_L2_CACHE_CPU) {
            l2station->flags |= BCM_L2_STATION_COPY_TO_CPU;
        }
    }
    sal_memcpy(l2station->dst_mac, l2caddr->mac, sizeof(bcm_mac_t));
    sal_memcpy(l2station->dst_mac_mask, l2caddr->mac_mask, sizeof(bcm_mac_t));
    l2station->vlan = l2caddr->vlan;
    l2station->vlan_mask = l2caddr->vlan_mask;
}

/*!
 * \brief Transfer data structure from L2 station to L2 cache.
 *
 * \param [in] unit Unit number.
 * \param [in] l2station Data structure of l2 station.
 * \param [out] l2caddr Data structure of l2 cache.
 *
 * \return NONE.
 */
static void
l2_my_station_to_cache_transfer(int unit, bcm_l2_station_t *l2station,
                                bcm_l2_cache_addr_t *l2caddr)
{
    sal_memset(l2caddr, 0, sizeof(bcm_l2_cache_addr_t));

    if (l2station->flags & BCM_L2_STATION_DISCARD) {
        l2caddr->flags |= BCM_L2_CACHE_DISCARD;
    }
    if (l2station->flags & BCM_L2_STATION_COPY_TO_CPU) {
        l2caddr->flags |= BCM_L2_CACHE_CPU;
    }
    sal_memcpy(l2caddr->mac, l2station->dst_mac, sizeof(bcm_mac_t));
    sal_memcpy(l2caddr->mac_mask, l2station->dst_mac_mask, sizeof(bcm_mac_t));
    l2caddr->vlan = l2station->vlan;
    l2caddr->vlan_mask = l2station->vlan_mask;
    l2caddr->src_port = l2station->src_port;
    l2caddr->src_port_mask = l2station->src_port_mask;
}

/*!
 * \brief Parse LT entry and fill API data structure.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] lt_info LT information.
 * \param [out] user_data L2 caching address structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_cache_entry_parse(int unit, bcmlt_entry_handle_t eh,
                     const bcmint_l2_map_info_t *lt_info,
                     void *user_data)
{
    bcm_l2_cache_addr_t *l2caddr = (bcm_l2_cache_addr_t *)user_data;
    uint32_t select_flags = SELECT_FLAG_KEY | SELECT_FLAG_DATA;

    SHR_FUNC_ENTER(unit);

    sal_memset(l2caddr, 0, sizeof(bcm_l2_cache_addr_t));

    SHR_IF_ERR_EXIT
        (xgs_ltsw_l2_struct_parse(unit, eh, lt_info,
                                  select_flags, user_data, NULL));

    if (BCM_MAC_IS_MCAST(l2caddr->mac)) {
        l2caddr->flags |= BCM_L2_CACHE_MULTICAST;
        l2caddr->group = l2caddr->dest_port;
        _BCM_MULTICAST_GROUP_SET(l2caddr->group, _BCM_MULTICAST_TYPE_L2,
                                 l2caddr->group);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief L2 module traverse function.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index >= 0, only get entry data of this index,
 * Index < 0, traverse all entries.
 * \param [in] cb Callback routine.
 * \param [out] user_data User data structure saved entry data.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_cache_traverse(int unit, int index, bcmint_l2_cache_trav_cb cb,
                  const bcmint_l2_map_info_t *lt_info,
                  void *user_data, int use_my_station, int del)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit, index_used;
    int rv = SHR_E_NONE;
    uint32_t index_num;
    bcm_l2_cache_addr_t l2caddr;
    bcm_l2_station_t l2station;
    bool found, tnl = 0;

    SHR_FUNC_ENTER(unit);

    if (index >= 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_tbl_control_config(unit, lt_info->lt_name, 1));
    }
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh));

    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_TRAVERSE,
                            BCMLT_PRIORITY_NORMAL);
    while (rv == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_cache_entry_parse(unit, eh, lt_info, user_data));
        if (index >= 0) {
            index_num = 1;
            SHR_IF_ERR_VERBOSE_EXIT
                (lt_tbl_op_pt_info_index_get(unit, lt_info->lt_name,
                                             &index_used, &index_num));
        }
        rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_TRAVERSE,
                                BCMLT_PRIORITY_NORMAL);
        if (index >= 0) {
            if (index_used == index) {
                if (cb != NULL) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (cb(unit, lt_info, user_data));
                }
                if (use_my_station == 0) {
                    rv = SHR_E_NONE;
                    break;
                }
                /* Get data from MY_STATION */
                sal_memcpy(&l2caddr, user_data, sizeof(bcm_l2_cache_addr_t));

                l2_cache_to_my_station_transfer(unit, &l2caddr, &l2station, 1);
                if (del == 0) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (xgs_ltsw_l2_station_get(unit, &l2station, 0));

                    if (user_data != NULL) {
                        sal_memset(&l2caddr, 0, sizeof(l2caddr));
                        l2_my_station_to_cache_transfer(unit, &l2station, &l2caddr);

                        sal_memcpy(user_data, (void *)(&l2caddr), sizeof(l2caddr));
                    }
                } else {
                    found = bcmint_l2_station_db_get(unit, &l2station, &tnl);
                    if (found && !tnl) {
                        rv = SHR_E_NONE;
                        /* exit, does not need to delete. */
                        break;
                    }
                    /* Return value can be "SHE_E_NOT_FOUND" */
                    (void)xgs_ltsw_l2_station_delete(unit, &l2station, 0);
                }
                rv = SHR_E_NONE;
                break;
            }
        } else {
            if (cb != NULL) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (cb(unit, lt_info, user_data));
            }
            if (use_my_station && del == 1) {
                sal_memcpy(&l2caddr, user_data, sizeof(bcm_l2_cache_addr_t));

                l2_cache_to_my_station_transfer(unit, &l2caddr, &l2station, 1);

                found = bcmint_l2_station_db_get(unit, &l2station, &tnl);
                if (found == 0 || tnl) {
                    /* Return value can be "SHE_E_NOT_FOUND" */
                    (void)xgs_ltsw_l2_station_delete(unit, &l2station, 0);
                }
            }
        }
    }
    /* Traverse all indexes */
    if (index < 0) {
        /* If not found, it must be the last one */
        if (rv == SHR_E_NOT_FOUND) {
            rv = SHR_E_NONE;
        }
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    if (index >= 0) {
        (void)lt_tbl_control_config(unit, lt_info->lt_name, 0);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Populate LT entry according to API data structure
 * of l2 caching of MAC addresses.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] l2_cache_addr L2 cache structure.
 * \param [in] key Only populate data to key fields.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_cache_entry_populate(int unit, bcmlt_entry_handle_t eh,
                        const bcmint_l2_map_info_t *lt_info,
                        bcm_l2_cache_addr_t *l2caddr, int key_only)
{
    uint32_t select_flags = SELECT_FLAG_KEY;
    int tgid, id, modid, port;
    bcm_l2_cache_addr_t l2caddr_data;

    SHR_FUNC_ENTER(unit);

    select_flags |= key_only ? 0 : SELECT_FLAG_DATA;

    sal_memcpy(&l2caddr_data, l2caddr, sizeof(bcm_l2_cache_addr_t));

    if (l2caddr->flags & BCM_L2_CACHE_SETPRI) {
        if (l2caddr->prio < 0 || l2caddr->prio > 15) {
            SHR_IF_ERR_EXIT(SHR_E_PARAM);
        }
    }
    if (l2caddr->flags & BCM_L2_CACHE_MULTICAST &&
        _BCM_MULTICAST_IS_SET(l2caddr->group)) {
        if (_BCM_MULTICAST_IS_L2(l2caddr->group)) {
            l2caddr_data.dest_port = _BCM_MULTICAST_ID_GET(l2caddr->group);
        } else {
            SHR_IF_ERR_EXIT(SHR_E_PARAM);
        }
    } else if (BCM_GPORT_IS_SET(l2caddr->dest_port)) {
        SHR_IF_ERR_EXIT
            (bcmi_ltsw_port_gport_resolve(unit, l2caddr->dest_port,
                                          &modid, &port, &tgid, &id));
        if (BCM_TRUNK_INVALID != tgid) {
            /* Trunk GPORT */
            l2caddr_data.flags |= BCM_L2_CACHE_TRUNK;
            l2caddr_data.dest_trunk = tgid;
        } else {
            /* MODPORT GPORT */
            l2caddr_data.dest_port = port;
        }
    } else {
        SHR_IF_ERR_EXIT
            (bcmi_ltsw_port_gport_validate(unit, l2caddr->dest_port, &port));
        l2caddr_data.dest_port = port;
    }
    SHR_IF_ERR_EXIT
        (xgs_ltsw_l2_struct_populate(unit, eh, lt_info, select_flags,
                                     (void *)&l2caddr_data, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete entry from l2 caching address.
 *
 * \param [in] unit Unit number
 * \param [in] lt_info LT information.
 * \param [in] user_data Data of cache entry.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_cache_entry_delete(int unit,
                     const bcmint_l2_map_info_t *lt_info,
                     void *user_data)
{
    int dunit;
    bcmlt_entry_handle_t eh_backup = BCMLT_INVALID_HDL;
    bcm_l2_cache_addr_t *l2caddr = NULL;

    SHR_FUNC_ENTER(unit);

    if (user_data == NULL) {
        SHR_IF_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh_backup));

    l2caddr = (bcm_l2_cache_addr_t *)user_data;
    SHR_IF_ERR_EXIT
        (l2_cache_entry_populate(unit, eh_backup, lt_info, l2caddr, 1));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(eh_backup, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (eh_backup != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh_backup);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert a entry into L2 caching address table.
 *
 * \param [in] unit Unit number.
 * \param [in] l2addr L2 caching address structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_cache_insert(int unit, bcm_l2_cache_addr_t *l2caddr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit, rv;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_CACHE_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_cache_entry_populate(unit, eh, lt_info, l2caddr, 0));

    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_INSERT, BCMLT_PRIORITY_NORMAL);

    if (rv == SHR_E_EXISTS) {
        /* Update all fields of existing entry */
        rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL);
    }
    SHR_IF_ERR_EXIT(rv);

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert an entry into L2_DST_BLOCK.
 *
 * \param [in] unit Unit number.
 * \param [in] index Profile entry index.
 * \param [out] profile Profile entry.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
l2_dst_block_entry_insert(int unit, int index, bcm_pbmp_t *profile)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    ltsw_l2_dst_blk_t dst_blk_info;
    const bcmint_l2_map_info_t *lt_info = NULL;
    uint32_t select_flags = SELECT_FLAG_KEY | SELECT_FLAG_DATA;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_DST_BLOCK_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    dst_blk_info.index = index;
    sal_memcpy(&(dst_blk_info.profile), profile, sizeof(bcm_pbmp_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_l2_struct_populate(unit, entry_hdl, lt_info, select_flags,
                                     (void *)&dst_blk_info, NULL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_INSERT,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete an entry from L2_DST_BLOCK.
 *
 * \param [in] unit Unit number.
 * \param [in] index Profile entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
l2_dst_block_entry_delete(int unit, int index)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const bcmint_l2_map_info_t *lt_info = NULL;
    ltsw_l2_dst_blk_t dst_blk_info;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    dst_blk_info.index = index;

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_DST_BLOCK_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_l2_struct_populate(unit, entry_hdl, lt_info, SELECT_FLAG_KEY,
                                     (void *)&dst_blk_info, NULL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash of L2_DST_BLOCK profile set.
 *
 * \param [in] unit Unit number.
 * \param [in] entries First profile entry in the set.
 * \param [in] entries_per_set Number of profile entries in the set.
 * \param [out] hash Hash value.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
l2_dst_block_profile_hash(int unit, void *entries,
                          int entries_per_set, uint32_t *hash)
{
    *hash = shr_crc32(0, entries, sizeof(bcm_pbmp_t));
    return SHR_E_NONE;
}

/*!
 * \brief Get profile entry from L2_DST_BLOCK.
 *
 * \param [in] unit Unit number.
 * \param [in] index Profile entry index.
 * \param [out] profile Profile entry.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
l2_dst_block_profile_get(int unit, int index, void *profile)
{
    int dunit;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t *block_mask = NULL;
    const bcmint_l2_map_info_t *lt_info = NULL;
    ltsw_l2_dst_blk_t dst_blk_info;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    dst_blk_info.index = index;
    BCM_PBMP_CLEAR(dst_blk_info.profile);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_DST_BLOCK_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_l2_struct_populate(unit, entry_hdl, lt_info, SELECT_FLAG_KEY,
                                     (void *)&dst_blk_info, NULL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_l2_struct_parse(unit, entry_hdl, lt_info, SELECT_FLAG_DATA,
                                  (void *)&dst_blk_info, NULL));

    sal_memcpy(profile, &(dst_blk_info.profile), sizeof(bcm_pbmp_t));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FREE(block_mask);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add profile.
 *
 * If same entries existed, just increament reference count.
 *
 * \param [in] unit Unit number.
 * \param [in] profile Profile to be added.
 * \param [in] ref_count Add how many reference counts for this profile.
 * \param [out] index Index of the added or existed profile enrty.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
int
l2_dst_block_profile_add(int unit, void *profile, int ref_count, int *index)
{
    int entry_idx, rv, rvt;
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_L2_DST_BLOCK;
    bcm_pbmp_t pbmp;

    SHR_FUNC_ENTER(unit);

    sal_memcpy(&pbmp, profile, sizeof(bcm_pbmp_t));

    rv = bcmi_ltsw_profile_index_allocate
            (unit, profile_hdl, profile, 0, 1, &entry_idx);
    if (rv == SHR_E_NONE) {
        /* write profile to LT entry */
        rvt = l2_dst_block_entry_insert(unit, entry_idx, &pbmp);
        if (SHR_FAILURE(rvt)) {
            /* free allocated index */
            (void)bcmi_ltsw_profile_index_free(unit, profile_hdl, entry_idx);
            SHR_ERR_EXIT(rvt);
        }
    } else if (rv != SHR_E_EXISTS) {
        SHR_ERR_EXIT(rv);
    }
    *index = entry_idx;

    if (ref_count > 1) {
        /* increment reference count if more than one ref_count */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase
                (unit, profile_hdl, 1, entry_idx, (ref_count - 1)));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete profile.
 *
 * If the entry is referred by more than one soure, just decreament ref count.
 *
 * \param [in] unit Unit number.
 * \param [in] index Index of the first entry to be deleted.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
int
l2_dst_block_profile_delete(int unit, int index)
{
    int rv;
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_L2_DST_BLOCK;

    SHR_FUNC_ENTER(unit);

    rv = bcmi_ltsw_profile_index_free(unit, profile_hdl, index);
    if (rv == SHR_E_NONE) {
        /* delete LT entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_dst_block_entry_delete(unit, index));
    } else if (rv != SHR_E_BUSY) {
        SHR_ERR_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare profile set.
 *
 * Compare if given L2_DST_BLOCK profile entries equals to
 * the entries in LT.
 *
 * \param [in] unit Unit number.
 * \param [in] entries First profile entry in the set.
 * \param [in] entries_per_set Number of profile entries in the set.
 * \param [in] index Profile table index to be compared.
 * \param [out] cmp 0 if equal, otherwise not equal.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
l2_dst_block_profile_cmp(int unit, void *entries,
                         int entries_per_set, int index, int *cmp)
{
    int profile_size;
    void *profile = NULL;

    SHR_FUNC_ENTER(unit);

    profile_size = sizeof(bcm_pbmp_t);
    SHR_ALLOC(profile, profile_size, "profile");
    SHR_NULL_CHECK(profile, SHR_E_MEMORY);
    sal_memset(profile, 0, profile_size);

    /* read LT entries starting from index */
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_dst_block_profile_get(unit, index, profile));

    *cmp = sal_memcmp(entries, profile, profile_size);

exit:
    SHR_FREE(profile);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover hash and reference count for profile.
 *
 * Hash is recovered from HW. Reference count is always increamented.
 *
 * \param [in] unit Unit number.
 * \param [in] index Profile index to be recovered.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
int
l2_dst_block_profile_per_index_recover(int unit, int index)
{
    int profile_size;
    void *profile = NULL;
    uint32_t ref_count;
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_L2_DST_BLOCK;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_get(unit, profile_hdl, index, &ref_count));
    /* the profile entry is not allocated */
    if (ref_count == 0) {
        profile_size = sizeof(bcm_pbmp_t);
        SHR_ALLOC(profile, profile_size, "profile");
        SHR_NULL_CHECK(profile, SHR_E_MEMORY);
        sal_memset(profile, 0, profile_size);
        /* read profile LT entries */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_dst_block_profile_get(unit, index, profile));
        /* recover profile hash */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_hash_update
                (unit, profile_hdl, profile, 1, index));
    }
    /* increment reference count */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_ref_count_increase
            (unit, profile_hdl, 1, index, 1));

exit:
    SHR_FREE(profile);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover L2_DST_BLOCK profile during warmboot.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
l2_dst_block_profile_recover(int unit)
{
    int entry_idx, dunit, l2_port_blk, profile_index;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    const bcmint_l2_map_info_t *lt_info = NULL;
    bcm_l2_addr_t l2addr;

    SHR_FUNC_ENTER(unit);

    /* Profile index 0 is reserved. */
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_dst_block_profile_per_index_recover(unit, 0));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_switch_control_get(unit, bcmSwitchL2PortBlocking,
                                     &l2_port_blk));
    if (l2_port_blk == 0) {
        SHR_EXIT();
    }
    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    dunit = bcmi_ltsw_dev_dunit(unit);
    /* read all entries from L2_FDB_VLANs.CLASS_IDs */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh));
    while (bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_TRAVERSE,
                                BCMLT_PRIORITY_NORMAL) == SHR_E_NONE) {

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_ltsw_l2_struct_parse(unit, eh, lt_info,
                                      SELECT_FLAG_L2_HOST_TAB_CLASS_ID,
                                      (void *)&l2addr, (void *)&profile_index));
        entry_idx = profile_index;

        if (entry_idx > 0) {
            /* recover the index */
            SHR_IF_ERR_VERBOSE_EXIT
                (l2_dst_block_profile_per_index_recover(unit, entry_idx));
        }
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize L2_DST_BLOCK profile information.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
l2_opaque_tag_init(int unit, bool warm)
{
    uint32_t ha_alloc_size , ha_req_size, ha_instance_size;
    int rv;

    SHR_FUNC_ENTER(unit);

    ha_instance_size = sizeof(bcmint_l2_opaque_tag_t);
    ha_req_size = ha_instance_size * (NUM_OPAQUE_TAG + NUM_PAYLOAD_OPAQUE_TAG);
    ha_alloc_size = ha_req_size;
    opaque_tag_config[unit] =
        bcmi_ltsw_ha_mem_alloc(unit,
                               BCMI_HA_COMP_ID_L2,
                               BCMINT_L2_SUB_COMP_ID_OPAQUE_TAG,
                               "bcmL2OpaqueTag",
                               &ha_alloc_size);
    SHR_NULL_CHECK(opaque_tag_config[unit], SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT((ha_alloc_size < ha_req_size) ?
                            SHR_E_MEMORY : SHR_E_NONE);

    if (!warm) {
        sal_memset(opaque_tag_config[unit], 0, ha_alloc_size);
    }
    rv = bcmi_ltsw_issu_struct_info_report(unit,
             BCMI_HA_COMP_ID_L2,
             BCMINT_L2_SUB_COMP_ID_OPAQUE_TAG,
             0, ha_instance_size, (NUM_OPAQUE_TAG + NUM_PAYLOAD_OPAQUE_TAG),
             BCMINT_L2_OPAQUE_TAG_T_ID);
    if (rv != SHR_E_EXISTS) {
       SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize L2_DST_BLOCK profile information.
 *
 * \param [in] unit Unit number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
l2_dst_block_profile_init(int unit)
{
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_L2_DST_BLOCK;
    int min_index, max_index, entry_index;
    uint32_t max_index_u;
    bcm_pbmp_t pbmp;
    const bcmint_l2_map_info_t *lt_info;

    SHR_FUNC_ENTER(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_DST_BLOCK_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, lt_info->lt_name, &max_index_u));
    max_index = max_index_u;
    min_index = 0;
    /* unregister in case the profile already exists */
    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_ltsw_profile_unregister(unit, profile_hdl),
         SHR_E_NOT_FOUND);
    /* register profile for L2_DST_BLOCK */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register
            (unit, &profile_hdl, &min_index, &max_index, 1,
             l2_dst_block_profile_hash,
             l2_dst_block_profile_cmp));

    if (bcmi_warmboot_get(unit)) {
        /* exit */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_dst_block_profile_recover(unit));
        SHR_EXIT();
    }
    /* clear profile table */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, lt_info->lt_name));

    sal_memset(&pbmp, 0, sizeof(pbmp));
    /* Profile index 0 is reserved. */
    SHR_IF_ERR_EXIT
        (l2_dst_block_profile_add
            (unit, (void *)(&pbmp), 1, &entry_index));
    if (entry_index != 0) {
        SHR_IF_ERR_EXIT(SHR_E_INTERNAL);
    }
    /* L2 table has been cleaned up as zero */

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Populate LT entry according to API data structure.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] l2addr L2 address structure.
 * \param [in] key_only Only populate key.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_entry_populate(int unit, bcmlt_entry_handle_t eh,
                  const bcmint_l2_map_info_t *lt_info,
                  bcm_l2_addr_t *l2addr, bool key_only)
{
    uint32_t select_flags = 0;

    SHR_FUNC_ENTER(unit);

    select_flags |= SELECT_FLAG_KEY;

    if (key_only == 0) {
        select_flags |= SELECT_FLAG_DATA;
    }

    SHR_IF_ERR_EXIT
        (xgs_ltsw_l2_struct_populate(unit, eh, lt_info, select_flags,
                                     (void *)l2addr, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse LT entry and fill API data structure.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] age Only get value of Static and Hit value for aging operation.
 * \param [out] l2addr L2 address structure.
 * \param [out] l2_dst_block_id Index of L2_DST_BLOCKs.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_entry_parse(int unit, bcmlt_entry_handle_t eh, int age,
               const bcmint_l2_map_info_t *lt_info,
               bcm_l2_addr_t *l2addr, int *l2_dst_block_id)
{
    uint32_t select_flags = 0;

    SHR_FUNC_ENTER(unit);

    select_flags |= SELECT_FLAG_KEY;
    if (age) {
        select_flags |= SELECT_FLAG_L2_HOST_TAB_AGE | SELECT_FLAG_L2_HOST_TAB_CLASS_ID;
    } else {
        select_flags |= SELECT_FLAG_DATA;
    }

    SHR_IF_ERR_EXIT
        (xgs_ltsw_l2_struct_parse(unit, eh, lt_info, select_flags,
                                  (void *)l2addr, (void *)l2_dst_block_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse LT entry and fill API data structure.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [out] l2addr L2 address structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_station_to_l2_addr_parse(int unit, bcmlt_entry_handle_t eh,
                            const bcmint_l2_map_info_t *lt_info,
                            bcm_l2_addr_t *l2addr)
{
    bcm_l2_station_t l2_station;

    SHR_FUNC_ENTER(unit);

    sal_memset(l2addr, 0, sizeof(bcm_l2_addr_t));
    sal_memset(&l2_station, 0, sizeof(bcm_l2_station_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_l2_struct_parse(unit, eh, lt_info,
                                  SELECT_FLAG_DATA | SELECT_FLAG_KEY,
                                  (void *)&l2_station, NULL));

    l2addr->flags |= BCM_L2_LEARN_LIMIT_EXEMPT;
    if (l2_station.flags & BCM_L2_STATION_COPY_TO_CPU) {
        l2addr->flags |= BCM_L2_COPY_TO_CPU;
    }
    if (l2_station.flags & BCM_L2_STATION_DISCARD) {
        l2addr->flags |= BCM_L2_DISCARD_DST;
    }
    if (l2_station.flags & BCM_L2_STATION_IPV4) {
        l2addr->flags |= BCM_L2_L3LOOKUP;
    }
    sal_memcpy(l2addr->mac, l2_station.dst_mac, sizeof(bcm_mac_t));
    l2addr->vid = l2_station.vlan;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Populate L2 station entry according to API data structure bcm_l2_addr_t.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] l2addr L2 address structure.
 * \param [in] key Only populate key field data.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_station_from_l2_addr_populate(int unit, bcmlt_entry_handle_t eh,
                                 const bcmint_l2_map_info_t *lt_info,
                                 bcm_l2_addr_t *l2addr, int key)
{
    bcm_l2_station_t l2_station;
    uint32_t select_flags = 0;

    SHR_FUNC_ENTER(unit);

    if (key) {
        select_flags = SELECT_FLAG_KEY;
    } else {
        select_flags = SELECT_FLAG_KEY | SELECT_FLAG_DATA;
    }
    sal_memset(&l2_station, 0, sizeof(bcm_l2_station_t));

    sal_memcpy(l2_station.dst_mac, l2addr->mac, sizeof(bcm_mac_t));

    sal_memset(l2_station.dst_mac_mask, 0xff, sizeof(bcm_mac_t));

    l2_station.vlan = l2addr->vid;
    l2_station.vlan_mask = 0xfff;

    if (l2addr->flags & BCM_L2_COPY_TO_CPU) {
        l2_station.flags |= BCM_L2_STATION_COPY_TO_CPU;
    }
    if (l2addr->flags & BCM_L2_DISCARD_DST) {
        l2_station.flags |= BCM_L2_STATION_DISCARD;
    }
    if (l2addr->flags & BCM_L2_L3LOOKUP) {
        l2_station.flags |= BCM_L2_STATION_IPV4 | BCM_L2_STATION_IPV6;
        l2_station.flags |= BCM_L2_STATION_ARP_RARP;
    }
    l2_station.flags |= BCM_L2_STATION_UNDERLAY;

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_l2_struct_populate(unit, eh, lt_info, select_flags,
                                     (void *)&l2_station, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert L2 station entry according to API data structure bcm_l2_addr_t.
 *
 * \param [in] unit Unit number
 * \param [in] l2addr L2 address structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_station_insert(int unit, bcm_l2_addr_t *l2addr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit, rv = SHR_E_NONE;
    bcm_l2_station_t l2station;
    bool tnl = 0, found = 0;
    const bcmint_l2_map_info_t *lt_info, *lt_underlay_info;

    SHR_FUNC_ENTER(unit);

    sal_memset(&l2station, 0, sizeof(bcm_l2_station_t));
    sal_memcpy(l2station.dst_mac, l2addr->mac, sizeof(bcm_mac_t));
    sal_memset(l2station.dst_mac_mask, 0xff, sizeof(bcm_mac_t));
    l2station.vlan = l2addr->vid;
    l2station.vlan_mask = 0xfff;

    found = bcmint_l2_station_db_get(unit, &l2station, &tnl);
    if (found && !tnl) {
        /* exit, does not need to insert. */
        SHR_EXIT();
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    lt_underlay_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_UNDERLAY_MY_STATION_ID);
    if (lt_underlay_info == NULL) {
        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_MY_STATION_ID);
        SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);
    }

    /* L2_MY_STATION does not care port field */
    if (lt_underlay_info != NULL) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate_by_id(dunit, lt_underlay_info->sdklt_tid,
                                        lt_underlay_info->fld_cnt, &eh));
        SHR_IF_ERR_EXIT
            (l2_station_from_l2_addr_populate(unit, eh, lt_underlay_info, l2addr, 0));
    } else {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                        lt_info->fld_cnt, &eh));
        SHR_IF_ERR_EXIT
            (l2_station_from_l2_addr_populate(unit, eh, lt_info, l2addr, 0));
    }
    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_INSERT, BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_EXISTS) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(eh, BCMLT_OPCODE_UPDATE, BCMLT_PRIORITY_NORMAL));
        rv = SHR_E_NONE;
    } else if (rv == SHR_E_FULL && lt_underlay_info != NULL) {
        bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;

        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_MY_STATION_ID);
        SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                        lt_info->fld_cnt, &eh));
        SHR_IF_ERR_EXIT
            (l2_station_from_l2_addr_populate(unit, eh, lt_info, l2addr, 0));

        rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_INSERT, BCMLT_PRIORITY_NORMAL);
        if (rv == SHR_E_EXISTS) {
            SHR_IF_ERR_EXIT
                (bcmlt_entry_commit(eh, BCMLT_OPCODE_UPDATE, BCMLT_PRIORITY_NORMAL));
            rv = SHR_E_NONE;
        }
    }
    SHR_IF_ERR_EXIT(rv);

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete L2 station entry according to MAC and VID.
 *
 * \param [in] unit Unit number
 * \param [in] mac MAC.
 * \param [in] vid Vlan ID.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_station_delete(int unit, bcm_mac_t mac, bcm_vlan_t vid)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit, rv;
    bcm_l2_addr_t l2addr;
    bcm_l2_station_t l2station;
    bool tnl = 0, found = 0;
    const bcmint_l2_map_info_t *lt_info, *lt_underlay_info;

    SHR_FUNC_ENTER(unit);

    sal_memset(&l2station, 0, sizeof(bcm_l2_station_t));
    sal_memcpy(l2station.dst_mac, mac, sizeof(bcm_mac_t));
    sal_memset(l2station.dst_mac_mask, 0xff, sizeof(bcm_mac_t));
    l2station.vlan = vid;
    l2station.vlan_mask = 0xfff;

    found = bcmint_l2_station_db_get(unit, &l2station, &tnl);
    if (found && !tnl) {
        /* exit, can't delete */
        SHR_EXIT();
    }
    dunit = bcmi_ltsw_dev_dunit(unit);

    lt_underlay_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_UNDERLAY_MY_STATION_ID);
    if (lt_underlay_info == NULL) {
        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_MY_STATION_ID);
        SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);
    }
    sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
    sal_memcpy(l2addr.mac, mac, sizeof(bcm_mac_t));
    l2addr.vid = vid;
    /* L2_MY_STATION does not care port field */
    if (lt_underlay_info != NULL) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate_by_id(dunit, lt_underlay_info->sdklt_tid,
                                        lt_underlay_info->fld_cnt, &eh));
        SHR_IF_ERR_EXIT
            (l2_station_from_l2_addr_populate(unit, eh, lt_underlay_info, &l2addr, 1));
    } else {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                        lt_info->fld_cnt, &eh));
        SHR_IF_ERR_EXIT
            (l2_station_from_l2_addr_populate(unit, eh, lt_info, &l2addr, 1));
    }
    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NOT_FOUND && lt_underlay_info != NULL) {
        bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;

        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_MY_STATION_ID);
        SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                        lt_info->fld_cnt, &eh));

        SHR_IF_ERR_EXIT
            (l2_station_from_l2_addr_populate(unit, eh, lt_info, &l2addr, 1));

        rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL);
        if (rv == SHR_E_NOT_FOUND) {
            rv = SHR_E_NONE;
        }
        SHR_IF_ERR_EXIT(rv);
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Look up L2 station entry according to MAC and VID.
 *
 * \param [in] unit Unit number
 * \param [in] mac MAC.
 * \param [in] vid Vlan ID.
 * \param [out] l2addr Lookup data.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_station_lookup(int unit, bcm_mac_t mac, bcm_vlan_t vid, bcm_l2_addr_t *l2addr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit, rv;
    bcm_l2_addr_t l2addr_key;
    const bcmint_l2_map_info_t *lt_info = NULL, *lt_underlay_info = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    lt_underlay_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_UNDERLAY_MY_STATION_ID);
    if (lt_underlay_info == NULL) {
        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_MY_STATION_ID);
        SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);
    }
    sal_memset(&l2addr_key, 0, sizeof(bcm_l2_addr_t));
    sal_memcpy(l2addr_key.mac, mac, sizeof(bcm_mac_t));
    l2addr_key.vid = vid;
    /* L2_MY_STATION does not care port field */
    if (lt_underlay_info != NULL) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate_by_id(dunit, lt_underlay_info->sdklt_tid,
                                        lt_underlay_info->fld_cnt, &eh));
        SHR_IF_ERR_EXIT
            (l2_station_from_l2_addr_populate(unit, eh, lt_underlay_info, &l2addr_key, 1));
    } else {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                        lt_info->fld_cnt, &eh));
        SHR_IF_ERR_EXIT
            (l2_station_from_l2_addr_populate(unit, eh, lt_info, &l2addr_key, 1));
    }

    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NONE) {
        if (lt_underlay_info != NULL) {
            SHR_IF_ERR_EXIT
                (l2_station_to_l2_addr_parse(unit, eh, lt_underlay_info, l2addr));
        } else if (lt_info != NULL) {
            SHR_IF_ERR_EXIT
                (l2_station_to_l2_addr_parse(unit, eh, lt_info, l2addr));
        }
    } else if (rv == SHR_E_NOT_FOUND && lt_underlay_info != NULL) {
        bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;

        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_MY_STATION_ID);
        SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                        lt_info->fld_cnt, &eh));
        SHR_IF_ERR_EXIT
            (l2_station_from_l2_addr_populate(unit, eh, lt_info, &l2addr_key, 1));

        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(eh, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_EXIT
            (l2_station_to_l2_addr_parse(unit, eh, lt_info, l2addr));
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Populate L2 station entry according to API data structure.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] station L2 station structure.
 * \param [in] flags Internal L2 station flags.
 * \param [bool] key_only Only populate key.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_station_entry_populate(int unit, bcmlt_entry_handle_t eh,
                          const bcmint_l2_map_info_t *lt_info,
                          bcm_l2_station_t *station,
                          int flags, uint32_t select_flags)
{
    SHR_FUNC_ENTER(unit);

    if (flags & BCMINT_L2_STATION_TUNNEL) {
        station->flags |= BCM_L2_STATION_MPLS;
    }
    SHR_IF_ERR_EXIT
        (xgs_ltsw_l2_struct_populate(unit, eh, lt_info, select_flags,
                                     (void *)station, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Parse LT entry and fill API data structure.
 *
 * \param [in] unit Unit number
 * \param [in] eh LT entry handle.
 * \param [in] station L2 station structure.
 * \param [bool] no_key Do not parse key.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_station_entry_parse(int unit, bcmlt_entry_handle_t eh,
                       const bcmint_l2_map_info_t *lt_info,
                       bcm_l2_station_t *station,
                       uint32_t select_flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (xgs_ltsw_l2_struct_parse(unit, eh, lt_info, select_flags,
                                  (void *)station, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief During replace operation, some L2 fields need to be updated.
 *
 * \param [in] unit Unit number
 * \param [in] eh_update LT entry handle.
 * \param [in] lt_info L2 map information.
 * \param [in] l2addr l2addr data.
 * \param [in] rep_st l2 replace data.
 * \param [out] notify 1: need to notify user.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_replace_fld_update(int unit, bcmlt_entry_handle_t eh_update,
                      const bcmint_l2_map_info_t *lt_info,
                      bcm_l2_addr_t *l2addr, bcm_l2_addr_t *l2addr_add,
                      bcmint_l2_replace_t *rep_st, bool *notify)
{

    bcm_l2_addr_t l2addr_rep;
    uint32_t select_flag = 0;

    SHR_FUNC_ENTER(unit);

    sal_memset(&l2addr_rep, 0, sizeof(bcm_l2_addr_t));
    sal_memcpy(l2addr_add, l2addr, sizeof(bcm_l2_addr_t));

    *notify = 0;

    if (l2addr->flags & BCM_L2_DES_HIT) {
        l2addr_rep.flags |= BCM_L2_DES_HIT;
    }
    if (l2addr->flags & BCM_L2_SRC_HIT) {
        l2addr_rep.flags |= BCM_L2_SRC_HIT;
    }
    if ((rep_st->int_flags & BCMINT_L2_REPLACE_CLEAR_HIT_ONLY) == 0) {
        if (BCM_MAC_IS_MCAST(l2addr->mac)) {
            /* Do nothing */
        }  else if (rep_st->new_dest.trunk != -1) {
            l2addr_rep.flags |= BCM_L2_TRUNK_MEMBER;
            l2addr_rep.tgid = rep_st->new_dest.trunk;
            l2addr_add->tgid = l2addr_rep.tgid;
            l2addr_add->flags |= BCM_L2_TRUNK_MEMBER;
            select_flag |= SELECT_FLAG_L2_HOST_TAB_REPL_MODPORT;
            *notify = 1;
        } else if (rep_st->new_dest.port != -1) {
            l2addr_rep.port = rep_st->new_dest.port;
            l2addr_add->port = l2addr_rep.port;
            select_flag |= SELECT_FLAG_L2_HOST_TAB_REPL_MODPORT;
            *notify = 1;
        }
    } else {
        if ((l2addr->flags & BCM_L2_DES_HIT) &&
            (rep_st->flags & BCM_L2_REPLACE_DES_HIT_CLEAR)) {
            l2addr_rep.flags &= ~BCM_L2_DES_HIT;
            l2addr_add->flags &= ~BCM_L2_DES_HIT;
            *notify = 1;
        }
        if ((l2addr->flags & BCM_L2_SRC_HIT) &&
            (rep_st->flags & BCM_L2_REPLACE_SRC_HIT_CLEAR)) {
            l2addr_rep.flags &= ~BCM_L2_SRC_HIT;
            l2addr_add->flags &= ~BCM_L2_SRC_HIT;
            *notify = 1;
        }
    }
    select_flag |= SELECT_FLAG_L2_HOST_TAB_REPL_HIT;

    SHR_IF_ERR_EXIT
        (xgs_ltsw_l2_struct_populate(unit, eh_update, lt_info, select_flag,
                                     (void *)&l2addr_rep, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief l2addr->group is used as profile ID when l2addr->block_bitmap is non-zero.
 * otherwise, l2addr->group is used as class ID.
 *
 * Set profile ID to l2addr->group.
 *
 * \param [in] l2addr L2 address data structure.
 * \param [in] l2_dst_prof_id L2 dst block profile ID.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_dst_block_profile_id_set(int unit, bcm_l2_addr_t *l2addr,
                            int l2_dst_prof_id)
{
    int count;

    SHR_FUNC_ENTER(unit);

    BCM_PBMP_COUNT(l2addr->block_bitmap, count);
    if (count) {
        if (l2_dst_prof_id < 0) {
            SHR_IF_ERR_EXIT(SHR_E_INTERNAL);
        }
        l2addr->group = l2_dst_prof_id;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief l2addr->group is used as profile ID when l2addr->block_bitmap is non-zero.
 * otherwise, l2addr->group is used as class ID.
 *
 * Get profile ID from l2addr->group.
 *
 * \param [in] l2addr L2 address data structure.
 * \param [out] l2_dst_prof_id L2 dst block profile ID.
 *
 * \return NONE.
 */
static void
l2_dst_block_profile_id_get(bcm_l2_addr_t *l2addr,
                            int *l2_dst_prof_id)
{
    int count;

    BCM_PBMP_COUNT(l2addr->block_bitmap, count);
    if (count) {
        *l2_dst_prof_id = l2addr->group;
        l2addr->group = 0;
    } else {
        /* Invalid */
        *l2_dst_prof_id = -1;
    }
}

/*!
 * \brief Internal callback function for l2 replace op.
 *
 * \param [in] unit Unit number.
 * \param [in] trav_st Traverse structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_replace_int_cb(int unit, void *trav_st)
{
    bcmint_l2_replace_t      *rep_st = NULL;
    bcmint_l2_traverse_t     *trv = NULL;
    bcm_l2_addr_t          l2addr, l2addr_add;
    bool notify = NOTIFY_L2_EVENT(unit);
    bcmlt_entry_handle_t   eh_update = BCMLT_INVALID_HDL;
    int dunit, l2_dst_prof_id;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL || trv->internal_data == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    rep_st = trv->user_data;
    if (rep_st == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    sal_memcpy(&l2addr, trv->internal_data, sizeof(bcm_l2_addr_t));

    if (rep_st->flags & BCM_L2_REPLACE_MATCH_VLAN) {
        if (rep_st->key_vlan != l2addr.vid) {
            SHR_EXIT();
        }
    }

    if (rep_st->flags & BCM_L2_REPLACE_MATCH_MAC) {
        if (sal_memcmp(rep_st->key_mac, l2addr.mac, sizeof(bcm_mac_t))) {
            SHR_EXIT();
        }
    }

    if (rep_st->flags & BCM_L2_REPLACE_MATCH_DEST) {
        if (rep_st->match_dest.trunk != -1) {
            if (rep_st->match_dest.trunk != l2addr.tgid) {
                SHR_EXIT();
            }
        } else {
            if (rep_st->int_flags & BCMINT_L2_REPLACE_IGNORE_PORTID) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcm_ltsw_stk_modid_get(unit, &(l2addr.modid)));
                if (rep_st->match_dest.module != l2addr.modid) {
                    SHR_EXIT();
                }
            } else {
                if (rep_st->match_dest.port != l2addr.port) {
                    SHR_EXIT();
                }
            }
        }
    }
    /* Check if user wants static field matched with the entry's static bit */
    if (!(rep_st->flags & BCM_L2_REPLACE_MATCH_STATIC)) {
        /* BCM_L2_REPLACE_MATCH_STATIC means to replace static as well as
         * non-static entries */
        if (l2addr.flags & BCM_L2_STATIC) {
            SHR_EXIT();
        }
    }
    if ((rep_st->flags & BCM_L2_REPLACE_MATCH_UC &&
         !(rep_st->flags & BCM_L2_REPLACE_MATCH_MC) &&
         BCM_MAC_IS_MCAST(l2addr.mac)) ||
        (rep_st->flags & BCM_L2_REPLACE_MATCH_MC &&
         !(rep_st->flags & BCM_L2_REPLACE_MATCH_UC) &&
         !BCM_MAC_IS_MCAST(l2addr.mac))) {
        SHR_EXIT();
    }
    if (rep_st->flags & BCM_L2_REPLACE_NO_CALLBACKS) {
        notify = false;
    }
    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, trv->tid, trv->fld_cnt, &eh_update));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_populate(unit, eh_update, lt_info, &l2addr, 1));

    l2_dst_block_profile_id_get(&l2addr, &l2_dst_prof_id);

    if (rep_st->flags & BCM_L2_REPLACE_DELETE) {
        if (l2_dst_prof_id >= 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (l2_dst_block_profile_delete(unit, l2_dst_prof_id));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh_update, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL));
        if (notify) {
            bcmint_l2_event_notify(unit, NULL, &l2addr, L2_EVENT_DELETE);
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_replace_fld_update(unit, eh_update, lt_info, &l2addr,
                                   &l2addr_add, rep_st, &notify));
        /* Perform replace action on matching entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh_update, BCMLT_OPCODE_UPDATE, BCMLT_PRIORITY_NORMAL));

        if (notify) {
            bcmint_l2_event_notify(unit, &l2addr_add, &l2addr, L2_EVENT_UPDATE);
        }
    }

exit:
    if (eh_update != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh_update);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief L2 module traverse function.
 *
 * \param [in] unit Unit number.
 * \param [in] trav_st Traverse structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_traverse(int unit, bcmint_l2_traverse_t *trav_st, int age)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    int rv = SHR_E_NONE, rv_cb;
    int with_lock = trav_st->flags & BCMINT_L2_TRAVERSE_WITH_LOCK;
    bcm_l2_addr_t          l2addr;
    int l2_dst_prof_id = 0;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    if (trav_st == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, trav_st->tid,
                                    trav_st->fld_cnt, &eh));
    if (trav_st->flags & BCMINT_L2_TRAVERSE_HW) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_attrib_set(eh, BCMLT_ENT_ATTR_GET_FROM_HW));
    }
    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);

    if (with_lock) {
        L2T_LOCK(unit);
    }
    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_TRAVERSE,
                            BCMLT_PRIORITY_NORMAL);

    while (rv == SHR_E_NONE) {
        /* Get and save data of the current entry */
        if (trav_st->int_cb) {
            sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
            SHR_IF_ERR_VERBOSE_EXIT
                (l2_entry_parse(unit, eh, age, lt_info,
                                &l2addr, &l2_dst_prof_id));
            SHR_IF_ERR_VERBOSE_EXIT
                (l2_dst_block_profile_id_set(unit, &l2addr, l2_dst_prof_id));

            trav_st->internal_data = (void *)&l2addr;
        }
        /* Traverse to the next entry */
        rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_TRAVERSE,
                                BCMLT_PRIORITY_NORMAL);
        /* Delete or update data from or into the current entry */
        if (trav_st->int_cb) {
            rv_cb = trav_st->int_cb(unit, (void *)trav_st);
            if (SHR_FAILURE(rv_cb)) {
                LOG_ERROR(BSL_LOG_MODULE,
                          (BSL_META_U(unit,
                                      "int_cb return ERR[%d].\n"),
                          rv_cb));
                break;
            }
        }
        if (with_lock) {
            /* Release lock to allow other l2 operation to be done. */
            L2T_UNLOCK(unit);
            /* Re-lock. */
            L2T_LOCK(unit);
        }
    }
    if (with_lock) {
        L2T_UNLOCK(unit);
    }
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_EXIT(rv);

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Internal callback function for l2 traverse op.
 *
 * \param [in] unit Unit number.
 * \param [in] trav_st Traverse structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_traverse_int_cb(int unit, void *trav_st)
{
    bcmint_l2_traverse_t *trv = NULL;
    bcm_l2_addr_t l2addr;
    int count = 0;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL || trv->internal_data == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (trv->user_cb) {
        sal_memcpy(&l2addr, trv->internal_data, sizeof(l2addr));

        BCM_PBMP_COUNT(l2addr.block_bitmap, count);
        if (count) {
            l2addr.group = 0;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (trv->user_cb(unit, &l2addr, trv->user_data));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief During age operation, some L2 fields need to be updated.
 *
 * \param [in] unit Unit number
 * \param [in] eh_update LT entry handle.
 * \param [in] lt_info L2 map information.
 * \param [in] l2addr l2addr data.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_age_fld_update(int unit, bcmlt_entry_handle_t eh,
                      const bcmint_l2_map_info_t *lt_info,
                      bcm_l2_addr_t *l2addr)
{

    bcm_l2_addr_t l2addr_rep;
    uint32_t select_flag = 0;

    SHR_FUNC_ENTER(unit);

    sal_memset(&l2addr_rep, 0, sizeof(bcm_l2_addr_t));

    if (l2addr->flags & BCM_L2_DES_HIT) {
        l2addr_rep.flags &= ~BCM_L2_DES_HIT;
        select_flag |= SELECT_FLAG_L2_HOST_TAB_REPL_HIT;
    }
    if (l2addr->flags & BCM_L2_SRC_HIT) {
        l2addr_rep.flags &= ~BCM_L2_SRC_HIT;
        select_flag |= SELECT_FLAG_L2_HOST_TAB_REPL_HIT;
    }

    SHR_IF_ERR_EXIT
        (xgs_ltsw_l2_struct_populate(unit, eh, lt_info, select_flag,
                                     (void *)&l2addr_rep, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Internal callback function for l2 age op.
 *
 * \param [in] unit Unit number.
 * \param [in] trav_st Traverse structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_age_int_cb(int unit, void *trav_st)
{
    bcmint_l2_traverse_t     *trv = NULL;
    bcmlt_entry_handle_t   eh_update = BCMLT_INVALID_HDL;
    bcm_l2_addr_t          l2addr;
    bool notify = NOTIFY_L2_EVENT(unit);
    int dunit, l2_dst_prof_id;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL || trv->internal_data == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    sal_memcpy(&l2addr, trv->internal_data, sizeof(l2addr));
    /* Skip static entries */
    if (l2addr.flags & BCM_L2_STATIC) {
        SHR_EXIT();
    }
    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, trv->tid, trv->fld_cnt, &eh_update));

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_populate(unit, eh_update, lt_info, &l2addr, 1));

    l2_dst_block_profile_id_get(&l2addr, &l2_dst_prof_id);

    if (!(l2addr.flags & BCM_L2_HIT)) {
        if (l2_dst_prof_id >= 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (l2_dst_block_profile_delete(unit, l2_dst_prof_id));
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh_update,
                                BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_age_fld_update(unit, eh_update, lt_info, &l2addr));
        /* Perform replace action on matching entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh_update,
                                BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    }
    if (notify && !(l2addr.flags & BCM_L2_HIT)) {
        bcmint_l2_event_notify(unit, NULL, &l2addr, L2_EVENT_AGE);
    }

exit:
    if (eh_update != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh_update);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Internal callback function for l2 delete by (vlan, gport) tuple.
 *
 * \param [in] unit Unit number.
 * \param [in] trav_st Traverse structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
tuple_match_delete_int_cb(int unit, void *trav_st)
{
    bcmint_l2_tuple_ctrl_t *tuple_ctrl = NULL;
    bcmint_l2_vlan_gport_tuple_t tuple;
    bcmint_l2_traverse_t *trv = NULL;
    bcmlt_entry_handle_t eh_update = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2addr;
    int vlan, port, retry = 0, mymodid = 0;
    int dunit, l2_dst_prof_id;
    bool found = false;
    bool notify = NOTIFY_L2_EVENT(unit);
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL || trv->internal_data == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    tuple_ctrl = (bcmint_l2_tuple_ctrl_t *)trv->user_data;
    if (tuple_ctrl == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    sal_memcpy(&l2addr, trv->internal_data, sizeof(l2addr));

    if ((l2addr.flags & BCM_L2_STATIC) &&
        !(tuple_ctrl->flags & BCM_L2_REPLACE_MATCH_STATIC)) {
        SHR_EXIT();
    }

    vlan = l2addr.vid;
    if (l2addr.flags & BCM_L2_TRUNK_MEMBER) {
        port = l2addr.tgid;
        BCM_GPORT_TRUNK_SET(tuple.gport, port);
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_stk_my_modid_get(unit, &mymodid));
        port = l2addr.port;
        BCM_GPORT_MODPORT_SET(tuple.gport, mymodid, port);
    }
    tuple.vlan = vlan;
    for (retry = 0; retry < 2; retry++) {
        found = bcmint_l2_tuple_find(unit, tuple_ctrl, tuple);
        if (found == false &&
            (tuple_ctrl->int_flags & BCMINT_L2_DONT_CARE_VLAN)) {
            tuple.vlan = BCM_VLAN_INVALID;
            found = bcmint_l2_tuple_find(unit, tuple_ctrl, tuple);
        }
        if (found == false &&
            (tuple_ctrl->int_flags & BCMINT_L2_DONT_CARE_GPORT)) {
            tuple.vlan = vlan;
            tuple.gport = BCM_GPORT_INVALID;
            found = bcmint_l2_tuple_find(unit, tuple_ctrl, tuple);
        }
        if (found == true || l2addr.flags & BCM_L2_TRUNK_MEMBER) {
            break;
        }
        tuple.vlan = vlan;
        if (retry == 0) {
            BCM_GPORT_LOCAL_SET(tuple.gport, port);
        }
    }
    if (found == true) {
        if (tuple_ctrl->flags & BCM_L2_REPLACE_NO_CALLBACKS) {
            notify = false;
        }
        l2_dst_block_profile_id_get(&l2addr, &l2_dst_prof_id);

        if (l2_dst_prof_id >= 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (l2_dst_block_profile_delete(unit, l2_dst_prof_id));
        }
        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
        SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

        dunit = bcmi_ltsw_dev_dunit(unit);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate_by_id(dunit, trv->tid, trv->fld_cnt, &eh_update));

        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_populate(unit, eh_update, lt_info, &l2addr, 1));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh_update,
                                BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL));
        if (notify) {
            bcmint_l2_event_notify(unit, NULL, &l2addr, L2_EVENT_DELETE);
        }
    }

exit:
    if (eh_update != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh_update);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Transform data from L2 learn cache to L2 address structure.
 *
 * \param [in] unit Unit number.
 * \param [in] eh Handler of L2 learn cache LT.
 * \param [in] eh_back Backup handler of L2 learn cache LT.
 * \param [out] l2addr L2 address structure.
 *
 * \retval NONE.
 */
static void
l2_learn_cache_to_l2addr_parse(int unit, bcmlt_entry_handle_t eh,
                               bcmlt_entry_handle_t eh_back,
                               bcm_l2_addr_t *l2addr)
{
    int gport, rv;
    const bcmint_l2_map_info_t *lt_info = NULL;
    xgs_l2_learn_notify_t learn_notify;

    if (l2addr == NULL) {
        LOG_WARN(BSL_LOG_MODULE,
                 (BSL_META_U(unit, "Invalid Parameter!\n")));
        return;
    }
    sal_memset(l2addr, 0, sizeof(bcm_l2_addr_t));
    sal_memset(&learn_notify, 0, sizeof(xgs_l2_learn_notify_t));

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_LEARN_DATA_ID);
    if (lt_info == NULL) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Fail to get info of LT l2_learn_data!\n")));
        return;
    }
    rv = xgs_ltsw_l2_struct_parse(unit, eh, lt_info,
                                  SELECT_FLAG_KEY | SELECT_FLAG_DATA,
                                  (void *)&learn_notify, NULL);
    if (SHR_FAILURE(rv)) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Fail to parse L2 learning data!\n")));
        return;
    }
    rv = xgs_ltsw_l2_struct_populate(unit, eh_back, lt_info,
                                     SELECT_FLAG_KEY,
                                     (void *)&learn_notify, NULL);
    if (SHR_FAILURE(rv)) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Fail to papulate L2 learning key fields!\n")));
        return;
    }
    bcmi_ltsw_util_uint64_to_mac(l2addr->mac, &(learn_notify.mac));

    /* VFI -> VPN */
    (void)bcmi_ltsw_virtual_vpnid_get(unit, learn_notify.vid, &l2addr->vid);

    switch (learn_notify.src_type) {
        /* PORT */
        case 0:
            l2addr->port = learn_notify.modport;

            if (learn_notify.modport == 0 &&
                learn_notify.svp) {
                rv = bcmi_ltsw_virtual_vp_encode_gport(unit, learn_notify.svp, &gport);
                if (SHR_FAILURE(rv)) {
                    LOG_WARN(BSL_LOG_MODULE,
                             (BSL_META_U(unit, "VP encode failed (%d)!\n"), rv));
                    break;
                }
                l2addr->port = gport;
            }
            break;
        /* TRUNK */
        case 1:
            l2addr->flags |= BCM_L2_TRUNK_MEMBER;
            l2addr->tgid = learn_notify.tgid;
            break;
        /* L2_MC_GRP */
        case 2:
        /* L3_MC_GRP */
        case 3:
        /* NHOP */
        case 4:
        /* ECMP */
        case 5:
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit,
                                 "Should not learn src_type (%d)!\n"),
                     learn_notify.src_type));
            break;
        default:
            return;
    }
}

/*!
* \brief Get operation code for L2 Learn cache entry.
*
* \param [in] unit Unit number.
* \param [in] lt_name Table name.
* \param [in] eh LT entry handle.
* \param [out] notif_info Pointer to notification info.
* \param [out] status Parser callback returned status, NULL for not care.
*
* \return BCM_E_NONE on success, error code otherwise.
*/
static void
l2_learn_entry_op_get(int unit, const char *lt_name,
                      bcmlt_entry_handle_t eh, void *notif_info,
                      bcmi_ltsw_event_status_t *status)
{
    int rv;
    xgs_l2_learn_notify_t *learn_notify;
    bcmlt_unified_opcode_t op;

    if (notif_info == NULL) {
        LOG_WARN(BSL_LOG_MODULE,
                 (BSL_META_U(unit, "Invalid Parameter!\n")));
        return;
    }

    learn_notify = (xgs_l2_learn_notify_t *)notif_info;

    rv = bcmlt_entry_oper_get(eh, &op);
    if (SHR_FAILURE(rv)) {
        LOG_WARN(BSL_LOG_MODULE,
                 (BSL_META_U(unit,
                             "Failed to get %s opcode(%d).\n"),
                  lt_name, rv));
        return;
    }
    learn_notify->op = op.opcode.lt;
    /* Skip the delete event */
    if (learn_notify->op == BCMLT_OPCODE_DELETE) {
        if (status) {
            *status = bcmiLtswEventStatusDismissNotif;
        }
        return;
    }
    if (LOG_CHECK(BSL_LOG_MODULE | BSL_DEBUG)) {
        learn_notify->stime = sal_time_usecs();
    }
}

/*!
 * \brief Insert a L2 table entry and notify application a learn event.
 *
 * \param [in] unit Unit number.
 * \param [in] l2addr L2 address structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_learn_insert(int unit, bcm_l2_addr_t *l2addr)
{
    bcmlt_entry_handle_t eh_new = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t eh_old = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2addr_del;
    int dunit, rv, l2_dst_block_id, count;
    bool update = false, notify = NOTIFY_L2_EVENT(unit);
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    L2T_LOCK(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh_new));

    l2addr->flags |= BCM_L2_SRC_HIT;

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_entry_populate(unit, eh_new, lt_info, l2addr, false));
    rv = bcmlt_entry_commit(eh_new, BCMLT_OPCODE_INSERT, BCMLT_PRIORITY_NORMAL);

    if (rv == SHR_E_EXISTS) {
        update = true;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                        lt_info->fld_cnt, &eh_old));
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_populate(unit, eh_old, lt_info, l2addr, true));
        /* First do lookup with key to fetch whole entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh_old, BCMLT_OPCODE_LOOKUP,
                                BCMLT_PRIORITY_NORMAL));

        sal_memset(&l2addr_del, 0, sizeof(bcm_l2_addr_t));
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_entry_parse(unit, eh_old, 0, lt_info,
                            &l2addr_del, &l2_dst_block_id));
        /* Dont relearn static MAC */
        if (l2addr_del.flags & BCM_L2_STATIC) {
            SHR_EXIT();
        }
        BCM_PBMP_COUNT(l2addr_del.block_bitmap, count);
        if (count) {
            SHR_IF_ERR_VERBOSE_EXIT
                (l2_dst_block_profile_delete(unit, l2_dst_block_id));
        }
        /* Update existing entry */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(eh_new, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    if (notify) {
        if (update) {
            bcmint_l2_event_notify(unit, l2addr, &l2addr_del, L2_EVENT_MOVE);
        } else {
            bcmint_l2_event_notify(unit, l2addr, NULL, L2_EVENT_LEARN);
        }
    }

exit:
    if (eh_new != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh_new);
    }
    if (eh_old != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh_old);
    }

    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse L2 learn cache LT.
 *
 * \param [in] unit Unit number.
 * \param [in] trav_st Traverse structure.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_learn_cache_traverse(int unit, bcmint_l2_traverse_t *trav_st)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcmlt_entry_handle_t eh_backup = BCMLT_INVALID_HDL;
    int dunit;
    int rv = SHR_E_NONE, rv_cb;
    bcm_l2_addr_t l2addr;

    SHR_FUNC_ENTER(unit);

    if (trav_st == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, trav_st->tid,
                                    trav_st->fld_cnt, &eh_backup));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, trav_st->tid,
                                    trav_st->fld_cnt, &eh));
    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_TRAVERSE,
                            BCMLT_PRIORITY_NORMAL);
    while (rv == SHR_E_NONE) {
        /* Get and save data of the current entry */
        sal_memset(&l2addr, 0, sizeof(bcm_l2_addr_t));
        l2_learn_cache_to_l2addr_parse(unit, eh, eh_backup, &l2addr);

        trav_st->internal_data = (void *)&l2addr;
        trav_st->eh = eh_backup;

        /* Traverse to the next entry */
        rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_TRAVERSE,
                                BCMLT_PRIORITY_NORMAL);
        /* Delete or update data from or into the current entry */
        rv_cb = trav_st->int_cb(unit, (void *)trav_st);
        if (SHR_FAILURE(rv_cb)) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "int_cb return ERR[%d].\n"),
                      rv_cb));
            break;
        }
    }
    if (rv == SHR_E_NOT_FOUND) {
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_EXIT(rv);

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    if (eh_backup != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh_backup);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable L2 slow-poll via configuring L2 learn control LT.
 *
 * \param [in] unit    Unit number.
 * \param [in] enable  Enable slow poll.
 *
 * \retval SHE_E_NONE No errors.
 */
static int
l2_learn_cache_slow_poll_enable(int unit, bool slow_poll)
{
    const bcmint_l2_map_info_t *lt_info = NULL;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int old_poll_mode = l2_learn_control[unit].slow_poll;
    int dunit;

    SHR_FUNC_ENTER(unit);

    if (l2_learn_control[unit].slow_poll == slow_poll) {
        SHR_EXIT();
    }
    LOG_DEBUG(BSL_LOG_MODULE,
              (BSL_META_U(unit,
                          "%s slow poll for L2 learning.\n"),
              slow_poll ? "Enable" : "Disable"));

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_LEARN_CTRL_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh));

    l2_learn_control[unit].slow_poll = slow_poll;
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_l2_struct_populate(unit, eh, lt_info,
                                     SELECT_FLAG_KEY,
                                     (void *)&l2_learn_control[unit], NULL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_UPDATE,
                              BCMLT_PRIORITY_NORMAL));

exit:
    if (SHR_FUNC_ERR()) {
        l2_learn_control[unit].slow_poll = old_poll_mode;
    }
    if (BCMLT_INVALID_HDL != eh) {
        (void) bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert data gotten from L2_LEARN_CACHE into L2 host table.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  trav_st       Traverse structure.
 *
 * \retval SHR_E_NONE         No errors.
 * \retval SHR_E_PARAM        Invalid parameter.
 */
static int
l2_learn_cache_data_process(int unit, void *trav_st)
{
    bcmint_l2_traverse_t *trv = NULL;
    bcmlt_entry_handle_t eh_backup = BCMLT_INVALID_HDL;
    bcm_l2_addr_t *l2addr;
    uint32_t *count = NULL;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    trv = (bcmint_l2_traverse_t *)trav_st;
    if (trv == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    count = (uint32_t *)trv->user_data;
    if (count == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    eh_backup = trv->eh;
    if (eh_backup == BCMLT_INVALID_HDL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    l2addr = (bcm_l2_addr_t *)trv->internal_data;
    rv = l2_learn_insert(unit, l2addr);
    if (SHR_FAILURE(rv)) {
        LOG_DEBUG(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Failed to insert L2 host table (%d).\n"), rv));
        if (rv == SHR_E_RESOURCE) {
            rv = l2_learn_cache_slow_poll_enable(unit, 1);
            if (SHR_FAILURE(rv)) {
                LOG_ERROR(BSL_LOG_MODULE,
                          (BSL_META_U(unit,
                                      "Failed to enable L2 learn "
                                      "slow poll mode (%d).\n"), rv));
            }
        }
    } else {
        rv = l2_learn_cache_slow_poll_enable(unit, 0);
        if (SHR_FAILURE(rv)) {
            LOG_ERROR(BSL_LOG_MODULE,
                      (BSL_META_U(unit,
                                  "Failed to disable L2 learn "
                                  "slow poll mode (%d).\n"), rv));
        }
    }
    /*
     * No matter L2 host table insertion succeeds or not, always delete
     * learn cache entry.
     */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(eh_backup,
                            BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL));
    *count += 1;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief The callback function to handle L2 learn notification.
 *
 * This function is responsible for L2 learning, it will judge new learn or
 * station move event based on notified event of L2 learn table, insert or
 * update L2 host table entry and delete L2 learn table entry, etc
 *
 * \param [in] unit Unit number.
 * \param [in] event Event string.
 * \param [in] notif_info L2 event info.
 * \param [in] user_data User data.
 *
 * \retval NONE.
 */
static void
l2_learn_cache_traverse_cb(int unit, const char *event,
                        void *notif_info, void *user_data)
{
    xgs_l2_learn_notify_t *learn_notify;
    const bcmint_l2_map_info_t *lt_info;
    bcmint_l2_traverse_t  trav_st;
    uint32_t count = 0;
    sal_usecs_t time, schedule_time = 0;

    if (notif_info == NULL) {
        return;
    }
    learn_notify = (xgs_l2_learn_notify_t *)notif_info;

    /* Skip the delete event */
    if (learn_notify->op == BCMLT_OPCODE_DELETE) {
        return;
    }

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_LEARN_DATA_ID);
    if (lt_info == NULL) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit, "Fail to get info of LT l2_learn_data!\n")));
        return;
    }
    if (LOG_CHECK(BSL_LOG_MODULE | BSL_DEBUG)) {
        schedule_time = sal_time_usecs();
    }
    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.user_data = (void *)&count;
    trav_st.tid = lt_info->sdklt_tid;
    trav_st.fld_cnt = lt_info->fld_cnt;
    trav_st.int_cb = l2_learn_cache_data_process;
    (void)l2_learn_cache_traverse(unit, &trav_st);

    if (LOG_CHECK(BSL_LOG_MODULE | BSL_DEBUG)) {
        time = sal_time_usecs();
        LOG_CLI((BSL_META("LEARN_TIME(ts:0x%x): total(%d us) schedule(%d us)" \
                          "process(%d us) count(%d)\n"),
                 learn_notify->stime, time - learn_notify->stime,
                 schedule_time - learn_notify->stime,
                 time - schedule_time, count));
        LOG_CLI((BSL_META("--------LEARN_END--------\n")));
    }

}

/*!
 * \brief Enable or disable L2 entry reporting.
 *
 * \param [in] unit Unit number
 * \param [in] del 1: disable L2 reporting.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_learn_ctrl_entry_update(int unit, int del, int warm)
{
    const bcmint_l2_map_info_t *lt_info;
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_LEARN_CTRL_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    if (warm) {
        if (del == 0){
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                            lt_info->fld_cnt, &eh));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_LOOKUP,
                                      BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_ltsw_l2_struct_parse(unit, eh, lt_info,
                                          SELECT_FLAG_KEY,
                                          (void *)&l2_learn_control[unit], NULL));
        }
        /* Exit */
        SHR_EXIT();
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                        lt_info->fld_cnt, &eh));
        if (del == 0) {
            l2_learn_control[unit].report = 1;
        } else {
            l2_learn_control[unit].report = 0;
        }
        l2_learn_control[unit].slow_poll = 0;

        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_ltsw_l2_struct_populate(unit, eh, lt_info, SELECT_FLAG_KEY,
                                         (void *)&l2_learn_control[unit], NULL));
        if (del == 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_INSERT,
                                      BCMLT_PRIORITY_NORMAL));
        } else {
            SHR_IF_ERR_EXIT_EXCEPT_IF
                (bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_DELETE,
                                      BCMLT_PRIORITY_NORMAL),
                 SHR_E_NOT_FOUND);
        }
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void) bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable L2 learning via configuring L2 learn control LT.
 *
 * \param [in] unit Unit number.
 * \param [in] enable Enable.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_learn_enable(int unit, bool enable)
{
    int warm = bcmi_warmboot_get(unit);
    const bcmint_l2_map_info_t *lt_info;

    SHR_FUNC_ENTER(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_LEARN_DATA_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    if (enable) {
        /* Set parser function for learn cache. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_table_parser_set(unit, lt_info->lt_name,
                                      l2_learn_entry_op_get,
                                      sizeof(xgs_l2_learn_notify_t)));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_table_attrib_set(unit, lt_info->lt_name,
                                      BCMI_LTSW_EVENT_HIGH_PRIORITY));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_event_msg_threshold_set(unit, lt_info->lt_name, 2));
        /* Subscribe learn cache LT. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_table_subscribe(unit, lt_info->lt_name,
                                     l2_learn_cache_traverse_cb, NULL));

        /* Enable reporting entry into learn cache. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_learn_ctrl_entry_update(unit, 0, warm));

    } else {
        /* Disable reporting entry into learn cache. */
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_learn_ctrl_entry_update(unit, 1, warm));

        /* Unsubscribe learn cache. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_table_unsubscribe(unit, lt_info->lt_name,
                                       l2_learn_cache_traverse_cb));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief hdl_cb in bcmi_lt_entry_set or bcmi_lt_entry_delete.
 * hdl_cb is used to set data to LT fields.
 *
 * \param [in] unit Unit number
 * \param [in] lt_name LT name.
 * \param [in] eh LT entry handle.
 * \param [in] cookie User data.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_lt_entry_set_cb(int unit, const char *lt_name,
                   bcmlt_entry_handle_t eh,
                   void *cookie)
{
    ltsw_l2_lt_head_info_t *lt_head_info;
    ltsw_l2_lt_head_info_encap_t *lt_head_info_encap = NULL;

    SHR_FUNC_ENTER(unit);

    lt_head_info_encap = (ltsw_l2_lt_head_info_encap_t *)cookie;
    lt_head_info = lt_head_info_encap->lt_head_info;

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_l2_struct_populate(unit, eh, lt_head_info->lt_info,
                                     lt_head_info->filter_set,
                                     cookie, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief hdl_cb in bcmi_lt_entry_get.
 * hdl_cb is used to get data from LT fields.
 *
 * \param [in] unit Unit number
 * \param [in] lt_name LT name.
 * \param [in] eh LT entry handle.
 * \param [in] cookie User data.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_lt_entry_get_cb(int unit, const char *lt_name,
                   bcmlt_entry_handle_t eh,
                   void *cookie)
{
    ltsw_l2_lt_head_info_t *lt_head_info;
    ltsw_l2_lt_head_info_encap_t *lt_head_info_encap = NULL;

    SHR_FUNC_ENTER(unit);

    lt_head_info_encap = (ltsw_l2_lt_head_info_encap_t *)cookie;
    lt_head_info = lt_head_info_encap->lt_head_info;

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_l2_struct_parse(unit, eh, lt_head_info->lt_info,
                                  lt_head_info->filter_get,
                                  cookie, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Resolve destination type according to user data.
 *
 * \param [in] unit Unit number
 * \param [in] mac MAC address.
 * \param [in/out] l2mc_group L2 or L3 multicast group ID.
 * \param [in] port Gport.
 * \param [in/out] tgid Trunk ID.
 * \param [in] is_trunk_flag BCM_L2_TRUNK_MEMBER is used.
 * \param [out] dest_type destination type.
 *
 * \return BCM_E_NONE on success, error code otherwise.
 */
static int
l2_dest_type_resolve(int unit, bcm_mac_t mac, bcm_multicast_t *l2mc_group,
                     int port, bcm_trunk_t *tgid,
                     bool is_trunk_flag, const char **dest_type)
{
    bcm_port_t port_out = 0;
    bcm_if_t egress_if;
    bcmi_ltsw_l3_egr_obj_type_t type;
    int nexthop = 0;
    bcm_trunk_t tgid_temp = BCM_TRUNK_INVALID;

    SHR_FUNC_ENTER(unit);

    if (is_trunk_flag) {
        tgid_temp = *tgid;
        if (tgid_temp == BCM_TRUNK_INVALID) {
            SHR_IF_ERR_EXIT(SHR_E_PARAM);
        }
    } else if (BCM_GPORT_IS_TRUNK(port)) {
        tgid_temp = BCM_GPORT_TRUNK_GET(port);
    }
    if (tgid_temp != BCM_TRUNK_INVALID) {
        *dest_type = "TRUNK";
        *tgid = tgid_temp;
    } else if (BCM_MAC_IS_MCAST(mac)) {
        *dest_type = "L2_MC_GRP";
        if (_BCM_MULTICAST_IS_SET(*l2mc_group)) {
            if (_BCM_MULTICAST_IS_L2(*l2mc_group) == 0) {
                *dest_type = "L3_MC_GRP";
            }
            *l2mc_group = _BCM_MULTICAST_ID_GET(*l2mc_group);
        }
    } else if (BCM_GPORT_IS_MPLS_PORT(port) ||
               BCM_GPORT_IS_FLOW_PORT(port)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_validate(unit, port, &port_out));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_port_egress_obj_get(unit, port, &egress_if));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_resolve(unit, egress_if,
                                                &nexthop, &type));
        /* egress_if is only for L2 tunnel use currently */
        if ((type != BCMI_LTSW_L3_EGR_OBJ_T_UL) &&
            (type != BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL)) {
            SHR_IF_ERR_EXIT(SHR_E_PARAM);
        }
        if (type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
            *dest_type = "NHOP";
        } else {
            *dest_type = "ECMP_GRP";
        }
    } else {
        *dest_type = "PORT";
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Confirm hsdk_tid according information in bcm_l2_station_t.
 *
 * \param [in] unit Unit number
 * \param [in] station Information for L2 my station table.
 * \param [out] lt_info_p L2 map information of hsdk_tid.
 * \param [in] underlay get underlay sid.
 *
 * \return NONE.
 */
static void
l2_station_lt_info_get(int unit, bcm_l2_station_t *station,
                       const bcmint_l2_map_info_t **lt_info_p,
                       bool overlay)
{
    bcmint_l2_xgs_lt_id_t hsdk_tid;
    const bcmint_l2_map_info_t *lt_info = NULL;

    if (station->src_port_mask == 0) {
        hsdk_tid = (overlay == 0) ?
            XGS_L2_UNDERLAY_MY_STATION_ID : XGS_L2_MY_STATION_ID;
    } else if (BCM_GPORT_IS_TRUNK(station->src_port)) {
        hsdk_tid = (overlay == 0) ?
            XGS_L2_UNDERLAY_MY_STATION_TRUNK_ID : XGS_L2_MY_STATION_TRUNK_ID;
    } else {
        hsdk_tid = (overlay == 0) ?
            XGS_L2_UNDERLAY_MY_STATION_MODPORT_ID : XGS_L2_MY_STATION_MODPORT_ID;
    }
    lt_info = xgs_ltsw_l2_lt_info_get(unit, hsdk_tid);
    /* No overlay my station table. */
    if (overlay == 0 && lt_info == NULL) {
        if (station->src_port_mask == 0) {
            hsdk_tid = XGS_L2_MY_STATION_ID;
        } else if (BCM_GPORT_IS_TRUNK(station->src_port)) {
            hsdk_tid = XGS_L2_MY_STATION_TRUNK_ID;
        } else {
            hsdk_tid = XGS_L2_MY_STATION_MODPORT_ID;
        }
        lt_info = xgs_ltsw_l2_lt_info_get(unit, hsdk_tid);
    }
    *lt_info_p = lt_info;
}

/******************************************************************************
 * Public functions
 */
int
xgs_ltsw_l2_dst_blk_profile_trans(int unit, bcmint_l2_trans_data_t *param, int dir)
{
    ltsw_l2_dst_blk_t *l2_dst_blk = (ltsw_l2_dst_blk_t *)param->struct_data;
    int i = 0;

    if (dir == DIR_POPULATE) {
        for (i = 0; i < param->array_depth; i++) {
            if (BCM_PBMP_MEMBER(l2_dst_blk->profile, i)) {
                param->fld_val[i] = 1;
            } else {
                param->fld_val[i] = 0;
            }
        }
    } else {
        for (i = 0; i < param->array_depth; i++) {
            if (param->fld_val[i]) {
                BCM_PBMP_PORT_ADD(l2_dst_blk->profile, i);
            } else {
                BCM_PBMP_PORT_REMOVE(l2_dst_blk->profile, i);
            }
        }
    }
    return SHR_E_NONE;
}

int
xgs_ltsw_l2_dest_type_trans(int unit, bcmint_l2_trans_data_t *param, int dir)
{
    bcm_l2_addr_t *l2addr = NULL;
    bool is_trunk_flag = 0;
    bcm_l2_cache_addr_t *l2cache_addr = NULL;

    SHR_FUNC_ENTER(unit);

    if (dir == DIR_POPULATE) {
        if (param->hsdk_tid == XGS_L2_HOST_TAB_ID) {
            l2addr = (bcm_l2_addr_t *)param->struct_data;
            is_trunk_flag = (l2addr->flags & BCM_L2_TRUNK_MEMBER) ? 1 : 0;
            SHR_IF_ERR_EXIT
                (l2_dest_type_resolve(unit, l2addr->mac, &(l2addr->l2mc_group),
                                      l2addr->port, &(l2addr->tgid),
                                      is_trunk_flag, param->fld_str_val));
        } else if (param->hsdk_tid == XGS_L2_CACHE_ID) {
            l2cache_addr = (bcm_l2_cache_addr_t *)param->struct_data;
            is_trunk_flag = (l2cache_addr->flags & BCM_L2_CACHE_TRUNK) ? 1 : 0;
            SHR_IF_ERR_EXIT
                (l2_dest_type_resolve(unit, l2cache_addr->mac, &(l2cache_addr->group),
                                      l2cache_addr->dest_port, &(l2cache_addr->dest_trunk),
                                      is_trunk_flag, param->fld_str_val));
        } else {
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_tgid_trans(int unit,  bcmint_l2_trans_data_t *param, int dir)
{
    int rv, tgid = BCM_TRUNK_INVALID, use_gport, local_port, src_port;
    bcm_l2_addr_t *l2addr = NULL;
    void *addr = NULL;
    uint64_t data = 0;

    SHR_FUNC_ENTER(unit);

    if (dir == DIR_POPULATE) {
        addr = (uint8_t *)(param->struct_data) + param->offset;
        xgs_ltsw_l2_mem_val_assign(unit, &addr, param->type,
                                   '=', &data, DIR_POPULATE);
        src_port = data;

        if (BCM_GPORT_IS_TRUNK(src_port)) {
            tgid = BCM_GPORT_TRUNK_GET(src_port);
        } else {
            tgid = src_port;
        }
        if (tgid != BCM_TRUNK_INVALID) {
            rv = bcmi_ltsw_trunk_tid_to_vp_lag_vp(unit, tgid, &local_port);
            if (SHR_FAILURE(rv)) {
                param->fld_val[0] = tgid;
            } else {
                SHR_IF_ERR_EXIT(SHR_E_PORT);
            }
        } else {
            SHR_IF_ERR_EXIT(SHR_E_PARAM);
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_switch_control_get(unit, bcmSwitchUseGport, &use_gport));

        if (param->hsdk_tid == XGS_L2_HOST_TAB_ID) {
            l2addr = (bcm_l2_addr_t *)param->struct_data;

            l2addr->tgid = param->fld_val[0];
            if (use_gport) {
                BCM_GPORT_TRUNK_SET(l2addr->port, l2addr->tgid);
            }
        } else {
            tgid = param->fld_val[0];
            BCM_GPORT_TRUNK_SET(tgid, tgid);
            param->fld_val[0] = tgid;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_mc_grp_trans(int unit, bcmint_l2_trans_data_t *param, int dir)
{
    int rval;
    bcm_multicast_t l2mc_group;
    void *addr = NULL;
    uint64_t data = 0;

    SHR_FUNC_ENTER(unit);

    if (dir == DIR_POPULATE) {
        addr = (uint8_t *)(param->struct_data) + param->offset;
        xgs_ltsw_l2_mem_val_assign(unit, &addr, param->type,
                                   '=', &data, DIR_POPULATE);
        l2mc_group = data;

        if (_BCM_MULTICAST_IS_SET(l2mc_group)) {
            l2mc_group = _BCM_MULTICAST_ID_GET(l2mc_group);
        }
        param->fld_val[0] = l2mc_group;
    } else {
        l2mc_group = (bcm_multicast_t)param->fld_val[0];

        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_switch_control_get(unit, bcmSwitchL2McIdxRetType, &rval));
        if (rval) {
            _BCM_MULTICAST_GROUP_SET(l2mc_group, _BCM_MULTICAST_TYPE_L2, l2mc_group);
        }
        param->fld_val[0] = l2mc_group;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l3_mc_grp_trans(int unit, bcmint_l2_trans_data_t *param, int dir)
{
    bcm_multicast_t l2mc_group, group;
    uint32_t ipmc_id;
    void *addr = NULL;
    uint64_t data = 0;

    SHR_FUNC_ENTER(unit);

    if (dir == DIR_POPULATE) {
        addr = (uint8_t *)(param->struct_data) + param->offset;
        xgs_ltsw_l2_mem_val_assign(unit, &addr, param->type,
                                   '=', &data, DIR_POPULATE);
        l2mc_group = data;

        if (_BCM_MULTICAST_IS_SET(l2mc_group)) {
            l2mc_group = _BCM_MULTICAST_ID_GET(l2mc_group);
        }
        ipmc_id = l2mc_group;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_multicast_l3_grp_id_get(unit, ipmc_id, &group));
        param->fld_val[0] = ipmc_id;
    } else {
        ipmc_id = param->fld_val[0];

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_multicast_l3_grp_id_get(unit, ipmc_id, &l2mc_group));

        param->fld_val[0] = l2mc_group;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_dest_port_trans(int unit, bcmint_l2_trans_data_t *param, int dir)
{
    int use_gport, mymodid, port_out, port_in;
    bcm_if_t egress_if;
    bcmi_ltsw_l3_egr_obj_type_t type;
    int nexthop = 0, rv;
    void *addr = NULL;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    if (dir == DIR_POPULATE) {
        addr = (uint8_t *)(param->struct_data) + param->offset;
        xgs_ltsw_l2_mem_val_assign(unit, &addr, param->type,
                                   '=', &data, DIR_POPULATE);
        port_in = data;

        rv = bcmi_ltsw_port_gport_validate(unit, port_in, &port_out);
        if (SHR_FAILURE(rv)) {
            /* For PORTMASK */
            if (L2_STATION_MEMB(src_port_mask) == param->offset) {
                if (BCM_GPORT_IS_SET(port_in)) {
                    port_out = BCM_GPORT_LOCAL_GET(port_in);
                } else {
                    port_out = port_in;
                }
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }
        } else if (BCM_GPORT_IS_MPLS_PORT(port_in) ||
                   BCM_GPORT_IS_FLOW_PORT(port_in)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_virtual_port_egress_obj_get(unit, port_in, &egress_if));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_egress_obj_id_resolve(unit, egress_if, &nexthop, &type));
            port_out = nexthop;
        }
        param->fld_val[0] = port_out;
    } else {
        port_in = (int)param->fld_val[0];
        SHR_IF_ERR_VERBOSE_EXIT
            (bcm_ltsw_switch_control_get(unit, bcmSwitchUseGport, &use_gport));
        if (use_gport) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_stk_my_modid_get(unit, &mymodid));
            BCM_GPORT_MODPORT_SET(port_in, mymodid, port_in);
        }
        param->fld_val[0] = port_in;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_vfi_trans(int unit, bcmint_l2_trans_data_t *param, int dir)
{
    bcm_vpn_t vpn;
    uint32_t vfi = 0;
    void *addr = NULL;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    if (dir == DIR_POPULATE) {
        addr = (uint8_t *)(param->struct_data) + param->offset;
        xgs_ltsw_l2_mem_val_assign(unit, &addr, param->type,
                                   '=', &data, DIR_POPULATE);
        vpn = data;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vfi_idx_get(unit, vpn, &vfi));
        param->fld_val[0] = vfi;
    } else {
        vfi = (uint32_t)param->fld_val[0];
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vpnid_get(unit, vfi, &vpn));
        param->fld_val[0] = vpn;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_dvp_trans(int unit, bcmint_l2_trans_data_t *param, int dir)
{
    int port_out, port_in;
    bcmi_ltsw_virtual_vp_info_t vp_info;
    bcmi_ltsw_gport_info_t gport_info;
    void *addr = NULL;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    if (dir == DIR_POPULATE) {
        addr = (uint8_t *)(param->struct_data) + param->offset;
        xgs_ltsw_l2_mem_val_assign(unit, &addr, param->type,
                                   '=', &data, DIR_POPULATE);
        port_in = data;

        if (BCM_GPORT_IS_MPLS_PORT(port_in) ||
            BCM_GPORT_IS_FLOW_PORT(port_in)) {
            SHR_IF_ERR_EXIT
                (bcmi_ltsw_port_gport_validate(unit, port_in, &port_out));
            param->fld_val[0] = port_out;
        } else {
            param->fld_val[0] = 0;
        }
    } else {
        port_in = (int)param->fld_val[0];
        sal_memset(&vp_info, 0, sizeof(bcmi_ltsw_virtual_vp_info_t));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_virtual_vp_info_get(unit, port_in, &vp_info));

        if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_MPLS) {
            gport_info.gport_type = _SHR_GPORT_TYPE_MPLS_PORT;
            gport_info.mpls_id = port_in;
        } else if (vp_info.flags & BCMI_LTSW_VIRTUAL_VP_TYPE_FLOW) {
            gport_info.gport_type = _SHR_GPORT_TYPE_FLOW_PORT;
            gport_info.flow_id = port_in;
        } else {
            SHR_IF_ERR_EXIT(SHR_E_UNAVAIL);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_construct(unit, &gport_info, &port_out));

        param->fld_val[0] = port_out;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_class_id_trans(int unit, bcmint_l2_trans_data_t *param, int dir)
{
    int l2_port_blk, count, entry_index;
    bcm_l2_addr_t *l2addr = (bcm_l2_addr_t *)param->struct_data;
    int *profile_id = (int *)param->cookie;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_switch_control_get(unit, bcmSwitchL2PortBlocking,
                                     &l2_port_blk));
    if (dir == DIR_POPULATE) {
        if (l2_port_blk) {
            BCM_PBMP_COUNT(l2addr->block_bitmap, count);
            if (count) {
                SHR_IF_ERR_EXIT
                    (l2_dst_block_profile_add
                        (unit, (void *)(&l2addr->block_bitmap), 1, &entry_index));
            } else {
                entry_index = 0;
            }
            /* CLASS_IDs is overlaied with L2_DST_BLOCK_ID*/
            param->fld_val[0] = entry_index;
        } else {
            param->fld_val[0] = l2addr->group;
        }
    } else {
        if (l2_port_blk) {
            entry_index = (int)param->fld_val[0];
            SHR_IF_ERR_EXIT
                (l2_dst_block_profile_get(unit, entry_index,
                                          (void *)(&l2addr->block_bitmap)));
            *profile_id = entry_index;
            l2addr->group = 0;
        } else {
            l2addr->group = (int)param->fld_val[0];
            BCM_PBMP_CLEAR(l2addr->block_bitmap);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_lt_map_register(int unit, const bcmint_l2_map_info_t *lt_map_info)
{
    l2_lt_map_info[unit] = lt_map_info;

    return SHR_E_NONE;
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_l2_init(int unit)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];
    int warm = bcmi_warmboot_get(unit);
    bool enable;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    if (l2c->mutex == NULL) {
        l2c->mutex = sal_mutex_create("xgsL2TableLock");
        SHR_NULL_CHECK(l2c->mutex, SHR_E_MEMORY);
    }
    if (l2c->cache_mutex == NULL) {
        l2c->cache_mutex = sal_mutex_create("xgsL2CacheTableLock");
        SHR_NULL_CHECK(l2c->cache_mutex, SHR_E_MEMORY);
    }
    if (!warm) {
        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
        SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

        /* Clean up L2 table */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, lt_info->lt_name));
        /* Init L2 cache table */
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_ltsw_l2_cache_init(unit));
    } else {
        l2c->l2_cache_init = true;
    }

    enable = bcmi_ltsw_property_get(unit, BCMI_CPN_L2_LEARN_ENABLE, true);
    if (enable) {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_learn_enable(unit, enable));
        l2c->learn_enable = enable;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_dst_block_profile_init(unit));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_opaque_tag_init(unit, warm));

exit:
    if (SHR_FUNC_ERR()) {
        if (l2c->mutex) {
            sal_mutex_destroy(l2c->mutex);
            l2c->mutex = NULL;
        }
        if (l2c->cache_mutex) {
            sal_mutex_destroy(l2c->cache_mutex);
            l2c->cache_mutex = NULL;
        }
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_detach(int unit)
{
    int rv;
    l2_ctrl_t *l2c = NULL;

    SHR_FUNC_ENTER(unit);

    l2c = &l2_ctrl[unit];

    if (l2c->learn_enable) {
        rv = l2_learn_enable(unit, false);
        SHR_IF_ERR_EXIT(rv);

        l2c->learn_enable = false;
    }
    if (l2c->mutex) {
        sal_mutex_destroy(l2c->mutex);
        l2c->mutex = NULL;
    }
    if (l2c->cache_mutex) {
        sal_mutex_destroy(l2c->cache_mutex);
        l2c->cache_mutex = NULL;
    }
    l2c->l2_cache_init = false;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_addr_add(
    int unit,
    bcm_l2_addr_t *l2addr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL, eh_del = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2addr_del;
    int dunit, rv, l2_dst_block_id;
    bool update = false, notify = NOTIFY_L2_EVENT(unit);
    const bcmint_l2_map_info_t *lt_info = NULL;
    int cb_suppress = false;

    SHR_FUNC_ENTER(unit);

    if (l2addr->flags & BCM_L2_L3LOOKUP) {
        rv = l2_station_insert(unit, l2addr);
    } else {
        rv = l2_station_delete(unit, l2addr->mac, l2addr->vid);
    }
    if (SHR_FAILURE(rv)) {
        return rv;
    }
    /* Check if suppress callbacks of L2 add/delete. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_switch_control_get(unit,
                                     bcmSwitchL2ApplCallbackSuppress,
                                     &cb_suppress));
    notify = cb_suppress ? false : notify;

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    L2T_LOCK(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh));

    SHR_IF_ERR_EXIT
        (l2_entry_populate(unit, eh, lt_info, l2addr, false));

    rv = bcmlt_entry_commit(eh, BCMLT_OPCODE_INSERT, BCMLT_PRIORITY_NORMAL);

    if (rv == SHR_E_EXISTS) {
        update = true;
        if (notify) {
            SHR_IF_ERR_EXIT
                (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                            lt_info->fld_cnt, &eh_del));
            /* First do lookup with key to fetch whole entry */
            SHR_IF_ERR_EXIT
                (bcmlt_entry_commit(eh_del,
                                    BCMLT_OPCODE_LOOKUP,
                                    BCMLT_PRIORITY_NORMAL));

            sal_memset(&l2addr_del, 0, sizeof(bcm_l2_addr_t));
            SHR_IF_ERR_EXIT
                (l2_entry_parse(unit, eh_del, 0, lt_info,
                                &l2addr_del, &l2_dst_block_id));
        }
        /* Update all fields of existing entry */
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(eh, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
        rv = SHR_E_NONE;
    }
    SHR_IF_ERR_VERBOSE_EXIT(rv);

    if (notify) {
        if (update) {
            bcmint_l2_event_notify(unit, l2addr, &l2addr_del, L2_EVENT_UPDATE);
        } else {
            bcmint_l2_event_notify(unit, l2addr, NULL, L2_EVENT_ADD);
        }
    }

exit:
    L2T_UNLOCK(unit);

    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    if (eh_del != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh_del);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_addr_get(
    int unit,
    bcm_mac_t mac,
    bcm_vlan_t vid,
    bcm_l2_addr_t *l2addr)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2_addr;
    int dunit, l2_dst_block_id;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    bcm_l2_addr_t_init(&l2_addr, mac, vid);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    L2T_LOCK(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_attrib_set(eh, BCMLT_ENT_ATTR_GET_FROM_HW));

    SHR_IF_ERR_EXIT
        (l2_entry_populate(unit, eh, lt_info, &l2_addr, true));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(eh, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_EXIT
        (l2_entry_parse(unit, eh, 0, lt_info, &l2_addr, &l2_dst_block_id));

    sal_memcpy(l2addr, &l2_addr, sizeof(bcm_l2_addr_t));

    l2_addr.flags = 0;
    (void)l2_station_lookup(unit, mac, vid, &l2_addr);

    l2addr->flags |= l2_addr.flags;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_addr_delete(
    int unit,
    bcm_mac_t mac,
    bcm_vlan_t vid)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcm_l2_addr_t l2addr, l2addr_del;
    int dunit, rv, l2_dst_block_id, count, cb_suppress = false;
    bool notify = NOTIFY_L2_EVENT(unit);
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    rv = l2_station_delete(unit, mac, vid);
    SHR_IF_ERR_EXIT(rv);

    /* Check if suppress callbacks of L2 add/delete. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_switch_control_get(unit,
                                     bcmSwitchL2ApplCallbackSuppress,
                                     &cb_suppress));
    notify = cb_suppress ? false : notify;

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    L2T_LOCK(unit);

    bcm_l2_addr_t_init(&l2addr, mac, vid);

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh));

    SHR_IF_ERR_EXIT
        (l2_entry_populate(unit, eh, lt_info, &l2addr, true));

    /* First do lookup with key to fetch whole entry */
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(eh,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    sal_memset(&l2addr_del, 0, sizeof(bcm_l2_addr_t));
    SHR_IF_ERR_EXIT
        (l2_entry_parse(unit, eh, 0, lt_info, &l2addr_del, &l2_dst_block_id));

    BCM_PBMP_COUNT(l2addr_del.block_bitmap, count);
    if (count) {
        SHR_IF_ERR_VERBOSE_EXIT
            (l2_dst_block_profile_delete(unit, l2_dst_block_id));
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(eh, BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

    if (notify) {
        bcmint_l2_event_notify(unit, NULL, &l2addr_del, L2_EVENT_DELETE);
    }

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_addr_replace(
    int unit,
    bcmint_l2_replace_t *rep_st)
{
    bcmint_l2_traverse_t  trav_st;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    L2T_LOCK(unit);

    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    if (rep_st->int_flags & BCMINT_L2_REPLACE_CLEAR_HIT_ONLY) {
        trav_st.flags = BCMINT_L2_TRAVERSE_HW;
    }
    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    trav_st.user_data = (void *)rep_st;
    trav_st.tid = lt_info->sdklt_tid;
    trav_st.fld_cnt = lt_info->fld_cnt;
    trav_st.int_cb = l2_replace_int_cb;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st, 0));
exit:
    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_addr_traverse(
    int unit,
    bcm_l2_traverse_cb trav_fn,
    void *user_data)
{
    bcmint_l2_traverse_t trav_st;
    bool locked = false;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    if (trav_fn == NULL) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    L2T_LOCK(unit);
    locked = true;
    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.flags = BCMINT_L2_TRAVERSE_HW;
    trav_st.user_cb = trav_fn;
    trav_st.user_data = user_data;
    trav_st.tid = lt_info->sdklt_tid;
    trav_st.fld_cnt = lt_info->fld_cnt;
    trav_st.int_cb = l2_traverse_int_cb;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st, 0));

exit:
    if (locked) {
        L2T_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_addr_del_by_tuple(
    int unit,
    bcmint_l2_tuple_ctrl_t *tuple_ctrl)
{
    bcmint_l2_traverse_t trav_st;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    L2T_LOCK(unit);

    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.user_data = (void *)tuple_ctrl;
    trav_st.tid = lt_info->sdklt_tid;
    trav_st.fld_cnt = lt_info->fld_cnt;
    trav_st.int_cb = tuple_match_delete_int_cb;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st, 0));
exit:
    L2T_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_station_size_get(
    int unit,
    uint32_t *tbl_sz)
{
    uint32_t size = 0;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_UNDERLAY_MY_STATION_ID);
    if (lt_info == NULL) {
        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_MY_STATION_ID);
    }
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    SHR_IF_ERR_EXIT
        (bcmi_lt_capacity_get(unit, lt_info->lt_name, &size));
    *tbl_sz = size;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_overlay_station_size_get(
    int unit,
    uint32_t *tbl_sz)
{
    uint32_t size = 0;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_UNDERLAY_MY_STATION_ID);
    if (lt_info == NULL) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_UNAVAIL);
    } else {
        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_MY_STATION_ID);
    }
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    SHR_IF_ERR_EXIT
        (bcmi_lt_capacity_get(unit, lt_info->lt_name, &size));
    *tbl_sz = size;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_age(int unit)
{
    bcmint_l2_traverse_t  trav_st;
    const bcmint_l2_map_info_t *lt_info = NULL;
    bool notify = NOTIFY_L2_EVENT(unit);
    int age = 1;

    SHR_FUNC_ENTER(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    sal_memset(&trav_st, 0, sizeof(bcmint_l2_traverse_t));
    trav_st.user_data = (void *)&unit;
    trav_st.flags = BCMINT_L2_TRAVERSE_HW | BCMINT_L2_TRAVERSE_WITH_LOCK;
    trav_st.tid = lt_info->sdklt_tid;
    trav_st.fld_cnt = lt_info->fld_cnt;
    trav_st.int_cb = l2_age_int_cb;
    age = notify ? 0 : 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_traverse(unit, &trav_st, age));
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_station_add(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    bcmlt_opcode_t opcode;
    int dunit;
    uint32_t select_flags = SELECT_FLAG_KEY | SELECT_FLAG_DATA;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    l2_station_lt_info_get(unit, station, &lt_info,
                           (flags & BCMINT_L2_STATION_OVERLAY) ? 1 : 0);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh));

    SHR_IF_ERR_EXIT
        (l2_station_entry_populate(unit, eh, lt_info,
                                   station, flags, select_flags));

    if (station->flags & BCM_L2_STATION_REPLACE) {
        opcode = BCMLT_OPCODE_UPDATE;
    } else {
        opcode = BCMLT_OPCODE_INSERT;
    }

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(eh, opcode, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_station_get(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    const bcmint_l2_map_info_t *lt_info = NULL;
    uint32_t select_flags = SELECT_FLAG_KEY;

    SHR_FUNC_ENTER(unit);

    l2_station_lt_info_get(unit, station, &lt_info,
                           (flags & BCMINT_L2_STATION_OVERLAY) ? 1 : 0);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh));

    SHR_IF_ERR_EXIT
        (l2_station_entry_populate(unit, eh, lt_info,
                                   station, flags, select_flags));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(eh, BCMLT_OPCODE_LOOKUP, BCMLT_PRIORITY_NORMAL));

    select_flags = SELECT_FLAG_KEY | SELECT_FLAG_DATA;

    SHR_IF_ERR_EXIT
        (l2_station_entry_parse(unit, eh, lt_info, station, select_flags));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_station_delete(
    int unit,
    bcm_l2_station_t *station,
    int flags)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    const bcmint_l2_map_info_t *lt_info = NULL;
    uint32_t select_flags = SELECT_FLAG_KEY;

    SHR_FUNC_ENTER(unit);

    l2_station_lt_info_get(unit, station, &lt_info,
                           (flags & BCMINT_L2_STATION_OVERLAY) ? 1 : 0);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate_by_id(dunit, lt_info->sdklt_tid,
                                    lt_info->fld_cnt, &eh));

    SHR_IF_ERR_EXIT
        (l2_station_entry_populate(unit, eh, lt_info,
                                   station, flags, select_flags));

    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(eh, BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(eh);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_learn_set(
    int unit,
    int enable)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_learn_enable(unit, enable));
    l2c->learn_enable = enable;
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_learn_get(
    int unit,
    int *enable)
{
    l2_ctrl_t *l2c = &l2_ctrl[unit];

    *enable = l2c->learn_enable;
    return SHR_E_NONE;
}

int
xgs_ltsw_l2_size_get(
    int unit,
    int *size)
{
    uint32_t size_tmp = 0;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, lt_info->lt_name, &size_tmp));
    *size = size_tmp;
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_count_get(
    int unit,
    int *count)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t value = 0;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_HOST_TAB_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    dunit = bcmi_ltsw_dev_dunit(unit);

    /* Check the current number of entries inserted in this LT. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_INFOs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs, lt_info->lt_name));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit,
                              entry_hdl,
                              BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, ENTRY_INUSE_CNTs, &value));

    *count = value;

exit:
    if (BCMLT_INVALID_HDL != entry_hdl) {
        (void) bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_cache_init(int unit)
{
    bcm_l2_cache_addr_t caddr;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    if (!l2_cache_is_supported(unit)) {
        return SHR_E_NONE;
    }
    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_CACHE_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    L2_CACHE_LOCK(unit);

    /* Clean up L2 caching table */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, lt_info->lt_name));

    sal_memset(&caddr, 0, sizeof(caddr));
    caddr.flags = BCM_L2_CACHE_CPU | BCM_L2_CACHE_BPDU;
    /* Set default BPDU addresses (01:80:c2:00:00:00) */
    sal_memcpy(caddr.mac, mac_spanning_tree, sizeof(mac_spanning_tree));
    sal_memcpy(caddr.mac_mask, mac_all_ones, sizeof(mac_all_ones));
    
    caddr.dest_port = 0;
    caddr.flags |= BCM_L2_CACHE_PROTO_PKT;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_cache_insert(unit, &caddr));
    /* Set 01:80:c2:00:00:10 */
    caddr.mac[5] = 0x10;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_cache_insert(unit, &caddr));
    /* Set 01:80:c2:00:00:0x */
    caddr.mac[5] = 0x00;
    caddr.mac_mask[5] = 0xf0;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_cache_insert(unit, &caddr));
    /* Set 01:80:c2:00:00:2x */
    caddr.mac[5] = 0x20;
    SHR_IF_ERR_VERBOSE_EXIT
        (l2_cache_insert(unit, &caddr));

    l2_ctrl[unit].l2_cache_init = true;

exit:
    L2_CACHE_UNLOCK(unit);
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_cache_set(
    int unit,
    int index,
    bcm_l2_cache_addr_t *l2caddr,
    int *index_used)
{
    uint32_t index_num = 1;
    bcm_l2_station_t l2station;
    int l2_station_del = 0, rv;
    bool tnl = 0, found;
    const bcmint_l2_map_info_t *lt_info = NULL;

    SHR_FUNC_ENTER(unit);

    if (!l2_cache_is_supported(unit)) {
        return SHR_E_UNAVAIL;
    }
    L2_CACHE_INIT_CHECK(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_CACHE_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    if (l2caddr->flags & BCM_L2_CACHE_L3) {
        l2_cache_to_my_station_transfer(unit, l2caddr, &l2station, 0);
        found = bcmint_l2_station_db_get(unit, &l2station, &tnl);
        if (found == 0 || tnl == 1) {
            rv = xgs_ltsw_l2_station_add(unit, &l2station, 0);
            if (rv == SHR_E_EXISTS) {
                rv = SHR_E_NONE;
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
                l2_station_del = 1;
            }
        }
    }
    L2_CACHE_LOCK(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_tbl_control_config(unit, lt_info->lt_name, 1));

    SHR_IF_ERR_VERBOSE_EXIT
        (l2_cache_insert(unit, l2caddr));

    index_num = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_tbl_op_pt_info_index_get(unit, lt_info->lt_name,
                                     index_used, &index_num));

exit:
    (void)lt_tbl_control_config(unit, lt_info->lt_name, 0);
    L2_CACHE_UNLOCK(unit);

    if (SHR_FUNC_ERR() && l2_station_del) {
        (void)xgs_ltsw_l2_station_delete(unit, &l2station, 0);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_cache_get(
    int unit,
    int index,
    bcm_l2_cache_addr_t *l2caddr)
{
    int rv;
    uint32_t entry_num = 0;
    int use_my_station = (l2caddr->flags & BCM_L2_CACHE_L3) ? 1 : 0;
    const bcmint_l2_map_info_t *lt_info = NULL;

    if (!l2_cache_is_supported(unit)) {
        return SHR_E_UNAVAIL;
    }
    L2_CACHE_INIT_CHECK(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_CACHE_ID);
    if (lt_info == NULL) {
        return SHR_E_UNAVAIL;
    }

    (void)bcmi_lt_capacity_get(unit, lt_info->lt_name, &entry_num);
    if (index <= 0 || index > entry_num) {
        return SHR_E_PARAM;
    }
    L2_CACHE_LOCK(unit);

    rv = l2_cache_traverse(unit, index, NULL, lt_info,
                           (void *)l2caddr, use_my_station, 0);

    L2_CACHE_UNLOCK(unit);
    return rv;
}

int
xgs_ltsw_l2_cache_size_get(
    int unit,
    int *size)
{
    int rv;
    uint32_t tbl_size = 0;
    const bcmint_l2_map_info_t *lt_info = NULL;

    if (!l2_cache_is_supported(unit)) {
        return SHR_E_UNAVAIL;
    }
    L2_CACHE_INIT_CHECK(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_CACHE_ID);
    if (lt_info == NULL) {
        return SHR_E_UNAVAIL;
    }

    rv = bcmi_lt_capacity_get(unit, lt_info->lt_name, &tbl_size);
    *size = tbl_size;
    return rv;
}

int
xgs_ltsw_l2_cache_delete(
    int unit,
    int index)
{
    int rv;
    uint32_t entry_num = 0, index_input = index;
    bcm_l2_cache_addr_t l2caddr;
    const bcmint_l2_map_info_t *lt_info = NULL;

    if (!l2_cache_is_supported(unit)) {
        return SHR_E_UNAVAIL;
    }
    L2_CACHE_INIT_CHECK(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_CACHE_ID);
    if (lt_info == NULL) {
        return SHR_E_UNAVAIL;
    }

    (void)bcmi_lt_capacity_get(unit, lt_info->lt_name, &entry_num);
    if (index <= 0 || index_input > entry_num) {
        return SHR_E_PARAM;
    }

    L2_CACHE_LOCK(unit);

    rv = l2_cache_traverse(unit, index, l2_cache_entry_delete, lt_info,
                           (void *)(&l2caddr), 1, 1);

    L2_CACHE_UNLOCK(unit);
    return rv;
}

int
xgs_ltsw_l2_cache_delete_all(int unit)
{
    int rv;
    bcm_l2_cache_addr_t l2caddr;
    const bcmint_l2_map_info_t *lt_info = NULL;

    if (!l2_cache_is_supported(unit)) {
        return SHR_E_UNAVAIL;
    }
    L2_CACHE_INIT_CHECK(unit);

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_CACHE_ID);
    if (lt_info == NULL) {
        return SHR_E_UNAVAIL;
    }

    L2_CACHE_LOCK(unit);

    rv = l2_cache_traverse(unit, -1, l2_cache_entry_delete, lt_info,
                          (void *)(&l2caddr), 1, 1);

    L2_CACHE_UNLOCK(unit);
    return rv;
}

int
xgs_ltsw_l2_opaque_tag_set(
    int unit,
    int opaque_tag_id,
    int tag_size,
    int ether_type,
    int tag_type,
    int valid)
{
    l2_opaque_tag_t l2_opaque_tag_info;
    const bcmint_l2_map_info_t *lt_info;
    ltsw_l2_lt_head_info_t lt_head_info;
    bcmint_l2_opaque_tag_t *config_ptr;

    SHR_FUNC_ENTER(unit);

    if (opaque_tag_id >= NUM_OPAQUE_TAG) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }
    l2_opaque_tag_info.opaque_tag_id = opaque_tag_id;
    l2_opaque_tag_info.tag_size = tag_size;
    l2_opaque_tag_info.ether_type = ether_type;
    l2_opaque_tag_info.tag_type = tag_type;

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_OPAQUE_TAG_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    lt_head_info.filter_set = SELECT_FLAG_KEY | SELECT_FLAG_DATA;
    lt_head_info.filter_get = 0;
    lt_head_info.lt_info = lt_info;
    l2_opaque_tag_info.lt_head_info = &lt_head_info;

    if (valid) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit, lt_info->lt_name,
                               (void *)&l2_opaque_tag_info,
                               l2_lt_entry_set_cb));
    } else {
        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_lt_entry_delete(unit, lt_info->lt_name,
                                  (void *)&l2_opaque_tag_info,
                                  l2_lt_entry_set_cb),
             SHR_E_NOT_FOUND);
    }
    config_ptr = &opaque_tag_config[unit][opaque_tag_id];
    config_ptr->tag_size = tag_size;
    config_ptr->ethertype = ether_type;
    config_ptr->tag_type = tag_type;
    config_ptr->valid = valid;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_opaque_tag_get(
    int unit,
    int opaque_tag_id,
    int *tag_size,
    int *ether_type,
    int *tag_type,
    int *valid)
{
    bcmint_l2_opaque_tag_t *config_ptr;

    SHR_FUNC_ENTER(unit);

    if (opaque_tag_id >= NUM_OPAQUE_TAG) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    config_ptr = &opaque_tag_config[unit][opaque_tag_id];
    *tag_size = config_ptr->tag_size;
    *ether_type = config_ptr->ethertype;
    *tag_type = config_ptr->tag_type;
    *valid = config_ptr->valid;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_payload_opaque_tag_set(
    int unit,
    int opaque_tag_id,
    int tag_size,
    int ether_type,
    int tag_type,
    int valid)
{
    l2_opaque_tag_t l2_opaque_tag_info;
    const bcmint_l2_map_info_t *lt_info;
    ltsw_l2_lt_head_info_t lt_head_info;
    bcmint_l2_opaque_tag_t *config_ptr;

    SHR_FUNC_ENTER(unit);

    if (opaque_tag_id >= NUM_PAYLOAD_OPAQUE_TAG ||
        tag_size != BCM_SWITCH_OPAQUE_TAG_SIZE_4_BYTES) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }
    l2_opaque_tag_info.opaque_tag_id = opaque_tag_id;
    l2_opaque_tag_info.tag_size = tag_size;
    l2_opaque_tag_info.ether_type = ether_type;
    l2_opaque_tag_info.tag_type = tag_type;

    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_PAYLOAD_OPAQUE_TAG_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    lt_head_info.filter_set = SELECT_FLAG_KEY | SELECT_FLAG_DATA;
    lt_head_info.filter_get = 0;
    lt_head_info.lt_info = lt_info;
    l2_opaque_tag_info.lt_head_info = &lt_head_info;

    if (valid) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit, lt_info->lt_name,
                               (void *)&l2_opaque_tag_info,
                               l2_lt_entry_set_cb));
    } else {
        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_lt_entry_delete(unit, lt_info->lt_name,
                                  (void *)&l2_opaque_tag_info,
                                  l2_lt_entry_set_cb),
             SHR_E_NOT_FOUND);
    }
    config_ptr = &opaque_tag_config[unit][opaque_tag_id + NUM_OPAQUE_TAG];
    config_ptr->tag_size = BCM_SWITCH_OPAQUE_TAG_SIZE_4_BYTES;
    config_ptr->ethertype = ether_type;
    config_ptr->tag_type = 0;
    config_ptr->valid = valid;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_payload_opaque_tag_get(
    int unit,
    int opaque_tag_id,
    int *tag_size,
    int *ether_type,
    int *tag_type,
    int *valid)
{
    bcmint_l2_opaque_tag_t *config_ptr;

    SHR_FUNC_ENTER(unit);

    if (opaque_tag_id >= NUM_PAYLOAD_OPAQUE_TAG) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }
    config_ptr = &opaque_tag_config[unit][opaque_tag_id + NUM_OPAQUE_TAG];
    *tag_size = config_ptr->tag_size;
    *ether_type = config_ptr->ethertype;
    *tag_type = config_ptr->tag_type;
    *valid = config_ptr->valid;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_frozen_cml_restore(
    int unit,
    int *l2_freeze_mode)
{
    const bcmint_l2_map_info_t *lt_info;
    ltsw_l2_lt_head_info_t lt_head_info;
    l2_learn_override_t l2_learn_override_info;

    SHR_FUNC_ENTER(unit);

    if (L2_FROZEN_OVERRIDE_STATUS(unit) == 1) {
        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_LEARN_OVERRIDE_ID);
        SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);
        l2_learn_override_info.mac_learn_override = 0;
        l2_learn_override_info.mac_move_override = 0;
        l2_learn_override_info.lt_head_info = &lt_head_info;
        lt_head_info.lt_info = lt_info;
        lt_head_info.filter_set = SELECT_FLAG_KEY;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit, lt_info->lt_name,
                               (void *)&l2_learn_override_info,
                               l2_lt_entry_set_cb));

        L2_FROZEN_OVERRIDE_STATUS(unit) = 0;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_switch_control_get(unit, bcmSwitchL2FreezeMode,
                                     l2_freeze_mode));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_frozen_cml_save(
    int unit,
    int *l2_freeze_mode)
{
    l2_learn_override_t l2_learn_override_info;
    const bcmint_l2_map_info_t *lt_info;
    ltsw_l2_lt_head_info_t lt_head_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_switch_control_get(unit, bcmSwitchL2FreezeMode,
                                     l2_freeze_mode));
    if (*l2_freeze_mode == 0) {
        /* freeze L2 by per port mode */
        SHR_EXIT();
    } else if (L2_FROZEN_OVERRIDE_STATUS(unit) == 0) {
        lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_LEARN_OVERRIDE_ID);
        SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

        l2_learn_override_info.mac_learn_override = 1;
        l2_learn_override_info.mac_move_override = 1;
        l2_learn_override_info.lt_head_info = &lt_head_info;
        lt_head_info.lt_info = lt_info;
        lt_head_info.filter_set = SELECT_FLAG_KEY;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit, lt_info->lt_name,
                               (void *)&l2_learn_override_info,
                               l2_lt_entry_set_cb));

        L2_FROZEN_OVERRIDE_STATUS(unit) = 1;
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_l2_frozen_cml_recover(
    int unit,
    int *l2_freeze_override)
{
    l2_learn_override_t l2_learn_override_info;
    const bcmint_l2_map_info_t *lt_info;
    ltsw_l2_lt_head_info_t lt_head_info;
    int l2_freeze_mode;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcm_ltsw_switch_control_get(unit, bcmSwitchL2FreezeMode,
                                     &l2_freeze_mode));
    if (l2_freeze_mode == 0) {
        /* freeze L2 by per port mode */
        *l2_freeze_override = 0;
        SHR_EXIT();
    }
    lt_info = xgs_ltsw_l2_lt_info_get(unit, XGS_L2_LEARN_OVERRIDE_ID);
    SHR_NULL_CHECK(lt_info, SHR_E_UNAVAIL);

    l2_learn_override_info.mac_learn_override = 0;
    l2_learn_override_info.mac_move_override = 0;
    l2_learn_override_info.lt_head_info = &lt_head_info;
    lt_head_info.lt_info = lt_info;
    lt_head_info.filter_get = SELECT_FLAG_KEY;
    /* Only one entry for this LT, so need not to configure key fields. */
    lt_head_info.filter_set = 0;

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmi_lt_entry_get(unit, lt_info->lt_name,
                           (void *)&l2_learn_override_info,
                           l2_lt_entry_set_cb,
                           l2_lt_entry_get_cb),
         SHR_E_NOT_FOUND);

    if (l2_learn_override_info.mac_learn_override !=
        l2_learn_override_info.mac_move_override) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    } else {
        L2_FROZEN_OVERRIDE_STATUS(unit) = l2_learn_override_info.mac_learn_override;
        *l2_freeze_override = l2_learn_override_info.mac_learn_override;
    }

exit:
    SHR_FUNC_EXIT();
}

