/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/ltsw/xgs/trunk.h>
#include <bcm_int/ltsw/feature.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/dlb.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_TRUNK

/******************************************************************************
 * Private functions
 */


/*!
 * \brief Get TRUNK module public infomation.
 *
 * \param [in] unit Unit Number.
 * \param [out] t_pub Trunk public information.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_pub_info_get(
    int unit,
    bcmint_trunk_pub_info_t *t_pub)
{
    uint64_t min, max;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(t_pub, SHR_E_MEMORY);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNKs, TRUNK_IDs,
                                       &min, &max));
    t_pub->ngroups_fp = (int)max + 1;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNKs, UC_MAX_MEMBERSs,
                                       &min, &max));
    t_pub->nports_fp = (int)max;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TRUNK_FAILOVERs, FAILOVER_CNTs,
                                       &min, &max));
    t_pub->nftports_fp = (int)max;

    
    t_pub->ngroups_fabric = 0;
    t_pub->nports_fabric = 0;
    t_pub->nftports_fabric = 0;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Psc decode to HW rtag and load balance mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] psc Port Selection Criteria.
 * \param [out] uc_rtag Unicast Rules Tag Value.
 * \param [out] lb_mode Load Balance Mode.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_psc_decode(
    int unit,
    int psc,
    const char **uc_rtag,
    const char **lb_mode)
{
    const char *local_uc_rtag, *local_lb_mode;

    SHR_FUNC_ENTER(unit);

    switch (psc) {
        case BCM_TRUNK_PSC_PORTFLOW:
            local_uc_rtag = LB_HASHs;
            local_lb_mode = REG_HASHs;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (uc_rtag) {
        *uc_rtag = local_uc_rtag;

    }

    if (lb_mode) {
        *lb_mode = local_lb_mode;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Psc encode from HW rtag and load balance mode.
 *
 * \param [in] unit Unit Number.
 * \param [in] uc_rtag Unicast Rules Tag Value.
 * \param [in] lb_mode Load Balance Mode.
 * \param [out] psc Port Selection Criteria.
 *
 * \retval SHE_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_psc_encode(
    int unit,
    const char *uc_rtag,
    const char *lb_mode,
    int *psc)
{
    const char *local_uc_rtag, *local_lb_mode;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(uc_rtag, SHR_E_PARAM);
    SHR_NULL_CHECK(psc, SHR_E_PARAM);

    local_uc_rtag = uc_rtag;

    if (lb_mode == NULL) {
        local_lb_mode = REG_HASHs;
    } else {
        local_lb_mode = lb_mode;
    }

    if (sal_strcmp(local_lb_mode, REG_HASHs) == 0) {
        if (sal_strcmp(local_uc_rtag, LB_HASHs) == 0) {
            *psc = BCM_TRUNK_PSC_PORTFLOW;
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Compare two psc values and return the result.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_type Trunk Type.
 * \param [in] psc0 First Port Selection Criteria.
 * \param [in] psc1 Second Port Selection Criteria.
 * \param [in] exact Exact match.
 * \param [out] result TRUE/False: Same or Not.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_psc_compare(
    int unit,
    int psc0,
    int psc1,
    int exact,
    bool *result)
{
    const char *uc_rtag, *lb_mode;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(result, SHR_E_PARAM);

    *result = false;

    if (psc0 == psc1) {
        *result = true;
    } else {
        if (exact) {
            SHR_EXIT();
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xgs_trunk_psc_decode(unit, psc0, &uc_rtag, &lb_mode));

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xgs_trunk_psc_encode(unit, uc_rtag, lb_mode, &psc0));

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xgs_trunk_psc_decode(unit, psc1, &uc_rtag, &lb_mode));

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xgs_trunk_psc_encode(unit, uc_rtag, lb_mode, &psc1));

        if (psc0 == psc1) {
            *result = true;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Extract front panel trunk failover flags from trunk configuration flags.
 *
 * \param [in] unit Unit Number.
 * \param [in] flags Trunk Configuration Flags.
 * \param [in] fail_flags Trunk Failover Flags.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_failover_flags_extract(
    int unit,
    uint32_t flags,
    uint32_t *fail_flags)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(fail_flags, SHR_E_PARAM);

    *fail_flags = 0;

    if (flags & BCM_TRUNK_FLAG_FAILOVER_NEXT) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_NEXT;
    } else if (flags & BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL;
    } else if (flags & BCM_TRUNK_FLAG_FAILOVER_ALL) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_ALL;
    } else if (flags & BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL) {
        *fail_flags = BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set front panel trunk failover members to a specific port member.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [in] psc Port Selection Criteria.
 * \param [in] ftp_count Failto Port Count.
 * \param [in] ftp Failto Port Array.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_failover_fp_set(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_gport_t fail_port,
    int psc,
    int ftp_count,
    bcm_gport_t *ftp)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int rv;
    uint64_t value;
    const char *rtag, *pre_rtag;
    int pre_lt_count, i, dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FAILOVERs, &lte_hdl));

    value = BCM_GPORT_MODPORT_PORT_GET(fail_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    if (ftp_count == 0) {
        rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL);

        if (SHR_SUCCESS(rv) || rv == SHR_E_NOT_FOUND) {
            SHR_EXIT();
        } else {
            SHR_ERR_EXIT(rv);
        }
    }

    rv = bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);

    if (SHR_SUCCESS(rv)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xgs_trunk_psc_decode(unit, psc, &rtag, NULL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(lte_hdl, RTAGs, &pre_rtag));

        if (sal_strcmp(pre_rtag, rtag) != 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(lte_hdl, RTAGs, rtag));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, FAILOVER_CNTs, &value));
        pre_lt_count = value & 0xffffffff;

        for (i = 0; i < ftp_count; i++) {
            value = BCM_GPORT_MODPORT_MODID_GET(ftp[i]);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_MODIDs,
                                             i, &value, 1));

            value = BCM_GPORT_MODPORT_PORT_GET(ftp[i]);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_MODPORTs,
                                             i, &value, 1));
        }

        if (pre_lt_count != ftp_count) {
            value = ftp_count;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, FAILOVER_CNTs, value));
        }

        if (pre_lt_count > 0 && ftp_count < pre_lt_count) {
            for (i = ftp_count; i < pre_lt_count; i++) {
                value = 0;
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_MODIDs,
                                                 i, &value, 1));

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_MODPORTs,
                                                 i, &value, 1));
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
    } else if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xgs_trunk_psc_decode(unit, psc, &rtag, NULL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(lte_hdl, RTAGs, rtag));

        pre_lt_count = 0;
        for (i = 0; i < ftp_count; i++) {
            value = BCM_GPORT_MODPORT_MODID_GET(ftp[i]);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_MODIDs,
                                             i, &value, 1));

            value = BCM_GPORT_MODPORT_PORT_GET(ftp[i]);
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, FAILOVER_MODPORTs,
                                             i, &value, 1));
        }

        if (pre_lt_count != ftp_count) {
            value = ftp_count;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, FAILOVER_CNTs, value));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_INSERT,
                                BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_ERR_EXIT(rv);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get front panel trunk failover members of a specific port member.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [out] psc Port Selection Criteria.
 * \param [in] ftp_max Failto Port Max Count.
 * \param [out] ftp Failto Port Array.
 * \param [out] ftp_count Failto Port Count.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_failover_fp_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_gport_t fail_port,
    int *psc,
    int ftp_max,
    bcm_gport_t *ftp,
    int *ftp_count)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    const char *rtag;
    int lt_count, i, modid, modport, dunit;

    SHR_FUNC_ENTER(unit);

    if (ftp_max < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (ftp_count) {
        *ftp_count = 0;
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNK_FAILOVERs, &lte_hdl));

    value = BCM_GPORT_MODPORT_PORT_GET(fail_port);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    if (psc) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(lte_hdl, RTAGs, &rtag));

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xgs_trunk_psc_encode(unit, rtag, NULL, psc));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, FAILOVER_CNTs, &value));
    lt_count = value & 0xffffffff;

    if ((lt_count > ftp_max) && (ftp_max > 0)) {
        lt_count = ftp_max;
    }

    if (ftp_count) {
        *ftp_count = lt_count;
    }

    if (ftp_max == 0) {
        SHR_EXIT();
    }

    for (i = 0; i < lt_count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, FAILOVER_MODIDs, &value));
        modid = value & 0xffffffff;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, FAILOVER_MODPORTs, &value));
        modport = value & 0xffffffff;

        BCM_GPORT_MODPORT_SET(ftp[i], modid, modport);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update trunk failover configuration for a specific trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_type Trunk Type.
 * \param [in] psc Port Selection Criteria.
 * \param [in] fail_flags Failover Configuration Flags.
 * \param [in] fail_port Local Failover Port Gport Number.
 * \param [in] ftp_max Failto Port Max Number.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_failover_update(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    int psc,
    uint32_t fail_flags,
    bcm_gport_t fail_port,
    int ftp_max,
    int member_count,
    bcm_trunk_member_t *member_array)
{
    int i, j;
    int local, next, hw_count, modid, modid_is_local;
    bcm_gport_t *ftp = NULL;

    SHR_FUNC_ENTER(unit);

    /* Where is failover port in the trunk member list? */
    for (i = 0; i < member_count; i++) {
        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            continue;
        }
        if (member_array[i].gport == fail_port) {
            break;
        }
    }

    /* Port is not in the trunk member list! */
    if ((0 != member_count) && (i == member_count)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    if (member_count == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_ltsw_trunk_failover_set(unit, t_id, t_type,
                                         fail_port, psc, 0, NULL));
        SHR_EXIT();
    }

    if (fail_flags) {
        switch (fail_flags) {
            case BCM_TRUNK_FLAG_FAILOVER_NEXT_LOCAL:
                next = TRUE;
                local = TRUE;
                break;
            case BCM_TRUNK_FLAG_FAILOVER_NEXT:
                next = TRUE;
                local = FALSE;
                break;
            case BCM_TRUNK_FLAG_FAILOVER_ALL_LOCAL:
                next = FALSE;
                local = TRUE;
                break;
            case BCM_TRUNK_FLAG_FAILOVER_ALL:
                next = FALSE;
                local = FALSE;
                break;
            default:
                /* Illegal flags setting */
                SHR_ERR_EXIT(SHR_E_PARAM);
        }

        SHR_ALLOC(ftp, sizeof(bcm_gport_t) * member_count, "bcmTrunkGport");
        SHR_NULL_CHECK(ftp, SHR_E_MEMORY);

        hw_count = 0;

        for (j = ((i + 1) % member_count);
             j != i;
             j = ((j + 1) % member_count)) {
            modid = BCM_GPORT_MODPORT_MODID_GET(member_array[j].gport);

            if (local) {
                SHR_IF_ERR_CONT
                    (bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local));
                if (SHR_FUNC_ERR() || !modid_is_local) {
                    continue;
                }
            }

            if (member_array[j].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }

            if (hw_count == ftp_max) {
                break;
            }

            ftp[hw_count++] = member_array[j].gport;

            if (next) {
                break;
            }
        }

        SHR_IF_ERR_CONT
            (xgs_ltsw_trunk_failover_set(unit, t_id, t_type,
                                         fail_port, psc, hw_count, ftp));

        SHR_FREE(ftp);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate the front panel trunk parameters before setting the trunk.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_params_validate_fp(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member)
{
    int i;

    SHR_FUNC_ENTER(unit);

    /* Validate the PSC value */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_psc_decode(unit, trunk_info->psc, NULL, NULL));

    /* Validate the member flags */
    for (i = 0; i < member_count; i++) {
        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            if (member_array[i].flags & BCM_TRUNK_MEMBER_INGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_UNICAST_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_IPMC_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_L2MC_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_BCAST_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }

            if (member_array[i].flags &
                    BCM_TRUNK_MEMBER_DLF_EGRESS_DISABLE) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_IPMC_EGRESS_DISABLE) {
            if (trunk_info->ipmc_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_L2MC_EGRESS_DISABLE) {
            if (trunk_info->mc_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_BCAST_EGRESS_DISABLE) {
            if (trunk_info->dlf_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_DLF_EGRESS_DISABLE) {
            if (trunk_info->dlf_index != BCM_TRUNK_UNSPEC_INDEX) {
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
    }

    /* Validate the trunk information */
    if (member_count > 0 && trunk_info->dlf_index >= member_count) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk group configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_update_fp_group(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int i, dunit;
    const char *uc_rtag, *lb_mode;
    uint64_t value;
    int member_cnt;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNKs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));

    if (member_count <= 0) {
        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                                BCMLT_PRIORITY_NORMAL),
             SHR_E_NOT_FOUND);
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_psc_decode(unit, trunk_info->psc,
                                   &uc_rtag, &lb_mode));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(lte_hdl, UC_RTAGs, uc_rtag));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(lte_hdl, LB_MODEs, lb_mode));

    member_cnt = 0;

    for (i = 0; i < member_count; i++) {
        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_UNICAST_EGRESS_DISABLE) {
            continue;
        }

        value = BCM_GPORT_MODPORT_MODID_GET(member_array[i].gport);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(lte_hdl, UC_MEMBER_MODIDs,
                                         member_cnt, &value, 1));

        value = BCM_GPORT_MODPORT_PORT_GET(member_array[i].gport);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(lte_hdl, UC_MEMBER_MODPORTs,
                                         member_cnt, &value, 1));

        member_cnt++;
    }

    if ((member_cnt >= 0) && (member_cnt < t_priv->t_info->member_count)) {
        for (i = member_cnt; i < t_priv->t_info->member_count; i++) {
            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, UC_MEMBER_MODIDs,
                                             i, &value, 1));

            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, UC_MEMBER_MODPORTs,
                                             i, &value, 1));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, UC_MEMBER_CNTs,
                               member_cnt));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, UC_MAX_MEMBERSs,
                               member_cnt));

    member_cnt = 0;

    for (i = 0; i < member_count; i++) {
        if (trunk_info->dlf_index != BCM_TRUNK_UNSPEC_INDEX &&
            trunk_info->dlf_index != i) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_IPMC_EGRESS_DISABLE) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_L2MC_EGRESS_DISABLE) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_BCAST_EGRESS_DISABLE) {
            continue;
        }

        if (member_array[i].flags & BCM_TRUNK_MEMBER_DLF_EGRESS_DISABLE) {
            continue;
        }

        value = BCM_GPORT_MODPORT_MODID_GET(member_array[i].gport);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(lte_hdl, NONUC_MEMBER_MODIDs,
                                         member_cnt, &value, 1));

        value = BCM_GPORT_MODPORT_PORT_GET(member_array[i].gport);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(lte_hdl, NONUC_MEMBER_MODPORTs,
                                         member_cnt, &value, 1));

        member_cnt++;
    }

    if ((member_cnt >= 0) && (member_cnt < t_priv->t_info->member_count)) {
        for (i = member_cnt; i < t_priv->t_info->member_count; i++) {
            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, NONUC_MEMBER_MODIDs,
                                             i, &value, 1));

            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_add(lte_hdl, NONUC_MEMBER_MODPORTs,
                                             i, &value, 1));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, NONUC_MEMBER_CNTs,
                               member_cnt));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, lte_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Migrate front panel trunk attribute to new joining members.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_update_fp_attr_migrate(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_update_info_t *t_update)
{
    
    return SHR_E_NONE;
}

/*!
 * \brief Update the front panel trunk port attributes.
 *
 * \param [in] unit Unit Number.
 * \param [in] modid Module Number.
 * \param [in] port Port Number.
 * \param [in] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_update_fp_port_attr(
    int unit,
    bcm_module_t modid,
    bcm_port_t port,
    bcmint_trunk_id_t t_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit;

    SHR_FUNC_ENTER(unit);

    /* Get PORT_SYSTEM_ID for specific modid */
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_MODBASEs, &lte_hdl));

    value = modid;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, MODIDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, MODBASEs, &value));

    (void)bcmlt_entry_free(lte_hdl);
    lte_hdl = BCMLT_INVALID_HDL;

    /* Update SYSTEM_PORT_TYPE for specific modid + port */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SYSTEMs, &lte_hdl));

    value += port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_SYSTEM_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    if (t_id == BCM_TRUNK_INVALID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(lte_hdl, SYSTEM_PORT_TYPEs,
                                          NORMAL_PORTs));

        value = 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(lte_hdl, SYSTEM_PORT_TYPEs,
                                          TRUNK_PORTs));

        value = t_id;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk member configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_update_fp_member(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    int i, modid, port;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < member_count; i++) {
        modid = BCM_GPORT_MODPORT_MODID_GET(member_array[i].gport);
        port = BCM_GPORT_MODPORT_PORT_GET(member_array[i].gport);

        if (member_array[i].flags & BCM_TRUNK_MEMBER_INGRESS_DISABLE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xgs_trunk_update_fp_port_attr(unit, modid, port,
                                                    BCM_TRUNK_INVALID));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xgs_trunk_update_fp_port_attr(unit, modid, port, t_id));
        }
    }

    for (i = 0; i < t_update->num_leaving; i++) {
        modid = BCM_GPORT_MODPORT_MODID_GET(t_update->leaving_members[i]);
        port = BCM_GPORT_MODPORT_PORT_GET(t_update->leaving_members[i]);

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xgs_trunk_update_fp_port_attr(unit, modid, port,
                                                BCM_TRUNK_INVALID));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk failover configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_update_fp_failover(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    int i;
    bcm_gport_t fail_port;
    int modid, modid_is_local;
    uint32_t fail_flags;
    bcmint_trunk_info_t *t_info;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_trunk_failover_flags_extract(unit, trunk_info->flags,
                                               bcmintTrunkTypeFrontPanel,
                                               &fail_flags));

    if (fail_flags != 0 || member_count == 0) {
        /* Disable hardware failover for old trunk ports */
        for (i = 0; i < t_priv->t_info->member_count; i++) {
            fail_port = t_priv->member_array[i].gport;
            modid = BCM_GPORT_MODPORT_MODID_GET(fail_port);

            SHR_IF_ERR_CONT
                (bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local));
            if (SHR_FUNC_ERR() || !modid_is_local) {
                continue;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_ltsw_trunk_failover_update(unit, t_id,
                                                bcmintTrunkTypeFrontPanel,
                                                0, 0, fail_port, 0, 0, NULL));
        }
    }

    if (fail_flags != 0) {
        for (i = 0; i < member_count; i++) {
            fail_port = member_array[i].gport;
            modid = BCM_GPORT_MODPORT_MODID_GET(fail_port);

            SHR_IF_ERR_CONT
                (bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local));
            if (SHR_FUNC_ERR() || !modid_is_local) {
                continue;
            }

            if (member_array[i].flags & BCM_TRUNK_MEMBER_EGRESS_DISABLE) {
                continue;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_ltsw_trunk_failover_update(unit, t_id,
                                                bcmintTrunkTypeFrontPanel,
                                                trunk_info->psc, fail_flags,
                                                fail_port, t_update->ftp_max,
                                                member_count, member_array));
        }
    } else {
        t_info = t_priv->t_info;
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_ltsw_trunk_failover_flags_extract(unit, t_info->flags,
                                                   bcmintTrunkTypeFrontPanel,
                                                   &fail_flags));
        if (fail_flags != 0) {
            trunk_info->flags |= fail_flags;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Update the front panel trunk configuration.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] trunk_info Trunk Information.
 * \param [in] member_count Trunk Member Count.
 * \param [in] member_array Trunk Member Array.
 * \param [in] op Trunk Member Operation Code.
 * \param [in] member Trunk Member.
 * \param [in] t_priv Trunk private information.
 * \param [in] t_update Trunk update information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_update_fp(
    int unit,
    bcmint_trunk_id_t t_id,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    SHR_FUNC_ENTER(unit);

    /* Configure static load balancing */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_update_fp_group(unit, t_id, trunk_info,
                                        member_count, member_array,
                                        t_priv, t_update));

    /* Update source trunk map configuration */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_update_fp_member(unit, t_id, trunk_info,
                                         member_count, member_array,
                                         t_priv, t_update));

    /* Harware trunk failover */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_update_fp_failover(unit, t_id, trunk_info,
                                           member_count, member_array,
                                           t_priv, t_update));

    /* Migrate trunk attributes */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_update_fp_attr_migrate(unit, t_id, t_update));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a front panel trunk with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_destroy_fp_group(
    int unit,
    bcmint_trunk_id_t t_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TRUNKs, &lte_hdl));

    value = t_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));

    SHR_IF_ERR_EXIT_EXCEPT_IF
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_DELETE,
                            BCMLT_PRIORITY_NORMAL),
         SHR_E_NOT_FOUND);

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a front panel trunk member attributes with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_destroy_fp_port_attr(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    int i, member_count;
    int modid, port;
    bcmint_trunk_member_t *member_array;

    SHR_FUNC_ENTER(unit);

    member_count = t_priv->t_info->member_count;
    member_array = t_priv->member_array;

    for (i = 0; i < member_count; i++) {
        modid = BCM_GPORT_MODPORT_MODID_GET(member_array[i].gport);
        port = BCM_GPORT_MODPORT_PORT_GET(member_array[i].gport);

        SHR_IF_ERR_VERBOSE_EXIT
            (ltsw_xgs_trunk_update_fp_port_attr(unit, modid, port,
                                                BCM_TRUNK_INVALID));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a front panel trunk failover with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_destroy_fp_failover(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    int i, member_count;
    int modid;
    bcmint_trunk_member_t *member_array;
    bcmint_trunk_info_t *t_info;
    uint32_t fail_flags;
    bcm_gport_t fail_port;
    int modid_is_local = 0;

    SHR_FUNC_ENTER(unit);

    t_info = t_priv->t_info;
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_trunk_failover_flags_extract(unit, t_info->flags,
                                               bcmintTrunkTypeFrontPanel,
                                               &fail_flags));
    if (fail_flags != 0) {
        member_count = t_priv->t_info->member_count;
        member_array = t_priv->member_array;

        for (i = 0; i < member_count; i++) {
            modid = BCM_GPORT_MODPORT_MODID_GET(member_array[i].gport);

            SHR_IF_ERR_CONT
                (bcmi_ltsw_modid_is_local(unit, modid, &modid_is_local));
            if (SHR_FUNC_ERR() || !modid_is_local) {
                continue;
            }
            fail_port = member_array[i].gport;

            SHR_IF_ERR_VERBOSE_EXIT
                (xgs_ltsw_trunk_failover_update(unit, t_id,
                                                bcmintTrunkTypeFrontPanel,
                                                0, 0, fail_port, 0, 0, NULL));
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Destroy a front panel trunk with a type-based trunk identifier.
 *
 * \param [in] unit Unit Number.
 * \param [in] t_id Type-based Trunk Identifier.
 * \param [in] t_priv Trunk private information.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_destroy_fp(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_destroy_fp_group(unit, t_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_destroy_fp_port_attr(unit, t_id, t_priv));

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_destroy_fp_failover(unit, t_id, t_priv));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear port type from trunk port to normal port.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_clear_port_attribute(int unit)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    int dunit, rv;
    uint64_t value;
    const char *sym_value;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SYSTEMs, &lte_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, lte_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_get(lte_hdl, SYSTEM_PORT_TYPEs,
                                          &sym_value));

        if (sal_strcmp(sym_value, TRUNK_PORTs) == 0) {
            sym_value = NORMAL_PORTs;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(lte_hdl, SYSTEM_PORT_TYPEs,
                                              sym_value));

            value = 0;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(lte_hdl, TRUNK_IDs, value));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL));
        }
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear front panel trunk configuration.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_clear_fp(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Clear TRUNK table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TRUNKs));

    /* Clear TRUNK_FAILOVER table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, TRUNK_FAILOVERs));

    /* Clear PORT_SYSTEM table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_clear_port_attribute(unit));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Find a specific front panel trunk with member gport.
 *
 * \param [in] unit Unit Number.
 * \param [in] gport Generic Port Number.
 * \param [out] t_id Type-based Trunk Identifier.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ltsw_xgs_trunk_find_fp(
    int unit,
    bcm_gport_t gport,
    bcmint_trunk_id_t *t_id)
{
    bcmlt_entry_handle_t lte_hdl = BCMLT_INVALID_HDL;
    uint64_t value;
    int dunit;
    const char *sys_port_type = NORMAL_PORTs;

    SHR_FUNC_ENTER(unit);

    /* Get PORT_SYSTEM_ID for specific modid */
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_MODBASEs, &lte_hdl));

    value = BCM_GPORT_MODPORT_MODID_GET(gport);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, MODIDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(lte_hdl, MODBASEs, &value));

    (void)bcmlt_entry_free(lte_hdl);
    lte_hdl = BCMLT_INVALID_HDL;

    /* Update SYSTEM_PORT_TYPE for specific modid + port */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, PORT_SYSTEMs, &lte_hdl));

    value += BCM_GPORT_MODPORT_PORT_GET(gport);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(lte_hdl, PORT_SYSTEM_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(lte_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(lte_hdl, SYSTEM_PORT_TYPEs,
                                      &sys_port_type));

    if (sal_strcmp(sys_port_type, TRUNK_PORTs) == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(lte_hdl, TRUNK_IDs, &value));
        *t_id = value & 0xffffffff;
    } else {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    if (lte_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(lte_hdl);
        lte_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_trunk_pub_info_get(
    int unit,
    bcmint_trunk_pub_info_t *t_pub)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_pub_info_get(unit, t_pub));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_psc_compare(
    int unit,
    bcmint_trunk_type_t t_type,
    int psc0,
    int psc1,
    int exact,
    bool *result)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xgs_trunk_psc_compare(unit, psc0, psc1, exact, result));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Clear front panel trunk configuration. */
    SHR_IF_ERR_VERBOSE_EXIT
        (ltsw_xgs_trunk_clear_fp(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_create(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_priv_info_t *t_priv)
{
    return SHR_E_NONE;
}

int
xgs_ltsw_trunk_params_validate(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xgs_trunk_params_validate_fp(unit, t_id, trunk_info,
                                                   member_count, member_array,
                                                   op, member));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_update(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_trunk_info_t *trunk_info,
    int member_count,
    bcm_trunk_member_t *member_array,
    int op,
    bcm_trunk_member_t *member,
    bcmint_trunk_priv_info_t *t_priv,
    bcmint_trunk_update_info_t *t_update)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xgs_trunk_update_fp(unit, t_id, trunk_info,
                                          member_count, member_array,
                                          op, member, t_priv, t_update));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_destroy(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_priv_info_t *t_priv)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xgs_trunk_destroy_fp(unit, t_id, t_priv));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_find(
    int unit,
    bcm_gport_t gport,
    bcmint_trunk_id_t *t_id,
    bcmint_trunk_type_t *t_type)
{
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(t_id, SHR_E_PARAM);
    SHR_NULL_CHECK(t_type, SHR_E_PARAM);

    rv = ltsw_xgs_trunk_find_fp(unit, gport, t_id);
    if (SHR_SUCCESS(rv)) {
        *t_type = bcmintTrunkTypeFrontPanel;
        SHR_EXIT();
    } else if (rv != SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(rv);
    }

    SHR_ERR_EXIT(rv);

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_failover_flags_extract(
    int unit,
    uint32_t flags,
    bcmint_trunk_type_t t_type,
    uint32_t *fail_flags)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xgs_trunk_failover_flags_extract(unit, flags,
                                                       fail_flags));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_failover_psc_validate(
    int unit,
    bcmint_trunk_type_t t_type,
    int psc)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_trunk_failover_set(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_gport_t fail_port,
    int psc,
    int ftp_count,
    bcm_gport_t *ftp)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xgs_trunk_failover_fp_set(unit, t_id, fail_port,
                                                psc, ftp_count, ftp));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_failover_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    bcm_gport_t fail_port,
    int *psc,
    int ftp_max,
    bcm_gport_t *ftp,
    int *ftp_count)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xgs_trunk_failover_fp_get(unit, t_id, fail_port,
                                                psc, ftp_max, ftp, ftp_count));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_failover_update(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_type_t t_type,
    int psc,
    uint32_t fail_flags,
    bcm_gport_t fail_port,
    int ftp_max,
    int member_count,
    bcm_trunk_member_t *member_array)
{
    SHR_FUNC_ENTER(unit);

    switch(t_type) {
        case bcmintTrunkTypeFrontPanel:
            SHR_IF_ERR_VERBOSE_EXIT
                (ltsw_xgs_trunk_failover_update(unit, t_id, t_type,
                                                psc, fail_flags,
                                                fail_port, ftp_max,
                                                member_count, member_array));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_override_set(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_override_type_t o_type,
    int o_index,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    
    SHR_ERR_EXIT(SHR_E_UNAVAIL);

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_override_get(
    int unit,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_override_type_t o_type,
    int o_index,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    
    SHR_ERR_EXIT(SHR_E_UNAVAIL);

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_trunk_member_status_set(
    int unit,
    bcm_port_t port,
    int status)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_trunk_member_status_get(
    int unit,
    bcm_port_t port,
    int *status)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_trunk_find_dlb_id(
    int unit,
    bcmint_trunk_type_t t_type,
    bcmint_trunk_id_t t_id,
    bcmint_trunk_priv_info_t *t_priv,
    int *dlb_id)
{
    return SHR_E_UNAVAIL;
}

