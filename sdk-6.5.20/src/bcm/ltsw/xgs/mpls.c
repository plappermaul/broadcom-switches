/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>
#include <bcm_int/common/multicast.h>
#include <bcm_int/ltsw_dispatch.h>

#include <bcm_int/ltsw/xgs/mpls.h>
#include <bcm_int/ltsw/xgs/types.h>
#include <bcm_int/ltsw/types.h>
#include <bcm_int/ltsw/mpls_int.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/qos.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/index_table_mgmt.h>
#include <bcm_int/ltsw/l3_egress.h>
#include <bcm_int/ltsw/ecn.h>
#include <bcm_int/ltsw/l3_intf.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/mpls.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/feature.h>

#include <shr/shr_bitop.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_MPLS

/******************************************************************************
 * Private functions
 */


/* Max count of encap labels. */
#define MPLS_ENCAP_LABEL_CNT_MAX 8

/* Min tunnel index. */
#define MPLS_TNL_IDX_MIN 1

/* Data structure for EGR_L3_TUNNEL_0/1 entry. */
typedef struct lt_mpls_tnl_encap_entry_s {
    uint64_t tnl_encap_id;

    uint64_t encap_index;

    uint64_t num_labels;

    uint64_t max_labels;

    uint64_t label[MPLS_ENCAP_LABEL_CNT_MAX];

    uint64_t label_ttl[MPLS_ENCAP_LABEL_CNT_MAX];

    uint64_t mpls_tnl_exp_mode[MPLS_ENCAP_LABEL_CNT_MAX];

    uint64_t phb_egr_mpls_id[MPLS_ENCAP_LABEL_CNT_MAX];

    uint64_t label_exp[MPLS_ENCAP_LABEL_CNT_MAX];

    uint64_t pri[MPLS_ENCAP_LABEL_CNT_MAX];

    uint64_t cfi[MPLS_ENCAP_LABEL_CNT_MAX];

    uint64_t ecn_cng_to_mpls_exp_id[MPLS_ENCAP_LABEL_CNT_MAX];

    uint64_t ecn_cng_to_mpls_exp_priority[MPLS_ENCAP_LABEL_CNT_MAX];

    uint64_t ecn_ip_to_mpls_exp_id[MPLS_ENCAP_LABEL_CNT_MAX];

    uint64_t ecn_ip_to_mpls_exp_priority[MPLS_ENCAP_LABEL_CNT_MAX];

} lt_mpls_tnl_encap_entry_t;

/* Data structure for TNL_MPLS_DECAP_x entry. */
typedef struct lt_mpls_tnl_decap_entry_s {
    bool     is_trunk;

    uint64_t label;

    uint64_t source;

    /* Bitmap of TNL_MPLS_DECAP_x fields to be operated. */
    uint64_t fld_bmp;
#define ME_FLD_BOS_ACTIONS                    (1 << 0)
#define ME_FLD_NON_BOS_ACTIONS                (1 << 1)
#define ME_FLD_L3_IIF_ID                      (1 << 2)
#define ME_FLD_NHOP_ID                        (1 << 3)
#define ME_FLD_ECMP_ID                        (1 << 4)
#define ME_FLD_USE_TTL_FROM_DECAP_HDR         (1 << 5)
#define ME_FLD_KEEP_PAYLOAD_DSCP              (1 << 6)
#define ME_FLD_TNL_EXP_TO_INNER_EXP           (1 << 7)
#define ME_FLD_EXP_MAP_ACTION                 (1 << 8)
#define ME_FLD_PHB_ING_MPLS_EXP_TO_INT_PRI_ID (1 << 9)
#define ME_FLD_IPV6_PAYLOAD                   (1 << 10)
#define ME_FLD_IPV4_PAYLOAD                   (1 << 11)
#define ME_FLD_DROP                           (1 << 12)
#define ME_FLD_INT_PRI                        (1 << 13)
#define ME_FLD_ECN_MPLS_EXP_TO_IP_ECN_ID      (1 << 14)
#define ME_FLD_BFD                            (1 << 15)
#define ME_FLD_CTR_ING_EFLEX_OBJECT           (1 << 16)
#define ME_FLD_CTR_ING_EFLEX_ACTION_ID        (1 << 17)
#define ME_FLD_CTR_ING_EFLEX_ACTION           (1 << 18)

    uint64_t bos_actions;

    uint64_t non_bos_actions;

    uint64_t l3_iif_id;

    uint64_t ecmp_id;

    uint64_t nhop_id;

    uint64_t use_ttl_from_decap_hdr;

    uint64_t keep_payload_dscp;

    uint64_t tnl_exp_to_inner_exp;

    uint64_t exp_map_action;

    uint64_t phb_ing_mpls_exp_to_int_pri_id;

    uint64_t ipv6_payload;

    uint64_t ipv4_payload;

    uint64_t drop;

    uint64_t int_pri;

    uint64_t ecn_mpls_exp_to_ip_ecn_id;

    uint64_t bfd;

    uint64_t ctr_ing_eflex_object;

    uint64_t ctr_ing_eflex_action_id;

} lt_mpls_tnl_decap_entry_t;

typedef struct nh_entry_info_s {
    /* NHOP type. */
    int nhop_type;
#define L3_INVALID_NHOP_TYPE 0
#define L3_UC_NHOP_TYPE 1
#define L3_MC_NHOP_TYPE 2
#define L3_MPLS_TRANSIT_NHOP_TYPE 3
#define L3_MPLS_ENCAP_NHOP_TYPE 4
#define L3_IFP_ACTION_NHOP_TYPE 5

} nh_entry_info_t;

typedef struct mpls_info_s {
    /* mpls manager initialized. */
    uint8_t inited;

    /* Mutex. */
    sal_mutex_t mutex;

    /* Store encap id. */
    uint16_t *encap_id;

} mpls_info_t;

static mpls_info_t mpls_info[BCM_MAX_NUM_UNITS] = {{0}};

#define MPLS_INITED(_u) (mpls_info[_u].inited)

#define MPLS_LOCK(_u)     \
    sal_mutex_take(mpls_info[_u].mutex, SAL_MUTEX_FOREVER)

#define MPLS_UNLOCK(_u)   \
    sal_mutex_give(mpls_info[_u].mutex)

#define MPLS_TNL_ENCAP_ID(_u, _idx) \
    mpls_info[_u].encap_id[_idx]

/*! MPLS exp map  modes. */
typedef enum mpls_exp_mode_s {
    BCMINT_LTSW_MPLS_EXP_MODE_FIXED = 0,
    BCMINT_LTSW_MPLS_EXP_MODE_MAP = 1,
    BCMINT_LTSW_MPLS_EXP_MODE_USE_INNER_LABEL = 2,
    BCMINT_LTSW_MPLS_EXP_MODE_CNT
} mpls_exp_mode_t;

/*! MPLS exp map  modes strings. */
static const char *mpls_exp_mode_str[] = {
    FIXEDs,
    MAPs,
    USE_INNER_LABELs
};

typedef struct mpls_flexctr_cfg_s {
    /* Operation of flexctr fields: 0 = set, 1 = get. */
    bool op;
#define MPLS_FLXCTR_OP_SET   0
#define MPLS_FLXCTR_OP_GET   1

    /* Flags indicate which flexctr field to be operated. */
    uint8_t flags;
#define MPLS_FLXCTR_F_ACTION     (1 << 0)
#define MPLS_FLXCTR_F_INDEX      (1 << 1)

    /* Flex counter action. */
    uint32_t action;

    /*! Distinct flex counter index. */
    uint32_t index;
} mpls_flexctr_cfg_t;

typedef struct mpls_label_flex_action_profile_s {
    /*! Action. */
    uint32_t action;
} mpls_label_flex_action_profile_t;

/*!
 * \brief Convert entry to handle for the LT TNL_MPLS_DECAP_x.
 *
 * \param [in]  unit       Unit number.
 * \param [in]  entry      Entry info.
 * \param [out] ent_hdl    Entry handle.
 * \param [in] lt_db      LT database info.
 *
 * \retval SHR_E_NONE      No errors.
 * \retval !SHR_E_NONE     Failure.
 */
static int
lt_mpls_tnl_decap_entry_to_hdl(
    int unit,
    lt_mpls_tnl_decap_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl,
    const bcmint_mpls_lt_t *lt_db)
{
    const bcmint_mpls_fld_t *flds;
    int fid;
    const char *str_value;

    SHR_FUNC_ENTER(unit);
    flds = lt_db->flds;

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_LABEL;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, flds[fid].name, entry->label));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_SOURCE;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                               entry->source));

    if (entry->fld_bmp & ME_FLD_BOS_ACTIONS) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_BOS_ACTIONS;
        SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].scalar_to_symbol(unit, entry->bos_actions,
                                        &str_value));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(ent_hdl, flds[fid].name, str_value));
    }

    if (entry->fld_bmp & ME_FLD_NON_BOS_ACTIONS) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_NON_BOS_ACTIONS;
        SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].scalar_to_symbol(unit, entry->non_bos_actions,
                                        &str_value));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(ent_hdl, flds[fid].name,
                                          str_value));
    }

    if ((entry->fld_bmp & ME_FLD_L3_IIF_ID) &&
        (entry->bos_actions == bcmintLtswMplsTnlBosL3Iif)) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_L3_IIF_ID;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->l3_iif_id));
    }

    if ((entry->fld_bmp & ME_FLD_NHOP_ID) &&
        ((entry->bos_actions == bcmintLtswMplsTnlBosSwapNhi) ||
        (entry->bos_actions == bcmintLtswMplsTnlBosL3Nhi) ||
        (entry->non_bos_actions == bcmintLtswMplsTnlNonBosPhpNhi) ||
        (entry->non_bos_actions == bcmintLtswMplsTnlNonBosSwapNhi))) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_NHOP_ID;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->nhop_id));
    }

    if ((entry->fld_bmp & ME_FLD_ECMP_ID) &&
        ((entry->bos_actions == bcmintLtswMplsTnlBosSwapEcmp) ||
        (entry->bos_actions == bcmintLtswMplsTnlBosL3Ecmp) ||
        (entry->non_bos_actions == bcmintLtswMplsTnlNonBosPhpEcmp) ||
        (entry->non_bos_actions == bcmintLtswMplsTnlNonBosSwapEcmp))) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_ECMP_ID;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name, entry->ecmp_id));
    }

    if (entry->fld_bmp & ME_FLD_USE_TTL_FROM_DECAP_HDR) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_USE_TTL_FROM_DECAP_HDR;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl,
                                   flds[fid].name,
                                   entry->use_ttl_from_decap_hdr));
    }

    if (entry->fld_bmp & ME_FLD_KEEP_PAYLOAD_DSCP) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_KEEP_PAYLOAD_DSCP;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->keep_payload_dscp));
    }

    if (entry->fld_bmp & ME_FLD_TNL_EXP_TO_INNER_EXP) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_TNL_EXP_MAP;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->tnl_exp_to_inner_exp));
    }

    if (entry->fld_bmp & ME_FLD_EXP_MAP_ACTION) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_EXP_MAP_ACTION;
        SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].scalar_to_symbol(unit, entry->exp_map_action,
                                        &str_value));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(ent_hdl, flds[fid].name,
                                          str_value));

    }

    if (entry->fld_bmp & ME_FLD_PHB_ING_MPLS_EXP_TO_INT_PRI_ID) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_EXP_TO_INT_PRI_ID;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->phb_ing_mpls_exp_to_int_pri_id));
    }

    if (entry->fld_bmp & ME_FLD_IPV6_PAYLOAD) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_IPV6_PAYLOAD;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->ipv6_payload));
    }

    if (entry->fld_bmp & ME_FLD_IPV4_PAYLOAD) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_IPV4_PAYLOAD;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->ipv4_payload));
    }

    if (entry->fld_bmp & ME_FLD_DROP) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_DROP;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->drop));
    }

    if (entry->fld_bmp & ME_FLD_INT_PRI) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_INT_PRI;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->int_pri));
    }

    if (entry->fld_bmp & ME_FLD_ECN_MPLS_EXP_TO_IP_ECN_ID) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_EXP_TO_IP_ECN_ID;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->ecn_mpls_exp_to_ip_ecn_id));
    }

    if (entry->fld_bmp & ME_FLD_BFD) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_BFD;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->bfd));
    }

    if (entry->fld_bmp & ME_FLD_CTR_ING_EFLEX_OBJECT) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_CTR_EFLEX_OBJECT;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->ctr_ing_eflex_object));
    }

    if (entry->fld_bmp & ME_FLD_CTR_ING_EFLEX_ACTION_ID) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_CTR_EFLEX_ACTION;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, flds[fid].name,
                                   entry->ctr_ing_eflex_action_id));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct entry of the LT TNL_MPLS_DECAP_x from handle.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle.
 * \param [in] lt_db      LT database info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mpls_tnl_decap_entry_from_hdl(
    int unit,
    lt_mpls_tnl_decap_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl,
    const bcmint_mpls_lt_t *lt_db)
{
    const char *bos_actions, *non_bos_actions, *exp_map_action;
    const bcmint_mpls_fld_t *flds;
    int fid;

    SHR_FUNC_ENTER(unit);

    flds = lt_db->flds;

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_LABEL;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name, &entry->label));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_SOURCE;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->source));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_BOS_ACTIONS;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(ent_hdl, flds[fid].name,
                                      &bos_actions));
    SHR_IF_ERR_VERBOSE_EXIT
        (flds[fid].symbol_to_scalar(unit, bos_actions,
                                    &(entry->bos_actions)));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_NON_BOS_ACTIONS;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(ent_hdl, flds[fid].name,
                                      &non_bos_actions));
    SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].symbol_to_scalar(unit, non_bos_actions,
                                        &(entry->non_bos_actions)));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_L3_IIF_ID;
    if (entry->bos_actions == bcmintLtswMplsTnlBosL3Iif) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                                   &entry->l3_iif_id));
    }

    if ((entry->bos_actions == bcmintLtswMplsTnlBosSwapNhi) ||
        (entry->bos_actions == bcmintLtswMplsTnlBosL3Nhi) ||
        (entry->non_bos_actions == bcmintLtswMplsTnlNonBosPhpNhi) ||
        (entry->non_bos_actions == bcmintLtswMplsTnlNonBosSwapNhi)) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_NHOP_ID;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                                   &entry->nhop_id));
    }

    if ((entry->bos_actions == bcmintLtswMplsTnlBosSwapEcmp) ||
        (entry->bos_actions == bcmintLtswMplsTnlBosL3Ecmp) ||
        (entry->non_bos_actions == bcmintLtswMplsTnlNonBosPhpEcmp) ||
        (entry->non_bos_actions == bcmintLtswMplsTnlNonBosSwapEcmp)) {
        fid = BCMINT_LTSW_MPLS_FLD_DECAP_ECMP_ID;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, flds[fid].name, &entry->ecmp_id));
    }

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_USE_TTL_FROM_DECAP_HDR;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl,
                               flds[fid].name,
                               &entry->use_ttl_from_decap_hdr));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_KEEP_PAYLOAD_DSCP;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->keep_payload_dscp));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_TNL_EXP_MAP;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->tnl_exp_to_inner_exp));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_EXP_MAP_ACTION;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(ent_hdl, flds[fid].name,
                                      &exp_map_action));
    SHR_IF_ERR_VERBOSE_EXIT
            (flds[fid].symbol_to_scalar(unit, exp_map_action,
                                        &(entry->exp_map_action)));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_EXP_TO_INT_PRI_ID;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->phb_ing_mpls_exp_to_int_pri_id));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_IPV6_PAYLOAD;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->ipv6_payload));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_IPV4_PAYLOAD;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->ipv4_payload));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_DROP;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->drop));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_INT_PRI;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->int_pri));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_EXP_TO_IP_ECN_ID;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->ecn_mpls_exp_to_ip_ecn_id));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_BFD;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->bfd));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_CTR_EFLEX_OBJECT;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->ctr_ing_eflex_object));

    fid = BCMINT_LTSW_MPLS_FLD_DECAP_CTR_EFLEX_ACTION;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, flds[fid].name,
                               &entry->ctr_ing_eflex_action_id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT TNL_MPLS_DECAP_x.
 *
 * \param [in] unit       Unit number.
 * \param [in] opcode     Operation code.
 * \param [in] ent_hdl    Entry handle.
 * \param [in] entry      Entry info.
 * \param [in] lt_db      LT database info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mpls_tnl_decap_entry_op(
    int unit,
    bcmlt_opcode_t opcode,
    bcmlt_entry_handle_t ent_hdl,
    lt_mpls_tnl_decap_entry_t *entry,
    const bcmint_mpls_lt_t *lt_db)
{
    const char *field_name;
    const bcmint_mpls_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    flds = lt_db->flds;
    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        field_name = flds[BCMINT_LTSW_MPLS_FLD_DECAP_LABEL].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, field_name, entry->label));

        field_name = flds[BCMINT_LTSW_MPLS_FLD_DECAP_SOURCE].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, field_name,
                                   entry->source));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_tnl_decap_entry_from_hdl(unit, entry, ent_hdl, lt_db));
        break;
    case BCMLT_OPCODE_INSERT:
    case BCMLT_OPCODE_UPDATE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_tnl_decap_entry_to_hdl(unit, entry, ent_hdl, lt_db));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        field_name = flds[BCMINT_LTSW_MPLS_FLD_DECAP_LABEL].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, field_name, entry->label));

        field_name = flds[BCMINT_LTSW_MPLS_FLD_DECAP_SOURCE].name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl, field_name,
                                   entry->source));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
}

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert entry to handle for the LT TNL_MPLS_ENCAP.
 *
 * \param [in]  unit          Unit number.
 * \param [in]  entry        Entry info.
 * \param [out] ent_hdl   Entry handle for TNL_MPLS_ENCAP.
 *
 * \retval SHR_E_NONE        No errors.
 * \retval !SHR_E_NONE       Failure.
 */
static int
lt_mpls_tnl_encap_entry_to_hdl(
    int unit,
    lt_mpls_tnl_encap_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    int i;
    int index;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl,
                               TNL_MPLS_ENCAP_IDs, entry->tnl_encap_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, NUM_LABELSs, entry->num_labels));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(ent_hdl, MAX_LABELSs, entry->max_labels));

    if (entry->num_labels) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(ent_hdl, LABELs,
                                         0, entry->label, entry->num_labels));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(ent_hdl, LABEL_TTLs,
                                         0, entry->label_ttl, entry->num_labels));

        for (i = 0; i < entry->num_labels; i++) {
            index = entry->mpls_tnl_exp_mode[i];
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_symbol_add(ent_hdl,
                                                    MPLS_TNL_EXP_MODEs,
                                                    i,
                                                    &mpls_exp_mode_str[index],
                                                    1));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(ent_hdl,
                                         PHB_EGR_MPLS_IDs,
                                         0,
                                         entry->phb_egr_mpls_id,
                                         entry->num_labels));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(ent_hdl,
                                         LABEL_EXPs,
                                         0,
                                         entry->label_exp,
                                         entry->num_labels));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(ent_hdl, PRIs,
                                         0, entry->pri,
                                         entry->num_labels));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(ent_hdl, CFIs,
                                         0, entry->cfi,
                                         entry->num_labels));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(ent_hdl,
                                         ECN_CNG_TO_MPLS_EXP_IDs,
                                         0,
                                         entry->ecn_cng_to_mpls_exp_id,
                                         entry->num_labels));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(ent_hdl,
                                         ECN_CNG_TO_MPLS_EXP_PRIORITYs,
                                         0,
                                         entry->ecn_cng_to_mpls_exp_priority,
                                         entry->num_labels));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(ent_hdl,
                                         ECN_IP_TO_MPLS_EXP_IDs,
                                         0,
                                         entry->ecn_ip_to_mpls_exp_id,
                                         entry->num_labels));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_add(ent_hdl,
                                         ECN_IP_TO_MPLS_EXP_PRIORITYs,
                                         0,
                                         entry->ecn_ip_to_mpls_exp_priority,
                                         entry->num_labels));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct entry of the LT TNL_MPLS_ENCAP from handle.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info.
 * \param [in] ent_hdl    Entry handle for TNL_MPLS_ENCAP.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
static int
lt_mpls_tnl_encap_entry_from_hdl(
    int unit,
    lt_mpls_tnl_encap_entry_t *entry,
    bcmlt_entry_handle_t ent_hdl)
{
    int i;
    uint32_t cnt;
    const char *exp_mode[MPLS_ENCAP_LABEL_CNT_MAX];

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl,
                               TNL_MPLS_ENCAP_IDs, &entry->tnl_encap_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, ENCAP_INDEXs, &entry->encap_index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, NUM_LABELSs, &entry->num_labels));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(ent_hdl, MAX_LABELSs, &entry->max_labels));

    if (entry->num_labels) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(ent_hdl, LABELs,
                                         0, entry->label,
                                         entry->num_labels,
                                         &cnt));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(ent_hdl, LABEL_TTLs,
                                         0, entry->label_ttl,
                                         entry->num_labels,
                                         &cnt));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_symbol_get(ent_hdl, MPLS_TNL_EXP_MODEs,
                                                0, exp_mode, entry->num_labels,
                                                &cnt));

        for (i = 0; i < entry->num_labels; i++) {
            if (!sal_strcmp(mpls_exp_mode_str[0], exp_mode[i])) {
                entry->mpls_tnl_exp_mode[i] = BCMINT_LTSW_MPLS_EXP_MODE_FIXED;
            } else if (!sal_strcmp(mpls_exp_mode_str[1], exp_mode[i])) {
                entry->mpls_tnl_exp_mode[i] = BCMINT_LTSW_MPLS_EXP_MODE_MAP;
            } else if (!sal_strcmp(mpls_exp_mode_str[2], exp_mode[i])) {
                entry->mpls_tnl_exp_mode[i] =
                    BCMINT_LTSW_MPLS_EXP_MODE_USE_INNER_LABEL;
            }
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(ent_hdl, PHB_EGR_MPLS_IDs,
                                         0, entry->phb_egr_mpls_id,
                                         entry->num_labels, &cnt));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(ent_hdl, LABEL_EXPs,
                                         0, entry->label_exp,
                                         entry->num_labels, &cnt));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(ent_hdl, PRIs,
                                         0, entry->pri,
                                         entry->num_labels, &cnt));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(ent_hdl, CFIs,
                                         0, entry->cfi,
                                         entry->num_labels, &cnt));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(ent_hdl, ECN_CNG_TO_MPLS_EXP_IDs,
                                         0, entry->ecn_cng_to_mpls_exp_id,
                                         entry->num_labels, &cnt));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(ent_hdl, ECN_CNG_TO_MPLS_EXP_PRIORITYs,
                                         0, entry->ecn_cng_to_mpls_exp_priority,
                                         entry->num_labels, &cnt));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(ent_hdl, ECN_IP_TO_MPLS_EXP_IDs,
                                         0, entry->ecn_ip_to_mpls_exp_id,
                                         entry->num_labels, &cnt));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(ent_hdl, ECN_IP_TO_MPLS_EXP_PRIORITYs,
                                         0, entry->ecn_ip_to_mpls_exp_priority,
                                         entry->num_labels, &cnt));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT TNL_MPLS_DECAP_x.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mpls_tnl_decap_entry_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_mpls_tnl_decap_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    const char *lt_name;
    const bcmint_mpls_lt_t *lt_db;
    bcmint_mpls_lt_id_t lt_id;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    lt_id = entry->is_trunk ?
            BCMINT_LTSW_MPLS_LT_DECAP_TRUNK : BCMINT_LTSW_MPLS_LT_DECAP;

    SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_mpls_lt_get(unit, lt_id, &lt_db));

    lt_name = lt_db->name;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (lt_mpls_tnl_decap_entry_op(unit, opcode, ent_hdl, entry, lt_db));

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
        ent_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Access entry of the LT TNL_MPLS_ENCAP.
 *
 * \param [in] unit       Unit number.
 * \param [in] op_code    Operation code.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mpls_tnl_encap_entry_op(
    int unit,
    bcmlt_opcode_t opcode,
    lt_mpls_tnl_encap_entry_t *entry)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_ENCAPs, &ent_hdl));

    switch (opcode) {
    case BCMLT_OPCODE_LOOKUP:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl,
                                   TNL_MPLS_ENCAP_IDs, entry->tnl_encap_id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_tnl_encap_entry_from_hdl(unit, entry, ent_hdl));

        break;
    case BCMLT_OPCODE_INSERT:
    case BCMLT_OPCODE_UPDATE:
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_tnl_encap_entry_to_hdl(unit, entry, ent_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    case BCMLT_OPCODE_DELETE:
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(ent_hdl,
                                   TNL_MPLS_ENCAP_IDs, entry->tnl_encap_id));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, ent_hdl, opcode,
                                  BCMLT_PRIORITY_NORMAL));
        break;
    default:
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
}
exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
        ent_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate if the label matches with the port group.
 *
 * \param [in] unit          Unit number.
 * \param [in] label         mpls label.
 * \param [in] port_group    port group.
 *
 * \retval SHR_E_NONE       Matched.
 * \retval !SHR_E_CONFIG    Not matched.
 */
static int
mpls_label_range_validate(int unit, int label, int port_group)
{
    int  min_label_0, max_label_0, min_label_1, max_label_1;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_global_label_range_get(unit, 0,
                                              &min_label_0, &max_label_0));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_ltsw_mpls_global_label_range_get(unit, 1,
                                              &min_label_1, &max_label_1));

    if (((label >= min_label_0) && (label <= max_label_0)) ||
        ((label >= min_label_1) && (label <= max_label_1)) ) {
        if (port_group == BCM_GPORT_INVALID) {
            SHR_EXIT();
        } else {
            SHR_ERR_EXIT(SHR_E_CONFIG);
        }
    } else {
        if (port_group == BCM_GPORT_INVALID) {
            SHR_ERR_EXIT(SHR_E_CONFIG);
        } else {
            SHR_EXIT();
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert tunnel switch info to
 * entry of the LT TNL_MPLS_DECAP_x.
 *
 * \param [in] unit                    Unit number.
 * \param [in] info                    Tunnel terminator information.
 * \param [in] entry                   Entry info.
 * \param [in] existing_pw_term_num    Existing pw_term_num.
 *
 * \retval SHR_E_NONE       No errors.
 * \retval !SHR_E_NONE      Failure.
 */
static int
mpls_tnl_switch_info_to_decap_entry(
    int unit,
    bcm_mpls_tunnel_switch_t *info,
    lt_mpls_tnl_decap_entry_t *entry)
{
    bcmi_ltsw_l3_egr_obj_type_t type;
    int idx;
    int nh_ecmp_idx;

    SHR_FUNC_ENTER(unit);

    entry->keep_payload_dscp  = 1;
    entry->fld_bmp = ME_FLD_KEEP_PAYLOAD_DSCP;

    entry->drop = (info->flags & BCM_MPLS_SWITCH_DROP) ? 1 : 0;
    entry->fld_bmp |= ME_FLD_DROP;


    /* POP ACTION. */
    if (BCM_MPLS_SWITCH_ACTION_POP == info->action_if_bos ||
        BCM_MPLS_SWITCH_ACTION_POP == info->action_if_not_bos) {
        /*
         * uniform qos model if either of these two flags set.
         * Only apply to L3 MPLS and BOS
         */
        if (info->flags &
            (BCM_MPLS_SWITCH_OUTER_EXP | BCM_MPLS_SWITCH_OUTER_TTL)) {
            entry->keep_payload_dscp  = 0;
        }

        entry->l3_iif_id = info->ingress_if;
        entry->fld_bmp |= ME_FLD_L3_IIF_ID;

        if (BCM_MPLS_SWITCH_ACTION_POP == info->action_if_not_bos) {
            entry->non_bos_actions = bcmintLtswMplsTnlNonBosPop;
            entry->fld_bmp |= ME_FLD_NON_BOS_ACTIONS;
        }

        if (BCM_MPLS_SWITCH_ACTION_POP == info->action_if_bos) {
            entry->bos_actions = bcmintLtswMplsTnlBosL3Iif;
            entry->fld_bmp |= ME_FLD_BOS_ACTIONS;
        }
    }

    /* PHP ACTION. */
    if (BCM_MPLS_SWITCH_ACTION_PHP == info->action_if_bos ||
        BCM_MPLS_SWITCH_ACTION_PHP == info->action_if_not_bos) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_resolve(unit, info->egress_if, &idx,
                                                &type));

        if (type == BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL) {
            if (BCM_MPLS_SWITCH_ACTION_PHP == info->action_if_bos) {
                entry->ecmp_id = idx;
                entry->fld_bmp |= ME_FLD_ECMP_ID;
                entry->bos_actions = bcmintLtswMplsTnlBosL3Ecmp;
                entry->fld_bmp |= ME_FLD_BOS_ACTIONS;
            }

            if (BCM_MPLS_SWITCH_ACTION_PHP == info->action_if_not_bos) {
                entry->ecmp_id = idx;
                entry->fld_bmp |= ME_FLD_ECMP_ID;
                entry->non_bos_actions = bcmintLtswMplsTnlNonBosPhpEcmp;
                entry->fld_bmp |= ME_FLD_NON_BOS_ACTIONS;
            }
        } else if (type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
            if (BCM_MPLS_SWITCH_ACTION_PHP == info->action_if_bos) {
                entry->nhop_id= idx;
                entry->fld_bmp |= ME_FLD_NHOP_ID;
                entry->bos_actions = bcmintLtswMplsTnlBosL3Nhi;
                entry->fld_bmp |= ME_FLD_BOS_ACTIONS;
            }

            if (BCM_MPLS_SWITCH_ACTION_PHP == info->action_if_not_bos) {
                entry->nhop_id= idx;
                entry->fld_bmp |= ME_FLD_NHOP_ID;
                entry->non_bos_actions = bcmintLtswMplsTnlNonBosPhpNhi;
                entry->fld_bmp |= ME_FLD_NON_BOS_ACTIONS;
            }
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }

       /*
        * uniform qos model if either of these two flags set.
        * Only apply to L3 MPLS and BOS
        */
        if (info->flags &
            (BCM_MPLS_SWITCH_OUTER_EXP | BCM_MPLS_SWITCH_OUTER_TTL)) {
            entry->keep_payload_dscp  = 0;
        }
    }


    /* SWAP ACTION. */
    if (BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_bos ||
        BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_not_bos) {

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_resolve(unit, info->egress_if,
                                                &nh_ecmp_idx, &type));

        if (type == BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL) {
            entry->ecmp_id = nh_ecmp_idx;
            entry->fld_bmp |= ME_FLD_ECMP_ID;
            if (BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_bos) {
                entry->bos_actions = bcmintLtswMplsTnlBosSwapEcmp;
                entry->fld_bmp |= ME_FLD_BOS_ACTIONS;
            }

            if (BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_not_bos) {
                entry->non_bos_actions = bcmintLtswMplsTnlNonBosSwapEcmp;
                entry->fld_bmp |= ME_FLD_NON_BOS_ACTIONS;
            }
        } else if (type == BCMI_LTSW_L3_EGR_OBJ_T_UL) {
            entry->nhop_id = nh_ecmp_idx;
            entry->fld_bmp |= ME_FLD_NHOP_ID;
            if (BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_bos) {
                entry->bos_actions = bcmintLtswMplsTnlBosSwapNhi;
                entry->fld_bmp |= ME_FLD_BOS_ACTIONS;
            }

            if (BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_not_bos) {
                entry->non_bos_actions = bcmintLtswMplsTnlNonBosSwapNhi;
                entry->fld_bmp |= ME_FLD_NON_BOS_ACTIONS;
            }
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    }/* BCM_MPLS_SWITCH_ACTION_SWAP */

    /* INVALID ACTION. */
    if (BCM_MPLS_SWITCH_ACTION_INVALID == info->action_if_bos) {
        entry->bos_actions = bcmintLtswMplsTnlBosActionInvalid;
        entry->fld_bmp |= ME_FLD_BOS_ACTIONS;
    } else if (BCM_MPLS_SWITCH_ACTION_INVALID == info->action_if_not_bos) {
        entry->non_bos_actions = bcmintLtswMplsTnlNonBosActionInvalid;
        entry->fld_bmp |= ME_FLD_NON_BOS_ACTIONS;
    }

    entry->ipv4_payload = 1;
    entry->fld_bmp |= ME_FLD_IPV4_PAYLOAD;

    entry->ipv6_payload = 1;
    entry->fld_bmp |= ME_FLD_IPV6_PAYLOAD;

    if (info->flags & BCM_MPLS_SWITCH_INNER_TTL) {
        if (BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_bos &&
            BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_not_bos) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        entry->use_ttl_from_decap_hdr = 0;
        entry->fld_bmp |= ME_FLD_USE_TTL_FROM_DECAP_HDR;
    } else {
        entry->use_ttl_from_decap_hdr = 1;
        entry->fld_bmp |= ME_FLD_USE_TTL_FROM_DECAP_HDR;
    }

    if (info->flags & BCM_MPLS_SWITCH_INNER_EXP) {
        if (BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_bos &&
            BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_not_bos) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        entry->tnl_exp_to_inner_exp = 0;
        entry->fld_bmp |= ME_FLD_TNL_EXP_TO_INNER_EXP;
    } else {
        /* For SWAP, Do-not PUSH EXP */
        if (BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_bos &&
            BCM_MPLS_SWITCH_ACTION_SWAP == info->action_if_not_bos) {
            entry->tnl_exp_to_inner_exp = 0;
            entry->fld_bmp |= ME_FLD_TNL_EXP_TO_INNER_EXP;
        } else {
            entry->tnl_exp_to_inner_exp = 1;
            entry->fld_bmp |= ME_FLD_TNL_EXP_TO_INNER_EXP;
        }
    }

    if (info->flags & BCM_MPLS_SWITCH_INT_PRI_MAP) {
        bcmi_ltsw_qos_map_type_t type;
        int hw_idx;
        entry->exp_map_action = bcmintLtswMplsExpMapActionMapPriCng;
        entry->fld_bmp |= ME_FLD_EXP_MAP_ACTION;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_resolve(unit, info->exp_map,
                                          &type, &hw_idx));
        if (type != bcmiQosMapTypeMplsIngress) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        entry->phb_ing_mpls_exp_to_int_pri_id = hw_idx;
        entry->fld_bmp |= ME_FLD_PHB_ING_MPLS_EXP_TO_INT_PRI_ID;
    } else if ((info->flags & BCM_MPLS_SWITCH_INT_PRI_SET) &&
               (info->flags & BCM_MPLS_SWITCH_COLOR_MAP)) {
        bcmi_ltsw_qos_map_type_t type;
        int hw_idx;
        entry->exp_map_action = bcmintLtswMplsExpMapActionFixedPriMapCng;
        entry->fld_bmp |= ME_FLD_EXP_MAP_ACTION;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_qos_map_id_resolve(unit, info->exp_map,
                                          &type, &hw_idx));
        if (type != bcmiQosMapTypeMplsIngress) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        entry->phb_ing_mpls_exp_to_int_pri_id = hw_idx;
        entry->fld_bmp |= ME_FLD_PHB_ING_MPLS_EXP_TO_INT_PRI_ID;

        entry->int_pri = info->int_pri;
        entry->fld_bmp |= ME_FLD_INT_PRI;
    } else if (info->flags & BCM_MPLS_SWITCH_INT_PRI_SET) {
        entry->exp_map_action = bcmintLtswMplsExpMapActionFixedPriMapCng;
        entry->fld_bmp |= ME_FLD_EXP_MAP_ACTION;

        entry->int_pri = info->int_pri;
        entry->fld_bmp |= ME_FLD_INT_PRI;
    } else {
        /*
         * Trust the encapsulated packet's 802.1p pri/cfi,
         * and use the incoming ports mapping.
         */
        entry->exp_map_action = bcmintLtswMplsExpMapActionNone;
        entry->fld_bmp |= ME_FLD_EXP_MAP_ACTION;
    }

    if (info->flags & BCM_MPLS_SWITCH_INGRESS_ECN_MAP) {
        int ecn_map_type;
        int prof_id;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_ecn_map_id_resolve(unit, info->ecn_map_id,
                                          &ecn_map_type,
                                          (uint32_t *)&prof_id));

        if (ecn_map_type != BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
        entry->ecn_mpls_exp_to_ip_ecn_id = prof_id;
        entry->fld_bmp |= ME_FLD_ECN_MPLS_EXP_TO_IP_ECN_ID;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct tunnel switch info from
 * entry of the LT TNL_MPLS_DECAP_x.
 *
 * \param [in] unit       Unit number.
 * \param [in] info       Tunnel terminator information.
 * \param [in] entry      Entry info.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
mpls_tnl_switch_info_from_decap_entry(
    int unit,
    bcm_mpls_tunnel_switch_t *info,
    lt_mpls_tnl_decap_entry_t *entry)
{
    bcmi_ltsw_l3_egr_obj_type_t type;
    int action_if_bos, action_if_not_bos;
    int nh_idx = -1;
    int rv;
    int ecn_map_id;

    SHR_FUNC_ENTER(unit);

    action_if_bos = entry->bos_actions;
    action_if_not_bos = entry->non_bos_actions;

    if (action_if_bos == bcmintLtswMplsTnlBosL3Iif ||
        action_if_not_bos == bcmintLtswMplsTnlNonBosPop) {
        info->ingress_if = entry->l3_iif_id;
    }

    if (action_if_bos == bcmintLtswMplsTnlBosSwapNhi ||
        action_if_not_bos == bcmintLtswMplsTnlNonBosSwapNhi) {
        type = BCMI_LTSW_L3_EGR_OBJ_T_UL;
        nh_idx = entry->nhop_id;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_construct(unit, nh_idx, type,
                                                  &info->egress_if));
    }

    if (action_if_bos == bcmintLtswMplsTnlBosL3Nhi ||
        action_if_not_bos == bcmintLtswMplsTnlNonBosPhpNhi) {
        info->action = BCM_MPLS_SWITCH_ACTION_PHP;
        nh_idx = entry->nhop_id;
        type = BCMI_LTSW_L3_EGR_OBJ_T_UL;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_construct(unit, nh_idx, type,
                                                  &info->egress_if));
    }

    if (action_if_bos == bcmintLtswMplsTnlBosL3Ecmp ||
        action_if_not_bos == bcmintLtswMplsTnlNonBosPhpEcmp ||
        action_if_bos == bcmintLtswMplsTnlBosSwapEcmp ||
        action_if_not_bos == bcmintLtswMplsTnlNonBosSwapEcmp) {
        info->action = BCM_MPLS_SWITCH_ACTION_SWAP;
        nh_idx = entry->ecmp_id;
        type = BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_obj_id_construct(unit, nh_idx, type,
                                                  &info->egress_if));
    }

     switch(action_if_bos) {
         case bcmintLtswMplsTnlBosL3Iif:
             info->action_if_bos = BCM_MPLS_SWITCH_ACTION_POP;
             break;
         case bcmintLtswMplsTnlBosSwapNhi:
         case bcmintLtswMplsTnlBosSwapEcmp:
             info->action_if_bos = BCM_MPLS_SWITCH_ACTION_SWAP;
             break;
         case bcmintLtswMplsTnlBosL3Nhi:
         case bcmintLtswMplsTnlBosL3Ecmp:
             info->action_if_bos = BCM_MPLS_SWITCH_ACTION_PHP;
             break;
         case bcmintLtswMplsTnlBosActionInvalid:
             info->action_if_bos = BCM_MPLS_SWITCH_ACTION_INVALID;
             break;
         default:
             return BCM_E_INTERNAL;
             break;
     }

    switch(action_if_not_bos) {
         case bcmintLtswMplsTnlNonBosPop:
             info->action_if_not_bos = BCM_MPLS_SWITCH_ACTION_POP;
             break;
         case bcmintLtswMplsTnlNonBosSwapNhi:
         case bcmintLtswMplsTnlNonBosSwapEcmp:
             info->action_if_not_bos = BCM_MPLS_SWITCH_ACTION_SWAP;
             break;
         case bcmintLtswMplsTnlNonBosPhpNhi:
         case bcmintLtswMplsTnlNonBosPhpEcmp:
             info->action_if_not_bos = BCM_MPLS_SWITCH_ACTION_PHP;
             break;
         case bcmintLtswMplsTnlNonBosActionInvalid:
             info->action_if_not_bos = BCM_MPLS_SWITCH_ACTION_INVALID;
             break;
         default:
             return BCM_E_INTERNAL;
             break;
     }

     if (info->action_if_bos == info->action_if_not_bos) {
         info->action = info->action_if_bos;
         if (info->action == BCM_MPLS_SWITCH_ACTION_INVALID) {
             /*
              * Both actions are invalid in the HW entry
              * Error out.
              */
             SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
         }
     } else {
         info->action = BCM_MPLS_SWITCH_ACTION_INVALID;
     }

    if (!entry->use_ttl_from_decap_hdr) {
        info->flags |= BCM_MPLS_SWITCH_INNER_TTL;
    }
    if (entry->tnl_exp_to_inner_exp) {
        if ((info->action_if_bos == BCM_MPLS_SWITCH_ACTION_PHP) ||
            (info->action_if_bos == BCM_MPLS_SWITCH_ACTION_POP) ||
            (info->action_if_not_bos == BCM_MPLS_SWITCH_ACTION_PHP) ||
            (info->action_if_not_bos == BCM_MPLS_SWITCH_ACTION_POP)) {
            info->flags |= BCM_MPLS_SWITCH_INNER_EXP;
        }
    }
    if (entry->exp_map_action ==
        bcmintLtswMplsExpMapActionMapPriCng) {
        /* Use specified EXP-map to determine internal prio/color */
        info->flags |= BCM_MPLS_SWITCH_INT_PRI_MAP;
        bcmi_ltsw_qos_map_id_construct(unit,
                                       entry->phb_ing_mpls_exp_to_int_pri_id,
                                       bcmiQosMapTypeMplsIngress,
                                       &info->exp_map);
    } else if (entry->exp_map_action ==
               bcmintLtswMplsExpMapActionFixedPriMapCng) {

        /* Use the specified internal priority value */
        info->flags |= BCM_MPLS_SWITCH_INT_PRI_SET;
        info->int_pri = entry->int_pri;

        /* Use specified EXP-map to determine internal color */
        info->flags |= BCM_MPLS_SWITCH_COLOR_MAP;
        bcmi_ltsw_qos_map_id_construct(unit,
                                       entry->phb_ing_mpls_exp_to_int_pri_id,
                                       bcmiQosMapTypeMplsIngress,
                                       &info->exp_map);
    }

    if (!entry->keep_payload_dscp) {
        if ((info->action_if_bos == BCM_MPLS_SWITCH_ACTION_PHP) ||
            (info->action_if_bos == BCM_MPLS_SWITCH_ACTION_POP) ||
            (info->action_if_not_bos == BCM_MPLS_SWITCH_ACTION_PHP) ||
            (info->action_if_not_bos == BCM_MPLS_SWITCH_ACTION_POP)) {
                 info->flags |=
                     (BCM_MPLS_SWITCH_OUTER_EXP | BCM_MPLS_SWITCH_OUTER_TTL);
        }
    }

    rv = bcmi_ltsw_ecn_map_id_construct(unit,
                                        BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN,
                                        entry->ecn_mpls_exp_to_ip_ecn_id,
                                        &ecn_map_id);

    if (SHR_SUCCESS(rv)) {
        info->flags |= BCM_MPLS_SWITCH_INGRESS_ECN_MAP;
        info->ecn_map_id = ecn_map_id;
    }

    if (entry->drop) {
        info->flags |= BCM_MPLS_SWITCH_DROP;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Convert tunnel initiator info to
 * entry of the LT TNL_MPLS_ENCAP.
 *
 * \param [in] unit            Unit number.
 * \param [in] num_labels Number of entries in label_array.
 * \param [in] label_array MPLS header information.
 * \param [in] entry           Entry info.
 *
 * \return Nothing.
 */
static int
mpls_tnl_encap_to_lt_entry(
    int unit,
    int num_labels,
    bcm_mpls_egress_label_t *label_array,
    lt_mpls_tnl_encap_entry_t *entry)
{
    int idx = 0;
    int ecn_map_type;
    uint32_t prof_id;
    uint32_t mpls_flags;
    bcmi_ltsw_qos_map_type_t qos_type;
    int map_id;

    SHR_FUNC_ENTER(unit);

    entry->num_labels = num_labels;
    entry->max_labels = MPLS_ENCAP_LABEL_CNT_MAX;

    for (idx = 0; idx < num_labels; idx++) {
        mpls_flags = label_array[idx].flags;
        entry->label[idx] = label_array[idx].label;
        if (mpls_flags & BCM_MPLS_EGRESS_LABEL_TTL_SET) {
            entry->label_ttl[idx] = label_array[idx].ttl;
        } else {
            entry->label_ttl[idx] = 0;
        }
        if (mpls_flags & BCM_MPLS_EGRESS_LABEL_EXP_SET ||
            mpls_flags & BCM_MPLS_EGRESS_LABEL_PRI_SET) {
            /* Use the specified EXP, PRI and CFI */
            if ((mpls_flags & BCM_MPLS_EGRESS_LABEL_EXP_REMARK) ||
                (mpls_flags & BCM_MPLS_EGRESS_LABEL_EXP_COPY) ||
                (mpls_flags & BCM_MPLS_EGRESS_LABEL_PRI_REMARK)) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            entry->mpls_tnl_exp_mode[idx] = BCMINT_LTSW_MPLS_EXP_MODE_FIXED;
            entry->label_exp[idx] = label_array[idx].exp;
            entry->pri[idx] = label_array[idx].pkt_pri;
            entry->cfi[idx] = label_array[idx].pkt_cfi;
        } else if (mpls_flags & BCM_MPLS_EGRESS_LABEL_EXP_REMARK) {
            if (mpls_flags & BCM_MPLS_EGRESS_LABEL_PRI_SET) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            entry->mpls_tnl_exp_mode[idx] = BCMINT_LTSW_MPLS_EXP_MODE_MAP;
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_resolve(unit,
                                              label_array[idx].qos_map_id,
                                              &qos_type,
                                              &map_id));
            if (bcmiQosMapTypeMplsEgress != qos_type) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            entry->phb_egr_mpls_id[idx] = map_id;
        } else {
            entry->mpls_tnl_exp_mode[idx] =
                BCMINT_LTSW_MPLS_EXP_MODE_USE_INNER_LABEL;
            if (label_array[idx].qos_map_id) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_qos_map_id_resolve(unit,
                                                  label_array[idx].qos_map_id,
                                                  &qos_type,
                                                  &map_id));

                if (bcmiQosMapTypeL2Egress != qos_type) {
                    SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
                }
                entry->phb_egr_mpls_id[idx] = map_id;
            } else {
                entry->phb_egr_mpls_id[idx] = 0;
            }

            entry->label_exp[idx] = label_array[idx].exp;
        }

        if (mpls_flags & BCM_MPLS_EGRESS_LABEL_INT_CN_TO_EXP_MAP) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_ecn_map_id_resolve(unit,
                                              label_array[idx].int_cn_map_id,
                                              &ecn_map_type,
                                              &prof_id));

            if (ecn_map_type != BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_INTCN2EXP) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }

            entry->ecn_cng_to_mpls_exp_id[idx] = prof_id;

            if (mpls_flags & BCM_MPLS_EGRESS_LABEL_ECN_EXP_MAP_TRUST) {
                entry->ecn_cng_to_mpls_exp_priority[idx] = 1;
            } else {
                entry->ecn_cng_to_mpls_exp_priority[idx] = 0;
            }
        }

        if (mpls_flags & BCM_MPLS_EGRESS_LABEL_ECN_TO_EXP_MAP) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_ecn_map_id_resolve(unit,
                                              label_array[idx].ecn_map_id,
                                              &ecn_map_type, &prof_id));
            if (ecn_map_type != BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_ECN2EXP) {
                SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
            }
            entry->ecn_ip_to_mpls_exp_id[idx] = prof_id;

            if (mpls_flags & BCM_MPLS_EGRESS_LABEL_ECN_EXP_MAP_TRUST) {
                entry->ecn_ip_to_mpls_exp_priority[idx] = 1;
            } else {
                entry->ecn_ip_to_mpls_exp_priority[idx] = 0;
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Construct tunnel initiator info from
 * entry of the LT TNL_MPLS_ENCAP.
 *
 * \param [in] unit               Unit number.
 * \param [out] num_labels Number of entries in label_array.
 * \param [out] label_array MPLS header information.
 * \param [in] entry             Entry info.
 *
 * \return Nothing.
 */
static int
mpls_tnl_encap_from_lt_entry(
    int unit,
    int *num_labels,
    bcm_mpls_egress_label_t *label_array,
    lt_mpls_tnl_encap_entry_t *entry)
{
    int idx = 0;
    int exp_mode = 0;
    int map_id = 0;
    int ecn_map_type;
    int ecn_map_index;
    int ecn_map_priority;
    int rv;

    SHR_FUNC_ENTER(unit);

    *num_labels = (int)(entry->num_labels);

    for (idx = 0; idx < entry->num_labels; idx++) {
        label_array[idx].label = entry->label[idx];
        if (entry->label_ttl[idx]) {
            label_array[idx].ttl = entry->label_ttl[idx];
            label_array[idx].flags |= BCM_MPLS_EGRESS_LABEL_TTL_SET;
        } else {
            label_array[idx].ttl = 0;
        }
        exp_mode = (int)(entry->mpls_tnl_exp_mode[idx]);
        if (exp_mode == BCMINT_LTSW_MPLS_EXP_MODE_FIXED) {
            label_array[idx].flags |= BCM_MPLS_EGRESS_LABEL_EXP_SET;
            label_array[idx].flags |= BCM_MPLS_EGRESS_LABEL_PRI_SET;
            label_array[idx].exp = entry->label_exp[idx];
            label_array[idx].pkt_pri = entry->pri[idx];
            label_array[idx].pkt_cfi = entry->cfi[idx];
        } else if (exp_mode == BCMINT_LTSW_MPLS_EXP_MODE_MAP) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_qos_map_id_construct(unit,
                                                entry->phb_egr_mpls_id[idx],
                                                bcmiQosMapTypeMplsEgress,
                                                &map_id));
            label_array[idx].qos_map_id = map_id;
            label_array[idx].flags |= BCM_MPLS_EGRESS_LABEL_EXP_REMARK;
            label_array[idx].flags |= BCM_MPLS_EGRESS_LABEL_PRI_REMARK;
        } else if (exp_mode == BCMINT_LTSW_MPLS_EXP_MODE_USE_INNER_LABEL){
            if (entry->phb_egr_mpls_id[idx]) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmi_ltsw_qos_map_id_construct(unit,
                                                    entry->phb_egr_mpls_id[idx],
                                                    bcmiQosMapTypeL2Egress,
                                                    &map_id));
                label_array[idx].qos_map_id = map_id;
            } else {
                label_array[idx].qos_map_id = 0;
            }
            label_array[idx].exp = entry->label_exp[idx];
            label_array[idx].flags |= BCM_MPLS_EGRESS_LABEL_EXP_COPY;
            label_array[idx].flags |= BCM_MPLS_EGRESS_LABEL_PRI_REMARK;
        }

        ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_INTCN2EXP;
        ecn_map_index = (int)(entry->ecn_cng_to_mpls_exp_id[idx]);
        ecn_map_priority = (int)(entry->ecn_cng_to_mpls_exp_priority[idx]);
        rv = bcmi_ltsw_ecn_map_id_construct(unit,
                                            ecn_map_type,
                                            ecn_map_index,
                                            &map_id);
        if (SHR_SUCCESS(rv)) {
            label_array[idx].ecn_map_id = map_id;
            label_array[idx].flags |=
                BCM_MPLS_EGRESS_LABEL_INT_CN_TO_EXP_MAP;
            label_array[idx].flags |=
                ecn_map_priority ?
                BCM_MPLS_EGRESS_LABEL_ECN_EXP_MAP_TRUST : 0;
        }

        ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_ECN2EXP;
        ecn_map_index = (int)(entry->ecn_ip_to_mpls_exp_id[idx]);
        ecn_map_priority = (int)(entry->ecn_cng_to_mpls_exp_priority[idx]);
        rv = bcmi_ltsw_ecn_map_id_construct(unit,
                                            ecn_map_type,
                                            ecn_map_index,
                                            &map_id);
        if (SHR_SUCCESS(rv)) {
            label_array[idx].ecn_map_id = map_id;

            label_array[idx].flags |=
                BCM_MPLS_EGRESS_LABEL_ECN_TO_EXP_MAP;
            label_array[idx].flags |=
                ecn_map_priority ?
                BCM_MPLS_EGRESS_LABEL_ECN_EXP_MAP_TRUST : 0;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Calculate hash of TNL_MPLS_ENCAP entry.
 *
 * \param [in] unit       Unit number.
 * \param [in] entry      Entry info of bcm_mpls_tunnel_encap_t type.
 * \param [out] hash      Hash value.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mpls_tnl_encap_hash(int unit, void *entry, uint16_t *hash)
{
    *hash = shr_crc16(0, (uint8*)entry, sizeof(lt_mpls_tnl_encap_entry_t));
    return SHR_E_NONE;
}

/*!
 * \brief Compare TNL_MPLS_ENCAP entries.
 *
 * \param [in] unit       Unit number.
 * \param [in] index      Index of entry to be compared.
 * \param [in] entry      Entry content of bcm_mpls_tunnel_encap_t type.
 * \param [out] result    Compare result. 0 if equal, 1 not equal.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mpls_tnl_encap_cmp(int unit, int index, void *entry, int *result)
{
    lt_mpls_tnl_encap_entry_t dst_entry;
    lt_mpls_tnl_encap_entry_t *src_entry;
    int num_labels;

    SHR_FUNC_ENTER(unit);

    src_entry = (lt_mpls_tnl_encap_entry_t *)entry;

    sal_memset(&dst_entry, 0, sizeof(dst_entry));
    dst_entry.tnl_encap_id = index;
    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_encap_entry_op(unit, BCMLT_OPCODE_LOOKUP, &dst_entry));

    *result = 1;

    if (src_entry->num_labels != dst_entry.num_labels) {
        SHR_EXIT();
    }

    if (src_entry->max_labels != dst_entry.max_labels) {
        SHR_EXIT();
    }

    for (num_labels = 0; num_labels < MPLS_ENCAP_LABEL_CNT_MAX; num_labels++) {
        if (src_entry->label[num_labels] == dst_entry.label[num_labels]) {
            SHR_EXIT();
        }
        if (src_entry->label_ttl[num_labels] == dst_entry.label_ttl[num_labels]) {
            SHR_EXIT();
        }
        if (src_entry->mpls_tnl_exp_mode[num_labels] ==
            dst_entry.mpls_tnl_exp_mode[num_labels]) {
            SHR_EXIT();
        }
        if (src_entry->phb_egr_mpls_id[num_labels] ==
            dst_entry.phb_egr_mpls_id[num_labels]) {
            SHR_EXIT();
        }
        if (src_entry->label_exp[num_labels] ==
            dst_entry.label_exp[num_labels]) {
            SHR_EXIT();
        }
        if (src_entry->pri[num_labels] ==
            dst_entry.pri[num_labels]) {
            SHR_EXIT();
        }
        if (src_entry->cfi[num_labels] ==
            dst_entry.cfi[num_labels]) {
            SHR_EXIT();
        }
        if (src_entry->ecn_cng_to_mpls_exp_id[num_labels] ==
            dst_entry.ecn_cng_to_mpls_exp_id[num_labels]) {
            SHR_EXIT();
        }
        if (src_entry->ecn_cng_to_mpls_exp_priority[num_labels] ==
            dst_entry.ecn_cng_to_mpls_exp_priority[num_labels]) {
            SHR_EXIT();
        }
        if (src_entry->ecn_ip_to_mpls_exp_id[num_labels] ==
            dst_entry.ecn_ip_to_mpls_exp_id[num_labels]) {
            SHR_EXIT();
        }
        if (src_entry->ecn_ip_to_mpls_exp_priority[num_labels] ==
            dst_entry.ecn_ip_to_mpls_exp_priority[num_labels]) {
            SHR_EXIT();
        }
    }

    *result = 0;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert TNL_MPLS_ENCAP entry.
 *
 * \param [in] unit       Unit number.
 * \param [in] flags      Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index      Index of entry to be inserted.
 * \param [in] entry      Entry content of bcm_mpls_tunnel_encap_t type.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mpls_tnl_encap_insert(int unit, uint32_t flags, int index, void *entry)
{
    lt_mpls_tnl_encap_entry_t *tnl_entry;
    bcmlt_opcode_t opcode = BCMLT_OPCODE_INSERT;

    SHR_FUNC_ENTER(unit);

    sal_memset(&tnl_entry, 0, sizeof(tnl_entry));
    tnl_entry = (lt_mpls_tnl_encap_entry_t *)entry;
    tnl_entry->tnl_encap_id = index;

    if (flags & BCMI_LTSW_IDX_TBL_OP_REPLACE) {
        opcode = BCMLT_OPCODE_UPDATE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_encap_entry_op(unit, opcode, tnl_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete TNL_MPLS_ENCAP entry.
 *
 * \param [in] unit       Unit number.
 * \param [in] index      Index of entry to be deleted.
 *
 * \retval SHR_E_NONE     No errors.
 * \retval !SHR_E_NONE    Failure.
 */
static int
lt_mpls_tnl_encap_delete(int unit, int index)
{
    lt_mpls_tnl_encap_entry_t tnl_entry;

    SHR_FUNC_ENTER(unit);

    sal_memset(&tnl_entry, 0, sizeof(tnl_entry));
    tnl_entry.tnl_encap_id = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_encap_entry_op(unit, BCMLT_OPCODE_DELETE, &tnl_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover MPLS database from LTs.
 *
 * \param [in] unit Unit number
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mpls_recover_cb(int unit, const char *lt_name, bcmlt_entry_handle_t eh,
                void *cookie)
{
    lt_mpls_tnl_encap_entry_t entry;
    bcmi_ltsw_idx_tbl_id_t tbl_id;
    uint8_t user_id;
    uint32_t ent_idx;
    uint32_t ref_cnt;

    SHR_FUNC_ENTER(unit);

    sal_memset(&entry, 0, sizeof(lt_mpls_tnl_encap_entry_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (lt_mpls_tnl_encap_entry_from_hdl(unit, &entry, eh));
    /* Save encap_id. */
    MPLS_TNL_ENCAP_ID(unit, entry.encap_index) = entry.tnl_encap_id;
    tbl_id  = BCMI_LTSW_IDX_TBL_ID_TNL_MPLS_ENCAP;
    user_id = BCMI_TNL_MPLS_ENCAP_USER_ID_MPLS;
    ent_idx = (uint32_t)entry.tnl_encap_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id,
                                         ent_idx, &ref_cnt));
    if (ref_cnt == 0) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_tnl_encap_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_hash_update(unit, tbl_id, user_id,
                                                 &entry, ent_idx));
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_increase(unit, tbl_id, user_id,
                                              ent_idx));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve a TNL_MPLS_DST_MAC profile.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_idx Profile Index.
 * \param [out] prof_entry Profile entry returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
mpls_tnl_dst_mac_profile_entry_get(
    int unit,
    int profile_idx,
    bcmi_ltsw_mpls_tnl_dst_mac_profile_t *prof_entry)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_DST_MACs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TNL_MPLS_DST_MAC_IDs, profile_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh, DST_MACs, &data));
    prof_entry->mac_da = data;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Set a TNL_MPLS_DST_MAC profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_idx Profile Index.
 * \param [out] prof_entry Profile entry returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
mpls_tnl_dst_mac_profile_entry_set(
    int unit,
    int profile_idx,
    bcmi_ltsw_mpls_tnl_dst_mac_profile_t *prof_entry)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    value = (uint64_t)profile_idx;
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_DST_MACs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TNL_MPLS_DST_MAC_IDs, value));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, DST_MACs, prof_entry->mac_da));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete a TNL_MPLS_DST_MAC profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_idx Profile Index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
mpls_tnl_dst_mac_profile_entry_del(
    int unit,
    int profile_idx)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_DST_MACs, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh, TNL_MPLS_DST_MAC_IDs, profile_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Add TNL_MPLS_DST_MAC profile.
 *
 * \param [in] unit Unit number.
 * \param [in] entry TNL_MPLS_DST_MAC entry.
 * \param [out] index Base index of TNL_MPLS_DST_MAC.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
mpls_tnl_dst_mac_profile_add(
    int unit,
    bcmi_ltsw_mpls_tnl_dst_mac_profile_t *entry,
    int *index)
{
    int rv;
    int profile_idx;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    rv = bcmi_ltsw_profile_index_allocate(unit, BCMI_LTSW_PROFILE_MPLS_DST_MAC,
                                          entry, 0, 1, index);
    if (rv == SHR_E_EXISTS) {
        /* the same profile already exists */
        SHR_EXIT();
    }

    if (rv == SHR_E_FULL) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }

    if (SHR_FAILURE(rv)) {
       SHR_ERR_EXIT(rv);
    }

    profile_idx = *index;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_dst_mac_profile_entry_set(unit, profile_idx, entry));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Get entries from LT TNL_MPLS_DST_MAC.
 *
 * This function is used to get entries from LT TNL_MPLS_DST_MAC.
 *
 * \param [in]  unit                 Unit Number.
 * \param [in] index               Profile base index.
 * \param [out] prof_entry      Profile entries.
 *
 * \retval SHR_E_NONE                No errors.
 * \retval !SHR_E_NONE               Failure.
 */
static int
mpls_tnl_dst_mac_profile_get(int unit,
                            int index,
                            bcmi_ltsw_mpls_tnl_dst_mac_profile_t *prof_entry)
{
    int profile_idx;

    SHR_FUNC_ENTER(unit);
    profile_idx = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_dst_mac_profile_entry_get(unit, profile_idx,
                                            prof_entry));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete entries from LT TNL_MPLS_DST_MAC.
 *
 * \param [in] unit Unit number.
 * \param [in] index Base Index of LT TNL_MPLS_DST_MAC.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
mpls_tnl_dst_mac_profile_delete(
    int unit,
    int index)
{
    int rv;
    int profile_idx;

    SHR_FUNC_ENTER(unit);

    profile_idx = index;

    rv = bcmi_ltsw_profile_index_free(unit, BCMI_LTSW_PROFILE_MPLS_DST_MAC,
                                      index);

    if (rv == SHR_E_BUSY) {
        /* profile entry is still inused */
       SHR_EXIT();
    }

    if (rv != SHR_E_NONE) {
        SHR_ERR_EXIT(rv);
    }

    /* empty the profile entry */
    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_dst_mac_profile_entry_del(unit, profile_idx));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Hash callback function for TNL_MPLS_DST_MAC profile.
 *
 * \param [in] unit Unit number.
 * \param [in] entries TNL_MPLS_DST_MAC profile entries.
 * \param [in] entries_per_set      Number of entries in the profile set.
 * \param [out] hash Hash value returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
mpls_tnl_dst_mac_profile_entry_hash_cb(
    int unit,
    void *entries,
    int entries_per_set,
    uint32_t *hash)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    if (entries_per_set != 1) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    *hash = shr_crc32(0, entries,
                      sizeof(bcmi_ltsw_mpls_tnl_dst_mac_profile_t));

exit:
    SHR_FUNC_EXIT();

}

/*!
 * \brief Comparison callback function for TNL_MPLS_DST_MAC profile.
 *
 * \param [in] unit Unit number.
 * \param [in] entries TNL_MPLS_DST_MAC entry.
 * \param [in] entries_per_set      Number of entries in the profile set.
 * \param [in] profile_idx Profile Index of LT entry.
 * \param [out] cmp_result Comparison result.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
mpls_tnl_dst_mac_profile_entry_cmp_cb(
    int unit,
    void *entries,
    int entries_per_set,
    int profile_idx,
    int *cmp_result)
{
    bcmi_ltsw_mpls_tnl_dst_mac_profile_t prof_entry;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(cmp_result, SHR_E_PARAM);

    if (entries_per_set != 1) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    sal_memset(&prof_entry, 0, sizeof(prof_entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_dst_mac_profile_get(unit, profile_idx, &prof_entry));

    *cmp_result = sal_memcmp(entries, &prof_entry, sizeof(prof_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover LT TNL_MPLS_DST_MAC..
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
mpls_tnl_dst_mac_profile_recover(int unit)
{
    uint32_t ref_cnt;
    uint32_t index;
    uint64_t idx_min, idx_max;
    int dunit;
    bcmi_ltsw_mpls_tnl_dst_mac_profile_t profile_entry = {0};
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_MPLS_DST_MAC;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int rv;
    uint64_t id;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_MPLS_DST_MACs,
                                       TNL_MPLS_DST_MAC_IDs,
                                       &idx_min, &idx_max));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_DST_MACs, &ent_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, ent_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl, TNL_MPLS_DST_MAC_IDs, &id));
        index = (uint32_t)id;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_get(unit, profile_hdl,
                                             index, &ref_cnt));
        if (ref_cnt == 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mpls_tnl_dst_mac_profile_get(unit, index, &profile_entry));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_profile_hash_update(unit, profile_hdl, &profile_entry,
                                               1, index));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit, profile_hdl,
                                                  1, index, 1));
    }

exit:
    if (ent_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(ent_hdl);
        ent_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear the information of TNL_MPLS_DST_MAC .
 *
 * This function is used to clear the information of TNL_MPLS_DST_MAC.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mpls_tnl_dst_mac_profile_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_MPLS_DST_MACs));
    }
exit:
    SHR_FUNC_EXIT();
}


/*
 * \brief Deinit LT TNL_MPLS_DST_MAC information.
 *
 * This function is used to deinit LT TNL_MPLS_DST_MAC information.
 *
 * \param [in]  unit                 Unit Number.
 *
 * \retval SHR_E_NONE                No errors.
 * \retval !SHR_E_NONE               Failure.
 */
static int
mpls_tnl_dst_mac_profile_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_dst_mac_profile_clear(unit));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve a TNL_MPLS_CTR_ING_EFLEX_ACTION profile.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_idx Profile Index.
 * \param [out] prof_entry Profile entry returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
mpls_label_flex_action_profile_entry_get(
    int unit,
    int profile_idx,
    mpls_label_flex_action_profile_t *prof_entry)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;
    const bcmint_mpls_lt_t *lt_db;
    const bcmint_mpls_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit,
                            BCMINT_LTSW_MPLS_LT_EFLEX_ACTION,
                            &lt_db));
    flds = lt_db->flds;

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_db->name, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh,
                               flds[BCMINT_LTSW_MPLS_FLD_EFA_ID].name,
                               profile_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(eh,
                               flds[BCMINT_LTSW_MPLS_FLD_EFA_ACTION].name,
                               &data));
    prof_entry->action = (uint32_t)data;

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Set a TNL_MPLS_CTR_ING_EFLEX_ACTION profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_idx Profile Index.
 * \param [out] prof_entry Profile entry returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
mpls_label_flex_action_profile_entry_set(
    int unit,
    int profile_idx,
    mpls_label_flex_action_profile_t *prof_entry)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    const bcmint_mpls_lt_t *lt_db;
    const bcmint_mpls_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(prof_entry, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit,
                            BCMINT_LTSW_MPLS_LT_EFLEX_ACTION,
                            &lt_db));
    flds = lt_db->flds;

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_db->name, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh,
                               flds[BCMINT_LTSW_MPLS_FLD_EFA_ID].name,
                               profile_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh,
                               flds[BCMINT_LTSW_MPLS_FLD_EFA_ACTION].name,
                               (uint64_t)prof_entry->action));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, eh, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete a TNL_MPLS_CTR_ING_EFLEX_ACTION profile entry.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_idx Profile Index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
mpls_label_flex_action_profile_entry_del(
    int unit,
    int profile_idx)
{
    bcmlt_entry_handle_t eh = BCMLT_INVALID_HDL;
    int dunit;
    const bcmint_mpls_lt_t *lt_db;
    const bcmint_mpls_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit,
                            BCMINT_LTSW_MPLS_LT_EFLEX_ACTION,
                            &lt_db));
    flds = lt_db->flds;

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_db->name, &eh));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(eh,
                               flds[BCMINT_LTSW_MPLS_FLD_EFA_ID].name,
                               profile_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, eh,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (eh != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(eh);
        eh = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Add TNL_MPLS_CTR_ING_EFLEX_ACTION profile.
 *
 * \param [in] unit Unit number.
 * \param [in] entry TNL_MPLS_CTR_ING_EFLEX_ACTION entry.
 * \param [out] index Base index of TNL_MPLS_CTR_ING_EFLEX_ACTION.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
mpls_label_flex_action_profile_add(
    int unit,
    mpls_label_flex_action_profile_t *entry,
    int *index)
{
    int rv;
    int profile_idx;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entry, SHR_E_PARAM);
    SHR_NULL_CHECK(index, SHR_E_PARAM);

    rv = bcmi_ltsw_profile_index_allocate(unit, BCMI_LTSW_PROFILE_MPLS_FLEX_ACTION,
                                          entry, 0, 1, index);
    if (rv == SHR_E_EXISTS) {
        /* the same profile already exists */
        SHR_EXIT();
    }

    if (rv == SHR_E_FULL) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }

    if (SHR_FAILURE(rv)) {
       SHR_ERR_EXIT(rv);
    }

    profile_idx = *index;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_flex_action_profile_entry_set(unit, profile_idx, entry));

exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Get entries from LT TNL_MPLS_CTR_ING_EFLEX_ACTION.
 *
 * This function is used to get entries from LT TNL_MPLS_CTR_ING_EFLEX_ACTION.
 *
 * \param [in]  unit                 Unit Number.
 * \param [in] index               Profile base index.
 * \param [out] prof_entry      Profile entries.
 *
 * \retval SHR_E_NONE                No errors.
 * \retval !SHR_E_NONE               Failure.
 */
static int
mpls_label_flex_action_profile_get(int unit,
                            int index,
                            mpls_label_flex_action_profile_t *prof_entry)
{
    int profile_idx;

    SHR_FUNC_ENTER(unit);
    profile_idx = index;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_flex_action_profile_entry_get(unit, profile_idx,
                                            prof_entry));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete entries from LT TNL_MPLS_CTR_ING_EFLEX_ACTION.
 *
 * \param [in] unit Unit number.
 * \param [in] index Base Index of LT TNL_MPLS_CTR_ING_EFLEX_ACTION.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
mpls_label_flex_action_profile_delete(
    int unit,
    int index)
{
    int rv;
    int profile_idx;

    SHR_FUNC_ENTER(unit);

    profile_idx = index;

    rv = bcmi_ltsw_profile_index_free(unit, BCMI_LTSW_PROFILE_MPLS_FLEX_ACTION,
                                      index);

    if (rv == SHR_E_BUSY) {
        /* profile entry is still inused */
       SHR_EXIT();
    }

    if (rv != SHR_E_NONE) {
        SHR_ERR_EXIT(rv);
    }

    /* empty the profile entry */
    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_flex_action_profile_entry_del(unit, profile_idx));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Hash callback function for TNL_MPLS_CTR_ING_EFLEX_ACTION profile.
 *
 * \param [in] unit Unit number.
 * \param [in] entries TNL_MPLS_CTR_ING_EFLEX_ACTION profile entries.
 * \param [in] entries_per_set      Number of entries in the profile set.
 * \param [out] hash Hash value returned.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
mpls_label_flex_action_profile_entry_hash_cb(
    int unit,
    void *entries,
    int entries_per_set,
    uint32_t *hash)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(hash, SHR_E_PARAM);

    if (entries_per_set != 1) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    *hash = shr_crc32(0, entries,
                      sizeof(mpls_label_flex_action_profile_t));

exit:
    SHR_FUNC_EXIT();

}

/*!
 * \brief Comparison callback function for TNL_MPLS_CTR_ING_EFLEX_ACTION profile.
 *
 * \param [in] unit Unit number.
 * \param [in] entries TNL_MPLS_CTR_ING_EFLEX_ACTION entry.
 * \param [in] entries_per_set      Number of entries in the profile set.
 * \param [in] profile_idx Profile Index of LT entry.
 * \param [out] cmp_result Comparison result.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
mpls_label_flex_action_profile_entry_cmp_cb(
    int unit,
    void *entries,
    int entries_per_set,
    int profile_idx,
    int *cmp_result)
{
    mpls_label_flex_action_profile_t prof_entry;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(entries, SHR_E_PARAM);
    SHR_NULL_CHECK(cmp_result, SHR_E_PARAM);

    if (entries_per_set != 1) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    sal_memset(&prof_entry, 0, sizeof(prof_entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_flex_action_profile_get(unit, profile_idx, &prof_entry));

    *cmp_result = sal_memcmp(entries, &prof_entry, sizeof(prof_entry));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover LT TNL_MPLS_CTR_ING_EFLEX_ACTION..
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
mpls_label_flex_action_profile_recover(int unit)
{
    uint32_t ref_cnt;
    uint32_t index;
    uint64_t idx_min, idx_max;
    int dunit;
    mpls_label_flex_action_profile_t profile_entry = {0};
    bcmi_ltsw_profile_hdl_t profile_hdl = BCMI_LTSW_PROFILE_MPLS_FLEX_ACTION;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int rv;
    uint64_t id;
    const bcmint_mpls_lt_t *lt_db;
    const bcmint_mpls_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    if (!ltsw_feature(unit, LTSW_FT_MPLS_FLEXCTR_ACTION_PROFILE)) {
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_mpls_lt_get(unit,
                            BCMINT_LTSW_MPLS_LT_EFLEX_ACTION,
                            &lt_db));
    flds = lt_db->flds;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, lt_db->name,
                                       flds[BCMINT_LTSW_MPLS_FLD_EFA_ID].name,
                                       &idx_min, &idx_max));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_db->name, &ent_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, ent_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(ent_hdl,
                                   flds[BCMINT_LTSW_MPLS_FLD_EFA_ID].name,
                                   &id));
        index = (uint32_t)id;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_get(unit, profile_hdl,
                                             index, &ref_cnt));
        if (ref_cnt == 0) {
            SHR_IF_ERR_VERBOSE_EXIT
                (mpls_label_flex_action_profile_get(unit, index, &profile_entry));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_profile_hash_update(unit, profile_hdl, &profile_entry,
                                               1, index));
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_ref_count_increase(unit, profile_hdl,
                                                  1, index, 1));
    }

exit:
    if (ent_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(ent_hdl);
        ent_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear the information of L3 flex action profile.
 *
 * This function is used to clear the information of L3 flex action profile.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
mpls_label_flex_action_profile_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    if (!ltsw_feature(unit, LTSW_FT_MPLS_FLEXCTR_ACTION_PROFILE)) {
        SHR_EXIT();
    }

    if (!bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, TNL_MPLS_CTR_ING_EFLEX_ACTIONs));
    }
exit:
    SHR_FUNC_EXIT();
}

/*
 * \brief Deinit LT TNL_MPLS_CTR_ING_EFLEX_ACTION information.
 *
 * This function is used to deinit LT TNL_MPLS_CTR_ING_EFLEX_ACTION information.
 *
 * \param [in]  unit                 Unit Number.
 *
 * \retval SHR_E_NONE                No errors.
 * \retval !SHR_E_NONE               Failure.
 */
static int
mpls_label_flex_action_profile_deinit(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_flex_action_profile_clear(unit));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Operate flex counter related fields of MPLS decap entry.
 *
 * \param [in] unit Unit number.
 * \param [in] label MPLS label.
 * \param [in] port MPLS Gport.
 * \param [in/out] flexctr Pointer to flex counter config info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval SHR_E_INTERNAL Failure.
 */
static int
mpls_label_flexctr_op(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t      port,
    mpls_flexctr_cfg_t *flexctr)
{
    bcmlt_opcode_t opcode;
    lt_mpls_tnl_decap_entry_t entry;
    bcm_module_t modid = BCM_MODID_INVALID;
    bcm_port_t local_port = BCM_PORT_INVALID;
    bcm_trunk_t trunk_id = BCM_TRUNK_INVALID;
    int id = -1;
    mpls_label_flex_action_profile_t action_profile;
    int index;

    SHR_FUNC_ENTER(unit);

    sal_memset(&entry, 0, sizeof(lt_mpls_tnl_decap_entry_t));

    if (BCM_GPORT_IS_SET(port)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_resolve(unit, port,
                                          &modid,
                                          &local_port,
                                          &trunk_id,
                                          &id));

        if (trunk_id != BCM_TRUNK_INVALID) {
            entry.is_trunk = true;
            entry.source = trunk_id;
        } else {
            entry.is_trunk = false;
            entry.source = local_port;
        }
    } else if (port == BCM_GPORT_INVALID){
        entry.is_trunk = false;
        entry.source = 0;
    } else if (SHR_SUCCESS(bcmi_ltsw_port_gport_validate(unit, port, &port))) {
        entry.is_trunk = false;
        entry.source = port;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    entry.label = label;

    if (flexctr->op == MPLS_FLXCTR_OP_SET) {
        if (flexctr->flags & MPLS_FLXCTR_F_ACTION) {
            if (ltsw_feature(unit, LTSW_FT_MPLS_FLEXCTR_ACTION_PROFILE)) {
                action_profile.action = flexctr->action;
                if (flexctr->action) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mpls_label_flex_action_profile_add(unit,
                                                            &action_profile,
                                                            &index));
                    entry.ctr_ing_eflex_action_id = index;
                    entry.fld_bmp |= ME_FLD_CTR_ING_EFLEX_ACTION_ID;
                } else {
                    /* Get the old action and delete it. */
                    opcode = BCMLT_OPCODE_LOOKUP;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mpls_tnl_decap_entry_op(unit, opcode, &entry));
                    index = entry.ctr_ing_eflex_action_id;
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mpls_label_flex_action_profile_delete(unit,
                                                               index));
                    entry.ctr_ing_eflex_action_id = 0;
                    entry.fld_bmp |= ME_FLD_CTR_ING_EFLEX_ACTION_ID;
                }
            } else {
                entry.ctr_ing_eflex_action_id = flexctr->action;
                entry.fld_bmp |= ME_FLD_CTR_ING_EFLEX_ACTION_ID;
            }
        }

        if (flexctr->flags & MPLS_FLXCTR_F_INDEX) {
            entry.ctr_ing_eflex_object = flexctr->index;
            entry.fld_bmp |= ME_FLD_CTR_ING_EFLEX_OBJECT;
        }

        opcode = BCMLT_OPCODE_UPDATE;
    } else if (flexctr->op == MPLS_FLXCTR_OP_GET) {
        opcode = BCMLT_OPCODE_LOOKUP;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INTERNAL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
            (mpls_tnl_decap_entry_op(unit, opcode, &entry));

    if (flexctr->op == MPLS_FLXCTR_OP_GET) {
        if (ltsw_feature(unit, LTSW_FT_MPLS_FLEXCTR_ACTION_PROFILE)) {
            if (flexctr->flags & MPLS_FLXCTR_F_ACTION) {
                index = entry.ctr_ing_eflex_action_id;
                if (index) {
                    SHR_IF_ERR_VERBOSE_EXIT
                        (mpls_label_flex_action_profile_get(unit, index, &action_profile));
                    flexctr->action = action_profile.action;
                } else {
                    flexctr->action = BCMI_LTSW_FLEXCTR_ACTION_INVALID;
                }
            }
        } else {
            flexctr->action = entry.ctr_ing_eflex_action_id;
        }
        if (flexctr->flags & MPLS_FLXCTR_F_INDEX) {
            flexctr->index = entry.ctr_ing_eflex_object;
        }
    }

exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_mpls_sw_dump(int unit)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_mpls_init(int unit)
{
    uint64_t idx_max, idx_min;
    bcmi_ltsw_idx_tbl_user_info_t user_info;
    bcmi_ltsw_idx_tbl_lt_info_t lt_info;
    bcmi_ltsw_idx_tbl_id_t tbl_id;
    int tnl_mpls_encap_registered = 0;
    uint8_t user_id;
    mpls_info_t *info = &mpls_info[unit];
    uint64_t sz;
    int ent_idx_min, ent_idx_max;
    bcmi_ltsw_profile_hdl_t profile_hdl;
    const bcmint_mpls_lt_t *lt_db;
    const bcmint_mpls_fld_t *flds;

    SHR_FUNC_ENTER(unit);

    if (info->inited) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_ltsw_mpls_detach(unit));
    }

    sal_memset(info, 0, sizeof(mpls_info_t));

    info->mutex = sal_mutex_create("bcmXgsMplsInfo");
    SHR_NULL_CHECK(info->mutex, SHR_E_MEMORY);

    /* Encap id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_MPLS_ENCAPs,
                                       TNL_MPLS_ENCAP_IDs, &idx_min, &idx_max));
    
    idx_max = 16383;
    sz = (idx_max + 1) * sizeof(uint16_t);
    SHR_ALLOC(info->encap_id, sz, "bcmXgsMplsEncapIdInfo");
    SHR_NULL_CHECK(info->encap_id, SHR_E_MEMORY);
    sal_memset(info->encap_id, 0, sz);

    /* DST_MAC profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_MPLS_DST_MACs,
                                       TNL_MPLS_DST_MAC_IDs, &idx_min, &idx_max));


    /* Register profile. */
    profile_hdl = BCMI_LTSW_PROFILE_MPLS_DST_MAC;
    if (bcmi_ltsw_profile_register_check(unit, profile_hdl)) {
        SHR_EXIT();
    }

    ent_idx_min = (int)idx_min;
    ent_idx_max = (int)idx_max;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_profile_register(unit, &profile_hdl,
                                    &ent_idx_min, &ent_idx_max, 1,
                                    mpls_tnl_dst_mac_profile_entry_hash_cb,
                                    mpls_tnl_dst_mac_profile_entry_cmp_cb));

    if (bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_tnl_dst_mac_profile_recover(unit));
    }

    if (ltsw_feature(unit, LTSW_FT_MPLS_FLEXCTR_ACTION_PROFILE)) {
        /* FLEX_ACTION profile. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_mpls_lt_get(unit, BCMINT_LTSW_MPLS_LT_EFLEX_ACTION, &lt_db));
        flds = lt_db->flds;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_value_range_get(unit, lt_db->name,
                                           flds[BCMINT_LTSW_MPLS_FLD_EFA_ID].name,
                                           &idx_min, &idx_max));

        /* Register profile. */
        profile_hdl = BCMI_LTSW_PROFILE_MPLS_FLEX_ACTION;
        if (bcmi_ltsw_profile_register_check(unit, profile_hdl)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_profile_unregister(unit, profile_hdl));
        }

        /* Reserve profile 0 for non-flex counter use. */
        ent_idx_min = (int)idx_min + 1;
        ent_idx_max = (int)idx_max;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_profile_register(unit, &profile_hdl,
                                        &ent_idx_min, &ent_idx_max, 1,
                                        mpls_label_flex_action_profile_entry_hash_cb,
                                        mpls_label_flex_action_profile_entry_cmp_cb));
    }

    if (bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_label_flex_action_profile_recover(unit));
    }

    /* Register callbacks for TNL_MPLS_ENCAP LT. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, TNL_MPLS_ENCAPs,
                                       TNL_MPLS_ENCAP_IDs,
                                       NULL, &idx_max));
    sal_memset(&lt_info, 0, sizeof(lt_info));
    lt_info.user_cnt  = BCMI_TNL_MPLS_ENCAP_USER_ID_CNT;
    lt_info.tbl_name  = TNL_MPLS_ENCAPs;
    lt_info.idx_field = TNL_MPLS_ENCAP_IDs;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = MPLS_TNL_IDX_MIN;
    user_info.idx_max     = (int)idx_max;
    user_info.func_hash   = lt_mpls_tnl_encap_hash;
    user_info.func_cmp    = lt_mpls_tnl_encap_cmp;
    user_info.func_insert = lt_mpls_tnl_encap_insert;
    user_info.func_del    = lt_mpls_tnl_encap_delete;

    tbl_id  = BCMI_LTSW_IDX_TBL_ID_TNL_MPLS_ENCAP;
    user_id = BCMI_TNL_MPLS_ENCAP_USER_ID_MPLS;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit, tbl_id, user_id,
                                    &lt_info, &user_info));
    tnl_mpls_encap_registered = 1;

    if (bcmi_warmboot_get(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_traverse(unit, TNL_MPLS_ENCAPs, NULL,
                                    mpls_recover_cb));
    }

    info->inited = 1;
exit:
    if (SHR_FUNC_ERR()) {
        if (tnl_mpls_encap_registered) {
            tbl_id  = BCMI_LTSW_IDX_TBL_ID_TNL_MPLS_ENCAP;
            user_id = BCMI_TNL_MPLS_ENCAP_USER_ID_MPLS;
            (void)bcmi_ltsw_idx_tbl_unregister(unit, tbl_id, user_id);

            profile_hdl = BCMI_LTSW_PROFILE_MPLS_DST_MAC;
            (void)bcmi_ltsw_profile_unregister(unit, profile_hdl);
            profile_hdl = BCMI_LTSW_PROFILE_MPLS_FLEX_ACTION;
            (void)bcmi_ltsw_profile_unregister(unit, profile_hdl);
        }
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_detach(int unit)
{
    bcmi_ltsw_idx_tbl_id_t tbl_id;
    uint8_t user_id;
    mpls_info_t *info = &mpls_info[unit];
    bcmi_ltsw_profile_hdl_t profile_hdl;

    SHR_FUNC_ENTER(unit);

    if (!info->inited || !info->mutex) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    sal_mutex_take(info->mutex, SAL_MUTEX_FOREVER);

    info->inited = 0;

    (void)mpls_tnl_dst_mac_profile_deinit(unit);

    (void)mpls_label_flex_action_profile_deinit(unit);

    tbl_id = BCMI_LTSW_IDX_TBL_ID_TNL_MPLS_ENCAP;
    user_id = BCMI_TNL_MPLS_ENCAP_USER_ID_MPLS;
    (void)bcmi_ltsw_idx_tbl_unregister(unit, tbl_id, user_id);

    profile_hdl = BCMI_LTSW_PROFILE_MPLS_DST_MAC;
    (void)bcmi_ltsw_profile_unregister(unit, profile_hdl);

    profile_hdl = BCMI_LTSW_PROFILE_MPLS_FLEX_ACTION;
    (void)bcmi_ltsw_profile_unregister(unit, profile_hdl);

    SHR_FREE(info->encap_id);
    sal_mutex_give(info->mutex);
    sal_mutex_destroy(info->mutex);

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_switch_add(
    int unit,
    bcm_mpls_tunnel_switch_t *info)
{
    int rv = SHR_E_NONE;
    int entry_exists = 0;
    lt_mpls_tnl_decap_entry_t entry;
    bcmlt_opcode_t opcode;
    bcm_module_t modid = BCM_MODID_INVALID;
    bcm_port_t port = BCM_PORT_INVALID;
    bcm_trunk_t trunk_id = BCM_TRUNK_INVALID;
    int id = -1;
    int action, action_if_bos, action_if_not_bos;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    sal_memset(&entry, 0, sizeof(lt_mpls_tnl_decap_entry_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_range_validate(unit, info->label, info->port));

    action = info->action;
    if (info->action_if_bos != info->action_if_not_bos) {
        action = BCM_MPLS_SWITCH_ACTION_INVALID;
        action_if_bos = info->action_if_bos;
        action_if_not_bos = info->action_if_not_bos;
    } else {
      /*
             * Same action specified in if_bos and if_not_bos.
             * If this action is of valid type, it will override
             * the action specified in info->action
             */
        if (info->action_if_bos != BCM_MPLS_SWITCH_ACTION_INVALID) {
            action = info->action_if_bos;
        }
        action_if_bos = action_if_not_bos = action;
    }

    if (!(BCM_MPLS_SWITCH_ACTION_SWAP == action_if_bos ||
          BCM_MPLS_SWITCH_ACTION_SWAP == action_if_not_bos ||
          BCM_MPLS_SWITCH_ACTION_POP == action_if_bos ||
          BCM_MPLS_SWITCH_ACTION_POP == action_if_not_bos ||
          BCM_MPLS_SWITCH_ACTION_PHP == action_if_bos ||
          BCM_MPLS_SWITCH_ACTION_PHP == action_if_not_bos)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if ((info->egress_label.flags & BCM_MPLS_EGRESS_LABEL_PRESERVE) &&
        (BCM_MPLS_SWITCH_ACTION_SWAP != action_if_bos ||
         BCM_MPLS_SWITCH_ACTION_SWAP != action_if_not_bos)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    info->action_if_bos = action_if_bos;
    info->action_if_not_bos = action_if_not_bos;

    entry.label = info->label;

    if (BCM_GPORT_IS_SET(info->port)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_resolve(unit, info->port,
                                          &modid,
                                          &port,
                                          &trunk_id,
                                          &id));

        if (trunk_id != BCM_TRUNK_INVALID) {
            entry.is_trunk = true;
            entry.source = trunk_id;
        } else {
            entry.is_trunk = false;
            entry.source = port;
        }
    } else if (info->port == BCM_GPORT_INVALID){
        entry.is_trunk = false;
        entry.source = 0;
    } else if (SHR_SUCCESS(bcmi_ltsw_port_gport_validate(unit, info->port, &info->port))) {
        entry.is_trunk = false;
        entry.source = info->port;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    rv = mpls_tnl_decap_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry);
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_NOT_FOUND);
    if (rv == SHR_E_NONE) {
        entry_exists = 1;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_switch_info_to_decap_entry(unit, info, &entry));

    opcode = entry_exists ? BCMLT_OPCODE_UPDATE : BCMLT_OPCODE_INSERT;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_decap_entry_op(unit, opcode, &entry));

    if (BCM_MPLS_SWITCH_ACTION_PHP == info->action_if_bos ||
        BCM_MPLS_SWITCH_ACTION_PHP == info->action_if_not_bos) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_php_action_add(unit,
                                                info->egress_if));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_switch_delete(
    int unit,
    bcm_mpls_tunnel_switch_t *info)
{
    lt_mpls_tnl_decap_entry_t entry;
    bcm_module_t modid = BCM_MODID_INVALID;
    bcm_port_t port = BCM_PORT_INVALID;
    bcm_trunk_t trunk_id = BCM_TRUNK_INVALID;
    int id = -1;
    bcm_if_t egress_if;

    SHR_FUNC_ENTER(unit);

    sal_memset(&entry, 0, sizeof(lt_mpls_tnl_decap_entry_t));

    entry.label = info->label;

    if (BCM_GPORT_IS_SET(info->port)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_resolve(unit, info->port,
                                          &modid,
                                          &port,
                                          &trunk_id,
                                          &id));

        if (trunk_id != BCM_TRUNK_INVALID) {
            entry.is_trunk = true;
            entry.source = trunk_id;
        } else {
            entry.is_trunk = false;
            entry.source = port;
        }
    } else if (info->port == BCM_GPORT_INVALID){
        entry.is_trunk = false;
        entry.source = 0;
    } else if (SHR_SUCCESS(bcmi_ltsw_port_gport_validate(unit, info->port, &info->port))) {
        entry.is_trunk = false;
        entry.source = info->port;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_decap_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_decap_entry_op(unit, BCMLT_OPCODE_DELETE, &entry));

    if ((bcmintLtswMplsTnlBosL3Nhi == entry.bos_actions) ||
        (bcmintLtswMplsTnlNonBosPhpNhi == entry.non_bos_actions)) {
        SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_egress_obj_id_construct(unit, (int)entry.nhop_id,
                                                      BCMI_LTSW_L3_EGR_OBJ_T_UL,
                                                      &egress_if));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_php_action_delete(unit, egress_if));
    }
    if ((bcmintLtswMplsTnlBosL3Ecmp == entry.bos_actions) ||
        (bcmintLtswMplsTnlNonBosPhpEcmp == entry.non_bos_actions)) {
        SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_ltsw_l3_egress_obj_id_construct(unit, (int)entry.ecmp_id,
                                                      BCMI_LTSW_L3_EGR_OBJ_T_ECMP_UL,
                                                      &egress_if));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_egress_php_action_delete(unit, egress_if));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_switch_get(
    int unit,
    bcm_mpls_tunnel_switch_t *info)
{
    lt_mpls_tnl_decap_entry_t entry;
    bcm_module_t modid = BCM_MODID_INVALID;
    bcm_port_t port = BCM_PORT_INVALID;
    bcm_trunk_t trunk_id = BCM_TRUNK_INVALID;
    int id = -1;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    sal_memset(&entry, 0, sizeof(lt_mpls_tnl_decap_entry_t));

    entry.label = info->label;

    if (BCM_GPORT_IS_SET(info->port)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_resolve(unit, info->port,
                                          &modid,
                                          &port,
                                          &trunk_id,
                                          &id));

        if (trunk_id != BCM_TRUNK_INVALID) {
            entry.is_trunk = true;
            entry.source = trunk_id;
        } else {
            entry.is_trunk = false;
            entry.source = port;
        }
    } else if (info->port == BCM_GPORT_INVALID){
        entry.is_trunk = false;
        entry.source = 0;
    } else if (SHR_SUCCESS(bcmi_ltsw_port_gport_validate(unit, info->port, &info->port))) {
        entry.is_trunk = false;
        entry.source = info->port;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_decap_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_switch_info_from_decap_entry(unit, info, &entry));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_switch_traverse(
    int unit,
    bcm_mpls_tunnel_switch_traverse_cb cb,
    void *user_data)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    int rv = SHR_E_NONE;
    lt_mpls_tnl_decap_entry_t entry;
    bcm_mpls_tunnel_switch_t info;
    const bcmint_mpls_lt_t *lt_db;
    bcmint_mpls_lt_id_t lt_id;

    SHR_FUNC_ENTER(unit);

    lt_id = BCMINT_LTSW_MPLS_LT_DECAP;

    SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_mpls_lt_get(unit, lt_id, &lt_db));

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_db->name, &ent_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, ent_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        sal_memset(&entry, 0, sizeof(lt_mpls_tnl_decap_entry_t));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_tnl_decap_entry_from_hdl(unit, &entry, ent_hdl, lt_db));

        sal_memset(&info, 0, sizeof(bcm_mpls_tunnel_switch_t));
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_tnl_switch_info_from_decap_entry(unit, &info, &entry));

        rv = cb(unit, &info, user_data);
        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }
    (void)bcmlt_entry_free(ent_hdl);
    ent_hdl = BCMLT_INVALID_HDL;

    lt_id = BCMINT_LTSW_MPLS_LT_DECAP_TRUNK;

    SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_mpls_lt_get(unit, lt_id, &lt_db));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_db->name, &ent_hdl));

    while ((rv = bcmi_lt_entry_commit(unit, ent_hdl,
                                      BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        sal_memset(&entry, 0, sizeof(lt_mpls_tnl_decap_entry_t));
        entry.is_trunk = true;
        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_tnl_decap_entry_from_hdl(unit, &entry, ent_hdl, lt_db));

        sal_memset(&info, 0, sizeof(bcm_mpls_tunnel_switch_t));
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_tnl_switch_info_from_decap_entry(unit, &info, &entry));

        rv = cb(unit, &info, user_data);
        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
        ent_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_switch_delete_all(int unit)
{
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    int rv = SHR_E_NONE;
    lt_mpls_tnl_decap_entry_t entry;
    const bcmint_mpls_lt_t *lt_db;
    bcmint_mpls_lt_id_t lt_id;

    SHR_FUNC_ENTER(unit);

    lt_id = BCMINT_LTSW_MPLS_LT_DECAP;

    SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_mpls_lt_get(unit, lt_id, &lt_db));

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_db->name, &ent_hdl));

    while ((rv = bcmi_lt_entry_commit(
                     unit, ent_hdl,
                     BCMLT_OPCODE_TRAVERSE,
                     BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        sal_memset(&entry, 0, sizeof(entry));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_tnl_decap_entry_from_hdl(unit, &entry, ent_hdl, lt_db));

        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_tnl_decap_entry_op(unit, BCMLT_OPCODE_DELETE, &entry));
    }
    (void)bcmlt_entry_free(ent_hdl);
    ent_hdl = BCMLT_INVALID_HDL;

    lt_id = BCMINT_LTSW_MPLS_LT_DECAP;

    SHR_IF_ERR_VERBOSE_EXIT
                (bcmint_mpls_lt_get(unit, lt_id, &lt_db));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_db->name, &ent_hdl));

    while ((rv = bcmi_lt_entry_commit(
                     unit, ent_hdl,
                     BCMLT_OPCODE_TRAVERSE,
                     BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        sal_memset(&entry, 0, sizeof(entry));

        SHR_IF_ERR_VERBOSE_EXIT
            (lt_mpls_tnl_decap_entry_from_hdl(unit, &entry, ent_hdl, lt_db));

        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_tnl_decap_entry_op(unit, BCMLT_OPCODE_DELETE, &entry));
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
        ent_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_initiator_clear(
    int unit,
    bcm_if_t intf)
{
    int tnl_idx;
    bcmi_ltsw_tunnel_type_t tnl_type = bcmiTunnelTypeInvalid;
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_TNL_MPLS_ENCAP;
    uint8_t user_id = BCMI_TNL_MPLS_ENCAP_USER_ID_MPLS;
    lt_mpls_tnl_encap_entry_t entry;
    int hw_idx;
    uint32_t ref_cnt = 0;
    bool locked = false;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    MPLS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_intf_tnl_init_get(unit, intf, &tnl_type, &hw_idx));

    if (tnl_type != bcmiTunnelTypeMpls) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    tnl_idx = MPLS_TNL_ENCAP_ID(unit, hw_idx);

    entry.tnl_encap_id = tnl_idx;
    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_encap_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_free(unit, 0, tbl_id, user_id, tnl_idx));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id, tnl_idx,
                                         &ref_cnt));

    if (!ref_cnt) {
        MPLS_TNL_ENCAP_ID(unit, hw_idx) = 0;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_intf_tnl_init_reset(unit, intf));

exit:
    if (locked) {
        MPLS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_initiator_clear_all(int unit)
{
    int tnl_idx;
    bcmi_ltsw_tunnel_type_t tnl_type = bcmiTunnelTypeInvalid;
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_TNL_MPLS_ENCAP;
    uint8_t user_id = BCMI_TNL_MPLS_ENCAP_USER_ID_MPLS;
    lt_mpls_tnl_encap_entry_t entry;
    int hw_idx;
    uint32_t ref_cnt = 0;
    bool locked = false;
    bcm_if_t intf;
    int min, max;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    MPLS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_egr_intf_id_range_get(unit, BCMI_LTSW_L3_EGR_INTF_T_UL,
                                            &min, &max));
    for (intf = min; intf <= max; intf++) {
         rv = bcmi_ltsw_l3_egr_intf_id_validate(unit, intf);
         if (SHR_FAILURE(rv)) {
             continue;
         }
         rv = bcmi_ltsw_l3_intf_tnl_init_get(unit, intf, &tnl_type, &hw_idx);
         if (SHR_FAILURE(rv)) {
            continue;
         }
         if (tnl_type != bcmiTunnelTypeMpls) {
            continue;
         }

        tnl_idx = MPLS_TNL_ENCAP_ID(unit, hw_idx);

        sal_memset(&entry, 0, sizeof(entry));

        entry.tnl_encap_id = tnl_idx;
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_tnl_encap_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_free(unit, 0, tbl_id, user_id, tnl_idx));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id, tnl_idx,
                                             &ref_cnt));

        if (!ref_cnt) {
            MPLS_TNL_ENCAP_ID(unit, hw_idx) = 0;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_l3_intf_tnl_init_reset(unit, intf));
    }


exit:
    if (locked) {
        MPLS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_initiator_get(
    int unit,
    bcm_if_t intf,
    int label_max,
    bcm_mpls_egress_label_t *label_array,
    int *label_count)
{
    int tnl_idx;
    lt_mpls_tnl_encap_entry_t tnl_entry;
    bcmi_ltsw_tunnel_type_t tnl_type = bcmiTunnelTypeInvalid;
    bool locked = false;
    int hw_idx;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    MPLS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_intf_tnl_init_get(unit, intf, &tnl_type, &hw_idx));

    if (tnl_type == bcmiTunnelTypeInvalid) {
        *label_count = 0;
        SHR_EXIT();
    }

    if (tnl_type != bcmiTunnelTypeMpls) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    tnl_idx = MPLS_TNL_ENCAP_ID(unit, hw_idx);
    sal_memset(&tnl_entry, 0, sizeof(tnl_entry));
    tnl_entry.tnl_encap_id = tnl_idx;
    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_encap_entry_op(unit, BCMLT_OPCODE_LOOKUP, &tnl_entry));

   SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_encap_from_lt_entry(unit, label_count, label_array, &tnl_entry));

exit:
    if (locked) {
        MPLS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_initiator_set(
    int unit,
    bcm_if_t intf,
    int num_labels,
    bcm_mpls_egress_label_t *label_array)
{
    uint32_t flags = 0;
    bcmi_ltsw_idx_tbl_id_t tbl_id = BCMI_LTSW_IDX_TBL_ID_TNL_MPLS_ENCAP;
    uint8_t user_id = BCMI_TNL_MPLS_ENCAP_USER_ID_MPLS;
    int tnl_idx, old_tnl_idx;
    bcmi_ltsw_tunnel_type_t tnl_type = bcmiTunnelTypeInvalid;
    bcmi_ltsw_tunnel_type_t old_tnl_type = bcmiTunnelTypeInvalid;
    lt_mpls_tnl_encap_entry_t entry;
    int hw_idx = 0, old_hw_idx = 0;
    bool locked = false;
    uint32_t ref_cnt;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    MPLS_LOCK(unit);
    locked = true;

    /*
     * num_labels == 0 means dummy tunnel entry.
     * In this case, VC label will be added without tunnel label added.
     * Without dummy tunnel entry, VC label could not be added.
     */
    if (num_labels < 0 || num_labels > MPLS_ENCAP_LABEL_CNT_MAX) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_intf_tnl_init_get(unit, intf, &old_tnl_type, &old_hw_idx));

    if ((old_tnl_type != bcmiTunnelTypeMpls) &&
        (old_tnl_type != bcmiTunnelTypeInvalid)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    sal_memset(&entry, 0, sizeof(entry));

    if (num_labels) {
        SHR_IF_ERR_VERBOSE_EXIT
            (mpls_tnl_encap_to_lt_entry(unit, num_labels, label_array, &entry));
    } else {
        entry.max_labels = 1;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_alloc(unit, flags, tbl_id, user_id,
                                       &entry, &tnl_idx));

    entry.tnl_encap_id = tnl_idx;
    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_encap_entry_op(unit, BCMLT_OPCODE_LOOKUP, &entry));

    hw_idx = entry.encap_index;
    tnl_type = bcmiTunnelTypeMpls;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_l3_intf_tnl_init_set(unit, intf, tnl_type, hw_idx));

    MPLS_TNL_ENCAP_ID(unit, hw_idx) = tnl_idx;

    if (old_tnl_type == bcmiTunnelTypeMpls) {
        old_tnl_idx = MPLS_TNL_ENCAP_ID(unit, old_hw_idx);
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_free(unit, 0, tbl_id, user_id, old_tnl_idx));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_get(unit, tbl_id, user_id, old_tnl_idx,
                                             &ref_cnt));

        if (!ref_cnt) {
            MPLS_TNL_ENCAP_ID(unit, old_hw_idx) = 0;
        }
    }


exit:
    if (locked) {
        MPLS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_global_label_range_set(
    int unit,
    int range_num,
    int range_min,
    int label_val)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (range_num < 0 || range_num > 2) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_GLOBAL_LABEL_RANGEs, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_field_add(ent_hdl,
                                TNL_MPLS_GLOBAL_LABEL_RANGE_IDs,
                                range_num));

    if (range_min) {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl, MIN_LABELs, label_val));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_add(ent_hdl, MAX_LABELs, label_val));
    }

    /* It always updates the LT as the LT is inserted during init. */
    SHR_ERR_EXIT
        (bcmi_lt_entry_set_commit(unit, ent_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
        ent_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_global_label_range_get(
    int unit,
    int range_num,
    int *min_label,
    int *max_label)
{
    int dunit;
    bcmlt_entry_handle_t ent_hdl = BCMLT_INVALID_HDL;
    uint64_t value = 0;
    int rv;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    if (range_num < 0 || range_num > 2) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, TNL_MPLS_GLOBAL_LABEL_RANGEs, &ent_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_field_add(ent_hdl,
                                TNL_MPLS_GLOBAL_LABEL_RANGE_IDs,
                                range_num));

    rv = bcmi_lt_entry_commit(unit, ent_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);

    if (rv == SHR_E_NOT_FOUND) {
        value = 0;
        if (min_label) {
            *min_label = (int)value;
        }
        if (max_label) {
            *max_label = (int)value;
        }
        SHR_EXIT();
    } else {
        SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_NOT_FOUND);
    }

    if (min_label) {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_get(ent_hdl, MIN_LABELs, &value));
        *min_label = (int)value;
    }

    if (max_label) {
        SHR_IF_ERR_VERBOSE_EXIT
             (bcmlt_entry_field_get(ent_hdl, MAX_LABELs, &value));
        *max_label = (int)value;
    }

exit:
    if (BCMLT_INVALID_HDL != ent_hdl) {
        (void)bcmlt_entry_free(ent_hdl);
        ent_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_dst_mac_profile_add(
    int unit,
    uint64_t mac,
    int *index)
{
    bool locked = false;
    bcmi_ltsw_mpls_tnl_dst_mac_profile_t mac_da_profile;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    MPLS_LOCK(unit);
    locked = true;

    mac_da_profile.mac_da = mac;
    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_dst_mac_profile_add(unit, &mac_da_profile, index));

exit:
    if (locked) {
        MPLS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_dst_mac_profile_del(
    int unit,
    int index)
{
    bool locked = false;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    MPLS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_dst_mac_profile_delete(unit, index));

exit:
    if (locked) {
        MPLS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_tnl_dst_mac_profile_get(
    int unit,
    int index,
    uint64_t *mac)
{
    bool locked = false;
    bcmi_ltsw_mpls_tnl_dst_mac_profile_t entry;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    MPLS_LOCK(unit);
    locked = true;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_tnl_dst_mac_profile_get(unit, index, &entry));

    *mac = entry.mac_da;

exit:
    if (locked) {
        MPLS_UNLOCK(unit);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_label_flexctr_attach(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t port,
    bcmi_ltsw_flexctr_counter_info_t *info)
{
    mpls_flexctr_cfg_t flexctr;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    sal_memset(&flexctr, 0, sizeof(mpls_flexctr_cfg_t));
    flexctr.op = MPLS_FLXCTR_OP_SET;
    flexctr.flags = MPLS_FLXCTR_F_ACTION;
    flexctr.action = info->action_index;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_flexctr_op(unit, label, port, &flexctr));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_label_flexctr_detach(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t port)
{
    mpls_flexctr_cfg_t flexctr;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    sal_memset(&flexctr, 0, sizeof(mpls_flexctr_cfg_t));
    flexctr.op = MPLS_FLXCTR_OP_SET;
    flexctr.flags = MPLS_FLXCTR_F_ACTION;
    flexctr.action = 0;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_flexctr_op(unit, label, port, &flexctr));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_label_flexctr_info_get(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t port,
    bcmi_ltsw_flexctr_counter_info_t *info)
{
    const char *ltname;
    mpls_flexctr_cfg_t flexctr;
    bool is_trunk;
    bcm_module_t modid = BCM_MODID_INVALID;
    bcm_port_t local_port = BCM_PORT_INVALID;
    bcm_trunk_t trunk_id = BCM_TRUNK_INVALID;
    int id = -1;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    if (BCM_GPORT_IS_SET(port)) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_resolve(unit, port,
                                          &modid,
                                          &local_port,
                                          &trunk_id,
                                          &id));

        if (trunk_id != BCM_TRUNK_INVALID) {
            is_trunk = true;
        } else {
            is_trunk = false;
        }
    } else if (port == BCM_GPORT_INVALID){
        is_trunk = false;
    } else if (SHR_SUCCESS(bcmi_ltsw_port_gport_validate(unit, port, &port))) {
        is_trunk = false;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    if (is_trunk) {
        ltname = TNL_MPLS_DECAP_TRUNKs;
    } else {
        ltname = TNL_MPLS_DECAPs;
    }

    sal_memset(&flexctr, 0, sizeof(mpls_flexctr_cfg_t));
    flexctr.op = MPLS_FLXCTR_OP_GET;
    flexctr.flags = MPLS_FLXCTR_F_ACTION;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_flexctr_op(unit, label, port, &flexctr));

    if (info->direction != BCMI_LTSW_FLEXCTR_DIR_INGRESS) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
    }

    info->source = bcmFlexctrSourceMplsLabel;
    info->stage = BCMI_LTSW_FLEXCTR_STAGE_ING_CTR;
    info->action_index = flexctr.action;
    info->table_name = ltname;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_label_flexctr_object_set(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t port,
    uint32_t value)
{
    mpls_flexctr_cfg_t flexctr;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    sal_memset(&flexctr, 0, sizeof(mpls_flexctr_cfg_t));
    flexctr.op = MPLS_FLXCTR_OP_SET;
    flexctr.flags = MPLS_FLXCTR_F_INDEX;
    flexctr.index = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_flexctr_op(unit, label, port, &flexctr));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_mpls_label_flexctr_object_get(
    int unit,
    bcm_mpls_label_t label,
    bcm_gport_t port,
    uint32_t *value)
{
    mpls_flexctr_cfg_t flexctr;

    SHR_FUNC_ENTER(unit);

    if (!MPLS_INITED(unit)) {
        SHR_IF_ERR_VERBOSE_EXIT(SHR_E_INIT);
    }

    sal_memset(&flexctr, 0, sizeof(mpls_flexctr_cfg_t));
    flexctr.op = MPLS_FLXCTR_OP_GET;
    flexctr.flags = MPLS_FLXCTR_F_INDEX;

    SHR_IF_ERR_VERBOSE_EXIT
        (mpls_label_flexctr_op(unit, label, port, &flexctr));

    *value = flexctr.index;

exit:
    SHR_FUNC_EXIT();
}

