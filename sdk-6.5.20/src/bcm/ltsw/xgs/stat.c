/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/stat.h>
#include <bcm_int/control.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/stat.h>
#include <bcm_int/ltsw/stat_int.h>

#include <bcm_int/ltsw/xgs/stat.h>
#include <bcm_int/ltsw/lt_intf.h>

#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_STAT

/*! Check whether the debug counter is valid. */
#define STAT_DBG_CTR_IS_VALID(unit, stat_id) \
            ((stat_id >= snmpBcmCustomReceive0 && \
              stat_id <= snmpBcmCustomReceive8) || \
             (stat_id >= snmpBcmCustomReceive9 && \
              stat_id <= snmpBcmCustomReceive15) || \
             (stat_id >= snmpBcmCustomTransmit0 && \
              stat_id <= snmpBcmCustomTransmit11))

/*! Check whether the debug counter is reserved. */
#define STAT_DBG_CTR_IS_RSV(unit, stat_id) \
            ((stat_id >= snmpBcmCustomReceive1 && \
              stat_id <= snmpBcmCustomReceive2) || \
             (stat_id >= snmpBcmCustomTransmit0 && \
              stat_id <= snmpBcmCustomTransmit5))

/*!
 * \brief Enum defines ingress debug counter IDs.
 */
typedef enum stat_dbg_ctr_select_rx_s {

    /*! Ingress debug counter select 0. */
    LTSW_STAT_RDBGC0 = 0,

    /*! Ingress debug counter select 1. */
    LTSW_STAT_RDBGC1 = 1,

    /*! Ingress debug counter select 2. */
    LTSW_STAT_RDBGC2 = 2,

    /*! Ingress debug counter select 3. */
    LTSW_STAT_RDBGC3 = 3,

    /*! Ingress debug counter select 4. */
    LTSW_STAT_RDBGC4 = 4,

    /*! Ingress debug counter select 5. */
    LTSW_STAT_RDBGC5 = 5,

    /*! Ingress debug counter select 6. */
    LTSW_STAT_RDBGC6 = 6,

    /*! Ingress debug counter select 7. */
    LTSW_STAT_RDBGC7 = 7,

    /*! Ingress debug counter select 8. */
    LTSW_STAT_RDBGC8 = 8,

    /*! Ingress debug counter select 9. */
    LTSW_STAT_RDBGC9 = 9,

    /*! Ingress debug counter select 10. */
    LTSW_STAT_RDBGC10 = 10,

    /*! Ingress debug counter select 11. */
    LTSW_STAT_RDBGC11 = 11,

    /*! Ingress debug counter select 12. */
    LTSW_STAT_RDBGC12 = 12,

    /*! Ingress debug counter select 13. */
    LTSW_STAT_RDBGC13 = 13,

    /*! Ingress debug counter select 14. */
    LTSW_STAT_RDBGC14 = 14,

    /*! Ingress debug counter select 15. */
    LTSW_STAT_RDBGC15 = 15

} stat_dbg_ctr_select_rx_t;

#define STAT_DBG_CTR_SELECT_RX_STR \
{ \
    "RDBGC0", \
    "RDBGC1", \
    "RDBGC2", \
    "RDBGC3", \
    "RDBGC4", \
    "RDBGC5", \
    "RDBGC6", \
    "RDBGC7", \
    "RDBGC8", \
    "RDBGC9", \
    "RDBGC10", \
    "RDBGC11", \
    "RDBGC12", \
    "RDBGC13", \
    "RDBGC14", \
    "RDBGC15" \
}

/*!
 * \brief Enum defines egress debug counter IDs.
 */
typedef enum stat_dbg_ctr_select_tx_s {

    /*! Egress debug counter select 0. */
    LTSW_STAT_TDBGC0 = 0,

    /*! Egress debug counter select 1. */
    LTSW_STAT_TDBGC1 = 1,

    /*! Egress debug counter select 2. */
    LTSW_STAT_TDBGC2 = 2,

    /*! Egress debug counter select 3. */
    LTSW_STAT_TDBGC3 = 3,

    /*! Egress debug counter select 4. */
    LTSW_STAT_TDBGC4 = 4,

    /*! Egress debug counter select 5. */
    LTSW_STAT_TDBGC5 = 5,

    /*! Egress debug counter select 6. */
    LTSW_STAT_TDBGC6 = 6,

    /*! Egress debug counter select 7. */
    LTSW_STAT_TDBGC7 = 7,

    /*! Egress debug counter select 8. */
    LTSW_STAT_TDBGC8 = 8,

    /*! Egress debug counter select 9. */
    LTSW_STAT_TDBGC9 = 9,

    /*! Egress debug counter select 10. */
    LTSW_STAT_TDBGC10 = 10,

    /*! Egress debug counter select 11. */
    LTSW_STAT_TDBGC11 = 11

} stat_dbg_ctr_select_tx_t;

#define STAT_DBG_CTR_SELECT_TX_STR \
{ \
    "TDBGC0", \
    "TDBGC1", \
    "TDBGC2", \
    "TDBGC3", \
    "TDBGC4", \
    "TDBGC5", \
    "TDBGC6", \
    "TDBGC7", \
    "TDBGC8", \
    "TDBGC9", \
    "TDBGC10", \
    "TDBGC11" \
}

/*!
 * \brief Ingress debug counter select structure.
 */
typedef struct stat_dbg_ctr_rx_s {

    /*! SNMP debug counter type for RX. */
    bcm_stat_val_t counter;

    /*! Logic table key field. */
    const char *key_name;

    /*! Ingress debug counter selection ID. */
    stat_dbg_ctr_select_rx_t select;

} stat_dbg_ctr_rx_t;

/*!
 * \brief Egress debug counter select structure.
 */
typedef struct stat_dbg_ctr_tx_s {

    /*! SNMP debug counter type for TX. */
    bcm_stat_val_t counter;

    /*! Logic table key field. */
    const char *key_name;

    /*! Egress debug counter selection ID. */
    stat_dbg_ctr_select_tx_t select;

} stat_dbg_ctr_tx_t;

/*!
 * \brief Stat ingress debug counter selection mapping table.
 */
static stat_dbg_ctr_rx_t xgs_ltsw_stat_dbg_sel_rx[] = {
    {snmpBcmCustomReceive0, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC0},
    {snmpBcmCustomReceive1, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC1},
    {snmpBcmCustomReceive2, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC2},
    {snmpBcmCustomReceive3, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC3},
    {snmpBcmCustomReceive4, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC4},
    {snmpBcmCustomReceive5, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC5},
    {snmpBcmCustomReceive6, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC6},
    {snmpBcmCustomReceive7, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC7},
    {snmpBcmCustomReceive8, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC8},
    {snmpBcmCustomReceive9, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC9},
    {snmpBcmCustomReceive10, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC10},
    {snmpBcmCustomReceive11, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC11},
    {snmpBcmCustomReceive12, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC12},
    {snmpBcmCustomReceive13, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC13},
    {snmpBcmCustomReceive14, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC14},
    {snmpBcmCustomReceive15, CTR_ING_DEBUG_SELECT_IDs, LTSW_STAT_RDBGC15}
};

/*!
 * \brief Stat egress debug counter selection mapping table.
 */
static stat_dbg_ctr_tx_t xgs_ltsw_stat_dbg_sel_tx[] = {
    {snmpBcmCustomTransmit0, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC0},
    {snmpBcmCustomTransmit1, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC1},
    {snmpBcmCustomTransmit2, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC2},
    {snmpBcmCustomTransmit3, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC3},
    {snmpBcmCustomTransmit4, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC4},
    {snmpBcmCustomTransmit5, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC5},
    {snmpBcmCustomTransmit6, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC6},
    {snmpBcmCustomTransmit7, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC7},
    {snmpBcmCustomTransmit8, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC8},
    {snmpBcmCustomTransmit9, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC9},
    {snmpBcmCustomTransmit10, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC10},
    {snmpBcmCustomTransmit11, CTR_EGR_DEBUG_SELECT_IDs, LTSW_STAT_TDBGC11}
};

/******************************************************************************
 * Private functions
 */


static bcmi_ltsw_stat_counter_control_t
    *ltsw_counter_control[BCM_MAX_NUM_UNITS];

static const bcmint_stat_dev_info_t *stat_dev_info[BCM_MAX_NUM_UNITS];

static int stat_ctr_index[BCM_MAX_NUM_UNITS][snmpValCount];
static int debug_ctr_index[BCM_MAX_NUM_UNITS][bcmDbgCntNum];

static int
xgs_stat_lt_debug_counter_clear(
    int unit,
    const char *table_name,
    const char *key_name,
    int select_id)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_opcode_t opcode_update = BCMLT_OPCODE_UPDATE;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_field_def_t *table_fields = NULL;
    uint32_t i;
    uint32_t num_fields;
    const char *field_name;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(table_name, SHR_E_PARAM);
    SHR_NULL_CHECK(key_name, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(dunit, table_name, 0, NULL, &num_fields));

    SHR_ALLOC(table_fields, sizeof(bcmlt_field_def_t) * num_fields,
              "ltswStatDefFields");
    SHR_NULL_CHECK(table_fields, SHR_E_MEMORY);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(dunit, table_name, num_fields,
                                    table_fields, &num_fields));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, table_name, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, key_name, select_id));

    for (i = 0; i < num_fields; i++) {
        if (table_fields[i].symbol || table_fields[i].key) {
            continue;
        }
        field_name = (char *)table_fields[i].name;
        /* Set field to 0 */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, field_name, 0));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, opcode_update, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FREE(table_fields);
    SHR_FUNC_EXIT();
}

static int
xgs_stat_counter_init(
    int unit,
    const char *table_name)
{
    int port;
    uint32_t port_type;
    bcm_pbmp_t pbmp;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t fields[] =
    {
        /* 0 */ {NULL, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    port_type = BCMI_LTSW_PORT_TYPE_PORT | BCMI_LTSW_PORT_TYPE_MGMT;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, port_type, &pbmp));
    if (BCM_PBMP_IS_NULL(pbmp)) {
        LOG_WARN(BSL_LOG_MODULE,
                 (BSL_META_U(unit,
                             "Port Bitmap is empty!\n")));
        SHR_EXIT();
    }

    fields[0].fld_name = PORT_IDs;
    lt_entry.fields = fields;
    lt_entry.nfields = sizeof(fields) / sizeof(fields[0]);
    lt_entry.attr = 0;

    BCM_PBMP_ITER(pbmp, port) {
        fields[0].u.val = port;
        SHR_IF_ERR_EXIT
            (bcmi_lt_entry_insert(unit, table_name, &lt_entry, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
xgs_stat_debug_counter_set(
    int unit,
    const char *table_name,
    const char *key_name,
    int select_id,
    const char *field_name,
    int value)
{
    int rv;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(table_name, SHR_E_PARAM);
    SHR_NULL_CHECK(key_name, SHR_E_PARAM);
    SHR_NULL_CHECK(field_name, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, table_name, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, key_name, select_id));

    /* Force to insert entry. */
    rv = bcmlt_entry_commit(entry_hdl,
                            BCMLT_OPCODE_INSERT,
                            BCMLT_PRIORITY_NORMAL);
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_EXISTS);

    /* Set the update data. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, field_name, (value) ? 1 : 0));

    /* Update the entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_stat_debug_counter_get(
    int unit,
    const char *table_name,
    const char *key_name,
    int select_id,
    const char *field_name,
    int *value)
{
    int rv;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    uint64_t result;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(table_name, SHR_E_PARAM);
    SHR_NULL_CHECK(key_name, SHR_E_PARAM);
    SHR_NULL_CHECK(field_name, SHR_E_PARAM);
    SHR_NULL_CHECK(value, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, table_name, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, key_name, select_id));

    rv = bcmlt_entry_commit(entry_hdl,
                            BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL);
    SHR_IF_ERR_EXIT_EXCEPT_IF(rv, SHR_E_NOT_FOUND);

    if (rv == SHR_E_NOT_FOUND) {
        *value = 0;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, field_name, &result));
        *value = (result) ? 1 : 0;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

static int
xgs_stat_debug_counter_clear(
    int unit,
    bcm_stat_val_t stat_id)
{
    int i;
    int select_id = -1;
    const char *table_name = NULL;
    const char *key_name = NULL;

    SHR_FUNC_ENTER(unit);

    /* Parameter check for stat_id. */
    if (!STAT_DBG_CTR_IS_VALID(unit, stat_id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (STAT_DBG_CTR_IS_RSV(unit, stat_id)) {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    /* Check if SNMP debug counter type is supported or not. */
    if (stat_ctr_index[unit][stat_id] < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Check to get the debug counter select ID for RX. */
    for (i = 0; i < COUNTOF(xgs_ltsw_stat_dbg_sel_rx); i++) {
        if (xgs_ltsw_stat_dbg_sel_rx[i].counter == stat_id) {
            key_name = xgs_ltsw_stat_dbg_sel_rx[i].key_name;
            select_id = xgs_ltsw_stat_dbg_sel_rx[i].select;
            table_name = CTR_ING_DEBUG_SELECTs;
            break;
        }
    }

    /*
     * Check to get the debug counter select ID for TX
     * (if not found in RX debug counter select).
     */
    if (select_id == -1) {
        for (i = 0; i < COUNTOF(xgs_ltsw_stat_dbg_sel_tx); i++) {
            if (xgs_ltsw_stat_dbg_sel_tx[i].counter == stat_id) {
                key_name = xgs_ltsw_stat_dbg_sel_tx[i].key_name;
                select_id = xgs_ltsw_stat_dbg_sel_tx[i].select;
                table_name = CTR_EGR_DEBUG_SELECTs;
                break;
            }
        }
    }

    /* Clear ingress/egress debug counter select LT entry fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_lt_debug_counter_clear(unit, table_name,
                                         key_name, select_id));

exit:
    SHR_FUNC_EXIT();
}

static int
xgs_stat_debug_counter_get_set(
    int unit,
    bcm_stat_val_t stat_id,
    bcm_custom_stat_trigger_t trigger,
    bcmint_stat_oper_t stat_op,
    int *value)
{
    int i, select_id = -1;
    const bcmint_stat_map_info_t *dbg_ctr_table;
    const char *key_name = NULL;
    const char *table_name = NULL;
    const char *field_name = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(value, SHR_E_PARAM);

    /* Parameter check for stat_id. */
    if (!STAT_DBG_CTR_IS_VALID(unit, stat_id)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    /* Check if SNMP debug counter type is supported or not. */
    if (stat_ctr_index[unit][stat_id] < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Parameter check for trigger. */
    if (trigger < 0 || trigger >= bcmDbgCntNum) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if (debug_ctr_index[unit][trigger] < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    /* Check to get the debug counter select ID for RX. */
    for (i = 0; i < COUNTOF(xgs_ltsw_stat_dbg_sel_rx); i++) {
        if (xgs_ltsw_stat_dbg_sel_rx[i].counter == stat_id) {
            key_name = xgs_ltsw_stat_dbg_sel_rx[i].key_name;
            select_id = xgs_ltsw_stat_dbg_sel_rx[i].select;
            break;
        }
    }

    /*
     * Check to get the debug counter select ID for TX
     * (if not found in RX debug counter select).
     */
    if (select_id == -1) {
        for (i = 0; i < COUNTOF(xgs_ltsw_stat_dbg_sel_tx); i++) {
            if (xgs_ltsw_stat_dbg_sel_tx[i].counter == stat_id) {
                key_name = xgs_ltsw_stat_dbg_sel_tx[i].key_name;
                select_id = xgs_ltsw_stat_dbg_sel_tx[i].select;
                break;
            }
        }
    }

    /* Get RX or TX debug counter select LT table and field. */
    dbg_ctr_table = stat_dev_info[unit]->dbg_ctr_table_info;
    table_name = dbg_ctr_table[debug_ctr_index[unit][trigger]].table;
    field_name = dbg_ctr_table[debug_ctr_index[unit][trigger]].field;

    if (stat_op == LTSW_STAT_SET) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_stat_debug_counter_set(unit, table_name, key_name, select_id,
                                        field_name, *value));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (xgs_stat_debug_counter_get(unit, table_name, key_name, select_id,
                                        field_name, value));
    }

exit:
    SHR_FUNC_EXIT();
}

static int
xgs_stat_debug_counter_rsv_init(int unit)
{
    int value = 1;
    SHR_FUNC_ENTER(unit);

    /* Setup for all Rx dropped packets. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomReceive0,
                                        bcmDbgCntRPORTD, LTSW_STAT_SET,
                                        &value));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomReceive0,
                                        bcmDbgCntRIPD4, LTSW_STAT_SET,
                                        &value));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomReceive0,
                                        bcmDbgCntRIPD6, LTSW_STAT_SET,
                                        &value));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomReceive0,
                                        bcmDbgCntPDISC, LTSW_STAT_SET,
                                        &value));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomReceive0,
                                        bcmDbgCntRDROP, LTSW_STAT_SET,
                                        &value));

    /* Setup counter for Bridged multicast packets. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomReceive1,
                                        bcmDbgCntIMBP, LTSW_STAT_SET,
                                        &value));

    /* Setup counter for Multicast (L2+L3) packets that are dropped. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomReceive2,
                                        bcmDbgCntRIMDR, LTSW_STAT_SET,
                                        &value));

    /* Setup counter for Good IPv6 L3 UC & IPMC packets. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomTransmit0,
                                        bcmDbgCntTGIPMC6, LTSW_STAT_SET,
                                        &value));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomTransmit0,
                                        bcmDbgCntTGIP6, LTSW_STAT_SET,
                                        &value));

    /* Setup counter for IPv6 L3 UC and IPMC Aged and Drop Packets. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomTransmit1,
                                        bcmDbgCntTIPMCD6, LTSW_STAT_SET,
                                        &value));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomTransmit1,
                                        bcmDbgCntTIPD6, LTSW_STAT_SET,
                                        &value));

    /* Setup counter for Good IPv6 IPMC packets. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomTransmit2,
                                        bcmDbgCntTGIPMC6, LTSW_STAT_SET,
                                        &value));

    /* Setup counter for Dropped packets. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomTransmit3,
                                        bcmDbgCntTPKTD, LTSW_STAT_SET,
                                        &value));

    /* Setup counter for Good IPv4 & IPv6 L3 UC packets. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomTransmit4,
                                        bcmDbgCntTGIP4, LTSW_STAT_SET,
                                        &value));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomTransmit4,
                                        bcmDbgCntTGIP6, LTSW_STAT_SET,
                                        &value));

    /* Setup counter for IPMC drops. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomTransmit5,
                                        bcmDbgCntTIPMCD4, LTSW_STAT_SET,
                                        &value));
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, snmpBcmCustomTransmit5,
                                        bcmDbgCntTIPMCD6, LTSW_STAT_SET,
                                        &value));

exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_stat_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Insert CTR_L3 LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_counter_init(unit, CTR_L3s));

    /* Insert CTR_ECN LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_counter_init(unit, CTR_ECNs));

    /* Insert CTR_ING_DEBUG LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_counter_init(unit, CTR_ING_DEBUGs));

    /* Insert CTR_EGR_DEBUG LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_counter_init(unit, CTR_EGR_DEBUGs));

    /*  Add a certain packet type to reserved debug counter to count. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_rsv_init(unit));

    /* Insert CTR_MIRROR_ING_PORT_SFLOW LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_counter_init(unit, CTR_MIRROR_ING_PORT_SFLOWs));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_detach(int unit)
{
    bcmi_ltsw_stat_counter_control_t *ltsw_ctr_ctrl = NULL;

    SHR_FUNC_ENTER(unit);

    ltsw_ctr_ctrl = ltsw_counter_control[unit];
    if (ltsw_ctr_ctrl != NULL) {
        if (ltsw_ctr_ctrl->counter_non_dma != NULL) {
            SHR_FREE(ltsw_ctr_ctrl->counter_non_dma);
        }
        SHR_FREE(ltsw_ctr_ctrl);
        ltsw_counter_control[unit] = NULL;
    }

    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_index_init(
    int unit,
    const bcmint_stat_dev_info_t *dev_info)
{
    int index;
    bcm_stat_val_t stat_id;
    bcm_custom_stat_trigger_t trigger_type;

    if (dev_info->stat_ctr_table_info != NULL) {
        memset(stat_ctr_index[unit], -1, sizeof(stat_ctr_index[unit]));

        index = 0;
        while (index < dev_info->num_stat_ctr) {
            stat_id = dev_info->stat_ctr_table_info[index].type;
            if (stat_ctr_index[unit][stat_id] == -1) {
                stat_ctr_index[unit][stat_id] = index;
            }
            index++;
        }
    }

    if (dev_info->dbg_ctr_table_info != NULL) {
        memset(debug_ctr_index[unit], -1, sizeof(debug_ctr_index[unit]));

        index = 0;
        while (index < dev_info->num_dbg_ctr) {
            trigger_type = dev_info->dbg_ctr_table_info[index].type;
            debug_ctr_index[unit][trigger_type] = index;
            index++;
        }
    }

    stat_dev_info[unit] = dev_info;

    return SHR_E_NONE;
}

int
xgs_ltsw_stat_lt_detach(int unit)
{
    SHR_FUNC_ENTER(unit);

    /* Remove CTR_L3 LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, CTR_L3s));

    /* Remove CTR_ECN LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, CTR_ECNs));

    /* Remove CTR_ING_DEBUG LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, CTR_ING_DEBUGs));

    /* Remove CTR_EGR_DEBUG LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, CTR_EGR_DEBUGs));

    /* Remove CTR_ING_DEBUG_SELECT LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, CTR_ING_DEBUG_SELECTs));

    /* Remove CTR_EGR_DEBUG_SELECT LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, CTR_EGR_DEBUG_SELECTs));

    /* Remove CTR_MIRROR_ING_PORT_SFLOW LT entries */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_clear(unit, CTR_MIRROR_ING_PORT_SFLOWs));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_port_attach(
    int unit,
    bcm_port_t port)
{
    SHR_FUNC_ENTER(unit);

    /* Insert CTR_L3 LT entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_insert(unit, CTR_L3s, port));

    /* Insert CTR_ECN LT entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_insert(unit, CTR_ECNs, port));

    /* Insert CTR_ING_DEBUG LT entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_insert(unit, CTR_ING_DEBUGs, port));

    /* Insert CTR_EGR_DEBUG LT entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_insert(unit, CTR_EGR_DEBUGs, port));

    /* Insert CTR_MIRROR_ING_PORT_SFLOW LT entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_insert(unit, CTR_MIRROR_ING_PORT_SFLOWs,
                                       port));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_port_detach(
    int unit,
    bcm_port_t port)
{
    SHR_FUNC_ENTER(unit);

    /* Delete CTR_L3 LT entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_delete(unit, CTR_L3s, port));

    /* Delete CTR_ECN LT entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_delete(unit, CTR_ECNs, port));

    /* Delete CTR_ING_DEBUG LT entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_delete(unit, CTR_ING_DEBUGs, port));

    /* Delete CTR_EGR_DEBUG LT entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_delete(unit, CTR_EGR_DEBUGs, port));

    /* Delete CTR_MIRROR_ING_PORT_SFLOW LT entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_delete(unit, CTR_MIRROR_ING_PORT_SFLOWs,
                                       port));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_clear(
    int unit,
    bcm_port_t port)
{
    SHR_FUNC_ENTER(unit);

    /* Clear CTR_L3 LT entry fields */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_clear(unit, CTR_L3s, port));

    /* Clear CTR_ECN LT entry fields */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_clear(unit, CTR_ECNs, port));

    /* Clear CTR_ING_DEBUG LT entry fields */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_clear(unit, CTR_ING_DEBUGs, port));
    /* Clear CTR_EGR_DEBUG LT entry fields */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_clear(unit, CTR_EGR_DEBUGs, port));

    /* Clear CTR_MIRROR_ING_PORT_SFLOW LT entry fields */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_stat_lt_counter_clear(unit, CTR_MIRROR_ING_PORT_SFLOWs,
                                      port));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_clear_single(
    int unit,
    bcm_port_t port,
    bcm_stat_val_t stat_id)
{
    int index;
    const bcmint_stat_ctr_map_info_t *stat_ctr_table;
    const char *table_name;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t fields[] = {
        {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        {NULL, BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    if (stat_id < 0 || stat_id >= snmpValCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (stat_ctr_index[unit][stat_id] < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    fields[0].u.val = port;
    lt_entry.fields = fields;
    lt_entry.nfields = COUNTOF(fields);
    lt_entry.attr = 0;

    stat_ctr_table = stat_dev_info[unit]->stat_ctr_table_info;

    for (index = stat_ctr_index[unit][stat_id];
         index < stat_dev_info[unit]->num_stat_ctr; index++) {
        if (stat_ctr_table[index].type != stat_id) {
            break;
        }
        table_name = stat_ctr_table[index].table_name;
        fields[1].fld_name = stat_ctr_table[index].field_name;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_update(unit, table_name, &lt_entry, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_get(
    int unit,
    bcm_port_t port,
    bool sync_mode,
    bcm_stat_val_t stat_id,
    uint64_t *val)
{
    uint64_t val64;
    int index;
    const bcmint_stat_ctr_map_info_t *stat_ctr_table;
    const char *table_name;
    const char *field_name;
    uint32_t entry_attr = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(val, SHR_E_PARAM);

    if (stat_id < 0 || stat_id >= snmpValCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (stat_ctr_index[unit][stat_id] < 0) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    stat_ctr_table = stat_dev_info[unit]->stat_ctr_table_info;

    *val = 0;
    for (index = stat_ctr_index[unit][stat_id];
         index < stat_dev_info[unit]->num_stat_ctr; index++) {
        if (stat_ctr_table[index].type != stat_id) {
            break;
        }

        table_name = stat_ctr_table[index].table_name;
        field_name = stat_ctr_table[index].field_name;
        entry_attr = sync_mode ? BCMLT_ENT_ATTR_GET_FROM_HW : 0;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmint_stat_lt_counter_get(unit, table_name, field_name, port,
                                        entry_attr, &val64));

        if (stat_ctr_table[index].minus) {
            *val -= val64;
        } else {
            *val += val64;
        }
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_counter_control_init(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmi_ltsw_stat_counter_control_t *ltsw_ctr_ctrl = NULL;
    int num_ports = 0;
    uint32_t num_fields;
    uint32_t total_entries;

    SHR_FUNC_ENTER(unit);

    ltsw_ctr_ctrl = ltsw_counter_control[unit];
    if (ltsw_ctr_ctrl != NULL) {
        if (ltsw_ctr_ctrl->counter_non_dma != NULL) {
            SHR_FREE(ltsw_ctr_ctrl->counter_non_dma);
        }
        SHR_FREE(ltsw_ctr_ctrl);
        ltsw_counter_control[unit] = NULL;
    }

    /* Alloc memory for counter control structure. */
    SHR_ALLOC(ltsw_ctr_ctrl, sizeof(bcmi_ltsw_stat_counter_control_t),
              "bcmLtswStatDefFields");
    SHR_NULL_CHECK(ltsw_ctr_ctrl, SHR_E_MEMORY);
    sal_memset(ltsw_ctr_ctrl, 0, sizeof(bcmi_ltsw_stat_counter_control_t));
    ltsw_counter_control[unit] = ltsw_ctr_ctrl;

    /* Get the number of physical ports. */
    num_ports = bcmi_ltsw_dev_phys_port_num(unit);

    /* Counter CPU port. */
    num_ports++;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(dunit, CTR_MACs, 0, NULL, &num_fields));
    ltsw_ctr_ctrl->entries_perport0 = num_fields;
    total_entries = num_fields * num_ports;

    ltsw_ctr_ctrl->base_index1 = total_entries;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(dunit, CTR_MAC_ERRs, 0, NULL,
                                    &num_fields));
    ltsw_ctr_ctrl->entries_perport1 = num_fields;
    total_entries += num_fields * num_ports;

    /*
     * Alloc memory for non-dma counter structure
     * (Currently, there is no non-dma case for XGS).
     */

    /* L3 counters. */
    ltsw_ctr_ctrl->l3_base_index = total_entries;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(dunit, CTR_L3s, 0, NULL, &num_fields));
    ltsw_ctr_ctrl->l3_entries_perport = num_fields;
    total_entries += num_fields * num_ports;

    /* ECN counters. */
    ltsw_ctr_ctrl->ecn_base_index = total_entries;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(dunit, CTR_ECNs, 0, NULL, &num_fields));
    ltsw_ctr_ctrl->ecn_entries_perport = num_fields;
    total_entries += num_fields * num_ports;

    /* Ingress debug counters. */
    ltsw_ctr_ctrl->rx_dbg_base_index = total_entries;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(dunit, CTR_ING_DEBUGs, 0, NULL,
                                    &num_fields));
    ltsw_ctr_ctrl->rx_dbg_entries_perport = num_fields;
    total_entries += num_fields * num_ports;

    /* Egress debug counters. */
    ltsw_ctr_ctrl->tx_dbg_base_index = total_entries;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(dunit, CTR_EGR_DEBUGs, 0, NULL,
                                    &num_fields));
    ltsw_ctr_ctrl->tx_dbg_entries_perport = num_fields;
    total_entries += num_fields * num_ports;

    /* Mirror SFLOW counters. */
    ltsw_ctr_ctrl->sflow_base_index = total_entries;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(dunit, CTR_MIRROR_ING_PORT_SFLOWs, 0, NULL,
                                    &num_fields));
    ltsw_ctr_ctrl->sflow_entries_perport = num_fields;
    total_entries += num_fields * num_ports;

    ltsw_ctr_ctrl->total_counters = total_entries;

exit:
    if (SHR_FUNC_ERR()) {
        if (ltsw_ctr_ctrl != NULL) {
            if (ltsw_ctr_ctrl->counter_non_dma != NULL) {
                SHR_FREE(ltsw_ctr_ctrl->counter_non_dma);
            }
            SHR_FREE(ltsw_ctr_ctrl);
            ltsw_counter_control[unit] = NULL;
        }
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_counter_control_get(
    int unit,
    bcmi_ltsw_stat_counter_control_t *info)
{
    bcmi_ltsw_stat_counter_control_t
        *ltsw_ctr_ctrl = ltsw_counter_control[unit];

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(info, SHR_E_PARAM);
    SHR_NULL_CHECK(ltsw_ctr_ctrl, SHR_E_INIT);

    sal_memset(info, 0, sizeof(*info));
    sal_memcpy(info, ltsw_ctr_ctrl, sizeof(*info));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_custom_add(
    int unit,
    bcm_port_t port,
    bcm_stat_val_t stat_id,
    bcm_custom_stat_trigger_t trigger)
{
    int value;

    SHR_FUNC_ENTER(unit);

    if (STAT_DBG_CTR_IS_RSV(unit, stat_id)) {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &port));

    value = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, stat_id, trigger,
                                        LTSW_STAT_SET, &value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_custom_check(
    int unit,
    bcm_port_t port,
    bcm_stat_val_t stat_id,
    bcm_custom_stat_trigger_t trigger,
    int *result)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(result, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &port));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, stat_id, trigger,
                                        LTSW_STAT_GET, result));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_custom_delete(
    int unit,
    bcm_port_t port,
    bcm_stat_val_t stat_id,
    bcm_custom_stat_trigger_t trigger)
{
    int value;

    SHR_FUNC_ENTER(unit);

    if (STAT_DBG_CTR_IS_RSV(unit, stat_id)) {
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &port));

    value = 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_get_set(unit, stat_id, trigger,
                                        LTSW_STAT_SET, &value));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_stat_custom_delete_all(
    int unit,
    bcm_port_t port,
    bcm_stat_val_t stat_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_gport_validate(unit, port, &port));

    SHR_IF_ERR_VERBOSE_EXIT
        (xgs_stat_debug_counter_clear(unit, stat_id));

exit:
    SHR_FUNC_EXIT();
}

